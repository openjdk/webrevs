{"files":[{"patch":"@@ -128,1 +128,2 @@\n-if [ -d \"$TOPLEVEL_DIR\/.git\" ] ; then\n+# Git worktrees use a '.git' file rather than directory, so test both.\n+if [ -d \"$TOPLEVEL_DIR\/.git\" -o -f \"$TOPLEVEL_DIR\/.git\" ] ; then\n","filename":"bin\/idea.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1454,4 +1454,4 @@\n-<pre><code>bash configure --with-devkit=&lt;devkit-path&gt; --openjdk-target=ppc64-linux-gnu &amp;&amp; make<\/code><\/pre>\n-<p>will configure and build the JDK for Linux\/ppc64 assuming that\n-<code>&lt;devkit-path&gt;<\/code> points to a Linux\/x86_64 to Linux\/ppc64\n-devkit.<\/p>\n+<pre><code>bash configure --with-devkit=&lt;devkit-path&gt; --openjdk-target=ppc64le-linux-gnu &amp;&amp; make<\/code><\/pre>\n+<p>will configure and build the JDK for Linux\/ppc64le assuming that\n+<code>&lt;devkit-path&gt;<\/code> points to a Linux\/x86_64 to\n+Linux\/ppc64le devkit.<\/p>\n@@ -1484,1 +1484,1 @@\n-<td>ppc64-linux-gnu<\/td>\n+<td>ppc64le-linux-gnu<\/td>\n@@ -1487,1 +1487,1 @@\n-<td>ppc64le-linux-gnu<\/td>\n+<td>riscv64-linux-gnu<\/td>\n","filename":"doc\/building.html","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1261,1 +1261,1 @@\n-bash configure --with-devkit=<devkit-path> --openjdk-target=ppc64-linux-gnu && make\n+bash configure --with-devkit=<devkit-path> --openjdk-target=ppc64le-linux-gnu && make\n@@ -1264,2 +1264,2 @@\n-will configure and build the JDK for Linux\/ppc64 assuming that `<devkit-path>`\n-points to a Linux\/x86_64 to Linux\/ppc64 devkit.\n+will configure and build the JDK for Linux\/ppc64le assuming that `<devkit-path>`\n+points to a Linux\/x86_64 to Linux\/ppc64le devkit.\n@@ -1284,1 +1284,0 @@\n-| ppc64-linux-gnu          |\n@@ -1286,0 +1285,1 @@\n+| riscv64-linux-gnu        |\n","filename":"doc\/building.md","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -14,3 +14,1 @@\n-    \/* The extra [class] is a hack that increases specificity enough to\n-       override a similar rule in reveal.js *\/\n-    ul.task-list[class]{list-style: none;}\n+    ul.task-list{list-style: none;}\n@@ -18,1 +16,0 @@\n-      font-size: inherit;\n","filename":"doc\/starting-next-release.html","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-<\/ul><\/li>\n@@ -77,3 +76,2 @@\n-id=\"toc-testing-ahead-of-time-optimizations\">### Testing Ahead-of-time\n-Optimizations<\/a>\n-<ul>\n+id=\"toc-testing-ahead-of-time-optimizations\">Testing Ahead-of-time\n+Optimizations<\/a><\/li>\n@@ -438,0 +436,3 @@\n+<h4 id=\"aot_jdk\">AOT_JDK<\/h4>\n+<p>See <a href=\"#testing-ahead-of-time-optimizations\">Testing\n+Ahead-of-time optimizations<\/a>.<\/p>\n@@ -460,0 +461,6 @@\n+<h4 id=\"jvmti_stress_agent\">JVMTI_STRESS_AGENT<\/h4>\n+<p>Executes JTReg tests with JVM TI stress agent. The stress agent is\n+the part of test library and located in\n+<code>test\/lib\/jdk\/test\/lib\/jvmti\/libJvmtiStressAgent.cpp<\/code>. The\n+value of this argument is set as JVM TI agent options. This mode uses\n+ProblemList-jvmti-stress-agent.txt as an additional exclude list.<\/p>\n@@ -559,0 +566,6 @@\n+<h4 id=\"test_jdk\">TEST_JDK<\/h4>\n+<p>The path to the JDK that will be used to run the benchmarks.<\/p>\n+<p>Defaults to <code>build\/&lt;CONF-NAME&gt;\/jdk<\/code>.<\/p>\n+<h4 id=\"benchmarks_jar\">BENCHMARKS_JAR<\/h4>\n+<p>The path to the JAR containing the benchmarks.<\/p>\n+<p>Defaults to <code>test\/micro\/benchmarks.jar<\/code>.<\/p>\n@@ -604,2 +617,2 @@\n-<h2 id=\"testing-ahead-of-time-optimizations\">### Testing Ahead-of-time\n-Optimizations<\/h2>\n+<h3 id=\"testing-ahead-of-time-optimizations\">Testing Ahead-of-time\n+Optimizations<\/h3>\n","filename":"doc\/testing.html","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -370,0 +370,4 @@\n+#### AOT_JDK\n+\n+See [Testing Ahead-of-time optimizations](#testing-ahead-of-time-optimizations).\n+\n@@ -400,0 +404,7 @@\n+#### JVMTI_STRESS_AGENT\n+\n+Executes JTReg tests with JVM TI stress agent. The stress agent is the part of\n+test library and located in `test\/lib\/jdk\/test\/lib\/jvmti\/libJvmtiStressAgent.cpp`.\n+The value of this argument is set as JVM TI agent options.\n+This mode uses ProblemList-jvmti-stress-agent.txt as an additional exclude list.\n+\n@@ -548,0 +559,12 @@\n+#### TEST_JDK\n+\n+The path to the JDK that will be used to run the benchmarks.\n+\n+Defaults to `build\/<CONF-NAME>\/jdk`.\n+\n+#### BENCHMARKS_JAR\n+\n+The path to the JAR containing the benchmarks.\n+\n+Defaults to `test\/micro\/benchmarks.jar`.\n+\n@@ -615,1 +638,1 @@\n--------------------------------------------------------------------------------\n+\n","filename":"doc\/testing.md","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -207,2 +207,3 @@\n-        TEST_MODE ASSERT VERBOSE RETAIN TEST_THREAD_FACTORY MAX_MEM RUN_PROBLEM_LISTS \\\n-        RETRY_COUNT REPEAT_COUNT MAX_OUTPUT REPORT AOT_JDK $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n+        TEST_MODE ASSERT VERBOSE RETAIN TEST_THREAD_FACTORY JVMTI_STRESS_AGENT \\\n+        MAX_MEM RUN_PROBLEM_LISTS RETRY_COUNT REPEAT_COUNT MAX_OUTPUT REPORT \\\n+        AOT_JDK $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n@@ -879,0 +880,9 @@\n+  ifneq ($$(JTREG_JVMTI_STRESS_AGENT), )\n+    AGENT := $$(LIBRARY_PREFIX)JvmtiStressAgent$$(SHARED_LIBRARY_SUFFIX)=$$(JTREG_JVMTI_STRESS_AGENT)\n+    $1_JTREG_BASIC_OPTIONS += -javaoption:'-agentpath:$(TEST_IMAGE_DIR)\/hotspot\/jtreg\/native\/$$(AGENT)'\n+    $1_JTREG_BASIC_OPTIONS += $$(addprefix $$(JTREG_PROBLEM_LIST_PREFIX), $$(wildcard \\\n+\t    $$(addprefix $$($1_TEST_ROOT)\/, ProblemList-jvmti-stress-agent.txt) \\\n+        ))\n+  endif\n+\n+\n","filename":"make\/RunTests.gmk","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -179,0 +179,16 @@\n+\n+# These settings are needed to run testing with jvmti agent\n+ifeq ($(OPENJDK_BUILD_OS), linux)\n+  LIBRARY_PREFIX := lib\n+  SHARED_LIBRARY_SUFFIX := .so\n+endif\n+\n+ifeq ($(OPENJDK_BUILD_OS), windows)\n+  LIBRARY_PREFIX :=\n+  SHARED_LIBRARY_SUFFIX := .dll\n+endif\n+\n+ifeq ($(OPENJDK_BUILD_OS), macosx)\n+  LIBRARY_PREFIX := lib\n+  SHARED_LIBRARY_SUFFIX := .dylib\n+endif\n","filename":"make\/RunTestsPrebuiltSpec.gmk","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -942,1 +942,1 @@\n-  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_CPU\" = \"xlinux\"; then\n+  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_OS\" = \"xlinux\"; then\n@@ -956,0 +956,11 @@\n+            # Switching the initialization mode with gcc from 'pattern' to 'zero'\n+            # avoids the use of unsupported `__builtin_clear_padding` for variable\n+            # length aggregates\n+            if test \"x$DEBUG_LEVEL\" != xrelease && test \"x$TOOLCHAIN_TYPE\" = xgcc ; then\n+              INIT_ZERO_FLAG=\"-ftrivial-auto-var-init=zero\"\n+              FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [$INIT_ZERO_FLAG],\n+                IF_TRUE: [\n+                  $2SVE_CFLAGS=\"${$2SVE_CFLAGS} $INIT_ZERO_FLAG\"\n+                ]\n+              )\n+            fi\n","filename":"make\/autoconf\/flags-cflags.m4","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-# make TARGETS=\"arm-linux-gnueabihf ppc64-linux-gnu\" BASE_OS=Fedora BASE_OS_VERSION=17\n+# make TARGETS=\"arm-linux-gnueabihf ppc64le-linux-gnu\" BASE_OS=Fedora BASE_OS_VERSION=17\n@@ -53,1 +53,1 @@\n-#    make TARGETS=\"arm-linux-gnueabihf,ppc64-linux-gnu\" BASE_OS=Fedora\n+#    make TARGETS=\"arm-linux-gnueabihf ppc64le-linux-gnu\" BASE_OS=Fedora\n","filename":"make\/devkit\/Makefile","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,3 @@\n+  ifeq ($(filter aarch64 armhfp ppc64le riscv64 s390x x86_64, $(ARCH)), )\n+    $(error Only \"aarch64 armhfp ppc64le riscv64 s390x x86_64\" architectures are supported for Fedora, but \"$(ARCH)\" was requested)\n+  endif\n@@ -73,0 +76,3 @@\n+    ifeq ($(filter 38 39 40 41, $(BASE_OS_VERSION)), )\n+      $(error Only Fedora 38-41 are supported for \"$(ARCH)\", but Fedora $(BASE_OS_VERSION) was requested)\n+    endif\n@@ -75,2 +81,2 @@\n-    LATEST_ARCHIVED_OS_VERSION := 35\n-    ifeq ($(filter x86_64 armhfp, $(ARCH)), )\n+    LATEST_ARCHIVED_OS_VERSION := 36\n+    ifeq ($(filter aarch64 armhfp x86_64, $(ARCH)), )\n@@ -81,0 +87,5 @@\n+    ifeq ($(ARCH), armhfp)\n+      ifneq ($(BASE_OS_VERSION), 36)\n+        $(error Fedora 36 is the last release supporting \"armhfp\", but $(BASE_OS) was requested)\n+      endif\n+    endif\n@@ -467,1 +478,1 @@\n-ifneq ($(filter riscv64 ppc64 ppc64le s390x, $(ARCH)), )\n+ifneq ($(filter riscv64 ppc64le s390x, $(ARCH)), )\n","filename":"make\/devkit\/Tools.gmk","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+\t\t\t\"oracle.oracle-java\",\n@@ -20,0 +21,4 @@\n+\n+\t\t\/\/ Java extension\n+\t\t\"jdk.project.jdkhome\": \"{{OUTPUTDIR}}\/jdk\",\n+\t\t\"jdk.java.onSave.organizeImports\": false, \/\/ prevents unnecessary changes\n","filename":"make\/ide\/vscode\/hotspot\/template-workspace.jsonc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -282,0 +282,14 @@\n+      case Op_AddVHF:\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_AbsVHF:\n+      case Op_NegVHF:\n+      case Op_FmaVHF:\n+      case Op_AddReductionVHF:\n+        \/\/ FEAT_FP16 is enabled if both \"fphp\" and \"asimdhp\" features are supported.\n+        \/\/ Only the Neon instructions need this check. SVE supports 16-bit floats by default.\n+        if (UseSVE > 0 || (VM_Version::supports_fphp() && VM_Version::supports_asimdhp())) {\n+          break;\n+        }\n+        return false;\n@@ -358,0 +372,1 @@\n+      case Op_AddReductionVHF:\n@@ -743,0 +758,10 @@\n+instruct vaddHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (AddVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vaddHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fadd($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -983,0 +1008,10 @@\n+instruct vsubHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (SubVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vsubHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fsub($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1196,0 +1231,10 @@\n+instruct vmulHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (MulVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vmulHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fmul($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1288,0 +1333,10 @@\n+instruct vdivHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src1 (DivVHF (Binary dst_src1 src2) pg));\n+  format %{ \"vdivHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1880,0 +1935,15 @@\n+instruct vabsHF(vReg dst, vReg src) %{\n+  match(Set dst (AbsVHF src));\n+  format %{ \"vabsHF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fabs($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fabs($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1952,0 +2022,10 @@\n+instruct vabsHF_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AbsVHF dst_src pg));\n+  format %{ \"vabsHF_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fabs($dst_src$$FloatRegister, __ H, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2053,0 +2133,15 @@\n+instruct vnegHF(vReg dst, vReg src) %{\n+  match(Set dst (NegVHF src));\n+  format %{ \"vnegHF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fneg($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fneg($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2107,0 +2202,10 @@\n+instruct vnegHF_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (NegVHF dst_src pg));\n+  format %{ \"vnegHF_masked $dst_src, $pg, $dst_src\" %}\n+  ins_encode %{\n+    __ sve_fneg($dst_src$$FloatRegister, __ H, $pg$$PRegister, $dst_src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2639,0 +2744,1 @@\n+  match(Set dst_src1 (FmaVHF (Binary dst_src1 src2) (Binary src3 pg)));\n@@ -3340,0 +3446,39 @@\n+\/\/ reduction addHF\n+instruct reduce_addHF_neon(iRegINoSp dst, iRegIorL2I hfsrc, vReg vsrc, vReg tmp1, vRegF tmp2) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (AddReductionVHF hfsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"reduce_addHF_neon $dst, $hfsrc, $vsrc\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"invalid vector length\");\n+\n+    __ fmovwh($tmp2$$FloatRegister, $hfsrc$$Register);\n+    if (length_in_bytes == 8) {\n+      __ faddp($tmp1$$FloatRegister, __ T4H, $vsrc$$FloatRegister, $vsrc$$FloatRegister);\n+    } else {\n+      __ faddp($tmp1$$FloatRegister, __ T8H, $vsrc$$FloatRegister, $vsrc$$FloatRegister);\n+      __ faddp($tmp1$$FloatRegister, __ T4H, $tmp1$$FloatRegister, $tmp1$$FloatRegister);\n+    }\n+    __ faddp($tmp1$$FloatRegister, $tmp1$$FloatRegister, __ H);\n+    __ faddh($tmp2$$FloatRegister, $tmp2$$FloatRegister, $tmp1$$FloatRegister);\n+    __ fmovhw($dst$$Register, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addHF_sve(iRegINoSp dst, iRegIorL2I hfsrc, vReg vsrc, vRegF tmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (AddReductionVHF hfsrc vsrc));\n+  effect(TEMP tmp);\n+  format %{ \"reduce_addHF_sve $dst, $hfsrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ fmovwh($tmp$$FloatRegister, $hfsrc$$Register);\n+    __ sve_fadda($tmp$$FloatRegister, __ H, ptrue, $vsrc$$FloatRegister);\n+    __ fmovhw($dst$$Register, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%};\n+\n@@ -4736,0 +4881,14 @@\n+\/\/ VectorCastHF2D\n+\n+instruct vcvtHFtoD_sve(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (VectorCastHF2D src));\n+  format %{ \"vcvtHFtoD_sve $dst, $src\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ H);\n+    __ sve_fcvt($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ H);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -4762,0 +4921,14 @@\n+\n+instruct vcvtDtoHF_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) > 16);\n+  match(Set dst (VectorCastD2HF src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtDtoHF_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fcvt($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ H,\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":173,"deletions":0,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -272,0 +272,14 @@\n+      case Op_AddVHF:\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_AbsVHF:\n+      case Op_NegVHF:\n+      case Op_FmaVHF:\n+      case Op_AddReductionVHF:\n+        \/\/ FEAT_FP16 is enabled if both \"fphp\" and \"asimdhp\" features are supported.\n+        \/\/ Only the Neon instructions need this check. SVE supports 16-bit floats by default.\n+        if (UseSVE > 0 || (VM_Version::supports_fphp() && VM_Version::supports_asimdhp())) {\n+          break;\n+        }\n+        return false;\n@@ -348,0 +362,1 @@\n+      case Op_AddReductionVHF:\n@@ -587,6 +602,7 @@\n-BINARY_OP_PREDICATE(vaddB, AddVB, sve_add,  B)\n-BINARY_OP_PREDICATE(vaddS, AddVS, sve_add,  H)\n-BINARY_OP_PREDICATE(vaddI, AddVI, sve_add,  S)\n-BINARY_OP_PREDICATE(vaddL, AddVL, sve_add,  D)\n-BINARY_OP_PREDICATE(vaddF, AddVF, sve_fadd, S)\n-BINARY_OP_PREDICATE(vaddD, AddVD, sve_fadd, D)\n+BINARY_OP_PREDICATE(vaddB,  AddVB,  sve_add,  B)\n+BINARY_OP_PREDICATE(vaddS,  AddVS,  sve_add,  H)\n+BINARY_OP_PREDICATE(vaddI,  AddVI,  sve_add,  S)\n+BINARY_OP_PREDICATE(vaddL,  AddVL,  sve_add,  D)\n+BINARY_OP_PREDICATE(vaddHF, AddVHF, sve_fadd, H)\n+BINARY_OP_PREDICATE(vaddF,  AddVF,  sve_fadd, S)\n+BINARY_OP_PREDICATE(vaddD,  AddVD,  sve_fadd, D)\n@@ -612,6 +628,7 @@\n-BINARY_OP_PREDICATE(vsubB, SubVB, sve_sub,  B)\n-BINARY_OP_PREDICATE(vsubS, SubVS, sve_sub,  H)\n-BINARY_OP_PREDICATE(vsubI, SubVI, sve_sub,  S)\n-BINARY_OP_PREDICATE(vsubL, SubVL, sve_sub,  D)\n-BINARY_OP_PREDICATE(vsubF, SubVF, sve_fsub, S)\n-BINARY_OP_PREDICATE(vsubD, SubVD, sve_fsub, D)\n+BINARY_OP_PREDICATE(vsubB,  SubVB,  sve_sub,  B)\n+BINARY_OP_PREDICATE(vsubS,  SubVS,  sve_sub,  H)\n+BINARY_OP_PREDICATE(vsubI,  SubVI,  sve_sub,  S)\n+BINARY_OP_PREDICATE(vsubL,  SubVL,  sve_sub,  D)\n+BINARY_OP_PREDICATE(vsubHF, SubVHF, sve_fsub, H)\n+BINARY_OP_PREDICATE(vsubF,  SubVF,  sve_fsub, S)\n+BINARY_OP_PREDICATE(vsubD,  SubVD,  sve_fsub, D)\n@@ -689,6 +706,7 @@\n-BINARY_OP_PREDICATE(vmulB, MulVB, sve_mul,  B)\n-BINARY_OP_PREDICATE(vmulS, MulVS, sve_mul,  H)\n-BINARY_OP_PREDICATE(vmulI, MulVI, sve_mul,  S)\n-BINARY_OP_PREDICATE(vmulL, MulVL, sve_mul,  D)\n-BINARY_OP_PREDICATE(vmulF, MulVF, sve_fmul, S)\n-BINARY_OP_PREDICATE(vmulD, MulVD, sve_fmul, D)\n+BINARY_OP_PREDICATE(vmulB,  MulVB,  sve_mul,  B)\n+BINARY_OP_PREDICATE(vmulS,  MulVS,  sve_mul,  H)\n+BINARY_OP_PREDICATE(vmulI,  MulVI,  sve_mul,  S)\n+BINARY_OP_PREDICATE(vmulL,  MulVL,  sve_mul,  D)\n+BINARY_OP_PREDICATE(vmulHF, MulVHF, sve_fmul, H)\n+BINARY_OP_PREDICATE(vmulF,  MulVF,  sve_fmul, S)\n+BINARY_OP_PREDICATE(vmulD,  MulVD,  sve_fmul, D)\n@@ -704,2 +722,3 @@\n-BINARY_OP_PREDICATE(vdivF, DivVF, sve_fdiv, S)\n-BINARY_OP_PREDICATE(vdivD, DivVD, sve_fdiv, D)\n+BINARY_OP_PREDICATE(vdivHF, DivVHF, sve_fdiv, H)\n+BINARY_OP_PREDICATE(vdivF,  DivVF,  sve_fdiv, S)\n+BINARY_OP_PREDICATE(vdivD,  DivVD,  sve_fdiv, D)\n@@ -997,6 +1016,7 @@\n-UNARY_OP(vabsB, AbsVB, absr, sve_abs,  B)\n-UNARY_OP(vabsS, AbsVS, absr, sve_abs,  H)\n-UNARY_OP(vabsI, AbsVI, absr, sve_abs,  S)\n-UNARY_OP(vabsL, AbsVL, absr, sve_abs,  D)\n-UNARY_OP(vabsF, AbsVF, fabs, sve_fabs, S)\n-UNARY_OP(vabsD, AbsVD, fabs, sve_fabs, D)\n+UNARY_OP(vabsB,  AbsVB,  absr, sve_abs,  B)\n+UNARY_OP(vabsS,  AbsVS,  absr, sve_abs,  H)\n+UNARY_OP(vabsI,  AbsVI,  absr, sve_abs,  S)\n+UNARY_OP(vabsL,  AbsVL,  absr, sve_abs,  D)\n+UNARY_OP(vabsHF, AbsVHF, fabs, sve_fabs, H)\n+UNARY_OP(vabsF,  AbsVF,  fabs, sve_fabs, S)\n+UNARY_OP(vabsD,  AbsVD,  fabs, sve_fabs, D)\n@@ -1005,6 +1025,7 @@\n-UNARY_OP_PREDICATE_WITH_SIZE(vabsB, AbsVB, sve_abs,  B)\n-UNARY_OP_PREDICATE_WITH_SIZE(vabsS, AbsVS, sve_abs,  H)\n-UNARY_OP_PREDICATE_WITH_SIZE(vabsI, AbsVI, sve_abs,  S)\n-UNARY_OP_PREDICATE_WITH_SIZE(vabsL, AbsVL, sve_abs,  D)\n-UNARY_OP_PREDICATE_WITH_SIZE(vabsF, AbsVF, sve_fabs, S)\n-UNARY_OP_PREDICATE_WITH_SIZE(vabsD, AbsVD, sve_fabs, D)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsB,  AbsVB,  sve_abs,  B)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsS,  AbsVS,  sve_abs,  H)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsI,  AbsVI,  sve_abs,  S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsL,  AbsVL,  sve_abs,  D)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsHF, AbsVHF, sve_fabs, H)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsF,  AbsVF,  sve_fabs, S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vabsD,  AbsVD,  sve_fabs, D)\n@@ -1077,3 +1098,4 @@\n-UNARY_OP(vnegL, NegVL, negr, sve_neg,  D)\n-UNARY_OP(vnegF, NegVF, fneg, sve_fneg, S)\n-UNARY_OP(vnegD, NegVD, fneg, sve_fneg, D)\n+UNARY_OP(vnegL,  NegVL,  negr, sve_neg,  D)\n+UNARY_OP(vnegHF, NegVHF, fneg, sve_fneg, H)\n+UNARY_OP(vnegF,  NegVF,  fneg, sve_fneg, S)\n+UNARY_OP(vnegD,  NegVD,  fneg, sve_fneg, D)\n@@ -1083,3 +1105,4 @@\n-UNARY_OP_PREDICATE_WITH_SIZE(vnegL, NegVL, sve_neg,  D)\n-UNARY_OP_PREDICATE_WITH_SIZE(vnegF, NegVF, sve_fneg, S)\n-UNARY_OP_PREDICATE_WITH_SIZE(vnegD, NegVD, sve_fneg, D)\n+UNARY_OP_PREDICATE_WITH_SIZE(vnegL,  NegVL,  sve_neg,  D)\n+UNARY_OP_PREDICATE_WITH_SIZE(vnegHF, NegVHF, sve_fneg, H)\n+UNARY_OP_PREDICATE_WITH_SIZE(vnegF,  NegVF,  sve_fneg, S)\n+UNARY_OP_PREDICATE_WITH_SIZE(vnegD,  NegVD,  sve_fneg, D)\n@@ -1406,0 +1429,1 @@\n+  match(Set dst_src1 (FmaVHF (Binary dst_src1 src2) (Binary src3 pg)));\n@@ -1997,0 +2021,39 @@\n+\/\/ reduction addHF\n+instruct reduce_addHF_neon(iRegINoSp dst, iRegIorL2I hfsrc, vReg vsrc, vReg tmp1, vRegF tmp2) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (AddReductionVHF hfsrc vsrc));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n+  format %{ \"reduce_addHF_neon $dst, $hfsrc, $vsrc\\t# KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == 8 || length_in_bytes == 16, \"invalid vector length\");\n+\n+    __ fmovwh($tmp2$$FloatRegister, $hfsrc$$Register);\n+    if (length_in_bytes == 8) {\n+      __ faddp($tmp1$$FloatRegister, __ T4H, $vsrc$$FloatRegister, $vsrc$$FloatRegister);\n+    } else {\n+      __ faddp($tmp1$$FloatRegister, __ T8H, $vsrc$$FloatRegister, $vsrc$$FloatRegister);\n+      __ faddp($tmp1$$FloatRegister, __ T4H, $tmp1$$FloatRegister, $tmp1$$FloatRegister);\n+    }\n+    __ faddp($tmp1$$FloatRegister, $tmp1$$FloatRegister, __ H);\n+    __ faddh($tmp2$$FloatRegister, $tmp2$$FloatRegister, $tmp1$$FloatRegister);\n+    __ fmovhw($dst$$Register, $tmp2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addHF_sve(iRegINoSp dst, iRegIorL2I hfsrc, vReg vsrc, vRegF tmp) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (AddReductionVHF hfsrc vsrc));\n+  effect(TEMP tmp);\n+  format %{ \"reduce_addHF_sve $dst, $hfsrc, $vsrc\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $vsrc);\n+    assert(length_in_bytes == MaxVectorSize, \"invalid vector length\");\n+    __ fmovwh($tmp$$FloatRegister, $hfsrc$$Register);\n+    __ sve_fadda($tmp$$FloatRegister, __ H, ptrue, $vsrc$$FloatRegister);\n+    __ fmovhw($dst$$Register, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%};\n+\n@@ -2988,0 +3051,14 @@\n+\/\/ VectorCastHF2D\n+\n+instruct vcvtHFtoD_sve(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (VectorCastHF2D src));\n+  format %{ \"vcvtHFtoD_sve $dst, $src\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_vector_extend($dst$$FloatRegister, __ D, $src$$FloatRegister, __ H);\n+    __ sve_fcvt($dst$$FloatRegister, __ D, ptrue, $dst$$FloatRegister, __ H);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3015,0 +3092,14 @@\n+instruct vcvtDtoHF_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) > 16);\n+  match(Set dst (VectorCastD2HF src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"vcvtDtoHF_sve $dst, $src\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fcvt($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister, __ D);\n+    __ sve_vector_narrow($dst$$FloatRegister, __ H,\n+                         $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":129,"deletions":38,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -2071,0 +2071,1 @@\n+    int op21 = (opcode == 0b000101) ? 0b0 : 0b1;\n@@ -2131,0 +2132,8 @@\n+  INSN(fabdh,  0b011, 0b11, 0b000101);\n+  INSN(fmulh,  0b000, 0b11, 0b000010);\n+  INSN(fdivh,  0b000, 0b11, 0b000110);\n+  INSN(faddh,  0b000, 0b11, 0b001010);\n+  INSN(fsubh,  0b000, 0b11, 0b001110);\n+  INSN(fmaxh,  0b000, 0b11, 0b010010);\n+  INSN(fminh,  0b000, 0b11, 0b010110);\n+  INSN(fnmulh, 0b000, 0b11, 0b100010);\n@@ -2220,2 +2229,3 @@\n-  INSN(fmovs, 0b0, 0b00, 0b00, 0b110);\n-  INSN(fmovd, 0b1, 0b01, 0b00, 0b110);\n+  INSN(fmovs,  0b0, 0b00, 0b00, 0b110);\n+  INSN(fmovd,  0b1, 0b01, 0b00, 0b110);\n+  INSN(fmovhw, 0b0, 0b11, 0b00, 0b110);    \/\/ half-precision -> 32-bit\n@@ -2232,2 +2242,3 @@\n-  INSN(fmovs, 0b0, 0b00, 0b00, 0b111);\n-  INSN(fmovd, 0b1, 0b01, 0b00, 0b111);\n+  INSN(fmovs,  0b0, 0b00, 0b00, 0b111);\n+  INSN(fmovd,  0b1, 0b01, 0b00, 0b111);\n+  INSN(fmovwh, 0b0, 0b11, 0b00, 0b111); \/\/ 32-bit -> half-precision\n@@ -2976,3 +2987,3 @@\n-    assert(type == D || type == S, \"Wrong type for faddp\/fmaxp\/fminp\");                 \\\n-    f(0b0111111, 31, 25), f(op1, 24, 23),                                               \\\n-    f(type == S ? 0 : 1, 22), f(0b11000, 21, 17), f(op2, 16, 10), rf(Vn, 5), rf(Vd, 0); \\\n+    assert(type == D || type == S || type == H, \"Wrong type for faddp\/fmaxp\/fminp\");    \\\n+    f(0b01, 31, 30), f(type == H ? 0 : 1, 29), f(0b1111, 28, 25), f(op1, 24, 23),       \\\n+    f(type == D ? 1 : 0, 22), f(0b11000, 21, 17), f(op2, 16, 10), rf(Vn, 5), rf(Vd, 0); \\\n@@ -3503,2 +3514,2 @@\n-  INSN(sve_fabs,   0b00000100, 0b011100101);\n-  INSN(sve_fadd,   0b01100101, 0b000000100);\n+  INSN(sve_fabs,   0b00000100, 0b011100101); \/\/ floating-point absolute value\n+  INSN(sve_fadd,   0b01100101, 0b000000100); \/\/ floating-point add vector\n@@ -3506,1 +3517,1 @@\n-  INSN(sve_fdiv,   0b01100101, 0b001101100);\n+  INSN(sve_fdiv,   0b01100101, 0b001101100); \/\/ floating-point divide by vector\n@@ -3511,2 +3522,2 @@\n-  INSN(sve_fmul,   0b01100101, 0b000010100);\n-  INSN(sve_fneg,   0b00000100, 0b011101101);\n+  INSN(sve_fmul,   0b01100101, 0b000010100); \/\/ floating-point multiply vectors\n+  INSN(sve_fneg,   0b00000100, 0b011101101); \/\/ floating-point negate\n@@ -3517,2 +3528,2 @@\n-  INSN(sve_fsqrt,  0b01100101, 0b001101101);\n-  INSN(sve_fsub,   0b01100101, 0b000001100);\n+  INSN(sve_fsqrt,  0b01100101, 0b001101101); \/\/ floating-point square root\n+  INSN(sve_fsub,   0b01100101, 0b000001100); \/\/ floating-point subtract vectors\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -3126,1 +3126,3 @@\n-  __ membar(__ AnyAny);\n+  if(!UseLSE) {\n+    __ membar(__ AnyAny);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,3 +104,6 @@\n-    \/\/ We need to re-read fp out of the frame because it may be an oop and we might have\n-    \/\/ had a safepoint in finalize_freeze, after constructing f.\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+    \/\/ For a compiled frame we need to re-read fp out of the frame because it may be an\n+    \/\/ oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ For stub\/native frames the value is not used while frozen, and will be constructed again\n+    \/\/ when thawing the frame (see ThawBase::new_stack_frame). We use a special bad address to\n+    \/\/ help with debugging, particularly when inspecting frames and identifying invalid accesses.\n+    fp = FKind::compiled ? *(intptr_t**)(f.sp() - frame::sender_sp_offset) : (intptr_t*)badAddressVal;\n@@ -195,0 +198,5 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  intptr_t* fp_addr = sp - frame::sender_sp_offset;\n+  *fp_addr = badAddressVal;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6424,4 +6424,8 @@\n-\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n-\/\/     return the number of characters copied.\n-\/\/ - java\/lang\/StringUTF16.compress\n-\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n+\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ASCII\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -337,0 +337,3 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2596,4 +2596,8 @@\n-\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n-\/\/     return the number of characters copied.\n-\/\/ - java\/lang\/StringUTF16.compress\n-\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n+\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ASCII\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -197,0 +197,3 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -232,5 +232,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ branch_optimized(Assembler::bcondAlways, *stub->entry());\n-    } else {\n-      __ unlock_object(Rtmp1, Rtmp2, lock->as_register(), *stub->entry());\n-    }\n+    __ unlock_object(Rtmp1, Rtmp2, lock->as_register(), *stub->entry());\n@@ -2717,7 +2713,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj);\n-    }\n-    __ branch_optimized(Assembler::bcondAlways, *op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -72,54 +70,1 @@\n-  assert(LockingMode != LM_MONITOR, \"LM_MONITOR is already handled, by emit_lock()\");\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(Rbox, Roop, Rmark, tmp, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(tmp, Roop);\n-      z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-      branch_optimized(Assembler::bcondAllOne, slow_case);\n-    }\n-\n-    NearLabel done;\n-\n-    \/\/ Load object header.\n-    z_lg(Rmark, Address(Roop, hdr_offset));\n-\n-    \/\/ and mark it as unlocked.\n-    z_oill(Rmark, markWord::unlocked_value);\n-    \/\/ Save unlocked object header into the displaced header location on the stack.\n-    z_stg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ Test if object header is still the same (i.e. unlocked), and if so, store the\n-    \/\/ displaced header address in the object header. If it is not the same, get the\n-    \/\/ object header instead.\n-    z_csg(Rmark, Rbox, hdr_offset, Roop);\n-    \/\/ If the object header was the same, we're done.\n-    branch_optimized(Assembler::bcondEqual, done);\n-    \/\/ If the object header was not the same, it is now in the Rmark register.\n-    \/\/ => Test if it is a stack pointer into the same stack (recursive locking), i.e.:\n-    \/\/\n-    \/\/ 1) (Rmark & markWord::lock_mask_in_place) == 0\n-    \/\/ 2) rsp <= Rmark\n-    \/\/ 3) Rmark <= rsp + page_size\n-    \/\/\n-    \/\/ These 3 tests can be done by evaluating the following expression:\n-    \/\/\n-    \/\/ (Rmark - Z_SP) & (~(page_size-1) | markWord::lock_mask_in_place)\n-    \/\/\n-    \/\/ assuming both the stack pointer and page_size have their least\n-    \/\/ significant 2 bits cleared and page_size is a power of 2\n-    z_sgr(Rmark, Z_SP);\n-\n-    load_const_optimized(Z_R0_scratch, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n-    z_ngr(Rmark, Z_R0_scratch); \/\/ AND sets CC (result eq\/ne 0).\n-    \/\/ For recursive locking, the result is zero. => Save it in the displaced header\n-    \/\/ location (null in the displaced Rmark location indicates recursive locking).\n-    z_stg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ Otherwise we don't care about the result and handle locking via runtime call.\n-    branch_optimized(Assembler::bcondNotZero, slow_case);\n-    \/\/ done\n-    bind(done);\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n+  lightweight_lock(Rbox, Roop, Rmark, tmp, slow_case);\n@@ -129,2 +74,0 @@\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -133,9 +76,0 @@\n-  NearLabel done;\n-\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Load displaced header.\n-    z_ltg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ If the loaded Rmark is null we had recursive locking, and we are done.\n-    z_bre(done);\n-  }\n-\n@@ -145,15 +79,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(Roop, Rmark, Z_R1_scratch, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ Test if object header is pointing to the displaced header, and if so, restore\n-    \/\/ the displaced header in the object. If the object header is not pointing to\n-    \/\/ the displaced header, get the object header instead.\n-    z_csg(Rbox, Rmark, hdr_offset, Roop);\n-    \/\/ If the object header was not pointing to the displaced header,\n-    \/\/ we do unlocking via runtime call.\n-    branch_optimized(Assembler::bcondNotEqual, slow_case);\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n-  \/\/ done\n-  bind(done);\n+  lightweight_unlock(Roop, Rmark, Z_R1_scratch, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":2,"deletions":82,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1011,22 +1011,0 @@\n-\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    return;\n-  }\n-\n-  \/\/ template code: (for LM_LEGACY)\n-  \/\/\n-  \/\/ markWord displaced_header = obj->mark().set_unlocked();\n-  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-  \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-  \/\/   \/\/ We stored the monitor address into the object's mark word.\n-  \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-  \/\/   \/\/ Simple recursive case.\n-  \/\/   monitor->lock()->set_displaced_header(nullptr);\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-  \/\/ }\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -1034,2 +1012,0 @@\n-  const Register object_mark_addr = Z_ARG4;\n-  const Register current_header   = Z_ARG5;\n@@ -1040,61 +1016,1 @@\n-  \/\/ markWord header = obj->mark().set_unlocked();\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(monitor, object, header, tmp, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(tmp, object);\n-      z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-      z_btrue(slow_case);\n-    }\n-\n-    \/\/ Load markWord from object into header.\n-    z_lg(header, hdr_offset, object);\n-\n-    \/\/ Set header to be (markWord of object | UNLOCK_VALUE).\n-    \/\/ This will not change anything if it was unlocked before.\n-    z_oill(header, markWord::unlocked_value);\n-\n-    \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n-\n-    \/\/ Initialize the box (Must happen before we update the object mark!).\n-    z_stg(header, mark_offset, monitor);\n-\n-    \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-\n-    \/\/ not necessary, use offset in instruction directly.\n-    \/\/ add2reg(object_mark_addr, hdr_offset, object);\n-\n-    \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n-    z_csg(header, monitor, hdr_offset, object);\n-    assert(current_header == header,\n-           \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n-\n-    z_bre(done);\n-\n-    \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-    \/\/   \/\/ Simple recursive case.\n-    \/\/   monitor->lock()->set_displaced_header(nullptr);\n-\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-    \/\/ Check if owner is self by comparing the value in the markWord of object\n-    \/\/ (current_header) with the stack pointer.\n-    z_sgr(current_header, Z_SP);\n-\n-    assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n-\n-    \/\/ The prior sequence \"LGR, NGR, LTGR\" can be done better\n-    \/\/ (Z_R1 is temp and not used after here).\n-    load_const_optimized(Z_R0, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n-    z_ngr(Z_R0, current_header); \/\/ AND sets CC (result eq\/ne 0)\n-\n-    \/\/ If condition is true we are done and hence we can store 0 in the displaced\n-    \/\/ header indicating it is a recursive lock and be done.\n-    z_brne(slow_case);\n-    z_release();  \/\/ Member unnecessary on zarch AND because the above csg does a sync before and after.\n-    z_stg(Z_R0\/*==0!*\/, mark_offset, monitor);\n-  }\n+  lightweight_lock(monitor, object, header, tmp, slow_case);\n@@ -1102,5 +1018,0 @@\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-  \/\/ None of the above fast optimizations worked so we have to get into the\n-  \/\/ slow case of monitor enter.\n@@ -1110,2 +1021,0 @@\n-  \/\/ }\n-\n@@ -1125,22 +1034,0 @@\n-\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n-    return;\n-  }\n-\n-\/\/ else {\n-  \/\/ template code: (for LM_LEGACY):\n-  \/\/\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-  \/\/   monitor->set_obj(nullptr);\n-  \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-  \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-  \/\/   monitor->set_obj(nullptr);\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorexit(monitor);\n-  \/\/ }\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -1162,39 +1049,2 @@\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-  \/\/   monitor->set_obj(nullptr);\n-\n-  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-  const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-  const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n-\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Test first if we are in the fast recursive case.\n-    MacroAssembler::load_and_test_long(header, Address(monitor, mark_offset));\n-    z_bre(done); \/\/ header == 0 -> goto done\n-  }\n-  \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-  \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-  \/\/   monitor->set_obj(nullptr);\n-\n-  \/\/ If we still have a lightweight lock, unlock the object and be done.\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-\n-    lightweight_unlock(object, header, current_header, slow_case);\n-\n-    z_bru(done);\n-  } else {\n-    \/\/ The markword is expected to be at offset 0.\n-    \/\/ This is not required on s390, at least not here.\n-    assert(hdr_offset == 0, \"unlock_object: review code below\");\n-\n-    \/\/ We have the displaced header in header. If the lock is still\n-    \/\/ lightweight, it will contain the monitor address and we'll store the\n-    \/\/ displaced header back into the object's mark word.\n-    z_lgr(current_header, monitor);\n-    z_csg(current_header, header, hdr_offset, object);\n-    z_bre(done);\n-  }\n-\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorexit(monitor);\n+  lightweight_unlock(object, header, current_header, slow_case);\n+  z_bru(done);\n@@ -1209,3 +1059,0 @@\n-\n-  \/\/ }\n-\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":3,"deletions":156,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -3769,205 +3769,0 @@\n-\/\/ \"The box\" is the space on the stack where we copy the object mark.\n-void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2) {\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_lock_lightweight\");\n-  assert_different_registers(oop, box, temp1, temp2, Z_R0_scratch);\n-\n-  Register displacedHeader = temp1;\n-  Register currentHeader   = temp1;\n-  Register temp            = temp2;\n-\n-  NearLabel done, object_has_monitor;\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n-  BLOCK_COMMENT(\"compiler_fast_lock_object {\");\n-\n-  \/\/ Load markWord from oop into mark.\n-  z_lg(displacedHeader, hdr_offset, oop);\n-\n-  if (DiagnoseSyncOnValueBasedClasses != 0) {\n-    load_klass(temp, oop);\n-    z_tm(Address(temp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-    z_brne(done);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  guarantee(Immediate::is_uimm16(markWord::monitor_value), \"must be half-word\");\n-  z_tmll(displacedHeader, markWord::monitor_value);\n-  z_brnaz(object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path\n-    \/\/ From loading the markWord, we know that oop != nullptr\n-    z_ltgr(oop, oop);\n-    z_bru(done);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Set mark to markWord | markWord::unlocked_value.\n-    z_oill(displacedHeader, markWord::unlocked_value);\n-\n-    \/\/ Load Compare Value application register.\n-\n-    \/\/ Initialize the box (must happen before we update the object mark).\n-    z_stg(displacedHeader, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    \/\/ Compare object markWord with mark and if equal, exchange box with object markWork.\n-    \/\/ If the compare-and-swap succeeds, then we found an unlocked object and have now locked it.\n-    z_csg(displacedHeader, box, hdr_offset, oop);\n-    assert(currentHeader == displacedHeader, \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n-    z_bre(done);\n-\n-    \/\/ We did not see an unlocked object\n-    \/\/ currentHeader contains what is currently stored in the oop's markWord.\n-    \/\/ We might have a recursive case. Verify by checking if the owner is self.\n-    \/\/ To do so, compare the value in the markWord (currentHeader) with the stack pointer.\n-    z_sgr(currentHeader, Z_SP);\n-    load_const_optimized(temp, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n-\n-    z_ngr(currentHeader, temp);\n-\n-    \/\/ result zero: owner is self -> recursive lock. Indicate that by storing 0 in the box.\n-    \/\/ result not-zero: attempt failed. We don't hold the lock -> go for slow case.\n-\n-    z_stg(currentHeader\/*==0 or not 0*\/, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    z_bru(done);\n-  }\n-\n-  bind(object_has_monitor);\n-\n-  Register zero = temp;\n-  Register monitor_tagged = displacedHeader; \/\/ Tagged with markWord::monitor_value.\n-\n-  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n-  \/\/ If csg succeeds then CR=EQ, otherwise, register zero is filled\n-  \/\/ with the current owner.\n-  z_lghi(zero, 0);\n-  z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::monitor_owner_id_offset()));\n-  z_csg(zero, Z_R0_scratch, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor_tagged);\n-\n-  \/\/ Store a non-null value into the box.\n-  z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-  z_bre(done); \/\/ acquired the lock for the first time.\n-\n-  BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n-  \/\/ Check if we are already the owner (recursive lock)\n-  z_cgr(Z_R0_scratch, zero); \/\/ owner is stored in zero by \"z_csg\" above\n-  z_brne(done); \/\/ not a recursive lock\n-\n-  \/\/ Current thread already owns the lock. Just increment recursion count.\n-  z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n-  z_cgr(zero, zero); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n-  bind(done);\n-\n-  BLOCK_COMMENT(\"} compiler_fast_lock_object\");\n-  \/\/ If locking was successful, CR should indicate 'EQ'.\n-  \/\/ The compiler or the native wrapper generates a branch to the runtime call\n-  \/\/ _complete_monitor_locking_Java.\n-}\n-\n-void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2) {\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_unlock_lightweight\");\n-  assert_different_registers(oop, box, temp1, temp2, Z_R0_scratch);\n-\n-  Register displacedHeader = temp1;\n-  Register currentHeader   = temp2;\n-  Register temp            = temp1;\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n-  Label done, object_has_monitor, not_recursive;\n-\n-  BLOCK_COMMENT(\"compiler_fast_unlock_object {\");\n-\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    \/\/ if the displaced header is zero, we have a recursive unlock.\n-    load_and_test_long(displacedHeader, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    z_bre(done);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  z_lg(currentHeader, hdr_offset, oop);\n-  guarantee(Immediate::is_uimm16(markWord::monitor_value), \"must be half-word\");\n-\n-  z_tmll(currentHeader, markWord::monitor_value);\n-  z_brnaz(object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path\n-    z_ltgr(oop, oop);\n-    z_bru(done);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Check if it is still a lightweight lock, this is true if we see\n-    \/\/ the stack address of the basicLock in the markWord of the object\n-    \/\/ copy box to currentHeader such that csg does not kill it.\n-    z_lgr(currentHeader, box);\n-    z_csg(currentHeader, displacedHeader, hdr_offset, oop);\n-    z_bru(done); \/\/ csg sets CR as desired.\n-  }\n-\n-  \/\/ In case of LM_LIGHTWEIGHT, we may reach here with (temp & ObjectMonitor::ANONYMOUS_OWNER) != 0.\n-  \/\/ This is handled like owner thread mismatches: We take the slow path.\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-\n-  z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::monitor_owner_id_offset()));\n-  z_cg(Z_R0_scratch, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-  z_brne(done);\n-\n-  BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n-\n-  \/\/ Recursive inflated unlock\n-  z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n-  z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n-  z_bru(done);\n-\n-  bind(not_recursive);\n-\n-  NearLabel set_eq_unlocked;\n-\n-  \/\/ Set owner to null.\n-  \/\/ Release to satisfy the JMM\n-  z_release();\n-  z_lghi(temp, 0);\n-  z_stg(temp, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);\n-  \/\/ We need a full fence after clearing owner to avoid stranding.\n-  z_fence();\n-\n-  \/\/ Check if the entry_list is empty.\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(entry_list)));\n-  z_bre(done); \/\/ If so we are done.\n-\n-  \/\/ Check if there is a successor.\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)));\n-  z_brne(set_eq_unlocked); \/\/ If so we are done.\n-\n-  \/\/ Save the monitor pointer in the current thread, so we can try to\n-  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n-  z_xilf(currentHeader, markWord::monitor_value);\n-  z_stg(currentHeader, Address(Z_thread, JavaThread::unlocked_inflated_monitor_offset()));\n-\n-  z_ltgr(oop, oop); \/\/ Set flag = NE\n-  z_bru(done);\n-\n-  bind(set_eq_unlocked);\n-  z_cr(temp, temp); \/\/ Set flag = EQ\n-\n-  bind(done);\n-\n-  BLOCK_COMMENT(\"} compiler_fast_unlock_object\");\n-  \/\/ flag == EQ indicates success\n-  \/\/ flag == NE indicates failure\n-}\n-\n@@ -6352,1 +6147,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -6418,1 +6212,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":0,"deletions":207,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -793,2 +793,0 @@\n-  void compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2);\n-  void compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -10164,22 +10164,0 @@\n-instruct cmpFastLock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set pcc (FastLock oop box));\n-  effect(TEMP tmp1, TEMP tmp2);\n-  ins_cost(100);\n-  \/\/ TODO: s390 port size(VARIABLE_SIZE); \/\/ Uses load_const_optimized.\n-  format %{ \"FASTLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n-  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n-instruct cmpFastUnlock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set pcc (FastUnlock oop box));\n-  effect(TEMP tmp1, TEMP tmp2);\n-  ins_cost(100);\n-  \/\/ TODO: s390 port size(FIXED_SIZE);\n-  format %{ \"FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n-  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n@@ -10187,1 +10165,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n@@ -10203,1 +10180,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1767,7 +1767,2 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n-      __ compiler_fast_lock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    } else {\n-      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n-      __ compiler_fast_lock_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    }\n+    \/\/ Fast_lock kills r_temp_1, r_temp_2.\n+    __ compiler_fast_lock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n@@ -1968,7 +1963,2 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n-      __ compiler_fast_unlock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    } else {\n-      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n-      __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    }\n+    \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n+    __ compiler_fast_unlock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+\/\/   z17:  2025-04\n@@ -72,5 +73,5 @@\n-static const char* z_gen[]      = {\"  \", \"G1\",         \"G2\",         \"G3\",         \"G4\",         \"G5\",         \"G6\",         \"G7\",         \"G8\",         \"G9\",         \"G10\" };\n-static const char* z_machine[]  = {\"  \", \"2064\",       \"2084\",       \"2094\",       \"2097\",       \"2817\",       \"2827\",       \"2964\",       \"3906\",       \"8561\",       \"3931\" };\n-static const char* z_name[]     = {\"  \", \"z900\",       \"z990\",       \"z9 EC\",      \"z10 EC\",     \"z196 EC\",    \"ec12\",       \"z13\",        \"z14\",        \"z15\",        \"z16\" };\n-static const char* z_WDFM[]     = {\"  \", \"2006-06-30\", \"2008-06-30\", \"2010-06-30\", \"2012-06-30\", \"2014-06-30\", \"2016-12-31\", \"2019-06-30\", \"2021-06-30\", \"2024-12-31\", \"tbd\" };\n-static const char* z_EOS[]      = {\"  \", \"2014-12-31\", \"2014-12-31\", \"2017-10-31\", \"2019-12-31\", \"2021-12-31\", \"2023-12-31\", \"2024-12-31\", \"tbd\",        \"tbd\",        \"tbd\" };\n+static const char* z_gen[]      = {\"  \", \"G1\",         \"G2\",         \"G3\",         \"G4\",         \"G5\",         \"G6\",         \"G7\",         \"G8\",         \"G9\",         \"G10\",         \"G11\" };\n+static const char* z_machine[]  = {\"  \", \"2064\",       \"2084\",       \"2094\",       \"2097\",       \"2817\",       \"2827\",       \"2964\",       \"3906\",       \"8561\",       \"3931\",        \"9175\" };\n+static const char* z_name[]     = {\"  \", \"z900\",       \"z990\",       \"z9 EC\",      \"z10 EC\",     \"z196 EC\",    \"ec12\",       \"z13\",        \"z14\",        \"z15\",        \"z16\",         \"z17\" };\n+static const char* z_WDFM[]     = {\"  \", \"2006-06-30\", \"2008-06-30\", \"2010-06-30\", \"2012-06-30\", \"2014-06-30\", \"2016-12-31\", \"2019-06-30\", \"2021-06-30\", \"2024-12-31\", \"tbd\",         \"tbd\" };\n+static const char* z_EOS[]      = {\"  \", \"2014-12-31\", \"2014-12-31\", \"2017-10-31\", \"2019-12-31\", \"2021-12-31\", \"2023-12-31\", \"2024-12-31\", \"tbd\",        \"tbd\",        \"tbd\",         \"tbd\" };\n@@ -88,1 +89,3 @@\n-                                       \"bear_enh, sort_enh, nnpa_assist, storage_key_removal, vpack_decimal_enh\"\n+                                       \"bear_enh, sort_enh, nnpa_assist, storage_key_removal, vpack_decimal_enh\",\n+                                   \"system-z, g11-z17, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1, instrext3, venh2,\"\n+                                       \"bear_enh, sort_enh, nnpa_assist, storage_key_removal, vpack_decimal_enh, concurrent_function\"\n@@ -342,0 +345,5 @@\n+  if (is_z17()) {\n+    model_ix = 11;\n+    ambiguity++;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-\/\/ --- FeatureBitString Bits 128..192 (DW[2]) ---\n+\/\/ --- FeatureBitString Bits 128..191 (DW[2]) ---\n@@ -121,1 +121,1 @@\n-\/\/ --- FeatureBitString Bits 193..200 (DW[3]) ---\n+\/\/ --- FeatureBitString Bits 192..255 (DW[3]) ---\n@@ -124,0 +124,1 @@\n+#define  ConcurrentFunFacilityMask      0x0040000000000000UL  \/\/ z17, Concurrent-functions facility, Bit: 201\n@@ -192,1 +193,2 @@\n-  static bool is_z16()  { return has_BEAR_Enh_Facility(); }\n+  static bool is_z16()  { return has_BEAR_Enh_Facility()      && !has_Concurrent_Fun_Facility(); }\n+  static bool is_z17()  { return has_Concurrent_Fun_Facility();}\n@@ -500,0 +502,1 @@\n+  static bool has_Concurrent_Fun_Facility()   { return  (_features[3] & ConcurrentFunFacilityMask)     == ConcurrentFunFacilityMask; }\n@@ -576,0 +579,1 @@\n+  static void set_has_Concurrent_Fun_Facility()   { _features[3] |= ConcurrentFunFacilityMask;}\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2374,0 +2374,55 @@\n+void Assembler::evcvtph2pd(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16((unsigned char)0x5A, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvtph2pd(XMMRegister dst, XMMRegister src, int vector_len) {\n+  evcvtph2pd(dst, k0, src, vector_len);\n+}\n+\n+void Assembler::evcvtpd2ph(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16((unsigned char)0x5A, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvtpd2ph(XMMRegister dst, XMMRegister src, int vector_len) {\n+  evcvtpd2ph(dst, k0, src, vector_len);\n+}\n+\n+void Assembler::evcvtps2ph(XMMRegister dst, KRegister mask, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x1D, (0xC0 | encode), imm8);\n+}\n+\n+void Assembler::evcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {\n+  evcvtps2ph(dst, k0, src, imm8, vector_len);\n+}\n+\n+void Assembler::evcvtph2ps(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x13, (0xC0 | encode));\n+}\n+\n+void Assembler::evcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len) {\n+  evcvtph2ps(dst, k0, src, vector_len);\n+}\n@@ -7428,0 +7483,9 @@\n+void Assembler::evaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int8(0x58);\n+  emit_int8((unsigned char)(0xC0 | encode));\n+}\n+\n@@ -7637,0 +7701,1 @@\n+\n@@ -7686,0 +7751,1 @@\n+\n@@ -7745,0 +7811,34 @@\n+\n+void Assembler::evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister src1, XMMRegister src2, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  assert(VM_Version::supports_fma(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int16((unsigned char)0xB8, (0xC0 | encode));\n+}\n+\n+void Assembler::evfmadd231ph(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {\n+  evfmadd231ph(dst, k0, src1, src2, vector_len);\n+}\n+\n+void Assembler::evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister src1, Address src2, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  assert(VM_Version::supports_fma(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  vex_prefix(src2, src1->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP6, &attributes);\n+  emit_int8((unsigned char)0xB8);\n+  emit_operand(dst, src2, 0);\n+}\n+\n+void Assembler::evfmadd231ph(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {\n+  evfmadd231ph(dst, k0, src1, src2, vector_len);\n+}\n+\n@@ -7828,0 +7928,1 @@\n+\n@@ -16527,1 +16628,1 @@\n-void Assembler::evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+void Assembler::evaddph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n@@ -16530,1 +16631,1 @@\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n@@ -16532,0 +16633,2 @@\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n@@ -16536,0 +16639,4 @@\n+void Assembler::evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  evaddph(dst, k0, nds, src, vector_len);\n+}\n+\n@@ -16548,1 +16655,1 @@\n-void Assembler::evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+void Assembler::evsubph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n@@ -16551,1 +16658,1 @@\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n@@ -16553,0 +16660,2 @@\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n@@ -16557,0 +16666,4 @@\n+void Assembler::evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  evsubph(dst, k0, nds, src, vector_len);\n+}\n+\n@@ -16569,9 +16682,0 @@\n-void Assembler::evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n-  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n-  emit_int16(0x59, (0xC0 | encode));\n-}\n-\n@@ -16590,0 +16694,15 @@\n+void Assembler::evmulph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x59, (0xC0 | encode));\n+}\n+\n+void Assembler::evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  evmulph(dst, k0, nds, src, vector_len);\n+}\n+\n@@ -16660,1 +16779,1 @@\n-void Assembler::evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+void Assembler::evdivph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len) {\n@@ -16663,1 +16782,1 @@\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n@@ -16665,0 +16784,2 @@\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.reset_is_clear_context();\n@@ -16669,0 +16790,4 @@\n+void Assembler::evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  evdivph(dst, k0, nds, src, vector_len);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":140,"deletions":15,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -1341,0 +1341,10 @@\n+  \/\/ convert vector HF and double\n+  void evcvtph2pd(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvtph2pd(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len);\n+  void evcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len);\n+  void evcvtps2ph(XMMRegister dst, KRegister mask, XMMRegister src, int imm8, int vector_len);\n+  void evcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvtph2ps(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len);\n+  void evcvtpd2ph(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvtpd2ph(XMMRegister dst, KRegister mask, XMMRegister src, int vector_len);\n+\n@@ -2368,0 +2378,1 @@\n+  void evaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n@@ -2449,0 +2460,4 @@\n+  void evfmadd231ph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evfmadd231ph(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evfmadd231ph(XMMRegister dst, KRegister mask, XMMRegister nds, Address src, int vector_len);\n@@ -2703,0 +2718,1 @@\n+  void evaddph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2705,0 +2721,1 @@\n+  void evsubph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2707,0 +2724,1 @@\n+  void evdivph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2709,0 +2727,1 @@\n+  void evmulph(XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2208,0 +2208,20 @@\n+void C2_MacroAssembler::reduce8HF(Register dst, XMMRegister src, XMMRegister vtmp, XMMRegister vtmp1, XMMRegister vtmp2) {\n+  movdl(vtmp1, dst);\n+  evaddsh(vtmp1, vtmp1, src);\n+  pshuflw(vtmp, src, 0x01);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshuflw(vtmp, src, 0x02);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshuflw(vtmp, src, 0x03);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshufd(vtmp2, src, 0x0E);\n+  evaddsh(vtmp1, vtmp1, vtmp2);\n+  pshuflw(vtmp, vtmp2, 0x01);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshuflw(vtmp, vtmp2, 0x02);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  pshuflw(vtmp, vtmp2, 0x03);\n+  evaddsh(vtmp1, vtmp1, vtmp);\n+  movdl(dst, vtmp1);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+  void reduce8HF(Register dst, XMMRegister src, XMMRegister vtmp, XMMRegister vtmp1, XMMRegister vtmp2);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,3 +101,6 @@\n-    \/\/ We need to re-read fp out of the frame because it may be an oop and we might have\n-    \/\/ had a safepoint in finalize_freeze, after constructing f.\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+    \/\/ For a compiled frame we need to re-read fp out of the frame because it may be an\n+    \/\/ oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ For stub\/native frames the value is not used while frozen, and will be constructed again\n+    \/\/ when thawing the frame (see ThawBase::new_stack_frame). We use a special bad address to\n+    \/\/ help with debugging, particularly when inspecting frames and identifying invalid accesses.\n+    fp = FKind::compiled ? *(intptr_t**)(f.sp() - frame::sender_sp_offset) : (intptr_t*)badAddressVal;\n@@ -186,0 +189,5 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  intptr_t* fp_addr = sp - frame::sender_sp_offset;\n+  *fp_addr = badAddressVal;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1698,0 +1698,16 @@\n+\/\/ dst = c = a * b + c\n+void MacroAssembler::evfmahf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {\n+  Assembler::evfmadd231ph(c, a, b, vector_len);\n+  if (dst != c) {\n+    vmovdqu(dst, c);\n+  }\n+}\n+\n+\/\/ dst = c = a * b + c\n+void MacroAssembler::evfmahf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {\n+  Assembler::evfmadd231ph(c, a, b, vector_len);\n+  if (dst != c) {\n+    vmovdqu(dst, c);\n+  }\n+}\n+\n@@ -6030,26 +6046,40 @@\n-\/\/ encode char[] to byte[] in ISO_8859_1 or ASCII\n-   \/\/@IntrinsicCandidate\n-   \/\/private static int implEncodeISOArray(byte[] sa, int sp,\n-   \/\/byte[] da, int dp, int len) {\n-   \/\/  int i = 0;\n-   \/\/  for (; i < len; i++) {\n-   \/\/    char c = StringUTF16.getChar(sa, sp++);\n-   \/\/    if (c > '\\u00FF')\n-   \/\/      break;\n-   \/\/    da[dp++] = (byte)c;\n-   \/\/  }\n-   \/\/  return i;\n-   \/\/}\n-   \/\/\n-   \/\/@IntrinsicCandidate\n-   \/\/private static int implEncodeAsciiArray(char[] sa, int sp,\n-   \/\/    byte[] da, int dp, int len) {\n-   \/\/  int i = 0;\n-   \/\/  for (; i < len; i++) {\n-   \/\/    char c = sa[sp++];\n-   \/\/    if (c >= '\\u0080')\n-   \/\/      break;\n-   \/\/    da[dp++] = (byte)c;\n-   \/\/  }\n-   \/\/  return i;\n-   \/\/}\n+\/\/ Encode given char[]\/byte[] to byte[] in ISO_8859_1 or ASCII\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(\n+\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/     int i = 0;\n+\/\/     for (; i < len; i++) {\n+\/\/         char c = sa[sp++];\n+\/\/         if (c > '\\u00FF')\n+\/\/             break;\n+\/\/         da[dp++] = (byte) c;\n+\/\/     }\n+\/\/     return i;\n+\/\/ }\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int java.lang.StringCoding.encodeISOArray0(\n+\/\/         byte[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/   int i = 0;\n+\/\/   for (; i < len; i++) {\n+\/\/     char c = StringUTF16.getChar(sa, sp++);\n+\/\/     if (c > '\\u00FF')\n+\/\/       break;\n+\/\/     da[dp++] = (byte) c;\n+\/\/   }\n+\/\/   return i;\n+\/\/ }\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int java.lang.StringCoding.encodeAsciiArray0(\n+\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/   int i = 0;\n+\/\/   for (; i < len; i++) {\n+\/\/     char c = sa[sp++];\n+\/\/     if (c >= '\\u0080')\n+\/\/       break;\n+\/\/     da[dp++] = (byte) c;\n+\/\/   }\n+\/\/   return i;\n+\/\/ }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":56,"deletions":26,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -458,0 +458,2 @@\n+  void evfmahf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);\n+  void evfmahf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,0 +84,8 @@\n+  do_stub(compiler, vector_halffloat_sign_mask)                         \\\n+  do_arch_entry(x86, compiler, vector_halffloat_sign_mask,              \\\n+                vector_halffloat_sign_mask,                             \\\n+                vector_halffloat_sign_mask)                             \\\n+  do_stub(compiler, vector_halffloat_sign_flip)                         \\\n+  do_arch_entry(x86, compiler, vector_halffloat_sign_flip,              \\\n+                vector_halffloat_sign_flip,                             \\\n+                vector_halffloat_sign_flip)                             \\\n","filename":"src\/hotspot\/cpu\/x86\/stubDeclarations_x86.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4167,0 +4167,2 @@\n+  StubRoutines::x86::_vector_halffloat_sign_mask = generate_vector_mask(StubId::stubgen_vector_halffloat_sign_mask_id, 0x7FFF7FFF7FFF7FFF);\n+  StubRoutines::x86::_vector_halffloat_sign_flip = generate_vector_mask(StubId::stubgen_vector_halffloat_sign_flip_id, 0x8000800080008000);\n@@ -4200,0 +4202,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1325,0 +1325,2 @@\n+  static address vector_halffloat_signmask() { return StubRoutines::x86::vector_halffloat_sign_mask();}\n+  static address vector_halffloat_signflip() { return StubRoutines::x86::vector_halffloat_sign_flip();}\n@@ -1614,0 +1616,1 @@\n+    case Op_AbsVHF:\n@@ -1618,0 +1621,1 @@\n+    case Op_NegVHF:\n@@ -1779,8 +1783,0 @@\n-    case Op_VectorCastF2HF:\n-    case Op_VectorCastHF2F:\n-      if (!VM_Version::supports_f16c() &&\n-         ((!VM_Version::supports_evex() ||\n-         ((size_in_bits != 512) && !VM_Version::supports_avx512vl())))) {\n-        return false;\n-      }\n-      break;\n@@ -1913,0 +1909,8 @@\n+    case Op_VectorCastF2HF:\n+    case Op_VectorCastHF2F:\n+    case Op_VectorCastD2HF:\n+    case Op_VectorCastHF2D:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -2084,0 +2088,1 @@\n+\n@@ -2863,0 +2868,22 @@\n+\/\/ Comparison Code for FP conditional move\n+operand cmpOp_vcmppd() %{\n+  match(Bool);\n+\n+  predicate(n->as_Bool()->_test._test != BoolTest::overflow &&\n+            n->as_Bool()->_test._test != BoolTest::no_overflow);\n+  format %{ \"\" %}\n+  interface(COND_INTER) %{\n+    equal        (0x0, \"eq\");\n+    less         (0x1, \"lt\");\n+    less_equal   (0x2, \"le\");\n+    not_equal    (0xC, \"ne\");\n+    greater_equal(0xD, \"ge\");\n+    greater      (0xE, \"gt\");\n+    \/\/TODO cannot compile (adlc breaks) without two next lines with error:\n+    \/\/ x86_64.ad(13987) Syntax Error: :In operand cmpOp_vcmppd: Do not support this encode constant: ' %{\n+    \/\/ equal' for overflow.\n+    overflow     (0x20, \"o\");  \/\/ not really supported by the instruction\n+    no_overflow  (0x21, \"no\"); \/\/ not really supported by the instruction\n+  %}\n+%}\n+\n@@ -4927,0 +4954,10 @@\n+\/\/ =======================Half Float Reduction==========================================\n+instruct reduction8HF(rRegI dst, vec src2, vec vtmp, vec vtmp1, vec vtmp2) %{\n+  match(Set dst (AddReductionVHF dst src2));\n+  effect(TEMP vtmp, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"reduction_halffloat  $dst, $src2\\t using $vtmp, $vtmp1, $vtmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ reduce8HF($dst$$Register, $src2$$XMMRegister, $vtmp$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -5691,0 +5728,11 @@\n+\/\/ Halffloat vector add\n+instruct vaddHF_reg(vec dst, vec src1, vec src2) %{\n+  match(Set dst (AddVHF src1 src2));\n+  format %{ \"evaddph  $dst,$src1,$src2\\t! add packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evaddph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -5899,0 +5947,11 @@\n+\/\/ Halffloat vector sub\n+instruct vsubHF_reg(vec dst, vec src1, vec src2) %{\n+  match(Set dst (SubVHF src1 src2));\n+  format %{ \"evsubph  $dst,$src1,$src2\\t! sub packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evsubph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -6206,0 +6265,36 @@\n+instruct vcmov8F_reg(legVec dst, legVec src1, legVec src2, immI8 cop, cmpOp_vcmppd copnd) %{\n+  predicate(Matcher::vector_length(n) == 8);\n+  match(Set dst (CMoveVF (Binary copnd cop) (Binary src1 src2)));\n+  effect(TEMP dst, USE src1, USE src2);\n+  format %{ \"cmpps.$copnd  $dst, $src1, $src2  ! vcmovevf, cond=$cop\\n\\t\"\n+            \"blendvps $dst,$src1,$src2,$dst ! vcmovevf\\n\\t\"\n+         %}\n+  ins_encode %{\n+    assert(UseAVX > 0, \"required\");\n+\n+    int vlen_enc = Assembler::AVX_256bit;\n+    int cond = (Assembler::Condition)($copnd$$cmpcode);\n+    __ vcmpps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cond, vlen_enc);\n+    __ vblendvps($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcmov4D_reg(legVec dst, legVec src1, legVec src2, immI8 cop, cmpOp_vcmppd copnd) %{\n+  predicate(Matcher::vector_length(n) == 4);\n+  match(Set dst (CMoveVD (Binary copnd cop) (Binary src1 src2)));\n+  effect(TEMP dst, USE src1, USE src2);\n+  format %{ \"cmppd.$copnd  $dst, $src1, $src2  ! vcmovevd, cond=$cop\\n\\t\"\n+            \"vblendvpd $dst,$src1,$src2,$dst ! vcmovevd\\n\\t\"\n+         %}\n+  ins_encode %{\n+    assert(UseAVX > 0, \"required\");\n+\n+    int vlen_enc = Assembler::AVX_256bit;\n+    int cond = (Assembler::Condition)($copnd$$cmpcode);\n+    __ vcmppd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cond, vlen_enc);\n+    __ vblendvpd($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -6276,0 +6371,11 @@\n+\/\/ Halffloat vector div\n+instruct vdivHF_reg(vec dst, vec src1, vec src2) %{\n+  match(Set dst (DivVHF src1 src2));\n+  format %{ \"evdivph  $dst,$src1,$src2\\t! div packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evdivph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7772,0 +7878,24 @@\n+\/\/ Convert from Halffloat to other types\n+instruct vcvtHFtoD_reg(vec dst, vec src) %{\n+  predicate(UseAVX > 2 && VM_Version::supports_avx512_fp16() && Matcher::vector_element_basic_type(n) == T_DOUBLE);\n+  match(Set dst (VectorCastHF2D src));\n+  format %{ \"evcvtph2pd   $dst,$src\\t! convert HF to D vector\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ evcvtph2pd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n+instruct vcvtDtoHF_reg(vec dst, vec src) %{\n+  predicate(UseAVX > 2 && VM_Version::supports_avx512_fp16() && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (VectorCastD2HF src));\n+  format %{ \"evcvtpd2ph   $dst,$src\\t! convert D to HF vector\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ evcvtpd2ph($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -8295,0 +8425,22 @@\n+\/\/ Half float abs\n+instruct vabsHF_reg(vec dst, vec src) %{\n+  match(Set dst (AbsVHF  src));\n+  format %{ \"vandps $dst,$src\\t# $dst = |$src| abs packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vandps($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_halffloat_signmask()), vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ Halffloat neg\n+instruct vnegHF_reg(vec dst, vec src) %{\n+  match(Set dst (NegVHF src));\n+  format %{\"vxorps $dst, $src\\t $dst = -$src neg packedHF\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vxorps($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_halffloat_signflip()), vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -9024,0 +9176,27 @@\n+\/\/ a * b + c\n+instruct vfmaHF_reg(vecX a, vecX b, vecX c) %{\n+  match(Set c (FmaVHF  c (Binary a b)));\n+  format %{ \"evfmaph $a,$b,$c\\t# $c = $a * $b + $c fma packedHF\" %}\n+  ins_cost(150);\n+  ins_encode %{\n+    assert(UseFMA, \"not enabled\");\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evfmahf($c$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $c$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ a * b + c\n+instruct vfmaHF_mem(vecX a, memory b, vecX c) %{\n+  predicate(Matcher::vector_length_in_bytes(n->in(1)) > 8);\n+  match(Set c (FmaVHF  c (Binary a (LoadVector b))));\n+  format %{ \"evfmaph $a,$b,$c\\t# $c = $a * $b + $c fma packedHF\" %}\n+  ins_cost(150);\n+  ins_encode %{\n+    assert(UseFMA, \"not enabled\");\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evfmahf($c$$XMMRegister, $a$$XMMRegister, $b$$Address, $c$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":187,"deletions":8,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  \/\/ VM expects i2c entry to be always filled. The rest can be unset.\n+  \/\/ foil any attempt to call the i2c, c2i or unverified c2i entries\n@@ -61,2 +61,2 @@\n-                            nullptr,\n-                            nullptr,\n+                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  do_arch_blob(initial, 32)                                             \\\n+  do_arch_blob(initial, 0)                                              \\\n@@ -61,1 +61,1 @@\n-  do_arch_blob(final, 32)                                               \\\n+  do_arch_blob(final, 0)                                                \\\n","filename":"src\/hotspot\/cpu\/zero\/stubDeclarations_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,0 +58,8 @@\n+#ifndef HWCAP_FPHP\n+#define HWCAP_FPHP (1<<9)\n+#endif\n+\n+#ifndef HWCAP_ASIMDHP\n+#define HWCAP_ASIMDHP (1<<10)\n+#endif\n+\n@@ -146,0 +154,2 @@\n+      HWCAP_FPHP    |\n+      HWCAP_ASIMDHP |\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -583,2 +583,2 @@\n-    \"AbsVB\", \"AbsVS\", \"AbsVI\", \"AbsVL\", \"AbsVF\", \"AbsVD\",\n-    \"NegVI\", \"NegVL\", \"NegVF\", \"NegVD\",\n+    \"AbsVB\", \"AbsVS\", \"AbsVI\", \"AbsVL\", \"AbsVHF\", \"AbsVF\", \"AbsVD\",\n+    \"NegVI\", \"NegVL\", \"NegVHF\", \"NegVF\", \"NegVD\",\n","filename":"src\/hotspot\/share\/adlc\/dfa.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4238,0 +4238,1 @@\n+        strcmp(opType,\"AddReductionVHF\")==0 ||\n@@ -4341,0 +4342,1 @@\n+    \"CMoveVD\", \"CMoveVF\",\n@@ -4342,2 +4344,2 @@\n-    \"AbsVB\",\"AbsVS\",\"AbsVI\",\"AbsVL\",\"AbsVF\",\"AbsVD\",\n-    \"NegVF\",\"NegVD\",\"NegVI\",\"NegVL\",\n+    \"AbsVB\",\"AbsVS\",\"AbsVI\",\"AbsVL\",\"AbsVHF\",\"AbsVF\",\"AbsVD\",\n+    \"NegVHF\",\"NegVF\",\"NegVD\",\"NegVI\",\"NegVL\",\n@@ -4349,1 +4351,1 @@\n-    \"AddReductionVF\", \"AddReductionVD\",\n+    \"AddReductionVF\", \"AddReductionVD\",\"AddReductionVHF\",\n@@ -4367,0 +4369,1 @@\n+    \"VectorCastD2HF\", \"VectorCastHF2D\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -646,2 +646,11 @@\n-    if (is_dumping_preimage_static_archive() || is_dumping_final_static_archive()) {\n-      \/\/ Don't tweak execution mode\n+    if (is_dumping_preimage_static_archive()) {\n+      \/\/ Don't tweak execution mode during AOT training run\n+    } else if (is_dumping_final_static_archive()) {\n+      if (Arguments::mode() == Arguments::_comp) {\n+        \/\/ AOT assembly phase submits the non-blocking compilation requests\n+        \/\/ for methods collected during training run, then waits for all compilations\n+        \/\/ to complete. With -Xcomp, we block for each compilation request, which is\n+        \/\/ counter-productive. Switching back to mixed mode improves testing time\n+        \/\/ with AOT and -Xcomp.\n+        Arguments::set_mode_flags(Arguments::_mixed);\n+      }\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1889,2 +1889,3 @@\n-         JavaThread::current()->thread_state() == _thread_in_vm,\n-         \"Java Thread is not running in vm\");\n+         JavaThread::current()->thread_state() == _thread_in_vm ||\n+         JavaThread::current() == java_lang_Thread::thread(java_thread),\n+         \"unsafe call to java_lang_Thread::get_thread_status()?\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n-   do_name(     countPositives_name,                       \"countPositives\")                                            \\\n+   do_name(     countPositives_name,                       \"countPositives0\")                                           \\\n@@ -423,1 +423,1 @@\n-   do_name(     encodeISOArray_name,                             \"implEncodeISOArray\")                                  \\\n+   do_name(     encodeISOArray_name,                             \"encodeISOArray0\")                                     \\\n@@ -429,1 +429,1 @@\n-   do_name(     encodeAsciiArray_name,                           \"implEncodeAsciiArray\")                                \\\n+   do_name(     encodeAsciiArray_name,                           \"encodeAsciiArray0\")                                   \\\n@@ -497,2 +497,2 @@\n-   do_name(gcm_crypt_name, \"implGCMCrypt0\")                                                                                 \\\n-   do_signature(aes_gcm_signature, \"([BII[BI[BILcom\/sun\/crypto\/provider\/GCTR;Lcom\/sun\/crypto\/provider\/GHASH;)I\")                                                             \\\n+   do_name(gcm_crypt_name, \"implGCMCrypt0\")                                                                             \\\n+   do_signature(aes_gcm_signature, \"([BII[BI[BILcom\/sun\/crypto\/provider\/GCTR;Lcom\/sun\/crypto\/provider\/GHASH;)I\")        \\\n@@ -1007,0 +1007,2 @@\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"I\"                                                                                                      \\\n@@ -1019,0 +1021,2 @@\n+                                       \"Ljava\/lang\/Class;\"                                                                                     \\\n+                                       \"I\"                                                                                                     \\\n@@ -1055,0 +1059,2 @@\n+                                        \"Ljava\/lang\/Class;\"                                                                                    \\\n+                                        \"I\"                                                                                                    \\\n@@ -1066,0 +1072,1 @@\n+                                            \"Ljava\/lang\/Class;\"                                                                                \\\n@@ -1068,0 +1075,1 @@\n+                                            \"I\"                                                                                                \\\n@@ -1078,0 +1086,2 @@\n+                                               \"Ljava\/lang\/Class;\"                                                                             \\\n+                                               \"I\"                                                                                             \\\n@@ -1089,0 +1099,2 @@\n+                                     \"Ljava\/lang\/Class;\"                                                                                       \\\n+                                     \"I\"                                                                                                       \\\n@@ -1102,0 +1114,1 @@\n+                                            \"Ljava\/lang\/Class;\"                                                                                \\\n@@ -1105,0 +1118,1 @@\n+                                            \"I\"                                                                                                \\\n@@ -1120,0 +1134,2 @@\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"I\"                                                                                                      \\\n@@ -1135,0 +1151,2 @@\n+                                             \"Ljava\/lang\/Class;\"                                                                               \\\n+                                             \"I\"                                                                                               \\\n@@ -1152,0 +1170,2 @@\n+                                               \"Ljava\/lang\/Class;\"                                                                             \\\n+                                               \"I\"                                                                                             \\\n@@ -1163,0 +1183,2 @@\n+                                  \"Ljava\/lang\/Class;\"                                                                                          \\\n+                                  \"I\"                                                                                                          \\\n@@ -1174,0 +1196,2 @@\n+                                   \"Ljava\/lang\/Class;\"                                                                                         \\\n+                                   \"I\"                                                                                                         \\\n@@ -1185,1 +1209,4 @@\n-                                     \"Ljava\/lang\/Class;Ljava\/lang\/Class;\"                                                                      \\\n+                                     \"Ljava\/lang\/Class;\"                                                                                       \\\n+                                     \"Ljava\/lang\/Class;\"                                                                                       \\\n+                                     \"Ljava\/lang\/Class;\"                                                                                       \\\n+                                     \"I\"                                                                                                       \\\n@@ -1199,0 +1226,2 @@\n+                                       \"Ljava\/lang\/Class;\"                                                                                     \\\n+                                       \"I\"                                                                                                     \\\n@@ -1211,0 +1240,2 @@\n+                                        \"Ljava\/lang\/Class;\"                                                                                     \\\n+                                        \"I\"                                                                                                     \\\n@@ -1217,1 +1248,1 @@\n-   do_name(vector_select_from_name, \"selectFromOp\")                                                                                              \\\n+   do_name(vector_select_from_name, \"selectFromOp\")                                                                                            \\\n@@ -1222,0 +1253,2 @@\n+                                     \"Ljava\/lang\/Class;\"                                                                                       \\\n+                                     \"I\"                                                                                                       \\\n@@ -1231,0 +1264,1 @@\n+                                    \"Ljava\/lang\/Class;\"                                                                                        \\\n@@ -1233,0 +1267,1 @@\n+                                    \"I\"                                                                                                        \\\n@@ -1244,0 +1279,2 @@\n+                                           \"Ljava\/lang\/Class;\"                                                                                 \\\n+                                           \"I\"                                                                                                 \\\n@@ -1270,0 +1307,2 @@\n+                                     \"Ljava\/lang\/Class;\"                                                                                       \\\n+                                     \"I\"                                                                                                       \\\n@@ -1289,0 +1328,1 @@\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n@@ -1292,0 +1332,1 @@\n+                                      \"I\"                                                                                                      \\\n@@ -1313,0 +1354,2 @@\n+                                        \"Ljava\/lang\/Class;\"                                                                                    \\\n+                                        \"I\"                                                                                                    \\\n@@ -1324,0 +1367,2 @@\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"I\"                                                                                                      \\\n@@ -1333,0 +1378,1 @@\n+                                       \"Ljava\/lang\/Class;\"                                                                                     \\\n@@ -1335,0 +1381,1 @@\n+                                       \"I\"                                                                                                     \\\n@@ -1345,0 +1392,2 @@\n+                                                     \"Ljava\/lang\/Class;\"                                                                                       \\\n+                                                     \"I\"                                                                                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":56,"deletions":7,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+  template(CTYPE_name,                                \"CTYPE\")                                              \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -407,1 +407,1 @@\n-void CompilationPolicy::print_counters(const char* prefix, Method* m) {\n+void CompilationPolicy::print_counters_on(outputStream* st, const char* prefix, Method* m) {\n@@ -419,6 +419,5 @@\n-  tty->print(\" %stotal=%d,%d %smdo=%d(%d),%d(%d)\", prefix,\n-      invocation_count, backedge_count, prefix,\n-      mdo_invocations, mdo_invocations_start,\n-      mdo_backedges, mdo_backedges_start);\n-  tty->print(\" %smax levels=%d,%d\", prefix,\n-      m->highest_comp_level(), m->highest_osr_comp_level());\n+  st->print(\" %stotal=%d,%d %smdo=%d(%d),%d(%d)\", prefix,\n+    invocation_count, backedge_count, prefix,\n+    mdo_invocations, mdo_invocations_start,\n+    mdo_backedges, mdo_backedges_start);\n+  st->print(\" %smax levels=%d,%d\", prefix, m->highest_comp_level(), m->highest_osr_comp_level());\n@@ -427,1 +426,1 @@\n-void CompilationPolicy::print_training_data(const char* prefix, Method* method) {\n+void CompilationPolicy::print_training_data_on(outputStream* st,  const char* prefix, Method* method) {\n@@ -429,1 +428,1 @@\n-  tty->print(\" %smtd: \", prefix);\n+  st->print(\" %smtd: \", prefix);\n@@ -432,1 +431,1 @@\n-    tty->print(\"null\");\n+    st->print(\"null\");\n@@ -435,1 +434,1 @@\n-    tty->print(\"mdo=\");\n+    st->print(\"mdo=\");\n@@ -437,1 +436,1 @@\n-      tty->print(\"null\");\n+      st->print(\"null\");\n@@ -443,1 +442,1 @@\n-      tty->print(\"%d(%d), %d(%d)\", mdo_invocations, mdo_invocations_start, mdo_backedges, mdo_backedges_start);\n+      st->print(\"%d(%d), %d(%d)\", mdo_invocations, mdo_invocations_start, mdo_backedges, mdo_backedges_start);\n@@ -446,1 +445,1 @@\n-    tty->print(\", deps=\");\n+    st->print(\", deps=\");\n@@ -448,1 +447,1 @@\n-      tty->print(\"null\");\n+      st->print(\"null\");\n@@ -450,1 +449,1 @@\n-      tty->print(\"%d\", ctd->init_deps_left());\n+      st->print(\"%d\", ctd->init_deps_left());\n@@ -456,1 +455,1 @@\n-void CompilationPolicy::print_event(EventType type, Method* m, Method* im, int bci, CompLevel level) {\n+void CompilationPolicy::print_event_on(outputStream *st, EventType type, Method* m, Method* im, int bci, CompLevel level) {\n@@ -459,2 +458,1 @@\n-  ttyLocker tty_lock;\n-  tty->print(\"%lf: [\", os::elapsedTime());\n+  st->print(\"%lf: [\", os::elapsedTime());\n@@ -464,1 +462,1 @@\n-    tty->print(\"call\");\n+    st->print(\"call\");\n@@ -467,1 +465,1 @@\n-    tty->print(\"loop\");\n+    st->print(\"loop\");\n@@ -470,1 +468,1 @@\n-    tty->print(\"compile\");\n+    st->print(\"compile\");\n@@ -473,1 +471,1 @@\n-    tty->print(\"force-compile\");\n+    st->print(\"force-compile\");\n@@ -476,1 +474,1 @@\n-    tty->print(\"remove-from-queue\");\n+    st->print(\"remove-from-queue\");\n@@ -479,1 +477,1 @@\n-    tty->print(\"update-in-queue\");\n+    st->print(\"update-in-queue\");\n@@ -482,1 +480,1 @@\n-    tty->print(\"reprofile\");\n+    st->print(\"reprofile\");\n@@ -485,1 +483,1 @@\n-    tty->print(\"make-not-entrant\");\n+    st->print(\"make-not-entrant\");\n@@ -488,1 +486,1 @@\n-    tty->print(\"unknown\");\n+    st->print(\"unknown\");\n@@ -491,1 +489,1 @@\n-  tty->print(\" level=%d \", level);\n+  st->print(\" level=%d \", level);\n@@ -495,1 +493,1 @@\n-  tty->print(\"[%s\", method_name);\n+  st->print(\"[%s\", method_name);\n@@ -498,1 +496,1 @@\n-    tty->print(\" [%s]] \", inlinee_name);\n+    st->print(\" [%s]] \", inlinee_name);\n@@ -500,3 +498,3 @@\n-  else tty->print(\"] \");\n-  tty->print(\"@%d queues=%d,%d\", bci, CompileBroker::queue_size(CompLevel_full_profile),\n-                                      CompileBroker::queue_size(CompLevel_full_optimization));\n+  else st->print(\"] \");\n+  st->print(\"@%d queues=%d,%d\", bci, CompileBroker::queue_size(CompLevel_full_profile),\n+                                     CompileBroker::queue_size(CompLevel_full_optimization));\n@@ -504,3 +502,3 @@\n-  tty->print(\" rate=\");\n-  if (m->prev_time() == 0) tty->print(\"n\/a\");\n-  else tty->print(\"%f\", m->rate());\n+  st->print(\" rate=\");\n+  if (m->prev_time() == 0) st->print(\"n\/a\");\n+  else st->print(\"%f\", m->rate());\n@@ -508,2 +506,2 @@\n-  tty->print(\" k=%.2lf,%.2lf\", threshold_scale(CompLevel_full_profile, Tier3LoadFeedback),\n-                               threshold_scale(CompLevel_full_optimization, Tier4LoadFeedback));\n+  st->print(\" k=%.2lf,%.2lf\", threshold_scale(CompLevel_full_profile, Tier3LoadFeedback),\n+                              threshold_scale(CompLevel_full_optimization, Tier4LoadFeedback));\n@@ -512,1 +510,1 @@\n-    print_counters(\"\", m);\n+    print_counters_on(st, \"\", m);\n@@ -514,1 +512,1 @@\n-      print_counters(\"inlinee \", im);\n+      print_counters_on(st, \"inlinee \", im);\n@@ -516,1 +514,1 @@\n-    tty->print(\" compilable=\");\n+    st->print(\" compilable=\");\n@@ -519,1 +517,1 @@\n-      tty->print(\"c1\");\n+      st->print(\"c1\");\n@@ -523,2 +521,2 @@\n-      if (need_comma) tty->print(\",\");\n-      tty->print(\"c1-osr\");\n+      if (need_comma) st->print(\",\");\n+      st->print(\"c1-osr\");\n@@ -528,2 +526,2 @@\n-      if (need_comma) tty->print(\",\");\n-      tty->print(\"c2\");\n+      if (need_comma) st->print(\",\");\n+      st->print(\"c2\");\n@@ -533,2 +531,2 @@\n-      if (need_comma) tty->print(\",\");\n-      tty->print(\"c2-osr\");\n+      if (need_comma) st->print(\",\");\n+      st->print(\"c2-osr\");\n@@ -536,1 +534,1 @@\n-    tty->print(\" status=\");\n+    st->print(\" status=\");\n@@ -538,3 +536,4 @@\n-      tty->print(\"in-queue\");\n-    } else tty->print(\"idle\");\n-    print_training_data(\"\", m);\n+      st->print(\"in-queue\");\n+    } else st->print(\"idle\");\n+\n+    print_training_data_on(st, \"\", m);\n@@ -542,1 +541,1 @@\n-      print_training_data(\"inlinee \", im);\n+      print_training_data_on(st, \"inlinee \", im);\n@@ -545,1 +544,9 @@\n-  tty->print_cr(\"]\");\n+  st->print_cr(\"]\");\n+\n+}\n+\n+void CompilationPolicy::print_event(EventType type, Method* m, Method* im, int bci, CompLevel level) {\n+  stringStream s;\n+  print_event_on(&s, type, m, im, bci, level);\n+  ResourceMark rm;\n+  tty->print(\"%s\", s.as_string());\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":62,"deletions":55,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -290,2 +290,2 @@\n-  static void print_counters(const char* prefix, Method* m);\n-  static void print_training_data(const char* prefix, Method* method);\n+  static void print_counters_on(outputStream* st, const char* prefix, Method* m);\n+  static void print_training_data_on(outputStream* st, const char* prefix, Method* method);\n@@ -321,0 +321,1 @@\n+  static void print_event_on(outputStream *st, EventType type, Method* m, Method* im, int bci, CompLevel level);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2796,2 +2796,0 @@\n-\n-  young_regions_cset_group()->clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -249,0 +249,5 @@\n+  \/\/ We clear remembered sets for young regions this late in the full GC because\n+  \/\/ G1HeapVerifier expects the remembered sets for all young regions to be complete\n+  \/\/ throughout most of the collection process (e.g. G1FullCollector::verify_after_marking).\n+  _heap->young_regions_cset_group()->clear();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -826,1 +826,0 @@\n-template<bool GENERATIONAL>\n@@ -836,3 +835,0 @@\n-    if (GENERATIONAL) {\n-      ShenandoahThreadLocalData::enable_plab_promotions(thread);\n-    }\n@@ -842,1 +838,0 @@\n-template<bool GENERATIONAL>\n@@ -854,5 +849,0 @@\n-    if (GENERATIONAL) {\n-      Thread* worker_thread = Thread::current();\n-      ShenandoahThreadLocalData::enable_plab_promotions(worker_thread);\n-    }\n-\n@@ -862,1 +852,1 @@\n-    ShenandoahConcurrentEvacThreadClosure<GENERATIONAL> thr_cl(&oops_cl);\n+    ShenandoahConcurrentEvacThreadClosure thr_cl(&oops_cl);\n@@ -868,1 +858,1 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  const ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -871,7 +861,2 @@\n-  if (heap->mode()->is_generational()) {\n-    ShenandoahConcurrentEvacUpdateThreadTask<true> task(heap->workers()->active_workers());\n-    heap->workers()->run_task(&task);\n-  } else {\n-    ShenandoahConcurrentEvacUpdateThreadTask<false> task(heap->workers()->active_workers());\n-    heap->workers()->run_task(&task);\n-  }\n+  ShenandoahConcurrentEvacUpdateThreadTask task(heap->workers()->active_workers());\n+  heap->workers()->run_task(&task);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1219,0 +1219,5 @@\n+\n+      \/\/ Re-enable promotions for the next evacuation phase.\n+      ShenandoahThreadLocalData::enable_plab_promotions(thread);\n+\n+      \/\/ Reset the fill size for next evacuation phase.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  _paced_time(0),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,2 +60,0 @@\n-  double _paced_time;\n-\n@@ -240,12 +238,0 @@\n-  static void add_paced_time(Thread* thread, double v) {\n-    data(thread)->_paced_time += v;\n-  }\n-\n-  static double paced_time(Thread* thread) {\n-    return data(thread)->_paced_time;\n-  }\n-\n-  static void reset_paced_time(Thread* thread) {\n-    data(thread)->_paced_time = 0;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n@@ -40,1 +39,1 @@\n-#include \"oops\/methodData.hpp\"\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"interpreter\/bytecodeStream.hpp\"\n+#include \"interpreter\/bytecodeStream.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeStream.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"interpreter\/bytecodes.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"interpreter\/bytecodes.hpp\"\n@@ -34,1 +34,1 @@\n-#include \"oops\/methodData.hpp\"\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/signature.hpp\"\n+#include \"runtime\/signature.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -30,1 +30,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n@@ -35,1 +34,1 @@\n-#include \"oops\/methodData.hpp\"\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -51,0 +50,1 @@\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -27,1 +28,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"interpreter\/zero\/bytecodeInterpreter.inline.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"interpreter\/zero\/bytecodeInterpreter.inline.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"bytecodeInterpreter_zero.inline.hpp\"\n@@ -45,2 +46,0 @@\n-# include \"bytecodeInterpreter_zero.inline.hpp\"\n-\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-\/\/ # include \"interpreter\/interp_masm.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,8 +51,0 @@\n-const unsigned int initial_size = 431;\n-\n-static JfrCHeapTraceIdSet* c_heap_allocate_set(int size = initial_size) {\n-  return new JfrCHeapTraceIdSet(size);\n-}\n-\n-static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n-\n@@ -69,8 +61,2 @@\n-static bool has_thread_exited(traceid tid) {\n-  assert(tid != 0, \"invariant\");\n-  if (unloaded_thread_id_set == nullptr) {\n-    return false;\n-  }\n-  ThreadIdExclusiveAccess lock;\n-  return unloaded_thread_id_set->contains(tid);\n-}\n+static const unsigned initial_set_size = 512;\n+static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n@@ -81,1 +67,1 @@\n-    unloaded_thread_id_set = c_heap_allocate_set();\n+    unloaded_thread_id_set = new (mtTracing) JfrCHeapTraceIdSet(initial_set_size);\n@@ -196,6 +182,0 @@\n-static JfrResourceAreaTraceIdSet* id_set = nullptr;\n-\n-static void prepare_for_resolution() {\n-  id_set = new JfrResourceAreaTraceIdSet(initial_size);\n-}\n-\n@@ -216,0 +196,2 @@\n+static JfrResourceAreaTraceIdSet* resolution_set = nullptr;\n+\n@@ -223,1 +205,1 @@\n-    prepare_for_resolution();\n+    resolution_set = new JfrResourceAreaTraceIdSet(initial_set_size);\n@@ -225,0 +207,1 @@\n+\n@@ -317,2 +300,2 @@\n-  assert(id_set != nullptr, \"invariant\");\n-  return !id_set->add(method_id);\n+  assert(resolution_set != nullptr, \"invariant\");\n+  return !resolution_set->add(method_id);\n@@ -359,1 +342,1 @@\n-  if (sample->is_virtual_thread() || has_thread_exited(sample->thread_id())) {\n+  if (sample->is_virtual_thread() || sample->thread_exited()) {\n@@ -375,1 +358,1 @@\n-  int _count;\n+  unsigned _count;\n@@ -381,1 +364,1 @@\n-  int count() const { return _count; }\n+  unsigned count() const { return _count; }\n@@ -397,2 +380,1 @@\n-  const int64_t count_offset = writer.reserve(sizeof(u4)); \/\/ Don't know how many yet\n-\n+  writer.write_count(_stacktrace_id_set->size());\n@@ -402,1 +384,0 @@\n-  writer.write_count(lpstw.count(), count_offset);\n@@ -425,0 +406,10 @@\n+static void check_if_thread_exited(const ObjectSample* sample) {\n+  assert(sample != nullptr, \"invariant\");\n+  if (sample->thread_exited() || unloaded_thread_id_set == nullptr) {\n+    return;\n+  }\n+  if (unloaded_thread_id_set->contains(sample->thread_id())) {\n+    sample->set_thread_exited();\n+  }\n+}\n+\n@@ -434,0 +425,1 @@\n+    check_if_thread_exited(sample);\n@@ -440,0 +432,7 @@\n+static void delete_unloaded_thread_id_set() {\n+  if (unloaded_thread_id_set != nullptr) {\n+    delete unloaded_thread_id_set;\n+    unloaded_thread_id_set = nullptr;\n+  }\n+}\n+\n@@ -445,0 +444,1 @@\n+  ThreadIdExclusiveAccess lock;\n@@ -446,0 +446,1 @@\n+  delete_unloaded_thread_id_set();\n@@ -448,3 +449,6 @@\n-static inline unsigned int set_size() {\n-  const unsigned int queue_size = static_cast<unsigned int>(JfrOptionSet::old_object_queue_size());\n-  return queue_size > initial_size ? queue_size : initial_size;\n+static inline unsigned stacktrace_id_set_size() {\n+  unsigned queue_size = static_cast<unsigned>(JfrOptionSet::old_object_queue_size());\n+  if (!is_power_of_2(queue_size)) {\n+    queue_size = next_power_of_2(queue_size);\n+  }\n+  return queue_size > initial_set_size ? queue_size : initial_set_size;\n@@ -459,1 +463,3 @@\n-    _stacktrace_id_set = new JfrResourceAreaTraceIdSet(set_size());\n+    const unsigned stacktrace_set_size = stacktrace_id_set_size();\n+    assert(is_power_of_2(stacktrace_set_size), \"invariant\");\n+    _stacktrace_id_set = new JfrResourceAreaTraceIdSet(stacktrace_set_size);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":42,"deletions":36,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  mutable bool _thread_exited;\n@@ -85,1 +86,2 @@\n-                   _virtual_thread(false) {}\n+                   _virtual_thread(false),\n+                   _thread_exited(false) {}\n@@ -228,0 +230,9 @@\n+  bool thread_exited() const {\n+    return _thread_exited;\n+  }\n+\n+  void set_thread_exited() const {\n+    assert(!_thread_exited, \"invariant\");\n+    _thread_exited = true;\n+  }\n+\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSample.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-void JfrMetadataEvent::write(JfrChunkWriter& chunkwriter) {\n+size_t JfrMetadataEvent::write(JfrChunkWriter& chunkwriter) {\n@@ -71,1 +71,1 @@\n-    return;\n+    return 0;\n@@ -90,0 +90,1 @@\n+  return 1;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrMetadataEvent.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  static void write(JfrChunkWriter& writer);\n+  static size_t write(JfrChunkWriter& writer);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrMetadataEvent.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1051,2 +1051,0 @@\n-  KlassUsedPredicate _klass_used_predicate;\n-  MethodUsedPredicate _method_used_predicate;\n@@ -1058,2 +1056,0 @@\n-    _klass_used_predicate(current_epoch()),\n-    _method_used_predicate(current_epoch()),\n@@ -1063,1 +1059,1 @@\n-    if (_method_used_predicate(klass)) {\n+    if (klass->is_instance_klass()) {\n@@ -1078,1 +1074,1 @@\n-    return _klass_used_predicate(klass) ? _klass_cb(klass) : true;\n+    return _klass_cb(klass);\n@@ -1283,1 +1279,1 @@\n-    _artifacts = new JfrArtifactSet(class_unload);\n+    _artifacts = new JfrArtifactSet(class_unload, previous_epoch());\n@@ -1285,1 +1281,1 @@\n-    _artifacts->initialize(class_unload);\n+    _artifacts->initialize(class_unload, previous_epoch());\n@@ -1287,0 +1283,1 @@\n+  assert(current_epoch() || _leakp_writer != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,6 +32,10 @@\n-JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_table(nullptr),\n-                                                    _klass_list(nullptr),\n-                                                    _total_count(0),\n-                                                    _class_unload(class_unload) {\n-  initialize(class_unload);\n-  assert(_klass_list != nullptr, \"invariant\");\n+JfrArtifactSet::JfrArtifactSet(bool class_unload, bool previous_epoch) : _symbol_table(nullptr),\n+                                                                         _klass_set(nullptr),\n+                                                                         _klass_loader_set(nullptr),\n+                                                                         _klass_loader_leakp_set(nullptr),\n+                                                                         _total_count(0),\n+                                                                         _class_unload(class_unload) {\n+  initialize(class_unload, previous_epoch);\n+  assert(!previous_epoch || _klass_loader_leakp_set != nullptr, \"invariant\");\n+  assert(_klass_loader_set != nullptr, \"invariant\");\n+  assert(_klass_set != nullptr, \"invariant\");\n@@ -40,2 +44,3 @@\n-static const size_t initial_klass_list_size = 4096;\n-const int initial_klass_loader_set_size = 64;\n+static unsigned initial_klass_set_size = 4096;\n+static unsigned initial_klass_loader_set_size = 64;\n+static unsigned initial_klass_loader_leakp_set_size = 64;\n@@ -43,1 +48,1 @@\n-void JfrArtifactSet::initialize(bool class_unload) {\n+void JfrArtifactSet::initialize(bool class_unload, bool previous_epoch) {\n@@ -53,3 +58,5 @@\n-  _klass_loader_leakp_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n-  _klass_loader_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n-  _klass_list = new GrowableArray<const Klass*>(initial_klass_list_size);\n+  if (previous_epoch) {\n+    _klass_loader_leakp_set = new JfrKlassSet(initial_klass_loader_leakp_set_size);\n+  }\n+  _klass_loader_set = new JfrKlassSet(initial_klass_loader_set_size);\n+  _klass_set = new JfrKlassSet(initial_klass_set_size);\n@@ -96,5 +103,1 @@\n-  return _klass_list->is_nonempty();\n-}\n-\n-int JfrArtifactSet::entries() const {\n-  return _klass_list->length();\n+  return _klass_set->is_nonempty();\n@@ -102,2 +105,1 @@\n-\n-static inline bool not_in_set(GrowableArray<const Klass*>* set, const Klass* k) {\n+static inline bool not_in_set(JfrArtifactSet::JfrKlassSet* set, const Klass* k) {\n@@ -106,1 +108,1 @@\n-  return !JfrMutablePredicate<const Klass*, compare_klasses>::test(set, k);\n+  return set->add(k);\n@@ -119,2 +121,2 @@\n-  assert(_klass_list != nullptr, \"invariant\");\n-  _klass_list->append(k);\n+  assert(_klass_set != nullptr, \"invariant\");\n+  _klass_set->add(k);\n@@ -124,0 +126,4 @@\n+  assert(_klass_set != nullptr, \"invariant\");\n+  initial_klass_set_size = MAX2(initial_klass_set_size, _klass_set->table_size());\n+  assert(_klass_loader_set != nullptr, \"invariant\");\n+  initial_klass_loader_set_size = MAX2(initial_klass_loader_set_size, _klass_loader_set->table_size());\n@@ -130,0 +136,2 @@\n+  assert(_klass_loader_leakp_set != nullptr, \"invariant\");\n+  initial_klass_loader_leakp_set_size = MAX2(initial_klass_loader_leakp_set_size, _klass_loader_leakp_set->table_size());\n@@ -131,1 +139,0 @@\n-\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":30,"deletions":23,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"jfr\/utilities\/jfrSet.hpp\"\n@@ -34,3 +35,0 @@\n-template <typename T>\n-class GrowableArray;\n-\n@@ -138,21 +136,0 @@\n-class KlassUsedPredicate {\n-  bool _current_epoch;\n- public:\n-  KlassUsedPredicate(bool current_epoch) : _current_epoch(current_epoch) {}\n-  bool operator()(const Klass* klass) {\n-    return _current_epoch ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass);\n-  }\n-};\n-\n-class MethodUsedPredicate {\n-  bool _current_epoch;\n-public:\n-  MethodUsedPredicate(bool current_epoch) : _current_epoch(current_epoch) {}\n-  bool operator()(const Klass* klass) {\n-    if (!klass->is_instance_klass()) {\n-      return false;\n-    }\n-    return _current_epoch ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass);\n-  }\n-};\n-\n@@ -206,0 +183,26 @@\n+ public:\n+  class JfrArtifactSetConfig : public AllStatic {\n+   public:\n+    typedef const Klass* KEY_TYPE;\n+\n+    constexpr static AnyObj::allocation_type alloc_type() {\n+      return AnyObj::RESOURCE_AREA;\n+    }\n+\n+    constexpr static MemTag memory_tag() {\n+      return mtInternal;\n+    }\n+\n+    \/\/ Knuth multiplicative hashing.\n+    static uint32_t hash(const KEY_TYPE& k) {\n+      const uint32_t v = static_cast<uint32_t>(JfrTraceId::load_raw(k));\n+      return v * UINT32_C(2654435761);\n+    }\n+\n+    static bool cmp(const KEY_TYPE& lhs, const KEY_TYPE& rhs) {\n+      return lhs == rhs;\n+    }\n+  };\n+\n+  typedef JfrSet<JfrArtifactSetConfig> JfrKlassSet;\n+\n@@ -208,3 +211,3 @@\n-  GrowableArray<const Klass*>* _klass_list;\n-  GrowableArray<const Klass*>* _klass_loader_set;\n-  GrowableArray<const Klass*>* _klass_loader_leakp_set;\n+  JfrKlassSet* _klass_set;\n+  JfrKlassSet* _klass_loader_set;\n+  JfrKlassSet* _klass_loader_leakp_set;\n@@ -215,1 +218,1 @@\n-  JfrArtifactSet(bool class_unload);\n+  JfrArtifactSet(bool class_unload, bool previous_epoch);\n@@ -219,1 +222,1 @@\n-  void initialize(bool class_unload);\n+  void initialize(bool class_unload, bool previous_epoch);\n@@ -234,1 +237,0 @@\n-  int entries() const;\n@@ -257,1 +259,1 @@\n-    if (iterate(functor, _klass_list)) {\n+    if (iterate(functor, _klass_set)) {\n@@ -264,6 +266,4 @@\n-  bool iterate(Functor& functor, GrowableArray<const Klass*>* list) const {\n-    assert(list != nullptr, \"invariant\");\n-    for (int i = 0; i < list->length(); ++i) {\n-      if (!functor(list->at(i))) {\n-        return false;\n-      }\n+  bool iterate(Functor& functor, JfrKlassSet* set) const {\n+    assert(set != nullptr, \"invariant\");\n+    if (set->is_nonempty()) {\n+      set->iterate(functor);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -370,0 +370,1 @@\n+  size_t _elements;\n@@ -371,1 +372,1 @@\n-  MetadataEvent(JfrChunkWriter& cw) : _cw(cw) {}\n+  MetadataEvent(JfrChunkWriter& cw) : _cw(cw), _elements(0) {}\n@@ -373,1 +374,1 @@\n-    JfrMetadataEvent::write(_cw);\n+    _elements = JfrMetadataEvent::write(_cw);\n@@ -376,1 +377,1 @@\n-  size_t elements() const { return 1; }\n+  size_t elements() const { return _elements; }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-static const int initial_size = 1009;\n+static const int initial_size = 1024;\n@@ -36,1 +36,1 @@\n-  return new JfrCHeapTraceIdSet(size);\n+  return new (mtTracing) JfrCHeapTraceIdSet(size);\n@@ -71,7 +71,0 @@\n-static bool is_nonempty_set(u1 epoch) {\n-  if (epoch == 0) {\n-    return _unload_set_epoch_0 != nullptr && _unload_set_epoch_0->is_nonempty();\n-  }\n-  return _unload_set_epoch_1 != nullptr && _unload_set_epoch_1->is_nonempty();\n-}\n-\n@@ -80,3 +73,1 @@\n-  if (is_nonempty_set(JfrTraceIdEpoch::previous())) {\n-    get_unload_set_previous_epoch()->clear();\n-  }\n+  get_unload_set_previous_epoch()->clear();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassUnloading.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -30,1 +30,0 @@\n-#include \"utilities\/resizableHashTable.hpp\"\n@@ -32,2 +31,2 @@\n-template <typename AllocPolicy = JfrCHeapObj, AnyObj::allocation_type AllocType = AnyObj::C_HEAP, MemTag memtag = mtTracing>\n-class ConfigTraceID : public AllStatic {\n+template <typename K, AnyObj::allocation_type AllocType = AnyObj::C_HEAP, MemTag memtag = mtTracing>\n+class JfrSetConfig : public AllStatic {\n@@ -35,2 +34,1 @@\n-  typedef AllocPolicy STORAGE;\n-  typedef traceid TYPE;\n+  typedef K KEY_TYPE;\n@@ -47,3 +45,3 @@\n-  static uint32_t hash(const TYPE& id) {\n-    const uint32_t v = static_cast<uint32_t>(id);\n-    return v * UINT32_C(2654435761);\n+  static uint32_t hash(const KEY_TYPE& key) {\n+    const uint32_t k = static_cast<uint32_t>(key);\n+    return k * UINT32_C(2654435761);\n@@ -52,1 +50,1 @@\n-  static bool cmp(const TYPE& lhs, const TYPE& rhs) {\n+  static bool cmp(const KEY_TYPE& lhs, const KEY_TYPE& rhs) {\n@@ -57,2 +55,0 @@\n-constexpr static unsigned int MAX_TABLE_SIZE = 0x3fffffff;\n-\n@@ -60,7 +56,16 @@\n-class JfrSet : public CONFIG::STORAGE {\n- public:\n-  typedef typename CONFIG::TYPE TYPE;\n-  typedef ResizeableHashTable<TYPE, TYPE, CONFIG::alloc_type(), CONFIG::memory_tag(), CONFIG::hash, CONFIG::cmp> HashMap;\n-\n-  constexpr static bool is_cheap() {\n-    return CONFIG::alloc_type() == AnyObj::C_HEAP;\n+class JfrSetStorage : public AnyObj {\n+  typedef typename CONFIG::KEY_TYPE K;\n+ protected:\n+  K* _table;\n+  unsigned _table_size;\n+  unsigned _elements;\n+\n+  static K* alloc_table(unsigned table_size) {\n+    K* table;\n+    if (CONFIG::alloc_type() == C_HEAP) {\n+      table = NEW_C_HEAP_ARRAY(K, table_size, CONFIG::memory_tag());\n+    } else {\n+      table = NEW_RESOURCE_ARRAY(K, table_size);\n+    }\n+    memset(table, 0, table_size * sizeof(K));\n+    return table;\n@@ -69,2 +74,4 @@\n-  JfrSet(unsigned int initial_size, unsigned int max_size = MAX_TABLE_SIZE) :\n-    _map(is_cheap() ? new (CONFIG::memory_tag()) HashMap(initial_size, max_size) : new HashMap(initial_size, max_size)) {}\n+  JfrSetStorage(unsigned table_size) :\n+    _table(alloc_table(table_size)),\n+    _table_size(table_size),\n+    _elements(0) {}\n@@ -72,3 +79,3 @@\n-  ~JfrSet() {\n-    if (is_cheap()) {\n-      delete _map;\n+  ~JfrSetStorage() {\n+    if (CONFIG::alloc_type() == C_HEAP) {\n+      FREE_C_HEAP_ARRAY(K, _table);\n@@ -78,4 +85,10 @@\n-  bool add(const TYPE& k) {\n-    bool inserted;\n-    _map->put_if_absent(k, &inserted);\n-    return inserted;\n+ public:\n+  template <typename Functor>\n+  void iterate(Functor& functor) {\n+    assert(is_nonempty(), \"invariant\");\n+    for (unsigned i = 0; i < _table_size; ++i) {\n+      K k = _table[i];\n+      if (k != 0) {\n+        functor(k);\n+      }\n+    }\n@@ -84,2 +97,2 @@\n-  bool remove(const TYPE& k) {\n-    return _map->remove(k);\n+  unsigned table_size() const {\n+    return _table_size;\n@@ -88,2 +101,2 @@\n-  bool contains(const TYPE& k) const {\n-    return _map->contains(k);\n+  unsigned size() const {\n+    return _elements;\n@@ -92,2 +105,2 @@\n-  bool is_empty() const {\n-    return _map->number_of_entries() == 0;\n+  bool is_nonempty() const {\n+    return _elements > 0;\n@@ -96,2 +109,2 @@\n-  bool is_nonempty() const {\n-    return !is_empty();\n+  void clear() {\n+    memset(_table, 0, _table_size * sizeof(K));\n@@ -99,0 +112,1 @@\n+};\n@@ -100,2 +114,11 @@\n-  int size() const {\n-    return _map->number_of_entries();\n+template <typename CONFIG>\n+class JfrSet : public JfrSetStorage<CONFIG> {\n+  typedef typename CONFIG::KEY_TYPE K;\n+  static_assert(sizeof(K) > 1, \"invalid size of CONFIG::KEY_TYPE\");\n+ private:\n+  static const constexpr unsigned max_initial_size = 1 << 30;\n+  unsigned _table_mask;\n+  unsigned _resize_threshold; \/\/ 0.5 load factor\n+\n+  uint32_t slot_idx(const uint32_t hash) const {\n+    return hash & _table_mask;\n@@ -104,3 +127,23 @@\n-  void clear() {\n-    if (is_nonempty()) {\n-      _map->unlink(this);\n+  void resize() {\n+    assert(this->_elements == _resize_threshold, \"invariant\");\n+    K* const old_table = this->_table;\n+    assert(old_table != nullptr, \"invariant\");\n+    const unsigned old_table_size = this->table_size();\n+    guarantee(old_table_size <= max_initial_size, \"overflow\");\n+    this->_table_size = old_table_size << 1;\n+    this->_table = JfrSetStorage<CONFIG>::alloc_table(this->_table_size);\n+    _table_mask = this->_table_size - 1;\n+    _resize_threshold = old_table_size;\n+    for (unsigned i = 0; i < old_table_size; ++i) {\n+      const K k = old_table[i];\n+      if (k != 0) {\n+        uint32_t idx = slot_idx(CONFIG::hash(k));\n+        do {\n+          K v = this->_table[idx];\n+          if (v == 0) {\n+            this->_table[idx] = k;\n+            break;\n+          }\n+          idx = slot_idx(idx + 1);\n+        } while (true);\n+      }\n@@ -108,1 +151,5 @@\n-    assert(is_empty(), \"invariant\");\n+    if (CONFIG::alloc_type() == AnyObj::C_HEAP) {\n+      FREE_C_HEAP_ARRAY(K, old_table);\n+    }\n+    assert(_table_mask + 1 == this->_table_size, \"invariant\");\n+    assert(_resize_threshold << 1 == this->_table_size, \"invariant\");\n@@ -111,3 +158,18 @@\n-  \/\/ Callback for node deletion, used by clear().\n-  bool do_entry(const TYPE& k, const TYPE& v) {\n-    return true;\n+  K* find_slot(K const& k) const {\n+    uint32_t idx = slot_idx(CONFIG::hash(k));\n+    assert(idx < this->table_size(), \"invariant\");\n+    K* result = nullptr;\n+    while (true) {\n+      K v = this->_table[idx];\n+      if (v == 0) {\n+        result = &this->_table[idx];\n+        break;\n+      }\n+      if (CONFIG::cmp(v, k)) {\n+        result = reinterpret_cast<K*>(p2i(&this->_table[idx]) | 1);\n+        break;\n+      }\n+      idx = slot_idx(idx + 1);\n+    }\n+    assert(result != nullptr, \"invariant\");\n+    return result;\n@@ -116,2 +178,29 @@\n- private:\n-  HashMap* _map;\n+ public:\n+  JfrSet(unsigned size) :\n+    JfrSetStorage<CONFIG>(size),\n+    _table_mask(size - 1),\n+    _resize_threshold(size >> 1) {\n+    assert(size >= 2, \"invariant\");\n+    assert(size % 2 == 0, \"invariant\");\n+    assert(size <= max_initial_size, \"avoid overflow in resize\");\n+  }\n+\n+  bool contains(K const& k) const {\n+    K* const slot = find_slot(k);\n+    return p2i(slot) & 1;\n+  }\n+\n+  bool add(K const& k) {\n+    K* const slot = find_slot(k);\n+    if (p2i(slot) & 1) {\n+      \/\/ Already exists.\n+      return false;\n+    }\n+    assert(*slot == 0, \"invariant\");\n+    *slot = k;\n+    if (++this->_elements == _resize_threshold) {\n+      resize();\n+    }\n+    assert(this->_elements < _resize_threshold, \"invariant\");\n+    return true;\n+  }\n@@ -120,2 +209,2 @@\n-typedef JfrSet<ConfigTraceID<> > JfrCHeapTraceIdSet;\n-typedef JfrSet<ConfigTraceID<ResourceObj, AnyObj::RESOURCE_AREA> > JfrResourceAreaTraceIdSet;\n+typedef JfrSet<JfrSetConfig<traceid> > JfrCHeapTraceIdSet;\n+typedef JfrSet<JfrSetConfig<traceid, AnyObj::RESOURCE_AREA> > JfrResourceAreaTraceIdSet;\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSet.hpp","additions":138,"deletions":49,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-  assert(Universe::objectArrayKlass() != nullptr, \"Too early?\");\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -188,1 +188,5 @@\n-  static ObjArrayKlass* objectArrayKlass()       { return _objectArrayKlass; }\n+  static ObjArrayKlass* objectArrayKlass() {\n+    ObjArrayKlass* k = _objectArrayKlass;\n+    assert(k != nullptr, \"Object array klass should be initialized; too early?\");\n+    return k;\n+  }\n@@ -190,1 +194,5 @@\n-  static Klass* fillerArrayKlass()               { return _fillerArrayKlass; }\n+  static Klass* fillerArrayKlass() {\n+    Klass* k = _fillerArrayKlass;\n+    assert(k != nullptr, \"Filler array class should be initialized; too early?\");\n+    return k;\n+  }\n@@ -195,2 +203,3 @@\n-    assert(_typeArrayKlasses[t] != nullptr, \"domain check\");\n-    return _typeArrayKlasses[t];\n+    TypeArrayKlass* k = _typeArrayKlasses[t];\n+    assert(k != nullptr, \"Type array class should be initialized; too early?\");\n+    return k;\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  bool match_mode_flag(MallocLimitMode* out) {\n+  bool match_mode(MallocLimitMode* out) {\n@@ -80,1 +80,1 @@\n-  \/\/ Check if string at position matches a category name.\n+  \/\/ Check if string at position matches a MemTag name.\n@@ -82,1 +82,1 @@\n-  bool match_category(MemTag* out) {\n+  bool match_mem_tag(MemTag* out) {\n@@ -133,1 +133,1 @@\n-void MallocLimitSet::set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode flag) {\n+void MallocLimitSet::set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode mode) {\n@@ -135,1 +135,1 @@\n-  _cat[i].sz = s; _cat[i].mode = flag;\n+  _mtag[i].sz = s; _mtag[i].mode = mode;\n@@ -147,1 +147,0 @@\n-  static const char* flagnames[] = { MODE_FATAL, MODE_OOM };\n@@ -153,1 +152,1 @@\n-      if (_cat[i].sz > 0) {\n+      if (_mtag[i].sz > 0) {\n@@ -156,1 +155,1 @@\n-                     PROPERFMTARGS(_cat[i].sz), mode_to_name(_cat[i].mode));\n+                     PROPERFMTARGS(_mtag[i].sz), mode_to_name(_mtag[i].mode));\n@@ -167,1 +166,1 @@\n-  \/\/ MallocLimit=<size>[:flag]\n+  \/\/ MallocLimit=<size>[:mode]\n@@ -169,2 +168,2 @@\n-  \/\/ Category-specific form:\n-  \/\/ MallocLimit=<category>:<size>[:flag][,<category>:<size>[:flag]...]\n+  \/\/ MemTag-specific form:\n+  \/\/ MallocLimit=<mem-tag>:<size>[:mode][,<mem-tag>:<size>[:mode]...]\n@@ -180,1 +179,1 @@\n-    \/\/ Match optional mode flag (e.g. 1g:oom)\n+    \/\/ Match optional mode  (e.g. 1g:oom)\n@@ -183,1 +182,1 @@\n-      BAIL_UNLESS(sst.match_mode_flag(&_glob.mode), \"Expected flag\");\n+      BAIL_UNLESS(sst.match_mode(&_glob.mode), \"Expected mode\");\n@@ -186,1 +185,1 @@\n-  \/\/ Category-specific form?\n+  \/\/ MemTag-specific form?\n@@ -191,2 +190,2 @@\n-      \/\/ Match category, followed by :\n-      BAIL_UNLESS(sst.match_category(&mem_tag), \"Expected category name\");\n+      \/\/ Match MemTag, followed by :\n+      BAIL_UNLESS(sst.match_mem_tag(&mem_tag), \"Expected category name\");\n@@ -195,1 +194,1 @@\n-      malloclimit* const modified_limit = &_cat[NMTUtil::tag_to_index(mem_tag)];\n+      malloclimit* const modified_limit = &_mtag[NMTUtil::tag_to_index(mem_tag)];\n@@ -200,1 +199,1 @@\n-      \/\/ Match optional flag\n+      \/\/ Match optional mode\n@@ -202,1 +201,1 @@\n-        BAIL_UNLESS(sst.match_mode_flag(&modified_limit->mode), \"Expected flag\");\n+        BAIL_UNLESS(sst.match_mode(&modified_limit->mode), \"Expected mode\");\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.cpp","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  malloclimit _cat[mt_number_of_tags]; \/\/ per-category limit\n+  malloclimit _mtag[mt_number_of_tags]; \/\/ per-memtag limit\n@@ -60,1 +60,1 @@\n-  const malloclimit* category_limit(MemTag mem_tag) const { return &_cat[(int)mem_tag]; }\n+  const malloclimit* mem_tag_limit(MemTag mem_tag) const { return &_mtag[(int)mem_tag]; }\n@@ -72,1 +72,1 @@\n-  static const malloclimit* category_limit(MemTag mem_tag) { return _limits.category_limit(mem_tag); }\n+  static const malloclimit* mem_tag_limit(MemTag mem_tag) { return _limits.mem_tag_limit(mem_tag); }\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -210,0 +210,6 @@\n+  if (ZapCHeap) {\n+    \/\/ To do this zapping, we need to know the block size.\n+    \/\/ This is why we have to do it here, and not in os::free.\n+    memset(memblock, freeBlockPad, header->size());\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-      \/\/ Category Limit?\n-      l = MallocLimitHandler::category_limit(mem_tag);\n+      \/\/ MemTag Limit?\n+      l = MallocLimitHandler::mem_tag_limit(mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+  if (_resolved_indy_entries == nullptr) {\n+    return 0;\n+  }\n","filename":"src\/hotspot\/share\/oops\/cpCache.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -669,0 +669,3 @@\n+  develop(bool, VerifyIntrinsicChecks, false,                               \\\n+          \"Verify in intrinsic that Java level checks work as expected\")    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -134,0 +134,2 @@\n+macro(CMoveVF)\n+macro(CMoveVD)\n@@ -158,0 +160,2 @@\n+macro(ConvHF2D)\n+macro(ConvD2HF)\n@@ -396,0 +400,1 @@\n+macro(AddReductionVHF)\n@@ -403,1 +408,1 @@\n-macro(SubVHF)\n+macro(SubVHF)\n@@ -420,1 +425,0 @@\n-macro(DivVHF)\n@@ -423,0 +427,1 @@\n+macro(DivVHF)\n@@ -429,0 +434,1 @@\n+macro(AbsVHF)\n@@ -433,0 +439,1 @@\n+macro(NegVHF)\n@@ -535,0 +542,2 @@\n+macro(VectorCastD2HF)\n+macro(VectorCastHF2D)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  ConvD2FNode(Node* in1) : ConvertNode(Type::FLOAT,in1) {}\n+  ConvD2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n@@ -73,0 +73,14 @@\n+\/\/------------------------------ConvD2HFNode------------------------------------\n+\/\/ Convert Double to Halffloat\n+class ConvD2HFNode : public ConvertNode {\n+  public:\n+  ConvD2HFNode(Node* in1) : ConvertNode(TypeInt::SHORT, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* in_type() const { return Type::DOUBLE; }\n+  \/*FIXME\n+   * virtual const Type* Value(PhaseGVN* phase) const;\n+   * virtual Node* Identity(PhaseGVN* phase);\n+   * virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+   *\/\n+};\n+\n@@ -77,1 +91,1 @@\n-  ConvD2INode(Node* in1) : ConvertNode(TypeInt::INT,in1) {}\n+  ConvD2INode(Node* in1) : ConvertNode(TypeInt::INT, in1) {}\n@@ -138,0 +152,13 @@\n+\/\/------------------------------ConvHF2DNode------------------------------------\n+\/\/ Convert Halffloat to Double\n+class ConvHF2DNode : public ConvertNode {\n+  public:\n+  ConvHF2DNode(Node* in1) : ConvertNode(Type::DOUBLE, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* in_type() const { return TypeInt::SHORT; }\n+  \/*\n+   * virtual const Type* Value(PhaseGVN* phase) const;\n+   * virtual Node* Identity(PhaseGVN* phase);\n+   *\/\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2312,7 +2312,9 @@\n-        assert(data->is_ReceiverTypeData(), \"bad profile data type\");\n-        ciReceiverTypeData* call = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n-        uint i = 0;\n-        for (; i < call->row_limit(); i++) {\n-          ciKlass* receiver = call->receiver(i);\n-          if (receiver != nullptr) {\n-            break;\n+        if (TypeProfileCasts) {\n+          assert(data->is_ReceiverTypeData(), \"bad profile data type\");\n+          ciReceiverTypeData* call = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n+          uint i = 0;\n+          for (; i < call->row_limit(); i++) {\n+            ciKlass* receiver = call->receiver(i);\n+            if (receiver != nullptr) {\n+              break;\n+            }\n@@ -2320,0 +2322,1 @@\n+          ptr_kind = (i == call->row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;\n@@ -2321,1 +2324,0 @@\n-        ptr_kind = (i == call->row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -942,1 +942,5 @@\n-void LibraryCallKit::generate_string_range_check(Node* array, Node* offset, Node* count, bool char_count) {\n+void LibraryCallKit::generate_string_range_check(Node* array,\n+                                                 Node* offset,\n+                                                 Node* count,\n+                                                 bool char_count,\n+                                                 bool halt_on_oob) {\n@@ -960,4 +964,11 @@\n-    PreserveJVMState pjvms(this);\n-    set_control(_gvn.transform(bailout));\n-    uncommon_trap(Deoptimization::Reason_intrinsic,\n-                  Deoptimization::Action_maybe_recompile);\n+    if (halt_on_oob) {\n+      bailout = _gvn.transform(bailout)->as_Region();\n+      Node* frame = _gvn.transform(new ParmNode(C->start(), TypeFunc::FramePtr));\n+      Node* halt = _gvn.transform(new HaltNode(bailout, frame, \"unexpected guard failure in intrinsic\"));\n+      C->root()->add_req(halt);\n+    } else {\n+      PreserveJVMState pjvms(this);\n+      set_control(_gvn.transform(bailout));\n+      uncommon_trap(Deoptimization::Reason_intrinsic,\n+                    Deoptimization::Action_maybe_recompile);\n+    }\n@@ -1121,0 +1132,1 @@\n+\/\/ int java.lang.StringCoding#countPositives0(byte[] ba, int off, int len)\n@@ -1132,6 +1144,6 @@\n-  ba = must_be_not_null(ba, true);\n-\n-  \/\/ Range checks\n-  generate_string_range_check(ba, offset, len, false);\n-  if (stopped()) {\n-    return true;\n+  if (VerifyIntrinsicChecks) {\n+    ba = must_be_not_null(ba, true);\n+    generate_string_range_check(ba, offset, len, false, true);\n+    if (stopped()) {\n+      return true;\n+    }\n@@ -1139,0 +1151,1 @@\n+\n@@ -3278,1 +3291,1 @@\n-  lease_result_value->init_req(_true_path, null()); \/\/ if the lease was returned, return 0.\n+  lease_result_value->init_req(_true_path, _gvn.longcon(0)); \/\/ if the lease was returned, return 0L.\n@@ -6131,0 +6144,3 @@\n+\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/ int java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/ int java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n@@ -6141,2 +6157,8 @@\n-  src = must_be_not_null(src, true);\n-  dst = must_be_not_null(dst, true);\n+  \/\/ Cast source & target arrays to not-null\n+  if (VerifyIntrinsicChecks) {\n+    src = must_be_not_null(src, true);\n+    dst = must_be_not_null(dst, true);\n+    if (stopped()) {\n+      return true;\n+    }\n+  }\n@@ -6159,0 +6181,9 @@\n+  \/\/ Check source & target bounds\n+  if (VerifyIntrinsicChecks) {\n+    generate_string_range_check(src, src_offset, length, src_elem == T_BYTE, true);\n+    generate_string_range_check(dst, dst_offset, length, false, true);\n+    if (stopped()) {\n+      return true;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -166,1 +166,2 @@\n-                                    Node* length, bool char_count);\n+                                    Node* length, bool char_count,\n+                                    bool halt_on_oob = false);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1633,0 +1633,58 @@\n+private:\n+  \/\/ Class to keep track of wins in split_thru_phi.\n+  class SplitThruPhiWins {\n+  private:\n+    \/\/ Region containing the phi we are splitting through.\n+    const Node* _region;\n+\n+    \/\/ Sum of all wins regardless of where they happen. This applies to Loops phis as well as non-loop phis.\n+    int _total_wins;\n+\n+    \/\/ For Loops, wins have different impact depending on if they happen on loop entry or on the backedge.\n+    \/\/ Number of wins on a loop entry edge if the split is through a loop head,\n+    \/\/ otherwise 0. Entry edge wins only pay dividends once on loop entry.\n+    int _loop_entry_wins;\n+    \/\/ Number of wins on a loop back-edge, which pay dividends on every iteration.\n+    int _loop_back_wins;\n+\n+  public:\n+    SplitThruPhiWins(const Node* region) :\n+      _region(region),\n+      _total_wins(0),\n+      _loop_entry_wins(0),\n+      _loop_back_wins(0) {};\n+\n+    void reset() {_total_wins = 0; _loop_entry_wins = 0; _loop_back_wins = 0;}\n+    void add_win(int ctrl_index) {\n+      if (_region->is_Loop() && ctrl_index == LoopNode::EntryControl) {\n+        _loop_entry_wins++;\n+      } else if (_region->is_Loop() && ctrl_index == LoopNode::LoopBackControl) {\n+        _loop_back_wins++;\n+      }\n+      _total_wins++;\n+    }\n+    \/\/ Is this split profitable with respect to the policy?\n+    bool profitable(int policy) const {\n+      assert(_region->is_Loop() || (_loop_entry_wins == 0 && _loop_back_wins == 0), \"wins on loop edges without a loop\");\n+      assert(!_region->is_Loop() || _total_wins == _loop_entry_wins + _loop_back_wins, \"missed some win\");\n+      \/\/ In general this means that the split has to have more wins than specified\n+      \/\/ in the policy. However, for loops we need to take into account where the\n+      \/\/ wins happen. We need to be careful when splitting, because splitting nodes\n+      \/\/ related to the iv through the phi can sufficiently rearrange the loop\n+      \/\/ structure to prevent RCE and thus vectorization. Thus, we only deem splitting\n+      \/\/ profitable if the win of a split is not on the entry edge, as such wins\n+      \/\/ only pay off once and have a high chance of messing up the loop structure.\n+      return (_loop_entry_wins == 0 && _total_wins > policy) ||\n+      \/\/ If there are wins on the entry edge but the backadge also has sufficient wins,\n+      \/\/ there is sufficient profitability to spilt regardless of the risk of messing\n+      \/\/ up the loop structure.\n+             _loop_back_wins > policy ||\n+      \/\/ If the policy is less than 0, a split is always profitable, i.e. we always\n+      \/\/ split. This is needed when we split a node and then must also split a\n+      \/\/ dependant node, i.e. spliting a Bool node after splitting a Cmp node.\n+             policy < 0;\n+    }\n+  };\n+\n+public:\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -69,1 +70,1 @@\n-  int wins = 0;\n+  SplitThruPhiWins wins(region);\n@@ -122,1 +123,1 @@\n-      wins++;\n+      wins.add_win(i);\n@@ -137,1 +138,1 @@\n-        wins++;\n+        wins.add_win(i);\n@@ -145,1 +146,1 @@\n-          wins++;\n+          wins.add_win(i);\n@@ -168,1 +169,1 @@\n-      wins = 0;\n+      wins.reset();\n@@ -173,1 +174,1 @@\n-  if (wins <= policy) {\n+  if (!wins.profitable(policy)) {\n@@ -230,0 +231,7 @@\n+#ifndef PRODUCT\n+  if (TraceLoopOpts) {\n+    tty->print(\"Split %d %s through %d Phi in %d %s\",\n+               n->_idx, n->Name(), phi->_idx, region->_idx, region->Name());\n+  }\n+#endif \/\/ !PRODUCT\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  ciField* fd1 = ik->get_field_by_name(ciSymbols::ETYPE_name(), ciSymbols::class_signature(), \/* is_static *\/ true);\n+  ciField* fd1 = ik->get_field_by_name(ciSymbols::CTYPE_name(), ciSymbols::class_signature(), \/* is_static *\/ true);\n@@ -290,14 +290,30 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V unaryOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<E> elementType,\n-\/\/           int length, V v, M m,\n-\/\/           UnaryOperation<V, M> defaultImpl)\n-\/\/ public static\n-\/\/ <V,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V binaryOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<E> elementType,\n-\/\/            int length, V v1, V v2, M m,\n-\/\/            BinaryOperation<V, M> defaultImpl)\n+\/\/  public static\n+\/\/  <V extends Vector<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  V unaryOp(int oprId,\n+\/\/            Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/            int length,\n+\/\/            V v, M m,\n+\/\/            UnaryOperation<V, M> defaultImpl) {\n+\/\/\n+\/\/  public static\n+\/\/  <VM extends VectorPayload,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  VM binaryOp(int oprId,\n+\/\/              Class<? extends VM> vmClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/              int length,\n+\/\/              VM v1, VM v2, M m,\n+\/\/              BinaryOperation<VM, M> defaultImpl) {\n+\/\/\n+\/\/\n+\/\/  public static\n+\/\/  <V extends Vector<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  V ternaryOp(int oprId,\n+\/\/              Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/              int length,\n+\/\/              V v1, V v2, V v3, M m,\n+\/\/              TernaryOperation<V, M> defaultImpl) {\n@@ -306,7 +322,0 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V ternaryOp(int oprId, Class<? extends V> vmClass, Class<? extends M> maskClass, Class<E> elementType,\n-\/\/             int length, V v1, V v2, V v3, M m,\n-\/\/             TernaryOperation<V, M> defaultImpl)\n@@ -319,1 +328,1 @@\n-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();\n@@ -345,1 +354,1 @@\n-  const Type* vmask_type = gvn().type(argument(n + 5));\n+  const Type* vmask_type = gvn().type(argument(n + 7));\n@@ -404,1 +413,1 @@\n-      opd3 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n+      opd3 = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);\n@@ -413,1 +422,1 @@\n-      opd2 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n+      opd2 = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);\n@@ -422,1 +431,1 @@\n-      opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+      opd1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n@@ -438,1 +447,1 @@\n-    mask = unbox_vector(argument(n + 5), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(argument(n + 7), mbox_type, elem_bt, num_elem);\n@@ -441,1 +450,1 @@\n-                      NodeClassNames[argument(n + 5)->Opcode()]);\n+                      NodeClassNames[argument(n + 7)->Opcode()]);\n@@ -480,5 +489,0 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>, E>\n-\/\/ V libraryUnaryOp(long address, Class<? extends V> vClass, Class<E> elementType, int length, String debugName,\n-\/\/                  V v,\n-\/\/                  UnaryOperation<V, ?> defaultImpl)\n@@ -486,5 +490,12 @@\n-\/\/ public static\n-\/\/ <V extends VectorPayload, E>\n-\/\/ V libraryBinaryOp(long address, Class<? extends V> vClass, Class<E> elementType, int length, String debugName,\n-\/\/            V v1, V v2,\n-\/\/            BinaryOperation<V, ?> defaultImpl)\n+\/\/  public static\n+\/\/  <V extends Vector<E>, E>\n+\/\/  V libraryUnaryOp(long addr, Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType, int length, String debugName,\n+\/\/                   V v,\n+\/\/                   UnaryOperation<V,?> defaultImpl)\n+\/\/\n+\/\/  public static\n+\/\/  <V extends VectorPayload, E>\n+\/\/  V libraryBinaryOp(long addr, Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType, int length, String debugName,\n+\/\/                    V v1, V v2,\n+\/\/                    BinaryOperation<V,?> defaultImpl)\n+\/\/\n@@ -497,2 +508,2 @@\n-  const TypeInt*     vlen           = gvn().type(argument(4))->isa_int();\n-  const TypeInstPtr* debug_name_oop = gvn().type(argument(5))->isa_instptr();\n+  const TypeInt*     vlen           = gvn().type(argument(6))->isa_int();\n+  const TypeInstPtr* debug_name_oop = gvn().type(argument(7))->isa_instptr();\n@@ -509,2 +520,2 @@\n-                  NodeClassNames[argument(4)->Opcode()],\n-                  NodeClassNames[argument(5)->Opcode()]);\n+                  NodeClassNames[argument(6)->Opcode()],\n+                  NodeClassNames[argument(7)->Opcode()]);\n@@ -540,1 +551,1 @@\n-  Node* opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n+  Node* opd1 = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);\n@@ -542,1 +553,1 @@\n-    log_if_needed(\"  ** unbox failed v1=%s\", NodeClassNames[argument(6)->Opcode()]);\n+    log_if_needed(\"  ** unbox failed v1=%s\", NodeClassNames[argument(8)->Opcode()]);\n@@ -548,1 +559,1 @@\n-    opd2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n+    opd2 = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);\n@@ -550,1 +561,1 @@\n-      log_if_needed(\"  ** unbox failed v2=%s\", NodeClassNames[argument(7)->Opcode()]);\n+      log_if_needed(\"  ** unbox failed v2=%s\", NodeClassNames[argument(9)->Opcode()]);\n@@ -582,3 +593,10 @@\n-\/\/ <E, M>\n-\/\/ long maskReductionCoerced(int oper, Class<? extends M> maskClass, Class<?> elemClass,\n-\/\/                          int length, M m, VectorMaskOp<M> defaultImpl)\n+\/\/\n+\/\/  public static\n+\/\/  <M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  long maskReductionCoerced(int oper,\n+\/\/                            Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/                            int length,\n+\/\/                            M m,\n+\/\/                            VectorMaskOp<M> defaultImpl)\n+\/\/\n@@ -589,2 +607,2 @@\n-  const TypeInt*     vlen       = gvn().type(argument(3))->isa_int();\n-  Node*              mask       = argument(4);\n+  const TypeInt*     vlen       = gvn().type(argument(5))->isa_int();\n+  Node*              mask       = argument(6);\n@@ -607,0 +625,6 @@\n+  if (!elem_type->is_primitive_type()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    }\n+    return false; \/\/ should be primitive type\n+  }\n@@ -621,1 +645,1 @@\n-                      NodeClassNames[argument(4)->Opcode()]);\n+                      NodeClassNames[argument(6)->Opcode()]);\n@@ -639,7 +663,10 @@\n-\/\/ public static\n-\/\/ <M,\n-\/\/  S extends VectorSpecies<E>,\n-\/\/  E>\n-\/\/ M fromBitsCoerced(Class<? extends M> vmClass, Class<E> elementType, int length,\n-\/\/                    long bits, int mode, S s,\n-\/\/                    BroadcastOperation<M, E, S> defaultImpl)\n+\/\/\n+\/\/  public static\n+\/\/  <VM extends VectorPayload,\n+\/\/   S extends VectorSpecies<E>,\n+\/\/   E>\n+\/\/  VM fromBitsCoerced(Class<? extends VM> vmClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/                     int length,\n+\/\/                     long bits, int mode, S s,\n+\/\/                     FromBitsCoercedOperation<VM, S> defaultImpl)\n+\/\/\n@@ -649,2 +676,2 @@\n-  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n-  const TypeLong*    bits_type    = gvn().type(argument(3))->isa_long();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeLong*    bits_type    = gvn().type(argument(5))->isa_long();\n@@ -654,1 +681,1 @@\n-  const TypeInt*     mode         = gvn().type(argument(5))->isa_int();\n+  const TypeInt*     mode         = gvn().type(argument(7))->isa_int();\n@@ -664,2 +691,2 @@\n-                    NodeClassNames[argument(2)->Opcode()],\n-                    NodeClassNames[argument(5)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()],\n+                    NodeClassNames[argument(7)->Opcode()]);\n@@ -706,1 +733,1 @@\n-  Node* bits = argument(3);\n+  Node* bits = argument(5);\n@@ -769,0 +796,1 @@\n+\/\/\n@@ -774,1 +802,1 @@\n-\/\/  VM load(Class<? extends VM> vmClass, Class<E> eClass,\n+\/\/  VM load(Class<? extends VM> vmClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -776,4 +804,5 @@\n-\/\/          Object base, long offset,            \/\/ Unsafe addressing\n-\/\/          boolean fromSegment,\n-\/\/          C container, long index, S s,        \/\/ Arguments for default implementation\n-\/\/          LoadOperation<C, VM, S> defaultImpl) {\n+\/\/          Object base, long offset, boolean fromSegment,\n+\/\/          C container, long index, S s,\n+\/\/          LoadOperation<C, VM, S> defaultImpl)\n+\/\/\n+\/\/\n@@ -783,1 +812,1 @@\n-\/\/  void store(Class<?> vClass, Class<?> eClass,\n+\/\/  void store(Class<?> vClass, Class<?> cClass, Class<?> eClass, int operType,\n@@ -785,4 +814,4 @@\n-\/\/             Object base, long offset,        \/\/ Unsafe addressing\n-\/\/             boolean fromSegment,\n-\/\/             V v, C container, long index,    \/\/ Arguments for default implementation\n-\/\/             StoreVectorOperation<C, V> defaultImpl) {\n+\/\/             Object base, long offset, boolean fromSegment,\n+\/\/             V v, C container, long index,\n+\/\/             StoreVectorOperation<C, V> defaultImpl)\n+\/\/\n@@ -792,2 +821,2 @@\n-  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n-  const TypeInt*     from_ms      = gvn().type(argument(6))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     from_ms      = gvn().type(argument(8))->isa_int();\n@@ -802,2 +831,2 @@\n-                    NodeClassNames[argument(2)->Opcode()],\n-                    NodeClassNames[argument(6)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()],\n+                    NodeClassNames[argument(8)->Opcode()]);\n@@ -830,2 +859,2 @@\n-  Node* base = argument(3);\n-  Node* offset = ConvL2X(argument(4));\n+  Node* base = argument(5);\n+  Node* offset = ConvL2X(argument(6));\n@@ -913,1 +942,1 @@\n-    Node* val = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n+    Node* val = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);\n@@ -961,0 +990,1 @@\n+\/\/\n@@ -967,3 +997,2 @@\n-\/\/  V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n-\/\/               int length, Object base, long offset,          \/\/ Unsafe addressing\n-\/\/               boolean fromSegment,\n+\/\/  V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/               int length, Object base, long offset, boolean fromSegment,\n@@ -971,2 +1000,3 @@\n-\/\/               C container, long index, S s,                  \/\/ Arguments for default implementation\n-\/\/               LoadVectorMaskedOperation<C, V, S, M> defaultImpl) {\n+\/\/               C container, long index, S s,\n+\/\/               LoadVectorMaskedOperation<C, V, S, M> defaultImpl)\n+\/\/\n@@ -978,1 +1008,1 @@\n-\/\/  void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+\/\/  void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -980,4 +1010,4 @@\n-\/\/                   Object base, long offset,                  \/\/ Unsafe addressing\n-\/\/                   boolean fromSegment,\n-\/\/                   V v, M m, C container, long index,         \/\/ Arguments for default implementation\n-\/\/                   StoreVectorMaskedOperation<C, V, M> defaultImpl) {\n+\/\/                   Object base, long offset, boolean fromSegment,\n+\/\/                   V v, M m, C container, long index,\n+\/\/                   StoreVectorMaskedOperation<C, V, M> defaultImpl)\n+\/\/\n@@ -989,2 +1019,2 @@\n-  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n-  const TypeInt*     from_ms      = gvn().type(argument(7))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();\n+  const TypeInt*     from_ms      = gvn().type(argument(9))->isa_int();\n@@ -1001,2 +1031,2 @@\n-                    NodeClassNames[argument(3)->Opcode()],\n-                    NodeClassNames[argument(7)->Opcode()]);\n+                    NodeClassNames[argument(5)->Opcode()],\n+                    NodeClassNames[argument(9)->Opcode()]);\n@@ -1024,2 +1054,2 @@\n-  Node* base = argument(4);\n-  Node* offset = ConvL2X(argument(5));\n+  Node* base = argument(6);\n+  Node* offset = ConvL2X(argument(7));\n@@ -1058,1 +1088,1 @@\n-      const TypeInt* offset_in_range = gvn().type(argument(9))->isa_int();\n+      const TypeInt* offset_in_range = gvn().type(argument(11))->isa_int();\n@@ -1061,1 +1091,1 @@\n-                        NodeClassNames[argument(8)->Opcode()]);\n+                        NodeClassNames[argument(10)->Opcode()]);\n@@ -1116,1 +1146,1 @@\n-  Node* mask = unbox_vector(is_store ? argument(9) : argument(8), mbox_type, elem_bt, num_elem);\n+  Node* mask = unbox_vector(is_store ? argument(11) : argument(10), mbox_type, elem_bt, num_elem);\n@@ -1119,2 +1149,2 @@\n-                    is_store ? NodeClassNames[argument(9)->Opcode()]\n-                             : NodeClassNames[argument(8)->Opcode()]);\n+                    is_store ? NodeClassNames[argument(11)->Opcode()]\n+                             : NodeClassNames[argument(10)->Opcode()]);\n@@ -1125,1 +1155,1 @@\n-    Node* val = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);\n+    Node* val = unbox_vector(argument(10), vbox_type, elem_bt, num_elem);\n@@ -1128,1 +1158,1 @@\n-                      NodeClassNames[argument(8)->Opcode()]);\n+                      NodeClassNames[argument(10)->Opcode()]);\n@@ -1185,0 +1215,1 @@\n+\/\/  public static\n@@ -1191,7 +1222,8 @@\n-\/\/   V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,\n-\/\/                 Class<? extends Vector<Integer>> vectorIndexClass, int indexLength,\n-\/\/                 Object base, long offset,\n-\/\/                 W indexVector1, W indexVector2, W indexVector3, W indexVector4,\n-\/\/                 M m, C container, int index, int[] indexMap, int indexM, S s,\n-\/\/                 LoadVectorOperationWithMap<C, V, S, M> defaultImpl)\n-\/\/\n+\/\/  V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/                int length,\n+\/\/                Class<? extends Vector<Integer>> vectorIndexClass,\n+\/\/                int indexLength, Object base, long offset,\n+\/\/                W indexVector1, W indexVector2, W indexVector3, W indexVector4,\n+\/\/                M m, C container, int index, int[] indexMap, int indexM, S s,\n+\/\/                LoadVectorOperationWithMap<C, V, S, M> defaultImpl)\n+\/\/  public static\n@@ -1204,6 +1236,8 @@\n-\/\/   void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,\n-\/\/                     Class<? extends Vector<Integer>> vectorIndexClass, int indexLength,\n-\/\/                     Object base, long offset, \/\/ Unsafe addressing\n-\/\/                     W indexVector, V v, M m,\n-\/\/                     C container, int index, int[] indexMap, int indexM, \/\/ Arguments for default implementation\n-\/\/                     StoreVectorOperationWithMap<C, V, M> defaultImpl)\n+\/\/  void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/                    int length,\n+\/\/                    Class<? extends Vector<Integer>> vectorIndexClass,\n+\/\/                    int indexLength, Object base, long offset,\n+\/\/                    W indexVector,\n+\/\/                    V v, M m, C container, int index, int[] indexMap, int indexM,\n+\/\/                    StoreVectorOperationWithMap<C, V, M> defaultImpl)\n+\/\/\n@@ -1215,3 +1249,3 @@\n-  const TypeInt*     vlen             = gvn().type(argument(3))->isa_int();\n-  const TypeInstPtr* vector_idx_klass = gvn().type(argument(4))->isa_instptr();\n-  const TypeInt*     idx_vlen         = gvn().type(argument(5))->isa_int();\n+  const TypeInt*     vlen             = gvn().type(argument(5))->isa_int();\n+  const TypeInstPtr* vector_idx_klass = gvn().type(argument(6))->isa_instptr();\n+  const TypeInt*     idx_vlen         = gvn().type(argument(7))->isa_int();\n@@ -1227,3 +1261,3 @@\n-                    NodeClassNames[argument(3)->Opcode()],\n-                    NodeClassNames[argument(4)->Opcode()],\n-                    NodeClassNames[argument(5)->Opcode()]);\n+                    NodeClassNames[argument(5)->Opcode()],\n+                    NodeClassNames[argument(6)->Opcode()],\n+                    NodeClassNames[argument(7)->Opcode()]);\n@@ -1248,1 +1282,1 @@\n-  Node* m = is_scatter ? argument(11) : argument(13);\n+  Node* m = is_scatter ? argument(13) : argument(15);\n@@ -1294,2 +1328,2 @@\n-  Node* base = argument(6);\n-  Node* offset = ConvL2X(argument(7));\n+  Node* base = argument(8);\n+  Node* offset = ConvL2X(argument(9));\n@@ -1308,1 +1342,1 @@\n-    Node* index = argument(15);\n+    Node* index = argument(17);\n@@ -1334,2 +1368,2 @@\n-    Node* indexMap = argument(16);\n-    Node* indexM   = argument(17);\n+    Node* indexMap = argument(18);\n+    Node* indexM   = argument(19);\n@@ -1339,1 +1373,1 @@\n-    indexes = unbox_vector(argument(9), vbox_idx_type, T_INT, idx_num_elem);\n+    indexes = unbox_vector(argument(11), vbox_idx_type, T_INT, idx_num_elem);\n@@ -1359,1 +1393,1 @@\n-    Node* val = unbox_vector(argument(10), vbox_type, elem_bt, num_elem);\n+    Node* val = unbox_vector(argument(12), vbox_type, elem_bt, num_elem);\n@@ -1388,7 +1422,11 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ long reductionCoerced(int oprId, Class<? extends V> vectorClass, Class<? extends M> maskClass,\n-\/\/                       Class<E> elementType, int length, V v, M m,\n-\/\/                       ReductionOperation<V, M> defaultImpl)\n+\/\/\n+\/\/  public static\n+\/\/  <V extends Vector<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  long reductionCoerced(int oprId,\n+\/\/                        Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/                        int length,\n+\/\/                        V v, M m,\n+\/\/                        ReductionOperation<V, M> defaultImpl)\n+\/\/\n@@ -1400,1 +1438,1 @@\n-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();\n@@ -1423,1 +1461,1 @@\n-  const Type* vmask_type = gvn().type(argument(6));\n+  const Type* vmask_type = gvn().type(argument(8));\n@@ -1427,1 +1465,1 @@\n-      log_if_needed(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(2)->Opcode()]);\n+      log_if_needed(\"  ** missing constant: maskclass=%s\", NodeClassNames[argument(4)->Opcode()]);\n@@ -1466,1 +1504,1 @@\n-  Node* opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  Node* opd = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n@@ -1476,1 +1514,1 @@\n-    mask = unbox_vector(argument(6), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);\n@@ -1479,1 +1517,1 @@\n-                      NodeClassNames[argument(6)->Opcode()]);\n+                      NodeClassNames[argument(8)->Opcode()]);\n@@ -1532,3 +1570,12 @@\n-\/\/ public static <V> boolean test(int cond, Class<?> vectorClass, Class<?> elementType, int vlen,\n-\/\/                                V v1, V v2,\n-\/\/                                BiFunction<V, V, Boolean> defaultImpl)\n+\n+\n+\/\/\n+\/\/  public static\n+\/\/  <M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  boolean test(int cond,\n+\/\/               Class<?> mClass, Class<?> cClass, Class<E> eClass, int opType,\n+\/\/               int length,\n+\/\/               M m1, M m2,\n+\/\/               BiFunction<M, M, Boolean> defaultImpl)\n+\/\/\n@@ -1540,1 +1587,1 @@\n-  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();\n@@ -1550,1 +1597,1 @@\n-                    NodeClassNames[argument(3)->Opcode()]);\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -1575,1 +1622,1 @@\n-  Node* opd1 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n+  Node* opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n@@ -1579,1 +1626,1 @@\n-    opd2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+    opd2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n@@ -1598,7 +1645,10 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V blend(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType, int vlen,\n-\/\/         V v1, V v2, M m,\n-\/\/         VectorBlendOp<V, M, E> defaultImpl)\n+\/\/\n+\/\/  public static\n+\/\/  <V extends Vector<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  V blend(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/          int length,\n+\/\/          V v1, V v2, M m,\n+\/\/          VectorBlendOp<V, M> defaultImpl)\n+\/\/\n@@ -1609,1 +1659,1 @@\n-  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(5))->isa_int();\n@@ -1620,1 +1670,1 @@\n-                    NodeClassNames[argument(3)->Opcode()]);\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -1647,3 +1697,3 @@\n-  Node* v1   = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n-  Node* v2   = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n-  Node* mask = unbox_vector(argument(6), mbox_type, mask_bt, num_elem);\n+  Node* v1   = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n+  Node* v2   = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n+  Node* mask = unbox_vector(argument(8), mbox_type, mask_bt, num_elem);\n@@ -1663,0 +1713,2 @@\n+\n+\/\/\n@@ -1667,1 +1719,3 @@\n-\/\/  M compare(int cond, Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType, int vlen,\n+\/\/  M compare(int cond,\n+\/\/            Class<? extends V> vectorClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/            int length,\n@@ -1669,1 +1723,2 @@\n-\/\/            VectorCompareOp<V,M> defaultImpl)\n+\/\/            VectorCompareOp<V, M> defaultImpl)\n+\/\/\n@@ -1675,1 +1730,1 @@\n-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();\n@@ -1687,1 +1742,1 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(6)->Opcode()]);\n@@ -1724,2 +1779,2 @@\n-  Node* v1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n-  Node* v2 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n+  Node* v1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n+  Node* v2 = unbox_vector(argument(8), vbox_type, elem_bt, num_elem);\n@@ -1727,2 +1782,2 @@\n-  bool is_masked_op = argument(7)->bottom_type() != TypePtr::NULL_PTR;\n-  Node* mask = is_masked_op ? unbox_vector(argument(7), mbox_type, elem_bt, num_elem) : nullptr;\n+  bool is_masked_op = argument(9)->bottom_type() != TypePtr::NULL_PTR;\n+  Node* mask = is_masked_op ? unbox_vector(argument(9), mbox_type, elem_bt, num_elem) : nullptr;\n@@ -1769,8 +1824,11 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  Sh extends VectorShuffle<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V rearrangeOp(Class<? extends V> vectorClass, Class<Sh> shuffleClass, Class<M> maskClass, Class<E> elementType, int vlen,\n-\/\/               V v1, Sh sh, M m,\n-\/\/               VectorRearrangeOp<V, Sh, M, E> defaultImpl)\n+\/\/\n+\/\/  public static\n+\/\/  <V extends Vector<E>,\n+\/\/   SH extends VectorShuffle<E>,\n+\/\/   M  extends VectorMask<E>,\n+\/\/   E>\n+\/\/  V rearrangeOp(Class<? extends V> vClass, Class<SH> shClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/                int length,\n+\/\/                V v, SH sh, M m,\n+\/\/                VectorRearrangeOp<V, SH, M> defaultImpl)\n+\/\/\n@@ -1782,1 +1840,1 @@\n-  const TypeInt*     vlen          = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen          = gvn().type(argument(6))->isa_int();\n@@ -1795,1 +1853,1 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(6)->Opcode()]);\n@@ -1828,1 +1886,1 @@\n-  bool is_masked_op = argument(7)->bottom_type() != TypePtr::NULL_PTR;\n+  bool is_masked_op = argument(9)->bottom_type() != TypePtr::NULL_PTR;\n@@ -1859,2 +1917,2 @@\n-  Node* v1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n-  Node* shuffle = unbox_vector(argument(6), shbox_type, shuffle_bt, num_elem);\n+  Node* v1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n+  Node* shuffle = unbox_vector(argument(8), shbox_type, shuffle_bt, num_elem);\n@@ -1876,1 +1934,1 @@\n-    mask = unbox_vector(argument(7), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(argument(9), mbox_type, elem_bt, num_elem);\n@@ -1908,7 +1966,9 @@\n-\/\/    public static\n-\/\/    <V extends Vector<E>,\n-\/\/     M  extends VectorMask<E>,\n-\/\/     E>\n-\/\/    V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n-\/\/                   int length, V v1, V v2, M m,\n-\/\/                   VectorSelectFromOp<V, M> defaultImpl)\n+\/\/\n+\/\/  public static\n+\/\/  <V extends Vector<E>,\n+\/\/   M  extends VectorMask<E>,\n+\/\/   E>\n+\/\/  V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/                 int length, V v1, V v2, M m,\n+\/\/                 VectorSelectFromOp<V, M> defaultImpl)\n+\/\/\n@@ -1919,1 +1979,1 @@\n-  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     vlen          = gvn().type(argument(5))->isa_int();\n@@ -1928,1 +1988,1 @@\n-                    NodeClassNames[argument(3)->Opcode()]);\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -1965,1 +2025,1 @@\n-  bool is_masked_op = argument(6)->bottom_type() != TypePtr::NULL_PTR;\n+  bool is_masked_op = argument(8)->bottom_type() != TypePtr::NULL_PTR;\n@@ -1990,1 +2050,1 @@\n-  Node* v1 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n+  Node* v1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n@@ -1992,1 +2052,1 @@\n-  Node* v2 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  Node* v2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n@@ -1995,1 +2055,1 @@\n-    log_if_needed(\"  ** unbox failed v1=%s\", NodeClassNames[argument(4)->Opcode()]);\n+    log_if_needed(\"  ** unbox failed v1=%s\", NodeClassNames[argument(6)->Opcode()]);\n@@ -2000,1 +2060,1 @@\n-    log_if_needed(\"  ** unbox failed v2=%s\", NodeClassNames[argument(5)->Opcode()]);\n+    log_if_needed(\"  ** unbox failed v2=%s\", NodeClassNames[argument(7)->Opcode()]);\n@@ -2008,1 +2068,1 @@\n-    mask = unbox_vector(argument(6), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);\n@@ -2010,1 +2070,1 @@\n-      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[argument(6)->Opcode()]);\n+      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[argument(8)->Opcode()]);\n@@ -2064,8 +2124,11 @@\n-\/\/  public static\n-\/\/  <V extends Vector<E>,\n-\/\/   M extends VectorMask<E>,\n-\/\/   E>\n-\/\/  V broadcastInt(int opr, Class<? extends V> vectorClass, Class<? extends M> maskClass,\n-\/\/                 Class<E> elementType, int length,\n-\/\/                 V v, int n, M m,\n-\/\/                 VectorBroadcastIntOp<V, M> defaultImpl)\n+\/\/\n+\/\/    public static\n+\/\/    <V extends Vector<E>,\n+\/\/     M extends VectorMask<E>,\n+\/\/     E>\n+\/\/    V broadcastInt(int opr,\n+\/\/                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/                   int length,\n+\/\/                   V v, int n, M m,\n+\/\/                   VectorBroadcastIntOp<V, M> defaultImpl) {\n+\/\/\n@@ -2077,1 +2140,1 @@\n-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();\n@@ -2087,1 +2150,1 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(6)->Opcode()]);\n@@ -2095,1 +2158,1 @@\n-  const Type* vmask_type = gvn().type(argument(7));\n+  const Type* vmask_type = gvn().type(argument(8));\n@@ -2138,1 +2201,1 @@\n-  Node* cnt  = argument(6);\n+  Node* cnt  = argument(8);\n@@ -2164,1 +2227,1 @@\n-  Node* opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  Node* opd1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n@@ -2187,1 +2250,1 @@\n-    mask = unbox_vector(argument(7), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(argument(9), mbox_type, elem_bt, num_elem);\n@@ -2189,1 +2252,1 @@\n-      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[argument(7)->Opcode()]);\n+      log_if_needed(\"  ** unbox failed mask=%s\", NodeClassNames[argument(9)->Opcode()]);\n@@ -2406,0 +2469,1 @@\n+\/\/\n@@ -2409,2 +2473,3 @@\n-\/\/  V insert(Class<? extends V> vectorClass, Class<E> elementType, int vlen,\n-\/\/           V vec, int ix, long val,\n+\/\/  V insert(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/           int length,\n+\/\/           V v, int i, long val,\n@@ -2412,0 +2477,1 @@\n+\/\/\n@@ -2415,2 +2481,2 @@\n-  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n-  const TypeInt*     idx          = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     idx          = gvn().type(argument(6))->isa_int();\n@@ -2425,2 +2491,2 @@\n-                    NodeClassNames[argument(2)->Opcode()],\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()],\n+                    NodeClassNames[argument(6)->Opcode()]);\n@@ -2449,1 +2515,1 @@\n-  Node* opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+  Node* opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n@@ -2454,1 +2520,1 @@\n-  Node* insert_val = argument(5);\n+  Node* insert_val = argument(7);\n@@ -2489,0 +2555,1 @@\n+\/\/\n@@ -2492,1 +2559,1 @@\n-\/\/  long extract(Class<? extends VM> vClass, Class<E> eClass,\n+\/\/  long extract(Class<? extends VM> vClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -2496,0 +2563,1 @@\n+\/\/\n@@ -2499,2 +2567,2 @@\n-  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n-  const TypeInt*     idx          = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     idx          = gvn().type(argument(6))->isa_int();\n@@ -2532,1 +2600,1 @@\n-    Node* pos = argument(4); \/\/ can be variable\n+    Node* pos = argument(6); \/\/ can be variable\n@@ -2535,1 +2603,1 @@\n-      opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+      opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n@@ -2543,1 +2611,1 @@\n-      opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+      opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n@@ -2562,1 +2630,1 @@\n-      log_if_needed(\"  ** missing constant: idx=%s\", NodeClassNames[argument(4)->Opcode()]);\n+      log_if_needed(\"  ** missing constant: idx=%s\", NodeClassNames[argument(6)->Opcode()]);\n@@ -2573,1 +2641,1 @@\n-    opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+    opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n@@ -2673,0 +2741,1 @@\n+\/\/\n@@ -2676,1 +2745,1 @@\n-\/\/  V selectFromTwoVectorOp(Class<? extends V> vClass, Class<E> eClass, int length,\n+\/\/  V selectFromTwoVectorOp(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType, int length,\n@@ -2679,0 +2748,1 @@\n+\/\/\n@@ -2682,1 +2752,1 @@\n-  const TypeInt* vlen = gvn().type(argument(2))->isa_int();\n+  const TypeInt* vlen = gvn().type(argument(4))->isa_int();\n@@ -2689,1 +2759,1 @@\n-                    NodeClassNames[argument(2)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()]);\n@@ -2754,1 +2824,1 @@\n-  Node* opd1 = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+  Node* opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n@@ -2757,1 +2827,1 @@\n-                  NodeClassNames[argument(3)->Opcode()]);\n+                  NodeClassNames[argument(5)->Opcode()]);\n@@ -2760,1 +2830,1 @@\n-  Node* opd2 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n+  Node* opd2 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n@@ -2763,1 +2833,1 @@\n-                  NodeClassNames[argument(4)->Opcode()]);\n+                  NodeClassNames[argument(6)->Opcode()]);\n@@ -2766,1 +2836,1 @@\n-  Node* opd3 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  Node* opd3 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n@@ -2769,1 +2839,1 @@\n-                  NodeClassNames[argument(5)->Opcode()]);\n+                  NodeClassNames[argument(7)->Opcode()]);\n@@ -2796,8 +2866,10 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/  V compressExpandOp(int opr,\n-\/\/                    Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n-\/\/                    int length, V v, M m,\n-\/\/                    CompressExpandOperation<V, M> defaultImpl)\n+\/\/\n+\/\/  public static\n+\/\/  <V extends Vector<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E>\n+\/\/  VectorPayload compressExpandOp(int opr,\n+\/\/                                 Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/                                 int length, V v, M m,\n+\/\/                                 CompressExpandOperation<V, M> defaultImpl)\n+\/\/\n@@ -2809,1 +2881,1 @@\n-  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(6))->isa_int();\n@@ -2821,1 +2893,1 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(6)->Opcode()]);\n@@ -2851,1 +2923,1 @@\n-    opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+    opd1 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n@@ -2854,1 +2926,1 @@\n-                      NodeClassNames[argument(5)->Opcode()]);\n+                      NodeClassNames[argument(7)->Opcode()]);\n@@ -2860,1 +2932,1 @@\n-  assert(is_vector_mask(mbox_klass), \"argument(6) should be a mask class\");\n+  assert(is_vector_mask(mbox_klass), \"argument(8) should be a mask class\");\n@@ -2863,1 +2935,1 @@\n-  Node* mask = unbox_vector(argument(6), mbox_type, elem_bt, num_elem);\n+  Node* mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);\n@@ -2866,1 +2938,1 @@\n-                    NodeClassNames[argument(6)->Opcode()]);\n+                    NodeClassNames[argument(8)->Opcode()]);\n@@ -2881,5 +2953,6 @@\n-\/\/ public static\n-\/\/ <V extends Vector<E>,\n-\/\/  E,\n-\/\/  S extends VectorSpecies<E>>\n-\/\/  V indexVector(Class<? extends V> vClass, Class<E> eClass,\n+\/\/\n+\/\/  public static\n+\/\/  <V extends Vector<E>,\n+\/\/   E,\n+\/\/   S extends VectorSpecies<E>>\n+\/\/  V indexVector(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -2888,1 +2961,2 @@\n-\/\/                IndexOperation<V, S> defaultImpl)\n+\/\/                IndexOperation<V, S> defaultImpl) {\n+\/\/\n@@ -2892,1 +2966,1 @@\n-  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n@@ -2900,1 +2974,1 @@\n-                    NodeClassNames[argument(2)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()]);\n@@ -2927,1 +3001,1 @@\n-  Node* scale = argument(4);\n+  Node* scale = argument(6);\n@@ -2953,1 +3027,1 @@\n-  Node* opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+  Node* opd = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n@@ -2956,1 +3030,1 @@\n-                    NodeClassNames[argument(3)->Opcode()]);\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -3017,6 +3091,8 @@\n-\/\/ public static\n-\/\/ <E,\n-\/\/  M extends VectorMask<E>>\n-\/\/ M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<E> eClass, int length,\n-\/\/                              long offset, long limit,\n-\/\/                              IndexPartiallyInUpperRangeOperation<E, M> defaultImpl)\n+\/\/\n+\/\/  public static\n+\/\/  <E,\n+\/\/   M extends VectorMask<E>>\n+\/\/  M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n+\/\/                               int length, long offset, long limit,\n+\/\/                               IndexPartiallyInUpperRangeOperation<E, M> defaultImpl)\n+\/\/\n@@ -3026,1 +3102,1 @@\n-  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n@@ -3034,1 +3110,1 @@\n-                    NodeClassNames[argument(2)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()]);\n@@ -3074,2 +3150,2 @@\n-  Node* offset = argument(3);\n-  Node* limit = argument(5);\n+  Node* offset = argument(5);\n+  Node* limit = argument(7);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":355,"deletions":279,"binary":false,"changes":634,"status":"modified"},{"patch":"@@ -295,0 +295,5 @@\n+VectorNode* VectorCastNode::make(int vopc, Node* n1, BasicType bt, uint vlen) {\n+  const TypeVect* vt = TypeVect::make(bt, vlen);\n+  return VectorNode::make(vopc, n1, nullptr, vt);\n+}\n+\n@@ -410,0 +415,23 @@\n+\/\/ Return the vector operator for the specified scalar operation\n+\/\/ and vector length for half float\n+int VectorNode::opcode(int sopc) {\n+  switch (sopc) {\n+    case Op_AddI:\n+      return Op_AddVHF;\n+    case Op_SubI:\n+      return Op_SubVHF;\n+    case Op_MulI:\n+      return Op_MulVHF;\n+    case Op_DivI:\n+      return Op_DivVHF;\n+    case Op_AbsI:\n+      return Op_AbsVHF;\n+    case Op_NegI:\n+      return Op_NegVHF;\n+    case Op_FmaF:\n+      return Op_FmaVHF;\n+    default:\n+      return 0; \/\/ Unimplemented\n+  }\n+}\n+\n@@ -821,0 +849,2 @@\n+  case Op_VectorCastD2HF: return new VectorCastD2HFNode(n1, vt);\n+  case Op_VectorCastHF2D: return new VectorCastHF2DNode(n1, vt);\n@@ -1479,0 +1509,16 @@\n+\/\/Haffloat reduction nodes.\n+int ReductionNode::opcode(int opc) {\n+  int vopc = opc;\n+  switch (opc) {\n+    case Op_AddI:\n+      vopc = Op_AddReductionVHF;\n+      break;\n+    case Op_MulI:\n+      vopc = Op_MulReductionVF;\n+      break;\n+    default: ShouldNotReachHere(); return 0;\n+  }\n+  return vopc;\n+}\n+\n+\n@@ -1502,0 +1548,1 @@\n+  case Op_AddReductionVHF: return new AddReductionVHFNode(ctrl, n1, n2);\n@@ -1581,5 +1628,0 @@\n-VectorNode* VectorCastNode::make(int vopc, Node* n1, BasicType bt, uint vlen) {\n-  const TypeVect* vt = TypeVect::make(bt, vlen);\n-  return VectorNode::make(vopc, n1, nullptr, vt);\n-}\n-\n@@ -1599,0 +1641,6 @@\n+    case Op_ConvD2HF:\n+      assert(bt == T_DOUBLE, \"\");\n+      return Op_VectorCastD2HF;\n+    case Op_ConvHF2D:\n+      assert(bt == T_SHORT, \"\");\n+      return Op_VectorCastHF2D;\n@@ -1600,1 +1648,1 @@\n-      \/\/ Handled normally below\n+      \/\/ handled below\n@@ -1664,0 +1712,1 @@\n+    case Op_AddReductionVHF:\/\/ fallthrough\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":55,"deletions":6,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+  static VectorNode* make(int vopc, Node* n1, Node* n2, uint vlen);\n+  static VectorNode* make(int vopc, Node* n1, Node* n2, Node* n3, uint vlen);\n@@ -98,0 +100,1 @@\n+  static int opcode(int opc);\n@@ -213,8 +216,0 @@\n-\/\/------------------------------AddVHFNode--------------------------------------\n-\/\/ Vector add float\n-class AddVHFNode : public VectorNode {\n-public:\n-  AddVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n-  virtual int Opcode() const;\n-};\n-\n@@ -237,0 +232,8 @@\n+\/\/------------------------------AddVHFNode--------------------------------------\n+\/\/ Vector add halffloat\n+class AddVHFNode : public VectorNode {\n+public:\n+  AddVHFNode(Node * in1, Node * in2, const TypeVect * vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -254,0 +257,1 @@\n+  static int  opcode(int opc);\n@@ -340,0 +344,10 @@\n+\/\/------------------------------AddReductionVHFNode--------------------------------------\n+\/\/ Vector add halffloat as a reduction\n+class AddReductionVHFNode : public ReductionNode {\n+public:\n+  AddReductionVHFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::SHORT; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+};\n+\n@@ -415,9 +429,0 @@\n-\/\/------------------------------SubVHFNode--------------------------------------\n-\/\/ Vector subtract half float\n-class SubVHFNode : public VectorNode {\n-public:\n-  SubVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n-  virtual int Opcode() const;\n-};\n-\n-\n@@ -440,0 +445,8 @@\n+\/\/------------------------------SubVHFNode--------------------------------------\n+\/\/ Vector sub halffloat\n+class SubVHFNode : public VectorNode {\n+public:\n+  SubVHFNode(Node * in1, Node * in2, const TypeVect * vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -534,0 +547,16 @@\n+\/\/------------------------------CMoveVFNode--------------------------------------\n+\/\/ Vector float conditional move\n+class CMoveVFNode : public VectorNode {\n+public:\n+  CMoveVFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------CMoveVDNode--------------------------------------\n+\/\/ Vector double conditional move\n+class CMoveVDNode : public VectorNode {\n+public:\n+  CMoveVDNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -610,8 +639,0 @@\n-\/\/------------------------------DivVHFNode-------------------------------------\n-\/\/ Vector divide half float\n-class DivVHFNode : public VectorNode {\n-public:\n-  DivVHFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n-  virtual int Opcode() const;\n-};\n-\n@@ -634,0 +655,8 @@\n+\/\/------------------------------DivVHFNode--------------------------------------\n+\/\/ Vector div halffloat\n+class DivVHFNode : public VectorNode {\n+public:\n+  DivVHFNode(Node * in1, Node * in2, const TypeVect * vt) : VectorNode(in1, in2, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -650,0 +679,8 @@\n+\/\/------------------------------AbsVHFNode--------------------------------------\n+\/\/ Vector Abs Halffloat\n+class AbsVHFNode : public VectorNode {\n+public:\n+  AbsVHFNode(Node * in, const TypeVect * vt) : VectorNode(in, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -781,0 +818,8 @@\n+\/\/------------------------------NegVHFNode--------------------------------------\n+\/\/ Vector Neg double\n+class NegVHFNode : public VectorNode {\n+public:\n+  NegVHFNode(Node * in, const TypeVect * vt) : VectorNode(in, vt) {}\n+  virtual int Opcode() const;\n+};\n+\n@@ -1887,0 +1932,16 @@\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE, \"must be double\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class VectorCastHF2DNode : public VectorCastNode {\n+ public:\n+  VectorCastHF2DNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_SHORT, \"must be short\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class VectorCastD2HFNode : public VectorCastNode {\n+ public:\n+  VectorCastD2HFNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":86,"deletions":25,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  Klass* holder = ik->find_field(vmSymbols::ETYPE_name(), vmSymbols::class_signature(), &fd);\n+  Klass* holder = ik->find_field(vmSymbols::CTYPE_name(), vmSymbols::class_signature(), &fd);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,0 +121,7 @@\n+  enum {\n+    VECTOR_TYPE_PRIM = 1,\n+    VECTOR_TYPE_FP16 = 2,\n+    VECTOR_TYPE_FP8  = 3,\n+    VECTOR_TYPE_INT8 = 4\n+  };\n+\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -463,0 +463,1 @@\n+  inline void patch_pd_unused(intptr_t* sp);\n@@ -786,3 +787,18 @@\n-  intptr_t* from = _cont_stack_top - frame::metadata_words_at_bottom;\n-  intptr_t* to   = chunk_top - frame::metadata_words_at_bottom;\n-  copy_to_chunk(from, to, cont_size() + frame::metadata_words_at_bottom);\n+\n+  int adjust = frame::metadata_words_at_bottom;\n+#if INCLUDE_ASAN && defined(AARCH64)\n+  \/\/ Reading at offset frame::metadata_words_at_bottom from _cont_stack_top\n+  \/\/ will accesss memory at the callee frame, which on preemption cases will\n+  \/\/ be the VM native method being called. The Arm 64-bit ABI doesn't specify\n+  \/\/ a location where the frame record (returnpc+fp) has to be stored within\n+  \/\/ a stack frame, and GCC currently chooses to save it at the top of the\n+  \/\/ frame (lowest address). ASan treats this memory access in the callee as\n+  \/\/ an overflow access to one of the locals stored in that frame. For these\n+  \/\/ preemption cases we don't need to read these words anyways so we avoid it.\n+  if (_preempt) {\n+    adjust = 0;\n+  }\n+#endif\n+  intptr_t* from = _cont_stack_top - adjust;\n+  intptr_t* to   = chunk_top - adjust;\n+  copy_to_chunk(from, to, cont_size() + adjust);\n@@ -819,0 +835,5 @@\n+    \/\/ For stub\/native frames the fp is not used while frozen, and will be constructed\n+    \/\/ again when thawing the frame (see ThawBase::handle_preempted_continuation). We\n+    \/\/ patch it with a special bad address to help with debugging, particularly when\n+    \/\/ inspecting frames and identifying invalid accesses.\n+    patch_pd_unused(chunk_top);\n@@ -2487,1 +2508,1 @@\n-    \/\/ we copied the original fp at the time of freeze which now will have to be fixed.\n+    \/\/ we copied the fp patched during freeze, which will now have to be fixed.\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+  static const bool compiled = false;\n@@ -130,0 +131,2 @@\n+  static const bool compiled = true;\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -564,1 +564,2 @@\n-    guarantee(expressions != nullptr && expressions->length() > 0, \"must have exception to throw\");\n+    guarantee(expressions != nullptr && expressions->length() == 1, \"should have only exception on stack\");\n+    guarantee(exec_mode != Unpack_exception, \"rethrow_exception set with Unpack_exception\");\n@@ -740,0 +741,1 @@\n+    assert(array->element(0)->rethrow_exception(), \"must be\");\n@@ -847,0 +849,1 @@\n+#ifdef ASSERT\n@@ -871,0 +874,1 @@\n+#endif\n@@ -935,4 +939,3 @@\n-    bool is_top_frame = true;\n-    int callee_max_locals = 0;\n-    for (int i = 0; i < cur_array->frames(); i++) {\n-      vframeArrayElement* el = cur_array->element(i);\n+    for (int frame_idx = 0; frame_idx < cur_array->frames(); frame_idx++) {\n+      bool is_top_frame = (frame_idx == 0);\n+      vframeArrayElement* el = cur_array->element(frame_idx);\n@@ -942,0 +945,2 @@\n+      methodHandle mh(thread, iframe->interpreter_frame_method());\n+      bool reexecute = el->should_reexecute();\n@@ -943,8 +948,1 @@\n-      \/\/ Get the oop map for this bci\n-      InterpreterOopMap mask;\n-      bool try_next_mask = false;\n-      int next_mask_expression_stack_size = -1;\n-      methodHandle mh(thread, iframe->interpreter_frame_method());\n-      OopMapCache::compute_one_oop_map(mh, iframe->interpreter_frame_bci(), &mask);\n-      BytecodeStream str(mh, iframe->interpreter_frame_bci());\n-      \/\/ Get to the next bytecode if possible\n+      BytecodeStream str(mh, iframe->interpreter_frame_bci());\n@@ -955,0 +953,32 @@\n+      Bytecodes::Code cur_code = str.next();\n+\n+      if (!reexecute && !Bytecodes::is_invoke(cur_code)) {\n+        \/\/ We can only compute OopMaps for the before state, so we need to roll forward\n+        \/\/ to the next bytecode.\n+        assert(is_top_frame, \"must be\");\n+        assert(falls_through(cur_code), \"must be\");\n+        assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n+        assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+\n+        \/\/ Need to subtract off the size of the result type of\n+        \/\/ the bytecode because this is not described in the\n+        \/\/ debug info but returned to the interpreter in the TOS\n+        \/\/ caching register\n+        BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n+        if (bytecode_result_type != T_ILLEGAL) {\n+          top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n+        }\n+        assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n+\n+        cur_code = str.next();\n+        \/\/ Reflect the fact that we have rolled forward and now need\n+        \/\/ top_frame_expression_stack_adjustment\n+        reexecute = true;\n+      }\n+\n+      assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n+      assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+\n+      \/\/ Get the oop map for this bci\n+      InterpreterOopMap mask;\n+      OopMapCache::compute_one_oop_map(mh, str.bci(), &mask);\n@@ -958,3 +988,1 @@\n-      Bytecodes::Code cur_code = str.next();\n-      Bytecodes::Code next_code = Bytecodes::_shouldnotreachhere;\n-        Bytecode_invoke invoke(mh, iframe->interpreter_frame_bci());\n+        Bytecode_invoke invoke(mh, str.bci());\n@@ -963,1 +991,1 @@\n-        if (i != 0 && invoke.has_member_arg()) {\n+        if (!is_top_frame && invoke.has_member_arg()) {\n@@ -967,30 +995,0 @@\n-      if (str.bci() < max_bci) {\n-        next_code = str.next();\n-        if (next_code >= 0) {\n-          \/\/ The interpreter oop map generator reports results before\n-          \/\/ the current bytecode has executed except in the case of\n-          \/\/ calls. It seems to be hard to tell whether the compiler\n-          \/\/ has emitted debug information matching the \"state before\"\n-          \/\/ a given bytecode or the state after, so we try both\n-          if (!Bytecodes::is_invoke(cur_code) && falls_through(cur_code)) {\n-            \/\/ Get expression stack size for the next bytecode\n-            InterpreterOopMap next_mask;\n-            OopMapCache::compute_one_oop_map(mh, str.bci(), &next_mask);\n-            next_mask_expression_stack_size = next_mask.expression_stack_size();\n-            if (Bytecodes::is_invoke(next_code)) {\n-              Bytecode_invoke invoke(mh, str.bci());\n-              next_mask_expression_stack_size += invoke.size_of_parameters();\n-            }\n-            \/\/ Need to subtract off the size of the result type of\n-            \/\/ the bytecode because this is not described in the\n-            \/\/ debug info but returned to the interpreter in the TOS\n-            \/\/ caching register\n-            BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n-            if (bytecode_result_type != T_ILLEGAL) {\n-              top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n-            }\n-            assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n-            try_next_mask = true;\n-          }\n-        }\n-      }\n@@ -999,38 +997,43 @@\n-      \/\/ This assertion may be dependent on the platform we're running on and may need modification (tested on x86 and sparc)\n-      if (!(\n-            \/* SPARC *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_size_of_parameters) ||\n-            \/* x86 *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_max_locals) ||\n-            (try_next_mask &&\n-             (iframe->interpreter_frame_expression_stack_size() == (next_mask_expression_stack_size -\n-                                                                    top_frame_expression_stack_adjustment))) ||\n-            (is_top_frame && (exec_mode == Unpack_exception) && iframe->interpreter_frame_expression_stack_size() == 0) ||\n-            (is_top_frame && (exec_mode == Unpack_uncommon_trap || exec_mode == Unpack_reexecute || el->should_reexecute()) &&\n-             (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + cur_invoke_parameter_size))\n-            )) {\n-        {\n-          \/\/ Print out some information that will help us debug the problem\n-          tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n-          tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", i, cur_array->frames() - 1);\n-          tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n-          if (try_next_mask) {\n-            tty->print_cr(\"  Next code %s\", Bytecodes::name(next_code));\n-          }\n-          tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n-                        iframe->interpreter_frame_expression_stack_size());\n-          tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n-          tty->print_cr(\"  try_next_mask = %d\", try_next_mask);\n-          tty->print_cr(\"  next_mask_expression_stack_size = %d\", next_mask_expression_stack_size);\n-          tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n-          tty->print_cr(\"  callee_max_locals = %d\", callee_max_locals);\n-          tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n-          tty->print_cr(\"  exec_mode = %d\", exec_mode);\n-          tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n-          tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n-          tty->print_cr(\"  Interpreted frames:\");\n-          for (int k = 0; k < cur_array->frames(); k++) {\n-            vframeArrayElement* el = cur_array->element(k);\n-            tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n-          }\n-          cur_array->print_on_2(tty);\n+      auto match = [&]() {\n+        int iframe_expr_ssize = iframe->interpreter_frame_expression_stack_size();\n+#if INCLUDE_JVMCI\n+        if (is_top_frame && el->rethrow_exception()) {\n+          return iframe_expr_ssize == 1;\n+        }\n+#endif\n+        \/\/ This should only be needed for C1\n+        if (is_top_frame && exec_mode == Unpack_exception && iframe_expr_ssize == 0) {\n+          return true;\n+        }\n+        if (reexecute) {\n+          int expr_ssize_before = iframe_expr_ssize + top_frame_expression_stack_adjustment;\n+          int oopmap_expr_invoke_ssize = mask.expression_stack_size() + cur_invoke_parameter_size;\n+          return expr_ssize_before == oopmap_expr_invoke_ssize;\n+        } else {\n+          int oopmap_expr_callee_ssize = mask.expression_stack_size() + callee_size_of_parameters;\n+          return iframe_expr_ssize == oopmap_expr_callee_ssize;\n+        }\n+      };\n+      if (!match()) {\n+        \/\/ Print out some information that will help us debug the problem\n+        tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n+        tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", frame_idx, cur_array->frames() - 1);\n+        tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n+        tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n+                      iframe->interpreter_frame_expression_stack_size());\n+        tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n+        tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n+        tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n+        tty->print_cr(\"  exec_mode = %d\", exec_mode);\n+        tty->print_cr(\"  original should_reexecute = %s\", el->should_reexecute() ? \"true\" : \"false\");\n+        tty->print_cr(\"  reexecute = %s%s\", reexecute ? \"true\" : \"false\",\n+                      (reexecute != el->should_reexecute()) ? \" (changed)\" : \"\");\n+#if INCLUDE_JVMCI\n+        tty->print_cr(\"  rethrow_exception = %s\", el->rethrow_exception() ? \"true\" : \"false\");\n+#endif\n+        tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n+        tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n+        tty->print_cr(\"  Interpreted frames:\");\n+        for (int k = 0; k < cur_array->frames(); k++) {\n+          vframeArrayElement* el = cur_array->element(k);\n+          tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n@@ -1038,0 +1041,1 @@\n+        cur_array->print_on_2(tty);\n@@ -1043,2 +1047,0 @@\n-      callee_max_locals = mh->max_locals();\n-      is_top_frame = false;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":89,"deletions":87,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -139,0 +139,10 @@\n+JVMFlag::Error LargePageSizeInBytesConstraintFunc(size_t value, bool verbose) {\n+  if (!is_power_of_2(value)) {\n+    JVMFlag::printError(verbose, \"LargePageSizeInBytes ( %zu ) must be \"\n+                        \"a power of 2\\n\",\n+                        value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  f(size_t, LargePageSizeInBytesConstraintFunc)       \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -240,1 +240,2 @@\n-          \"page size for the environment as the maximum)\")                  \\\n+          \"page size for the environment as the maximum) \"                  \\\n+          \"(must be a power of 2)\")                                         \\\n@@ -242,0 +243,1 @@\n+          constraint(LargePageSizeInBytesConstraintFunc, AtParse)           \\\n@@ -486,0 +488,3 @@\n+  develop(bool, ZapCHeap, trueInDebug,                                      \\\n+          \"Zap allocated\/freed C heap space\")                               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-    VMError::set_handshake_timed_out_thread(p2i(target));\n+    VMError::set_handshake_timed_out_thread(target);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -714,0 +714,1 @@\n+  assert(node->TState == ObjectWaiter::TS_RUN, \"\");\n@@ -729,0 +730,1 @@\n+      node->TState = ObjectWaiter::TS_RUN;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -669,2 +669,2 @@\n-  } else {\n-    DEBUG_ONLY(::memset(inner_ptr, uninitBlockPad, size);)\n+  } else if (ZapCHeap) {\n+    ::memset(inner_ptr, uninitBlockPad, size);\n@@ -743,1 +743,1 @@\n-    if (old_size < size) {\n+    if (ZapCHeap && old_size < size) {\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -654,1 +654,1 @@\n-        VMError::set_safepoint_timed_out_thread(p2i(cur_thread));\n+        VMError::set_safepoint_timed_out_thread(cur_thread);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2605,5 +2605,7 @@\n-    assert(no_arg_blob != nullptr &&\n-           obj_arg_blob != nullptr &&\n-           int_arg_blob != nullptr &&\n-           obj_int_arg_blob != nullptr &&\n-           obj_obj_arg_blob != nullptr, \"Initial adapters must be properly created\");\n+    \/\/ we should always get an entry back but we don't have any\n+    \/\/ associated blob on Zero\n+    assert(_no_arg_handler != nullptr &&\n+           _obj_arg_handler != nullptr &&\n+           _int_arg_handler != nullptr &&\n+           _obj_int_arg_handler != nullptr &&\n+           _obj_obj_arg_handler != nullptr, \"Initial adapter handlers must be properly created\");\n@@ -2613,0 +2615,2 @@\n+#ifndef ZERO\n+  \/\/ no blobs to register when we are on Zero\n@@ -2618,0 +2622,1 @@\n+#endif \/\/ ZERO\n@@ -2712,0 +2717,2 @@\n+  \/\/ we can only check for the same code if there is any\n+#ifndef ZERO\n@@ -2718,0 +2725,1 @@\n+# endif \/\/ ZERO\n@@ -2795,1 +2803,2 @@\n-  int insts_size = adapter_blob->code_size();\n+  int insts_size;\n+  \/\/ on Zero the blob may be null\n@@ -2797,0 +2806,4 @@\n+  if (adapter_blob == nullptr) {\n+    return;\n+  }\n+  insts_size = adapter_blob->code_size();\n@@ -2837,0 +2850,5 @@\n+#ifdef ZERO\n+  \/\/ On zero there is no code to save and no need to create a blob and\n+  \/\/ or relocate the handler.\n+  adapter_blob = nullptr;\n+#else\n@@ -2872,0 +2890,2 @@\n+#endif \/\/ ZERO\n+\n@@ -2878,0 +2898,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -171,8 +171,0 @@\n-  if (code_size == 0) {\n-    LogTarget(Info, stubs) lt;\n-    if (lt.is_enabled()) {\n-      LogStream ls(lt);\n-      ls.print_cr(\"%s\\t not generated\", buffer_name);\n-    }\n-    return nullptr;\n-  }\n@@ -199,0 +191,9 @@\n+  if (code_size == 0) {\n+    assert(buffer.insts_size() == 0, \"should not write into buffer when bob size declared as 0\");\n+    LogTarget(Info, stubs) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      ls.print_cr(\"%s\\t not generated\", buffer_name);\n+    }\n+    return nullptr;\n+  }\n@@ -201,1 +202,1 @@\n-  assert(code_size == 0 || buffer.insts_remaining() > 200,\n+  assert(buffer.insts_remaining() > 200,\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"code\/scopeDesc.hpp\"\n@@ -64,1 +65,4 @@\n-  _reexecute = vf->should_reexecute();\n+  _reexecute = vf->should_reexecute(); \/\/ initial value, updated in unpack_on_stack\n+#if INCLUDE_JVMCI\n+  _rethrow = vf->scope()->rethrow_exception();\n+#endif\n@@ -174,1 +178,28 @@\n-int unpack_counter = 0;\n+static int unpack_counter = 0;\n+\n+bool vframeArrayElement::should_reexecute(bool is_top_frame, int exec_mode) const {\n+  if (is_top_frame) {\n+    switch (exec_mode) {\n+    case Deoptimization::Unpack_uncommon_trap:\n+    case Deoptimization::Unpack_reexecute:\n+      return true;\n+    case Deoptimization::Unpack_exception:\n+      assert(raw_bci() >= 0, \"bad bci %d for Unpack_exception\", raw_bci());\n+    default:\n+      break;\n+    }\n+  }\n+  if (raw_bci() == SynchronizationEntryBCI) {\n+    return true;\n+  }\n+  bool reexec = should_reexecute();\n+  assert(is_top_frame || reexec == false, \"unexepected should_reexecute()\");\n+#ifdef ASSERT\n+  if (!reexec) {\n+    address bcp = method()->bcp_from(bci());\n+    Bytecodes::Code code = Bytecodes::code_at(method(), bcp);\n+    assert(!Interpreter::bytecode_should_reexecute(code), \"should_reexecute mismatch\");\n+  }\n+#endif\n+  return reexec;\n+}\n@@ -192,3 +223,10 @@\n-  bool use_next_mdp = false; \/\/ true if we should use the mdp associated with the next bci\n-                             \/\/ rather than the one associated with bcp\n-  if (raw_bci() == SynchronizationEntryBCI) {\n+  bool reexecute = should_reexecute(is_top_frame, exec_mode);\n+  if (is_top_frame && exec_mode == Deoptimization::Unpack_exception) {\n+    assert(raw_bci() >= 0, \"bad bci %d for Unpack_exception\", raw_bci());\n+    bcp = method()->bcp_from(bci());\n+    \/\/ exception is pending\n+    pc = Interpreter::rethrow_exception_entry();\n+    \/\/ [phh] We're going to end up in some handler or other, so it doesn't\n+    \/\/ matter what mdp we point to.  See exception_handler_for_exception()\n+    \/\/ in interpreterRuntime.cpp.\n+  } else if (raw_bci() == SynchronizationEntryBCI) {\n@@ -198,1 +236,2 @@\n-  } else if (should_reexecute()) { \/\/reexecute this bytecode\n+    assert(reexecute, \"must be\");\n+  } else if (reexecute) { \/\/reexecute this bytecode\n@@ -201,1 +240,10 @@\n-    pc  = Interpreter::deopt_reexecute_entry(method(), bcp);\n+    switch (exec_mode) {\n+    case Deoptimization::Unpack_uncommon_trap:\n+    case Deoptimization::Unpack_reexecute:\n+      \/\/ Do not special-case _athrow or _return_register_finalizer\n+      pc = Interpreter::deopt_entry(vtos, 0);\n+      break;\n+    default:\n+      \/\/ Yes, special-case _athrow and _return_register_finalizer\n+      pc = Interpreter::deopt_reexecute_entry(method(), bcp);\n+    }\n@@ -204,0 +252,1 @@\n+    assert(!reexecute, \"must be\");\n@@ -205,1 +254,0 @@\n-    use_next_mdp = true;\n@@ -242,1 +290,10 @@\n-        use_next_mdp = false;\n+#ifdef ASSERT\n+        Bytecodes::Code code = Bytecodes::code_at(method(), bcp);\n+        assert(Bytecodes::is_invoke(code), \"must be\");\n+        assert(!reexecute, \"must be\");\n+#endif\n+        \/\/ It would be nice if the VerifyStack logic in unpack_frames() was refactored so\n+        \/\/ we could check the stack before and after changing the reexecute mode, but\n+        \/\/ it should pass either way because an invoke uses the same stack state for both modes,\n+        \/\/ which is: args popped but result not yet pushed.\n+        reexecute = true;\n@@ -248,6 +305,5 @@\n-    } else if (!realloc_failure_exception && JvmtiExport::can_force_early_return() && state != nullptr &&\n-               state->is_earlyret_pending()) {\n-      \/\/ Force early return from top frame after deoptimization\n-      pc = Interpreter::remove_activation_early_entry(state->earlyret_tos());\n-    } else {\n-      if (realloc_failure_exception && JvmtiExport::can_force_early_return() && state != nullptr && state->is_earlyret_pending()) {\n+    } else if (JvmtiExport::can_force_early_return() && state != nullptr && state->is_earlyret_pending()) {\n+      if (!realloc_failure_exception) {\n+        \/\/ Force early return from top frame after deoptimization\n+        pc = Interpreter::remove_activation_early_entry(state->earlyret_tos());\n+      } else {\n@@ -258,21 +314,1 @@\n-      \/\/ Possibly override the previous pc computation of the top (youngest) frame\n-      switch (exec_mode) {\n-      case Deoptimization::Unpack_deopt:\n-        \/\/ use what we've got\n-        break;\n-      case Deoptimization::Unpack_exception:\n-        \/\/ exception is pending\n-        pc = SharedRuntime::raw_exception_handler_for_return_address(thread, pc);\n-        \/\/ [phh] We're going to end up in some handler or other, so it doesn't\n-        \/\/ matter what mdp we point to.  See exception_handler_for_exception()\n-        \/\/ in interpreterRuntime.cpp.\n-        break;\n-      case Deoptimization::Unpack_uncommon_trap:\n-      case Deoptimization::Unpack_reexecute:\n-        \/\/ redo last byte code\n-        pc  = Interpreter::deopt_entry(vtos, 0);\n-        use_next_mdp = false;\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-      }\n+    _reexecute = reexecute;\n@@ -320,3 +356,0 @@\n-  if (ProfileInterpreter) {\n-    iframe()->interpreter_frame_set_mdp(nullptr); \/\/ clear out the mdp.\n-  }\n@@ -326,1 +359,1 @@\n-    if (mdo != nullptr) {\n+    if (mdo != nullptr && exec_mode != Deoptimization::Unpack_exception) {\n@@ -328,1 +361,1 @@\n-      if (use_next_mdp) ++bci;\n+      if (!reexecute) ++bci;\n@@ -331,0 +364,2 @@\n+    } else {\n+      iframe()->interpreter_frame_set_mdp(nullptr); \/\/ clear out the mdp.\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":76,"deletions":41,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,3 @@\n+#if INCLUDE_JVMCI\n+    bool _rethrow;                                               \/\/ from ScopeDesc::rethrow_exception()\n+#endif\n@@ -74,0 +77,1 @@\n+  bool should_reexecute(bool is_top_frame, int exec_mode) const;\n@@ -75,0 +79,3 @@\n+#if INCLUDE_JVMCI\n+  bool rethrow_exception(void) const  { return _rethrow; }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -96,6 +96,0 @@\n-\n-  void  clear()                 { _len = 0; }\n-  void  trunc_to(int length)    {\n-    assert(length <= _len,\"cannot increase length\");\n-    _len = length;\n-  }\n@@ -192,5 +186,0 @@\n-  E pop() {\n-    assert(_len > 0, \"empty list\");\n-    return _data[--_len];\n-  }\n-\n@@ -250,53 +239,0 @@\n-  \/\/ Order preserving remove operations.\n-\n-  void remove(const E& elem) {\n-    \/\/ Assuming that element does exist.\n-    bool removed = remove_if_existing(elem);\n-    if (removed) return;\n-    ShouldNotReachHere();\n-  }\n-\n-  bool remove_if_existing(const E& elem) {\n-    \/\/ Returns TRUE if elem is removed.\n-    for (int i = 0; i < _len; i++) {\n-      if (_data[i] == elem) {\n-        remove_at(i);\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  void remove_at(int index) {\n-    assert(0 <= index && index < _len, \"illegal index %d for length %d\", index, _len);\n-    for (int j = index + 1; j < _len; j++) {\n-      _data[j-1] = _data[j];\n-    }\n-    _len--;\n-  }\n-\n-  \/\/ Remove all elements up to the index (exclusive). The order is preserved.\n-  void remove_till(int idx) {\n-    remove_range(0, idx);\n-  }\n-\n-  \/\/ Remove all elements in the range [start - end). The order is preserved.\n-  void remove_range(int start, int end) {\n-    assert(0 <= start, \"illegal start index %d\", start);\n-    assert(start < end && end <= _len, \"erase called with invalid range (%d, %d) for length %d\", start, end, _len);\n-\n-    for (int i = start, j = end; j < length(); i++, j++) {\n-      at_put(i, at(j));\n-    }\n-    trunc_to(length() - (end - start));\n-  }\n-\n-  \/\/ The order is changed.\n-  void delete_at(int index) {\n-    assert(0 <= index && index < _len, \"illegal index %d for length %d\", index, _len);\n-    if (index < --_len) {\n-      \/\/ Replace removed element with last one.\n-      _data[index] = _data[_len];\n-    }\n-  }\n-\n@@ -430,0 +366,5 @@\n+  E pop() {\n+    assert(this->_len > 0, \"empty list\");\n+    return this->_data[--this->_len];\n+  }\n+\n@@ -517,0 +458,61 @@\n+  void trunc_to(int length) {\n+    assert(length <= this->_len,\"cannot increase length\");\n+    this->_len = length;\n+  }\n+\n+  \/\/ Order preserving remove operations.\n+\n+  void remove_at(int index) {\n+    assert(0 <= index && index < this->_len,\n+           \"illegal index %d for length %d\", index, this->_len);\n+    for (int j = index + 1; j < this->_len; j++) {\n+      this->_data[j-1] = this->_data[j];\n+    }\n+    this->_len--;\n+  }\n+\n+  void remove(const E& elem) {\n+    \/\/ Assuming that element does exist.\n+    bool removed = this->remove_if_existing(elem);\n+    if (removed) return;\n+    ShouldNotReachHere();\n+  }\n+\n+  bool remove_if_existing(const E& elem) {\n+    \/\/ Returns TRUE if elem is removed.\n+    for (int i = 0; i < this->_len; i++) {\n+      if (this->_data[i] == elem) {\n+        this->remove_at(i);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Remove all elements up to the index (exclusive). The order is preserved.\n+  void remove_till(int idx) {\n+    remove_range(0, idx);\n+  }\n+\n+  \/\/ Remove all elements in the range [start - end). The order is preserved.\n+  void remove_range(int start, int end) {\n+    assert(0 <= start, \"illegal start index %d\", start);\n+    assert(start < end && end <= this->_len,\n+           \"erase called with invalid range (%d, %d) for length %d\",\n+           start, end, this->_len);\n+\n+    for (int i = start, j = end; j < this->length(); i++, j++) {\n+      this->at_put(i, this->at(j));\n+    }\n+    this->_len -= (end - start);\n+  }\n+\n+  \/\/ Replaces the designated element with the last element and shrinks by 1.\n+  void delete_at(int index) {\n+    assert(0 <= index && index < this->_len, \"illegal index %d for length %d\", index, this->_len);\n+    if (index < --this->_len) {\n+      \/\/ Replace removed element with last one.\n+      this->_data[index] = this->_data[this->_len];\n+    }\n+  }\n+\n@@ -520,0 +522,1 @@\n+  void clear() { this->_len = 0; }\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":67,"deletions":64,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-volatile intptr_t VMError::_handshake_timed_out_thread = p2i(nullptr);\n-volatile intptr_t VMError::_safepoint_timed_out_thread = p2i(nullptr);\n+Thread* volatile VMError::_handshake_timed_out_thread = nullptr;\n+Thread* volatile VMError::_safepoint_timed_out_thread = nullptr;\n@@ -824,4 +824,4 @@\n-        if (_handshake_timed_out_thread == p2i(_thread)) {\n-          st->print(\" (sent by handshake timeout handler\");\n-        } else if (_safepoint_timed_out_thread == p2i(_thread)) {\n-          st->print(\" (sent by safepoint timeout handler\");\n+        if (get_handshake_timed_out_thread() == _thread) {\n+          st->print(\" (sent by handshake timeout handler)\");\n+        } else if (get_safepoint_timed_out_thread() == _thread) {\n+          st->print(\" (sent by safepoint timeout handler)\");\n@@ -1341,2 +1341,4 @@\n-void VMError::set_handshake_timed_out_thread(intptr_t thread_addr) {\n-  _handshake_timed_out_thread = thread_addr;\n+void VMError::set_handshake_timed_out_thread(Thread* thread) {\n+  \/\/ Only preserve the first thread to time-out this way. The atomic operation ensures\n+  \/\/ visibility to the target thread.\n+  Atomic::replace_if_null(&_handshake_timed_out_thread, thread);\n@@ -1345,2 +1347,12 @@\n-void VMError::set_safepoint_timed_out_thread(intptr_t thread_addr) {\n-  _safepoint_timed_out_thread = thread_addr;\n+void VMError::set_safepoint_timed_out_thread(Thread* thread) {\n+  \/\/ Only preserve the first thread to time-out this way. The atomic operation ensures\n+  \/\/ visibility to the target thread.\n+  Atomic::replace_if_null(&_safepoint_timed_out_thread, thread);\n+}\n+\n+Thread* VMError::get_handshake_timed_out_thread() {\n+  return Atomic::load(&_handshake_timed_out_thread);\n+}\n+\n+Thread* VMError::get_safepoint_timed_out_thread() {\n+  return Atomic::load(&_safepoint_timed_out_thread);\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -146,2 +146,2 @@\n-  static volatile intptr_t _handshake_timed_out_thread;\n-  static volatile intptr_t _safepoint_timed_out_thread;\n+  static Thread* volatile _handshake_timed_out_thread;\n+  static Thread* volatile _safepoint_timed_out_thread;\n@@ -226,2 +226,4 @@\n-  static void set_handshake_timed_out_thread(intptr_t thread_addr);\n-  static void set_safepoint_timed_out_thread(intptr_t thread_addr);\n+  static void set_handshake_timed_out_thread(Thread* thread);\n+  static void set_safepoint_timed_out_thread(Thread* thread);\n+  static Thread* get_handshake_timed_out_thread();\n+  static Thread* get_safepoint_timed_out_thread();\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -602,1 +602,1 @@\n-                str = JLA.uncheckedNewStringNoRepl(bytearr, StandardCharsets.ISO_8859_1);\n+                str = JLA.uncheckedNewStringWithLatin1Bytes(bytearr);\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataInputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -693,5 +693,2 @@\n-     *\n-     * @param  noShare\n-     *         {@code true} if the resulting string MUST NOT share the byte array,\n-     *         {@code false} if the byte array can be exclusively used to construct\n-     *         the string and is not modified or used for any other purpose.\n+     * The byte array can be exclusively used to construct\n+     * the string and is not modified or used for any other purpose.\n@@ -699,1 +696,1 @@\n-    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n+    private static String newStringUTF8NoRepl(byte[] bytes, int offset, int length) {\n@@ -710,1 +707,1 @@\n-                if (noShare || length != bytes.length) {\n+                if (length != bytes.length) {\n@@ -762,0 +759,28 @@\n+    \/**\n+     * {@return a new String created using the supplied latin1 bytes}\n+     * @param src a byte array with the bytes for a latin1 string\n+     *\/\n+    static String newStringWithLatin1Bytes(byte[] src) {\n+        int len = src.length;\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        if (COMPACT_STRINGS)\n+            return new String(src, LATIN1);\n+        return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n+    }\n+\n+    \/**\n+     * {@return a new {@code String} created using the given byte array that is\n+     * encoded in specified charset}\n+     * <p>\n+     * <b>WARNING: The caller of this method is assumed to have relinquished\n+     * and transferred the ownership of the byte array<\/b>. It can thus be\n+     * exclusively used to construct the {@code String}.\n+     *\n+     * @param src byte array containing encoded characters\n+     * @param cs charset the byte array encoded in\n+     *\n+     * @throws CharacterCodingException for malformed input or unmappable characters\n+     *\/\n@@ -781,1 +806,1 @@\n-            return newStringUTF8NoRepl(src, 0, src.length, false);\n+            return newStringUTF8NoRepl(src, 0, src.length);\n@@ -1022,1 +1047,1 @@\n-            int ret = StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n+            int ret = StringCoding.encodeISOArray(val, sp, dst, dp, len);\n@@ -1287,1 +1312,2 @@\n-        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n+        int positives = StringCoding.countPositives(val, 0, val.length);\n+        if (positives == val.length) {\n@@ -1291,1 +1317,0 @@\n-        int dp = 0;\n@@ -1293,1 +1318,6 @@\n-        for (byte c : val) {\n+        if (positives > 0) {\n+            System.arraycopy(val, 0, dst, 0, positives);\n+        }\n+        int dp = positives;\n+        for (int i = dp; i < val.length; i++) {\n+            byte c = val[i];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":42,"deletions":12,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -31,0 +32,2 @@\n+import java.util.function.BiFunction;\n+\n@@ -41,1 +44,1 @@\n-    public static int countNonZeroAscii(String s) {\n+    static int countNonZeroAscii(String s) {\n@@ -53,1 +56,1 @@\n-    public static int countNonZeroAsciiLatin1(byte[] ba, int off, int len) {\n+    private static int countNonZeroAsciiLatin1(byte[] ba, int off, int len) {\n@@ -66,1 +69,1 @@\n-    public static int countNonZeroAsciiUTF16(byte[] ba, int off, int strlen) {\n+    private static int countNonZeroAsciiUTF16(byte[] ba, int off, int strlen) {\n@@ -77,1 +80,1 @@\n-    public static boolean hasNegatives(byte[] ba, int off, int len) {\n+    static boolean hasNegatives(byte[] ba, int off, int len) {\n@@ -88,0 +91,7 @@\n+     *\n+     * @param ba a byte array\n+     * @param off the index of the first byte to start reading from\n+     * @param len the total number of bytes to read\n+     * @throws NullPointerException if {@code ba} is null\n+     * @throws ArrayIndexOutOfBoundsException if the provided sub-range is\n+     *         {@linkplain Preconditions#checkFromIndexSize(int, int, int, BiFunction) out of bounds}\n@@ -89,0 +99,8 @@\n+    static int countPositives(byte[] ba, int off, int len) {\n+        Preconditions.checkFromIndexSize(\n+                off, len,\n+                ba.length,      \/\/ Implicit null check on `ba`\n+                Preconditions.AIOOBE_FORMATTER);\n+        return countPositives0(ba, off, len);\n+    }\n+\n@@ -90,1 +108,1 @@\n-    public static int countPositives(byte[] ba, int off, int len) {\n+    private static int countPositives0(byte[] ba, int off, int len) {\n@@ -100,0 +118,28 @@\n+    \/**\n+     * Encodes as many ISO-8859-1 codepoints as possible from the source byte\n+     * array containing characters encoded in UTF-16, into the destination byte\n+     * array, assuming that the encoding is ISO-8859-1 compatible.\n+     *\n+     * @param sa the source byte array containing characters encoded in UTF-16\n+     * @param sp the index of the <em>character (not byte!)<\/em> from the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the maximum number of <em>characters (not bytes!)<\/em> to be encoded\n+     * @return the total number of <em>characters (not bytes!)<\/em> successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     *\/\n+    static int encodeISOArray(byte[] sa, int sp,\n+                              byte[] da, int dp, int len) {\n+        \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n+        \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n+        int sl;\n+        if ((sp | dp | len) < 0 ||\n+                \/\/ Halving the length of `sa` to obtain the number of characters:\n+                sp >= (sl = sa.length >>> 1) ||     \/\/ Implicit null check on `sa`\n+                dp >= da.length) {                  \/\/ Implicit null check on `da`\n+            return 0;\n+        }\n+        int minLen = Math.min(len, Math.min(sl - sp, da.length - dp));\n+        return encodeISOArray0(sa, sp, da, dp, minLen);\n+    }\n+\n@@ -101,2 +147,2 @@\n-    public static int implEncodeISOArray(byte[] sa, int sp,\n-                                         byte[] da, int dp, int len) {\n+    private static int encodeISOArray0(byte[] sa, int sp,\n+                                       byte[] da, int dp, int len) {\n@@ -113,0 +159,26 @@\n+    \/**\n+     * Encodes as many ASCII codepoints as possible from the source\n+     * character array into the destination byte array, assuming that\n+     * the encoding is ASCII compatible.\n+     *\n+     * @param sa the source character array\n+     * @param sp the index of the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the maximum number of characters to be encoded\n+     * @return the total number of characters successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     *\/\n+    static int encodeAsciiArray(char[] sa, int sp,\n+                                byte[] da, int dp, int len) {\n+        \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n+        \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n+        if ((sp | dp | len) < 0 ||\n+                sp >= sa.length ||      \/\/ Implicit null check on `sa`\n+                dp >= da.length) {      \/\/ Implicit null check on `da`\n+            return 0;\n+        }\n+        int minLen = Math.min(len, Math.min(sa.length - sp, da.length - dp));\n+        return encodeAsciiArray0(sa, sp, da, dp, minLen);\n+    }\n+\n@@ -114,3 +186,2 @@\n-    public static int implEncodeAsciiArray(char[] sa, int sp,\n-                                           byte[] da, int dp, int len)\n-    {\n+    static int encodeAsciiArray0(char[] sa, int sp,\n+                                 byte[] da, int dp, int len) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":82,"deletions":11,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import java.util.concurrent.ScheduledExecutorService;\n@@ -2130,0 +2129,5 @@\n+\n+            public String uncheckedNewStringWithLatin1Bytes(byte[] bytes) {\n+                return String.newStringWithLatin1Bytes(bytes);\n+            }\n+\n@@ -2143,4 +2147,0 @@\n-            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n-                return String.newStringUTF8NoRepl(bytes, off, len, true);\n-            }\n-\n@@ -2159,2 +2159,2 @@\n-            public int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n-                return StringCoding.implEncodeAsciiArray(src, srcOff, dst, dstOff, len);\n+            public int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len) {\n+                return StringCoding.encodeAsciiArray(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -178,0 +178,5 @@\n+     * <p>\n+     * The location where a block of code merges back to its parent block, as\n+     * represented by the {@link #breakLabel()}, is expected to be reachable,\n+     * either from this block or the parent block.  The built code may be\n+     * malformed if there is no executable code at that location.\n@@ -328,0 +333,5 @@\n+     * <p>\n+     * The order of catch blocks is significant.  When an exception is thrown\n+     * by the try block, the first catch block whose exception type is {@linkplain\n+     * Class#isAssignableFrom(Class) the same class as or a superclass of} the\n+     * class of exception thrown is branched to (JVMS {@jvms 2.10}).\n@@ -346,0 +356,4 @@\n+         * @apiNote\n+         * If the type of exception to catch is already handled by previous\n+         * catch blocks, this block will never be executed.\n+         *\n@@ -350,3 +364,2 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         an exception of the given type or {@code exceptionType}\n-         *         represents a primitive type\n+         * @throws IllegalArgumentException if {@code exceptionType} represents\n+         *         a primitive type\n@@ -370,0 +383,4 @@\n+         * @apiNote\n+         * If every type of exception to catch is already handled by previous\n+         * catch blocks, this block will never be executed.\n+         *\n@@ -374,2 +391,2 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         one or more exceptions of the given types\n+         * @throws IllegalArgumentException if any exception type represents a\n+         *         primitive type\n@@ -390,0 +407,4 @@\n+         * @apiNote\n+         * Since this block intercepts all exceptions, all subsequent catch\n+         * blocks will never be executed.\n+         *\n@@ -392,2 +413,0 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         all exceptions\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -42,2 +42,4 @@\n- * table entries.  Delivered as a {@link CodeElement} when traversing the\n- * contents of a {@link CodeModel}.\n+ * table entries.  The order of exception table entries is significant: when an\n+ * exception is thrown in a method, execution branches to the first matching\n+ * exception handler if such a handler exists (JVMS {@jvms 2.10}). Delivered as\n+ * a {@link CodeElement} when traversing the contents of a {@link CodeModel}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ExceptionCatch.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,70 +1,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-\n-import static java.lang.constant.ConstantDescs.BSM_INVOKE;\n-import static java.lang.constant.ConstantDescs.CD_MethodHandle;\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a\n- * {@link MethodHandle} constant that performs a {@link MethodHandle#asType(MethodType)}\n- * adaptation on another {@link MethodHandle}.\n- *\/\n-final class AsTypeMethodHandleDesc extends DynamicConstantDesc<MethodHandle>\n-        implements MethodHandleDesc {\n-\n-    private final MethodHandleDesc underlying;\n-    private final MethodTypeDesc type;\n-\n-    AsTypeMethodHandleDesc(MethodHandleDesc underlying, MethodTypeDesc type) {\n-        super(BSM_INVOKE, ConstantDescs.DEFAULT_NAME, CD_MethodHandle,\n-              ConstantDescs.MHD_METHODHANDLE_ASTYPE, underlying, type);\n-        this.underlying = requireNonNull(underlying);\n-        this.type = requireNonNull(type);\n-    }\n-\n-    @Override\n-    public MethodTypeDesc invocationType() {\n-        return type;\n-    }\n-\n-    @Override\n-    public MethodHandle resolveConstantDesc(MethodHandles.Lookup lookup)\n-            throws ReflectiveOperationException {\n-        MethodHandle handle = underlying.resolveConstantDesc(lookup);\n-        MethodType methodType = type.resolveConstantDesc(lookup);\n-        return handle.asType(methodType);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return  String.format(\"%s.asType%s\", underlying.toString(), type.displayDescriptor());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/AsTypeMethodHandleDesc.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -47,1 +47,0 @@\n-import static java.lang.constant.DirectMethodHandleDesc.*;\n@@ -341,3 +340,0 @@\n-    static final DirectMethodHandleDesc MHD_METHODHANDLE_ASTYPE\n-            = MethodHandleDesc.ofMethod(Kind.VIRTUAL, CD_MethodHandle, \"asType\",\n-                                        MethodTypeDesc.of(CD_MethodHandle, CD_MethodType));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.internal.constant.AsTypeMethodHandleDesc;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.StandardCharsets;\n@@ -4152,5 +4150,1 @@\n-            try {\n-                return JLA.uncheckedNewStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n-            } catch (CharacterCodingException cce) {\n-                throw new AssertionError(cce);\n-            }\n+            return JLA.uncheckedNewStringWithLatin1Bytes(buf);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.List;\n@@ -43,0 +44,1 @@\n+import java.util.Objects;\n@@ -47,0 +49,1 @@\n+import java.util.function.Supplier;\n@@ -384,11 +387,1 @@\n-    private static class ThreadTrackHolder {\n-        static final ThreadTracker TRACKER = new ThreadTracker();\n-    }\n-\n-    private static Object tryBeginLookup() {\n-        return ThreadTrackHolder.TRACKER.tryBegin();\n-    }\n-\n-    private static void endLookup(Object key) {\n-        ThreadTrackHolder.TRACKER.end(key);\n-    }\n+    private static final ScopedValue<Boolean> IN_LOOKUP = ScopedValue.newInstance();\n@@ -409,2 +402,1 @@\n-        Object key = tryBeginLookup();\n-        if (key == null) {\n+        if (IN_LOOKUP.isBound()) {\n@@ -415,9 +407,17 @@\n-            for (Iterator<CharsetProvider> i = providers(); i.hasNext();) {\n-                CharsetProvider cp = i.next();\n-                Charset cs = cp.charsetForName(charsetName);\n-                if (cs != null)\n-                    return cs;\n-            }\n-            return null;\n-        } finally {\n-            endLookup(key);\n+            return ScopedValue.where(IN_LOOKUP, true).call(\n+                    new ScopedValue.CallableOp<Charset, Exception>() {\n+                        @Override\n+                        public Charset call() {\n+                            for (Iterator<CharsetProvider> i = providers(); i.hasNext(); ) {\n+                                CharsetProvider cp = i.next();\n+                                Charset cs = cp.charsetForName(charsetName);\n+                                if (cs != null)\n+                                    return cs;\n+                            }\n+                            return null;\n+                        }\n+                    }\n+            );\n+        } catch (Exception t) {\n+            \/\/ Should not happen\n+            throw new RuntimeException(t);\n@@ -425,0 +425,1 @@\n+\n@@ -428,7 +429,7 @@\n-    private static class ExtendedProviderHolder {\n-        static final CharsetProvider[] extendedProviders = extendedProviders();\n-        \/\/ returns ExtendedProvider, if installed\n-        private static CharsetProvider[] extendedProviders() {\n-            CharsetProvider[] cps = new CharsetProvider[1];\n-            int n = 0;\n-            ServiceLoader<CharsetProvider> sl =\n+    private static final Supplier<List<CharsetProvider>> EXTENDED_PROVIDERS = StableValue.supplier(\n+            new Supplier<>() { public List<CharsetProvider> get() { return extendedProviders0(); }});\n+\n+    private static List<CharsetProvider> extendedProviders0() {\n+        CharsetProvider[] cps = new CharsetProvider[1];\n+        int n = 0;\n+        final ServiceLoader<CharsetProvider> sl =\n@@ -436,5 +437,3 @@\n-            for (CharsetProvider cp : sl) {\n-                if (n + 1 > cps.length) {\n-                    cps = Arrays.copyOf(cps, cps.length << 1);\n-                }\n-                cps[n++] = cp;\n+        for (CharsetProvider cp : sl) {\n+            if (n + 1 > cps.length) {\n+                cps = Arrays.copyOf(cps, cps.length << 1);\n@@ -442,1 +441,1 @@\n-            return n == cps.length ? cps : Arrays.copyOf(cps, n);\n+            cps[n++] = cp;\n@@ -444,0 +443,1 @@\n+        return List.of(n == cps.length ? cps : Arrays.copyOf(cps, n));\n@@ -449,2 +449,1 @@\n-        CharsetProvider[] ecps = ExtendedProviderHolder.extendedProviders;\n-        for (CharsetProvider cp : ecps) {\n+        for (CharsetProvider cp : EXTENDED_PROVIDERS.get()) {\n@@ -610,2 +609,1 @@\n-        CharsetProvider[] ecps = ExtendedProviderHolder.extendedProviders;\n-        for (CharsetProvider ecp :ecps) {\n+        for (CharsetProvider ecp : EXTENDED_PROVIDERS.get()) {\n@@ -622,1 +620,10 @@\n-    private @Stable static Charset defaultCharset;\n+    private static final Supplier<Charset> defaultCharset = StableValue.supplier(\n+            new Supplier<>() { public Charset get() { return defaultCharset0(); }});\n+\n+    private static Charset defaultCharset0() {\n+        \/\/ do not look for providers other than the standard one\n+        final Charset cs = standardProvider.charsetForName(StaticProperty.fileEncoding());\n+        return (cs == null)\n+                ? sun.nio.cs.UTF_8.INSTANCE\n+                : cs;\n+    }\n@@ -643,11 +650,1 @@\n-        if (defaultCharset == null) {\n-            synchronized (Charset.class) {\n-                \/\/ do not look for providers other than the standard one\n-                Charset cs = standardProvider.charsetForName(StaticProperty.fileEncoding());\n-                if (cs != null)\n-                    defaultCharset = cs;\n-                else\n-                    defaultCharset = sun.nio.cs.UTF_8.INSTANCE;\n-            }\n-        }\n-        return defaultCharset;\n+        return defaultCharset.get();\n@@ -659,3 +656,7 @@\n-    private final String name;          \/\/ tickles a bug in oldjavac\n-    private final String[] aliases;     \/\/ tickles a bug in oldjavac\n-    private Set<String> aliasSet;\n+    @Stable\n+    private final String name;\n+    @Stable\n+    private final String[] aliases;\n+    @Stable\n+    private final Supplier<Set<String>> aliasSet = StableValue.supplier(\n+            new Supplier<>() { public Set<String> get() { return Set.of(aliases); }});\n@@ -713,6 +714,1 @@\n-        Set<String> set = this.aliasSet;\n-        if (set == null) {\n-            set = Set.of(aliases);\n-            this.aliasSet = set;\n-        }\n-        return set;\n+        return aliasSet.get();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/charset\/Charset.java","additions":56,"deletions":60,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -655,8 +655,1 @@\n-        \/* Detecting whether a double is negative is easy with the exception of\n-         * the value -0.0.  This is a double which has a zero mantissa (and\n-         * exponent), but a negative sign bit.  It is semantically distinct from\n-         * a zero with a positive sign bit, and this distinction is important\n-         * to certain kinds of computations.  However, it's a little tricky to\n-         * detect, since (-0.0 == 0.0) and !(-0.0 < 0.0).  How then, you may\n-         * ask, does it behave distinctly from +0.0?  Well, 1\/(-0.0) ==\n-         * -Infinity.  Proper detection of -0.0 is needed to deal with the\n+        \/* Proper detection of -0.0 is needed to deal with the\n@@ -665,1 +658,1 @@\n-        boolean isNegative = ((number < 0.0) || (number == 0.0 && 1\/number < 0.0)) ^ (multiplier < 0);\n+        boolean isNegative = Double.doubleToRawLongBits(number) < 0 ^ multiplier < 0;\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,3 +62,6 @@\n- * <p>If the locale contains \"rg\" (region override)\n- * <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extension<\/a>,\n- * the symbols are overridden for the designated region.\n+ * <p>The \"rg\" (region override), \"nu\" (numbering system), and \"cu\" (currency)\n+ * {@code Locale} <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode\n+ * extensions<\/a> are supported which may override values within the symbols.\n+ * For both \"nu\" and \"cu\", if they are specified in addition to \"rg\" by the\n+ * backing {@code Locale}, the respective values from the \"nu\" and \"cu\" extension\n+ * supersede the implicit ones from the \"rg\" extension.\n@@ -91,1 +94,1 @@\n-        initialize( Locale.getDefault(Locale.Category.FORMAT) );\n+        initialize(Locale.getDefault(Locale.Category.FORMAT));\n@@ -114,2 +117,2 @@\n-    public DecimalFormatSymbols( Locale locale ) {\n-        initialize( locale );\n+    public DecimalFormatSymbols(Locale locale) {\n+        initialize(locale);\n@@ -815,1 +818,1 @@\n-    private void initialize( Locale locale ) {\n+    private void initialize(Locale locale) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormatSymbols.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- *\n+ * <p>\n@@ -59,1 +59,1 @@\n- *\n+ * <p>\n@@ -85,1 +85,1 @@\n-     *\n+     * <p>\n@@ -91,1 +91,1 @@\n-     *\n+     * <p>\n@@ -95,1 +95,1 @@\n-     *\n+     * <p>\n@@ -100,1 +100,1 @@\n-     *\n+     * <p>\n@@ -169,1 +169,1 @@\n-    public final double getDouble() {\n+    public double getDouble() {\n@@ -181,1 +181,1 @@\n-    public final long getLong() {\n+    public long getLong() {\n@@ -211,1 +211,1 @@\n-    public final BigDecimal getBigDecimal() {\n+    public BigDecimal getBigDecimal() {\n@@ -283,1 +283,1 @@\n-    final void set(boolean isNegative, double source, int maximumFractionDigits) {\n+    void set(boolean isNegative, double source, int maximumFractionDigits) {\n@@ -287,0 +287,16 @@\n+    \/*\n+     * This compatibility option will only be available for a *very* limited\n+     * number of releases.\n+     * It restores the original behavior to help migrating to the new one,\n+     * and is used by adding\n+     *      -Djdk.compat.DecimalFormat=true\n+     * to the launcher's command line.\n+     *\n+     * The new behavior differs from the old one only in very rare cases,\n+     * so migration should be painless.\n+     *\n+     * When this option is removed, the old behavior, including relevant\n+     * fields and methods, will be removed as well.\n+     *\/\n+    private static final boolean COMPAT = Boolean.getBoolean(\"jdk.compat.DecimalFormat\");\n+\n@@ -298,3 +314,3 @@\n-    final void set(boolean isNegative, double source, int maximumDigits, boolean fixedPoint) {\n-\n-        FloatingDecimal.BinaryToASCIIConverter fdConverter  = FloatingDecimal.getBinaryToASCIIConverter(source);\n+    void set(boolean isNegative, double source, int maximumDigits, boolean fixedPoint) {\n+        FloatingDecimal.BinaryToASCIIConverter fdConverter =\n+                FloatingDecimal.getBinaryToASCIIConverter(source, COMPAT);\n@@ -418,1 +434,1 @@\n-    private final void round(int maximumDigits,\n+    private void round(int maximumDigits,\n@@ -585,1 +601,1 @@\n-    final void set(boolean isNegative, long source) {\n+    void set(boolean isNegative, long source) {\n@@ -598,1 +614,1 @@\n-    final void set(boolean isNegative, long source, int maximumDigits) {\n+    void set(boolean isNegative, long source, int maximumDigits) {\n@@ -648,1 +664,1 @@\n-    final void set(boolean isNegative, BigDecimal source, int maximumDigits, boolean fixedPoint) {\n+    void set(boolean isNegative, BigDecimal source, int maximumDigits, boolean fixedPoint) {\n@@ -665,1 +681,1 @@\n-    final void set(boolean isNegative, BigInteger source, int maximumDigits) {\n+    void set(boolean isNegative, BigInteger source, int maximumDigits) {\n@@ -775,1 +791,1 @@\n-    private final char[] getDataChars(int length) {\n+    private char[] getDataChars(int length) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":35,"deletions":19,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -106,0 +106,3 @@\n+ * <li> \"cu\"\n+ * (<a href=\"https:\/\/www.unicode.org\/reports\/tr35\/tr35.html#UnicodeCurrencyIdentifier\">\n+ * Currency Type<\/a>) - Overrides the Currency used\n@@ -108,2 +111,2 @@\n- * If both \"nu\" and \"rg\" are specified, the decimal digits from the \"nu\"\n- * extension supersedes the implicit one from the \"rg\" extension.\n+ * For both \"nu\" and \"cu\", if they are specified in addition to \"rg\", the respective\n+ * values from the \"nu\" and \"cu\" extension supersede the implicit ones from the \"rg\" extension.\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.StandardCharsets;\n@@ -463,6 +461,1 @@\n-        try {\n-            \/\/ Return a new string using the bytes without making a copy\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -698,5 +691,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -734,5 +723,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -762,5 +747,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -798,5 +779,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -826,5 +803,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":6,"deletions":33,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.StandardCharsets;\n@@ -482,5 +480,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(buf);\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -255,1 +256,7 @@\n-            return JLA.newStringUTF8NoRepl(ba, off, length);\n+            try {\n+                \/\/ Copy subrange for exclusive use by the string being created\n+                byte[] bytes = Arrays.copyOfRange(ba, off, off + length);\n+                return JLA.uncheckedNewStringNoRepl(bytes, StandardCharsets.UTF_8);\n+            } catch (CharacterCodingException cce) {\n+                throw new IllegalArgumentException(cce);\n+            }\n@@ -276,1 +283,1 @@\n-                return hash(JLA.newStringUTF8NoRepl(a, off, len));\n+                return hash(toString(a, off, len));\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.function.BiFunction;\n@@ -320,0 +321,12 @@\n+    \/**\n+     * Constructs a new {@code String} with the supplied Latin1 bytes.\n+     * <p>\n+     * <b>WARNING: The caller of this method shall relinquish and transfer the\n+     * ownership of the byte array to the callee<\/b>, since the latter will not\n+     * make a copy.\n+     *\n+     * @param bytes the byte array source\n+     * @return the newly created string\n+     *\/\n+    String uncheckedNewStringWithLatin1Bytes(byte[] bytes);\n+\n@@ -353,10 +366,0 @@\n-    \/**\n-     * Returns a new string by decoding from the given UTF-8 bytes array.\n-     *\n-     * @param off the index of the first byte to decode\n-     * @param len the number of bytes to decode\n-     * @return the newly created string\n-     * @throws IllegalArgumentException for malformed or unmappable bytes.\n-     *\/\n-    String newStringUTF8NoRepl(byte[] bytes, int off, int len);\n-\n@@ -425,5 +428,3 @@\n-     * Encodes as many ASCII codepoints as possible from the source array into\n-     * the destination byte array, assuming that the encoding is ASCII\n-     * compatible.\n-     * <p>\n-     * <b>WARNING: This method does not perform any bound checks.<\/b>\n+     * Encodes as many ASCII codepoints as possible from the source\n+     * character array into the destination byte array, assuming that\n+     * the encoding is ASCII compatible.\n@@ -431,3 +432,9 @@\n-     * @return the number of bytes successfully encoded, or 0 if none\n-     *\/\n-    int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len);\n+     * @param sa the source character array\n+     * @param sp the index of the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the total number of characters to be encoded\n+     * @return the total number of characters successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     *\/\n+    int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":25,"deletions":18,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.classfile.constantpool.ClassEntry;\n@@ -31,1 +32,1 @@\n-import java.lang.constant.ConstantDesc;\n+import java.util.ArrayList;\n@@ -42,1 +43,0 @@\n-    final Set<ConstantDesc> catchTypes;\n@@ -49,1 +49,0 @@\n-        this.catchTypes = new HashSet<>();\n@@ -62,3 +61,8 @@\n-        if (catchBlock == null) {\n-            if (tryBlock.reachable()) {\n-                b.branch(Opcode.GOTO, tryCatchEnd);\n+        \/\/ nullable list of CP entries - null means catching all (0)\n+        List<ClassEntry> entries = new ArrayList<>(Math.max(1, exceptionTypes.size()));\n+        if (exceptionTypes.isEmpty()) {\n+            entries.add(null);\n+        } else {\n+            for (var exceptionType : exceptionTypes) {\n+                var entry = b.constantPool().classEntry(exceptionType); \/\/ throws IAE\n+                entries.add(entry);\n@@ -67,0 +71,1 @@\n+        \/\/ End validation\n@@ -68,3 +73,3 @@\n-        for (var exceptionType : exceptionTypes) {\n-            if (!catchTypes.add(exceptionType)) {\n-                throw new IllegalArgumentException(\"Existing catch block catches exception of type: \" + exceptionType);\n+        if (catchBlock == null) {\n+            if (tryBlock.reachable()) {\n+                b.branch(Opcode.GOTO, tryCatchEnd);\n@@ -85,7 +90,3 @@\n-        if (exceptionTypes.isEmpty()) {\n-            catchBlock.exceptionCatchAll(tryStart, tryEnd, catchBlock.startLabel());\n-        }\n-        else {\n-            for (var exceptionType : exceptionTypes) {\n-                catchBlock.exceptionCatch(tryStart, tryEnd, catchBlock.startLabel(), exceptionType);\n-            }\n+        for (var entry : entries) {\n+            \/\/ This accepts null for catching all\n+            catchBlock.exceptionCatch(tryStart, tryEnd, catchBlock.startLabel(), entry);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CatchBuilderImpl.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.constant.ConstantDescs.BSM_INVOKE;\n+import static java.lang.constant.ConstantDescs.CD_MethodHandle;\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a\n+ * {@link MethodHandle} constant that performs a {@link MethodHandle#asType(MethodType)}\n+ * adaptation on another {@link MethodHandle}.\n+ *\/\n+public final class AsTypeMethodHandleDesc extends DynamicConstantDesc<MethodHandle>\n+        implements MethodHandleDesc {\n+\n+    private static final DirectMethodHandleDesc MHD_METHODHANDLE_ASTYPE\n+            = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.VIRTUAL, CD_MethodHandle, \"asType\",\n+                                        MethodTypeDesc.of(CD_MethodHandle, ConstantDescs.CD_MethodType));\n+\n+    private final MethodHandleDesc underlying;\n+    private final MethodTypeDesc type;\n+\n+    public AsTypeMethodHandleDesc(MethodHandleDesc underlying, MethodTypeDesc type) {\n+        super(BSM_INVOKE, ConstantDescs.DEFAULT_NAME, CD_MethodHandle,\n+              MHD_METHODHANDLE_ASTYPE, underlying, type);\n+        this.underlying = requireNonNull(underlying);\n+        this.type = requireNonNull(type);\n+    }\n+\n+    @Override\n+    public MethodTypeDesc invocationType() {\n+        return type;\n+    }\n+\n+    @Override\n+    public MethodHandle resolveConstantDesc(MethodHandles.Lookup lookup)\n+            throws ReflectiveOperationException {\n+        MethodHandle handle = underlying.resolveConstantDesc(lookup);\n+        MethodType methodType = type.resolveConstantDesc(lookup);\n+        return handle.asType(methodType);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return  String.format(\"%s.asType%s\", underlying.toString(), type.displayDescriptor());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/AsTypeMethodHandleDesc.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -249,1 +249,1 @@\n-                        return toChars(str, index, f, 0, fd) - start;\n+                        return toChars(str, index, f, 0, fd, true, false) - start;\n@@ -327,0 +327,3 @@\n+             *\n+             * Also,\n+             * d_v = v      iff     4 sp10 = vb\n@@ -333,1 +336,2 @@\n-                return toChars(str, index, upin ? sp10 : tp10, k, fd);\n+                \/* Exactly one of u' or w' lies in Rv *\/\n+                return toChars(str, index, upin ? sp10 : tp10, k, fd, sp10 << 2 == vb, wpin);\n@@ -342,0 +346,3 @@\n+         *\n+         * Also,\n+         * d_v = v      iff     4 s = vb\n@@ -348,1 +355,1 @@\n-            return toChars(str, index, uin ? s : t, k + dk, fd);\n+            return toChars(str, index, uin ? s : t, k + dk, fd, s << 2 == vb, win);\n@@ -355,1 +362,2 @@\n-        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk, fd);\n+        boolean away = cmp > 0 || cmp == 0 && (s & 0x1) != 0;\n+        return toChars(str, index, away ? t : s, k + dk, fd, s << 2 == vb, away);\n@@ -374,1 +382,2 @@\n-    private int toChars(byte[] str, int index, long f, int e, FormattedFPDecimal fd) {\n+    private int toChars(byte[] str, int index, long f, int e,\n+                        FormattedFPDecimal fd, boolean exact, boolean away) {\n@@ -386,1 +395,1 @@\n-            fd.set(f, e, len);\n+            fd.set(f, e, len, exact, away);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleToDecimal.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -307,0 +307,1 @@\n+                \/* Exactly one of u' or w' lies in Rv *\/\n@@ -329,1 +330,2 @@\n-        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n+        boolean away = cmp > 0 || cmp == 0 && (s & 0x1) != 0;\n+        return toChars(str, index, away ? t : s, k + dk);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatToDecimal.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1745,1 +1745,2 @@\n-     * @param d The double precision value to convert.\n+     * @param d      The double precision value to convert.\n+     * @param compat    compatibility with releases < JDK 21\n@@ -1748,2 +1749,4 @@\n-    public static BinaryToASCIIConverter getBinaryToASCIIConverter(double d) {\n-        return getBinaryToASCIIConverter(d, true);\n+    public static BinaryToASCIIConverter getBinaryToASCIIConverter(double d, boolean compat) {\n+        return compat\n+                ? getCompatBinaryToASCIIConverter(d, true)\n+                : getBinaryToASCIIConverter(d);\n@@ -1752,7 +1755,26 @@\n-    \/**\n-     * Returns a <code>BinaryToASCIIConverter<\/code> for a <code>double<\/code>.\n-     * The returned object is a <code>ThreadLocal<\/code> variable of this class.\n-     *\n-     * @param d The double precision value to convert.\n-     * @param isCompatibleFormat\n-     * @return The converter.\n+    private static BinaryToASCIIConverter getBinaryToASCIIConverter(double d) {\n+        assert Double.isFinite(d);\n+\n+        FormattedFPDecimal dec = FormattedFPDecimal.split(d);\n+        BinaryToASCIIBuffer buf = getBinaryToASCIIBuffer();\n+\n+        buf.nDigits = dec.getPrecision();\n+        buf.decExponent = dec.getExp() + buf.nDigits;\n+        buf.firstDigitIndex = 0;\n+        buf.exactDecimalConversion = dec.getExact();\n+        buf.decimalDigitsRoundedUp = dec.getAway();\n+\n+        long f = dec.getSignificand();\n+        char[] digits = buf.digits;\n+        for (int i = buf.nDigits - 1; i >= 0; --i) {\n+            long q = f \/ 10;\n+            digits[i] = (char) ((f - 10 * q) + '0');\n+            f = q;\n+        }\n+        return buf;\n+    }\n+\n+    \/*\n+     * The old implementation of getBinaryToASCIIConverter().\n+     * Should be removed in the future, along with its dependent methods and\n+     * fields (> 550 lines).\n@@ -1760,1 +1782,1 @@\n-    static BinaryToASCIIConverter getBinaryToASCIIConverter(double d, boolean isCompatibleFormat) {\n+    private static BinaryToASCIIConverter getCompatBinaryToASCIIConverter(double d, boolean isCompatibleFormat) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":33,"deletions":11,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -50,1 +50,7 @@\n-    private long f;\n+    \/* Whether the decimal exactly represents the double *\/\n+    private boolean exact;\n+    \/*\n+     * When not exact, whether the magnitude of the decimal is larger than\n+     * the magnitude of the double. Aka \"away from zero\".\n+     *\/\n+    private boolean away;\n@@ -53,0 +59,1 @@\n+    private long f;\n@@ -71,1 +78,1 @@\n-    private static FormattedFPDecimal split(double v) {\n+    static FormattedFPDecimal split(double v) {\n@@ -122,1 +129,1 @@\n-        fd.set(s, eNew, prec);\n+        fd.set(s, eNew, prec, fd.exact, fd.away);\n@@ -135,0 +142,8 @@\n+    public boolean getAway() {\n+        return away;\n+    }\n+\n+    public boolean getExact() {\n+        return exact;\n+    }\n+\n@@ -139,1 +154,1 @@\n-    public void set(long f, int e, int n) {\n+    public void set(long f, int e, int n, boolean exact, boolean away) {\n@@ -144,0 +159,2 @@\n+        this.exact = exact;\n+        this.away = away;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FormattedFPDecimal.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-    V loadFromMemorySegment(Class<? extends V> vmClass, Class<E> e, int length,\n+    V loadFromMemorySegment(Class<? extends V> vmClass, Class<?> c, Class<E> e, int operType, int length,\n@@ -337,1 +337,1 @@\n-                    vmClass, e, length,\n+                    vmClass, c, e, operType, length,\n@@ -351,1 +351,1 @@\n-                                          Class<? extends V> vmClass, Class<E> e, int length,\n+                                          Class<? extends V> vmClass, Class<?> c, Class<E> e, int operType, int length,\n@@ -358,1 +358,1 @@\n-            return VectorSupport.load(vmClass, e, length,\n+            return VectorSupport.load(vmClass, c, e, operType, length,\n@@ -371,1 +371,1 @@\n-    V loadFromMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n+    V loadFromMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<?> c, Class<E> e, int operType,\n@@ -378,1 +378,1 @@\n-                    vmClass, maskClass, e, length,\n+                    vmClass, maskClass, c, e, operType, length,\n@@ -393,1 +393,1 @@\n-                                                Class<M> maskClass, Class<E> e, int length,\n+                                                Class<M> maskClass, Class<?> c, Class<E> e, int operType, int length,\n@@ -400,1 +400,1 @@\n-            return VectorSupport.loadMasked(vmClass, maskClass, e, length,\n+            return VectorSupport.loadMasked(vmClass, maskClass, c, e, operType, length,\n@@ -412,1 +412,1 @@\n-    void storeIntoMemorySegment(Class<? extends V> vmClass, Class<E> e, int length,\n+    void storeIntoMemorySegment(Class<? extends V> vmClass, Class<?> c, Class<E> e, int operType, int length,\n@@ -420,1 +420,1 @@\n-                    vmClass, e, length,\n+                    vmClass, c, e, operType, length,\n@@ -434,1 +434,1 @@\n-                                              Class<? extends V> vmClass, Class<E> e, int length,\n+                                              Class<? extends V> vmClass, Class<?> c, Class<E> e, int operType, int length,\n@@ -441,1 +441,1 @@\n-            VectorSupport.store(vmClass, e, length,\n+            VectorSupport.store(vmClass, c, e, operType, length,\n@@ -454,2 +454,2 @@\n-    void storeIntoMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n-                                      int length, V v, M m,\n+    void storeIntoMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<?> c, Class<E> e,\n+                                      int operType, int length, V v, M m,\n@@ -462,1 +462,1 @@\n-                    vmClass, maskClass, e, length,\n+                    vmClass, maskClass, c, e, operType, length,\n@@ -477,1 +477,1 @@\n-                                                    Class<E> e, int length, V v, M m,\n+                                                    Class<?> c, Class<E> e, int operType, int length, V v, M m,\n@@ -483,1 +483,1 @@\n-            VectorSupport.storeMasked(vmClass, maskClass, e, length,\n+            VectorSupport.storeMasked(vmClass, maskClass, c, e, operType, length,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -433,0 +433,1 @@\n+            Objects.requireNonNull(name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,0 +152,6 @@\n+    \/\/ Vector operation types.\n+    public static final int VECTOR_TYPE_PRIM = 1;\n+    public static final int VECTOR_TYPE_FP16 = 2;\n+    public static final int VECTOR_TYPE_FP8  = 3;\n+    public static final int VECTOR_TYPE_INT8 = 4;\n+\n@@ -154,6 +160,7 @@\n-        T_FLOAT   = 6,\n-        T_DOUBLE  = 7,\n-        T_BYTE    = 8,\n-        T_SHORT   = 9,\n-        T_INT     = 10,\n-        T_LONG    = 11;\n+        T_HALFFLOAT = 5,\n+        T_FLOAT     = 6,\n+        T_DOUBLE    = 7,\n+        T_BYTE      = 8,\n+        T_SHORT     = 9,\n+        T_INT       = 10,\n+        T_LONG      = 11;\n@@ -206,1 +213,1 @@\n-    VM fromBitsCoerced(Class<? extends VM> vmClass, Class<E> eClass,\n+    VM fromBitsCoerced(Class<? extends VM> vmClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -224,1 +231,1 @@\n-    M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<E> eClass,\n+    M indexPartiallyInUpperRange(Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -242,1 +249,1 @@\n-    V indexVector(Class<? extends V> vClass, Class<E> eClass,\n+    V indexVector(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -263,1 +270,1 @@\n-                          Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+                          Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -282,1 +289,1 @@\n-    long extract(Class<? extends VM> vClass, Class<E> eClass,\n+    long extract(Class<? extends VM> vClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -300,1 +307,1 @@\n-    V insert(Class<? extends V> vClass, Class<E> eClass,\n+    V insert(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -321,1 +328,1 @@\n-              Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+              Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -359,1 +366,1 @@\n-                Class<? extends VM> vmClass, Class<? extends M> mClass, Class<E> eClass,\n+                Class<? extends VM> vmClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -394,1 +401,1 @@\n-    V selectFromTwoVectorOp(Class<? extends V> vClass, Class<E> eClass, int length,\n+    V selectFromTwoVectorOp(Class<? extends V> vClass, Class<?> cClass, Class<E> eClass, int operType, int length,\n@@ -416,1 +423,1 @@\n-                Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+                Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -440,1 +447,1 @@\n-    VM load(Class<? extends VM> vmClass, Class<E> eClass,\n+    VM load(Class<? extends VM> vmClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -465,1 +472,1 @@\n-    V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+    V loadMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -491,1 +498,1 @@\n-    V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+    V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -513,1 +520,1 @@\n-    void store(Class<?> vClass, Class<?> eClass,\n+    void store(Class<?> vClass, Class<?> cClass, Class<?> eClass, int operType,\n@@ -534,1 +541,1 @@\n-    void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+    void storeMasked(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -558,1 +565,1 @@\n-    void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+    void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -576,1 +583,1 @@\n-                 Class<?> mClass, Class<?> eClass,\n+                 Class<?> mClass, Class<?> cClass, Class<E> eClass, int opType,\n@@ -597,1 +604,1 @@\n-              Class<? extends V> vectorClass, Class<M> mClass, Class<E> eClass,\n+              Class<? extends V> vectorClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -618,1 +625,1 @@\n-    V rearrangeOp(Class<? extends V> vClass, Class<SH> shClass, Class<M> mClass, Class<E> eClass,\n+    V rearrangeOp(Class<? extends V> vClass, Class<SH> shClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -636,1 +643,1 @@\n-    V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+    V selectFromOp(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -655,1 +662,1 @@\n-    V blend(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+    V blend(Class<? extends V> vClass, Class<M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -676,1 +683,1 @@\n-                   Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -722,1 +729,1 @@\n-                                   Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+                                   Class<? extends V> vClass, Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n@@ -751,1 +758,1 @@\n-                              Class<? extends M> mClass, Class<?> eClass,\n+                              Class<? extends M> mClass, Class<?> cClass, Class<E> eClass, int operType,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":37,"deletions":30,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -157,7 +157,1 @@\n-        jdk.compiler,\n-        jdk.incubator.vector, \/\/ participates in preview features\n-        jdk.jartool, \/\/ participates in preview features\n-        jdk.jdeps, \/\/ participates in preview features\n-        jdk.jfr, \/\/ participates in preview features\n-        jdk.jlink,   \/\/ participates in preview features\n-        jdk.jshell; \/\/ participates in preview features\n+        jdk.compiler;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n@@ -554,1 +554,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(len, da.length));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(len, da.length));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/CESU_8.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-                    int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                    int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n@@ -689,1 +689,1 @@\n-                int n = JLA.uncheckedEncodeASCII(src, sp, dst, dp, len);\n+                int n = JLA.encodeASCII(src, sp, dst, dp, len);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/DoubleByte.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.util.Preconditions;\n@@ -145,1 +144,13 @@\n-        \/\/ Method possible replaced with a compiler intrinsic.\n+        \/**\n+         * Encodes as many ISO-8859-1 codepoints as possible from the source\n+         * character array into the destination byte array, assuming that\n+         * the encoding is ISO-8859-1 compatible.\n+         *\n+         * @param sa the source character array\n+         * @param sp the index of the source array to start reading from\n+         * @param da the target byte array\n+         * @param dp the index of the target array to start writing to\n+         * @param len the maximum number of characters to be encoded\n+         * @return the total number of characters successfully encoded\n+         * @throws NullPointerException if any of the provided arrays is null\n+         *\/\n@@ -148,1 +159,5 @@\n-            if (len <= 0) {\n+            \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n+            \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n+            if ((sp | dp | len) < 0 ||\n+                    sp >= sa.length ||      \/\/ Implicit null check on `sa`\n+                    dp >= da.length) {      \/\/ Implicit null check on `da`\n@@ -151,2 +166,2 @@\n-            encodeISOArrayCheck(sa, sp, da, dp, len);\n-            return implEncodeISOArray(sa, sp, da, dp, len);\n+            int minLen = Math.min(len, Math.min(sa.length - sp, da.length - dp));\n+            return encodeISOArray0(sa, sp, da, dp, minLen);\n@@ -156,3 +171,1 @@\n-        private static int implEncodeISOArray(char[] sa, int sp,\n-                                              byte[] da, int dp, int len)\n-        {\n+        private static int encodeISOArray0(char[] sa, int sp, byte[] da, int dp, int len) {\n@@ -169,11 +182,0 @@\n-        private static void encodeISOArrayCheck(char[] sa, int sp,\n-                                                byte[] da, int dp, int len) {\n-            Objects.requireNonNull(sa);\n-            Objects.requireNonNull(da);\n-            Preconditions.checkIndex(sp, sa.length, Preconditions.AIOOBE_FORMATTER);\n-            Preconditions.checkIndex(dp, da.length, Preconditions.AIOOBE_FORMATTER);\n-\n-            Preconditions.checkIndex(sp + len - 1, sa.length, Preconditions.AIOOBE_FORMATTER);\n-            Preconditions.checkIndex(dp + len - 1, da.length, Preconditions.AIOOBE_FORMATTER);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/ISO_8859_1.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-                int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, len);\n+                int n = JLA.encodeASCII(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/SingleByte.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/US_ASCII.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/UTF_8.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -346,8 +346,0 @@\n-#if defined(_ALLBSD_SOURCE)\n-    my_openat_func = (openat_func*) openat;\n-    my_fstatat_func = (fstatat_func*) fstatat;\n-#else\n-    \/\/ Make sure we link to the 64-bit version of the functions\n-    my_openat_func = (openat_func*) dlsym(RTLD_DEFAULT, \"openat64\");\n-    my_fstatat_func = (fstatat_func*) dlsym(RTLD_DEFAULT, \"fstatat64\");\n-#endif\n@@ -357,0 +349,2 @@\n+    my_openat_func = (openat_func*) dlsym(RTLD_DEFAULT, \"open64at\");\n+    my_fstatat_func = (fstatat_func*) dlsym(RTLD_DEFAULT, \"stat64at\");\n@@ -360,0 +354,2 @@\n+    my_openat_func = (openat_func*) openat;\n+    my_fstatat_func = (fstatat_func*) fstatat;\n@@ -362,0 +358,3 @@\n+    \/\/ Make sure we link to the 64-bit version of the functions\n+    my_openat_func = (openat_func*) dlsym(RTLD_DEFAULT, \"openat64\");\n+    my_fstatat_func = (fstatat_func*) dlsym(RTLD_DEFAULT, \"fstatat64\");\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,3 +36,4 @@\n-    private Cache cache = new Cache();\n-    CFont fFont;\n-    int numGlyphs = -1;\n+    private final Cache rawCache = new Cache(true);\n+    private final Cache modCache = new Cache(false);\n+    private final CFont fFont;\n+    private int numGlyphs = -1;\n@@ -104,1 +105,2 @@\n-        int glyph = cache.get(unicode, raw);\n+        Cache cache = raw ? rawCache : modCache;\n+        int glyph = cache.get(unicode);\n@@ -107,4 +109,8 @@\n-        final char[] unicodeArray = new char[] { unicode };\n-        final int[] glyphArray = new int[1];\n-        nativeCharsToGlyphs(fFont.getNativeFontPtr(), 1, unicodeArray, glyphArray);\n-        glyph = glyphArray[0];\n+        if (isIgnorableWhitespace(unicode) || (isDefaultIgnorable(unicode) && !raw)) {\n+            glyph = INVISIBLE_GLYPH_ID;\n+        } else {\n+            final char[] unicodeArray = new char[]{unicode};\n+            final int[] glyphArray = new int[1];\n+            nativeCharsToGlyphs(fFont.getNativeFontPtr(), 1, unicodeArray, glyphArray);\n+            glyph = glyphArray[0];\n+        }\n@@ -134,1 +140,2 @@\n-            cache.get(2, surrogates, glyphs, raw);\n+            Cache cache = raw ? rawCache : modCache;\n+            cache.get(2, surrogates, glyphs);\n@@ -143,1 +150,1 @@\n-        cache.get(count, unicodes, glyphs, false);\n+        modCache.get(count, unicodes, glyphs);\n@@ -167,0 +174,1 @@\n+        private final boolean raw;\n@@ -171,1 +179,2 @@\n-        Cache() {\n+        Cache(boolean raw) {\n+            this.raw = raw;\n@@ -176,5 +185,1 @@\n-        public synchronized int get(final int index, final boolean raw) {\n-            if (isIgnorableWhitespace(index) || (isDefaultIgnorable(index) && !raw)) {\n-                return INVISIBLE_GLYPH_ID;\n-            }\n-\n+        public synchronized int get(final int index) {\n@@ -251,1 +256,1 @@\n-        public synchronized void get(int count, char[] indices, int[] values, boolean raw)\n+        public synchronized void get(int count, char[] indices, int[] values)\n@@ -273,1 +278,1 @@\n-                final int value = get(code, raw);\n+                final int value = get(code);\n@@ -280,0 +285,3 @@\n+                } else if (isIgnorableWhitespace(code) || (isDefaultIgnorable(code) && !raw)) {\n+                    values[i] = INVISIBLE_GLYPH_ID;\n+                    put(code, INVISIBLE_GLYPH_ID);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CCharToGlyphMapper.java","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -74,6 +74,0 @@\n-\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer (for improved performance; no need to call\n-        \/\/ super.finalize() in this case)\n-    }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/common\/SubImageInputStream.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -149,7 +149,0 @@\n-\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer (for improved performance; no need to call\n-        \/\/ super.finalize() in this case)\n-    }\n@@ -286,7 +279,0 @@\n-\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer (for improved performance; no need to call\n-        \/\/ super.finalize() in this case)\n-    }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/png\/PNGImageWriter.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,73 +1,0 @@\n-\/*\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.imageio.stream;\n-\n-import java.io.IOException;\n-import javax.imageio.stream.ImageInputStream;\n-\n-\/**\n- * Small class to assist in properly closing an ImageInputStream instance\n- * prior to garbage collection.  The ImageInputStreamImpl class defines a\n- * finalize() method, but in a number of its public subclasses\n- * (e.g. FileImageInputStream) we override the finalize() method to be\n- * empty for performance reasons, and instead rely on the Disposer mechanism\n- * for closing\/disposing resources.  This is fine when one of these classes\n- * is instantiated directly (e.g. new FileImageInputStream()) but in the\n- * unlikely case where a user defines their own subclass of one of those\n- * streams, we need some way to get back to the behavior of\n- * ImageInputStreamImpl, which will call close() as part of finalization.\n- *\n- * Typically an Image{Input,Output}Stream will construct an instance of\n- * StreamFinalizer in its constructor if it detects that it has been\n- * subclassed by the user.  The ImageInputStream instance will hold a\n- * reference to the StreamFinalizer, and the StreamFinalizer will hold a\n- * reference back to the ImageInputStream from which it was created.  When\n- * both are no longer reachable, the StreamFinalizer.finalize() method will\n- * be called, which will take care of closing down the ImageInputStream.\n- *\n- * Clearly this is a bit of a hack, but it will likely only be used in the\n- * rarest of circumstances: when a user has subclassed one of the public\n- * stream classes.  (It should be no worse than the old days when the public\n- * stream classes had non-empty finalize() methods.)\n- *\/\n-public class StreamFinalizer {\n-    private ImageInputStream stream;\n-\n-    public StreamFinalizer(ImageInputStream stream) {\n-        this.stream = stream;\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        try {\n-            stream.close();\n-        } catch (IOException e) {\n-        } finally {\n-            stream = null;\n-            super.finalize();\n-        }\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/stream\/StreamFinalizer.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -54,0 +54,1 @@\n+import sun.java2d.cmm.BuiltinProfileInfo;\n@@ -58,1 +59,0 @@\n-import sun.java2d.cmm.ProfileDeferralInfo;\n@@ -105,4 +105,3 @@\n-     * Stores some information about {@code ICC_Profile} without causing a\n-     * deferred profile to be loaded. Note that we can defer the loading of\n-     * standard profiles only. If this field is null, then {@link #cmmProfile}\n-     * should be used to access profile information.\n+     * Stores information about a built-in profile without triggering profile\n+     * loading. If this field is null, {@link #cmmProfile} should be used to\n+     * access profile data. If not null, the profile is considered immutable.\n@@ -110,9 +109,1 @@\n-    private transient volatile ProfileDeferralInfo deferralInfo;\n-\n-\n-    \/**\n-     * Set to {@code true} for {@code BuiltInProfile}, {@code false} otherwise.\n-     * This flag is used in {@link #setData(int, byte[])} to prevent modifying\n-     * built-in profiles.\n-     *\/\n-    private final transient boolean builtIn;\n+    private transient final BuiltinProfileInfo builtInInfo;\n@@ -127,1 +118,1 @@\n-         * ProfileDeferralInfo is used for built-in profile creation only,\n+         * BuiltinProfileInfo is used for built-in profile creation only,\n@@ -130,1 +121,1 @@\n-        ICC_Profile SRGB = new ICC_ProfileRGB(new ProfileDeferralInfo(\n+        ICC_Profile SRGB = new ICC_ProfileRGB(new BuiltinProfileInfo(\n@@ -133,1 +124,1 @@\n-        ICC_Profile LRGB = new ICC_ProfileRGB(new ProfileDeferralInfo(\n+        ICC_Profile LRGB = new ICC_ProfileRGB(new BuiltinProfileInfo(\n@@ -136,1 +127,1 @@\n-        ICC_Profile XYZ = new ICC_Profile(new ProfileDeferralInfo(\n+        ICC_Profile XYZ = new ICC_Profile(new BuiltinProfileInfo(\n@@ -139,1 +130,1 @@\n-        ICC_Profile PYCC = new ICC_Profile(new ProfileDeferralInfo(\n+        ICC_Profile PYCC = new ICC_Profile(new BuiltinProfileInfo(\n@@ -142,1 +133,1 @@\n-        ICC_Profile GRAY = new ICC_ProfileGray(new ProfileDeferralInfo(\n+        ICC_Profile GRAY = new ICC_ProfileGray(new BuiltinProfileInfo(\n@@ -774,1 +765,1 @@\n-        builtIn = false;\n+        builtInInfo = null;\n@@ -782,1 +773,1 @@\n-     * Note: {@code ProfileDeferralInfo} is used for built-in profile\n+     * Note: {@code BuiltinProfileInfo} is used for built-in profile\n@@ -785,3 +776,2 @@\n-    ICC_Profile(ProfileDeferralInfo pdi) {\n-        deferralInfo = pdi;\n-        builtIn = true;\n+    ICC_Profile(BuiltinProfileInfo bpi) {\n+        builtInInfo = bpi;\n@@ -937,1 +927,1 @@\n-            var is = getStandardProfileInputStream(deferralInfo.filename);\n+            var is = getStandardProfileInputStream(builtInInfo.filename);\n@@ -945,2 +935,0 @@\n-                    \/\/ from now we cannot use the deferred value, drop it\n-                    deferralInfo = null;\n@@ -978,3 +966,2 @@\n-        ProfileDeferralInfo info = deferralInfo;\n-        if (info != null) {\n-            return info.profileClass;\n+        if (builtInInfo != null) {\n+            return builtInInfo.profileClass;\n@@ -1015,3 +1002,2 @@\n-        ProfileDeferralInfo info = deferralInfo;\n-        if (info != null) {\n-            return info.colorSpaceType;\n+        if (builtInInfo != null) {\n+            return builtInInfo.colorSpaceType;\n@@ -1163,2 +1149,2 @@\n-        if (builtIn) {\n-            throw new IllegalArgumentException(\"Built-in profile cannot be modified\");\n+        if (builtInInfo != null) {\n+            throw new IllegalArgumentException(\"Can't modify built-in profile\");\n@@ -1208,3 +1194,2 @@\n-        ProfileDeferralInfo info = deferralInfo;\n-        if (info != null) {\n-            return info.numComponents;\n+        if (builtInInfo != null) {\n+            return builtInInfo.numComponents;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":24,"deletions":39,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.java2d.cmm.BuiltinProfileInfo;\n@@ -41,1 +42,0 @@\n-import sun.java2d.cmm.ProfileDeferralInfo;\n@@ -90,1 +90,1 @@\n-     * {@code ProfileDeferralInfo} object.\n+     * {@code BuiltinProfileInfo} object.\n@@ -92,2 +92,2 @@\n-    ICC_ProfileGray(ProfileDeferralInfo pdi) {\n-        super(pdi);\n+    ICC_ProfileGray(BuiltinProfileInfo bpi) {\n+        super(bpi);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileGray.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.java2d.cmm.BuiltinProfileInfo;\n@@ -41,1 +42,0 @@\n-import sun.java2d.cmm.ProfileDeferralInfo;\n@@ -125,3 +125,1 @@\n-     * {@code ProfileDeferralInfo} object.\n-     *\n-     * @param  pdi\n+     * {@code BuiltinProfileInfo} object.\n@@ -129,2 +127,2 @@\n-    ICC_ProfileRGB(ProfileDeferralInfo pdi) {\n-        super(pdi);\n+    ICC_ProfileRGB(BuiltinProfileInfo bpi) {\n+        super(bpi);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileRGB.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2504,2 +2504,1 @@\n-     * result of calling any other method (other than\n-     * {@code finalize}) subsequent to a call to this method\n+     * result of calling any other method subsequent to a call to this method\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/ImageReader.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2003,2 +2003,1 @@\n-     * result of calling any other method (other than\n-     * {@code finalize}) subsequent to a call to this method\n+     * result of calling any other method subsequent to a call to this method\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/ImageWriter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.imageio.stream.StreamFinalizer;\n@@ -61,1 +60,1 @@\n-    private final Object disposerReferent;\n+    private final Object disposerReferent = new Object();\n@@ -112,6 +111,1 @@\n-        if (getClass() == FileCacheImageInputStream.class) {\n-            disposerReferent = new Object();\n-            Disposer.addRecord(disposerReferent, disposerRecord);\n-        } else {\n-            disposerReferent = new StreamFinalizer(this);\n-        }\n+        Disposer.addRecord(disposerReferent, disposerRecord);\n@@ -261,16 +255,1 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer: for performance reasons we instead use the\n-        \/\/ Disposer mechanism for ensuring that the underlying\n-        \/\/ RandomAccessFile is closed\/deleted prior to garbage collection\n-    }\n-\n-    private static class StreamDisposerRecord implements DisposerRecord {\n+    static class StreamDisposerRecord implements DisposerRecord {\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileCacheImageInputStream.java","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import javax.imageio.stream.FileCacheImageInputStream.StreamDisposerRecord;\n@@ -34,0 +35,2 @@\n+import sun.java2d.Disposer;\n+import sun.java2d.DisposerRecord;\n@@ -49,0 +52,3 @@\n+    private final Object disposerReferent = new Object();\n+\n+    private final StreamDisposerRecord disposerRecord;\n@@ -94,0 +100,7 @@\n+        \/\/ If this instance becomes unreachable the disposer will clean up resources\n+        \/\/ used for caching. This can't flush any un-flushed cache.\n+        this.disposerRecord = new StreamDisposerRecord(cacheFile, cache);\n+        Disposer.addRecord(this.disposerReferent, this.disposerRecord);\n+        \/\/ If the VM is exiting and this instance is still reachable,\n+        \/\/ StreamCloser will call close() to flush the cache and clean up resources.\n+        \/\/ However closing the java.io.OutputStream is the application's responsibility.\n@@ -234,1 +247,1 @@\n-        cache.close();\n+        disposerRecord.dispose();\n@@ -236,1 +249,0 @@\n-        cacheFile.delete();\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileCacheImageOutputStream.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import com.sun.imageio.stream.StreamFinalizer;\n@@ -48,1 +47,1 @@\n-    private final Object disposerReferent;\n+    private final Object disposerReferent = new Object();\n@@ -98,6 +97,1 @@\n-        if (getClass() == FileImageInputStream.class) {\n-            disposerReferent = new Object();\n-            Disposer.addRecord(disposerReferent, disposerRecord);\n-        } else {\n-            disposerReferent = new StreamFinalizer(this);\n-        }\n+        Disposer.addRecord(disposerReferent, disposerRecord);\n@@ -157,15 +151,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer: for performance reasons we instead use the\n-        \/\/ Disposer mechanism for ensuring that the underlying\n-        \/\/ RandomAccessFile is closed prior to garbage collection\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileImageInputStream.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import com.sun.imageio.stream.StreamFinalizer;\n@@ -47,1 +46,1 @@\n-    private final Object disposerReferent;\n+    private final Object disposerReferent = new Object();\n@@ -90,6 +89,1 @@\n-        if (getClass() == FileImageOutputStream.class) {\n-            disposerReferent = new Object();\n-            Disposer.addRecord(disposerReferent, disposerRecord);\n-        } else {\n-            disposerReferent = new StreamFinalizer(this);\n-        }\n+        Disposer.addRecord(disposerReferent, disposerRecord);\n@@ -165,15 +159,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer: for performance reasons we instead use the\n-        \/\/ Disposer mechanism for ensuring that the underlying\n-        \/\/ RandomAccessFile is closed prior to garbage collection\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileImageOutputStream.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -844,25 +844,0 @@\n-\n-    \/**\n-     * Finalizes this object prior to garbage collection.  The\n-     * {@code close} method is called to close any open input\n-     * source.  This method should not be called from application\n-     * code.\n-     *\n-     * @throws Throwable if an error occurs during superclass\n-     * finalization.\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        if (!isClosed) {\n-            try {\n-                close();\n-            } catch (IOException e) {\n-            }\n-        }\n-        super.finalize();\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/ImageInputStreamImpl.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import com.sun.imageio.stream.StreamFinalizer;\n@@ -53,1 +52,1 @@\n-    private final Object disposerReferent;\n+    private final Object disposerReferent = new Object();\n@@ -74,6 +73,1 @@\n-        if (getClass() == MemoryCacheImageInputStream.class) {\n-            disposerReferent = new Object();\n-            Disposer.addRecord(disposerReferent, disposerRecord);\n-        } else {\n-            disposerReferent = new StreamFinalizer(this);\n-        }\n+        Disposer.addRecord(disposerReferent, disposerRecord);\n@@ -179,15 +173,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer: for performance reasons we instead use the\n-        \/\/ Disposer mechanism for ensuring that the underlying\n-        \/\/ MemoryCache is reset prior to garbage collection\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/MemoryCacheImageInputStream.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -47,1 +47,25 @@\n- *\n+ * <p>\n+ * An {@code ImageInputStream} or {@code ImageOutputStream} may internally allocate\n+ * system resources, such as a temporary cache file.\n+ * Clients are encouraged to use a try-with-resources statement to ensure the\n+ * {@link ImageInputStream#close()} or {@link ImageOutputStream#close()}\n+ * method is called which can promptly free those native resources.\n+ * Otherwise there is the possibility they will leak and eventually cause the\n+ * application to fail as well the possibility that not all data is flushed\n+ * to the underlying output stream. A logical consequence of that is that\n+ * this should be done before closing the destination {@link java.io.OutputStream}.\n+ * A simple pattern would be\n+ * {@snippet lang='java':\n+ * try (FileOutputStream fos = new FileOutputStream(\"out.jpg\");\n+ *      ImageOutputStream ios = new FileCacheImageOutputStream(fos, null)) {\n+ *     ImageIO.write(img, \"jpg\", ios);\n+ * } catch (IOException e) {\n+ * } \/\/ implicit finally block closes the streams in the reverse order to opening\n+ * }\n+ * <p>\n+ * Sub-classers of these Image I\/O API stream types can, to a limited extent, protect\n+ * the application from the consequences of failures to close by adopting mechanisms\n+ * such as {@link java.lang.ref.Cleaner} to free internal resources when it\n+ * is no longer reachable. This is only necessary if there are any resources to release.\n+ * However applications cannot rely on this, either for resource management, or\n+ * for program correctness.\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/package-info.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-\/* remember that the API requires a Font use a\n+\/* Remember that the API requires a Font use a\n@@ -39,1 +39,1 @@\n- * to 216*256*4 bytes of storage per composite font. If an app\n+ * to 2*216*256*4 bytes of storage per composite font. If an app\n@@ -41,1 +41,1 @@\n- * over 1Mb of cached data. May need to employ WeakReferences if\n+ * over 2Mb of cached data. May need to employ WeakReferences if\n@@ -57,4 +57,5 @@\n-    CompositeFont font;\n-    CharToGlyphMapper[] slotMappers;\n-    int[][] glyphMaps;\n-    private boolean hasExcludes;\n+    private final CompositeFont font;\n+    private final CharToGlyphMapper[] slotMappers;\n+    private final int[][] glyphMapsRaw;\n+    private final int[][] glyphMapsMod;\n+    private final boolean hasExcludes;\n@@ -64,1 +65,6 @@\n-        initMapper();\n+        glyphMapsRaw = new int[NBLOCKS][];\n+        glyphMapsMod = new int[NBLOCKS][];\n+        slotMappers = new CharToGlyphMapper[font.numSlots];\n+        \/* This requires that slot 0 is never empty. *\/\n+        missingGlyph = font.getSlotFont(0).getMissingGlyphCode();\n+        missingGlyph = compositeGlyphCode(0, missingGlyph);\n@@ -76,13 +82,1 @@\n-    private void initMapper() {\n-        if (missingGlyph == CharToGlyphMapper.UNINITIALIZED_GLYPH) {\n-            if (glyphMaps == null) {\n-                glyphMaps = new int[NBLOCKS][];\n-            }\n-            slotMappers = new CharToGlyphMapper[font.numSlots];\n-            \/* This requires that slot 0 is never empty. *\/\n-            missingGlyph = font.getSlotFont(0).getMissingGlyphCode();\n-            missingGlyph = compositeGlyphCode(0, missingGlyph);\n-        }\n-    }\n-\n-    private int getCachedGlyphCode(int unicode) {\n+    private int getCachedGlyphCode(int unicode, boolean raw) {\n@@ -93,0 +87,1 @@\n+        int[][] glyphMaps = raw ? glyphMapsRaw : glyphMapsMod;\n@@ -99,1 +94,1 @@\n-    private void setCachedGlyphCode(int unicode, int glyphCode) {\n+    private void setCachedGlyphCode(int unicode, int glyphCode, boolean raw) {\n@@ -104,0 +99,1 @@\n+        int[][] glyphMaps = raw ? glyphMapsRaw : glyphMapsMod;\n@@ -123,4 +119,1 @@\n-        if (isIgnorableWhitespace(unicode) || (isDefaultIgnorable(unicode) && !raw)) {\n-            return INVISIBLE_GLYPH_ID;\n-        }\n-        int glyphCode = getCachedGlyphCode(unicode);\n+        int glyphCode = getCachedGlyphCode(unicode, raw);\n@@ -130,0 +123,5 @@\n+        if (isIgnorableWhitespace(unicode) || (isDefaultIgnorable(unicode) && !raw)) {\n+            glyphCode = INVISIBLE_GLYPH_ID;\n+            setCachedGlyphCode(unicode, glyphCode, raw);\n+            return glyphCode;\n+        }\n@@ -136,1 +134,1 @@\n-                    setCachedGlyphCode(unicode, glyphCode);\n+                    setCachedGlyphCode(unicode, glyphCode, raw);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CompositeGlyphMapper.java","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.cmm;\n+\n+\/**\n+ * Stores information about a built-in profile used by\n+ * ICC_Profile.getInstance(int cspace) to defer the loading of profile data and\n+ * CMM initialization. Since built-in profiles are immutable, this information\n+ * is always valid.\n+ *\/\n+public final class BuiltinProfileInfo {\n+\n+    \/**\n+     * Used by ICC_ColorSpace without triggering built-in profile loading.\n+     *\/\n+    public final int colorSpaceType, numComponents, profileClass;\n+\n+    \/**\n+     * The profile file name, such as \"CIEXYZ.pf\", \"sRGB.pf\", etc.\n+     *\/\n+    public final String filename;\n+\n+    public BuiltinProfileInfo(String fn, int type, int ncomp, int pclass) {\n+        filename = fn;\n+        colorSpaceType = type;\n+        numComponents = ncomp;\n+        profileClass = pclass;\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/BuiltinProfileInfo.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -1,52 +1,0 @@\n-\/*\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.cmm;\n-\n-\/**\n- * A class to pass information about a profile to be loaded from a file to the\n- * static getInstance(int cspace) method of ICC_Profile. Loading of the profile\n- * data and initialization of the CMM is to be deferred as long as possible.\n- *\/\n-public final class ProfileDeferralInfo {\n-\n-    \/**\n-     * Need to have this info for ICC_ColorSpace without causing a deferred\n-     * profile to be loaded.\n-     *\/\n-    public final int colorSpaceType, numComponents, profileClass;\n-\n-    \/**\n-     * The profile file name, such as \"CIEXYZ.pf\", \"sRGB.pf\", etc.\n-     *\/\n-    public final String filename;\n-\n-    public ProfileDeferralInfo(String fn, int type, int ncomp, int pclass) {\n-        filename = fn;\n-        colorSpaceType = type;\n-        numComponents = ncomp;\n-        profileClass = pclass;\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/ProfileDeferralInfo.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-            profiles[i].getNumComponents(); \/\/ force header initialization\n+            profiles[i].getMajorVersion(); \/\/ force header initialization\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSTransform.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2151,6 +2151,2 @@\n-            (Error OPAQUE_FRAME      \"Attempted to return early from a frame \"\n-                                     \"corresponding to a native method, \"\n-                                     \"the thread is a suspended virtual thread and the target \"\n-                                     \"VM is unable to force its current frame to return, \"\n-                                     \"or the implementation is unable to provide this \"\n-                                     \"functionality on this frame.\")\n+            (Error OPAQUE_FRAME      \"Unable to force the current frame to return \"\n+                                     \"(e.g. the current frame is executing a native method).\")\n@@ -2628,0 +2624,2 @@\n+            (Error OPAQUE_FRAME      \"Unable to get the value of local variables in the frame \"\n+                                     \"(e.g. the frame is executing a native method).\")\n@@ -2665,3 +2663,3 @@\n-            (Error OPAQUE_FRAME      \"The thread is a suspended virtual thread and the target VM \"\n-                                     \"does not support setting the value of local \"\n-                                     \"variables in the frame.\")\n+            (Error INVALID_SLOT)\n+            (Error OPAQUE_FRAME      \"Unable to set the value of local variables in the frame \"\n+                                     \"(e.g. the frame is executing a native method).\")\n@@ -2716,4 +2714,3 @@\n-            (Error OPAQUE_FRAME      \"If one or more of the frames to pop is a native \"\n-                                     \"method or its caller is a native method, or the \"\n-                                     \"thread is a suspended virtual thread and the implementation \"\n-                                     \"was unable to pop the frames.\")\n+            (Error OPAQUE_FRAME      \"Unable to pop one or more of the frames \"\n+                                     \"(e.g. one or more of the frames to pop is a native \"\n+                                     \"method or its caller is a native method).\")\n","filename":"src\/java.se\/share\/data\/jdwp\/jdwp.spec","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-                    int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                    int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/EUC_JP.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -415,0 +415,1 @@\n+            compiler.log.reportOutstandingWarnings();\n@@ -486,1 +487,2 @@\n-            if (compiler != null)\n+            if (compiler != null) {\n+                compiler.log.reportOutstandingWarnings();\n@@ -488,0 +490,1 @@\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskImpl.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -271,0 +272,1 @@\n+                LintMapper.instance(this).clear();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskPool.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -363,3 +363,8 @@\n-                    Type t = attr.attribType(dcReference.qualifierExpression, env);\n-                    if (t != null && !t.isErroneous()) {\n-                        return t;\n+                    JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+                    try {\n+                        Type t = attr.attribType(dcReference.qualifierExpression, env);\n+                        if (t != null && !t.isErroneous()) {\n+                            return t;\n+                        }\n+                    } finally {\n+                        log.useSource(prevSource);\n@@ -391,0 +396,1 @@\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n@@ -512,0 +518,1 @@\n+            log.useSource(prevSource);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,176 +1,0 @@\n-\/*\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.code;\n-\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.tree.JCTree.Tag;\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.Context;\n-\n-\/**\n- * Holds pending {@link Lint} warnings until the {@lint Lint} instance associated with the containing\n- * module, package, class, method, or variable declaration is known so that {@link @SupressWarnings}\n- * suppressions may be applied.\n- *\n- * <p>\n- * Warnings are regsistered at any time prior to attribution via {@link #report}. The warning will be\n- * associated with the declaration placed in context by the most recent invocation of {@link #push push()}\n- * not yet {@link #pop}'d. Warnings are actually emitted later, during attribution, via {@link #flush}.\n- *\n- * <p>\n- * There is also an \"immediate\" mode, where warnings are emitted synchronously; see {@link #pushImmediate}.\n- *\n- * <p>\n- * Deferred warnings are grouped by the innermost containing module, package, class, method, or variable\n- * declaration (represented by {@link JCTree} nodes), so that the corresponding {@link Lint} configuration\n- * can be applied when the warning is eventually generated.\n- *\n- * <p><b>This is NOT part of any supported API.\n- * If you write code that depends on this, you do so at your own risk.\n- * This code and its internal interfaces are subject to change or\n- * deletion without notice.<\/b>\n- *\/\n-public class DeferredLintHandler {\n-\n-    protected static final Context.Key<DeferredLintHandler> deferredLintHandlerKey = new Context.Key<>();\n-\n-    public static DeferredLintHandler instance(Context context) {\n-        DeferredLintHandler instance = context.get(deferredLintHandlerKey);\n-        if (instance == null)\n-            instance = new DeferredLintHandler(context);\n-        return instance;\n-    }\n-\n-    \/**\n-     * Registered {@link LintLogger}s grouped by the innermost containing module, package, class,\n-     * method, or variable declaration.\n-     *\/\n-    private final HashMap<JCTree, ArrayList<LintLogger>> deferralMap = new HashMap<>();\n-\n-    \/**\n-     * The current \"reporter\" stack, reflecting calls to {@link #push} and {@link #pop}.\n-     *\n-     * <p>\n-     * The top of the stack determines how calls to {@link #report} are handled.\n-     *\/\n-    private final ArrayDeque<Consumer<LintLogger>> reporterStack = new ArrayDeque<>();\n-\n-    @SuppressWarnings(\"this-escape\")\n-    protected DeferredLintHandler(Context context) {\n-        context.put(deferredLintHandlerKey, this);\n-        Lint rootLint = Lint.instance(context);\n-        pushImmediate(rootLint);            \/\/ default to \"immediate\" mode\n-    }\n-\n-\/\/ LintLogger\n-\n-    \/**An interface for deferred lint reporting - loggers passed to\n-     * {@link #report(LintLogger) } will be called when\n-     * {@link #flush(DiagnosticPosition) } is invoked.\n-     *\/\n-    public interface LintLogger {\n-\n-        \/**\n-         * Generate a warning if appropriate.\n-         *\n-         * @param lint the applicable lint configuration\n-         *\/\n-        void report(Lint lint);\n-    }\n-\n-\/\/ Reporter Stack\n-\n-    \/**\n-     * Defer {@link #report}ed warnings until the given declaration is flushed.\n-     *\n-     * @param decl module, package, class, method, or variable declaration\n-     * @see #pop\n-     *\/\n-    public void push(JCTree decl) {\n-        Assert.check(decl.getTag() == Tag.MODULEDEF\n-                  || decl.getTag() == Tag.PACKAGEDEF\n-                  || decl.getTag() == Tag.CLASSDEF\n-                  || decl.getTag() == Tag.METHODDEF\n-                  || decl.getTag() == Tag.VARDEF);\n-        reporterStack.push(logger -> deferralMap\n-                                        .computeIfAbsent(decl, s -> new ArrayList<>())\n-                                        .add(logger));\n-    }\n-\n-    \/**\n-     * Enter \"immediate\" mode so that {@link #report}ed warnings are emitted synchonously.\n-     *\n-     * @param lint lint configuration to use for reported warnings\n-     *\/\n-    public void pushImmediate(Lint lint) {\n-        reporterStack.push(logger -> logger.report(lint));\n-    }\n-\n-    \/**\n-     * Revert to the previous configuration in effect prior to the most recent invocation\n-     * of {@link #push} or {@link #pushImmediate}.\n-     *\n-     * @see #pop\n-     *\/\n-    public void pop() {\n-        Assert.check(reporterStack.size() > 1);     \/\/ the bottom stack entry should never be popped\n-        reporterStack.pop();\n-    }\n-\n-    \/**\n-     * Report a warning.\n-     *\n-     * <p>\n-     * In immediate mode, the warning is emitted synchronously. Otherwise, the warning is emitted later\n-     * when the current declaration is flushed.\n-     *\/\n-    public void report(LintLogger logger) {\n-        Assert.check(!reporterStack.isEmpty());\n-        reporterStack.peek().accept(logger);\n-    }\n-\n-\/\/ Warning Flush\n-\n-    \/**\n-     * Emit deferred warnings encompassed by the given declaration.\n-     *\n-     * @param decl module, package, class, method, or variable declaration\n-     * @param lint lint configuration corresponding to {@code decl}\n-     *\/\n-    public void flush(JCTree decl, Lint lint) {\n-        Optional.of(decl)\n-          .map(deferralMap::remove)\n-          .stream()\n-          .flatMap(ArrayList::stream)\n-          .forEach(logger -> logger.report(lint));\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/DeferredLintHandler.java","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"@@ -377,4 +377,1 @@\n-         *\n-         * <p>\n-         * This category is not supported by {@code @SuppressWarnings} (yet - see JDK-8224228).\n-        TEXT_BLOCKS(\"text-blocks\", false),\n+        TEXT_BLOCKS(\"text-blocks\"),\n@@ -479,21 +476,0 @@\n-    \/**\n-     * Helper method. Log a lint warning if its lint category is enabled.\n-     *\n-     * @param warning key for the localized warning message\n-     *\/\n-    public void logIfEnabled(LintWarning warning) {\n-        logIfEnabled(null, warning);\n-    }\n-\n-    \/**\n-     * Helper method. Log a lint warning if its lint category is enabled.\n-     *\n-     * @param pos source position at which to report the warning\n-     * @param warning key for the localized warning message\n-     *\/\n-    public void logIfEnabled(DiagnosticPosition pos, LintWarning warning) {\n-        if (isEnabled(warning.getLintCategory())) {\n-            log.warning(pos, warning);\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,328 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.code;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import javax.tools.DiagnosticListener;\n+import javax.tools.JavaFileObject;\n+\n+import com.sun.tools.javac.tree.EndPosTable;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+\n+\/**\n+ * Maps source code positions to the applicable {@link Lint} instance.\n+ *\n+ * <p>\n+ * Because {@code @SuppressWarnings} is a Java symbol, in general this mapping can't be\n+ * calculated until after attribution. As each top-level declaration (class, package, or module)\n+ * is attributed, this singleton is notified and the {@link Lint}s that apply to every source\n+ * position within that top-level declaration are calculated.\n+ *\n+ * <p>\n+ * The method {@link #lintAt} returns the {@link Lint} instance applicable to source position;\n+ * if it can't be determined yet, an empty {@link Optional} is returned.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public class LintMapper {\n+\n+    \/\/ The key for the context singleton\n+    private static final Context.Key<LintMapper> CONTEXT_KEY = new Context.Key<>();\n+\n+    \/\/ Per-source file information. Note: during the parsing of a file, an entry exists but the FileInfo value is null\n+    private final Map<JavaFileObject, FileInfo> fileInfoMap = new HashMap<>();\n+\n+    \/\/ Compiler context\n+    private final Context context;\n+\n+    \/\/ These are initialized lazily; see initializeIfNeeded()\n+    private Lint rootLint;\n+\n+    \/**\n+     * Obtain the {@link LintMapper} context singleton.\n+     *\/\n+    public static LintMapper instance(Context context) {\n+        LintMapper instance = context.get(CONTEXT_KEY);\n+        if (instance == null)\n+            instance = new LintMapper(context);\n+        return instance;\n+    }\n+\n+    \/**\n+     * Constructor.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    protected LintMapper(Context context) {\n+        context.put(CONTEXT_KEY, this);\n+        this.context = context;\n+    }\n+\n+    \/\/ Lazy initialization to avoid dependency loops\n+    private void initializeIfNeeded() {\n+        if (rootLint == null)\n+            rootLint = Lint.instance(context);\n+    }\n+\n+\/\/ Lint Operations\n+\n+    \/**\n+     * Determine if the given file is known to this instance.\n+     *\n+     * @param sourceFile source file\n+     * @return true if file is recognized\n+     *\/\n+    public boolean isKnown(JavaFileObject sourceFile) {\n+        return fileInfoMap.containsKey(sourceFile);\n+    }\n+\n+    \/**\n+     * Obtain the {@link Lint} configuration that applies at the given position, if known.\n+     *\n+     * @param sourceFile source file\n+     * @param pos source position\n+     * @return the applicable {@link Lint}, if known, otherwise empty\n+     *\/\n+    public Optional<Lint> lintAt(JavaFileObject sourceFile, DiagnosticPosition pos) {\n+        initializeIfNeeded();\n+        return Optional.of(sourceFile)\n+          .map(fileInfoMap::get)\n+          .flatMap(fileInfo -> fileInfo.lintAt(pos));\n+    }\n+\n+    \/**\n+     * Calculate {@lint Lint} configurations for all positions within the given top-level declaration.\n+     *\n+     * @param sourceFile source file\n+     * @param tree top-level declaration (class, package, or module)\n+     *\/\n+    public void calculateLints(JavaFileObject sourceFile, JCTree tree, EndPosTable endPositions) {\n+        Assert.check(rootLint != null);\n+        fileInfoMap.get(sourceFile).afterAttr(tree, endPositions);\n+    }\n+\n+    \/**\n+     * Reset this instance.\n+     *\/\n+    public void clear() {\n+        fileInfoMap.clear();\n+    }\n+\n+\/\/ Parsing Notifications\n+\n+    \/**\n+     * Invoked when file parsing starts to create an entry for the new file (but with a null value).\n+     *\/\n+    public void startParsingFile(JavaFileObject sourceFile) {\n+        initializeIfNeeded();\n+        fileInfoMap.put(sourceFile, null);\n+    }\n+\n+    \/**\n+     * Invoked when file parsing completes to put in place a corresponding {@link FileInfo}.\n+     *\/\n+    public void finishParsingFile(JCCompilationUnit tree) {\n+        Assert.check(rootLint != null);\n+        fileInfoMap.put(tree.sourcefile, new FileInfo(rootLint, tree));\n+    }\n+\n+\/\/ FileInfo\n+\n+    \/**\n+     * Holds {@link Lint} information for a fully parsed source file.\n+     *\n+     * <p>\n+     * Initially (immediately after parsing), \"unmappedDecls\" contains a {@link Span} corresponding to each\n+     * top-level declaration in the source file. As each top-level declaration is attributed, the corresponding\n+     * {@link Span} is removed and the corresponding {@link LintRange} subtree is populated under \"rootRange\".\n+     *\/\n+    private static class FileInfo {\n+\n+        final LintRange rootRange;                              \/\/ the root LintRange (covering the entire source file)\n+        final List<Span> unmappedDecls = new ArrayList<>();     \/\/ unmapped top-level declarations awaiting attribution\n+\n+        \/\/ After parsing: Add top-level declarations to our \"unmappedDecls\" list\n+        FileInfo(Lint rootLint, JCCompilationUnit tree) {\n+            rootRange = new LintRange(rootLint);\n+            tree.defs.stream()\n+              .filter(this::isTopLevelDecl)\n+              .map(decl -> new Span(decl, tree.endPositions))\n+              .forEach(unmappedDecls::add);\n+        }\n+\n+        \/\/ After attribution: Discard the span from \"unmappedDecls\" and populate the declaration's subtree under \"rootRange\"\n+        void afterAttr(JCTree tree, EndPosTable endPositions) {\n+            for (Iterator<Span> i = unmappedDecls.iterator(); i.hasNext(); ) {\n+                if (i.next().contains(tree.pos())) {\n+                    rootRange.populateSubtree(tree, endPositions);\n+                    i.remove();\n+                    return;\n+                }\n+            }\n+            throw new AssertionError(\"top-level declaration not found\");\n+        }\n+\n+        \/\/ Find the most specific Lint configuration applying to the given position, unless the position has not been mapped yet\n+        Optional<Lint> lintAt(DiagnosticPosition pos) {\n+            boolean mapped = unmappedDecls.stream().noneMatch(span -> span.contains(pos));\n+            return mapped ? Optional.of(rootRange.bestMatch(pos).lint) : Optional.empty();\n+        }\n+\n+        boolean isTopLevelDecl(JCTree tree) {\n+            return tree.getTag() == Tag.MODULEDEF\n+                || tree.getTag() == Tag.PACKAGEDEF\n+                || tree.getTag() == Tag.CLASSDEF;\n+        }\n+    }\n+\n+\/\/ Span\n+\n+    \/**\n+     * A lexical range.\n+     *\/\n+    private record Span(int startPos, int endPos) {\n+\n+        static final Span MAXIMAL = new Span(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+\n+        Span(JCTree tree, EndPosTable endPositions) {\n+            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions));\n+        }\n+\n+        boolean contains(DiagnosticPosition pos) {\n+            int offset = pos.getLintPosition();\n+            return offset == startPos || (offset > startPos && offset < endPos);\n+        }\n+\n+        boolean contains(Span that) {\n+            return this.startPos <= that.startPos && this.endPos >= that.endPos;\n+        }\n+    }\n+\n+\/\/ LintRange\n+\n+    \/**\n+     * A tree of nested lexical ranges and the {@link Lint} configurations that apply therein.\n+     *\/\n+    private record LintRange(\n+        Span span,                                      \/\/ declaration's lexical range\n+        Lint lint,                                      \/\/ the Lint configuration that applies at this declaration\n+        List<LintRange> children                        \/\/ the nested declarations one level below this node\n+    ) {\n+\n+        \/\/ Create a node representing the entire file, using the root lint configuration\n+        LintRange(Lint rootLint) {\n+            this(Span.MAXIMAL, rootLint, new ArrayList<>());\n+        }\n+\n+        \/\/ Create a node representing the given declaration and its corresponding Lint configuration\n+        LintRange(JCTree tree, EndPosTable endPositions, Lint lint) {\n+            this(new Span(tree, endPositions), lint, new ArrayList<>());\n+        }\n+\n+        \/\/ Find the most specific node in this tree (including me) that contains the given position, if any\n+        LintRange bestMatch(DiagnosticPosition pos) {\n+            return children.stream()\n+              .map(child -> child.bestMatch(pos))\n+              .filter(Objects::nonNull)\n+              .reduce((a, b) -> a.span.contains(b.span) ? b : a)\n+              .orElseGet(() -> span.contains(pos) ? this : null);\n+        }\n+\n+        \/\/ Populate a sparse subtree corresponding to the given nested declaration.\n+        \/\/ Only when the Lint configuration differs from the parent is a node added.\n+        void populateSubtree(JCTree tree, EndPosTable endPositions) {\n+            new TreeScanner() {\n+\n+                private LintRange currentNode = LintRange.this;\n+\n+                @Override\n+                public void visitModuleDef(JCModuleDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitModuleDef);\n+                }\n+                @Override\n+                public void visitPackageDef(JCPackageDecl tree) {\n+                    scanDecl(tree, tree.packge, super::visitPackageDef);\n+                }\n+                @Override\n+                public void visitClassDef(JCClassDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitClassDef);\n+                }\n+                @Override\n+                public void visitMethodDef(JCMethodDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitMethodDef);\n+                }\n+                @Override\n+                public void visitVarDef(JCVariableDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitVarDef);\n+                }\n+\n+                private <T extends JCTree> void scanDecl(T tree, Symbol symbol, Consumer<? super T> recursor) {\n+\n+                    \/\/ The \"symbol\" can be null if there were earlier errors; skip this declaration if so\n+                    if (symbol == null) {\n+                        recursor.accept(tree);\n+                        return;\n+                    }\n+\n+                    \/\/ Update the Lint using the declaration; if there's no change, then we don't need a new node here\n+                    Lint newLint = currentNode.lint.augment(symbol);\n+                    if (newLint == currentNode.lint) {  \/\/ note: lint.augment() returns the same instance if there's no change\n+                        recursor.accept(tree);\n+                        return;\n+                    }\n+\n+                    \/\/ Add a new node here and proceed\n+                    final LintRange previousNode = currentNode;\n+                    currentNode = new LintRange(tree, endPositions, newLint);\n+                    previousNode.children.add(currentNode);\n+                    try {\n+                        recursor.accept(tree);\n+                    } finally {\n+                        currentNode = previousNode;\n+                    }\n+                }\n+            }.scan(tree);\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":328,"deletions":0,"binary":false,"changes":328,"status":"added"},{"patch":"@@ -70,3 +70,0 @@\n-    \/** flag: is the \"preview\" lint category enabled? *\/\n-    private final boolean verbose;\n-\n@@ -102,1 +99,0 @@\n-        verbose = Lint.instance(context).isEnabled(LintCategory.PREVIEW);\n@@ -187,3 +183,1 @@\n-        if (verbose) {\n-            log.warning(LintWarnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n-        }\n+        log.warning(LintWarnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,2 +92,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n-    private final Lint lint;\n@@ -113,1 +111,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -116,1 +113,0 @@\n-        lint = Lint.instance(context);\n@@ -238,3 +234,1 @@\n-     * @param deferDecl   enclosing declaration for DeferredLintHandler, or null for no deferral\n-    public void annotateLater(List<JCAnnotation> annotations, Env<AttrContext> localEnv,\n-            Symbol s, JCTree deferDecl)\n+    public void annotateLater(List<JCAnnotation> annotations, Env<AttrContext> localEnv, Symbol s)\n@@ -259,2 +253,0 @@\n-            Assert.check(deferDecl != null);\n-            deferredLintHandler.push(deferDecl);\n@@ -271,1 +263,0 @@\n-                deferredLintHandler.pop();\n@@ -288,2 +279,1 @@\n-    public void annotateDefaultValueLater(JCExpression defaultValue, Env<AttrContext> localEnv,\n-            MethodSymbol m, JCTree deferDecl)\n+    public void annotateDefaultValueLater(JCExpression defaultValue, Env<AttrContext> localEnv, MethodSymbol m)\n@@ -293,1 +283,0 @@\n-            deferredLintHandler.push(deferDecl);\n@@ -297,1 +286,0 @@\n-                deferredLintHandler.pop();\n@@ -685,1 +673,1 @@\n-            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym, null);\n+            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym);\n@@ -1037,2 +1025,1 @@\n-    public void enterTypeAnnotations(List<JCAnnotation> annotations, Env<AttrContext> env,\n-            Symbol s, JCTree deferDecl, boolean isTypeParam)\n+    public void enterTypeAnnotations(List<JCAnnotation> annotations, Env<AttrContext> env, Symbol s, boolean isTypeParam)\n@@ -1042,3 +1029,0 @@\n-        if (deferDecl != null) {\n-            deferredLintHandler.push(deferDecl);\n-        }\n@@ -1049,2 +1033,0 @@\n-            if (deferDecl != null)\n-                deferredLintHandler.pop();\n@@ -1058,1 +1040,1 @@\n-    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym, JCTree deferDecl)\n+    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym)\n@@ -1061,1 +1043,1 @@\n-        normal(() -> tree.accept(new TypeAnnotate(env, sym, deferDecl)));\n+        normal(() -> tree.accept(new TypeAnnotate(env, sym)));\n@@ -1096,2 +1078,1 @@\n-        private JCTree deferDecl;\n-        public TypeAnnotate(Env<AttrContext> env, Symbol sym, JCTree deferDecl) {\n+        public TypeAnnotate(Env<AttrContext> env, Symbol sym) {\n@@ -1102,1 +1083,0 @@\n-            this.deferDecl = deferDecl;\n@@ -1107,1 +1087,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, false);\n@@ -1113,1 +1093,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, true);\n+            enterTypeAnnotations(tree.annotations, env, sym, true);\n@@ -1119,1 +1099,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, false);\n@@ -1121,1 +1101,1 @@\n-                enterTypeAnnotations(dimAnnos, env, sym, deferDecl, false);\n+                enterTypeAnnotations(dimAnnos, env, sym, false);\n@@ -1140,12 +1120,5 @@\n-            JCTree prevDecl = deferDecl;\n-            deferDecl = tree;\n-            try {\n-                if (sym != null && sym.kind == VAR) {\n-                    \/\/ Don't visit a parameter once when the sym is the method\n-                    \/\/ and once when the sym is the parameter.\n-                    scan(tree.mods);\n-                    scan(tree.vartype);\n-                }\n-                scan(tree.init);\n-            } finally {\n-                deferDecl = prevDecl;\n+            if (sym != null && sym.kind == VAR) {\n+                \/\/ Don't visit a parameter once when the sym is the method\n+                \/\/ and once when the sym is the parameter.\n+                scan(tree.mods);\n+                scan(tree.vartype);\n@@ -1153,0 +1126,1 @@\n+            scan(tree.init);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":17,"deletions":43,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -101,0 +102,1 @@\n+    final LintMapper lintMapper;\n@@ -119,1 +121,0 @@\n-    final DeferredLintHandler deferredLintHandler;\n@@ -140,0 +141,1 @@\n+        lintMapper = LintMapper.instance(context);\n@@ -159,1 +161,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -856,1 +857,0 @@\n-        deferredLintHandler.push(variable);\n@@ -872,1 +872,0 @@\n-            deferredLintHandler.pop();\n@@ -1001,1 +1000,0 @@\n-            deferredLintHandler.flush(tree, lint);\n@@ -1236,1 +1234,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);\n+                annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m);\n@@ -1300,1 +1298,0 @@\n-            deferredLintHandler.flush(tree, lint);\n@@ -1345,1 +1342,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym);\n@@ -1442,1 +1439,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);\n+            annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner);\n@@ -1955,1 +1952,1 @@\n-            env.info.lint.logIfEnabled(tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n+            log.warning(tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n@@ -2057,1 +2054,1 @@\n-                env.info.lint.logIfEnabled(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n+                log.warning(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n@@ -4228,1 +4225,1 @@\n-        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.var);\n+        annotate.annotateLater(tree.var.mods.annotations, env, v);\n@@ -4230,1 +4227,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v);\n@@ -4469,1 +4466,1 @@\n-            env.info.lint.logIfEnabled(tree, LintWarnings.TryExplicitCloseCall);\n+            log.warning(tree, LintWarnings.TryExplicitCloseCall);\n@@ -4496,1 +4493,1 @@\n-                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n+                log.warning(tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n@@ -4498,1 +4495,1 @@\n-                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n+                log.warning(tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n@@ -5300,0 +5297,3 @@\n+\n+        \/\/ Now that this tree is attributed, we can calculate the Lint configuration everywhere within it\n+        lintMapper.calculateLints(env.toplevel.sourcefile, env.tree, env.toplevel.endPositions);\n@@ -5342,1 +5342,0 @@\n-            deferredLintHandler.flush(env.tree, lint);\n@@ -5526,1 +5525,0 @@\n-                deferredLintHandler.flush(env.tree, env.info.lint);\n@@ -5572,4 +5570,2 @@\n-        chk.checkModuleName(tree);\n-        chk.checkDeprecatedAnnotation(tree, msym);\n-\n-            deferredLintHandler.flush(tree, lint);\n+            chk.checkModuleName(tree);\n+            chk.checkDeprecatedAnnotation(tree, msym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":18,"deletions":22,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-    Lint lint;\n+    private Lint lint;\n@@ -167,2 +167,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n-\n@@ -183,4 +181,0 @@\n-    \/** A handler for deferred lint warnings.\n-     *\/\n-    private DeferredLintHandler deferredLintHandler;\n-\n@@ -232,18 +226,9 @@\n-        LintWarning warningKey = null;\n-        if (sym.isDeprecatedForRemoval()) {\n-            if (!lint.isSuppressed(LintCategory.REMOVAL)) {\n-                if (sym.kind == MDL) {\n-                    warningKey = LintWarnings.HasBeenDeprecatedForRemovalModule(sym);\n-                } else {\n-                    warningKey = LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location());\n-                }\n-            }\n-        } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {\n-            if (sym.kind == MDL) {\n-                warningKey = LintWarnings.HasBeenDeprecatedModule(sym);\n-            } else {\n-                warningKey = LintWarnings.HasBeenDeprecated(sym, sym.location());\n-            }\n-        }\n-        if (warningKey != null)\n-            log.warning(pos, warningKey);\n+        Assert.check(!importSuppression);\n+        LintWarning warningKey = sym.isDeprecatedForRemoval() ?\n+            (sym.kind == MDL ?\n+                LintWarnings.HasBeenDeprecatedForRemovalModule(sym) :\n+                LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location())) :\n+            (sym.kind == MDL ?\n+                LintWarnings.HasBeenDeprecatedModule(sym) :\n+                LintWarnings.HasBeenDeprecated(sym, sym.location()));\n+        log.warning(pos, warningKey);\n@@ -257,1 +242,1 @@\n-        if (!importSuppression && !lint.isSuppressed(LintCategory.PREVIEW))\n+        if (!importSuppression)\n@@ -261,8 +246,0 @@\n-    \/** Log a preview warning.\n-     *  @param pos        Position to be used for error reporting.\n-     *  @param msg        A Warning describing the problem.\n-     *\/\n-    public void warnRestrictedAPI(DiagnosticPosition pos, Symbol sym) {\n-        lint.logIfEnabled(pos, LintWarnings.RestrictedMethod(sym.enclClass(), sym));\n-    }\n-\n@@ -274,2 +251,1 @@\n-        if (!lint.isSuppressed(LintCategory.UNCHECKED))\n-            log.warning(pos, warnKey);\n+        log.warning(pos, warnKey);\n@@ -611,3 +587,1 @@\n-            deferredLintHandler.report(_l -> {\n-                lint.logIfEnabled(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n-            });\n+            log.warning(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n@@ -917,1 +891,1 @@\n-            lint.logIfEnabled(tree, LintWarnings.VarargsRedundantTrustmeAnno(\n+            log.warning(tree.pos(), LintWarnings.VarargsRedundantTrustmeAnno(\n@@ -1176,1 +1150,1 @@\n-                warnOnExplicitStrictfp(tree);\n+                log.warning(tree.pos(), LintWarnings.Strictfp);\n@@ -1220,1 +1194,1 @@\n-                warnOnExplicitStrictfp(tree);\n+                log.warning(tree.pos(), LintWarnings.Strictfp);\n@@ -1284,10 +1258,0 @@\n-    private void warnOnExplicitStrictfp(JCTree tree) {\n-        deferredLintHandler.push(tree);\n-        try {\n-            deferredLintHandler.report(_ -> lint.logIfEnabled(tree.pos(), LintWarnings.Strictfp));\n-        } finally {\n-            deferredLintHandler.pop();\n-        }\n-    }\n-\n-\n@@ -1506,1 +1470,1 @@\n-            lint.logIfEnabled(tree.pos(), LintWarnings.RawClassUse(tree.type, tree.type.tsym.type));\n+            log.warning(tree.pos(), LintWarnings.RawClassUse(tree.type, tree.type.tsym.type));\n@@ -1830,1 +1794,1 @@\n-            lint.logIfEnabled(TreeInfo.diagnosticPositionFor(m, tree),\n+            log.warning(TreeInfo.diagnosticPositionFor(m, tree),\n@@ -1844,6 +1808,1 @@\n-            Lint prevLint = setLint(lint.augment(m));\n-            try {\n-                checkDeprecated(() -> TreeInfo.diagnosticPositionFor(m, tree), m, other);\n-            } finally {\n-                setLint(prevLint);\n-            }\n+            checkDeprecated(() -> TreeInfo.diagnosticPositionFor(m, tree), m, other);\n@@ -2918,7 +2877,2 @@\n-        final Lint prevLint = setLint(warnOnAnyAccessToMembers ? lint.enable(LintCategory.SERIAL) : lint);\n-        try {\n-            if (warnOnAnyAccessToMembers || isLambda)\n-                checkAccessFromSerializableElementInner(tree, isLambda);\n-        } finally {\n-            setLint(prevLint);\n-        }\n+        if (warnOnAnyAccessToMembers || isLambda)\n+            checkAccessFromSerializableElementInner(tree, isLambda);\n@@ -2928,5 +2882,4 @@\n-        if (lint.isEnabled(LintCategory.SERIAL)) {\n-            Symbol sym = TreeInfo.symbol(tree);\n-            if (!sym.kind.matches(KindSelector.VAL_MTH)) {\n-                return;\n-            }\n+        Symbol sym = TreeInfo.symbol(tree);\n+        if (!sym.kind.matches(KindSelector.VAL_MTH)) {\n+            return;\n+        }\n@@ -2934,7 +2887,6 @@\n-            if (sym.kind == VAR) {\n-                if ((sym.flags() & PARAMETER) != 0 ||\n-                    sym.isDirectlyOrIndirectlyLocal() ||\n-                    sym.name == names._this ||\n-                    sym.name == names._super) {\n-                    return;\n-                }\n+        if (sym.kind == VAR) {\n+            if ((sym.flags() & PARAMETER) != 0 ||\n+                sym.isDirectlyOrIndirectlyLocal() ||\n+                sym.name == names._this ||\n+                sym.name == names._super) {\n+                return;\n@@ -2942,0 +2894,1 @@\n+        }\n@@ -2943,10 +2896,5 @@\n-            if (!types.isSubtype(sym.owner.type, syms.serializableType) &&\n-                isEffectivelyNonPublic(sym)) {\n-                if (isLambda) {\n-                    if (belongsToRestrictedPackage(sym)) {\n-                        log.warning(tree.pos(),\n-                                    LintWarnings.AccessToMemberFromSerializableLambda(sym));\n-                    }\n-                } else {\n-                    log.warning(tree.pos(),\n-                                LintWarnings.AccessToMemberFromSerializableElement(sym));\n+        if (!types.isSubtype(sym.owner.type, syms.serializableType) && isEffectivelyNonPublic(sym)) {\n+            DiagnosticFlag flag = warnOnAnyAccessToMembers ? DiagnosticFlag.DEFAULT_ENABLED : null;\n+            if (isLambda) {\n+                if (belongsToRestrictedPackage(sym)) {\n+                    log.warning(flag, tree.pos(), LintWarnings.AccessToMemberFromSerializableLambda(sym));\n@@ -2954,0 +2902,2 @@\n+            } else {\n+                log.warning(flag, tree.pos(), LintWarnings.AccessToMemberFromSerializableElement(sym));\n@@ -3740,2 +3690,1 @@\n-                log.warning(pos,\n-                            LintWarnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));\n+                log.warning(pos, LintWarnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));\n@@ -3755,1 +3704,1 @@\n-            deferredLintHandler.report(_l -> warnDeprecated(pos.get(), s));\n+            warnDeprecated(pos.get(), s);\n@@ -3761,3 +3710,1 @@\n-            deferredLintHandler.report(_l -> {\n-                log.warning(pos, Warnings.SunProprietary(s));\n-            });\n+            log.warning(pos, Warnings.SunProprietary(s));\n@@ -3820,1 +3767,1 @@\n-            deferredLintHandler.report(_l -> warnRestrictedAPI(pos, s));\n+            log.warning(pos, LintWarnings.RestrictedMethod(s.enclClass(), s));\n@@ -4092,1 +4039,1 @@\n-                deferredLintHandler.report(_ -> lint.logIfEnabled(pos, LintWarnings.DivZero));\n+                log.warning(pos, LintWarnings.DivZero);\n@@ -4105,2 +4052,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.PossibleLossOfPrecision(found, req)));\n+            log.warning(pos, LintWarnings.PossibleLossOfPrecision(found, req));\n@@ -4115,1 +4061,1 @@\n-            lint.logIfEnabled(tree.thenpart.pos(), LintWarnings.EmptyIf);\n+            log.warning(tree.thenpart.pos(), LintWarnings.EmptyIf);\n@@ -4262,2 +4208,1 @@\n-            lint.logIfEnabled(pos,\n-                        LintWarnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));\n+            log.warning(pos, LintWarnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));\n@@ -4305,2 +4250,1 @@\n-                            deferredLintHandler.report(_ ->\n-                                lint.logIfEnabled(pos, LintWarnings.MissingExplicitCtor(c, pkg, modle)));\n+                            log.warning(pos, LintWarnings.MissingExplicitCtor(c, pkg, modle));\n@@ -4342,1 +4286,1 @@\n-                        Check.this.lint.logIfEnabled(pos(), LintWarnings.VarargsUnsafeUseVarargsParam(method.params.last()));\n+                        log.warning(pos(), LintWarnings.VarargsUnsafeUseVarargsParam(method.params.last()));\n@@ -4640,2 +4584,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.ModuleNotFound(msym)));\n+            log.warning(pos, LintWarnings.ModuleNotFound(msym));\n@@ -4648,2 +4591,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.PackageEmptyOrNotFound(packge)));\n+            log.warning(pos, LintWarnings.PackageEmptyOrNotFound(packge));\n@@ -4655,7 +4597,5 @@\n-            deferredLintHandler.report(_ -> {\n-                if (rd.isTransitive() && lint.isEnabled(LintCategory.REQUIRES_TRANSITIVE_AUTOMATIC)) {\n-                    log.warning(pos, LintWarnings.RequiresTransitiveAutomatic);\n-                } else {\n-                    lint.logIfEnabled(pos, LintWarnings.RequiresAutomatic);\n-                }\n-            });\n+            if (rd.isTransitive()) {    \/\/ see comment in Log.applyLint() for special logic that applies\n+                log.warning(pos, LintWarnings.RequiresTransitiveAutomatic);\n+            } else {\n+                log.warning(pos, LintWarnings.RequiresAutomatic);\n+            }\n@@ -5696,1 +5636,1 @@\n-                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                                log.warning(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5703,1 +5643,1 @@\n-                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                                log.warning(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5730,1 +5670,1 @@\n-                lint.logIfEnabled(pos, LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                log.warning(pos, LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5807,1 +5747,1 @@\n-                        .forEach(ta -> lint.logIfEnabled(typeParamTrees.get(ta.position.parameter_index).pos(),\n+                        .forEach(ta -> log.warning(typeParamTrees.get(ta.position.parameter_index).pos(),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":60,"deletions":120,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -217,1 +217,0 @@\n-    private       Lint lint;\n@@ -340,1 +339,0 @@\n-        lint = Lint.instance(context);\n@@ -565,1 +563,0 @@\n-            Lint lintPrev = lint;\n@@ -568,1 +565,0 @@\n-            lint = lint.augment(tree.sym);\n@@ -599,1 +595,0 @@\n-                lint = lintPrev;\n@@ -605,3 +600,0 @@\n-            Lint lintPrev = lint;\n-\n-            lint = lint.augment(tree.sym);\n@@ -611,4 +603,3 @@\n-            try {\n-                alive = Liveness.ALIVE;\n-                scanStat(tree.body);\n-                tree.completesNormally = alive != Liveness.DEAD;\n+            alive = Liveness.ALIVE;\n+            scanStat(tree.body);\n+            tree.completesNormally = alive != Liveness.DEAD;\n@@ -616,2 +607,2 @@\n-                if (alive == Liveness.ALIVE && !tree.sym.type.getReturnType().hasTag(VOID))\n-                    log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);\n+            if (alive == Liveness.ALIVE && !tree.sym.type.getReturnType().hasTag(VOID))\n+                log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);\n@@ -619,4 +610,1 @@\n-                clearPendingExits(true);\n-            } finally {\n-                lint = lintPrev;\n-            }\n+            clearPendingExits(true);\n@@ -637,9 +625,1 @@\n-            if (tree.init != null) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try{\n-                    scan(tree.init);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n-            }\n+            scan(tree.init);\n@@ -726,2 +706,1 @@\n-                    lint.logIfEnabled(l.tail.head.pos(),\n-                                LintWarnings.PossibleFallThroughIntoCase);\n+                    log.warning(l.tail.head.pos(), LintWarnings.PossibleFallThroughIntoCase);\n@@ -1235,1 +1214,1 @@\n-                    lint.logIfEnabled(TreeInfo.diagEndPos(tree.finalizer),\n+                    log.warning(TreeInfo.diagEndPos(tree.finalizer),\n@@ -1456,1 +1435,0 @@\n-            Lint lintPrev = lint;\n@@ -1464,1 +1442,0 @@\n-            lint = lint.augment(tree.sym);\n@@ -1513,1 +1490,0 @@\n-                lint = lintPrev;\n@@ -1522,3 +1498,0 @@\n-            Lint lintPrev = lint;\n-\n-            lint = lint.augment(tree.sym);\n@@ -1557,1 +1530,0 @@\n-                lint = lintPrev;\n@@ -1562,9 +1534,1 @@\n-            if (tree.init != null) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try{\n-                    scan(tree.init);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n-            }\n+            scan(tree.init);\n@@ -2390,7 +2354,4 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n-            try {\n-                JCClassDecl classDefPrev = classDef;\n-                int firstadrPrev = firstadr;\n-                int nextadrPrev = nextadr;\n-                ListBuffer<PendingExit> pendingExitsPrev = pendingExits;\n+            JCClassDecl classDefPrev = classDef;\n+            int firstadrPrev = firstadr;\n+            int nextadrPrev = nextadr;\n+            ListBuffer<PendingExit> pendingExitsPrev = pendingExits;\n@@ -2398,15 +2359,14 @@\n-                pendingExits = new ListBuffer<>();\n-                if (tree.name != names.empty) {\n-                    firstadr = nextadr;\n-                }\n-                classDef = tree;\n-                try {\n-                    \/\/ define all the static fields\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(VARDEF)) {\n-                            JCVariableDecl def = (JCVariableDecl)l.head;\n-                            if ((def.mods.flags & STATIC) != 0) {\n-                                VarSymbol sym = def.sym;\n-                                if (trackable(sym)) {\n-                                    newVar(def);\n-                                }\n+            pendingExits = new ListBuffer<>();\n+            if (tree.name != names.empty) {\n+                firstadr = nextadr;\n+            }\n+            classDef = tree;\n+            try {\n+                \/\/ define all the static fields\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(VARDEF)) {\n+                        JCVariableDecl def = (JCVariableDecl)l.head;\n+                        if ((def.mods.flags & STATIC) != 0) {\n+                            VarSymbol sym = def.sym;\n+                            if (trackable(sym)) {\n+                                newVar(def);\n@@ -2416,0 +2376,1 @@\n+                }\n@@ -2417,5 +2378,5 @@\n-                    \/\/ process all the static initializers\n-                    forEachInitializer(tree, true, def -> {\n-                        scan(def);\n-                        clearPendingExits(false);\n-                    });\n+                \/\/ process all the static initializers\n+                forEachInitializer(tree, true, def -> {\n+                    scan(def);\n+                    clearPendingExits(false);\n+                });\n@@ -2423,7 +2384,6 @@\n-                    \/\/ verify all static final fields got initialized\n-                    for (int i = firstadr; i < nextadr; i++) {\n-                        JCVariableDecl vardecl = vardecls[i];\n-                        VarSymbol var = vardecl.sym;\n-                        if (var.owner == classDef.sym && var.isStatic()) {\n-                            checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n-                        }\n+                \/\/ verify all static final fields got initialized\n+                for (int i = firstadr; i < nextadr; i++) {\n+                    JCVariableDecl vardecl = vardecls[i];\n+                    VarSymbol var = vardecl.sym;\n+                    if (var.owner == classDef.sym && var.isStatic()) {\n+                        checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n@@ -2431,0 +2391,1 @@\n+                }\n@@ -2432,9 +2393,8 @@\n-                    \/\/ define all the instance fields\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(VARDEF)) {\n-                            JCVariableDecl def = (JCVariableDecl)l.head;\n-                            if ((def.mods.flags & STATIC) == 0) {\n-                                VarSymbol sym = def.sym;\n-                                if (trackable(sym)) {\n-                                    newVar(def);\n-                                }\n+                \/\/ define all the instance fields\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(VARDEF)) {\n+                        JCVariableDecl def = (JCVariableDecl)l.head;\n+                        if ((def.mods.flags & STATIC) == 0) {\n+                            VarSymbol sym = def.sym;\n+                            if (trackable(sym)) {\n+                                newVar(def);\n@@ -2444,0 +2404,1 @@\n+                }\n@@ -2445,5 +2406,4 @@\n-                    \/\/ process all the methods\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(METHODDEF)) {\n-                            scan(l.head);\n-                        }\n+                \/\/ process all the methods\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(METHODDEF)) {\n+                        scan(l.head);\n@@ -2451,0 +2411,1 @@\n+                }\n@@ -2452,5 +2413,4 @@\n-                    \/\/ process all the nested classes\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(CLASSDEF)) {\n-                            scan(l.head);\n-                        }\n+                \/\/ process all the nested classes\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(CLASSDEF)) {\n+                        scan(l.head);\n@@ -2458,5 +2418,0 @@\n-                } finally {\n-                    pendingExits = pendingExitsPrev;\n-                    nextadr = nextadrPrev;\n-                    firstadr = firstadrPrev;\n-                    classDef = classDefPrev;\n@@ -2465,1 +2420,4 @@\n-                lint = lintPrev;\n+                pendingExits = pendingExitsPrev;\n+                nextadr = nextadrPrev;\n+                firstadr = firstadrPrev;\n+                classDef = classDefPrev;\n@@ -2480,2 +2438,8 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n+            final Bits initsPrev = new Bits(inits);\n+            final Bits uninitsPrev = new Bits(uninits);\n+            int nextadrPrev = nextadr;\n+            int firstadrPrev = firstadr;\n+            int returnadrPrev = returnadr;\n+\n+            Assert.check(pendingExits.isEmpty());\n+            boolean isConstructorPrev = isConstructor;\n@@ -2483,15 +2447,1 @@\n-                final Bits initsPrev = new Bits(inits);\n-                final Bits uninitsPrev = new Bits(uninits);\n-                int nextadrPrev = nextadr;\n-                int firstadrPrev = firstadr;\n-                int returnadrPrev = returnadr;\n-\n-                Assert.check(pendingExits.isEmpty());\n-                boolean isConstructorPrev = isConstructor;\n-                try {\n-                    isConstructor = TreeInfo.isConstructor(tree);\n-\n-                    \/\/ We only track field initialization inside constructors\n-                    if (!isConstructor) {\n-                        firstadr = nextadr;\n-                    }\n+                isConstructor = TreeInfo.isConstructor(tree);\n@@ -2499,42 +2449,44 @@\n-                    \/\/ Mark all method parameters as DA\n-                    for (List<JCVariableDecl> l = tree.params; l.nonEmpty(); l = l.tail) {\n-                        JCVariableDecl def = l.head;\n-                        scan(def);\n-                        Assert.check((def.sym.flags() & PARAMETER) != 0, \"Method parameter without PARAMETER flag\");\n-                        \/*  If we are executing the code from Gen, then there can be\n-                         *  synthetic or mandated variables, ignore them.\n-                         *\/\n-                        initParam(def);\n-                    }\n-                    \/\/ else we are in an instance initializer block;\n-                    \/\/ leave caught unchanged.\n-                    scan(tree.body);\n-\n-                    boolean isCompactOrGeneratedRecordConstructor = (tree.sym.flags() & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n-                            (tree.sym.flags() & (GENERATEDCONSTR | RECORD)) == (GENERATEDCONSTR | RECORD);\n-                    if (isConstructor) {\n-                        boolean isSynthesized = (tree.sym.flags() &\n-                                                 GENERATEDCONSTR) != 0;\n-                        for (int i = firstadr; i < nextadr; i++) {\n-                            JCVariableDecl vardecl = vardecls[i];\n-                            VarSymbol var = vardecl.sym;\n-                            if (var.owner == classDef.sym && !var.isStatic()) {\n-                                \/\/ choose the diagnostic position based on whether\n-                                \/\/ the ctor is default(synthesized) or not\n-                                if (isSynthesized && !isCompactOrGeneratedRecordConstructor) {\n-                                    checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),\n-                                            var, Errors.VarNotInitializedInDefaultConstructor(var));\n-                                } else if (isCompactOrGeneratedRecordConstructor) {\n-                                    boolean isInstanceRecordField = var.enclClass().isRecord() &&\n-                                            (var.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n-                                            var.owner.kind == TYP;\n-                                    if (isInstanceRecordField) {\n-                                        boolean notInitialized = !inits.isMember(var.adr);\n-                                        if (notInitialized && uninits.isMember(var.adr) && tree.completesNormally) {\n-                                        \/*  this way we indicate Lower that it should generate an initialization for this field\n-                                         *  in the compact constructor\n-                                         *\/\n-                                            var.flags_field |= UNINITIALIZED_FIELD;\n-                                        } else {\n-                                            checkInit(TreeInfo.diagEndPos(tree.body), var);\n-                                        }\n+                \/\/ We only track field initialization inside constructors\n+                if (!isConstructor) {\n+                    firstadr = nextadr;\n+                }\n+\n+                \/\/ Mark all method parameters as DA\n+                for (List<JCVariableDecl> l = tree.params; l.nonEmpty(); l = l.tail) {\n+                    JCVariableDecl def = l.head;\n+                    scan(def);\n+                    Assert.check((def.sym.flags() & PARAMETER) != 0, \"Method parameter without PARAMETER flag\");\n+                    \/*  If we are executing the code from Gen, then there can be\n+                     *  synthetic or mandated variables, ignore them.\n+                     *\/\n+                    initParam(def);\n+                }\n+                \/\/ else we are in an instance initializer block;\n+                \/\/ leave caught unchanged.\n+                scan(tree.body);\n+\n+                boolean isCompactOrGeneratedRecordConstructor = (tree.sym.flags() & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n+                        (tree.sym.flags() & (GENERATEDCONSTR | RECORD)) == (GENERATEDCONSTR | RECORD);\n+                if (isConstructor) {\n+                    boolean isSynthesized = (tree.sym.flags() &\n+                                             GENERATEDCONSTR) != 0;\n+                    for (int i = firstadr; i < nextadr; i++) {\n+                        JCVariableDecl vardecl = vardecls[i];\n+                        VarSymbol var = vardecl.sym;\n+                        if (var.owner == classDef.sym && !var.isStatic()) {\n+                            \/\/ choose the diagnostic position based on whether\n+                            \/\/ the ctor is default(synthesized) or not\n+                            if (isSynthesized && !isCompactOrGeneratedRecordConstructor) {\n+                                checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),\n+                                        var, Errors.VarNotInitializedInDefaultConstructor(var));\n+                            } else if (isCompactOrGeneratedRecordConstructor) {\n+                                boolean isInstanceRecordField = var.enclClass().isRecord() &&\n+                                        (var.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n+                                        var.owner.kind == TYP;\n+                                if (isInstanceRecordField) {\n+                                    boolean notInitialized = !inits.isMember(var.adr);\n+                                    if (notInitialized && uninits.isMember(var.adr) && tree.completesNormally) {\n+                                    \/*  this way we indicate Lower that it should generate an initialization for this field\n+                                     *  in the compact constructor\n+                                     *\/\n+                                        var.flags_field |= UNINITIALIZED_FIELD;\n@@ -2542,1 +2494,1 @@\n-                                        checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n+                                        checkInit(TreeInfo.diagEndPos(tree.body), var);\n@@ -2545,1 +2497,1 @@\n-                                    checkInit(TreeInfo.diagEndPos(tree.body), var);\n+                                    checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n@@ -2547,0 +2499,2 @@\n+                            } else {\n+                                checkInit(TreeInfo.diagEndPos(tree.body), var);\n@@ -2550,8 +2504,1 @@\n-                    clearPendingExits(true);\n-                } finally {\n-                    inits.assign(initsPrev);\n-                    uninits.assign(uninitsPrev);\n-                    nextadr = nextadrPrev;\n-                    firstadr = firstadrPrev;\n-                    returnadr = returnadrPrev;\n-                    isConstructor = isConstructorPrev;\n+                clearPendingExits(true);\n@@ -2560,1 +2507,6 @@\n-                lint = lintPrev;\n+                inits.assign(initsPrev);\n+                uninits.assign(uninitsPrev);\n+                nextadr = nextadrPrev;\n+                firstadr = firstadrPrev;\n+                returnadr = returnadrPrev;\n+                isConstructor = isConstructorPrev;\n@@ -2588,12 +2540,8 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n-            try{\n-                boolean track = trackable(tree.sym);\n-                if (track && (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {\n-                    newVar(tree);\n-                }\n-                if (tree.init != null) {\n-                    scanExpr(tree.init);\n-                    if (track) {\n-                        letInit(tree.pos(), tree.sym);\n-                    }\n+            boolean track = trackable(tree.sym);\n+            if (track && (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {\n+                newVar(tree);\n+            }\n+            if (tree.init != null) {\n+                scanExpr(tree.init);\n+                if (track) {\n+                    letInit(tree.pos(), tree.sym);\n@@ -2601,2 +2549,0 @@\n-            } finally {\n-                lint = lintPrev;\n@@ -2854,2 +2800,1 @@\n-            if (!resourceVarDecls.isEmpty() &&\n-                    lint.isEnabled(Lint.LintCategory.TRY)) {\n+            if (!resourceVarDecls.isEmpty()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":136,"deletions":191,"binary":false,"changes":327,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n@@ -90,1 +89,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -197,10 +195,5 @@\n-        deferredLintHandler.push(tree);\n-        try {\n-            \/\/ Compute the method type\n-            m.type = signature(m, tree.typarams, tree.params,\n-                               tree.restype, tree.recvparam,\n-                               tree.thrown,\n-                               localEnv);\n-        } finally {\n-            deferredLintHandler.pop();\n-        }\n+        \/\/ Compute the method type\n+        m.type = signature(m, tree.typarams, tree.params,\n+                           tree.restype, tree.recvparam,\n+                           tree.thrown,\n+                           localEnv);\n@@ -230,1 +223,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, m, tree);\n+        annotate.annotateLater(tree.mods.annotations, localEnv, m);\n@@ -233,1 +226,1 @@\n-        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m, tree);\n+        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m);\n@@ -237,1 +230,1 @@\n-            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m, tree);\n+            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m);\n@@ -266,11 +259,6 @@\n-        deferredLintHandler.push(tree);\n-        try {\n-            if (TreeInfo.isEnumInit(tree)) {\n-                attr.attribIdentAsEnumType(localEnv, (JCIdent)tree.vartype);\n-            } else if (!tree.isImplicitlyTyped()) {\n-                attr.attribType(tree.vartype, localEnv);\n-                if (TreeInfo.isReceiverParam(tree))\n-                    checkReceiver(tree, localEnv);\n-            }\n-        } finally {\n-            deferredLintHandler.pop();\n+        if (TreeInfo.isEnumInit(tree)) {\n+            attr.attribIdentAsEnumType(localEnv, (JCIdent)tree.vartype);\n+        } else if (!tree.isImplicitlyTyped()) {\n+            attr.attribType(tree.vartype, localEnv);\n+            if (TreeInfo.isReceiverParam(tree))\n+                checkReceiver(tree, localEnv);\n@@ -318,1 +306,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, v, tree);\n+        annotate.annotateLater(tree.mods.annotations, localEnv, v);\n@@ -320,1 +308,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v, tree);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":16,"deletions":28,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -144,1 +143,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n@@ -172,2 +170,0 @@\n-    private final boolean lintOptions;\n-\n@@ -196,1 +192,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -207,2 +202,0 @@\n-        lintOptions = !options.isLintDisabled(LintCategory.OPTIONS);\n-\n@@ -749,1 +742,0 @@\n-                deferredLintHandler.push(moduleDecl);\n@@ -757,1 +749,0 @@\n-                    deferredLintHandler.pop();\n@@ -994,1 +985,0 @@\n-            deferredLintHandler.push(decl);\n@@ -1000,1 +990,0 @@\n-                deferredLintHandler.pop();\n@@ -1266,6 +1255,3 @@\n-            if (lintOptions) {\n-                for (ModuleSymbol msym : limitMods) {\n-                    if (!observable.contains(msym)) {\n-                        log.warning(\n-                                LintWarnings.ModuleForOptionNotFound(Option.LIMIT_MODULES, msym));\n-                    }\n+            for (ModuleSymbol msym : limitMods) {\n+                if (!observable.contains(msym)) {\n+                    log.warning(LintWarnings.ModuleForOptionNotFound(Option.LIMIT_MODULES, msym));\n@@ -1724,4 +1710,1 @@\n-            if (lintOptions) {\n-                log.warning(\n-                        LintWarnings.ModuleForOptionNotFound(Option.ADD_EXPORTS, msym));\n-            }\n+            log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_EXPORTS, msym));\n@@ -1763,3 +1746,1 @@\n-                if (lintOptions) {\n-                    log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, msym));\n-                }\n+                log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, msym));\n@@ -1783,3 +1764,1 @@\n-                        if (lintOptions) {\n-                            log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, targetModule));\n-                        }\n+                        log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, targetModule));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":6,"deletions":27,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -60,0 +61,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -70,0 +72,1 @@\n+import static com.sun.tools.javac.util.Position.NOPOS;\n@@ -159,1 +162,1 @@\n-    private       Lint lint;\n+    private final LintMapper lintMapper;\n@@ -171,4 +174,0 @@\n-    \/** Contains symbols of fields and constructors that have warnings suppressed.\n-     *\/\n-    private final Set<Symbol> suppressed = new HashSet<>();\n-\n@@ -234,1 +233,1 @@\n-        lint = Lint.instance(context);\n+        lintMapper = LintMapper.instance(context);\n@@ -265,2 +264,2 @@\n-        \/\/ Short circuit if warnings are totally disabled\n-        if (!lint.isEnabled(THIS_ESCAPE))\n+        \/\/ Short circuit if this calculation is unnecessary\n+        if (!lintMapper.lintAt(env.toplevel.sourcefile, env.tree.pos()).get().isEnabled(THIS_ESCAPE))\n@@ -281,1 +280,0 @@\n-        \/\/ Track which constructors and fields have warnings suppressed.\n@@ -285,1 +283,0 @@\n-            private Lint lint = ThisEscapeAnalyzer.this.lint;\n@@ -293,2 +290,0 @@\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n@@ -309,18 +304,0 @@\n-                    lint = lintPrev;\n-                }\n-            }\n-\n-            @Override\n-            public void visitVarDef(JCVariableDecl tree) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try {\n-\n-                    \/\/ Track warning suppression of fields\n-                    if (tree.sym.owner.kind == TYP && !lint.isEnabled(THIS_ESCAPE))\n-                        suppressed.add(tree.sym);\n-\n-                    \/\/ Recurse\n-                    super.visitVarDef(tree);\n-                } finally {\n-                    lint = lintPrev;\n@@ -332,12 +309,5 @@\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try {\n-\n-                    \/\/ Track warning suppression of constructors\n-                    if (TreeInfo.isConstructor(tree) && !lint.isEnabled(THIS_ESCAPE))\n-                        suppressed.add(tree.sym);\n-                    \/\/ Gather some useful info\n-                    boolean constructor = TreeInfo.isConstructor(tree);\n-                    boolean extendableClass = currentClassIsExternallyExtendable();\n-                    boolean nonPrivate = (tree.sym.flags() & (Flags.PUBLIC | Flags.PROTECTED)) != 0;\n-                    boolean finalish = (tree.mods.flags & (Flags.STATIC | Flags.PRIVATE | Flags.FINAL)) != 0;\n+                \/\/ Gather some useful info\n+                boolean constructor = TreeInfo.isConstructor(tree);\n+                boolean extendableClass = currentClassIsExternallyExtendable();\n+                boolean nonPrivate = (tree.sym.flags() & (Flags.PUBLIC | Flags.PROTECTED)) != 0;\n+                boolean finalish = (tree.mods.flags & (Flags.STATIC | Flags.PRIVATE | Flags.FINAL)) != 0;\n@@ -346,2 +316,2 @@\n-                    \/\/ Determine if this is a constructor we should analyze\n-                    boolean analyzable = extendableClass && constructor && nonPrivate;\n+                \/\/ Determine if this is a constructor we should analyze\n+                boolean analyzable = extendableClass && constructor && nonPrivate;\n@@ -349,2 +319,2 @@\n-                    \/\/ Determine if it's safe to \"invoke\" the method in an analysis (i.e., it can't be overridden)\n-                    boolean invokable = !extendableClass || constructor || finalish;\n+                \/\/ Determine if it's safe to \"invoke\" the method in an analysis (i.e., it can't be overridden)\n+                boolean invokable = !extendableClass || constructor || finalish;\n@@ -352,2 +322,2 @@\n-                    \/\/ Add this method or constructor to our map\n-                    methodMap.put(tree.sym, new MethodInfo(currentClass, tree, constructor, analyzable, invokable));\n+                \/\/ Add this method or constructor to our map\n+                methodMap.put(tree.sym, new MethodInfo(currentClass, tree, constructor, analyzable, invokable));\n@@ -355,5 +325,2 @@\n-                    \/\/ Recurse\n-                    super.visitMethodDef(tree);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n+                \/\/ Recurse\n+                super.visitMethodDef(tree);\n@@ -404,1 +371,1 @@\n-                log.warning(frame.site.pos(), key);\n+                log.warning(frame.warningPos(), key);\n@@ -1749,0 +1716,8 @@\n+        DiagnosticPosition warningPos() {\n+            return site.pos().withLintPosition(NOPOS);      \/\/ disable normal Lint suppression\n+        }\n+\n+        Lint lint() {\n+            return lintMapper.lintAt(topLevelEnv.toplevel.sourcefile, site.pos()).get();\n+        }\n+\n@@ -1750,2 +1725,1 @@\n-            return suppressible &&\n-              suppressed.contains(initializer instanceof JCVariableDecl v ? v.sym : method.declaration.sym);\n+            return suppressible && !lint().isEnabled(THIS_ESCAPE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":30,"deletions":56,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -111,2 +110,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n-    private final Lint lint;\n@@ -138,2 +135,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n-        lint = Lint.instance(context);\n@@ -277,1 +272,0 @@\n-                deferredLintHandler.push(tree);\n@@ -285,1 +279,0 @@\n-                    deferredLintHandler.pop();\n@@ -354,2 +347,0 @@\n-            deferredLintHandler.pushImmediate(lint);\n-            Lint prevLint = chk.setLint(lint);\n@@ -379,7 +370,2 @@\n-                    deferredLintHandler.push(decl);\n-                    try {\n-                        \/\/check @Deprecated:\n-                        markDeprecated(decl.sym, decl.mods.annotations, env);\n-                    } finally {\n-                        deferredLintHandler.pop();\n-                    }\n+                    \/\/check for @Deprecated annotations\n+                    markDeprecated(decl.sym, decl.mods.annotations, env);\n@@ -387,1 +373,1 @@\n-                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, decl);\n+                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle);\n@@ -391,2 +377,0 @@\n-                chk.setLint(prevLint);\n-                deferredLintHandler.pop();\n@@ -425,1 +409,1 @@\n-            annotate.annotateLater(tree.annotations, env, env.toplevel.packge, tree);\n+            annotate.annotateLater(tree.annotations, env, env.toplevel.packge);\n@@ -917,1 +901,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym);\n@@ -919,1 +903,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym);\n@@ -934,1 +918,1 @@\n-            annotate.annotateLater(tree.mods.annotations, baseEnv, sym, tree);\n+            annotate.annotateLater(tree.mods.annotations, baseEnv, sym);\n@@ -938,1 +922,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        locations.update(log, lint, FSInfo.instance(context));\n+        locations.update(log, FSInfo.instance(context));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,2 +80,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -86,0 +84,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -126,5 +125,0 @@\n-    \/**\n-     * The root {@link Lint} instance.\n-     *\/\n-    private Lint lint;\n-\n@@ -171,1 +165,1 @@\n-    void update(Log log, Lint lint, FSInfo fsInfo) {\n+    void update(Log log, FSInfo fsInfo) {\n@@ -173,1 +167,0 @@\n-        this.lint = lint;\n@@ -224,1 +217,1 @@\n-                    lint.logIfEnabled(LintWarnings.InvalidPath(s));\n+                    log.warning(LintWarnings.InvalidPath(s));\n@@ -319,1 +312,1 @@\n-                    lint.logIfEnabled(LintWarnings.DirPathElementNotFound(dir));\n+                    log.warning(LintWarnings.DirPathElementNotFound(dir));\n@@ -364,1 +357,1 @@\n-                    lint.logIfEnabled(LintWarnings.PathElementNotFound(file));\n+                    log.warning(LintWarnings.PathElementNotFound(file));\n@@ -386,1 +379,1 @@\n-                                lint.logIfEnabled(LintWarnings.UnexpectedArchiveFile(file));\n+                                log.warning(LintWarnings.UnexpectedArchiveFile(file));\n@@ -391,1 +384,1 @@\n-                                lint.logIfEnabled(LintWarnings.InvalidArchiveFile(file));\n+                                log.warning(LintWarnings.InvalidArchiveFile(file));\n@@ -1654,1 +1647,1 @@\n-                lint.logIfEnabled(Files.exists(prefix) ?\n+                log.warning(Files.exists(prefix) ?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/Locations.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -142,3 +141,0 @@\n-    \/** The root Lint config. *\/\n-    Lint lint;\n-\n@@ -306,2 +302,0 @@\n-        lint = Lint.instance(context);\n-\n@@ -857,2 +851,1 @@\n-                        lint.logIfEnabled(\n-                                    LintWarnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));\n+                        log.warning(LintWarnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));\n@@ -1612,1 +1605,1 @@\n-            lint.logIfEnabled(LintWarnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n+            log.warning(LintWarnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n@@ -2078,1 +2071,1 @@\n-                    lint.logIfEnabled(LintWarnings.AnnotationMethodNotFound(container, name));\n+                    log.warning(LintWarnings.AnnotationMethodNotFound(container, name));\n@@ -2080,1 +2073,1 @@\n-                    lint.logIfEnabled(LintWarnings.AnnotationMethodNotFoundReason(container,\n+                    log.warning(LintWarnings.AnnotationMethodNotFoundReason(container,\n@@ -2957,1 +2950,1 @@\n-        lint.logIfEnabled(LintWarnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n+        log.warning(LintWarnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -506,6 +505,3 @@\n-                    boolean lintPaths = !options.isLintDisabled(LintCategory.PATH);\n-                    if (lintPaths) {\n-                        Path outDirParent = outDir.getParent();\n-                        if (outDirParent != null && Files.exists(outDirParent.resolve(\"module-info.class\"))) {\n-                            log.warning(LintWarnings.OutdirIsInExplodedModule(outDir));\n-                        }\n+                    Path outDirParent = outDir.getParent();\n+                    if (outDirParent != null && Files.exists(outDirParent.resolve(\"module-info.class\"))) {\n+                        log.warning(LintWarnings.OutdirIsInExplodedModule(outDir));\n@@ -579,2 +575,1 @@\n-        boolean lintOptions = !options.isLintDisabled(LintCategory.OPTIONS);\n-        if (lintOptions && source.compareTo(Source.DEFAULT) < 0 && !options.isSet(Option.RELEASE)) {\n+        if (source.compareTo(Source.DEFAULT) < 0 && !options.isSet(Option.RELEASE)) {\n@@ -583,1 +578,1 @@\n-                    if (baseFileManager.isDefaultBootClassPath())\n+                    if (baseFileManager.isDefaultBootClassPath()) {\n@@ -585,3 +580,3 @@\n-                } else {\n-                    if (baseFileManager.isDefaultSystemModulesPath())\n-                        log.warning(LintWarnings.SourceNoSystemModulesPath(source.name, releaseNote(source, targetString)));\n+                    }\n+                } else if (baseFileManager.isDefaultSystemModulesPath()) {\n+                    log.warning(LintWarnings.SourceNoSystemModulesPath(source.name, releaseNote(source, targetString)));\n@@ -596,1 +591,1 @@\n-        } else if (source == Source.MIN && lintOptions) {\n+        } else if (source == Source.MIN) {\n@@ -603,1 +598,1 @@\n-        } else if (target == Target.MIN && lintOptions) {\n+        } else if (target == Target.MIN) {\n@@ -637,1 +632,1 @@\n-        if (obsoleteOptionFound && lintOptions) {\n+        if (obsoleteOptionFound) {\n@@ -648,1 +643,1 @@\n-        if (lintOptions && options.isSet(Option.ADD_OPENS)) {\n+        if (options.isSet(Option.ADD_OPENS)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Arguments.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -261,0 +261,4 @@\n+    \/** The Lint mapper.\n+     *\/\n+    protected LintMapper lintMapper;\n+\n@@ -387,0 +391,1 @@\n+        lintMapper = LintMapper.instance(context);\n@@ -578,0 +583,1 @@\n+        log.reportOutstandingWarnings();\n@@ -628,0 +634,1 @@\n+        lintMapper.startParsingFile(filename);\n@@ -647,0 +654,1 @@\n+        lintMapper.finishParsingFile(tree);\n@@ -1846,0 +1854,1 @@\n+        log.reportOutstandingWarnings();\n@@ -1919,0 +1928,1 @@\n+        lintMapper = null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -86,1 +84,1 @@\n-    private final Log log;\n+    protected final Log log;\n@@ -138,7 +136,0 @@\n-    \/**\n-     * The set of lint options currently in effect. It is initialized\n-     * from the context, and then is set\/reset as needed by Attr as it\n-     * visits all the various parts of the trees during attribution.\n-     *\/\n-    protected final Lint lint;\n-\n@@ -171,1 +162,0 @@\n-        this.lint = fac.lint;\n@@ -208,11 +198,0 @@\n-    \/**\n-     * Report a warning at the given position using the provided arguments.\n-     *\n-     * @param pos    position in input buffer.\n-     * @param key    error key to report.\n-     *\/\n-    protected void lexWarning(int pos, JCDiagnostic.LintWarning key) {\n-        DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;\n-        log.warning(dp, key);\n-    }\n-\n@@ -1063,11 +1042,6 @@\n-                    if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {\n-                        Set<TextBlockSupport.WhitespaceChecks> checks =\n-                                TextBlockSupport.checkWhitespace(string);\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.InconsistentWhiteSpaceIndentation);\n-                        }\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n-                        }\n+                    Set<TextBlockSupport.WhitespaceChecks> checks = TextBlockSupport.checkWhitespace(string);\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n+                        log.warning(pos, LintWarnings.InconsistentWhiteSpaceIndentation);\n+                    }\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n+                        log.warning(pos, LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":7,"deletions":33,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -119,2 +119,0 @@\n-    \/** Handler for deferred diagnostics. *\/\n-    protected final DeferredLintHandler deferredLintHandler;\n@@ -193,1 +191,0 @@\n-        this.deferredLintHandler = fac.deferredLintHandler;\n@@ -219,1 +216,0 @@\n-        this.deferredLintHandler = parser.deferredLintHandler;\n@@ -594,2 +590,1 @@\n-     *     dangling comments are also attached to the tree node\n-     *     by registering them using the {@link #deferredLintHandler}.\n+     *     dangling comments are reported to the log as warnings.\n@@ -656,6 +651,1 @@\n-            deferredLintHandler.push(tree);\n-            try {\n-                list.forEach(this::reportDanglingDocComment);\n-            } finally {\n-                deferredLintHandler.pop();\n-            }\n+            list.forEach(c -> reportDanglingDocComment(tree, c));\n@@ -666,1 +656,1 @@\n-     * Reports an individual dangling comment using the {@link #deferredLintHandler}.\n+     * Reports an individual dangling comment as a warning to the log.\n@@ -672,1 +662,1 @@\n-    void reportDanglingDocComment(Comment c) {\n+    void reportDanglingDocComment(JCTree tree, Comment c) {\n@@ -674,8 +664,3 @@\n-        if (pos != null) {\n-            deferredLintHandler.report(lint -> {\n-                if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) &&\n-                        !shebang(c, pos)) {\n-                    log.warning(\n-                            pos, LintWarnings.DanglingDocComment);\n-                }\n-            });\n+        if (pos != null && !shebang(c, pos)) {\n+            pos = pos.withLintPosition(tree.getStartPosition());\n+            S.lintWarning(pos, LintWarnings.DanglingDocComment);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -106,0 +108,8 @@\n+\n+    \/**\n+     * Report a warning that is subject to possible suppression by {@code @SuppressWarnings}.\n+     *\n+     * @param pos the lexical position at which the warning occurs\n+     * @param key the warning to report\n+     *\/\n+    void lintWarning(DiagnosticPosition pos, LintWarning key);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Lexer.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -73,1 +72,0 @@\n-    final DeferredLintHandler deferredLintHandler;\n@@ -91,1 +89,0 @@\n-        this.deferredLintHandler = DeferredLintHandler.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ParserFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -153,0 +155,5 @@\n+    @Override\n+    public void lintWarning(DiagnosticPosition pos, LintWarning key) {\n+        tokenizer.log.warning(pos, key);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import com.sun.tools.javac.code.Lint;\n@@ -65,1 +64,0 @@\n-    final Lint lint;\n@@ -77,1 +75,0 @@\n-        this.lint = Lint.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ScannerFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -170,4 +171,3 @@\n-        public void commit() {\n-            for (int i = 0 ; i < offset ; i++) {\n-                S.nextToken(); \/\/ advance underlying lexer until position matches\n-            }\n+        @Override\n+        public void lintWarning(DiagnosticPosition pos, LintWarning key) {\n+           \/\/ ignore\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/VirtualParser.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import com.sun.tools.javac.code.Lint;\n@@ -65,1 +64,0 @@\n-import static com.sun.tools.javac.code.Lint.LintCategory.PROCESSING;\n@@ -341,1 +339,0 @@\n-    Lint lint;\n@@ -424,2 +421,0 @@\n-        lint = Lint.instance(context);\n-\n@@ -489,8 +484,6 @@\n-        if (lint.isEnabled(PROCESSING)) {\n-            int periodIndex = name.lastIndexOf(\".\");\n-            if (periodIndex != -1) {\n-                String base = name.substring(periodIndex);\n-                String extn = (isSourceFile ? \".java\" : \".class\");\n-                if (base.equals(extn))\n-                    log.warning(LintWarnings.ProcSuspiciousClassName(name, extn));\n-            }\n+        int periodIndex = name.lastIndexOf(\".\");\n+        if (periodIndex != -1) {\n+            String base = name.substring(periodIndex);\n+            String extn = (isSourceFile ? \".java\" : \".class\");\n+            if (base.equals(extn))\n+                log.warning(LintWarnings.ProcSuspiciousClassName(name, extn));\n@@ -710,1 +703,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcIllegalFileName(name));\n+            log.warning(LintWarnings.ProcIllegalFileName(name));\n@@ -738,1 +731,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcTypeRecreate(typename));\n+            log.warning(LintWarnings.ProcTypeRecreate(typename));\n@@ -742,1 +735,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcTypeAlreadyExists(typename));\n+            log.warning(LintWarnings.ProcTypeAlreadyExists(typename));\n@@ -771,1 +764,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcFileReopening(fileObject.getName()));\n+            log.warning(LintWarnings.ProcFileReopening(fileObject.getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacFiler.java","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-    private final Lint lint;\n@@ -209,1 +208,0 @@\n-        lint = Lint.instance(context);\n@@ -629,1 +627,1 @@\n-                       boolean allowModules, ProcessingEnvironment env, Lint lint) {\n+                       boolean allowModules, ProcessingEnvironment env) {\n@@ -650,2 +648,1 @@\n-                        add(importStringToPattern(allowModules, annotationPattern,\n-                                                  processor, log, lint));\n+                        add(importStringToPattern(allowModules, annotationPattern, processor, log));\n@@ -653,1 +650,1 @@\n-                        lint.logIfEnabled(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n+                        log.warning(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n@@ -666,1 +663,1 @@\n-                    lint.logIfEnabled(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n+                    log.warning(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n@@ -674,2 +671,1 @@\n-                            lint.logIfEnabled(LintWarnings.ProcDuplicateOptionName(optionName,\n-                                                                         p.getClass().getName()));\n+                            log.warning(LintWarnings.ProcDuplicateOptionName(optionName, p.getClass().getName()));\n@@ -762,2 +758,1 @@\n-                                                           JavacProcessingEnvironment.this,\n-                                                           lint);\n+                                                           JavacProcessingEnvironment.this);\n@@ -891,1 +886,1 @@\n-        if (lint.isEnabled(PROCESSING) && unmatchedAnnotations.size() > 0) {\n+        if (unmatchedAnnotations.size() > 0) {\n@@ -1652,1 +1647,1 @@\n-    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log, Lint lint) {\n+    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log) {\n@@ -1665,1 +1660,1 @@\n-                return warnAndNoMatches(s, p, log, lint);\n+                return warnAndNoMatches(s, p, log);\n@@ -1674,1 +1669,1 @@\n-            return warnAndNoMatches(s, p, log, lint);\n+            return warnAndNoMatches(s, p, log);\n@@ -1678,2 +1673,2 @@\n-    private static Pattern warnAndNoMatches(String s, Processor p, Log log, Lint lint) {\n-        lint.logIfEnabled(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n+    private static Pattern warnAndNoMatches(String s, Processor p, Log log) {\n+        log.warning(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1603,0 +1603,1 @@\n+# flags: default-enabled\n@@ -1927,1 +1928,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1933,1 +1934,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1939,1 +1940,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1950,1 +1951,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1962,1 +1963,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1968,1 +1969,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2197,0 +2198,1 @@\n+# flags: default-enabled\n@@ -2202,0 +2204,1 @@\n+# flags: default-enabled\n@@ -2227,0 +2230,1 @@\n+# flags: default-enabled\n@@ -2232,0 +2236,1 @@\n+# flags: default-enabled\n@@ -2244,0 +2249,1 @@\n+# flags: default-enabled\n@@ -2368,1 +2374,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2374,1 +2380,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2384,1 +2390,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2392,1 +2398,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2398,1 +2404,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2797,1 +2803,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3194,1 +3200,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3201,1 +3207,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3305,1 +3311,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3311,1 +3317,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3882,0 +3888,1 @@\n+# flags: default-enabled\n@@ -3898,0 +3905,1 @@\n+# flags: default-enabled\n@@ -4275,1 +4283,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -371,0 +371,30 @@\n+        \/** Get the position that determines which Lint configuration applies. *\/\n+        default int getLintPosition() {\n+            return getStartPosition();\n+        }\n+        \/** Create a new instance from this instance and the given lint position. *\/\n+        default DiagnosticPosition withLintPosition(int lintPos) {\n+            DiagnosticPosition orig = this;\n+            return new DiagnosticPosition() {\n+                @Override\n+                public JCTree getTree() {\n+                    return orig.getTree();\n+                }\n+                @Override\n+                public int getStartPosition() {\n+                    return orig.getStartPosition();\n+                }\n+                @Override\n+                public int getPreferredPosition() {\n+                    return orig.getPreferredPosition();\n+                }\n+                @Override\n+                public int getEndPosition(EndPosTable endPosTable) {\n+                    return orig.getEndPosition(endPosTable);\n+                }\n+                @Override\n+                public int getLintPosition() {\n+                    return lintPos;\n+                }\n+            };\n+        }\n@@ -408,0 +438,4 @@\n+        \/** Flag for lint diagnostics that should be emitted even when their category\n+         *  is not explicitly enabled, as long as it is not explicitly suppressed.\n+         *\/\n+        DEFAULT_ENABLED,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JCDiagnostic.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n@@ -39,0 +41,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -45,0 +48,1 @@\n+import com.sun.tools.javac.code.Flags;\n@@ -47,0 +51,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -48,0 +53,3 @@\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.comp.AttrContext;\n+import com.sun.tools.javac.comp.Env;\n@@ -51,1 +59,4 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeScanner;\n@@ -55,0 +66,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -58,0 +70,4 @@\n+import static com.sun.tools.javac.code.Lint.LintCategory.*;\n+import static com.sun.tools.javac.resources.CompilerProperties.LintWarnings.RequiresAutomatic;\n+import static com.sun.tools.javac.resources.CompilerProperties.LintWarnings.RequiresTransitiveAutomatic;\n+import static com.sun.tools.javac.tree.JCTree.Tag.*;\n@@ -106,0 +122,5 @@\n+        \/**\n+         * Diagnostics waiting for an applicable {@link Lint} instance.\n+         *\/\n+        protected Map<JavaFileObject, List<JCDiagnostic>> lintWaitersMap = new LinkedHashMap<>();\n+\n@@ -116,1 +137,57 @@\n-         * Handle a diagnostic.\n+         * Step 1: Handle a diagnostic for which the applicable Lint instance (if any) may not be known yet.\n+         *\/\n+        public final void report(JCDiagnostic diag) {\n+            Lint lint = null;\n+            LintCategory category = diag.getLintCategory();\n+            if (category != null) {                                         \/\/ this is a lint warning; find the applicable Lint\n+                DiagnosticPosition pos = diag.getDiagnosticPosition();\n+                if (pos != null && category.annotationSuppression) {        \/\/ we should apply the Lint from the warning's position\n+                    if ((lint = lintFor(diag)) == null) {\n+                        addLintWaiter(currentSourceFile(), diag);           \/\/ ...but we don't know it yet, so defer\n+                        return;\n+                    }\n+                } else                                                      \/\/ we should apply the root Lint\n+                    lint = rootLint();\n+            }\n+            reportWithLint(diag, lint);\n+        }\n+\n+        \/**\n+         * Step 2: Handle a diagnostic for which the applicable Lint instance (if any) is known and provided.\n+         *\/\n+        public final void reportWithLint(JCDiagnostic diag, Lint lint) {\n+\n+            \/\/ Apply hackery for REQUIRES_TRANSITIVE_AUTOMATIC (see also Check.checkModuleRequires())\n+            if (diag.getCode().equals(RequiresTransitiveAutomatic.key()) && !lint.isEnabled(REQUIRES_TRANSITIVE_AUTOMATIC)) {\n+                reportWithLint(\n+                  diags.warning(null, diag.getDiagnosticSource(), diag.getDiagnosticPosition(), RequiresAutomatic), lint);\n+                return;\n+            }\n+\n+            \/\/ Apply the lint configuration (if any) and discard the warning if it gets filtered out\n+            if (lint != null) {\n+                LintCategory category = diag.getLintCategory();\n+                boolean emit = !diag.isFlagSet(DEFAULT_ENABLED) ?       \/\/ is the warning not enabled by default?\n+                  lint.isEnabled(category) :                            \/\/ then emit if the category is enabled\n+                  category.annotationSuppression ?                      \/\/ else emit if the category is not suppressed, where\n+                    !lint.isSuppressed(category) :                      \/\/ ...suppression happens via @SuppressWarnings\n+                    !options.isLintDisabled(category);                  \/\/ ...suppression happens via -Xlint:-category\n+                if (!emit)\n+                    return;\n+            }\n+\n+            \/\/ Proceed\n+            reportReady(diag);\n+        }\n+\n+        \/**\n+         * Step 3: Handle a diagnostic to which the applicable Lint instance (if any) has been applied.\n+         *\/\n+        protected abstract void reportReady(JCDiagnostic diag);\n+\n+        protected void addLintWaiter(JavaFileObject sourceFile, JCDiagnostic diagnostic) {\n+            lintWaitersMap.computeIfAbsent(sourceFile, s -> new LinkedList<>()).add(diagnostic);\n+        }\n+\n+        \/**\n+         * Flush any lint waiters whose {@link Lint} configurations are now known.\n@@ -118,1 +195,28 @@\n-        public abstract void report(JCDiagnostic diag);\n+        public void flushLintWaiters() {\n+            lintWaitersMap.entrySet().removeIf(entry -> {\n+\n+                \/\/ Is the source file no longer recognized? If so, discard warnings (e.g., this can happen with JShell)\n+                JavaFileObject sourceFile = entry.getKey();\n+                if (!lintMapper.isKnown(sourceFile))\n+                    return true;\n+\n+                \/\/ Flush those diagnostics for which we now know the applicable Lint\n+                List<JCDiagnostic> diagnosticList = entry.getValue();\n+                JavaFileObject prevSourceFile = useSource(sourceFile);\n+                try {\n+                    diagnosticList.removeIf(diag -> {\n+                        Lint lint = lintFor(diag);\n+                        if (lint != null) {\n+                            reportWithLint(diag, lint);\n+                            return true;\n+                        }\n+                        return false;\n+                    });\n+                } finally {\n+                    useSource(prevSourceFile);\n+                }\n+\n+                \/\/ Discard list if empty\n+                return diagnosticList.isEmpty();\n+            });\n+        }\n@@ -127,1 +231,4 @@\n-        public void report(JCDiagnostic diag) { }\n+        protected void addLintWaiter(JavaFileObject sourceFile, JCDiagnostic diagnostic) { }\n+\n+        @Override\n+        protected void reportReady(JCDiagnostic diag) { }\n@@ -160,1 +267,1 @@\n-        public void report(JCDiagnostic diag) {\n+        protected void reportReady(JCDiagnostic diag) {\n@@ -164,1 +271,10 @@\n-                prev.report(diag);\n+                prev.reportReady(diag);\n+            }\n+        }\n+\n+        @Override\n+        protected void addLintWaiter(JavaFileObject sourceFile, JCDiagnostic diag) {\n+            if (deferrable(diag)) {\n+                super.addLintWaiter(sourceFile, diag);\n+            } else {\n+                prev.addLintWaiter(sourceFile, diag);\n@@ -185,0 +301,7 @@\n+\n+            \/\/ Flush matching Lint waiters to the previous handler\n+            lintWaitersMap.forEach(\n+              (sourceFile, diagnostics) -> diagnostics.stream()\n+                .filter(accepter)\n+                .forEach(diagnostic -> prev.addLintWaiter(sourceFile, diagnostic)));\n+            lintWaitersMap = null; \/\/ prevent accidental ongoing use\n@@ -250,0 +373,10 @@\n+    \/**\n+     * The {@link Options} singleton.\n+     *\/\n+    private final Options options;\n+\n+    \/**\n+     * The lint positions table.\n+     *\/\n+    private final LintMapper lintMapper;\n+\n@@ -353,0 +486,2 @@\n+        this.options = Options.instance(context);\n+        this.lintMapper = LintMapper.instance(context);\n@@ -372,1 +507,0 @@\n-        final Options options = Options.instance(context);\n@@ -692,0 +826,15 @@\n+\/\/ Deferred Lint Calculation\n+\n+    \/**\n+     * Report unreported lint warnings for which the applicable {@link Lint} configuration is now known.\n+     *\/\n+    public void reportOutstandingWarnings() {\n+        diagnosticHandler.flushLintWaiters();\n+    }\n+\n+    \/\/ Get the Lint config for the given warning (if known)\n+    private Lint lintFor(JCDiagnostic diag) {\n+        Assert.check(diag.getLintCategory() != null);\n+        return lintMapper.lintAt(diag.getSource(), diag.getDiagnosticPosition()).orElse(null);\n+    }\n+\n@@ -759,1 +908,1 @@\n-        public void report(JCDiagnostic diagnostic) {\n+        protected void reportReady(JCDiagnostic diagnostic) {\n@@ -786,1 +935,1 @@\n-                    boolean verbose = rootLint().isEnabled(category);\n+                    boolean verbose = lintFor(diagnostic).isEnabled(category);\n@@ -792,1 +941,1 @@\n-                if (diagnostic.isFlagSet(DiagnosticFlag.STRICT)) {\n+                if (diagnostic.isFlagSet(STRICT)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":159,"deletions":10,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -1464,2 +1464,1 @@\n-        case CKA_ECDSA_PARAMS:\n-            \/* CKA_EC_PARAMS is the same, these two are equivalent *\/\n+        case CKA_EC_PARAMS:\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-#define CK_ATTRIBUTES_TEMPLATE_LENGTH (CK_ULONG)61U\n+#define CK_ATTRIBUTES_TEMPLATE_LENGTH (CK_ULONG)60U\n@@ -61,0 +61,2 @@\n+\/\/ Group attributes based on their value types; put attributes whose values\n+\/\/ requiring address alignments, e.g. CK_ULONG, first\n@@ -62,7 +64,1 @@\n-        {CKA_CLASS, 0, 0},\n-        {CKA_TOKEN, 0, 0},\n-        {CKA_PRIVATE, 0, 0},\n-        {CKA_LABEL, 0, 0},\n-        {CKA_APPLICATION, 0, 0},\n-        {CKA_VALUE, 0, 0},\n-        {CKA_OBJECT_ID, 0, 0},\n+        \/\/ CK_ULONG\n@@ -70,6 +66,3 @@\n-        {CKA_ISSUER, 0, 0},\n-        {CKA_SERIAL_NUMBER, 0, 0},\n-        {CKA_AC_ISSUER, 0, 0},\n-        {CKA_OWNER, 0, 0},\n-        {CKA_ATTR_TYPES, 0, 0},\n-        {CKA_TRUSTED, 0, 0},\n+        {CKA_CLASS, 0, 0},\n+        {CKA_HW_FEATURE_TYPE, 0, 0},\n+        {CKA_KEY_GEN_MECHANISM, 0, 0},\n@@ -77,25 +70,0 @@\n-        {CKA_SUBJECT, 0, 0},\n-        {CKA_ID, 0, 0},\n-        {CKA_SENSITIVE, 0, 0},\n-        {CKA_ENCRYPT, 0, 0},\n-        {CKA_DECRYPT, 0, 0},\n-        {CKA_WRAP, 0, 0},\n-        {CKA_UNWRAP, 0, 0},\n-        {CKA_SIGN, 0, 0},\n-        {CKA_SIGN_RECOVER, 0, 0},\n-        {CKA_VERIFY, 0, 0},\n-        {CKA_VERIFY_RECOVER, 0, 0},\n-        {CKA_DERIVE, 0, 0},\n-        {CKA_START_DATE, 0, 0},\n-        {CKA_END_DATE, 0, 0},\n-        {CKA_MODULUS, 0, 0},\n-        {CKA_PUBLIC_EXPONENT, 0, 0},\n-        {CKA_PRIVATE_EXPONENT, 0, 0},\n-        {CKA_PRIME_1, 0, 0},\n-        {CKA_PRIME_2, 0, 0},\n-        {CKA_EXPONENT_1, 0, 0},\n-        {CKA_EXPONENT_2, 0, 0},\n-        {CKA_COEFFICIENT, 0, 0},\n-        {CKA_PRIME, 0, 0},\n-        {CKA_SUBPRIME, 0, 0},\n-        {CKA_BASE, 0, 0},\n@@ -107,0 +75,5 @@\n+        \/\/ CK_BBOOL\n+        {CKA_ALWAYS_SENSITIVE, 0, 0},\n+        {CKA_DECRYPT, 0, 0},\n+        {CKA_DERIVE, 0, 0},\n+        {CKA_ENCRYPT, 0, 0},\n@@ -108,0 +81,1 @@\n+        {CKA_HAS_RESET, 0, 0},\n@@ -109,4 +83,17 @@\n-        {CKA_NEVER_EXTRACTABLE, 0, 0},\n-        {CKA_ALWAYS_SENSITIVE, 0, 0},\n-        {CKA_KEY_GEN_MECHANISM, 0, 0},\n-        {CKA_ECDSA_PARAMS, 0, 0},\n+        {CKA_NEVER_EXTRACTABLE, 0, 0},\n+        {CKA_PRIVATE, 0, 0},\n+        {CKA_RESET_ON_INIT, 0, 0},\n+        {CKA_SENSITIVE, 0, 0},\n+        {CKA_SIGN, 0, 0},\n+        {CKA_SIGN_RECOVER, 0, 0},\n+        {CKA_TOKEN, 0, 0},\n+        {CKA_TRUSTED, 0, 0},\n+        {CKA_UNWRAP, 0, 0},\n+        {CKA_VERIFY, 0, 0},\n+        {CKA_VERIFY_RECOVER, 0, 0},\n+        {CKA_WRAP, 0, 0},\n+        \/\/ PTR: byte[]\n+        {CKA_AC_ISSUER, 0, 0},\n+        {CKA_ATTR_TYPES, 0, 0},\n+        {CKA_BASE, 0, 0},\n+        {CKA_COEFFICIENT, 0, 0},\n@@ -116,0 +103,23 @@\n+        {CKA_EXPONENT_1, 0, 0},\n+        {CKA_EXPONENT_2, 0, 0},\n+        {CKA_ID, 0, 0},\n+        {CKA_ISSUER, 0, 0},\n+        {CKA_MODULUS, 0, 0},\n+        {CKA_OBJECT_ID, 0, 0},\n+        {CKA_OWNER, 0, 0},\n+        {CKA_PRIME, 0, 0},\n+        {CKA_PRIME_1, 0, 0},\n+        {CKA_PRIME_2, 0, 0},\n+        {CKA_PRIVATE_EXPONENT, 0, 0},\n+        {CKA_PUBLIC_EXPONENT, 0, 0},\n+        {CKA_SERIAL_NUMBER, 0, 0},\n+        {CKA_SUBJECT, 0, 0},\n+        {CKA_SUBPRIME, 0, 0},\n+        {CKA_VALUE, 0, 0},\n+        \/\/ PTR: CK_UTF8CHAR[]\n+        {CKA_APPLICATION, 0, 0},\n+        {CKA_LABEL, 0, 0},\n+        \/\/ PTR: CK_DATE\n+        {CKA_START_DATE, 0, 0},\n+        {CKA_END_DATE, 0, 0},\n+        \/\/ deprecated\n@@ -118,3 +128,1 @@\n-        {CKA_HW_FEATURE_TYPE, 0, 0},\n-        {CKA_RESET_ON_INIT, 0, 0},\n-        {CKA_HAS_RESET, 0, 0},\n+        \/\/ misc\n@@ -122,0 +130,1 @@\n+        \/\/ keep this at the end to match the impl in getNativeKeyInfo(...)\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_keymgmt.c","additions":56,"deletions":47,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,0 @@\n-        jframe.setLocationRelativeTo(null);\n@@ -100,0 +99,1 @@\n+        jframe.setLocationRelativeTo(null);\n","filename":"src\/jdk.editpad\/share\/classes\/jdk\/editpad\/EditPad.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-            vsp.maskType(), vsp.elementType(), laneCount,\n+            vsp.maskType(), vsp.carrierType(), vsp.elementType(), vsp.operType(), laneCount,\n@@ -305,2 +305,8 @@\n-        VectorMask<E> badMask =\n-            iota.compare(GE, iota.broadcast(indexLimit));\n+        VectorMask<E> badMask = null, badMask2 = null;\n+        if (vectorSpecies().elementType() == Float16.class) {\n+            badMask =\n+                iota.compare(GE, Float.floatToFloat16((float)indexLimit));\n+        } else {\n+            badMask =\n+                iota.compare(GE, iota.broadcast(indexLimit));\n+        }\n@@ -315,2 +321,7 @@\n-            VectorMask<E> badMask2 =\n-                iota.compare(LT, iota.broadcast(firstGoodIndex));\n+            if (vectorSpecies().elementType() == Float16.class) {\n+                badMask2 =\n+                    iota.compare(LT, iota.broadcast(Float.floatToFloat16((float)firstGoodIndex)));\n+            } else {\n+                badMask2 =\n+                    iota.compare(LT, iota.broadcast(firstGoodIndex));\n+            }\n@@ -380,1 +391,6 @@\n-        VectorMask<E> badMask =\n+        VectorMask<E> badMask = null, badMask2 = null;\n+        if (vectorSpecies().elementType() == Float16.class) {\n+            badMask =\n+                iota.compare(GE, Float.floatToFloat16((float)indexLimit));\n+        } else {\n+            badMask =\n@@ -382,0 +398,1 @@\n+        }\n@@ -391,1 +408,5 @@\n-            VectorMask<E> badMask2 =\n+            if (vectorSpecies().elementType() == Float16.class) {\n+                badMask2 =\n+                    iota.compare(LT, iota.broadcast(Float.floatToFloat16((float)firstGoodIndex)));\n+            } else {\n+                badMask2 =\n@@ -393,0 +414,1 @@\n+            }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -306,0 +306,6 @@\n+    \/*package-private*\/\n+    abstract Class<?> carrierType();\n+\n+    \/*package-private*\/\n+    abstract int operType();\n+\n@@ -323,1 +329,1 @@\n-        Object za = Array.newInstance(elementType(), laneCount);\n+        Object za = Array.newInstance(carrierType(), laneCount);\n@@ -418,12 +424,25 @@\n-        Object ia = Array.newInstance(laneType.elementType,\n-                                      laneCount);\n-        assert(ia.getClass() == laneType.arrayType);\n-        checkValue(laneCount-1);  \/\/ worst case\n-        for (int i = 0; i < laneCount; i++) {\n-            if ((byte)i == i)\n-                Array.setByte(ia, i, (byte)i);\n-            else if ((short)i == i)\n-                Array.setShort(ia, i, (short)i);\n-            else\n-                Array.setInt(ia, i, i);\n-            assert(Array.getDouble(ia, i) == i);\n+        Object ia = null;\n+        if (elementType() == Float16.class) {\n+            ia = Array.newInstance(carrierType(), laneCount);\n+            checkValue(laneCount - 1);  \/\/ worst case\n+            for (int i = 0; i < laneCount; i++) {\n+                \/\/ All the numbers in the range [0 2048] are directly representable in FP16 format without the precision loss.\n+                if (i < 2049) {\n+                    Array.setShort(ia, i, Float.floatToFloat16((float)i));\n+                } else {\n+                    assert(Float16.valueOf(i).intValue() == i);\n+                }\n+            }\n+        } else {\n+            ia = Array.newInstance(laneType.elementType, laneCount);\n+            assert(ia.getClass() == laneType.arrayType);\n+            checkValue(laneCount-1);  \/\/ worst case\n+            for (int i = 0; i < laneCount; i++) {\n+                if ((byte)i == i)\n+                    Array.setByte(ia, i, (byte)i);\n+                else if ((short)i == i)\n+                    Array.setShort(ia, i, (short)i);\n+                else\n+                    Array.setInt(ia, i, i);\n+                assert(Array.getDouble(ia, i) == i);\n+            }\n@@ -627,0 +646,2 @@\n+        case LaneType.SK_HALFFLOAT:\n+            s = HalffloatVector.species(shape); break;\n@@ -639,1 +660,3 @@\n-        assert(s.laneType == laneType) : s + \"!=\" + laneType;\n+        \/\/ FIXME: Remove the additional check for Halffloat laneTypes from following assertion after proper fix.\n+        \/\/ Currently the incoming laneType does not comply with the laneType of Halffloat species.\n+        assert(s.laneType == laneType) || laneType.switchKey == LaneType.SK_HALFFLOAT : s + \"!=\" + laneType;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":37,"deletions":14,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -296,0 +296,9 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public HalffloatVector reinterpretAsHalffloats() {\n+        return (HalffloatVector) asVectorRaw(LaneType.HALFFLOAT);\n+    }\n+\n@@ -568,0 +577,2 @@\n+        case LaneType.SK_HALFFLOAT:\n+            return HalffloatVector.fromMemorySegment(rsp.check(Float16.class), ms, 0, bo, m.check(Float16.class)).check0(rsp);\n@@ -630,0 +641,7 @@\n+            case LaneType.SK_HALFFLOAT: {\n+                short[] a = new short[rlength];\n+                for (int i = 0; i < limit; i++) {\n+                    a[i] = Float16.float16ToRawShortBits(Float16.valueOf((float) lanes[i]));\n+                }\n+                return HalffloatVector.fromArray(dsp.check(Float16.class), a, 0).check0(dsp);\n+            }\n@@ -680,0 +698,7 @@\n+            case LaneType.SK_HALFFLOAT: {\n+                short[] a = new short[rlength];\n+                for (int i = 0; i < limit; i++) {\n+                    a[i] = Float16.float16ToRawShortBits(Float16.valueOf((float) lanes[i]));\n+                }\n+                return HalffloatVector.fromArray(dsp.check(Float16.class), a, 0).check0(dsp);\n+            }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+    static final Class<Byte> CTYPE = byte.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Byte> ETYPE = byte.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Byte> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Byte> elementType() { return byte.class; }\n+    public final Class<Byte> elementType() { return ETYPE; }\n@@ -544,1 +551,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -579,1 +586,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -592,1 +599,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n@@ -694,1 +701,1 @@\n-                Byte128Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -710,2 +717,3 @@\n-                Byte128Vector.class, Byte128Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Byte128Vector.class, Byte128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -722,1 +730,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -732,1 +740,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -742,1 +750,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -752,2 +760,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte128Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte128Mask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -759,2 +768,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte128Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte128Mask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -766,2 +776,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte128Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte128Mask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -776,1 +787,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte128Mask.class, byte.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte128Mask.class, byte.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -786,1 +798,1 @@\n-            return VectorSupport.extract(Byte128Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.extract(Byte128Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -795,3 +807,3 @@\n-            return VectorSupport.test(BT_ne, Byte128Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Byte128Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Byte128Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Byte128Mask)m).getBits()));\n@@ -803,3 +815,3 @@\n-            return VectorSupport.test(BT_overflow, Byte128Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Byte128Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Byte128Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Byte128Mask)m).getBits()));\n@@ -811,1 +823,1 @@\n-            return VectorSupport.fromBitsCoerced(Byte128Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Byte128Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -824,1 +836,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+    static final Class<Byte> CTYPE = byte.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Byte> ETYPE = byte.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Byte> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Byte> elementType() { return byte.class; }\n+    public final Class<Byte> elementType() { return ETYPE; }\n@@ -560,1 +567,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -611,1 +618,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -624,1 +631,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n@@ -726,1 +733,1 @@\n-                Byte256Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -742,2 +749,3 @@\n-                Byte256Vector.class, Byte256Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Byte256Vector.class, Byte256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -754,1 +762,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -764,1 +772,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -774,1 +782,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -784,2 +792,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte256Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte256Mask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -791,2 +800,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte256Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte256Mask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -798,2 +808,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte256Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte256Mask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -808,1 +819,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte256Mask.class, byte.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte256Mask.class, byte.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -818,1 +830,1 @@\n-            return VectorSupport.extract(Byte256Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.extract(Byte256Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -827,3 +839,3 @@\n-            return VectorSupport.test(BT_ne, Byte256Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Byte256Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Byte256Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Byte256Mask)m).getBits()));\n@@ -835,3 +847,3 @@\n-            return VectorSupport.test(BT_overflow, Byte256Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Byte256Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Byte256Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Byte256Mask)m).getBits()));\n@@ -843,1 +855,1 @@\n-            return VectorSupport.fromBitsCoerced(Byte256Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Byte256Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -856,1 +868,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+    static final Class<Byte> CTYPE = byte.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Byte> ETYPE = byte.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Byte> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Byte> elementType() { return byte.class; }\n+    public final Class<Byte> elementType() { return ETYPE; }\n@@ -592,1 +599,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -675,1 +682,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -688,1 +695,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n@@ -790,1 +797,1 @@\n-                Byte512Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -806,2 +813,3 @@\n-                Byte512Vector.class, Byte512Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Byte512Vector.class, Byte512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -818,1 +826,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -828,1 +836,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -838,1 +846,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -848,2 +856,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte512Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte512Mask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -855,2 +864,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte512Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte512Mask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -862,2 +872,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte512Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte512Mask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -872,1 +883,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte512Mask.class, byte.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte512Mask.class, byte.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -882,1 +894,1 @@\n-            return VectorSupport.extract(Byte512Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.extract(Byte512Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -891,3 +903,3 @@\n-            return VectorSupport.test(BT_ne, Byte512Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Byte512Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Byte512Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Byte512Mask)m).getBits()));\n@@ -899,3 +911,3 @@\n-            return VectorSupport.test(BT_overflow, Byte512Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Byte512Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Byte512Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Byte512Mask)m).getBits()));\n@@ -907,1 +919,1 @@\n-            return VectorSupport.fromBitsCoerced(Byte512Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Byte512Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -920,1 +932,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+    static final Class<Byte> CTYPE = byte.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Byte> ETYPE = byte.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Byte> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Byte> elementType() { return byte.class; }\n+    public final Class<Byte> elementType() { return ETYPE; }\n@@ -536,1 +543,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -563,1 +570,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -576,1 +583,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n@@ -678,1 +685,1 @@\n-                Byte64Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -694,2 +701,3 @@\n-                Byte64Vector.class, Byte64Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Byte64Vector.class, Byte64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -706,1 +714,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -716,1 +724,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -726,1 +734,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -736,2 +744,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte64Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte64Mask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -743,2 +752,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte64Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte64Mask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -750,2 +760,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte64Mask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte64Mask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -760,1 +771,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte64Mask.class, byte.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Byte64Mask.class, byte.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -770,1 +782,1 @@\n-            return VectorSupport.extract(Byte64Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.extract(Byte64Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -779,3 +791,3 @@\n-            return VectorSupport.test(BT_ne, Byte64Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Byte64Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Byte64Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Byte64Mask)m).getBits()));\n@@ -787,3 +799,3 @@\n-            return VectorSupport.test(BT_overflow, Byte64Mask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Byte64Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Byte64Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Byte64Mask)m).getBits()));\n@@ -795,1 +807,1 @@\n-            return VectorSupport.fromBitsCoerced(Byte64Mask.class, byte.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Byte64Mask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -808,1 +820,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+    static final Class<Byte> CTYPE = byte.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Byte> ETYPE = byte.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Byte> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Byte> elementType() { return byte.class; }\n+    public final Class<Byte> elementType() { return ETYPE; }\n@@ -529,1 +536,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -549,1 +556,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -562,1 +569,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n@@ -664,1 +671,1 @@\n-                ByteMaxMask.class, byte.class, VLENGTH, offset, limit,\n+                ByteMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -680,2 +687,3 @@\n-                ByteMaxVector.class, ByteMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                ByteMaxVector.class, ByteMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -692,1 +700,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, ByteMaxMask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, ByteMaxMask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -702,1 +710,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, ByteMaxMask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, ByteMaxMask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -712,1 +720,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, ByteMaxMask.class, null, byte.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, ByteMaxMask.class, null, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -722,2 +730,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ByteMaxMask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -729,2 +738,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ByteMaxMask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -736,2 +746,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ByteMaxMask.class, byte.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -746,1 +757,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ByteMaxMask.class, byte.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ByteMaxMask.class, byte.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -756,1 +768,1 @@\n-            return VectorSupport.extract(ByteMaxMask.class, byte.class, VLENGTH,\n+            return VectorSupport.extract(ByteMaxMask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -765,3 +777,3 @@\n-            return VectorSupport.test(BT_ne, ByteMaxMask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((ByteMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_ne, ByteMaxMask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((ByteMaxMask)m).getBits()));\n@@ -773,3 +785,3 @@\n-            return VectorSupport.test(BT_overflow, ByteMaxMask.class, byte.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((ByteMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, ByteMaxMask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((ByteMaxMask)m).getBits()));\n@@ -781,1 +793,1 @@\n-            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -794,1 +806,1 @@\n-        static final Class<Byte> ETYPE = byte.class; \/\/ used by the JVM\n+        static final Class<Byte> CTYPE = byte.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n+\n@@ -576,1 +578,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), byte.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), byte.class, byte.class, VECTOR_OPER_TYPE, species.length(),\n@@ -698,1 +700,1 @@\n-            opc, getClass(), null, byte.class, length(),\n+            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -726,1 +728,1 @@\n-            opc, getClass(), maskClass, byte.class, length(),\n+            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -799,1 +801,1 @@\n-            opc, getClass(), null, byte.class, length(),\n+            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -850,1 +852,1 @@\n-            opc, getClass(), maskClass, byte.class, length(),\n+            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -1037,1 +1039,1 @@\n-            opc, getClass(), null, byte.class, length(),\n+            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -1058,1 +1060,1 @@\n-            opc, getClass(), maskClass, byte.class, length(),\n+            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -1135,1 +1137,1 @@\n-            opc, getClass(), null, byte.class, length(),\n+            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -1175,1 +1177,1 @@\n-            opc, getClass(), maskClass, byte.class, length(),\n+            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2073,1 +2075,1 @@\n-            opc, getClass(), maskType, byte.class, length(),\n+            opc, getClass(), maskType, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2095,1 +2097,1 @@\n-            opc, getClass(), maskType, byte.class, length(),\n+            opc, getClass(), maskType, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2226,1 +2228,1 @@\n-            getClass(), maskType, byte.class, length(),\n+            getClass(), maskType, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2243,1 +2245,1 @@\n-            getClass(), byte.class, length(),\n+            getClass(), byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2435,1 +2437,1 @@\n-            getClass(), shuffletype, null, byte.class, length(),\n+            getClass(), shuffletype, null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2461,1 +2463,1 @@\n-                   getClass(), shuffletype, masktype, byte.class, length(),\n+                   getClass(), shuffletype, masktype, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2488,1 +2490,1 @@\n-                getClass(), shuffletype, null, byte.class, length(),\n+                getClass(), shuffletype, null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2496,1 +2498,1 @@\n-                getClass(), shuffletype, null, byte.class, length(),\n+                getClass(), shuffletype, null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2546,1 +2548,1 @@\n-                                                        byte.class, length(), this, m,\n+                                                        byte.class, byte.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2565,1 +2567,1 @@\n-                                                        byte.class, length(), this, m,\n+                                                        byte.class, byte.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2580,1 +2582,1 @@\n-        return (ByteVector)VectorSupport.selectFromOp(getClass(), null, byte.class,\n+        return (ByteVector)VectorSupport.selectFromOp(getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE,\n@@ -2600,1 +2602,1 @@\n-        return (ByteVector)VectorSupport.selectFromOp(getClass(), masktype, byte.class,\n+        return (ByteVector)VectorSupport.selectFromOp(getClass(), masktype, byte.class, byte.class, VECTOR_OPER_TYPE,\n@@ -2618,1 +2620,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), byte.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), byte.class, byte.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -2838,1 +2840,1 @@\n-            opc, getClass(), maskClass, byte.class, length(),\n+            opc, getClass(), maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -2856,1 +2858,1 @@\n-            opc, getClass(), null, byte.class, length(),\n+            opc, getClass(), null, byte.class, byte.class, VECTOR_OPER_TYPE, length(),\n@@ -3146,1 +3148,1 @@\n-            vectorType, null, byte.class, vsp.laneCount(),\n+            vectorType, null, byte.class, byte.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3481,1 +3483,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3635,1 +3637,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3848,1 +3850,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3865,1 +3867,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3921,1 +3923,1 @@\n-            vectorType, maskClass, byte.class, vsp.laneCount(),\n+            vectorType, maskClass, byte.class, byte.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3938,1 +3940,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3955,1 +3957,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3969,1 +3971,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3985,1 +3987,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4003,1 +4005,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4020,1 +4022,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4039,1 +4041,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4052,1 +4054,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4069,1 +4071,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4250,0 +4252,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return byte.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (byte.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -4282,1 +4297,1 @@\n-                    vectorType, byte.class, laneCount,\n+                    vectorType, byte.class, byte.class, VECTOR_OPER_TYPE, laneCount,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":55,"deletions":40,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+    static final Class<Double> CTYPE = double.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Double> ETYPE = double.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Double> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Double> elementType() { return double.class; }\n+    public final Class<Double> elementType() { return ETYPE; }\n@@ -519,1 +526,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -540,1 +547,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -553,1 +560,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Double> CTYPE = double.class; \/\/ used by the JVM\n@@ -655,1 +662,1 @@\n-                Double128Mask.class, double.class, VLENGTH, offset, limit,\n+                Double128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -671,2 +678,3 @@\n-                Double128Vector.class, Double128Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Double128Vector.class, Double128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -683,1 +691,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -693,1 +701,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -703,1 +711,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -713,2 +721,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double128Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double128Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -720,2 +729,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double128Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double128Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -727,2 +737,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double128Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double128Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -737,1 +748,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double128Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double128Mask.class, long.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -747,1 +759,1 @@\n-            return VectorSupport.extract(Double128Mask.class, double.class, VLENGTH,\n+            return VectorSupport.extract(Double128Mask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -756,3 +768,3 @@\n-            return VectorSupport.test(BT_ne, Double128Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Double128Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Double128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Double128Mask)m).getBits()));\n@@ -764,3 +776,3 @@\n-            return VectorSupport.test(BT_overflow, Double128Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Double128Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Double128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Double128Mask)m).getBits()));\n@@ -772,1 +784,1 @@\n-            return VectorSupport.fromBitsCoerced(Double128Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Double128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -785,1 +797,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+    static final Class<Double> CTYPE = double.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Double> ETYPE = double.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Double> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Double> elementType() { return double.class; }\n+    public final Class<Double> elementType() { return ETYPE; }\n@@ -521,1 +528,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -544,1 +551,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -557,1 +564,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Double> CTYPE = double.class; \/\/ used by the JVM\n@@ -659,1 +666,1 @@\n-                Double256Mask.class, double.class, VLENGTH, offset, limit,\n+                Double256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -675,2 +682,3 @@\n-                Double256Vector.class, Double256Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Double256Vector.class, Double256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -687,1 +695,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -697,1 +705,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -707,1 +715,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -717,2 +725,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double256Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double256Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -724,2 +733,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double256Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double256Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -731,2 +741,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double256Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double256Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -741,1 +752,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double256Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double256Mask.class, long.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -751,1 +763,1 @@\n-            return VectorSupport.extract(Double256Mask.class, double.class, VLENGTH,\n+            return VectorSupport.extract(Double256Mask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -760,3 +772,3 @@\n-            return VectorSupport.test(BT_ne, Double256Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Double256Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Double256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Double256Mask)m).getBits()));\n@@ -768,3 +780,3 @@\n-            return VectorSupport.test(BT_overflow, Double256Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Double256Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Double256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Double256Mask)m).getBits()));\n@@ -776,1 +788,1 @@\n-            return VectorSupport.fromBitsCoerced(Double256Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Double256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -789,1 +801,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+    static final Class<Double> CTYPE = double.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Double> ETYPE = double.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Double> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Double> elementType() { return double.class; }\n+    public final Class<Double> elementType() { return ETYPE; }\n@@ -525,1 +532,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -552,1 +559,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -565,1 +572,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Double> CTYPE = double.class; \/\/ used by the JVM\n@@ -667,1 +674,1 @@\n-                Double512Mask.class, double.class, VLENGTH, offset, limit,\n+                Double512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -683,2 +690,3 @@\n-                Double512Vector.class, Double512Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Double512Vector.class, Double512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -695,1 +703,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -705,1 +713,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -715,1 +723,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -725,2 +733,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double512Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double512Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -732,2 +741,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double512Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double512Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -739,2 +749,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double512Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double512Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -749,1 +760,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double512Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double512Mask.class, long.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -759,1 +771,1 @@\n-            return VectorSupport.extract(Double512Mask.class, double.class, VLENGTH,\n+            return VectorSupport.extract(Double512Mask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -768,3 +780,3 @@\n-            return VectorSupport.test(BT_ne, Double512Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Double512Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Double512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Double512Mask)m).getBits()));\n@@ -776,3 +788,3 @@\n-            return VectorSupport.test(BT_overflow, Double512Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Double512Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Double512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Double512Mask)m).getBits()));\n@@ -784,1 +796,1 @@\n-            return VectorSupport.fromBitsCoerced(Double512Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Double512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -797,1 +809,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+    static final Class<Double> CTYPE = double.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Double> ETYPE = double.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Double> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Double> elementType() { return double.class; }\n+    public final Class<Double> elementType() { return ETYPE; }\n@@ -518,1 +525,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -538,1 +545,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -551,1 +558,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Double> CTYPE = double.class; \/\/ used by the JVM\n@@ -653,1 +660,1 @@\n-                Double64Mask.class, double.class, VLENGTH, offset, limit,\n+                Double64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -669,2 +676,3 @@\n-                Double64Vector.class, Double64Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Double64Vector.class, Double64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -681,1 +689,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -691,1 +699,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -701,1 +709,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -711,2 +719,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double64Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double64Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -718,2 +727,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double64Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double64Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -725,2 +735,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double64Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double64Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -735,1 +746,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double64Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Double64Mask.class, long.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -745,1 +757,1 @@\n-            return VectorSupport.extract(Double64Mask.class, double.class, VLENGTH,\n+            return VectorSupport.extract(Double64Mask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -754,3 +766,3 @@\n-            return VectorSupport.test(BT_ne, Double64Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Double64Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Double64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Double64Mask)m).getBits()));\n@@ -762,3 +774,3 @@\n-            return VectorSupport.test(BT_overflow, Double64Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Double64Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Double64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Double64Mask)m).getBits()));\n@@ -770,1 +782,1 @@\n-            return VectorSupport.fromBitsCoerced(Double64Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Double64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -783,1 +795,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+    static final Class<Double> CTYPE = double.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Double> ETYPE = double.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Double> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Double> elementType() { return double.class; }\n+    public final Class<Double> elementType() { return ETYPE; }\n@@ -517,1 +524,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -537,1 +544,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -550,1 +557,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Double> CTYPE = double.class; \/\/ used by the JVM\n@@ -652,1 +659,1 @@\n-                DoubleMaxMask.class, double.class, VLENGTH, offset, limit,\n+                DoubleMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -668,2 +675,3 @@\n-                DoubleMaxVector.class, DoubleMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                DoubleMaxVector.class, DoubleMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -680,1 +688,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, DoubleMaxMask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, DoubleMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -690,1 +698,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, DoubleMaxMask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, DoubleMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -700,1 +708,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, DoubleMaxMask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, DoubleMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -710,2 +718,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, DoubleMaxMask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -717,2 +726,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, DoubleMaxMask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -724,2 +734,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, DoubleMaxMask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -734,1 +745,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, DoubleMaxMask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, DoubleMaxMask.class, long.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -744,1 +756,1 @@\n-            return VectorSupport.extract(DoubleMaxMask.class, double.class, VLENGTH,\n+            return VectorSupport.extract(DoubleMaxMask.class, double.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -753,3 +765,3 @@\n-            return VectorSupport.test(BT_ne, DoubleMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((DoubleMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_ne, DoubleMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((DoubleMaxMask)m).getBits()));\n@@ -761,3 +773,3 @@\n-            return VectorSupport.test(BT_overflow, DoubleMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((DoubleMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, DoubleMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((DoubleMaxMask)m).getBits()));\n@@ -769,1 +781,1 @@\n-            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -782,1 +794,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n+\n@@ -565,1 +567,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), double.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), double.class, double.class, VECTOR_OPER_TYPE, species.length(),\n@@ -687,1 +689,1 @@\n-            opc, getClass(), null, double.class, length(),\n+            opc, getClass(), null, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -715,1 +717,1 @@\n-            opc, getClass(), maskClass, double.class, length(),\n+            opc, getClass(), maskClass, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -804,1 +806,1 @@\n-            opc, getClass(), null, double.class, length(),\n+            opc, getClass(), null, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -842,1 +844,1 @@\n-            opc, getClass(), maskClass, double.class, length(),\n+            opc, getClass(), maskClass, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -1024,1 +1026,1 @@\n-            opc, getClass(), null, double.class, length(),\n+            opc, getClass(), null, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -1059,1 +1061,1 @@\n-            opc, getClass(), maskClass, double.class, length(),\n+            opc, getClass(), maskClass, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -1931,1 +1933,1 @@\n-            opc, getClass(), maskType, double.class, length(),\n+            opc, getClass(), maskType, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -1953,1 +1955,1 @@\n-            opc, getClass(), maskType, double.class, length(),\n+            opc, getClass(), maskType, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2080,1 +2082,1 @@\n-            getClass(), maskType, double.class, length(),\n+            getClass(), maskType, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2097,1 +2099,1 @@\n-            getClass(), double.class, length(),\n+            getClass(), double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2289,1 +2291,1 @@\n-            getClass(), shuffletype, null, double.class, length(),\n+            getClass(), shuffletype, null, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2315,1 +2317,1 @@\n-                   getClass(), shuffletype, masktype, double.class, length(),\n+                   getClass(), shuffletype, masktype, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2342,1 +2344,1 @@\n-                getClass(), shuffletype, null, double.class, length(),\n+                getClass(), shuffletype, null, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2350,1 +2352,1 @@\n-                getClass(), shuffletype, null, double.class, length(),\n+                getClass(), shuffletype, null, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2394,1 +2396,1 @@\n-                                                        double.class, length(), this, m,\n+                                                        double.class, double.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2413,1 +2415,1 @@\n-                                                        double.class, length(), this, m,\n+                                                        double.class, double.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2428,1 +2430,1 @@\n-        return (DoubleVector)VectorSupport.selectFromOp(getClass(), null, double.class,\n+        return (DoubleVector)VectorSupport.selectFromOp(getClass(), null, double.class, double.class, VECTOR_OPER_TYPE,\n@@ -2448,1 +2450,1 @@\n-        return (DoubleVector)VectorSupport.selectFromOp(getClass(), masktype, double.class,\n+        return (DoubleVector)VectorSupport.selectFromOp(getClass(), masktype, double.class, double.class, VECTOR_OPER_TYPE,\n@@ -2466,1 +2468,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), double.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), double.class, double.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -2664,1 +2666,1 @@\n-            opc, getClass(), maskClass, double.class, length(),\n+            opc, getClass(), maskClass, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2682,1 +2684,1 @@\n-            opc, getClass(), null, double.class, length(),\n+            opc, getClass(), null, double.class, double.class, VECTOR_OPER_TYPE, length(),\n@@ -2939,1 +2941,1 @@\n-            vectorType, null, double.class, vsp.laneCount(),\n+            vectorType, null, double.class, double.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3122,1 +3124,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3230,1 +3232,1 @@\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3357,1 +3359,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3374,1 +3376,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3425,1 +3427,1 @@\n-            vectorType, maskClass, double.class, vsp.laneCount(),\n+            vectorType, maskClass, double.class, double.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3442,1 +3444,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3458,1 +3460,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3476,1 +3478,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3493,1 +3495,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3541,1 +3543,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3560,1 +3562,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3577,1 +3579,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3749,0 +3751,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return double.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (double.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -3781,1 +3796,1 @@\n-                    vectorType, double.class, laneCount,\n+                    vectorType, double.class, double.class, VECTOR_OPER_TYPE, laneCount,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":51,"deletions":36,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+    static final Class<Float> CTYPE = float.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float> ETYPE = float.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Float> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Float> elementType() { return float.class; }\n+    public final Class<Float> elementType() { return ETYPE; }\n@@ -521,1 +528,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -544,1 +551,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -557,1 +564,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Float> CTYPE = float.class; \/\/ used by the JVM\n@@ -659,1 +666,1 @@\n-                Float128Mask.class, float.class, VLENGTH, offset, limit,\n+                Float128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -675,2 +682,3 @@\n-                Float128Vector.class, Float128Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Float128Vector.class, Float128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -687,1 +695,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -697,1 +705,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -707,1 +715,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -717,2 +725,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float128Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float128Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -724,2 +733,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float128Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float128Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -731,2 +741,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float128Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float128Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -741,1 +752,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float128Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float128Mask.class, int.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -751,1 +763,1 @@\n-            return VectorSupport.extract(Float128Mask.class, float.class, VLENGTH,\n+            return VectorSupport.extract(Float128Mask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -760,3 +772,3 @@\n-            return VectorSupport.test(BT_ne, Float128Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Float128Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Float128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Float128Mask)m).getBits()));\n@@ -768,3 +780,3 @@\n-            return VectorSupport.test(BT_overflow, Float128Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Float128Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Float128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Float128Mask)m).getBits()));\n@@ -776,1 +788,1 @@\n-            return VectorSupport.fromBitsCoerced(Float128Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Float128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -789,1 +801,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+    static final Class<Float> CTYPE = float.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float> ETYPE = float.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Float> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Float> elementType() { return float.class; }\n+    public final Class<Float> elementType() { return ETYPE; }\n@@ -525,1 +532,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -552,1 +559,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -565,1 +572,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Float> CTYPE = float.class; \/\/ used by the JVM\n@@ -667,1 +674,1 @@\n-                Float256Mask.class, float.class, VLENGTH, offset, limit,\n+                Float256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -683,2 +690,3 @@\n-                Float256Vector.class, Float256Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Float256Vector.class, Float256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -695,1 +703,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -705,1 +713,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -715,1 +723,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -725,2 +733,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float256Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float256Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -732,2 +741,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float256Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float256Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -739,2 +749,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float256Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float256Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -749,1 +760,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float256Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float256Mask.class, int.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -759,1 +771,1 @@\n-            return VectorSupport.extract(Float256Mask.class, float.class, VLENGTH,\n+            return VectorSupport.extract(Float256Mask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -768,3 +780,3 @@\n-            return VectorSupport.test(BT_ne, Float256Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Float256Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Float256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Float256Mask)m).getBits()));\n@@ -776,3 +788,3 @@\n-            return VectorSupport.test(BT_overflow, Float256Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Float256Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Float256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Float256Mask)m).getBits()));\n@@ -784,1 +796,1 @@\n-            return VectorSupport.fromBitsCoerced(Float256Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Float256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -797,1 +809,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+    static final Class<Float> CTYPE = float.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float> ETYPE = float.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Float> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Float> elementType() { return float.class; }\n+    public final Class<Float> elementType() { return ETYPE; }\n@@ -533,1 +540,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -568,1 +575,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -581,1 +588,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Float> CTYPE = float.class; \/\/ used by the JVM\n@@ -683,1 +690,1 @@\n-                Float512Mask.class, float.class, VLENGTH, offset, limit,\n+                Float512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -699,2 +706,3 @@\n-                Float512Vector.class, Float512Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Float512Vector.class, Float512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -711,1 +719,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -721,1 +729,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -731,1 +739,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -741,2 +749,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float512Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float512Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -748,2 +757,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float512Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float512Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -755,2 +765,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float512Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float512Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -765,1 +776,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float512Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float512Mask.class, int.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -775,1 +787,1 @@\n-            return VectorSupport.extract(Float512Mask.class, float.class, VLENGTH,\n+            return VectorSupport.extract(Float512Mask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -784,3 +796,3 @@\n-            return VectorSupport.test(BT_ne, Float512Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Float512Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Float512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Float512Mask)m).getBits()));\n@@ -792,3 +804,3 @@\n-            return VectorSupport.test(BT_overflow, Float512Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Float512Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Float512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Float512Mask)m).getBits()));\n@@ -800,1 +812,1 @@\n-            return VectorSupport.fromBitsCoerced(Float512Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Float512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -813,1 +825,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+    static final Class<Float> CTYPE = float.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float> ETYPE = float.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Float> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Float> elementType() { return float.class; }\n+    public final Class<Float> elementType() { return ETYPE; }\n@@ -519,1 +526,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -540,1 +547,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -553,1 +560,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Float> CTYPE = float.class; \/\/ used by the JVM\n@@ -655,1 +662,1 @@\n-                Float64Mask.class, float.class, VLENGTH, offset, limit,\n+                Float64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -671,2 +678,3 @@\n-                Float64Vector.class, Float64Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Float64Vector.class, Float64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -683,1 +691,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -693,1 +701,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -703,1 +711,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -713,2 +721,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float64Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float64Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -720,2 +729,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float64Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float64Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -727,2 +737,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float64Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float64Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -737,1 +748,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float64Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Float64Mask.class, int.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -747,1 +759,1 @@\n-            return VectorSupport.extract(Float64Mask.class, float.class, VLENGTH,\n+            return VectorSupport.extract(Float64Mask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -756,3 +768,3 @@\n-            return VectorSupport.test(BT_ne, Float64Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Float64Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Float64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Float64Mask)m).getBits()));\n@@ -764,3 +776,3 @@\n-            return VectorSupport.test(BT_overflow, Float64Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Float64Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Float64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Float64Mask)m).getBits()));\n@@ -772,1 +784,1 @@\n-            return VectorSupport.fromBitsCoerced(Float64Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Float64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -785,1 +797,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+    static final Class<Float> CTYPE = float.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float> ETYPE = float.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Float> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Float> elementType() { return float.class; }\n+    public final Class<Float> elementType() { return ETYPE; }\n@@ -517,1 +524,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -537,1 +544,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -550,1 +557,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Float> CTYPE = float.class; \/\/ used by the JVM\n@@ -652,1 +659,1 @@\n-                FloatMaxMask.class, float.class, VLENGTH, offset, limit,\n+                FloatMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -668,2 +675,3 @@\n-                FloatMaxVector.class, FloatMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                FloatMaxVector.class, FloatMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -680,1 +688,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, FloatMaxMask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, FloatMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -690,1 +698,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, FloatMaxMask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, FloatMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -700,1 +708,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, FloatMaxMask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, FloatMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -710,2 +718,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, FloatMaxMask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -717,2 +726,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, FloatMaxMask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -724,2 +734,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, FloatMaxMask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -734,1 +745,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, FloatMaxMask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, FloatMaxMask.class, int.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -744,1 +756,1 @@\n-            return VectorSupport.extract(FloatMaxMask.class, float.class, VLENGTH,\n+            return VectorSupport.extract(FloatMaxMask.class, float.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -753,3 +765,3 @@\n-            return VectorSupport.test(BT_ne, FloatMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((FloatMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_ne, FloatMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((FloatMaxMask)m).getBits()));\n@@ -761,3 +773,3 @@\n-            return VectorSupport.test(BT_overflow, FloatMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((FloatMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, FloatMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((FloatMaxMask)m).getBits()));\n@@ -769,1 +781,1 @@\n-            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -782,1 +794,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n+\n@@ -565,1 +567,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), float.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), float.class, float.class, VECTOR_OPER_TYPE, species.length(),\n@@ -687,1 +689,1 @@\n-            opc, getClass(), null, float.class, length(),\n+            opc, getClass(), null, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -715,1 +717,1 @@\n-            opc, getClass(), maskClass, float.class, length(),\n+            opc, getClass(), maskClass, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -804,1 +806,1 @@\n-            opc, getClass(), null, float.class, length(),\n+            opc, getClass(), null, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -842,1 +844,1 @@\n-            opc, getClass(), maskClass, float.class, length(),\n+            opc, getClass(), maskClass, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -1024,1 +1026,1 @@\n-            opc, getClass(), null, float.class, length(),\n+            opc, getClass(), null, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -1059,1 +1061,1 @@\n-            opc, getClass(), maskClass, float.class, length(),\n+            opc, getClass(), maskClass, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -1943,1 +1945,1 @@\n-            opc, getClass(), maskType, float.class, length(),\n+            opc, getClass(), maskType, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -1965,1 +1967,1 @@\n-            opc, getClass(), maskType, float.class, length(),\n+            opc, getClass(), maskType, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2092,1 +2094,1 @@\n-            getClass(), maskType, float.class, length(),\n+            getClass(), maskType, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2109,1 +2111,1 @@\n-            getClass(), float.class, length(),\n+            getClass(), float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2301,1 +2303,1 @@\n-            getClass(), shuffletype, null, float.class, length(),\n+            getClass(), shuffletype, null, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2327,1 +2329,1 @@\n-                   getClass(), shuffletype, masktype, float.class, length(),\n+                   getClass(), shuffletype, masktype, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2354,1 +2356,1 @@\n-                getClass(), shuffletype, null, float.class, length(),\n+                getClass(), shuffletype, null, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2362,1 +2364,1 @@\n-                getClass(), shuffletype, null, float.class, length(),\n+                getClass(), shuffletype, null, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2406,1 +2408,1 @@\n-                                                        float.class, length(), this, m,\n+                                                        float.class, float.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2425,1 +2427,1 @@\n-                                                        float.class, length(), this, m,\n+                                                        float.class, float.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2440,1 +2442,1 @@\n-        return (FloatVector)VectorSupport.selectFromOp(getClass(), null, float.class,\n+        return (FloatVector)VectorSupport.selectFromOp(getClass(), null, float.class, float.class, VECTOR_OPER_TYPE,\n@@ -2460,1 +2462,1 @@\n-        return (FloatVector)VectorSupport.selectFromOp(getClass(), masktype, float.class,\n+        return (FloatVector)VectorSupport.selectFromOp(getClass(), masktype, float.class, float.class, VECTOR_OPER_TYPE,\n@@ -2478,1 +2480,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), float.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), float.class, float.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -2684,1 +2686,1 @@\n-            opc, getClass(), maskClass, float.class, length(),\n+            opc, getClass(), maskClass, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2702,1 +2704,1 @@\n-            opc, getClass(), null, float.class, length(),\n+            opc, getClass(), null, float.class, float.class, VECTOR_OPER_TYPE, length(),\n@@ -2945,1 +2947,1 @@\n-            vectorType, null, float.class, vsp.laneCount(),\n+            vectorType, null, float.class, float.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3128,1 +3130,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3217,1 +3219,1 @@\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3344,1 +3346,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3361,1 +3363,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3394,1 +3396,1 @@\n-            vectorType, maskClass, float.class, vsp.laneCount(),\n+            vectorType, maskClass, float.class, float.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3411,1 +3413,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3427,1 +3429,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3445,1 +3447,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3462,1 +3464,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3491,1 +3493,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3510,1 +3512,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3527,1 +3529,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3699,0 +3701,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return float.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (float.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -3731,1 +3746,1 @@\n-                    vectorType, float.class, laneCount,\n+                    vectorType, float.class, float.class, VECTOR_OPER_TYPE, laneCount,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":51,"deletions":36,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -0,0 +1,1042 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat128Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_128;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat128Vector> VCLASS = Halffloat128Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;\n+\n+    Halffloat128Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat128Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat128Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat128Vector ZERO = new Halffloat128Vector(new short[VLENGTH]);\n+    static final Halffloat128Vector IOTA = new Halffloat128Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return ETYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Vector broadcast(short e) {\n+        return (Halffloat128Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Vector broadcast(long e) {\n+        return (Halffloat128Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat128Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle iotaShuffle() { return Halffloat128Shuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+        return (Halffloat128Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat128Shuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat128Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector vectorFactory(short[] vec) {\n+        return new Halffloat128Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte128Vector asByteVectorRaw() {\n+        return (Byte128Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector uOp(FUnOp f) {\n+        return (Halffloat128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (Halffloat128Vector)\n+            super.uOpTemplate((Halffloat128Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector bOp(Vector<Float16> v, FBinOp f) {\n+        return (Halffloat128Vector) super.bOpTemplate((Halffloat128Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (Halffloat128Vector)\n+            super.bOpTemplate((Halffloat128Vector)v, (Halffloat128Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (Halffloat128Vector)\n+            super.tOpTemplate((Halffloat128Vector)v1, (Halffloat128Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (Halffloat128Vector)\n+            super.tOpTemplate((Halffloat128Vector)v1, (Halffloat128Vector)v2,\n+                              (Halffloat128Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Unary op) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Binary op, Vector<Float16> v) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, v, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, v1, v2, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector addIndex(int scale) {\n+        return (Halffloat128Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Shuffle toShuffle() {\n+        return (Halffloat128Shuffle) toShuffle(vspecies(), false);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask test(Test op) {\n+        return super.testTemplate(Halffloat128Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(Halffloat128Mask.class, op, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, v, (Halffloat128Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.blendTemplate(Halffloat128Mask.class,\n+                                (Halffloat128Vector) v,\n+                                (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector slice(int origin, Vector<Float16> v) {\n+        return (Halffloat128Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector slice(int origin) {\n+        return (Halffloat128Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin, Vector<Float16> w, int part) {\n+        return (Halffloat128Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.unsliceTemplate(Halffloat128Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin) {\n+        return (Halffloat128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Float16> s) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    (Halffloat128Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    Halffloat128Mask.class,\n+                                    (Halffloat128Shuffle) shuffle,\n+                                    (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    (Halffloat128Shuffle) s,\n+                                    (Halffloat128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector compress(VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.compressTemplate(Halffloat128Mask.class,\n+                                   (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector expand(VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.expandTemplate(Halffloat128Mask.class,\n+                                   (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector selectFrom(Vector<Float16> v) {\n+        return (Halffloat128Vector)\n+            super.selectFromTemplate((Halffloat128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.selectFromTemplate((Halffloat128Vector) v,\n+                                     Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector selectFrom(Vector<Float16> v1,\n+                                   Vector<Float16> v2) {\n+        return (Halffloat128Vector)\n+            super.selectFromTemplate((Halffloat128Vector) v1, (Halffloat128Vector) v2);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return bits;\n+    }\n+\n+    @ForceInline\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return vecarr[ix];\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat128Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Halffloat128Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = e;\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat128Mask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat128Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat128Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat128Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat128Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat128Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat128Mask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat128Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat128Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat128Vector toVector() {\n+            return (Halffloat128Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat128Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat128Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat128Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask compress() {\n+            return (Halffloat128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat128Vector.class, Halffloat128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat128Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat128Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat128Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat128Mask.class, short.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Halffloat128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Halffloat128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Halffloat128Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat128Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat128Mask  TRUE_MASK = new Halffloat128Mask(true);\n+        private static final Halffloat128Mask FALSE_MASK = new Halffloat128Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat128Shuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat128Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        Halffloat128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        Halffloat128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat128Shuffle IOTA = new Halffloat128Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Vector toVector() {\n+            return (Halffloat128Vector) toBitsVector().castShape(vspecies(), 0);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        Short128Vector toBitsVector() {\n+            return (Short128Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short128Vector toBitsVector0() {\n+            return ((Short128Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset, bo);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);\n+         }\n+\n+        @Override\n+        @ForceInline\n+        public final Halffloat128Mask laneIsValid() {\n+            return (Halffloat128Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat128Shuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            Halffloat128Shuffle concreteShuffle = (Halffloat128Shuffle) shuffle;\n+            return (Halffloat128Shuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_128))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat128Shuffle wrapIndexes() {\n+            Short128Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short128Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short128Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Halffloat128Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {\n+        return super.fromArray0Template(Halffloat128Mask.class, a, offset, indexMap, mapOffset, (Halffloat128Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromCharArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat128Mask.class, ms, offset, (Halffloat128Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(Halffloat128Mask.class, ms, offset, (Halffloat128Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {\n+        super.intoCharArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat128Vector.java","additions":1042,"deletions":0,"binary":false,"changes":1042,"status":"added"},{"patch":"@@ -0,0 +1,1058 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat256Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_256;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat256Vector> VCLASS = Halffloat256Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;\n+\n+    Halffloat256Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat256Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat256Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat256Vector ZERO = new Halffloat256Vector(new short[VLENGTH]);\n+    static final Halffloat256Vector IOTA = new Halffloat256Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return ETYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Vector broadcast(short e) {\n+        return (Halffloat256Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Vector broadcast(long e) {\n+        return (Halffloat256Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat256Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle iotaShuffle() { return Halffloat256Shuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+        return (Halffloat256Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat256Shuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat256Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector vectorFactory(short[] vec) {\n+        return new Halffloat256Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte256Vector asByteVectorRaw() {\n+        return (Byte256Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector uOp(FUnOp f) {\n+        return (Halffloat256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (Halffloat256Vector)\n+            super.uOpTemplate((Halffloat256Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector bOp(Vector<Float16> v, FBinOp f) {\n+        return (Halffloat256Vector) super.bOpTemplate((Halffloat256Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (Halffloat256Vector)\n+            super.bOpTemplate((Halffloat256Vector)v, (Halffloat256Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (Halffloat256Vector)\n+            super.tOpTemplate((Halffloat256Vector)v1, (Halffloat256Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (Halffloat256Vector)\n+            super.tOpTemplate((Halffloat256Vector)v1, (Halffloat256Vector)v2,\n+                              (Halffloat256Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Unary op) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Binary op, Vector<Float16> v) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, v, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, v1, v2, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector addIndex(int scale) {\n+        return (Halffloat256Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Shuffle toShuffle() {\n+        return (Halffloat256Shuffle) toShuffle(vspecies(), false);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask test(Test op) {\n+        return super.testTemplate(Halffloat256Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(Halffloat256Mask.class, op, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, v, (Halffloat256Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.blendTemplate(Halffloat256Mask.class,\n+                                (Halffloat256Vector) v,\n+                                (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector slice(int origin, Vector<Float16> v) {\n+        return (Halffloat256Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector slice(int origin) {\n+        return (Halffloat256Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin, Vector<Float16> w, int part) {\n+        return (Halffloat256Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.unsliceTemplate(Halffloat256Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin) {\n+        return (Halffloat256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Float16> s) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    (Halffloat256Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    Halffloat256Mask.class,\n+                                    (Halffloat256Shuffle) shuffle,\n+                                    (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    (Halffloat256Shuffle) s,\n+                                    (Halffloat256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector compress(VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.compressTemplate(Halffloat256Mask.class,\n+                                   (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector expand(VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.expandTemplate(Halffloat256Mask.class,\n+                                   (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector selectFrom(Vector<Float16> v) {\n+        return (Halffloat256Vector)\n+            super.selectFromTemplate((Halffloat256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.selectFromTemplate((Halffloat256Vector) v,\n+                                     Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector selectFrom(Vector<Float16> v1,\n+                                   Vector<Float16> v2) {\n+        return (Halffloat256Vector)\n+            super.selectFromTemplate((Halffloat256Vector) v1, (Halffloat256Vector) v2);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            case 8: bits = laneHelper(8); break;\n+            case 9: bits = laneHelper(9); break;\n+            case 10: bits = laneHelper(10); break;\n+            case 11: bits = laneHelper(11); break;\n+            case 12: bits = laneHelper(12); break;\n+            case 13: bits = laneHelper(13); break;\n+            case 14: bits = laneHelper(14); break;\n+            case 15: bits = laneHelper(15); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return bits;\n+    }\n+\n+    @ForceInline\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return vecarr[ix];\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat256Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            case 8: return withLaneHelper(8, e);\n+            case 9: return withLaneHelper(9, e);\n+            case 10: return withLaneHelper(10, e);\n+            case 11: return withLaneHelper(11, e);\n+            case 12: return withLaneHelper(12, e);\n+            case 13: return withLaneHelper(13, e);\n+            case 14: return withLaneHelper(14, e);\n+            case 15: return withLaneHelper(15, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Halffloat256Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = e;\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat256Mask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat256Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat256Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat256Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat256Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat256Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat256Mask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat256Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat256Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat256Vector toVector() {\n+            return (Halffloat256Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat256Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat256Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat256Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask compress() {\n+            return (Halffloat256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat256Vector.class, Halffloat256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat256Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat256Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat256Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat256Mask.class, short.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Halffloat256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Halffloat256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Halffloat256Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat256Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat256Mask  TRUE_MASK = new Halffloat256Mask(true);\n+        private static final Halffloat256Mask FALSE_MASK = new Halffloat256Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat256Shuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat256Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        Halffloat256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        Halffloat256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat256Shuffle IOTA = new Halffloat256Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Vector toVector() {\n+            return (Halffloat256Vector) toBitsVector().castShape(vspecies(), 0);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        Short256Vector toBitsVector() {\n+            return (Short256Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short256Vector toBitsVector0() {\n+            return ((Short256Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset, bo);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);\n+         }\n+\n+        @Override\n+        @ForceInline\n+        public final Halffloat256Mask laneIsValid() {\n+            return (Halffloat256Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat256Shuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            Halffloat256Shuffle concreteShuffle = (Halffloat256Shuffle) shuffle;\n+            return (Halffloat256Shuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_256))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat256Shuffle wrapIndexes() {\n+            Short256Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short256Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short256Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Halffloat256Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {\n+        return super.fromArray0Template(Halffloat256Mask.class, a, offset, indexMap, mapOffset, (Halffloat256Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromCharArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat256Mask.class, ms, offset, (Halffloat256Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(Halffloat256Mask.class, ms, offset, (Halffloat256Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {\n+        super.intoCharArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat256Vector.java","additions":1058,"deletions":0,"binary":false,"changes":1058,"status":"added"},{"patch":"@@ -0,0 +1,1090 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat512Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_512;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat512Vector> VCLASS = Halffloat512Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;\n+\n+    Halffloat512Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat512Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat512Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat512Vector ZERO = new Halffloat512Vector(new short[VLENGTH]);\n+    static final Halffloat512Vector IOTA = new Halffloat512Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return ETYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Vector broadcast(short e) {\n+        return (Halffloat512Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Vector broadcast(long e) {\n+        return (Halffloat512Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat512Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle iotaShuffle() { return Halffloat512Shuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+        return (Halffloat512Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat512Shuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat512Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector vectorFactory(short[] vec) {\n+        return new Halffloat512Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte512Vector asByteVectorRaw() {\n+        return (Byte512Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector uOp(FUnOp f) {\n+        return (Halffloat512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (Halffloat512Vector)\n+            super.uOpTemplate((Halffloat512Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector bOp(Vector<Float16> v, FBinOp f) {\n+        return (Halffloat512Vector) super.bOpTemplate((Halffloat512Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (Halffloat512Vector)\n+            super.bOpTemplate((Halffloat512Vector)v, (Halffloat512Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (Halffloat512Vector)\n+            super.tOpTemplate((Halffloat512Vector)v1, (Halffloat512Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (Halffloat512Vector)\n+            super.tOpTemplate((Halffloat512Vector)v1, (Halffloat512Vector)v2,\n+                              (Halffloat512Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Unary op) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Binary op, Vector<Float16> v) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, v, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, v1, v2, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector addIndex(int scale) {\n+        return (Halffloat512Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Shuffle toShuffle() {\n+        return (Halffloat512Shuffle) toShuffle(vspecies(), false);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask test(Test op) {\n+        return super.testTemplate(Halffloat512Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(Halffloat512Mask.class, op, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, v, (Halffloat512Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.blendTemplate(Halffloat512Mask.class,\n+                                (Halffloat512Vector) v,\n+                                (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector slice(int origin, Vector<Float16> v) {\n+        return (Halffloat512Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector slice(int origin) {\n+        return (Halffloat512Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin, Vector<Float16> w, int part) {\n+        return (Halffloat512Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.unsliceTemplate(Halffloat512Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin) {\n+        return (Halffloat512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Float16> s) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    (Halffloat512Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    Halffloat512Mask.class,\n+                                    (Halffloat512Shuffle) shuffle,\n+                                    (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    (Halffloat512Shuffle) s,\n+                                    (Halffloat512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector compress(VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.compressTemplate(Halffloat512Mask.class,\n+                                   (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector expand(VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.expandTemplate(Halffloat512Mask.class,\n+                                   (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector selectFrom(Vector<Float16> v) {\n+        return (Halffloat512Vector)\n+            super.selectFromTemplate((Halffloat512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.selectFromTemplate((Halffloat512Vector) v,\n+                                     Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector selectFrom(Vector<Float16> v1,\n+                                   Vector<Float16> v2) {\n+        return (Halffloat512Vector)\n+            super.selectFromTemplate((Halffloat512Vector) v1, (Halffloat512Vector) v2);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            case 8: bits = laneHelper(8); break;\n+            case 9: bits = laneHelper(9); break;\n+            case 10: bits = laneHelper(10); break;\n+            case 11: bits = laneHelper(11); break;\n+            case 12: bits = laneHelper(12); break;\n+            case 13: bits = laneHelper(13); break;\n+            case 14: bits = laneHelper(14); break;\n+            case 15: bits = laneHelper(15); break;\n+            case 16: bits = laneHelper(16); break;\n+            case 17: bits = laneHelper(17); break;\n+            case 18: bits = laneHelper(18); break;\n+            case 19: bits = laneHelper(19); break;\n+            case 20: bits = laneHelper(20); break;\n+            case 21: bits = laneHelper(21); break;\n+            case 22: bits = laneHelper(22); break;\n+            case 23: bits = laneHelper(23); break;\n+            case 24: bits = laneHelper(24); break;\n+            case 25: bits = laneHelper(25); break;\n+            case 26: bits = laneHelper(26); break;\n+            case 27: bits = laneHelper(27); break;\n+            case 28: bits = laneHelper(28); break;\n+            case 29: bits = laneHelper(29); break;\n+            case 30: bits = laneHelper(30); break;\n+            case 31: bits = laneHelper(31); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return bits;\n+    }\n+\n+    @ForceInline\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return vecarr[ix];\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat512Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            case 8: return withLaneHelper(8, e);\n+            case 9: return withLaneHelper(9, e);\n+            case 10: return withLaneHelper(10, e);\n+            case 11: return withLaneHelper(11, e);\n+            case 12: return withLaneHelper(12, e);\n+            case 13: return withLaneHelper(13, e);\n+            case 14: return withLaneHelper(14, e);\n+            case 15: return withLaneHelper(15, e);\n+            case 16: return withLaneHelper(16, e);\n+            case 17: return withLaneHelper(17, e);\n+            case 18: return withLaneHelper(18, e);\n+            case 19: return withLaneHelper(19, e);\n+            case 20: return withLaneHelper(20, e);\n+            case 21: return withLaneHelper(21, e);\n+            case 22: return withLaneHelper(22, e);\n+            case 23: return withLaneHelper(23, e);\n+            case 24: return withLaneHelper(24, e);\n+            case 25: return withLaneHelper(25, e);\n+            case 26: return withLaneHelper(26, e);\n+            case 27: return withLaneHelper(27, e);\n+            case 28: return withLaneHelper(28, e);\n+            case 29: return withLaneHelper(29, e);\n+            case 30: return withLaneHelper(30, e);\n+            case 31: return withLaneHelper(31, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Halffloat512Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = e;\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat512Mask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat512Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat512Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat512Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat512Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat512Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat512Mask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat512Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat512Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat512Vector toVector() {\n+            return (Halffloat512Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat512Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat512Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat512Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask compress() {\n+            return (Halffloat512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat512Vector.class, Halffloat512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat512Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat512Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat512Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat512Mask.class, short.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Halffloat512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Halffloat512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Halffloat512Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat512Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat512Mask  TRUE_MASK = new Halffloat512Mask(true);\n+        private static final Halffloat512Mask FALSE_MASK = new Halffloat512Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat512Shuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat512Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        Halffloat512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        Halffloat512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat512Shuffle IOTA = new Halffloat512Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Vector toVector() {\n+            return (Halffloat512Vector) toBitsVector().castShape(vspecies(), 0);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        Short512Vector toBitsVector() {\n+            return (Short512Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short512Vector toBitsVector0() {\n+            return ((Short512Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset, bo);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);\n+         }\n+\n+        @Override\n+        @ForceInline\n+        public final Halffloat512Mask laneIsValid() {\n+            return (Halffloat512Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat512Shuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            Halffloat512Shuffle concreteShuffle = (Halffloat512Shuffle) shuffle;\n+            return (Halffloat512Shuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_512))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat512Shuffle wrapIndexes() {\n+            Short512Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short512Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short512Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Halffloat512Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {\n+        return super.fromArray0Template(Halffloat512Mask.class, a, offset, indexMap, mapOffset, (Halffloat512Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromCharArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat512Mask.class, ms, offset, (Halffloat512Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(Halffloat512Mask.class, ms, offset, (Halffloat512Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {\n+        super.intoCharArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat512Vector.java","additions":1090,"deletions":0,"binary":false,"changes":1090,"status":"added"},{"patch":"@@ -0,0 +1,1034 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat64Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_64;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat64Vector> VCLASS = Halffloat64Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;\n+\n+    Halffloat64Vector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat64Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat64Vector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final Halffloat64Vector ZERO = new Halffloat64Vector(new short[VLENGTH]);\n+    static final Halffloat64Vector IOTA = new Halffloat64Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return ETYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Vector broadcast(short e) {\n+        return (Halffloat64Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Vector broadcast(long e) {\n+        return (Halffloat64Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat64Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle iotaShuffle() { return Halffloat64Shuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+        return (Halffloat64Shuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle shuffleFromArray(int[] indices, int i) { return new Halffloat64Shuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat64Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector vectorFactory(short[] vec) {\n+        return new Halffloat64Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte64Vector asByteVectorRaw() {\n+        return (Byte64Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector uOp(FUnOp f) {\n+        return (Halffloat64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (Halffloat64Vector)\n+            super.uOpTemplate((Halffloat64Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector bOp(Vector<Float16> v, FBinOp f) {\n+        return (Halffloat64Vector) super.bOpTemplate((Halffloat64Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (Halffloat64Vector)\n+            super.bOpTemplate((Halffloat64Vector)v, (Halffloat64Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (Halffloat64Vector)\n+            super.tOpTemplate((Halffloat64Vector)v1, (Halffloat64Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (Halffloat64Vector)\n+            super.tOpTemplate((Halffloat64Vector)v1, (Halffloat64Vector)v2,\n+                              (Halffloat64Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Unary op) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Binary op, Vector<Float16> v) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, v, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, v1, v2, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector addIndex(int scale) {\n+        return (Halffloat64Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        return (long) super.reduceLanesTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Shuffle toShuffle() {\n+        return (Halffloat64Shuffle) toShuffle(vspecies(), false);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask test(Test op) {\n+        return super.testTemplate(Halffloat64Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(Halffloat64Mask.class, op, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, short s) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, v, (Halffloat64Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.blendTemplate(Halffloat64Mask.class,\n+                                (Halffloat64Vector) v,\n+                                (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector slice(int origin, Vector<Float16> v) {\n+        return (Halffloat64Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector slice(int origin) {\n+        return (Halffloat64Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin, Vector<Float16> w, int part) {\n+        return (Halffloat64Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.unsliceTemplate(Halffloat64Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin) {\n+        return (Halffloat64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Float16> s) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    (Halffloat64Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    Halffloat64Mask.class,\n+                                    (Halffloat64Shuffle) shuffle,\n+                                    (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    (Halffloat64Shuffle) s,\n+                                    (Halffloat64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector compress(VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.compressTemplate(Halffloat64Mask.class,\n+                                   (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector expand(VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.expandTemplate(Halffloat64Mask.class,\n+                                   (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector selectFrom(Vector<Float16> v) {\n+        return (Halffloat64Vector)\n+            super.selectFromTemplate((Halffloat64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.selectFromTemplate((Halffloat64Vector) v,\n+                                     Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector selectFrom(Vector<Float16> v1,\n+                                   Vector<Float16> v2) {\n+        return (Halffloat64Vector)\n+            super.selectFromTemplate((Halffloat64Vector) v1, (Halffloat64Vector) v2);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return bits;\n+    }\n+\n+    @ForceInline\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return vecarr[ix];\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat64Vector withLane(int i, short e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Halffloat64Vector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = e;\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat64Mask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat64Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat64Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat64Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat64Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat64Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat64Mask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat64Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat64Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat64Vector toVector() {\n+            return (Halffloat64Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat64Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat64Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat64Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask compress() {\n+            return (Halffloat64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat64Vector.class, Halffloat64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat64Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat64Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat64Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat64Mask.class, short.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Halffloat64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Halffloat64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Halffloat64Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat64Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat64Mask  TRUE_MASK = new Halffloat64Mask(true);\n+        private static final Halffloat64Mask FALSE_MASK = new Halffloat64Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat64Shuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        Halffloat64Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        Halffloat64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        Halffloat64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat64Shuffle IOTA = new Halffloat64Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Vector toVector() {\n+            return (Halffloat64Vector) toBitsVector().castShape(vspecies(), 0);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        Short64Vector toBitsVector() {\n+            return (Short64Vector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        Short64Vector toBitsVector0() {\n+            return ((Short64Vector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset, bo);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);\n+         }\n+\n+        @Override\n+        @ForceInline\n+        public final Halffloat64Mask laneIsValid() {\n+            return (Halffloat64Mask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat64Shuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            Halffloat64Shuffle concreteShuffle = (Halffloat64Shuffle) shuffle;\n+            return (Halffloat64Shuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_64))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final Halffloat64Shuffle wrapIndexes() {\n+            Short64Vector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (Short64Vector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (Short64Vector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (Halffloat64Shuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {\n+        return super.fromArray0Template(Halffloat64Mask.class, a, offset, indexMap, mapOffset, (Halffloat64Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromCharArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat64Mask.class, ms, offset, (Halffloat64Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(Halffloat64Mask.class, ms, offset, (Halffloat64Mask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {\n+        super.intoCharArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat64Vector.java","additions":1034,"deletions":0,"binary":false,"changes":1034,"status":"added"},{"patch":"@@ -0,0 +1,1027 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class HalffloatMaxVector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_MAX;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<HalffloatMaxVector> VCLASS = HalffloatMaxVector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;\n+\n+    HalffloatMaxVector(short[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as HalffloatMaxVector::new,\n+    \/\/ stored into species.vectorFactory.\n+    HalffloatMaxVector(Object v) {\n+        this((short[]) v);\n+    }\n+\n+    static final HalffloatMaxVector ZERO = new HalffloatMaxVector(new short[VLENGTH]);\n+    static final HalffloatMaxVector IOTA = new HalffloatMaxVector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return ETYPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    short[] vec() {\n+        return (short[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxVector broadcast(short e) {\n+        return (HalffloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxVector broadcast(long e) {\n+        return (HalffloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxMask maskFromArray(boolean[] bits) {\n+        return new HalffloatMaxMask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle iotaShuffle() { return HalffloatMaxShuffle.IOTA; }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+        return (HalffloatMaxShuffle) iotaShuffleTemplate((short) start, (short) step, wrap);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle shuffleFromArray(int[] indices, int i) { return new HalffloatMaxShuffle(indices, i); }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new HalffloatMaxShuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector vectorFactory(short[] vec) {\n+        return new HalffloatMaxVector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector asByteVectorRaw() {\n+        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector uOp(FUnOp f) {\n+        return (HalffloatMaxVector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (HalffloatMaxVector)\n+            super.uOpTemplate((HalffloatMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector bOp(Vector<Float16> v, FBinOp f) {\n+        return (HalffloatMaxVector) super.bOpTemplate((HalffloatMaxVector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (HalffloatMaxVector)\n+            super.bOpTemplate((HalffloatMaxVector)v, (HalffloatMaxMask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (HalffloatMaxVector)\n+            super.tOpTemplate((HalffloatMaxVector)v1, (HalffloatMaxVector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (HalffloatMaxVector)\n+            super.tOpTemplate((HalffloatMaxVector)v1, (HalffloatMaxVector)v2,\n+                              (HalffloatMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    short rOp(short v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Unary op) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Binary op, Vector<Float16> v) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, v, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, v1, v2, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector addIndex(int scale) {\n+        return (HalffloatMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final short reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        return (long) super.reduceLanesTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxShuffle toShuffle() {\n+        return (HalffloatMaxShuffle) toShuffle(vspecies(), false);\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask test(Test op) {\n+        return super.testTemplate(HalffloatMaxMask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(HalffloatMaxMask.class, op, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, short s) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, long s) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, v, (HalffloatMaxMask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.blendTemplate(HalffloatMaxMask.class,\n+                                (HalffloatMaxVector) v,\n+                                (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector slice(int origin, Vector<Float16> v) {\n+        return (HalffloatMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector slice(int origin) {\n+        return (HalffloatMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin, Vector<Float16> w, int part) {\n+        return (HalffloatMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.unsliceTemplate(HalffloatMaxMask.class,\n+                                  origin, w, part,\n+                                  (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin) {\n+        return (HalffloatMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Float16> s) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    (HalffloatMaxShuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    HalffloatMaxMask.class,\n+                                    (HalffloatMaxShuffle) shuffle,\n+                                    (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    (HalffloatMaxShuffle) s,\n+                                    (HalffloatMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector compress(VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.compressTemplate(HalffloatMaxMask.class,\n+                                   (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector expand(VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.expandTemplate(HalffloatMaxMask.class,\n+                                   (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector selectFrom(Vector<Float16> v) {\n+        return (HalffloatMaxVector)\n+            super.selectFromTemplate((HalffloatMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.selectFromTemplate((HalffloatMaxVector) v,\n+                                     HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector selectFrom(Vector<Float16> v1,\n+                                   Vector<Float16> v2) {\n+        return (HalffloatMaxVector)\n+            super.selectFromTemplate((HalffloatMaxVector) v1, (HalffloatMaxVector) v2);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public short lane(int i) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        short bits = laneHelper(i);\n+        return bits;\n+    }\n+\n+    @ForceInline\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     short[] vecarr = vec.vec();\n+                     return vecarr[ix];\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public HalffloatMaxVector withLane(int i, short e) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return withLaneHelper(i, e);\n+    }\n+\n+    @ForceInline\n+    public HalffloatMaxVector withLaneHelper(int i, short e) {\n+        return VectorSupport.insert(\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                this, i, (long)e,\n+                                (v, ix, bits) -> {\n+                                    short[] res = v.vec().clone();\n+                                    res[ix] = e;\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class HalffloatMaxMask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        HalffloatMaxMask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        HalffloatMaxMask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        HalffloatMaxMask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        HalffloatMaxMask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new HalffloatMaxMask(res);\n+        }\n+\n+        @Override\n+        HalffloatMaxMask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((HalffloatMaxMask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new HalffloatMaxMask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        HalffloatMaxVector toVector() {\n+            return (HalffloatMaxVector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        HalffloatMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (HalffloatMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                HalffloatMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n+                (o, l) -> (HalffloatMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask compress() {\n+            return (HalffloatMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                HalffloatMaxVector.class, HalffloatMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                Float16.float16ToShortBits(Float16.valueOf(m1.trueCount()))));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, HalffloatMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, HalffloatMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, HalffloatMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, HalffloatMaxMask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, HalffloatMaxMask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, HalffloatMaxMask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, HalffloatMaxMask.class, short.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(HalffloatMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, HalffloatMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((HalffloatMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, HalffloatMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((HalffloatMaxMask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static HalffloatMaxMask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(HalffloatMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final HalffloatMaxMask  TRUE_MASK = new HalffloatMaxMask(true);\n+        private static final HalffloatMaxMask FALSE_MASK = new HalffloatMaxMask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class HalffloatMaxShuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n+\n+        HalffloatMaxShuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n+        }\n+\n+        HalffloatMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n+        }\n+\n+        HalffloatMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n+        }\n+\n+        short[] indices() {\n+            return (short[])getPayload();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final HalffloatMaxShuffle IOTA = new HalffloatMaxShuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxVector toVector() {\n+            return (HalffloatMaxVector) toBitsVector().castShape(vspecies(), 0);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        ShortMaxVector toBitsVector() {\n+            return (ShortMaxVector) super.toBitsVectorTemplate();\n+        }\n+\n+        @Override\n+        ShortMaxVector toBitsVector0() {\n+            return ((ShortMaxVector) vspecies().asIntegral().dummyVector()).vectorFactory(indices());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset, bo);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoMemorySegment(ms, offset + species.vectorByteSize(), bo);\n+         }\n+\n+        @Override\n+        @ForceInline\n+        public final HalffloatMaxMask laneIsValid() {\n+            return (HalffloatMaxMask) toBitsVector().compare(VectorOperators.GE, 0)\n+                    .cast(vspecies());\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final HalffloatMaxShuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            HalffloatMaxShuffle concreteShuffle = (HalffloatMaxShuffle) shuffle;\n+            return (HalffloatMaxShuffle) toBitsVector().rearrange(concreteShuffle.cast(ShortVector.SPECIES_MAX))\n+                    .toShuffle(vspecies(), false);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final HalffloatMaxShuffle wrapIndexes() {\n+            ShortMaxVector v = toBitsVector();\n+            if ((length() & (length() - 1)) == 0) {\n+                v = (ShortMaxVector) v.lanewise(VectorOperators.AND, length() - 1);\n+            } else {\n+                v = (ShortMaxVector) v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                            v.compare(VectorOperators.LT, 0));\n+            }\n+            return (HalffloatMaxShuffle) v.toShuffle(vspecies(), false);\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(short[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float16> m) {\n+        return super.fromArray0Template(HalffloatMaxMask.class, a, offset, indexMap, mapOffset, (HalffloatMaxMask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromCharArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(HalffloatMaxMask.class, ms, offset, (HalffloatMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(short[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(HalffloatMaxMask.class, ms, offset, (HalffloatMaxMask) m);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m) {\n+        super.intoCharArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);\n+    }\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatMaxVector.java","additions":1027,"deletions":0,"binary":false,"changes":1027,"status":"added"},{"patch":"@@ -0,0 +1,4361 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+import static jdk.incubator.vector.VectorIntrinsics.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+import jdk.incubator.vector.Float16;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+\/**\n+ * A specialized {@link Vector} representing an ordered immutable sequence of\n+ * {@code short} values.\n+ *\/\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+public abstract class HalffloatVector extends AbstractVector<Float16> {\n+\n+    HalffloatVector(short[] vec) {\n+        super(vec);\n+    }\n+\n+    static final int FORBID_OPCODE_KIND = VO_NOFP;\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_FP16;\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+\n+    @ForceInline\n+    static int opCode(Operator op) {\n+        return VectorOperators.opCode(op, VO_OPCODE_VALID, FORBID_OPCODE_KIND);\n+    }\n+    @ForceInline\n+    static int opCode(Operator op, int requireKind) {\n+        requireKind |= VO_OPCODE_VALID;\n+        return VectorOperators.opCode(op, requireKind, FORBID_OPCODE_KIND);\n+    }\n+    @ForceInline\n+    static boolean opKind(Operator op, int bit) {\n+        return VectorOperators.opKind(op, bit);\n+    }\n+\n+    \/\/ Virtualized factories and operators,\n+    \/\/ coded with portable definitions.\n+    \/\/ These are all @ForceInline in case\n+    \/\/ they need to be used performantly.\n+    \/\/ The various shape-specific subclasses\n+    \/\/ also specialize them by wrapping\n+    \/\/ them in a call like this:\n+    \/\/    return (Byte128Vector)\n+    \/\/       super.bOp((Byte128Vector) o);\n+    \/\/ The purpose of that is to forcibly inline\n+    \/\/ the generic definition from this file\n+    \/\/ into a sharply-typed and size-specific\n+    \/\/ wrapper in the subclass file, so that\n+    \/\/ the JIT can specialize the code.\n+    \/\/ The code is only inlined and expanded\n+    \/\/ if it gets hot.  Think of it as a cheap\n+    \/\/ and lazy version of C++ templates.\n+\n+    \/\/ Virtualized getter\n+\n+    \/*package-private*\/\n+    abstract short[] vec();\n+\n+    \/\/ Virtualized constructors\n+\n+    \/**\n+     * Build a vector directly using my own constructor.\n+     * It is an error if the array is aliased elsewhere.\n+     *\/\n+    \/*package-private*\/\n+    abstract HalffloatVector vectorFactory(short[] vec);\n+\n+    \/**\n+     * Build a mask directly using my species.\n+     * It is an error if the array is aliased elsewhere.\n+     *\/\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    AbstractMask<Float16> maskFactory(boolean[] bits) {\n+        return vspecies().maskFactory(bits);\n+    }\n+\n+    \/\/ Constant loader (takes dummy as vector arg)\n+    interface FVOp {\n+        short apply(int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    HalffloatVector vOp(FVOp f) {\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    @ForceInline\n+    final\n+    HalffloatVector vOp(VectorMask<Float16> m, FVOp f) {\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Unary operator\n+\n+    \/*package-private*\/\n+    interface FUnOp {\n+        short apply(int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector uOp(FUnOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector uOpTemplate(FUnOp f) {\n+        short[] vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector uOp(VectorMask<Float16> m,\n+                             FUnOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector uOpTemplate(VectorMask<Float16> m,\n+                                     FUnOp f) {\n+        if (m == null) {\n+            return uOpTemplate(f);\n+        }\n+        short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Binary operator\n+\n+    \/*package-private*\/\n+    interface FBinOp {\n+        short apply(int i, short a, short b);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector bOp(Vector<Float16> o,\n+                             FBinOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector bOpTemplate(Vector<Float16> o,\n+                                     FBinOp f) {\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o).vec();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector bOp(Vector<Float16> o,\n+                             VectorMask<Float16> m,\n+                             FBinOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector bOpTemplate(Vector<Float16> o,\n+                                     VectorMask<Float16> m,\n+                                     FBinOp f) {\n+        if (m == null) {\n+            return bOpTemplate(o, f);\n+        }\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o).vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    \/*package-private*\/\n+    interface FTriOp {\n+        short apply(int i, short a, short b, short c);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector tOp(Vector<Float16> o1,\n+                             Vector<Float16> o2,\n+                             FTriOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector tOpTemplate(Vector<Float16> o1,\n+                                     Vector<Float16> o2,\n+                                     FTriOp f) {\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o1).vec();\n+        short[] vec3 = ((HalffloatVector)o2).vec();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector tOp(Vector<Float16> o1,\n+                             Vector<Float16> o2,\n+                             VectorMask<Float16> m,\n+                             FTriOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector tOpTemplate(Vector<Float16> o1,\n+                                     Vector<Float16> o2,\n+                                     VectorMask<Float16> m,\n+                                     FTriOp f) {\n+        if (m == null) {\n+            return tOpTemplate(o1, o2, f);\n+        }\n+        short[] res = new short[length()];\n+        short[] vec1 = this.vec();\n+        short[] vec2 = ((HalffloatVector)o1).vec();\n+        short[] vec3 = ((HalffloatVector)o2).vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Reduction operator\n+\n+    \/*package-private*\/\n+    abstract\n+    short rOp(short v, VectorMask<Float16> m, FBinOp f);\n+\n+    @ForceInline\n+    final\n+    short rOpTemplate(short v, VectorMask<Float16> m, FBinOp f) {\n+        if (m == null) {\n+            return rOpTemplate(v, f);\n+        }\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        }\n+        return v;\n+    }\n+\n+    @ForceInline\n+    final\n+    short rOpTemplate(short v, FBinOp f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            v = f.apply(i, v, vec[i]);\n+        }\n+        return v;\n+    }\n+\n+    \/\/ Memory reference\n+\n+    \/*package-private*\/\n+    interface FLdOp<M> {\n+        short apply(M memory, int offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> HalffloatVector ldOp(M memory, int offset,\n+                                  FLdOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> HalffloatVector ldOp(M memory, int offset,\n+                                  VectorMask<Float16> m,\n+                                  FLdOp<M> f) {\n+        \/\/short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    interface FLdLongOp {\n+        short apply(MemorySegment memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n+        \/\/dummy; no vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                  VectorMask<Float16> m,\n+                                  FLdLongOp f) {\n+        \/\/short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static short memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 2L);\n+    }\n+\n+    interface FStOp<M> {\n+        void apply(M memory, int offset, int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stOp(M memory, int offset,\n+                  FStOp<M> f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stOp(M memory, int offset,\n+                  VectorMask<Float16> m,\n+                  FStOp<M> f) {\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  VectorMask<Float16> m,\n+                  FStLongOp f) {\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, short e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 2L, e);\n+    }\n+\n+    \/\/ Binary test\n+\n+    \/*package-private*\/\n+    interface FBinTest {\n+        boolean apply(int cond, int i, short a, short b);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    AbstractMask<Float16> bTest(int cond,\n+                                  Vector<Float16> o,\n+                                  FBinTest f) {\n+        short[] vec1 = vec();\n+        short[] vec2 = ((HalffloatVector)o).vec();\n+        boolean[] bits = new boolean[length()];\n+        for (int i = 0; i < length(); i++){\n+            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        }\n+        return maskFactory(bits);\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    abstract HalffloatSpecies vspecies();\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static long toBits(short e) {\n+        return e;\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static short fromBits(long bits) {\n+        return Float16.float16ToRawShortBits(Float16.shortBitsToFloat16((short)bits));\n+    }\n+\n+    static HalffloatVector expandHelper(Vector<Float16> v, VectorMask<Float16> m) {\n+        VectorSpecies<Float16> vsp = m.vectorSpecies();\n+        HalffloatVector r  = (HalffloatVector) vsp.zero();\n+        HalffloatVector vi = (HalffloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static HalffloatVector compressHelper(Vector<Float16> v, VectorMask<Float16> m) {\n+        VectorSpecies<Float16> vsp = m.vectorSpecies();\n+        HalffloatVector r  = (HalffloatVector) vsp.zero();\n+        HalffloatVector vi = (HalffloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static HalffloatVector selectFromTwoVectorHelper(Vector<Float16> indexes, Vector<Float16> src1, Vector<Float16> src2) {\n+        int vlen = indexes.length();\n+        short[] res = new short[vlen];\n+        short[] vecPayload1 = ((HalffloatVector)indexes).vec();\n+        short[] vecPayload2 = ((HalffloatVector)src1).vec();\n+        short[] vecPayload3 = ((HalffloatVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((HalffloatVector)src1).vectorFactory(res);\n+    }\n+\n+    \/\/ Static factories (other than memory operations)\n+\n+    \/\/ Note: A surprising behavior in javadoc\n+    \/\/ sometimes makes a lone \/** {@inheritDoc} *\/\n+    \/\/ comment drop the method altogether,\n+    \/\/ apparently if the method mentions a\n+    \/\/ parameter or return type of Vector<Float16>\n+    \/\/ instead of Vector<E> as originally specified.\n+    \/\/ Adding an empty HTML fragment appears to\n+    \/\/ nudge javadoc into providing the desired\n+    \/\/ inherited documentation.  We use the HTML\n+    \/\/ comment <!--workaround--> for this.\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * zero, the default primitive value.\n+     *\n+     * @param species species of the desired zero vector\n+     * @return a zero vector\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector zero(VectorSpecies<Float16> species) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, Float16.class, VECTOR_OPER_TYPE, species.length(),\n+                        toBits((short) 0), MODE_BROADCAST, vsp,\n+                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+    }\n+\n+    \/**\n+     * Returns a vector of the same species as this one\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * The contents of the current vector are discarded;\n+     * only the species is relevant to this operation.\n+     *\n+     * <p> This method returns the value of this expression:\n+     * {@code HalffloatVector.broadcast(this.species(), e)}.\n+     *\n+     * @apiNote\n+     * Unlike the similar method named {@code broadcast()}\n+     * in the supertype {@code Vector}, this method does not\n+     * need to validate its argument, and cannot throw\n+     * {@code IllegalArgumentException}.  This method is\n+     * therefore preferable to the supertype method.\n+     *\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @see #broadcast(VectorSpecies,long)\n+     * @see Vector#broadcast(long)\n+     * @see VectorSpecies#broadcast(long)\n+     *\/\n+    public abstract HalffloatVector broadcast(short e);\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * @param species species of the desired vector\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @see #broadcast(long)\n+     * @see Vector#broadcast(long)\n+     * @see VectorSpecies#broadcast(long)\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector broadcast(VectorSpecies<Float16> species, short e) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector broadcastTemplate(short e) {\n+        HalffloatSpecies vsp = vspecies();\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #broadcast(short) the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.broadcast((short)e)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @Override\n+    public abstract HalffloatVector broadcast(long e);\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * The {@code long} value must be accurately representable\n+     * by the {@code ETYPE} of the vector species, so that\n+     * {@code e==(long)(ETYPE)e}.\n+     *\n+     * @param species species of the desired vector\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @throws IllegalArgumentException\n+     *         if the given {@code long} value cannot\n+     *         be represented by the vector's {@code ETYPE}\n+     * @see #broadcast(VectorSpecies,short)\n+     * @see VectorSpecies#checkValue(long)\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector broadcast(VectorSpecies<Float16> species, long e) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector broadcastTemplate(long e) {\n+        return vspecies().broadcast(e);\n+    }\n+\n+    \/\/ Unary lanewise support\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Unary op);\n+\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Unary op) {\n+        if (opKind(op, VO_SPECIAL)) {\n+            if (op == ZOMO) {\n+                return blend(broadcast(-1), compare(NE, 0));\n+            }\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return unaryMathOp(op);\n+            }\n+        }\n+        int opc = opCode(op);\n+        return VectorSupport.unaryOp(\n+            opc, getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+            this, null,\n+            UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Unary op,\n+                                  VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Unary op,\n+                                          Class<? extends VectorMask<Float16>> maskClass,\n+                                          VectorMask<Float16> m) {\n+        m.check(maskClass, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            if (op == ZOMO) {\n+                return blend(broadcast(-1), compare(NE, 0, m));\n+            }\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return blend(unaryMathOp(op), m);\n+            }\n+        }\n+        int opc = opCode(op);\n+        return VectorSupport.unaryOp(\n+            opc, getClass(), maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+            this, m,\n+            UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));\n+    }\n+\n+    @ForceInline\n+    final\n+    HalffloatVector unaryMathOp(VectorOperators.Unary op) {\n+        return VectorMathLibrary.unaryMathOp(op, opCode(op), species(), HalffloatVector::unaryOperations,\n+                                             this);\n+    }\n+\n+    private static final\n+    ImplCache<Unary, UnaryOperation<HalffloatVector, VectorMask<Float16>>>\n+        UN_IMPL = new ImplCache<>(Unary.class, HalffloatVector.class);\n+\n+    private static UnaryOperation<HalffloatVector, VectorMask<Float16>> unaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_NEG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) -a);\n+            case VECTOR_OP_ABS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Math.abs(a));\n+            case VECTOR_OP_SIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.sin(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_COS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.cos(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_TAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.tan(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_ASIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.asin(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_ACOS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.acos(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_ATAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.atan(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_EXP: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.exp(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_LOG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.log(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_LOG10: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.log10(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_SQRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.sqrt(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_CBRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.cbrt(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_SINH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.sinh(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_COSH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.cosh(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_TANH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.tanh(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_EXPM1: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.expm1(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_LOG1P: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.log1p(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            default: return null;\n+        }\n+    }\n+\n+    \/\/ Binary lanewise support\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  Vector<Float16> v);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Vector<Float16> v) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                VectorMask<Short> mask\n+                    = this.viewAsIntegralLanes().compare(EQ, (short) 0);\n+                return this.blend(that, mask.cast(vspecies()));\n+            }\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return binaryMathOp(op, that);\n+            }\n+        }\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryOp(\n+            opc, getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+            this, that, null,\n+            BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  Vector<Float16> v,\n+                                  VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Float16>> maskClass,\n+                                          Vector<Float16> v, VectorMask<Float16> m) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        m.check(maskClass, this);\n+\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                ShortVector bits = this.viewAsIntegralLanes();\n+                VectorMask<Short> mask\n+                    = bits.compare(EQ, (short) 0, m.cast(bits.vspecies()));\n+                return this.blend(that, mask.cast(vspecies()));\n+            }\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return this.blend(binaryMathOp(op, that), m);\n+            }\n+\n+        }\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryOp(\n+            opc, getClass(), maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+            this, that, m,\n+            BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));\n+    }\n+\n+    @ForceInline\n+    final\n+    HalffloatVector binaryMathOp(VectorOperators.Binary op, HalffloatVector that) {\n+        return VectorMathLibrary.binaryMathOp(op, opCode(op), species(), HalffloatVector::binaryOperations,\n+                                              this, that);\n+    }\n+\n+    private static final\n+    ImplCache<Binary, BinaryOperation<HalffloatVector, VectorMask<Float16>>>\n+        BIN_IMPL = new ImplCache<>(Binary.class, HalffloatVector.class);\n+\n+    private static BinaryOperation<HalffloatVector, VectorMask<Float16>> binaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.subtract(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.multiply(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.divide(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.max(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.min(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.atan2(Float16.shortBitsToFloat16(a).floatValue(), Float16.shortBitsToFloat16(b).floatValue()))));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.pow(Float16.shortBitsToFloat16(a).floatValue(), Float16.shortBitsToFloat16(b).floatValue()))));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.hypot(Float16.shortBitsToFloat16(a).floatValue(), Float16.shortBitsToFloat16(b).floatValue()))));\n+            default: return null;\n+        }\n+    }\n+\n+    \/\/ FIXME: Maybe all of the public final methods in this file (the\n+    \/\/ simple ones that just call lanewise) should be pushed down to\n+    \/\/ the X-VectorBits template.  They can't optimize properly at\n+    \/\/ this level, and must rely on inlining.  Does it work?\n+    \/\/ (If it works, of course keep the code here.)\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the value of a broadcast scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e))}.\n+     *\n+     * @param op the operation used to process lane values\n+     * @param e the input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the two input vectors\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  short e) {\n+        return lanewise(op, broadcast(e));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the value of a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e), m)}.\n+     *\n+     * @param op the operation used to process lane values\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Binary,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  short e,\n+                                  VectorMask<Float16> m) {\n+        return lanewise(op, broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #lanewise(VectorOperators.Binary,short)\n+     * the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.lanewise(op,(short)e)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  long e) {\n+        short e1 = (short) e;\n+        if ((long)e1 != e) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #lanewise(VectorOperators.Binary,short,VectorMask)\n+     * the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.lanewise(op,(short)e,m)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  long e, VectorMask<Float16> m) {\n+        short e1 = (short) e;\n+        if ((long)e1 != e) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1, m);\n+    }\n+\n+\n+    \/\/ Ternary lanewise support\n+\n+    \/\/ Ternary operators come in eight variations:\n+    \/\/   lanewise(op, [broadcast(e1)|v1], [broadcast(e2)|v2])\n+    \/\/   lanewise(op, [broadcast(e1)|v1], [broadcast(e2)|v2], mask)\n+\n+    \/\/ It is annoying to support all of these variations of masking\n+    \/\/ and broadcast, but it would be more surprising not to continue\n+    \/\/ the obvious pattern started by unary and binary.\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,short)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Ternary op,\n+                                                  Vector<Float16> v1,\n+                                                  Vector<Float16> v2);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,\n+                                          Vector<Float16> v1,\n+                                          Vector<Float16> v2) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        HalffloatVector tother = (HalffloatVector) v2;\n+        \/\/ It's a word: https:\/\/www.dictionary.com\/browse\/tother\n+        \/\/ See also Chapter 11 of Dickens, Our Mutual Friend:\n+        \/\/ \"Totherest Governor,\" replied Mr Riderhood...\n+        that.check(this);\n+        tother.check(this);\n+        int opc = opCode(op);\n+        return VectorSupport.ternaryOp(\n+            opc, getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+            this, that, tother, null,\n+            TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Ternary op,\n+                                  Vector<Float16> v1,\n+                                  Vector<Float16> v2,\n+                                  VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,\n+                                          Class<? extends VectorMask<Float16>> maskClass,\n+                                          Vector<Float16> v1,\n+                                          Vector<Float16> v2,\n+                                          VectorMask<Float16> m) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        HalffloatVector tother = (HalffloatVector) v2;\n+        \/\/ It's a word: https:\/\/www.dictionary.com\/browse\/tother\n+        \/\/ See also Chapter 11 of Dickens, Our Mutual Friend:\n+        \/\/ \"Totherest Governor,\" replied Mr Riderhood...\n+        that.check(this);\n+        tother.check(this);\n+        m.check(maskClass, this);\n+\n+        int opc = opCode(op);\n+        return VectorSupport.ternaryOp(\n+            opc, getClass(), maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+            this, that, tother, m,\n+            TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));\n+    }\n+\n+    private static final\n+    ImplCache<Ternary, TernaryOperation<HalffloatVector, VectorMask<Float16>>>\n+        TERN_IMPL = new ImplCache<>(Ternary.class, HalffloatVector.class);\n+\n+    private static TernaryOperation<HalffloatVector, VectorMask<Float16>> ternaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) ->\n+                                        Float16.float16ToRawShortBits(Float16.fma(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b), Float16.shortBitsToFloat16(c))));\n+            default: return null;\n+        }\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of two broadcast scalars.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), this.broadcast(e2))}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the first input scalar\n+     * @param e2 the second input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalars\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,e2)\n+                                  short e1,\n+                                  short e2) {\n+        return lanewise(op, broadcast(e1), broadcast(e2));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of two broadcast scalars,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), this.broadcast(e2), m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the first input scalar\n+     * @param e2 the second input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalars\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,e2,m)\n+                                  short e1,\n+                                  short e2,\n+                                  VectorMask<Float16> m) {\n+        return lanewise(op, broadcast(e1), broadcast(e2), m);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, v1, this.broadcast(e2))}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param v1 the other input vector\n+     * @param e2 the input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,short,short)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,v1,e2)\n+                                  Vector<Float16> v1,\n+                                  short e2) {\n+        return lanewise(op, v1, broadcast(e2));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, v1, this.broadcast(e2), m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param v1 the other input vector\n+     * @param e2 the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,v1,e2,m)\n+                                  Vector<Float16> v1,\n+                                  short e2,\n+                                  VectorMask<Float16> m) {\n+        return lanewise(op, v1, broadcast(e2), m);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), v2)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the input scalar\n+     * @param v2 the other input vector\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,v2)\n+                                  short e1,\n+                                  Vector<Float16> v2) {\n+        return lanewise(op, broadcast(e1), v2);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), v2, m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the input scalar\n+     * @param v2 the other input vector\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,short,Vector)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,v2,m)\n+                                  short e1,\n+                                  Vector<Float16> v2,\n+                                  VectorMask<Float16> m) {\n+        return lanewise(op, broadcast(e1), v2, m);\n+    }\n+\n+    \/\/ (Thus endeth the Great and Mighty Ternary Ogdoad.)\n+    \/\/ https:\/\/en.wikipedia.org\/wiki\/Ogdoad\n+\n+    \/\/\/ FULL-SERVICE BINARY METHODS: ADD, SUB, MUL, DIV\n+    \/\/\n+    \/\/ These include masked and non-masked versions.\n+    \/\/ This subclass adds broadcast (masked or not).\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #add(short)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector add(Vector<Float16> v) {\n+        return lanewise(ADD, v);\n+    }\n+\n+    \/**\n+     * Adds this vector to the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive addition operation ({@code +}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#ADD\n+     *    ADD}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of adding each lane of this vector to the scalar\n+     * @see #add(Vector)\n+     * @see #broadcast(short)\n+     * @see #add(short,VectorMask)\n+     * @see VectorOperators#ADD\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector add(short e) {\n+        return lanewise(ADD, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #add(short,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector add(Vector<Float16> v,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(ADD, v, m);\n+    }\n+\n+    \/**\n+     * Adds this vector to the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive addition operation ({@code +}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#ADD\n+     *    ADD}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of adding each lane of this vector to the scalar\n+     * @see #add(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #add(short)\n+     * @see VectorOperators#ADD\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector add(short e,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(ADD, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #sub(short)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector sub(Vector<Float16> v) {\n+        return lanewise(SUB, v);\n+    }\n+\n+    \/**\n+     * Subtracts an input scalar from this vector.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive subtraction operation ({@code -}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#SUB\n+     *    SUB}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of subtracting the scalar from each lane of this vector\n+     * @see #sub(Vector)\n+     * @see #broadcast(short)\n+     * @see #sub(short,VectorMask)\n+     * @see VectorOperators#SUB\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sub(short e) {\n+        return lanewise(SUB, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #sub(short,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector sub(Vector<Float16> v,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(SUB, v, m);\n+    }\n+\n+    \/**\n+     * Subtracts an input scalar from this vector\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive subtraction operation ({@code -}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#SUB\n+     *    SUB}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of subtracting the scalar from each lane of this vector\n+     * @see #sub(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #sub(short)\n+     * @see VectorOperators#SUB\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sub(short e,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(SUB, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #mul(short)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector mul(Vector<Float16> v) {\n+        return lanewise(MUL, v);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive multiplication operation ({@code *}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#MUL\n+     *    MUL}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #mul(Vector)\n+     * @see #broadcast(short)\n+     * @see #mul(short,VectorMask)\n+     * @see VectorOperators#MUL\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector mul(short e) {\n+        return lanewise(MUL, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #mul(short,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector mul(Vector<Float16> v,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(MUL, v, m);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive multiplication operation ({@code *}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#MUL\n+     *    MUL}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of muling each lane of this vector to the scalar\n+     * @see #mul(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #mul(short)\n+     * @see VectorOperators#MUL\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector mul(short e,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(MUL, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector div(Vector<Float16> v) {\n+        return lanewise(DIV, v);\n+    }\n+\n+    \/**\n+     * Divides this vector by the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive division operation ({@code \/}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#DIV\n+     *    DIV}{@code , e)}.\n+     *\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\n+     * @param e the input scalar\n+     * @return the result of dividing each lane of this vector by the scalar\n+     * @see #div(Vector)\n+     * @see #broadcast(short)\n+     * @see #div(short,VectorMask)\n+     * @see VectorOperators#DIV\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector div(short e) {\n+        return lanewise(DIV, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #div(short,VectorMask)\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector div(Vector<Float16> v,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(DIV, v, m);\n+    }\n+\n+    \/**\n+     * Divides this vector by the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive division operation ({@code \/}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#DIV\n+     *    DIV}{@code , s, m)}.\n+     *\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of dividing each lane of this vector by the scalar\n+     * @see #div(Vector,VectorMask)\n+     * @see #broadcast(short)\n+     * @see #div(short)\n+     * @see VectorOperators#DIV\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,short)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector div(short e,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(DIV, e, m);\n+    }\n+\n+    \/\/\/ END OF FULL-SERVICE BINARY METHODS\n+\n+    \/\/\/ SECOND-TIER BINARY METHODS\n+    \/\/\n+    \/\/ There are no masked versions.\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector min(Vector<Float16> v) {\n+        return lanewise(MIN, v);\n+    }\n+\n+    \/\/ FIXME:  \"broadcast of an input scalar\" is really wordy.  Reduce?\n+    \/**\n+     * Computes the smaller of this vector and the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies the\n+     * operation {@code Math.min()} to each pair of\n+     * corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#MIN\n+     *    MIN}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #min(Vector)\n+     * @see #broadcast(short)\n+     * @see VectorOperators#MIN\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector min(short e) {\n+        return lanewise(MIN, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector max(Vector<Float16> v) {\n+        return lanewise(MAX, v);\n+    }\n+\n+    \/**\n+     * Computes the larger of this vector and the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies the\n+     * operation {@code Math.max()} to each pair of\n+     * corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,short)\n+     *    lanewise}{@code (}{@link VectorOperators#MAX\n+     *    MAX}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #max(Vector)\n+     * @see #broadcast(short)\n+     * @see VectorOperators#MAX\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector max(short e) {\n+        return lanewise(MAX, e);\n+    }\n+\n+\n+    \/\/ common FP operator: pow\n+    \/**\n+     * Raises this vector to the power of a second input vector.\n+     *\n+     * This is a lane-wise binary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#pow Math.pow(a,b)}\n+     * to each pair of corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#POW\n+     *    POW}{@code , b)}.\n+     *\n+     * <p>\n+     * This is not a full-service named operation like\n+     * {@link #add(Vector) add}.  A masked version of\n+     * this operation is not directly available\n+     * but may be obtained via the masked version of\n+     * {@code lanewise}.\n+     *\n+     * @param b a vector exponent by which to raise this vector\n+     * @return the {@code b}-th power of this vector\n+     * @see #pow(short)\n+     * @see VectorOperators#POW\n+     * @see #lanewise(VectorOperators.Binary,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector pow(Vector<Float16> b) {\n+        return lanewise(POW, b);\n+    }\n+\n+    \/**\n+     * Raises this vector to a scalar power.\n+     *\n+     * This is a lane-wise binary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#pow Math.pow(a,b)}\n+     * to each pair of corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#POW\n+     *    POW}{@code , b)}.\n+     *\n+     * @param b a scalar exponent by which to raise this vector\n+     * @return the {@code b}-th power of this vector\n+     * @see #pow(Vector)\n+     * @see VectorOperators#POW\n+     * @see #lanewise(VectorOperators.Binary,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector pow(short b) {\n+        return lanewise(POW, b);\n+    }\n+\n+    \/\/\/ UNARY METHODS\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector neg() {\n+        return lanewise(NEG);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector abs() {\n+        return lanewise(ABS);\n+    }\n+\n+\n+\n+    \/\/ sqrt\n+    \/**\n+     * Computes the square root of this vector.\n+     *\n+     * This is a lane-wise unary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#sqrt Math.sqrt(a)}\n+     * to each lane value.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Unary)\n+     *    lanewise}{@code (}{@link VectorOperators#SQRT\n+     *    SQRT}{@code )}.\n+     *\n+     * @return the square root of this vector\n+     * @see VectorOperators#SQRT\n+     * @see #lanewise(VectorOperators.Unary,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sqrt() {\n+        return lanewise(SQRT);\n+    }\n+\n+    \/\/\/ COMPARISONS\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> eq(Vector<Float16> v) {\n+        return compare(EQ, v);\n+    }\n+\n+    \/**\n+     * Tests if this vector is equal to an input scalar.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the primitive equals operation ({@code ==}) to each lane.\n+     * The result is the same as {@code compare(VectorOperators.Comparison.EQ, e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result mask of testing if this vector\n+     *         is equal to {@code e}\n+     * @see #compare(VectorOperators.Comparison,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> eq(short e) {\n+        return compare(EQ, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> lt(Vector<Float16> v) {\n+        return compare(LT, v);\n+    }\n+\n+    \/**\n+     * Tests if this vector is less than an input scalar.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the primitive less than operation ({@code <}) to each lane.\n+     * The result is the same as {@code compare(VectorOperators.LT, e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the mask result of testing if this vector\n+     *         is less than the input scalar\n+     * @see #compare(VectorOperators.Comparison,short)\n+     *\/\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> lt(short e) {\n+        return compare(LT, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Float16> test(VectorOperators.Test op);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M testTemplate(Class<M> maskType, Test op) {\n+        HalffloatSpecies vsp = vspecies();\n+        if (opKind(op, VO_SPECIAL)) {\n+            ShortVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Short> m;\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (short) 0);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (short) 0);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Short.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                short infbits = (short) toBits(Float16.float16ToRawShortBits(Float16.POSITIVE_INFINITY));\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits);\n+                } else {\n+                    m = bits.compare(EQ, infbits);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(vsp));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Float16> test(VectorOperators.Test op,\n+                                  VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        HalffloatSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            ShortVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Short> m = mask.cast(ShortVector.species(shape()));\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (short) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (short) 0, m);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Short.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                short infbits = (short) toBits(Float16.float16ToRawShortBits(Float16.POSITIVE_INFINITY));\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits, m);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits, m);\n+                } else {\n+                    m = bits.compare(EQ, infbits, m);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(vsp));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Float16> compare(VectorOperators.Comparison op, Vector<Float16> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M compareTemplate(Class<M> maskType, Comparison op, Vector<Float16> v) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        int opc = opCode(op);\n+        return VectorSupport.compare(\n+            opc, getClass(), maskType, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+            this, that, null,\n+            (cond, v0, v1, m1) -> {\n+                AbstractMask<Float16> m\n+                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                               -> compareWithOp(cond, a, b));\n+                @SuppressWarnings(\"unchecked\")\n+                M m2 = (M) m;\n+                return m2;\n+            });\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M compareTemplate(Class<M> maskType, Comparison op, Vector<Float16> v, M m) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        m.check(maskType, this);\n+        int opc = opCode(op);\n+        return VectorSupport.compare(\n+            opc, getClass(), maskType, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+            this, that, m,\n+            (cond, v0, v1, m1) -> {\n+                AbstractMask<Float16> cmpM\n+                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                               -> compareWithOp(cond, a, b));\n+                @SuppressWarnings(\"unchecked\")\n+                M m2 = (M) cmpM.and(m1);\n+                return m2;\n+            });\n+    }\n+\n+    @ForceInline\n+    private static boolean compareWithOp(int cond, short a, short b) {\n+        return switch (cond) {\n+            case BT_eq -> Float.float16ToFloat(a) == Float.float16ToFloat(b);\n+            case BT_ne -> Float.float16ToFloat(a) != Float.float16ToFloat(b);\n+            case BT_lt -> Float.float16ToFloat(a) < Float.float16ToFloat(b);\n+            case BT_le -> Float.float16ToFloat(a) <= Float.float16ToFloat(b);\n+            case BT_gt -> Float.float16ToFloat(a) > Float.float16ToFloat(b);\n+            case BT_ge -> Float.float16ToFloat(a) >= Float.float16ToFloat(b);\n+            default -> throw new AssertionError();\n+        };\n+    }\n+\n+    \/**\n+     * Tests this vector by comparing it with an input scalar,\n+     * according to the given comparison operation.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the comparison operation to each lane.\n+     * <p>\n+     * The result is the same as\n+     * {@code compare(op, broadcast(species(), e))}.\n+     * That is, the scalar may be regarded as broadcast to\n+     * a vector of the same species, and then compared\n+     * against the original vector, using the selected\n+     * comparison operation.\n+     *\n+     * @param op the operation used to compare lane values\n+     * @param e the input scalar\n+     * @return the mask result of testing lane-wise if this vector\n+     *         compares to the input, according to the selected\n+     *         comparison operator\n+     * @see HalffloatVector#compare(VectorOperators.Comparison,Vector)\n+     * @see #eq(short)\n+     * @see #lt(short)\n+     *\/\n+    public abstract\n+    VectorMask<Float16> compare(Comparison op, short e);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M compareTemplate(Class<M> maskType, Comparison op, short e) {\n+        return compareTemplate(maskType, op, broadcast(e));\n+    }\n+\n+    \/**\n+     * Tests this vector by comparing it with an input scalar,\n+     * according to the given comparison operation,\n+     * in lanes selected by a mask.\n+     *\n+     * This is a masked lane-wise binary test operation which applies\n+     * to each pair of corresponding lane values.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code compare(op,s).and(m)}.\n+     *\n+     * @param op the operation used to compare lane values\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the mask result of testing lane-wise if this vector\n+     *         compares to the input, according to the selected\n+     *         comparison operator,\n+     *         and only in the lanes selected by the mask\n+     * @see HalffloatVector#compare(VectorOperators.Comparison,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final VectorMask<Float16> compare(VectorOperators.Comparison op,\n+                                               short e,\n+                                               VectorMask<Float16> m) {\n+        return compare(op, broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Float16> compare(Comparison op, long e);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M compareTemplate(Class<M> maskType, Comparison op, long e) {\n+        return compareTemplate(maskType, op, broadcast(e));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> compare(Comparison op, long e, VectorMask<Float16> m) {\n+        return compare(op, broadcast(e), m);\n+    }\n+\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override public abstract\n+    HalffloatVector blend(Vector<Float16> v, VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector\n+    blendTemplate(Class<M> maskType, HalffloatVector v, M m) {\n+        v.check(this);\n+        return VectorSupport.blend(\n+            getClass(), maskType, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+            this, v, m,\n+            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override public abstract HalffloatVector addIndex(int scale);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector addIndexTemplate(int scale) {\n+        HalffloatSpecies vsp = vspecies();\n+        \/\/ make sure VLENGTH*scale doesn't overflow:\n+        vsp.checkScale(scale);\n+        return VectorSupport.indexVector(\n+            getClass(), short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+            this, scale, vsp,\n+            (v, scale_, s)\n+            -> {\n+                \/\/ If the platform doesn't support an INDEX\n+                \/\/ instruction directly, load IOTA from memory\n+                \/\/ and multiply.\n+                HalffloatVector iota = s.iota();\n+                short sc = (short) scale_;\n+                return v.add(sc == 1 ? iota : iota.mul(Float16.float16ToRawShortBits(Float16.valueOf(sc))));\n+            });\n+    }\n+\n+    \/**\n+     * Replaces selected lanes of this vector with\n+     * a scalar value\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which\n+     * selects each lane value from one or the other input.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code blend(broadcast(e),m)}.\n+     *\n+     * @param e the input scalar, containing the replacement lane value\n+     * @param m the mask controlling lane selection of the scalar\n+     * @return the result of blending the lane elements of this vector with\n+     *         the scalar value\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector blend(short e,\n+                                            VectorMask<Float16> m) {\n+        return blend(broadcast(e), m);\n+    }\n+\n+    \/**\n+     * Replaces selected lanes of this vector with\n+     * a scalar value\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which\n+     * selects each lane value from one or the other input.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code blend(broadcast(e),m)}.\n+     *\n+     * @param e the input scalar, containing the replacement lane value\n+     * @param m the mask controlling lane selection of the scalar\n+     * @return the result of blending the lane elements of this vector with\n+     *         the scalar value\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector blend(long e,\n+                                            VectorMask<Float16> m) {\n+        return blend(broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector slice(int origin, Vector<Float16> v1);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector sliceTemplate(int origin, Vector<Float16> v1) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        that.check(this);\n+        Objects.checkIndex(origin, length() + 1);\n+        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();\n+        ShortVector filter = ShortVector.broadcast((ShortVector.ShortSpecies) vspecies().asIntegral(), (short)(length() - origin));\n+        VectorMask<Float16> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n+        AbstractShuffle<Float16> iota = iotaShuffle(origin, 1, true);\n+        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector slice(int origin,\n+                               Vector<Float16> w,\n+                               VectorMask<Float16> m) {\n+        return broadcast(0).blend(slice(origin, w), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector slice(int origin);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector sliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();\n+        ShortVector filter = ShortVector.broadcast((ShortVector.ShortSpecies) vspecies().asIntegral(), (short)(length() - origin));\n+        VectorMask<Float16> blendMask = iotaVector.compare(VectorOperators.LT, filter).cast(vspecies());\n+        AbstractShuffle<Float16> iota = iotaShuffle(origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin, Vector<Float16> w, int part);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector\n+    unsliceTemplate(int origin, Vector<Float16> w, int part) {\n+        HalffloatVector that = (HalffloatVector) w;\n+        that.check(this);\n+        Objects.checkIndex(origin, length() + 1);\n+        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();\n+        ShortVector filter = ShortVector.broadcast((ShortVector.ShortSpecies) vspecies().asIntegral(), (short)origin);\n+        VectorMask<Float16> blendMask = iotaVector.compare((part == 0) ? VectorOperators.GE : VectorOperators.LT, filter).cast(vspecies());\n+        AbstractShuffle<Float16> iota = iotaShuffle(-origin, 1, true);\n+        return that.blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector\n+    unsliceTemplate(Class<M> maskType, int origin, Vector<Float16> w, int part, M m) {\n+        HalffloatVector that = (HalffloatVector) w;\n+        that.check(this);\n+        HalffloatVector slice = that.sliceTemplate(origin, that);\n+        slice = slice.blendTemplate(maskType, this, m);\n+        return slice.unsliceTemplate(origin, w, part);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m);\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector\n+    unsliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        ShortVector iotaVector = (ShortVector) iotaShuffle().toBitsVector();\n+        ShortVector filter = ShortVector.broadcast((ShortVector.ShortSpecies) vspecies().asIntegral(), (short)origin);\n+        VectorMask<Float16> blendMask = iotaVector.compare(VectorOperators.GE, filter).cast(vspecies());\n+        AbstractShuffle<Float16> iota = iotaShuffle(-origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    private ArrayIndexOutOfBoundsException\n+    wrongPartForSlice(int part) {\n+        String msg = String.format(\"bad part number %d for slice operation\",\n+                                   part);\n+        return new ArrayIndexOutOfBoundsException(msg);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Float16> shuffle);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Float16>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {\n+        Objects.requireNonNull(shuffle);\n+        return VectorSupport.rearrangeOp(\n+            getClass(), shuffletype, null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+            this, shuffle, null,\n+            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n+                return v1.lane(ei);\n+            }));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Float16> s,\n+                                   VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Float16>, M extends VectorMask<Float16>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype,\n+                                           Class<M> masktype,\n+                                           S shuffle,\n+                                           M m) {\n+        Objects.requireNonNull(shuffle);\n+        m.check(masktype, this);\n+        return VectorSupport.rearrangeOp(\n+                   getClass(), shuffletype, masktype, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+                   this, shuffle, m,\n+                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                        int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n+                        return !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n+                   }));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Float16> s,\n+                                   Vector<Float16> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Float16>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype,\n+                                           S shuffle,\n+                                           HalffloatVector v) {\n+        VectorMask<Float16> valid = shuffle.laneIsValid();\n+        HalffloatVector r0 =\n+            VectorSupport.rearrangeOp(\n+                getClass(), shuffletype, null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+                this, shuffle, null,\n+                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v0.length());\n+                    return v0.lane(ei);\n+                }));\n+        HalffloatVector r1 =\n+            VectorSupport.rearrangeOp(\n+                getClass(), shuffletype, null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+                v, shuffle, null,\n+                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                    int ei = Integer.remainderUnsigned(s_.laneSource(i), v1.length());\n+                    return v1.lane(ei);\n+                }));\n+        return r1.blend(r0, valid);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    final <F> VectorShuffle<F> bitsToShuffle0(AbstractSpecies<F> dsp) {\n+        throw new AssertionError();\n+    }\n+\n+    @ForceInline\n+    final <F>\n+    VectorShuffle<F> toShuffle(AbstractSpecies<F> dsp, boolean wrap) {\n+        assert(dsp.elementSize() == vspecies().elementSize());\n+        ShortVector idx = convert(VectorOperators.H2S, 0).reinterpretAsShorts();\n+        ShortVector wrapped = idx.lanewise(VectorOperators.AND, length() - 1);\n+        if (!wrap) {\n+            ShortVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<Short> inBound = wrapped.compare(VectorOperators.EQ, idx);\n+            wrapped = wrappedEx.blend(wrapped, inBound);\n+        }\n+        return wrapped.bitsToShuffle(dsp);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector compress(VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Float16>>\n+    HalffloatVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (HalffloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                        short.class, Float16.class, VECTOR_OPER_TYPE, length(), this, m,\n+                                                        (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector expand(VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Float16>>\n+    HalffloatVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (HalffloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                        short.class, Float16.class, VECTOR_OPER_TYPE, length(), this, m,\n+                                                        (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector selectFrom(Vector<Float16> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector selectFromTemplate(HalffloatVector v) {\n+        return (HalffloatVector)VectorSupport.selectFromOp(getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE,\n+                                                        length(), this, v, null,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle()));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector selectFrom(Vector<Float16> s, VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector selectFromTemplate(HalffloatVector v,\n+                                            Class<M> masktype, M m) {\n+        m.check(masktype, this);\n+        return (HalffloatVector)VectorSupport.selectFromOp(getClass(), masktype, short.class, Float16.class, VECTOR_OPER_TYPE,\n+                                                        length(), this, v, m,\n+                                                        (v1, v2, _m) ->\n+                                                         v2.rearrange(v1.toShuffle(), _m));\n+    }\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector selectFrom(Vector<Float16> v1, Vector<Float16> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector selectFromTemplate(HalffloatVector v1, HalffloatVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, Float16.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n+    \/\/\/ Ternary operations\n+\n+\n+    \/**\n+     * Multiplies this vector by a second input vector, and sums\n+     * the result with a third.\n+     *\n+     * Extended precision is used for the intermediate result,\n+     * avoiding possible loss of precision from rounding once\n+     * for each of the two operations.\n+     * The result is numerically close to {@code this.mul(b).add(c)},\n+     * and is typically closer to the true mathematical result.\n+     *\n+     * This is a lane-wise ternary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#fma(short,short,short) Math.fma(a,b,c)}\n+     * to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#FMA\n+     *    FMA}{@code , b, c)}.\n+     *\n+     * @param b the second input vector, supplying multiplier values\n+     * @param c the third input vector, supplying addend values\n+     * @return the product of this vector and the second input vector\n+     *         summed with the third input vector, using extended precision\n+     *         for the intermediate result\n+     * @see #fma(short,short)\n+     * @see VectorOperators#FMA\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector fma(Vector<Float16> b, Vector<Float16> c) {\n+        return lanewise(FMA, b, c);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by a scalar multiplier, and sums\n+     * the result with a scalar addend.\n+     *\n+     * Extended precision is used for the intermediate result,\n+     * avoiding possible loss of precision from rounding once\n+     * for each of the two operations.\n+     * The result is numerically close to {@code this.mul(b).add(c)},\n+     * and is typically closer to the true mathematical result.\n+     *\n+     * This is a lane-wise ternary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#fma(short,short,short) Math.fma(a,b,c)}\n+     * to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#FMA\n+     *    FMA}{@code , b, c)}.\n+     *\n+     * @param b the scalar multiplier\n+     * @param c the scalar addend\n+     * @return the product of this vector and the scalar multiplier\n+     *         summed with scalar addend, using extended precision\n+     *         for the intermediate result\n+     * @see #fma(Vector,Vector)\n+     * @see VectorOperators#FMA\n+     * @see #lanewise(VectorOperators.Ternary,short,short,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector fma(short b, short c) {\n+        return lanewise(FMA, b, c);\n+    }\n+\n+    \/\/ Don't bother with (Vector,short) and (short,Vector) overloadings.\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    \/**\n+     * Returns a value accumulated from all the lanes of this vector.\n+     *\n+     * This is an associative cross-lane reduction operation which\n+     * applies the specified operation to all the lane elements.\n+     * <p>\n+     * A few reduction operations do not support arbitrary reordering\n+     * of their operands, yet are included here because of their\n+     * usefulness.\n+     * <ul>\n+     * <li>\n+     * In the case of {@code FIRST_NONZERO}, the reduction returns\n+     * the value from the lowest-numbered non-zero lane.\n+     * (As with {@code MAX} and {@code MIN}, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from\n+     * the default value, positive zero. So a first-nonzero lane reduction\n+     * might return {@code -0.0} even in the presence of non-zero\n+     * lane values.)\n+     * <li>\n+     * In the case of {@code ADD} and {@code MUL}, the\n+     * precise result will reflect the choice of an arbitrary order\n+     * of operations, which may even vary over time.\n+     * For further details see the section\n+     * <a href=\"VectorOperators.html#fp_assoc\">Operations on floating point vectors<\/a>.\n+     * <li>\n+     * All other reduction operations are fully commutative and\n+     * associative.  The implementation can choose any order of\n+     * processing, yet it will always produce the same result.\n+     * <\/ul>\n+     *\n+     * @param op the operation used to combine lane values\n+     * @return the accumulated result\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #reduceLanes(VectorOperators.Associative,VectorMask)\n+     * @see #add(Vector)\n+     * @see #mul(Vector)\n+     * @see #min(Vector)\n+     * @see #max(Vector)\n+     * @see VectorOperators#FIRST_NONZERO\n+     *\/\n+    public abstract short reduceLanes(VectorOperators.Associative op);\n+\n+    \/**\n+     * Returns a value accumulated from selected lanes of this vector,\n+     * controlled by a mask.\n+     *\n+     * This is an associative cross-lane reduction operation which\n+     * applies the specified operation to the selected lane elements.\n+     * <p>\n+     * If no elements are selected, an operation-specific identity\n+     * value is returned.\n+     * <ul>\n+     * <li>\n+     * If the operation is\n+     *  {@code ADD}\n+     * or {@code FIRST_NONZERO},\n+     * then the identity value is positive zero, the default {@code short} value.\n+     * <li>\n+     * If the operation is {@code MUL},\n+     * then the identity value is one.\n+     * <li>\n+     * If the operation is {@code MAX},\n+     * then the identity value is {@code Float16.NEGATIVE_INFINITY}.\n+     * <li>\n+     * If the operation is {@code MIN},\n+     * then the identity value is {@code Float16.POSITIVE_INFINITY}.\n+     * <\/ul>\n+     * <p>\n+     * A few reduction operations do not support arbitrary reordering\n+     * of their operands, yet are included here because of their\n+     * usefulness.\n+     * <ul>\n+     * <li>\n+     * In the case of {@code FIRST_NONZERO}, the reduction returns\n+     * the value from the lowest-numbered non-zero lane.\n+     * (As with {@code MAX} and {@code MIN}, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from\n+     * the default value, positive zero. So a first-nonzero lane reduction\n+     * might return {@code -0.0} even in the presence of non-zero\n+     * lane values.)\n+     * <li>\n+     * In the case of {@code ADD} and {@code MUL}, the\n+     * precise result will reflect the choice of an arbitrary order\n+     * of operations, which may even vary over time.\n+     * For further details see the section\n+     * <a href=\"VectorOperators.html#fp_assoc\">Operations on floating point vectors<\/a>.\n+     * <li>\n+     * All other reduction operations are fully commutative and\n+     * associative.  The implementation can choose any order of\n+     * processing, yet it will always produce the same result.\n+     * <\/ul>\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param m the mask controlling lane selection\n+     * @return the reduced result accumulated from the selected lane values\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #reduceLanes(VectorOperators.Associative)\n+     *\/\n+    public abstract short reduceLanes(VectorOperators.Associative op,\n+                                       VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    short reduceLanesTemplate(VectorOperators.Associative op,\n+                               Class<? extends VectorMask<Float16>> maskClass,\n+                               VectorMask<Float16> m) {\n+        m.check(maskClass, this);\n+        if (op == FIRST_NONZERO) {\n+            \/\/ FIXME:  The JIT should handle this.\n+            HalffloatVector v = broadcast((short) 0).blend(this, m);\n+            return v.reduceLanesTemplate(op);\n+        }\n+        int opc = opCode(op);\n+        return fromBits(VectorSupport.reductionCoerced(\n+            opc, getClass(), maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+            this, m,\n+            REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    short reduceLanesTemplate(VectorOperators.Associative op) {\n+        if (op == FIRST_NONZERO) {\n+            \/\/ FIXME:  The JIT should handle this.\n+            VectorMask<Short> thisNZ\n+                = this.viewAsIntegralLanes().compare(NE, (short) 0);\n+            int ft = thisNZ.firstTrue();\n+            return ft < length() ? this.lane(ft) : (short) 0;\n+        }\n+        int opc = opCode(op);\n+        return fromBits(VectorSupport.reductionCoerced(\n+            opc, getClass(), null, short.class, Float16.class, VECTOR_OPER_TYPE, length(),\n+            this, null,\n+            REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));\n+    }\n+\n+    private static final\n+    ImplCache<Associative, ReductionOperation<HalffloatVector, VectorMask<Float16>>>\n+        REDUCE_IMPL = new ImplCache<>(Associative.class, HalffloatVector.class);\n+\n+    private static ReductionOperation<HalffloatVector, VectorMask<Float16>> reductionOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v, m) ->\n+                    toBits(v.rOp((short)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));\n+            case VECTOR_OP_MUL: return (v, m) ->\n+                    toBits(v.rOp((short)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.multiply(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));\n+            case VECTOR_OP_MIN: return (v, m) ->\n+                    toBits(v.rOp((short)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.min(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));\n+            case VECTOR_OP_MAX: return (v, m) ->\n+                    toBits(v.rOp((short)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.max(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));\n+            default: return null;\n+        }\n+    }\n+\n+    private static final short MIN_OR_INF = Float16.float16ToRawShortBits(Float16.NEGATIVE_INFINITY);\n+    private static final short MAX_OR_INF = Float16.float16ToRawShortBits(Float16.POSITIVE_INFINITY);\n+\n+    public @Override abstract long reduceLanesToLong(VectorOperators.Associative op);\n+    public @Override abstract long reduceLanesToLong(VectorOperators.Associative op,\n+                                                     VectorMask<Float16> m);\n+\n+    \/\/ Type specific accessors\n+\n+    \/**\n+     * Gets the lane element at lane index {@code i}\n+     *\n+     * @param i the lane index\n+     * @return the lane element at lane index {@code i}\n+     * @throws IllegalArgumentException if the index is out of range\n+     * ({@code < 0 || >= length()})\n+     *\/\n+    public abstract short lane(int i);\n+\n+    \/**\n+     * Replaces the lane element of this vector at lane index {@code i} with\n+     * value {@code e}.\n+     *\n+     * This is a cross-lane operation and behaves as if it returns the result\n+     * of blending this vector with an input vector that is the result of\n+     * broadcasting {@code e} and a mask that has only one lane set at lane\n+     * index {@code i}.\n+     *\n+     * @param i the lane index of the lane element to be replaced\n+     * @param e the value to be placed\n+     * @return the result of replacing the lane element of this vector at lane\n+     * index {@code i} with value {@code e}.\n+     * @throws IllegalArgumentException if the index is out of range\n+     * ({@code < 0 || >= length()})\n+     *\/\n+    public abstract HalffloatVector withLane(int i, short e);\n+\n+    \/\/ Memory load operations\n+\n+    \/**\n+     * Returns an array of type {@code short[]}\n+     * containing all the lane values.\n+     * The array length is the same as the vector length.\n+     * The array elements are stored in lane order.\n+     * <p>\n+     * This method behaves as if it stores\n+     * this vector into an allocated array\n+     * (using {@link #intoArray(short[], int) intoArray})\n+     * and returns the array as follows:\n+     * <pre>{@code\n+     *   short[] a = new short[this.length()];\n+     *   this.intoArray(a, 0);\n+     *   return a;\n+     * }<\/pre>\n+     *\n+     * @return an array containing the lane values of this vector\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final short[] toArray() {\n+        short[] a = new short[vspecies().laneCount()];\n+        intoArray(a, 0);\n+        return a;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final int[] toIntArray() {\n+        short[] a = toArray();\n+        int[] res = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            short e = a[i];\n+            res[i] = (int) HalffloatSpecies.toIntegralChecked(e, true);\n+        }\n+        return res;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final long[] toLongArray() {\n+        short[] a = toArray();\n+        long[] res = new long[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            short e = Float16.shortBitsToFloat16(a[i]).shortValue();\n+            res[i] = HalffloatSpecies.toIntegralChecked(e, false);\n+        }\n+        return res;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     * @implNote\n+     * When this method is used on vectors\n+     * of type {@code HalffloatVector},\n+     * there will be no loss of precision.\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final double[] toDoubleArray() {\n+        short[] a = toArray();\n+        double[] res = new double[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            res[i] = (double) Float16.shortBitsToFloat16(a[i]).doubleValue();\n+        }\n+        return res;\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code short[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N} is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Float16> species,\n+                                   short[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code short[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (positive zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N} is placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Float16> species,\n+                                   short[] a, int offset,\n+                                   VectorMask<Float16> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+        }\n+\n+        ((AbstractMask<Float16>)m)\n+            .checkIndexByLane(offset, a.length, vsp.iota(), 1);\n+        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code short[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Float16> species,\n+                                   short[] a, int offset,\n+                                   int[] indexMap, int mapOffset) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+        Objects.requireNonNull(a);\n+        Objects.requireNonNull(indexMap);\n+        Class<? extends HalffloatVector> vectorType = vsp.vectorType();\n+\n+\n+        \/\/ Constant folding should sweep out following conditonal logic.\n+        VectorSpecies<Integer> lsp;\n+        if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {\n+            lsp = IntVector.SPECIES_PREFERRED;\n+        } else {\n+            lsp = isp;\n+        }\n+\n+        \/\/ Check indices are within array bounds.\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+        return VectorSupport.loadWithMap(\n+            vectorType, null, short.class, Float16.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, null,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(n -> c[idx + iMap[idy+n]]));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code short[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Float16> species,\n+                                   short[] a, int offset,\n+                                   int[] indexMap, int mapOffset,\n+                                   VectorMask<Float16> m) {\n+        if (m.allTrue()) {\n+            return fromArray(species, a, offset, indexMap, mapOffset);\n+        }\n+        else {\n+            HalffloatSpecies vsp = (HalffloatSpecies) species;\n+            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+        }\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Float16> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (positive zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Float16> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<Float16> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+            return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_IN_RANGE);\n+        }\n+\n+        ((AbstractMask<Float16>)m)\n+            .checkIndexByLane(offset, a.length, vsp.iota(), 1);\n+        return vsp.dummyVector().fromCharArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Float16> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromCharArray(VectorSpecies<Float16> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<Float16> m) {\n+        \/\/ FIXME: optimize\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromMemorySegment(VectorSpecies<Float16> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (positive zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * short[] ar = new short[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_SHORT.withByteAlignment(1), n);\n+     *     }\n+     * }\n+     * HalffloatVector r = HalffloatVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromMemorySegment(VectorSpecies<Float16> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Float16> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (VectorIntrinsics.indexInRange(offset, vsp.vectorByteSize(), ms.byteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+        }\n+\n+        ((AbstractMask<Float16>)m)\n+            .checkIndexByLane(offset, ms.byteSize(), vsp.iota(), 2);\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+    }\n+\n+    \/\/ Memory store operations\n+\n+    \/**\n+     * Stores this vector into an array of type {@code short[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code short[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, arrayAddress(a, offset), false,\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, (int) off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code short[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code short[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset,\n+                   VectorMask<Float16> m) {\n+        if (m.allTrue()) {\n+            intoArray(a, offset);\n+        } else {\n+            HalffloatSpecies vsp = vspecies();\n+            if (!VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+                ((AbstractMask<Float16>)m)\n+                    .checkIndexByLane(offset, a.length, vsp.iota(), 1);\n+            }\n+            intoArray0(a, offset, m);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code short[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset,\n+                   int[] indexMap, int mapOffset) {\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code short[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, int offset,\n+                   int[] indexMap, int mapOffset,\n+                   VectorMask<Float16> m) {\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, charArrayAddress(a, offset), false,\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, (int) off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<Float16> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            HalffloatSpecies vsp = vspecies();\n+            if (!VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+                ((AbstractMask<Float16>)m)\n+                    .checkIndexByLane(offset, a.length, vsp.iota(), 1);\n+            }\n+            intoCharArray0(a, offset, m);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<Float16> m) {\n+        \/\/ FIXME: optimize\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Float16> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            HalffloatSpecies vsp = vspecies();\n+            if (!VectorIntrinsics.indexInRange(offset, vsp.vectorByteSize(), ms.byteSize())) {\n+                ((AbstractMask<Float16>)m)\n+                    .checkIndexByLane(offset, ms.byteSize(), vsp.iota(), 2);\n+            }\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Low-level memory operations.\n+    \/\/\n+    \/\/ Note that all of these operations *must* inline into a context\n+    \/\/ where the exact species of the involved vector is a\n+    \/\/ compile-time constant.  Otherwise, the intrinsic generation\n+    \/\/ will fail and performance will suffer.\n+    \/\/\n+    \/\/ In many cases this is achieved by re-deriving a version of the\n+    \/\/ method in each concrete subclass (per species).  The re-derived\n+    \/\/ method simply calls one of these generic methods, with exact\n+    \/\/ parameters for the controlling metadata, which is either a\n+    \/\/ typed vector or constant species instance.\n+\n+    \/\/ Unchecked loading operations in native byte order.\n+    \/\/ Caller is responsible for applying index checks, masking, and\n+    \/\/ byte swapping.\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromArray0(short[] a, int offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromArray0Template(short[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, arrayAddress(a, offset), false,\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n+                                    (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromArray0(short[] a, int offset, VectorMask<Float16> m, int offsetInRange);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector fromArray0Template(Class<M> maskClass, short[] a, int offset, M m, int offsetInRange) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, arrayAddress(a, offset), false, m, offsetInRange,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+                                        (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromArray0(short[] a, int offset,\n+                                    int[] indexMap, int mapOffset,\n+                                    VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector fromArray0Template(Class<M> maskClass, short[] a, int offset,\n+                                            int[] indexMap, int mapOffset, M m) {\n+        HalffloatSpecies vsp = vspecies();\n+        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+        Objects.requireNonNull(a);\n+        Objects.requireNonNull(indexMap);\n+        m.check(vsp);\n+        Class<? extends HalffloatVector> vectorType = vsp.vectorType();\n+\n+\n+        \/\/ Constant folding should sweep out following conditonal logic.\n+        VectorSpecies<Integer> lsp;\n+        if (isp.length() > IntVector.SPECIES_PREFERRED.length()) {\n+            lsp = IntVector.SPECIES_PREFERRED;\n+        } else {\n+            lsp = isp;\n+        }\n+\n+        \/\/ Check indices are within array bounds.\n+        \/\/ FIXME: Check index under mask controlling.\n+        IntVector vix0 = IntVector.fromArray(lsp, indexMap, mapOffset).add(offset);\n+        VectorIntrinsics.checkIndex(vix0, a.length);\n+\n+        int vlen = vsp.length();\n+        int idx_vlen = lsp.length();\n+        IntVector vix1 = null;\n+        if (vlen >= idx_vlen * 2) {\n+            vix1 = IntVector.fromArray(lsp, indexMap, mapOffset + idx_vlen).add(offset);\n+            VectorIntrinsics.checkIndex(vix1, a.length);\n+        }\n+\n+        return VectorSupport.loadWithMap(\n+            vectorType, maskClass, short.class, Float16.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n+            lsp.vectorType(), lsp.length(),\n+            a, ARRAY_BASE, vix0, vix1, null, null, m,\n+            a, offset, indexMap, mapOffset, vsp,\n+            (c, idx, iMap, idy, s, vm) ->\n+            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromCharArray0Template(char[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, charArrayAddress(a, offset), false,\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromCharArray0(char[] a, int offset, VectorMask<Float16> m, int offsetInRange);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector fromCharArray0Template(Class<M> maskClass, char[] a, int offset, M m, int offsetInRange) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+                a, charArrayAddress(a, offset), false, m, offsetInRange,\n+                a, offset, vsp,\n+                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+                                            (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+\n+\n+    abstract\n+    HalffloatVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+                (AbstractMemorySegmentImpl) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, HalffloatVector::memorySegmentGet);\n+                });\n+    }\n+\n+    abstract\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m, int offsetInRange) {\n+        HalffloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+                (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n+                (msp, off, s, vm) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, HalffloatVector::memorySegmentGet);\n+                });\n+    }\n+\n+    \/\/ Unchecked storing operations in native byte order.\n+    \/\/ Caller is responsible for applying index checks, masking, and\n+    \/\/ byte swapping.\n+\n+    abstract\n+    void intoArray0(short[] a, int offset);\n+    @ForceInline\n+    final\n+    void intoArray0Template(short[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, arrayAddress(a, offset), false,\n+            this, a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, (int) off,\n+                      (arr_, off_, i, e) -> arr_[off_+i] = e));\n+    }\n+\n+    abstract\n+    void intoArray0(short[] a, int offset, VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    void intoArray0Template(Class<M> maskClass, short[] a, int offset, M m) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, arrayAddress(a, offset), false,\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.stOp(arr, (int) off, vm,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+    }\n+\n+\n+\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+                this,\n+                (AbstractMemorySegmentImpl) ms, offset,\n+                (msp, off, v) -> {\n+                    v.stLongOp((MemorySegment) msp, off, HalffloatVector::memorySegmentSet);\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        HalffloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+                this, m,\n+                (AbstractMemorySegmentImpl) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    v.stLongOp((MemorySegment) msp, off, vm, HalffloatVector::memorySegmentSet);\n+                });\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    void intoCharArray0(char[] a, int offset, VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    void intoCharArray0Template(Class<M> maskClass, char[] a, int offset, M m) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n+            a, charArrayAddress(a, offset), false,\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.stOp(arr, (int) off, vm,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/\/ End of low-level memory operations.\n+\n+    @ForceInline\n+    private void conditionalStoreNYI(int offset,\n+                                     HalffloatSpecies vsp,\n+                                     VectorMask<Float16> m,\n+                                     int scale,\n+                                     int limit) {\n+        if (offset < 0 || offset + vsp.laneCount() * scale > limit) {\n+            String msg =\n+                String.format(\"unimplemented: store @%d in [0..%d), %s in %s\",\n+                              offset, limit, m, vsp);\n+            throw new AssertionError(msg);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    final\n+    HalffloatVector maybeSwap(ByteOrder bo) {\n+        if (bo != NATIVE_ENDIAN) {\n+            return this.reinterpretAsBytes()\n+                .rearrange(swapBytesShuffle())\n+                .reinterpretAsHalffloats();\n+        }\n+        return this;\n+    }\n+\n+    static final int ARRAY_SHIFT =\n+        31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_SHORT_INDEX_SCALE);\n+    static final long ARRAY_BASE =\n+        Unsafe.ARRAY_SHORT_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long arrayAddress(short[] a, int index) {\n+        return ARRAY_BASE + (((long)index) << ARRAY_SHIFT);\n+    }\n+\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+\n+\n+    @ForceInline\n+    static long byteArrayAddress(byte[] a, int index) {\n+        return Unsafe.ARRAY_BYTE_BASE_OFFSET + index;\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/\/ Reinterpreting view methods:\n+    \/\/   lanewise reinterpret: viewAsXVector()\n+    \/\/   keep shape, redraw lanes: reinterpretAsEs()\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final ByteVector reinterpretAsBytes() {\n+         \/\/ Going to ByteVector, pay close attention to byte order.\n+         assert(REGISTER_ENDIAN == ByteOrder.LITTLE_ENDIAN);\n+         return asByteVectorRaw();\n+         \/\/return asByteVectorRaw().rearrange(swapBytesShuffle());\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final ShortVector viewAsIntegralLanes() {\n+        LaneType ilt = LaneType.SHORT.asIntegral();\n+        return (ShortVector) asVectorRaw(ilt);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\n+     * @implNote This method always throws\n+     * {@code UnsupportedOperationException}, because there is no floating\n+     * point type of the same size as {@code short}.  The return type\n+     * of this method is arbitrarily designated as\n+     * {@code Vector<?>}.  Future versions of this API may change the return\n+     * type if additional floating point types become available.\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final\n+    HalffloatVector\n+    viewAsFloatingLanes() {\n+        return this;\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/\/ Object methods: toString, equals, hashCode\n+    \/\/\n+    \/\/ Object methods are defined as if via Arrays.toString, etc.,\n+    \/\/ is applied to the array of elements.  Two equal vectors\n+    \/\/ are required to have equal species and equal lane values.\n+\n+    \/**\n+     * Returns a string representation of this vector, of the form\n+     * {@code \"[0,1,2...]\"}, reporting the lane values of this vector,\n+     * in lane order.\n+     *\n+     * The string is produced as if by a call to {@link\n+     * java.util.Arrays#toString(short[]) Arrays.toString()},\n+     * as appropriate to the {@code short} array returned by\n+     * {@link #toArray this.toArray()}.\n+     *\n+     * @return a string of the form {@code \"[0,1,2...]\"}\n+     * reporting the lane values of this vector\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    String toString() {\n+        \/\/ now that toArray is strongly typed, we can define this\n+        return Arrays.toString(toArray());\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    boolean equals(Object obj) {\n+        if (obj instanceof Vector) {\n+            Vector<?> that = (Vector<?>) obj;\n+            if (this.species().equals(that.species())) {\n+                return this.eq(that.check(this.species())).allTrue();\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    int hashCode() {\n+        \/\/ now that toArray is strongly typed, we can define this\n+        return Objects.hash(species(), Arrays.hashCode(toArray()));\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Species\n+\n+    \/**\n+     * Class representing {@link HalffloatVector}'s of the same {@link VectorShape VectorShape}.\n+     *\/\n+    \/*package-private*\/\n+    static final class HalffloatSpecies extends AbstractSpecies<Float16> {\n+        private HalffloatSpecies(VectorShape shape,\n+                Class<? extends HalffloatVector> vectorType,\n+                Class<? extends AbstractMask<Float16>> maskType,\n+                Class<? extends AbstractShuffle<Float16>> shuffleType,\n+                Function<Object, HalffloatVector> vectorFactory) {\n+            super(shape, LaneType.of(Float16.class),\n+                  vectorType, maskType, shuffleType,\n+                  vectorFactory);\n+            assert(this.elementSize() == Float16.SIZE);\n+        }\n+\n+        \/\/ Specializing overrides:\n+\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return short.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (Float16.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final Class<Float16> elementType() {\n+            return Float16.class;\n+        }\n+\n+        @Override\n+        @ForceInline\n+        final Class<Float16> genericElementType() {\n+            return Float16.class;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        @ForceInline\n+        public final Class<? extends HalffloatVector> vectorType() {\n+            return (Class<? extends HalffloatVector>) vectorType;\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final long checkValue(long e) {\n+            longToElementBits(e);  \/\/ only for exception\n+            return e;\n+        }\n+\n+        \/*package-private*\/\n+        @Override\n+        @ForceInline\n+        final HalffloatVector broadcastBits(long bits) {\n+            return (HalffloatVector)\n+                VectorSupport.fromBitsCoerced(\n+                    vectorType, short.class, Float16.class, VECTOR_OPER_TYPE, laneCount,\n+                    bits, MODE_BROADCAST, this,\n+                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        final HalffloatVector broadcast(short e) {\n+            return broadcastBits(toBits(e));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector broadcast(long e) {\n+            return broadcastBits(longToElementBits(e));\n+        }\n+\n+        \/*package-private*\/\n+        final @Override\n+        @ForceInline\n+        long longToElementBits(long value) {\n+            \/\/ Do the conversion, and then test it for failure.\n+            short e = (short) value;\n+            if ((long) e != value) {\n+                throw badElementBits(value, e);\n+            }\n+            return toBits(e);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        static long toIntegralChecked(short e, boolean convertToInt) {\n+            long value = convertToInt ? (int) e : (long) e;\n+            if ((short) value != e) {\n+                throw badArrayBits(e, convertToInt, value);\n+            }\n+            return value;\n+        }\n+\n+        \/* this non-public one is for internal conversions *\/\n+        @Override\n+        @ForceInline\n+        final HalffloatVector fromIntValues(int[] values) {\n+            VectorIntrinsics.requireLength(values.length, laneCount);\n+            short[] va = new short[laneCount()];\n+            for (int i = 0; i < va.length; i++) {\n+                int lv = values[i];\n+                short v = Float16.float16ToRawShortBits(Float16.valueOf(lv));\n+                va[i] = v;\n+                if (Float16.valueOf(lv).intValue() != lv) {\n+                    throw badElementBits(lv, v);\n+                }\n+            }\n+            return dummyVector().fromArray0(va, 0);\n+        }\n+\n+        \/\/ Virtual constructors\n+\n+        @ForceInline\n+        @Override final\n+        public HalffloatVector fromArray(Object a, int offset) {\n+            \/\/ User entry point\n+            \/\/ Defer only to the equivalent method on the vector class, using the same inputs\n+            return HalffloatVector\n+                .fromArray(this, (short[]) a, offset);\n+        }\n+\n+        @ForceInline\n+        @Override final\n+        public HalffloatVector fromMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n+            \/\/ User entry point\n+            \/\/ Defer only to the equivalent method on the vector class, using the same inputs\n+            return HalffloatVector\n+                .fromMemorySegment(this, ms, offset, bo);\n+        }\n+\n+        @ForceInline\n+        @Override final\n+        HalffloatVector dummyVector() {\n+            return (HalffloatVector) super.dummyVector();\n+        }\n+\n+        \/*package-private*\/\n+        final @Override\n+        @ForceInline\n+        HalffloatVector rvOp(RVOp f) {\n+            short[] res = new short[laneCount()];\n+            for (int i = 0; i < res.length; i++) {\n+                short bits = (short) f.apply(i);\n+                res[i] = fromBits(bits);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        HalffloatVector vOp(FVOp f) {\n+            short[] res = new short[laneCount()];\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        HalffloatVector vOp(VectorMask<Float16> m, FVOp f) {\n+            short[] res = new short[laneCount()];\n+            boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                if (mbits[i]) {\n+                    res[i] = f.apply(i);\n+                }\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> HalffloatVector ldOp(M memory, int offset,\n+                                      FLdOp<M> f) {\n+            return dummyVector().ldOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> HalffloatVector ldOp(M memory, int offset,\n+                                      VectorMask<Float16> m,\n+                                      FLdOp<M> f) {\n+            return dummyVector().ldOp(memory, offset, m, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                      VectorMask<Float16> m,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stOp(M memory, int offset, FStOp<M> f) {\n+            dummyVector().stOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stOp(M memory, int offset,\n+                      AbstractMask<Float16> m,\n+                      FStOp<M> f) {\n+            dummyVector().stOp(memory, offset, m, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset,\n+                      AbstractMask<Float16> m,\n+                      FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n+        \/\/ N.B. Make sure these constant vectors and\n+        \/\/ masks load up correctly into registers.\n+        \/\/\n+        \/\/ Also, see if we can avoid all that switching.\n+        \/\/ Could we cache both vectors and both masks in\n+        \/\/ this species object?\n+\n+        \/\/ Zero and iota vector access\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector zero() {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.ZERO;\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.ZERO;\n+                case 128: return Halffloat128Vector.ZERO;\n+                case 256: return Halffloat256Vector.ZERO;\n+                case 512: return Halffloat512Vector.ZERO;\n+            }\n+            throw new AssertionError();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector iota() {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.IOTA;\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.IOTA;\n+                case 128: return Halffloat128Vector.IOTA;\n+                case 256: return Halffloat256Vector.IOTA;\n+                case 512: return Halffloat512Vector.IOTA;\n+            }\n+            throw new AssertionError();\n+        }\n+\n+        \/\/ Mask access\n+        @Override\n+        @ForceInline\n+        public final VectorMask<Float16> maskAll(boolean bit) {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.HalffloatMaxMask.maskAll(bit);\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.Halffloat64Mask.maskAll(bit);\n+                case 128: return Halffloat128Vector.Halffloat128Mask.maskAll(bit);\n+                case 256: return Halffloat256Vector.Halffloat256Mask.maskAll(bit);\n+                case 512: return Halffloat512Vector.Halffloat512Mask.maskAll(bit);\n+            }\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    \/**\n+     * Finds a species for an element type of {@code short} and shape.\n+     *\n+     * @param s the shape\n+     * @return a species for an element type of {@code short} and shape\n+     * @throws IllegalArgumentException if no such species exists for the shape\n+     *\/\n+    static HalffloatSpecies species(VectorShape s) {\n+        Objects.requireNonNull(s);\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (HalffloatSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (HalffloatSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (HalffloatSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (HalffloatSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (HalffloatSpecies) SPECIES_MAX;\n+            default: throw new IllegalArgumentException(\"Bad shape: \" + s);\n+        }\n+    }\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_64_BIT VectorShape.S_64_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_64\n+        = new HalffloatSpecies(VectorShape.S_64_BIT,\n+                            Halffloat64Vector.class,\n+                            Halffloat64Vector.Halffloat64Mask.class,\n+                            Halffloat64Vector.Halffloat64Shuffle.class,\n+                            Halffloat64Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_128_BIT VectorShape.S_128_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_128\n+        = new HalffloatSpecies(VectorShape.S_128_BIT,\n+                            Halffloat128Vector.class,\n+                            Halffloat128Vector.Halffloat128Mask.class,\n+                            Halffloat128Vector.Halffloat128Shuffle.class,\n+                            Halffloat128Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_256_BIT VectorShape.S_256_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_256\n+        = new HalffloatSpecies(VectorShape.S_256_BIT,\n+                            Halffloat256Vector.class,\n+                            Halffloat256Vector.Halffloat256Mask.class,\n+                            Halffloat256Vector.Halffloat256Shuffle.class,\n+                            Halffloat256Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_512_BIT VectorShape.S_512_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_512\n+        = new HalffloatSpecies(VectorShape.S_512_BIT,\n+                            Halffloat512Vector.class,\n+                            Halffloat512Vector.Halffloat512Mask.class,\n+                            Halffloat512Vector.Halffloat512Shuffle.class,\n+                            Halffloat512Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_MAX\n+        = new HalffloatSpecies(VectorShape.S_Max_BIT,\n+                            HalffloatMaxVector.class,\n+                            HalffloatMaxVector.HalffloatMaxMask.class,\n+                            HalffloatMaxVector.HalffloatMaxShuffle.class,\n+                            HalffloatMaxVector::new);\n+\n+    \/**\n+     * Preferred species for {@link HalffloatVector}s.\n+     * A preferred species is a species of maximal bit-size for the platform.\n+     *\/\n+    public static final VectorSpecies<Float16> SPECIES_PREFERRED\n+        = (HalffloatSpecies) VectorSpecies.ofPreferred(Float16.class);\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatVector.java","additions":4361,"deletions":0,"binary":false,"changes":4361,"status":"added"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+    static final Class<Integer> CTYPE = int.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Integer> ETYPE = int.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Integer> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Integer> elementType() { return int.class; }\n+    public final Class<Integer> elementType() { return ETYPE; }\n@@ -532,1 +539,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -555,1 +562,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -568,1 +575,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n@@ -670,1 +677,1 @@\n-                Int128Mask.class, int.class, VLENGTH, offset, limit,\n+                Int128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -686,2 +693,3 @@\n-                Int128Vector.class, Int128Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Int128Vector.class, Int128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -698,1 +706,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -708,1 +716,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -718,1 +726,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -728,2 +736,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int128Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int128Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -735,2 +744,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int128Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int128Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -742,2 +752,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int128Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int128Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -752,1 +763,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int128Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int128Mask.class, int.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -762,1 +774,1 @@\n-            return VectorSupport.extract(Int128Mask.class, int.class, VLENGTH,\n+            return VectorSupport.extract(Int128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -771,3 +783,3 @@\n-            return VectorSupport.test(BT_ne, Int128Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Int128Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Int128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Int128Mask)m).getBits()));\n@@ -779,3 +791,3 @@\n-            return VectorSupport.test(BT_overflow, Int128Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Int128Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Int128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Int128Mask)m).getBits()));\n@@ -787,1 +799,1 @@\n-            return VectorSupport.fromBitsCoerced(Int128Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Int128Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -800,1 +812,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+    static final Class<Integer> CTYPE = int.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Integer> ETYPE = int.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Integer> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Integer> elementType() { return int.class; }\n+    public final Class<Integer> elementType() { return ETYPE; }\n@@ -536,1 +543,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -563,1 +570,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -576,1 +583,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n@@ -678,1 +685,1 @@\n-                Int256Mask.class, int.class, VLENGTH, offset, limit,\n+                Int256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -694,2 +701,3 @@\n-                Int256Vector.class, Int256Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Int256Vector.class, Int256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -706,1 +714,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -716,1 +724,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -726,1 +734,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -736,2 +744,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int256Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int256Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -743,2 +752,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int256Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int256Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -750,2 +760,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int256Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int256Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -760,1 +771,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int256Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int256Mask.class, int.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -770,1 +782,1 @@\n-            return VectorSupport.extract(Int256Mask.class, int.class, VLENGTH,\n+            return VectorSupport.extract(Int256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -779,3 +791,3 @@\n-            return VectorSupport.test(BT_ne, Int256Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Int256Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Int256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Int256Mask)m).getBits()));\n@@ -787,3 +799,3 @@\n-            return VectorSupport.test(BT_overflow, Int256Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Int256Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Int256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Int256Mask)m).getBits()));\n@@ -795,1 +807,1 @@\n-            return VectorSupport.fromBitsCoerced(Int256Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Int256Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -808,1 +820,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+    static final Class<Integer> CTYPE = int.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Integer> ETYPE = int.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Integer> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Integer> elementType() { return int.class; }\n+    public final Class<Integer> elementType() { return ETYPE; }\n@@ -544,1 +551,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -579,1 +586,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -592,1 +599,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n@@ -694,1 +701,1 @@\n-                Int512Mask.class, int.class, VLENGTH, offset, limit,\n+                Int512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -710,2 +717,3 @@\n-                Int512Vector.class, Int512Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Int512Vector.class, Int512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -722,1 +730,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -732,1 +740,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -742,1 +750,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -752,2 +760,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int512Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int512Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -759,2 +768,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int512Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int512Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -766,2 +776,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int512Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int512Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -776,1 +787,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int512Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int512Mask.class, int.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -786,1 +798,1 @@\n-            return VectorSupport.extract(Int512Mask.class, int.class, VLENGTH,\n+            return VectorSupport.extract(Int512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -795,3 +807,3 @@\n-            return VectorSupport.test(BT_ne, Int512Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Int512Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Int512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Int512Mask)m).getBits()));\n@@ -803,3 +815,3 @@\n-            return VectorSupport.test(BT_overflow, Int512Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Int512Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Int512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Int512Mask)m).getBits()));\n@@ -811,1 +823,1 @@\n-            return VectorSupport.fromBitsCoerced(Int512Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Int512Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -824,1 +836,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+    static final Class<Integer> CTYPE = int.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Integer> ETYPE = int.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Integer> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Integer> elementType() { return int.class; }\n+    public final Class<Integer> elementType() { return ETYPE; }\n@@ -530,1 +537,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -551,1 +558,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -564,1 +571,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n@@ -666,1 +673,1 @@\n-                Int64Mask.class, int.class, VLENGTH, offset, limit,\n+                Int64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -682,2 +689,3 @@\n-                Int64Vector.class, Int64Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Int64Vector.class, Int64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -694,1 +702,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -704,1 +712,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -714,1 +722,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -724,2 +732,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int64Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int64Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -731,2 +740,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int64Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int64Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -738,2 +748,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int64Mask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int64Mask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -748,1 +759,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int64Mask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Int64Mask.class, int.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -758,1 +770,1 @@\n-            return VectorSupport.extract(Int64Mask.class, int.class, VLENGTH,\n+            return VectorSupport.extract(Int64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -767,3 +779,3 @@\n-            return VectorSupport.test(BT_ne, Int64Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Int64Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Int64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Int64Mask)m).getBits()));\n@@ -775,3 +787,3 @@\n-            return VectorSupport.test(BT_overflow, Int64Mask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Int64Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Int64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Int64Mask)m).getBits()));\n@@ -783,1 +795,1 @@\n-            return VectorSupport.fromBitsCoerced(Int64Mask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Int64Mask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -796,1 +808,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+    static final Class<Integer> CTYPE = int.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Integer> ETYPE = int.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Integer> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Integer> elementType() { return int.class; }\n+    public final Class<Integer> elementType() { return ETYPE; }\n@@ -529,1 +536,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -549,1 +556,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -562,1 +569,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n@@ -664,1 +671,1 @@\n-                IntMaxMask.class, int.class, VLENGTH, offset, limit,\n+                IntMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -680,2 +687,3 @@\n-                IntMaxVector.class, IntMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                IntMaxVector.class, IntMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -692,1 +700,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, IntMaxMask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, IntMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -702,1 +710,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, IntMaxMask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, IntMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -712,1 +720,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, IntMaxMask.class, null, int.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, IntMaxMask.class, null, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -722,2 +730,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, IntMaxMask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -729,2 +738,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, IntMaxMask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -736,2 +746,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, IntMaxMask.class, int.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, IntMaxMask.class, int.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -746,1 +757,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, IntMaxMask.class, int.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, IntMaxMask.class, int.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -756,1 +768,1 @@\n-            return VectorSupport.extract(IntMaxMask.class, int.class, VLENGTH,\n+            return VectorSupport.extract(IntMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -765,3 +777,3 @@\n-            return VectorSupport.test(BT_ne, IntMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((IntMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_ne, IntMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((IntMaxMask)m).getBits()));\n@@ -773,3 +785,3 @@\n-            return VectorSupport.test(BT_overflow, IntMaxMask.class, int.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((IntMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, IntMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((IntMaxMask)m).getBits()));\n@@ -781,1 +793,1 @@\n-            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -805,1 +817,1 @@\n-        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n+        static final Class<Integer> CTYPE = int.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n+\n@@ -576,1 +578,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), int.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), int.class, int.class, VECTOR_OPER_TYPE, species.length(),\n@@ -698,1 +700,1 @@\n-            opc, getClass(), null, int.class, length(),\n+            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -726,1 +728,1 @@\n-            opc, getClass(), maskClass, int.class, length(),\n+            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -799,1 +801,1 @@\n-            opc, getClass(), null, int.class, length(),\n+            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -850,1 +852,1 @@\n-            opc, getClass(), maskClass, int.class, length(),\n+            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -1041,1 +1043,1 @@\n-            opc, getClass(), null, int.class, length(),\n+            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -1062,1 +1064,1 @@\n-            opc, getClass(), maskClass, int.class, length(),\n+            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -1138,1 +1140,1 @@\n-            opc, getClass(), null, int.class, length(),\n+            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -1178,1 +1180,1 @@\n-            opc, getClass(), maskClass, int.class, length(),\n+            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2058,1 +2060,1 @@\n-            opc, getClass(), maskType, int.class, length(),\n+            opc, getClass(), maskType, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2080,1 +2082,1 @@\n-            opc, getClass(), maskType, int.class, length(),\n+            opc, getClass(), maskType, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2211,1 +2213,1 @@\n-            getClass(), maskType, int.class, length(),\n+            getClass(), maskType, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2228,1 +2230,1 @@\n-            getClass(), int.class, length(),\n+            getClass(), int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2420,1 +2422,1 @@\n-            getClass(), shuffletype, null, int.class, length(),\n+            getClass(), shuffletype, null, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2446,1 +2448,1 @@\n-                   getClass(), shuffletype, masktype, int.class, length(),\n+                   getClass(), shuffletype, masktype, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2473,1 +2475,1 @@\n-                getClass(), shuffletype, null, int.class, length(),\n+                getClass(), shuffletype, null, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2481,1 +2483,1 @@\n-                getClass(), shuffletype, null, int.class, length(),\n+                getClass(), shuffletype, null, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2531,1 +2533,1 @@\n-                                                        int.class, length(), this, m,\n+                                                        int.class, int.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2550,1 +2552,1 @@\n-                                                        int.class, length(), this, m,\n+                                                        int.class, int.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2565,1 +2567,1 @@\n-        return (IntVector)VectorSupport.selectFromOp(getClass(), null, int.class,\n+        return (IntVector)VectorSupport.selectFromOp(getClass(), null, int.class, int.class, VECTOR_OPER_TYPE,\n@@ -2585,1 +2587,1 @@\n-        return (IntVector)VectorSupport.selectFromOp(getClass(), masktype, int.class,\n+        return (IntVector)VectorSupport.selectFromOp(getClass(), masktype, int.class, int.class, VECTOR_OPER_TYPE,\n@@ -2603,1 +2605,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), int.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), int.class, int.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -2823,1 +2825,1 @@\n-            opc, getClass(), maskClass, int.class, length(),\n+            opc, getClass(), maskClass, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -2841,1 +2843,1 @@\n-            opc, getClass(), null, int.class, length(),\n+            opc, getClass(), null, int.class, int.class, VECTOR_OPER_TYPE, length(),\n@@ -3101,1 +3103,1 @@\n-            vectorType, null, int.class, vsp.laneCount(),\n+            vectorType, null, int.class, int.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3284,1 +3286,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3373,1 +3375,1 @@\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3500,1 +3502,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3517,1 +3519,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3550,1 +3552,1 @@\n-            vectorType, maskClass, int.class, vsp.laneCount(),\n+            vectorType, maskClass, int.class, int.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3567,1 +3569,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3583,1 +3585,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3601,1 +3603,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3618,1 +3620,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3647,1 +3649,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3666,1 +3668,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3683,1 +3685,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3855,0 +3857,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return int.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (int.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -3887,1 +3902,1 @@\n-                    vectorType, int.class, laneCount,\n+                    vectorType, int.class, int.class, VECTOR_OPER_TYPE, laneCount,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":53,"deletions":38,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -43,1 +43,2 @@\n-    LONG(long.class, Long.class, long[].class, 'I', -1, Long.SIZE, T_LONG);\n+    LONG(long.class, Long.class, long[].class, 'I', -1, Long.SIZE, T_LONG),\n+    HALFFLOAT(Float16.class, Short.class, short[].class, 'F', 11, Float16.SIZE, T_HALFFLOAT);\n@@ -69,1 +70,6 @@\n-        assert(\"FDBSIL\".indexOf(typeChar) == ordinal()) : this;\n+        if (basicType == T_HALFFLOAT) {\n+          assert(\"FDBSILS\".indexOf(typeChar, \"FDBSILS\".indexOf(typeChar) + 1) == ordinal()) : this;\n+        }\n+        else {\n+          assert(\"FDBSILS\".indexOf(typeChar) == ordinal()) : this;\n+        }\n@@ -75,1 +81,1 @@\n-        assert(\"....zcFDBSILoav..\".charAt(basicType) == typeChar);\n+        assert(\"....zSFDBSILSoav..\".charAt(basicType) == typeChar);\n@@ -181,7 +187,8 @@\n-        SK_FLOAT    = 1,\n-        SK_DOUBLE   = 2,\n-        SK_BYTE     = 3,\n-        SK_SHORT    = 4,\n-        SK_INT      = 5,\n-        SK_LONG     = 6,\n-        SK_LIMIT    = 7;\n+        SK_FLOAT     = 1,\n+        SK_DOUBLE    = 2,\n+        SK_BYTE      = 3,\n+        SK_SHORT     = 4,\n+        SK_INT       = 5,\n+        SK_LONG      = 6,\n+        SK_HALFFLOAT = 7,\n+        SK_LIMIT     = 8;\n@@ -249,1 +256,2 @@\n-            } else {\n+            } else if (value.basicType != T_SHORT) {\n+                \/\/ FIXME: Support asFloating for short to be Halffloat\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LaneType.java","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+    static final Class<Long> CTYPE = long.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Long> ETYPE = long.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Long> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Long> elementType() { return long.class; }\n+    public final Class<Long> elementType() { return ETYPE; }\n@@ -520,1 +527,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -541,1 +548,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -554,1 +561,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n@@ -656,1 +663,1 @@\n-                Long128Mask.class, long.class, VLENGTH, offset, limit,\n+                Long128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -672,2 +679,3 @@\n-                Long128Vector.class, Long128Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Long128Vector.class, Long128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -684,1 +692,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -694,1 +702,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -704,1 +712,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -714,2 +722,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long128Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long128Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -721,2 +730,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long128Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long128Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -728,2 +738,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long128Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long128Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -738,1 +749,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long128Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long128Mask.class, long.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -748,1 +760,1 @@\n-            return VectorSupport.extract(Long128Mask.class, long.class, VLENGTH,\n+            return VectorSupport.extract(Long128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -757,3 +769,3 @@\n-            return VectorSupport.test(BT_ne, Long128Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Long128Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Long128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Long128Mask)m).getBits()));\n@@ -765,3 +777,3 @@\n-            return VectorSupport.test(BT_overflow, Long128Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Long128Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Long128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Long128Mask)m).getBits()));\n@@ -773,1 +785,1 @@\n-            return VectorSupport.fromBitsCoerced(Long128Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Long128Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -786,1 +798,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+    static final Class<Long> CTYPE = long.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Long> ETYPE = long.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Long> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Long> elementType() { return long.class; }\n+    public final Class<Long> elementType() { return ETYPE; }\n@@ -522,1 +529,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -545,1 +552,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -558,1 +565,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n@@ -660,1 +667,1 @@\n-                Long256Mask.class, long.class, VLENGTH, offset, limit,\n+                Long256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -676,2 +683,3 @@\n-                Long256Vector.class, Long256Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Long256Vector.class, Long256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -688,1 +696,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -698,1 +706,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -708,1 +716,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -718,2 +726,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long256Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long256Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -725,2 +734,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long256Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long256Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -732,2 +742,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long256Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long256Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -742,1 +753,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long256Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long256Mask.class, long.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -752,1 +764,1 @@\n-            return VectorSupport.extract(Long256Mask.class, long.class, VLENGTH,\n+            return VectorSupport.extract(Long256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -761,3 +773,3 @@\n-            return VectorSupport.test(BT_ne, Long256Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Long256Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Long256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Long256Mask)m).getBits()));\n@@ -769,3 +781,3 @@\n-            return VectorSupport.test(BT_overflow, Long256Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Long256Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Long256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Long256Mask)m).getBits()));\n@@ -777,1 +789,1 @@\n-            return VectorSupport.fromBitsCoerced(Long256Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Long256Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -790,1 +802,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+    static final Class<Long> CTYPE = long.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Long> ETYPE = long.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Long> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Long> elementType() { return long.class; }\n+    public final Class<Long> elementType() { return ETYPE; }\n@@ -526,1 +533,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -553,1 +560,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -566,1 +573,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n@@ -668,1 +675,1 @@\n-                Long512Mask.class, long.class, VLENGTH, offset, limit,\n+                Long512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -684,2 +691,3 @@\n-                Long512Vector.class, Long512Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Long512Vector.class, Long512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -696,1 +704,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -706,1 +714,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -716,1 +724,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -726,2 +734,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long512Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long512Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -733,2 +742,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long512Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long512Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -740,2 +750,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long512Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long512Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -750,1 +761,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long512Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long512Mask.class, long.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -760,1 +772,1 @@\n-            return VectorSupport.extract(Long512Mask.class, long.class, VLENGTH,\n+            return VectorSupport.extract(Long512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -769,3 +781,3 @@\n-            return VectorSupport.test(BT_ne, Long512Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Long512Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Long512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Long512Mask)m).getBits()));\n@@ -777,3 +789,3 @@\n-            return VectorSupport.test(BT_overflow, Long512Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Long512Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Long512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Long512Mask)m).getBits()));\n@@ -785,1 +797,1 @@\n-            return VectorSupport.fromBitsCoerced(Long512Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Long512Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -798,1 +810,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+    static final Class<Long> CTYPE = long.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Long> ETYPE = long.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Long> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Long> elementType() { return long.class; }\n+    public final Class<Long> elementType() { return ETYPE; }\n@@ -519,1 +526,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -539,1 +546,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -552,1 +559,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n@@ -654,1 +661,1 @@\n-                Long64Mask.class, long.class, VLENGTH, offset, limit,\n+                Long64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -670,2 +677,3 @@\n-                Long64Vector.class, Long64Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Long64Vector.class, Long64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -682,1 +690,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -692,1 +700,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -702,1 +710,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -712,2 +720,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long64Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long64Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -719,2 +728,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long64Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long64Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -726,2 +736,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long64Mask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long64Mask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -736,1 +747,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long64Mask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Long64Mask.class, long.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -746,1 +758,1 @@\n-            return VectorSupport.extract(Long64Mask.class, long.class, VLENGTH,\n+            return VectorSupport.extract(Long64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -755,3 +767,3 @@\n-            return VectorSupport.test(BT_ne, Long64Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Long64Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Long64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Long64Mask)m).getBits()));\n@@ -763,3 +775,3 @@\n-            return VectorSupport.test(BT_overflow, Long64Mask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Long64Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Long64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Long64Mask)m).getBits()));\n@@ -771,1 +783,1 @@\n-            return VectorSupport.fromBitsCoerced(Long64Mask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Long64Mask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -784,1 +796,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+    static final Class<Long> CTYPE = long.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Long> ETYPE = long.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Long> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Long> elementType() { return long.class; }\n+    public final Class<Long> elementType() { return ETYPE; }\n@@ -519,1 +526,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -539,1 +546,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -552,1 +559,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n@@ -654,1 +661,1 @@\n-                LongMaxMask.class, long.class, VLENGTH, offset, limit,\n+                LongMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -670,2 +677,3 @@\n-                LongMaxVector.class, LongMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                LongMaxVector.class, LongMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -682,1 +690,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, LongMaxMask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, LongMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -692,1 +700,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, LongMaxMask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, LongMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -702,1 +710,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, LongMaxMask.class, null, long.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, LongMaxMask.class, null, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -712,2 +720,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, LongMaxMask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -719,2 +728,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, LongMaxMask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -726,2 +736,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, LongMaxMask.class, long.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, LongMaxMask.class, long.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -736,1 +747,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, LongMaxMask.class, long.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, LongMaxMask.class, long.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -746,1 +758,1 @@\n-            return VectorSupport.extract(LongMaxMask.class, long.class, VLENGTH,\n+            return VectorSupport.extract(LongMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -755,3 +767,3 @@\n-            return VectorSupport.test(BT_ne, LongMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((LongMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_ne, LongMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((LongMaxMask)m).getBits()));\n@@ -763,3 +775,3 @@\n-            return VectorSupport.test(BT_overflow, LongMaxMask.class, long.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((LongMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, LongMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((LongMaxMask)m).getBits()));\n@@ -771,1 +783,1 @@\n-            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -784,1 +796,1 @@\n-        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n+        static final Class<Long> CTYPE = long.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n+\n@@ -576,1 +578,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), long.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), long.class, long.class, VECTOR_OPER_TYPE, species.length(),\n@@ -656,1 +658,1 @@\n-            opc, getClass(), null, long.class, length(),\n+            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -684,1 +686,1 @@\n-            opc, getClass(), maskClass, long.class, length(),\n+            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -757,1 +759,1 @@\n-            opc, getClass(), null, long.class, length(),\n+            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -808,1 +810,1 @@\n-            opc, getClass(), maskClass, long.class, length(),\n+            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -954,1 +956,1 @@\n-            opc, getClass(), null, long.class, length(),\n+            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -975,1 +977,1 @@\n-            opc, getClass(), maskClass, long.class, length(),\n+            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -1051,1 +1053,1 @@\n-            opc, getClass(), null, long.class, length(),\n+            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -1091,1 +1093,1 @@\n-            opc, getClass(), maskClass, long.class, length(),\n+            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -1971,1 +1973,1 @@\n-            opc, getClass(), maskType, long.class, length(),\n+            opc, getClass(), maskType, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -1993,1 +1995,1 @@\n-            opc, getClass(), maskType, long.class, length(),\n+            opc, getClass(), maskType, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2098,1 +2100,1 @@\n-            getClass(), maskType, long.class, length(),\n+            getClass(), maskType, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2115,1 +2117,1 @@\n-            getClass(), long.class, length(),\n+            getClass(), long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2286,1 +2288,1 @@\n-            getClass(), shuffletype, null, long.class, length(),\n+            getClass(), shuffletype, null, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2312,1 +2314,1 @@\n-                   getClass(), shuffletype, masktype, long.class, length(),\n+                   getClass(), shuffletype, masktype, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2339,1 +2341,1 @@\n-                getClass(), shuffletype, null, long.class, length(),\n+                getClass(), shuffletype, null, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2347,1 +2349,1 @@\n-                getClass(), shuffletype, null, long.class, length(),\n+                getClass(), shuffletype, null, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2397,1 +2399,1 @@\n-                                                        long.class, length(), this, m,\n+                                                        long.class, long.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2416,1 +2418,1 @@\n-                                                        long.class, length(), this, m,\n+                                                        long.class, long.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2431,1 +2433,1 @@\n-        return (LongVector)VectorSupport.selectFromOp(getClass(), null, long.class,\n+        return (LongVector)VectorSupport.selectFromOp(getClass(), null, long.class, long.class, VECTOR_OPER_TYPE,\n@@ -2451,1 +2453,1 @@\n-        return (LongVector)VectorSupport.selectFromOp(getClass(), masktype, long.class,\n+        return (LongVector)VectorSupport.selectFromOp(getClass(), masktype, long.class, long.class, VECTOR_OPER_TYPE,\n@@ -2469,1 +2471,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), long.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), long.class, long.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -2689,1 +2691,1 @@\n-            opc, getClass(), maskClass, long.class, length(),\n+            opc, getClass(), maskClass, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2707,1 +2709,1 @@\n-            opc, getClass(), null, long.class, length(),\n+            opc, getClass(), null, long.class, long.class, VECTOR_OPER_TYPE, length(),\n@@ -2980,1 +2982,1 @@\n-            vectorType, null, long.class, vsp.laneCount(),\n+            vectorType, null, long.class, long.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3163,1 +3165,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3271,1 +3273,1 @@\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3398,1 +3400,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3415,1 +3417,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3466,1 +3468,1 @@\n-            vectorType, maskClass, long.class, vsp.laneCount(),\n+            vectorType, maskClass, long.class, long.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3483,1 +3485,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3499,1 +3501,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3517,1 +3519,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3534,1 +3536,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3582,1 +3584,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3601,1 +3603,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3618,1 +3620,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3790,0 +3792,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return long.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (long.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -3822,1 +3837,1 @@\n-                    vectorType, long.class, laneCount,\n+                    vectorType, long.class, long.class, VECTOR_OPER_TYPE, laneCount,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":53,"deletions":38,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Short> ETYPE = short.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Short> elementType() { return short.class; }\n+    public final Class<Short> elementType() { return ETYPE; }\n@@ -536,1 +543,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -563,1 +570,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -576,1 +583,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n@@ -678,1 +685,1 @@\n-                Short128Mask.class, short.class, VLENGTH, offset, limit,\n+                Short128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -694,2 +701,3 @@\n-                Short128Vector.class, Short128Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Short128Vector.class, Short128Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -706,1 +714,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -716,1 +724,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -726,1 +734,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -736,2 +744,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short128Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short128Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -743,2 +752,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short128Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short128Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -750,2 +760,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short128Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short128Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -760,1 +771,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short128Mask.class, short.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short128Mask.class, short.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -770,1 +782,1 @@\n-            return VectorSupport.extract(Short128Mask.class, short.class, VLENGTH,\n+            return VectorSupport.extract(Short128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -779,3 +791,3 @@\n-            return VectorSupport.test(BT_ne, Short128Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Short128Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Short128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Short128Mask)m).getBits()));\n@@ -787,3 +799,3 @@\n-            return VectorSupport.test(BT_overflow, Short128Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Short128Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Short128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Short128Mask)m).getBits()));\n@@ -795,1 +807,1 @@\n-            return VectorSupport.fromBitsCoerced(Short128Mask.class, short.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Short128Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -808,1 +820,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Short> ETYPE = short.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Short> elementType() { return short.class; }\n+    public final Class<Short> elementType() { return ETYPE; }\n@@ -544,1 +551,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -579,1 +586,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -592,1 +599,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n@@ -694,1 +701,1 @@\n-                Short256Mask.class, short.class, VLENGTH, offset, limit,\n+                Short256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -710,2 +717,3 @@\n-                Short256Vector.class, Short256Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Short256Vector.class, Short256Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -722,1 +730,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -732,1 +740,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -742,1 +750,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -752,2 +760,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short256Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short256Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -759,2 +768,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short256Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short256Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -766,2 +776,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short256Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short256Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -776,1 +787,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short256Mask.class, short.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short256Mask.class, short.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -786,1 +798,1 @@\n-            return VectorSupport.extract(Short256Mask.class, short.class, VLENGTH,\n+            return VectorSupport.extract(Short256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -795,3 +807,3 @@\n-            return VectorSupport.test(BT_ne, Short256Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Short256Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Short256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Short256Mask)m).getBits()));\n@@ -803,3 +815,3 @@\n-            return VectorSupport.test(BT_overflow, Short256Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Short256Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Short256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Short256Mask)m).getBits()));\n@@ -811,1 +823,1 @@\n-            return VectorSupport.fromBitsCoerced(Short256Mask.class, short.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Short256Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -824,1 +836,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Short> ETYPE = short.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Short> elementType() { return short.class; }\n+    public final Class<Short> elementType() { return ETYPE; }\n@@ -560,1 +567,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -611,1 +618,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -624,1 +631,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n@@ -726,1 +733,1 @@\n-                Short512Mask.class, short.class, VLENGTH, offset, limit,\n+                Short512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -742,2 +749,3 @@\n-                Short512Vector.class, Short512Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Short512Vector.class, Short512Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -754,1 +762,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -764,1 +772,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -774,1 +782,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -784,2 +792,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short512Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short512Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -791,2 +800,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short512Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short512Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -798,2 +808,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short512Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short512Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -808,1 +819,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short512Mask.class, short.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short512Mask.class, short.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -818,1 +830,1 @@\n-            return VectorSupport.extract(Short512Mask.class, short.class, VLENGTH,\n+            return VectorSupport.extract(Short512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -827,3 +839,3 @@\n-            return VectorSupport.test(BT_ne, Short512Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Short512Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Short512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Short512Mask)m).getBits()));\n@@ -835,3 +847,3 @@\n-            return VectorSupport.test(BT_overflow, Short512Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Short512Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Short512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Short512Mask)m).getBits()));\n@@ -843,1 +855,1 @@\n-            return VectorSupport.fromBitsCoerced(Short512Mask.class, short.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Short512Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -856,1 +868,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Short> ETYPE = short.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Short> elementType() { return short.class; }\n+    public final Class<Short> elementType() { return ETYPE; }\n@@ -532,1 +539,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -555,1 +562,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -568,1 +575,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n@@ -670,1 +677,1 @@\n-                Short64Mask.class, short.class, VLENGTH, offset, limit,\n+                Short64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -686,2 +693,3 @@\n-                Short64Vector.class, Short64Mask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                Short64Vector.class, Short64Mask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -698,1 +706,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -708,1 +716,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -718,1 +726,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -728,2 +736,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short64Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short64Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -735,2 +744,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short64Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short64Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -742,2 +752,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short64Mask.class, short.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short64Mask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -752,1 +763,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short64Mask.class, short.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Short64Mask.class, short.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -762,1 +774,1 @@\n-            return VectorSupport.extract(Short64Mask.class, short.class, VLENGTH,\n+            return VectorSupport.extract(Short64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -771,3 +783,3 @@\n-            return VectorSupport.test(BT_ne, Short64Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((Short64Mask)m).getBits()));\n+            return VectorSupport.test(BT_ne, Short64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((Short64Mask)m).getBits()));\n@@ -779,3 +791,3 @@\n-            return VectorSupport.test(BT_overflow, Short64Mask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((Short64Mask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, Short64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((Short64Mask)m).getBits()));\n@@ -787,1 +799,1 @@\n-            return VectorSupport.fromBitsCoerced(Short64Mask.class, short.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(Short64Mask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -800,1 +812,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+    static final Class<Short> CTYPE = short.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<Short> ETYPE = short.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<Short> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<Short> elementType() { return short.class; }\n+    public final Class<Short> elementType() { return ETYPE; }\n@@ -529,1 +536,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -549,1 +556,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -562,1 +569,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n@@ -664,1 +671,1 @@\n-                ShortMaxMask.class, short.class, VLENGTH, offset, limit,\n+                ShortMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -680,2 +687,3 @@\n-                ShortMaxVector.class, ShortMaxMask.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                ShortMaxVector.class, ShortMaxMask.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                m1.trueCount()));\n@@ -692,1 +700,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, ShortMaxMask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, ShortMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -702,1 +710,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, ShortMaxMask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, ShortMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -712,1 +720,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, ShortMaxMask.class, null, short.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, ShortMaxMask.class, null, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -722,2 +730,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ShortMaxMask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -729,2 +738,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ShortMaxMask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -736,2 +746,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ShortMaxMask.class, short.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -746,1 +757,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ShortMaxMask.class, short.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, ShortMaxMask.class, short.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -756,1 +768,1 @@\n-            return VectorSupport.extract(ShortMaxMask.class, short.class, VLENGTH,\n+            return VectorSupport.extract(ShortMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -765,3 +777,3 @@\n-            return VectorSupport.test(BT_ne, ShortMaxMask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper(((ShortMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_ne, ShortMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper(((ShortMaxMask)m).getBits()));\n@@ -773,3 +785,3 @@\n-            return VectorSupport.test(BT_overflow, ShortMaxMask.class, short.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper(((ShortMaxMask)m).getBits()));\n+            return VectorSupport.test(BT_overflow, ShortMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper(((ShortMaxMask)m).getBits()));\n@@ -781,1 +793,1 @@\n-            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -794,1 +806,1 @@\n-        static final Class<Short> ETYPE = short.class; \/\/ used by the JVM\n+        static final Class<Short> CTYPE = short.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+    static final int VECTOR_OPER_TYPE = VECTOR_TYPE_PRIM;\n+\n@@ -576,1 +578,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, short.class, VECTOR_OPER_TYPE, species.length(),\n@@ -698,1 +700,1 @@\n-            opc, getClass(), null, short.class, length(),\n+            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -726,1 +728,1 @@\n-            opc, getClass(), maskClass, short.class, length(),\n+            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -799,1 +801,1 @@\n-            opc, getClass(), null, short.class, length(),\n+            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -850,1 +852,1 @@\n-            opc, getClass(), maskClass, short.class, length(),\n+            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -1037,1 +1039,1 @@\n-            opc, getClass(), null, short.class, length(),\n+            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -1058,1 +1060,1 @@\n-            opc, getClass(), maskClass, short.class, length(),\n+            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -1135,1 +1137,1 @@\n-            opc, getClass(), null, short.class, length(),\n+            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -1175,1 +1177,1 @@\n-            opc, getClass(), maskClass, short.class, length(),\n+            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2074,1 +2076,1 @@\n-            opc, getClass(), maskType, short.class, length(),\n+            opc, getClass(), maskType, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2096,1 +2098,1 @@\n-            opc, getClass(), maskType, short.class, length(),\n+            opc, getClass(), maskType, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2227,1 +2229,1 @@\n-            getClass(), maskType, short.class, length(),\n+            getClass(), maskType, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2244,1 +2246,1 @@\n-            getClass(), short.class, length(),\n+            getClass(), short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2436,1 +2438,1 @@\n-            getClass(), shuffletype, null, short.class, length(),\n+            getClass(), shuffletype, null, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2462,1 +2464,1 @@\n-                   getClass(), shuffletype, masktype, short.class, length(),\n+                   getClass(), shuffletype, masktype, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2489,1 +2491,1 @@\n-                getClass(), shuffletype, null, short.class, length(),\n+                getClass(), shuffletype, null, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2497,1 +2499,1 @@\n-                getClass(), shuffletype, null, short.class, length(),\n+                getClass(), shuffletype, null, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2547,1 +2549,1 @@\n-                                                        short.class, length(), this, m,\n+                                                        short.class, short.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2566,1 +2568,1 @@\n-                                                        short.class, length(), this, m,\n+                                                        short.class, short.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -2581,1 +2583,1 @@\n-        return (ShortVector)VectorSupport.selectFromOp(getClass(), null, short.class,\n+        return (ShortVector)VectorSupport.selectFromOp(getClass(), null, short.class, short.class, VECTOR_OPER_TYPE,\n@@ -2601,1 +2603,1 @@\n-        return (ShortVector)VectorSupport.selectFromOp(getClass(), masktype, short.class,\n+        return (ShortVector)VectorSupport.selectFromOp(getClass(), masktype, short.class, short.class, VECTOR_OPER_TYPE,\n@@ -2619,1 +2621,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, short.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -2839,1 +2841,1 @@\n-            opc, getClass(), maskClass, short.class, length(),\n+            opc, getClass(), maskClass, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -2857,1 +2859,1 @@\n-            opc, getClass(), null, short.class, length(),\n+            opc, getClass(), null, short.class, short.class, VECTOR_OPER_TYPE, length(),\n@@ -3138,1 +3140,1 @@\n-            vectorType, null, short.class, vsp.laneCount(),\n+            vectorType, null, short.class, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3471,1 +3473,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3620,1 +3622,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3825,1 +3827,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3842,1 +3844,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3889,1 +3891,1 @@\n-            vectorType, maskClass, short.class, vsp.laneCount(),\n+            vectorType, maskClass, short.class, short.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3905,1 +3907,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3922,1 +3924,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3937,1 +3939,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3953,1 +3955,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3971,1 +3973,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3988,1 +3990,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4003,1 +4005,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4020,1 +4022,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4038,1 +4040,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4141,1 +4143,1 @@\n-    Vector<?>\n+    HalffloatVector\n@@ -4226,0 +4228,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return short.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if (short.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -4258,1 +4273,1 @@\n-                    vectorType, short.class, laneCount,\n+                    vectorType, short.class, short.class, VECTOR_OPER_TYPE, laneCount,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":56,"deletions":41,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -3072,0 +3072,13 @@\n+    \/**\n+     * Reinterprets this vector as a vector of the same shape\n+     * and contents but a lane type of {@code halffloat},\n+     * where the lanes are assembled from successive bytes\n+     * according to little-endian order.\n+     * It is a convenience method for the expression\n+     * {@code reinterpretShape(species().withLanes(halffloat.class))}.\n+     * It may be considered an inverse to {@link Vector#reinterpretAsBytes()}.\n+     *\n+     * @return a {@code HalffloatVector} with the same shape and information content\n+     *\/\n+    public abstract HalffloatVector reinterpretAsHalffloats();\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -35,0 +36,2 @@\n+    static final Unsafe U = Unsafe.getUnsafe();\n+\n@@ -151,0 +154,4 @@\n+    static <V> V maybeRebox(V v) {\n+        U.loadFence();\n+        return v;\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorIntrinsics.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n@@ -210,2 +212,2 @@\n-                vsp.maskType(), vsp.elementType(), laneCount,\n-                bits, (long) offset + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET, false,\n+                vsp.maskType(), vsp.carrierType(), vsp.elementType(),\n+                vsp.operType(), laneCount, bits, (long) offset + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET, false,\n@@ -243,1 +245,2 @@\n-        return VectorSupport.fromBitsCoerced(vsp.maskType(), vsp.elementType(), vsp.laneCount(), bits,\n+        return VectorSupport.fromBitsCoerced(vsp.maskType(), vsp.carrierType(), vsp.elementType(),\n+                                             vsp.operType(), vsp.laneCount(), bits,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -697,0 +697,2 @@\n+    \/** Convert {@code byteVal} to {@code (halffloat)byteVal}. *\/\n+    public static final Conversion<Byte,Float16> B2H = convert(\"B2H\", 'C', byte.class, Float16.class, VO_KIND_CAST, VO_ALL);\n@@ -707,0 +709,2 @@\n+    \/** Convert {@code doubleVal} to {@code (halffloat)doubleVal}. *\/\n+    public static final Conversion<Double,Float16> D2H = convert(\"D2H\", 'C', double.class, Float16.class, VO_KIND_CAST, VO_ALL);\n@@ -717,0 +721,2 @@\n+    \/** Convert {@code floatVal} to {@code (halffloat)floatVal}. *\/\n+    public static final Conversion<Float,Float16> F2H = convert(\"F2H\", 'C', float.class, Float16.class, VO_KIND_CAST, VO_ALL);\n@@ -727,0 +733,2 @@\n+    \/** Convert {@code intVal} to {@code (halffloat)intVal}. *\/\n+    public static final Conversion<Integer,Float16> I2H = convert(\"I2H\", 'C', int.class, Float16.class, VO_KIND_CAST, VO_ALL);\n@@ -737,0 +745,2 @@\n+    \/** Convert {@code longVal} to {@code (halffloat)longVal}. *\/\n+    public static final Conversion<Long,Float16> L2H = convert(\"L2H\", 'C', long.class, Float16.class, VO_KIND_CAST, VO_ALL);\n@@ -747,0 +757,15 @@\n+    \/** Convert {@code shortVal} to {@code (halffloat)shortVal}. *\/\n+    public static final Conversion<Short,Float16> S2H = convert(\"S2H\", 'C', short.class, Float16.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (byte)halffloatVal}. *\/\n+    public static final Conversion<Float16,Byte> H2B = convert(\"H2B\", 'C', Float16.class, byte.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (short)halffloatVal}. *\/\n+    public static final Conversion<Float16,Short> H2S = convert(\"H2S\", 'C', Float16.class, short.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (double)halffloatVal}. *\/\n+    public static final Conversion<Float16,Double> H2D = convert(\"H2D\", 'C', Float16.class, double.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (float)halffloatVal}. *\/\n+    public static final Conversion<Float16,Float> H2F = convert(\"H2F\", 'C', Float16.class, float.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (int)halffloatVal}. *\/\n+    public static final Conversion<Float16,Integer> H2I = convert(\"H2I\", 'C', Float16.class, int.class, VO_KIND_CAST, VO_ALL);\n+    \/** Convert {@code halffloatVal} to {@code (long)halffloatVal}. *\/\n+    public static final Conversion<Float16,Long> H2L = convert(\"H2L\", 'C', Float16.class, long.class, VO_KIND_CAST, VO_ALL);\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -275,0 +275,3 @@\n+        if (etype == Float16.class) {\n+            etype = short.class;\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShape.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+#if[FP16]\n+import jdk.incubator.vector.Float16;\n+#end[FP16]\n@@ -64,1 +67,3 @@\n-    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withByteAlignment(1);\n+    static final int VECTOR_OPER_TYPE = {#if[FP16]?VECTOR_TYPE_FP16:VECTOR_TYPE_PRIM};\n+\n+    static final ValueLayout.Of$ElemLayout$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withByteAlignment(1);\n@@ -514,0 +519,3 @@\n+#if[FP16]\n+        return e;\n+#else[FP16]    \n@@ -515,0 +523,1 @@\n+#end[FP16]\n@@ -520,0 +529,3 @@\n+#if[FP16]\n+        return Float16.float16ToRawShortBits(Float16.shortBitsToFloat16((short)bits));\n+#else[FP16]\n@@ -521,0 +533,1 @@\n+#end[FP16]\n@@ -591,2 +604,2 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),\n-                        toBits(0.0f), MODE_BROADCAST, vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, species.length(),\n+                        toBits({#if[FP16]?(short) 0:0.0f}), MODE_BROADCAST, vsp,\n@@ -594,1 +607,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, species.length(),\n@@ -727,1 +740,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -762,1 +775,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -817,0 +830,1 @@\n+#if[!FP16]\n@@ -849,0 +863,34 @@\n+#else[!FP16]\n+            case VECTOR_OP_SIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.sin(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_COS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.cos(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_TAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.tan(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_ASIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.asin(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_ACOS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.acos(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_ATAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.atan(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_EXP: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.exp(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_LOG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.log(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_LOG10: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.log10(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_SQRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.sqrt(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_CBRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.cbrt(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_SINH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.sinh(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_COSH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.cosh(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_TANH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.tanh(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_EXPM1: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.expm1(Float16.shortBitsToFloat16(a).doubleValue()))));\n+            case VECTOR_OP_LOG1P: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.log1p(Float16.shortBitsToFloat16(a).doubleValue()))));\n+#end[!FP16]\n@@ -906,1 +954,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -973,1 +1021,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -993,0 +1041,14 @@\n+#if[FP16]\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.subtract(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.multiply(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.divide(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.max(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.min(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b))));\n+#else[FP16]\n@@ -1005,0 +1067,1 @@\n+#end[FP16]\n@@ -1042,0 +1105,1 @@\n+#if[!FP16]\n@@ -1050,0 +1114,8 @@\n+#else[!FP16]\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.atan2(Float16.shortBitsToFloat16(a).floatValue(), Float16.shortBitsToFloat16(b).floatValue()))));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.pow(Float16.shortBitsToFloat16(a).floatValue(), Float16.shortBitsToFloat16(b).floatValue()))));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.float16ToRawShortBits(Float16.valueOf(Math.hypot(Float16.shortBitsToFloat16(a).floatValue(), Float16.shortBitsToFloat16(b).floatValue()))));\n+#end[!FP16]\n@@ -1201,1 +1273,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -1222,1 +1294,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -1306,1 +1378,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -1348,1 +1420,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -1360,0 +1432,4 @@\n+#if[FP16]\n+            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) ->\n+                                        Float16.float16ToRawShortBits(Float16.fma(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b), Float16.shortBitsToFloat16(c))));\n+#else[FP16]\n@@ -1362,0 +1438,1 @@\n+#end[FP16]\n@@ -2390,1 +2467,1 @@\n-                $bitstype$ infbits = ($bitstype$) toBits($Boxtype$.POSITIVE_INFINITY);\n+                $bitstype$ infbits = ($bitstype$) toBits({#if[FP16]?Float16.float16ToRawShortBits($Boxtype$.POSITIVE_INFINITY):$Boxtype$.POSITIVE_INFINITY});\n@@ -2444,1 +2521,1 @@\n-                $bitstype$ infbits = ($bitstype$) toBits($Boxtype$.POSITIVE_INFINITY);\n+                $bitstype$ infbits = ($bitstype$) toBits({#if[FP16]?Float16.float16ToRawShortBits($Boxtype$.POSITIVE_INFINITY):$Boxtype$.POSITIVE_INFINITY});\n@@ -2480,1 +2557,1 @@\n-            opc, getClass(), maskType, $type$.class, length(),\n+            opc, getClass(), maskType, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2502,1 +2579,1 @@\n-            opc, getClass(), maskType, $type$.class, length(),\n+            opc, getClass(), maskType, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2515,1 +2592,1 @@\n-    private static boolean compareWithOp(int cond, $type$ a, $type$ b) {\n+    private static boolean compareWithOp(int cond, $carriertype$ a, $carriertype$ b) {\n@@ -2517,0 +2594,8 @@\n+#if[FP16]\n+            case BT_eq -> Float.float16ToFloat(a) == Float.float16ToFloat(b);\n+            case BT_ne -> Float.float16ToFloat(a) != Float.float16ToFloat(b);\n+            case BT_lt -> Float.float16ToFloat(a) < Float.float16ToFloat(b);\n+            case BT_le -> Float.float16ToFloat(a) <= Float.float16ToFloat(b);\n+            case BT_gt -> Float.float16ToFloat(a) > Float.float16ToFloat(b);\n+            case BT_ge -> Float.float16ToFloat(a) >= Float.float16ToFloat(b);\n+#else[FP16]\n@@ -2523,0 +2608,1 @@\n+#end[FP16]\n@@ -2637,1 +2723,1 @@\n-            getClass(), maskType, $type$.class, length(),\n+            getClass(), maskType, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2654,1 +2740,1 @@\n-            getClass(), $type$.class, length(),\n+            getClass(), $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2663,1 +2749,1 @@\n-                return v.add(sc == 1 ? iota : iota.mul(sc));\n+                return v.add(sc == 1 ? iota : iota.mul({#if[FP16]?Float16.float16ToRawShortBits(Float16.valueOf(sc)):sc}));\n@@ -2868,1 +2954,1 @@\n-            getClass(), shuffletype, null, $type$.class, length(),\n+            getClass(), shuffletype, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2894,1 +2980,1 @@\n-                   getClass(), shuffletype, masktype, $type$.class, length(),\n+                   getClass(), shuffletype, masktype, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2921,1 +3007,1 @@\n-                getClass(), shuffletype, null, $type$.class, length(),\n+                getClass(), shuffletype, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2929,1 +3015,1 @@\n-                getClass(), shuffletype, null, $type$.class, length(),\n+                getClass(), shuffletype, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -2958,0 +3044,3 @@\n+#if[FP16]\n+        ShortVector idx = convert(VectorOperators.H2S, 0).reinterpretAsShorts();\n+#end[FP16]\n@@ -2991,1 +3080,1 @@\n-                                                        $type$.class, length(), this, m,\n+                                                        $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -3010,1 +3099,1 @@\n-                                                        $type$.class, length(), this, m,\n+                                                        $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(), this, m,\n@@ -3025,1 +3114,1 @@\n-        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), null, $type$.class,\n+        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE,\n@@ -3045,1 +3134,1 @@\n-        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), masktype, $type$.class,\n+        return ($Type$Vector)VectorSupport.selectFromOp(getClass(), masktype, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE,\n@@ -3063,1 +3152,1 @@\n-        return VectorSupport.selectFromTwoVectorOp(getClass(), $type$.class, length(), this, v1, v2,\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(), this, v1, v2,\n@@ -3412,1 +3501,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -3430,1 +3519,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, length(),\n@@ -3441,0 +3530,10 @@\n+#if[FP16]\n+            case VECTOR_OP_ADD: return (v, m) ->\n+                    toBits(v.rOp(($type$)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.add(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));\n+            case VECTOR_OP_MUL: return (v, m) ->\n+                    toBits(v.rOp(($type$)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.multiply(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));\n+            case VECTOR_OP_MIN: return (v, m) ->\n+                    toBits(v.rOp(($type$)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.min(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));\n+            case VECTOR_OP_MAX: return (v, m) ->\n+                    toBits(v.rOp(($type$)0, m, (i, a, b) -> Float16.float16ToRawShortBits(Float16.max(Float16.shortBitsToFloat16(a), Float16.shortBitsToFloat16(b)))));\n+#else[FP16]\n@@ -3449,0 +3548,1 @@\n+#end[FP16]\n@@ -3470,2 +3570,2 @@\n-    private static final $type$ MIN_OR_INF = $Boxtype$.NEGATIVE_INFINITY;\n-    private static final $type$ MAX_OR_INF = $Boxtype$.POSITIVE_INFINITY;\n+    private static final $type$ MIN_OR_INF = {#if[FP16]?Float16.float16ToRawShortBits($Boxtype$.NEGATIVE_INFINITY):$Boxtype$.NEGATIVE_INFINITY};\n+    private static final $type$ MAX_OR_INF = {#if[FP16]?Float16.float16ToRawShortBits($Boxtype$.POSITIVE_INFINITY):$Boxtype$.POSITIVE_INFINITY};\n@@ -3608,1 +3708,1 @@\n-            $type$ e = a[i];\n+            $type$ e = {#if[FP16]?Float16.shortBitsToFloat16(a[i]).shortValue():a[i]};\n@@ -3649,1 +3749,1 @@\n-            res[i] = (double) a[i];\n+            res[i] = (double) {#if[FP16]?Float16.shortBitsToFloat16(a[i]).doubleValue():a[i]};\n@@ -3790,1 +3890,1 @@\n-            vectorType, null, $type$.class, vsp.laneCount(),\n+            vectorType, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3798,1 +3898,1 @@\n-            vectorType, null, $type$.class, vsp.laneCount(),\n+            vectorType, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -3851,1 +3951,1 @@\n-            vectorType, null, $type$.class, vsp.laneCount(),\n+            vectorType, null, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4350,1 +4450,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4477,1 +4577,1 @@\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), null, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4570,1 +4670,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4732,1 +4832,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4946,1 +5046,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -4963,1 +5063,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5021,1 +5121,1 @@\n-            vectorType, maskClass, $type$.class, vsp.laneCount(),\n+            vectorType, maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5029,1 +5129,1 @@\n-            vectorType, maskClass, $type$.class, vsp.laneCount(),\n+            vectorType, maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5084,1 +5184,1 @@\n-            vectorType, maskClass, $type$.class, vsp.laneCount(),\n+            vectorType, maskClass, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5102,1 +5202,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5119,1 +5219,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5136,1 +5236,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5153,1 +5253,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5168,1 +5268,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5184,1 +5284,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5202,1 +5302,1 @@\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5219,1 +5319,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5275,1 +5375,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5300,1 +5400,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5314,1 +5414,1 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5331,1 +5431,1 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5350,1 +5450,1 @@\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            vsp.vectorType(), maskClass, vsp.carrierType(), vsp.elementType(), VECTOR_OPER_TYPE, vsp.laneCount(),\n@@ -5480,1 +5580,5 @@\n-    {#if[byteOrShort]?Vector<?>:$Fptype$Vector}\n+#if[FP16]\n+    $Type$Vector\n+#else[FP16]\n+    {#if[byte]?Vector<?>:$Fptype$Vector}\n+#end[FP16]\n@@ -5565,1 +5669,1 @@\n-            super(shape, LaneType.of($type$.class),\n+            super(shape, LaneType.of($elemtype$.class),\n@@ -5573,0 +5677,13 @@\n+        @ForceInline\n+        final Class<?> carrierType() {\n+            return $carriertype$.class;\n+        }\n+\n+        @ForceInline\n+        final int operType() {\n+            if ($elemtype$.class.equals(Float16.class)) {\n+                return VECTOR_TYPE_FP16;\n+            }\n+            return VECTOR_TYPE_PRIM;\n+        }\n+\n@@ -5576,1 +5693,1 @@\n-            return $type$.class;\n+            return $elemtype$.class;\n@@ -5605,1 +5722,1 @@\n-                    vectorType, $type$.class, laneCount,\n+                    vectorType, $carriertype$.class, $elemtype$.class, VECTOR_OPER_TYPE, laneCount,\n@@ -5659,0 +5776,7 @@\n+#if[FP16]\n+                $type$ v = Float16.float16ToRawShortBits(Float16.valueOf(lv));\n+                va[i] = v;\n+                if (Float16.valueOf(lv).intValue() != lv) {\n+                    throw badElementBits(lv, v);\n+                }\n+#else[FP16]\n@@ -5664,0 +5788,1 @@\n+#end[FP16]\n@@ -5899,1 +6024,1 @@\n-        = ($Type$Species) VectorSpecies.ofPreferred($type$.class);\n+        = ($Type$Species) VectorSpecies.ofPreferred($elemtype$.class);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":190,"deletions":65,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-    static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+    static final Class<$Carriertype$> CTYPE = $carriertype$.class; \/\/ carrier type used by the JVM\n+\n+    static final Class<$Boxtype$> ETYPE = $elemtype$.class; \/\/ vector element type used by the JVM\n+\n+    static final int VECTOR_OPER_TYPE = {#if[FP16]?VECTOR_TYPE_FP16:VECTOR_TYPE_PRIM};\n@@ -91,0 +95,3 @@\n+    @ForceInline\n+    final Class<$Carriertype$> carrierType() { return CTYPE; }\n+\n@@ -93,1 +100,1 @@\n-    public final Class<$Boxtype$> elementType() { return $type$.class; }\n+    public final Class<$Boxtype$> elementType() { return ETYPE; }\n@@ -562,0 +569,18 @@\n+#if[!16L]\n+            case 16: bits = laneHelper(16); break;\n+            case 17: bits = laneHelper(17); break;\n+            case 18: bits = laneHelper(18); break;\n+            case 19: bits = laneHelper(19); break;\n+            case 20: bits = laneHelper(20); break;\n+            case 21: bits = laneHelper(21); break;\n+            case 22: bits = laneHelper(22); break;\n+            case 23: bits = laneHelper(23); break;\n+            case 24: bits = laneHelper(24); break;\n+            case 25: bits = laneHelper(25); break;\n+            case 26: bits = laneHelper(26); break;\n+            case 27: bits = laneHelper(27); break;\n+            case 28: bits = laneHelper(28); break;\n+            case 29: bits = laneHelper(29); break;\n+            case 30: bits = laneHelper(30); break;\n+            case 31: bits = laneHelper(31); break;\n+#end[!16L]\n@@ -574,1 +599,1 @@\n-        return $Type$.$bitstype$BitsTo$Fptype$(bits);\n+        return {#if[FP16]?bits:$Type$.$bitstype$BitsTo$Fptype$(bits)};\n@@ -580,1 +605,1 @@\n-                     VCLASS, ETYPE, VLENGTH,\n+                     VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -584,1 +609,1 @@\n-                     return (long)$Type$.$type$ToRaw$Bitstype$Bits(vecarr[ix]);\n+                     return {#if[FP16]?vecarr[ix]:(long)$Type$.$type$ToRaw$Bitstype$Bits(vecarr[ix])};\n@@ -613,0 +638,18 @@\n+#if[!16L]\n+            case 16: return withLaneHelper(16, e);\n+            case 17: return withLaneHelper(17, e);\n+            case 18: return withLaneHelper(18, e);\n+            case 19: return withLaneHelper(19, e);\n+            case 20: return withLaneHelper(20, e);\n+            case 21: return withLaneHelper(21, e);\n+            case 22: return withLaneHelper(22, e);\n+            case 23: return withLaneHelper(23, e);\n+            case 24: return withLaneHelper(24, e);\n+            case 25: return withLaneHelper(25, e);\n+            case 26: return withLaneHelper(26, e);\n+            case 27: return withLaneHelper(27, e);\n+            case 28: return withLaneHelper(28, e);\n+            case 29: return withLaneHelper(29, e);\n+            case 30: return withLaneHelper(30, e);\n+            case 31: return withLaneHelper(31, e);\n+#end[!16L]\n@@ -630,2 +673,2 @@\n-                                VCLASS, ETYPE, VLENGTH,\n-                                this, i, (long)$Type$.$type$ToRaw$Bitstype$Bits(e),\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                this, i, (long){#if[FP16]?e:$Type$.$type$ToRaw$Bitstype$Bits(e)},\n@@ -634,1 +677,1 @@\n-                                    res[ix] = $Type$.$bitstype$BitsTo$Type$(($bitstype$)bits);\n+                                    res[ix] = {#if[FP16]?e:$Type$.$bitstype$BitsTo$Type$(($bitstype$)bits)};\n@@ -733,1 +776,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -835,1 +878,1 @@\n-                                VCLASS, ETYPE, VLENGTH,\n+                                VCLASS, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -849,1 +892,1 @@\n-        static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+        static final Class<$Carriertype$> CTYPE = $carriertype$.class; \/\/ used by the JVM\n@@ -951,1 +994,1 @@\n-                $masktype$.class, $type$.class, VLENGTH, offset, limit,\n+                $masktype$.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, offset, limit,\n@@ -967,2 +1010,3 @@\n-                $vectortype$.class, $masktype$.class, ETYPE, VLENGTH, null, this,\n-                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+                $vectortype$.class, $masktype$.class, CTYPE, ETYPE, VECTOR_OPER_TYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT,\n+                {#if[FP16]?Float16.float16ToShortBits(Float16.valueOf(m1.trueCount())):m1.trueCount()}));\n@@ -979,1 +1023,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $bitstype$.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -989,1 +1033,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -999,1 +1043,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -1009,2 +1053,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $bitstype$.class, VLENGTH, this,\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $bitstype$.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> trueCountHelper(m.getBits()));\n@@ -1016,2 +1061,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $bitstype$.class, VLENGTH, this,\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $bitstype$.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> firstTrueHelper(m.getBits()));\n@@ -1023,2 +1069,3 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $bitstype$.class, VLENGTH, this,\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $bitstype$.class, ETYPE,\n+                                                            VECTOR_OPER_TYPE, VLENGTH, this,\n+                                                            (m) -> lastTrueHelper(m.getBits()));\n@@ -1033,1 +1080,2 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, $masktype$.class, $bitstype$.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, $masktype$.class, $bitstype$.class, ETYPE,\n+                                                      VECTOR_OPER_TYPE, VLENGTH, this,\n@@ -1043,1 +1091,1 @@\n-            return VectorSupport.extract($masktype$.class, $type$.class, VLENGTH,\n+            return VectorSupport.extract($masktype$.class, $type$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -1052,3 +1100,3 @@\n-            return VectorSupport.test(BT_ne, $masktype$.class, $bitstype$.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> anyTrueHelper((($masktype$)m).getBits()));\n+            return VectorSupport.test(BT_ne, $masktype$.class, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> anyTrueHelper((($masktype$)m).getBits()));\n@@ -1060,3 +1108,3 @@\n-            return VectorSupport.test(BT_overflow, $masktype$.class, $bitstype$.class, VLENGTH,\n-                                         this, vspecies().maskAll(true),\n-                                         (m, __) -> allTrueHelper((($masktype$)m).getBits()));\n+            return VectorSupport.test(BT_overflow, $masktype$.class, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n+                                      this, vspecies().maskAll(true),\n+                                      (m, __) -> allTrueHelper((($masktype$)m).getBits()));\n@@ -1068,1 +1116,1 @@\n-            return VectorSupport.fromBitsCoerced($masktype$.class, $bitstype$.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced($masktype$.class, $bitstype$.class, ETYPE, VECTOR_OPER_TYPE, VLENGTH,\n@@ -1096,1 +1144,1 @@\n-        static final Class<$Boxbitstype$> ETYPE = $bitstype$.class; \/\/ used by the JVM\n+        static final Class<$Boxbitstype$> CTYPE = $bitstype$.class; \/\/ used by the JVM\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":81,"deletions":33,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-for type in byte short int long float double\n+for type in byte short int long float double halffloat\n@@ -58,0 +58,1 @@\n+\n@@ -60,0 +61,8 @@\n+\n+  case $type in\n+    halffloat)\n+       type=short\n+       TYPE=SHORT\n+       ;;\n+  esac\n+\n@@ -65,0 +74,1 @@\n+  ElemLayout=$Type\n@@ -69,0 +79,1 @@\n+  maskbitstype=$type\n@@ -75,0 +86,4 @@\n+  carriertype=$type\n+  Carriertype=$Type\n+  elemtype=$type\n+  FPtype=$type\n@@ -76,2 +91,2 @@\n-  case $type in\n-    byte)\n+  case $Type in\n+    Byte)\n@@ -82,1 +97,4 @@\n-    short)\n+    Short)\n+      fptype=halffloat\n+      Fptype=Halffloat\n+      Boxfptype=Halffloat\n@@ -87,1 +105,1 @@\n-    int)\n+    Int)\n@@ -89,0 +107,1 @@\n+      Carriertype=Integer\n@@ -97,1 +116,1 @@\n-    long)\n+    Long)\n@@ -104,1 +123,1 @@\n-    float)\n+    Float)\n@@ -107,0 +126,1 @@\n+      maskbitstype=int\n@@ -111,0 +131,1 @@\n+      FPtype=FP32\n@@ -112,1 +133,1 @@\n-    double)\n+    Double)\n@@ -115,0 +136,1 @@\n+      maskbitstype=long\n@@ -119,0 +141,16 @@\n+      FPtype=FP64\n+      ;;\n+    Halffloat)\n+      kind=FP\n+      bitstype=short\n+      maskbitstype=short\n+      Bitstype=Short\n+      Boxbitstype=Short\n+      sizeInBytes=2\n+      carriertype=short\n+      Carriertype=Short\n+      FPtype=FP16\n+      Boxtype=Float16\n+      elemtype=Float16\n+      ElemLayout=Short\n+      args=\"$args -KbyteOrShort -KshortOrFP -KshortOrHalffloat\"\n@@ -121,0 +159,1 @@\n+   \n@@ -122,2 +161,2 @@\n-  args=\"$args -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype\"\n-  args=\"$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype\"\n+  args=\"$args -K$FPtype -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype\"\n+  args=\"$args -DElemLayout=$ElemLayout -Dbitstype=$bitstype -Dmaskbitstype=$maskbitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype\"\n@@ -126,0 +165,1 @@\n+  args=\"$args -Dcarriertype=$carriertype -Delemtype=$elemtype -DCarriertype=$Carriertype\"\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/gen-src.sh","additions":51,"deletions":11,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -361,2 +361,12 @@\n-            List<? extends DocTree> ref2 = transform(tree.reference);\n-            return (equal(ref2, tree.getReference()))\n+            \/\/ Some extra work is required to accommodate various forms of @see tags, as a\n+            \/\/ leading reference affects the position of the label following it (JDK-8356411),\n+            var ref = tree.reference;\n+            var hasReference = !ref.isEmpty() && ref.getFirst().getKind() == DocTree.Kind.REFERENCE;\n+            List<DCTree> transformed = new ArrayList<>();\n+            if (hasReference) {\n+                transformed.add(ref.getFirst());\n+                transformed.addAll(transform(ref.subList(1, ref.size())));\n+            } else {\n+                transformed.addAll(transform(ref));\n+            }\n+            return (equal(ref, transformed))\n@@ -364,1 +374,1 @@\n-                    : m.at(tree.pos).newSeeTree(ref2);\n+                    : m.at(tree.pos).newSeeTree(transformed);\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/markdown\/MarkdownTransformer.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -178,0 +178,2 @@\n+        FPHP,\n+        ASIMDHP,\n@@ -187,2 +189,0 @@\n-        FPHP,\n-        ASIMDHP,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/aarch64\/AArch64.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -189,1 +189,4 @@\n-                            result.getCompiler();\n+                            \/\/ EagerJVMCI only applies to JVMCI when used by the CompileBroker.\n+                            if (result.getCompilerToVM().isCompilerThread()) {\n+                                result.getCompiler();\n+                            }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -52,1 +50,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jartool\/share\/classes\/module-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -879,0 +879,5 @@\n+                    \/\/ If the file exists, remove it from all entries in entriesInSF\n+                    for (var signed : entriesInSF.values()) {\n+                        signed.remove(name);\n+                    }\n+\n@@ -893,3 +898,0 @@\n-                        for (var signed : entriesInSF.values()) {\n-                            signed.remove(name);\n-                        }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -423,1 +423,2 @@\n-                    file = createTemporaryFile(\"tmpJar\", \".jar\");\n+                    tmpFile = createTemporaryFile(\"tmpJar\", \".jar\");\n+                    file = tmpFile;\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -330,0 +330,2 @@\n+        copyResource(DocPaths.MOON_SVG, DocPaths.RESOURCE_FILES.resolve(DocPaths.MOON_SVG), true);\n+        copyResource(DocPaths.SUN_SVG, DocPaths.RESOURCE_FILES.resolve(DocPaths.SUN_SVG), true);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,0 +117,5 @@\n+    static final HtmlId THEME_BUTTON = HtmlId.of(\"theme-button\");\n+    static final HtmlId THEME_DARK = HtmlId.of(\"theme-dark\");\n+    static final HtmlId THEME_LIGHT = HtmlId.of(\"theme-light\");\n+    static final HtmlId THEME_OS = HtmlId.of(\"theme-os\");\n+    static final HtmlId THEME_PANEL = HtmlId.of(\"theme-panel\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+                addThemeSwitcher(target);\n@@ -151,0 +152,1 @@\n+                addThemeSwitcher(target);\n@@ -169,0 +171,1 @@\n+                addThemeSwitcher(target);\n@@ -187,0 +190,1 @@\n+                addThemeSwitcher(target);\n@@ -211,0 +215,1 @@\n+                addThemeSwitcher(target);\n@@ -229,0 +234,1 @@\n+                addThemeSwitcher(target);\n@@ -271,0 +277,1 @@\n+                addThemeSwitcher(target);\n@@ -288,0 +295,1 @@\n+                addThemeSwitcher(target);\n@@ -314,0 +322,1 @@\n+                addThemeSwitcher(target);\n@@ -320,4 +329,0 @@\n-    private void addContentToList(List<Content> listContents, Content source) {\n-        listContents.add(HtmlTree.LI(source));\n-    }\n-\n@@ -495,0 +500,11 @@\n+    private void addThemeSwitcher(Content target) {\n+        var selectTheme = contents.getContent(\"doclet.theme.select_theme\");\n+        target.add(HtmlTree.LI(HtmlTree.BUTTON(HtmlIds.THEME_BUTTON)\n+                .add(HtmlTree.IMG(pathToRoot.resolve(DocPaths.RESOURCE_FILES).resolve(DocPaths.SUN_SVG),\n+                        selectTheme.toString()).addStyle(HtmlIds.THEME_LIGHT.name()))\n+                .add(HtmlTree.IMG(pathToRoot.resolve(DocPaths.RESOURCE_FILES).resolve(DocPaths.MOON_SVG),\n+                        selectTheme.toString()).addStyle(HtmlIds.THEME_DARK.name()))\n+                .put(HtmlAttr.ARIA_LABEL, selectTheme.toString())\n+                .put(HtmlAttr.TITLE, selectTheme.toString())));\n+    }\n+\n@@ -548,0 +564,1 @@\n+\n@@ -560,0 +577,16 @@\n+        var selectTheme = contents.getContent(\"doclet.theme.select_theme\");\n+        subNavContent.add(HtmlTree.DIV(HtmlIds.THEME_PANEL)\n+                .add(HtmlTree.DIV(selectTheme))\n+                .add(HtmlTree.DIV(HtmlTree.LABEL(HtmlIds.THEME_LIGHT.name(), Text.EMPTY)\n+                                .add(HtmlTree.INPUT(HtmlAttr.InputType.RADIO, HtmlIds.THEME_LIGHT)\n+                                        .put(HtmlAttr.NAME, \"theme\").put(HtmlAttr.VALUE, HtmlIds.THEME_LIGHT.name()))\n+                                .add(HtmlTree.SPAN(contents.getContent(\"doclet.theme.light\"))))\n+                        .add(HtmlTree.LABEL(HtmlIds.THEME_DARK.name(), Text.EMPTY)\n+                                .add(HtmlTree.INPUT(HtmlAttr.InputType.RADIO, HtmlIds.THEME_DARK)\n+                                        .put(HtmlAttr.NAME, \"theme\").put(HtmlAttr.VALUE, HtmlIds.THEME_DARK.name()))\n+                                .add(HtmlTree.SPAN(contents.getContent(\"doclet.theme.dark\"))))\n+                        .add(HtmlTree.LABEL(HtmlIds.THEME_OS.name(), Text.EMPTY)\n+                                .add(HtmlTree.INPUT(HtmlAttr.InputType.RADIO, HtmlIds.THEME_OS)\n+                                        .put(HtmlAttr.NAME, \"theme\").put(HtmlAttr.VALUE, HtmlIds.THEME_OS.name()))\n+                                .add(HtmlTree.SPAN(contents.getContent(\"doclet.theme.system\"))))));\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Navigation.java","additions":37,"deletions":4,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -11,3 +11,3 @@\n-    <path d=\"M66.37 55.005C64.415 58.958 60.147 63.321 56.153 66l32.478 33.456L99.377 88.99Z\" style=\"baseline-shift:baseline;display:inline;overflow:visible;opacity:1;vector-effect:none;fill:#1a73a8;stop-color:#000;stop-opacity:1\"\/>\n-    <circle cx=\"35.072\" cy=\"35.072\" r=\"30.635\" style=\"fill:none;fill-opacity:1;stroke:#1a73a8;stroke-width:8;stroke-dasharray:none;stroke-opacity:1\"\/>\n-<\/svg>\n+    <path d=\"M66.37 55.005C64.415 58.958 60.147 63.321 56.153 66l32.478 33.456L99.377 88.99Z\" style=\"fill:#1a73a8\"\/>\n+    <circle cx=\"35.072\" cy=\"35.072\" r=\"30.635\" style=\"fill:none;stroke:#1a73a8;stroke-width:8\"\/>\n+<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/glass.svg","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,0 +68,185 @@\n+body.theme-dark {\n+    .hljs-title.function_,\n+    .hljs-template-variable {\n+        color: #66bcce;\n+    }\n+    .hljs-code,\n+    .hljs-comment,\n+    .hljs-quote {\n+        color:#9d9d9d;\n+        font-style: italic;\n+    }\n+    .hljs-meta {\n+        color: #836F00;\n+    }\n+    .hljs-symbol,\n+    .hljs-template-tag,\n+    .hljs-keyword,\n+    .hljs-literal,\n+    .hljs-name,\n+    .hljs-built_in,\n+    .hljs-char.escape_ {\n+        color: #88aece;\n+    }\n+    .hljs-variable,\n+    .hljs-property,\n+    .hljs-attr,\n+    .hljs-section {\n+        color: #c59bc1;\n+    }\n+    .hljs-attribute {\n+        color:  #c59bc1;\n+    }\n+    .hljs-regexp,\n+    .hljs-number {\n+        color: #cfe374;\n+    }\n+    .hljs-link {\n+        color: #b5bd68;\n+    }\n+    .hljs-string {\n+        color: #b5bd68;\n+    }\n+    .hljs-doctag {\n+        text-decoration: underline;\n+    }\n+    .hljs-emphasis {\n+        font-style: italic;\n+    }\n+    .hljs-strong {\n+        font-weight: bold;\n+    }\n+    .hljs-subst,\n+    .hljs-title,\n+    .hljs-params,\n+    .hljs-bullet,\n+    .hljs-formula,\n+    .hljs-tag,\n+    .hljs-type {\n+        \/* ignored *\/\n+    }\n+}\n+\n+@media (prefers-color-scheme: dark) {\n+    .hljs-title.function_,\n+    .hljs-template-variable {\n+        color: #66bcce;\n+    }\n+    .hljs-code,\n+    .hljs-comment,\n+    .hljs-quote {\n+        color:#9d9d9d;\n+        font-style: italic;\n+    }\n+    .hljs-meta {\n+        color: #836F00;\n+    }\n+    .hljs-symbol,\n+    .hljs-template-tag,\n+    .hljs-keyword,\n+    .hljs-literal,\n+    .hljs-name,\n+    .hljs-built_in,\n+    .hljs-char.escape_ {\n+        color: #88aece;\n+    }\n+    .hljs-variable,\n+    .hljs-property,\n+    .hljs-attr,\n+    .hljs-section {\n+        color: #c59bc1;\n+    }\n+    .hljs-attribute {\n+        color:  #c59bc1;\n+    }\n+    .hljs-regexp,\n+    .hljs-number {\n+        color: #cfe374;\n+    }\n+    .hljs-link {\n+        color: #b5bd68;\n+    }\n+    .hljs-string {\n+        color: #b5bd68;\n+    }\n+    .hljs-doctag {\n+        text-decoration: underline;\n+    }\n+    .hljs-emphasis {\n+        font-style: italic;\n+    }\n+    .hljs-strong {\n+        font-weight: bold;\n+    }\n+    .hljs-subst,\n+    .hljs-title,\n+    .hljs-params,\n+    .hljs-bullet,\n+    .hljs-formula,\n+    .hljs-tag,\n+    .hljs-type {\n+        \/* ignored *\/\n+    }\n+\n+    body.theme-light {\n+        .hljs-title.function_,\n+        .hljs-template-variable {\n+            color: #00738F;\n+        }\n+        .hljs-code,\n+        .hljs-comment,\n+        .hljs-quote {\n+            color: #6e6e71;\n+            font-style: italic;\n+        }\n+        .hljs-meta {\n+            color: #836F00;\n+        }\n+        .hljs-symbol,\n+        .hljs-template-tag,\n+        .hljs-keyword,\n+        .hljs-literal,\n+        .hljs-name,\n+        .hljs-built_in,\n+        .hljs-char.escape_ {\n+            color: #0C40C2;\n+        }\n+        .hljs-variable,\n+        .hljs-property,\n+        .hljs-attr,\n+        .hljs-section {\n+            color: #841191;\n+        }\n+        .hljs-attribute {\n+            color: #164ad9;\n+        }\n+        .hljs-regexp,\n+        .hljs-number {\n+            color: #104BEB;\n+        }\n+        .hljs-link {\n+            color: #47688a;\n+        }\n+        .hljs-string {\n+            color: #008313;\n+        }\n+        .hljs-doctag {\n+            text-decoration: underline;\n+        }\n+        .hljs-emphasis {\n+            font-style: italic;\n+        }\n+        .hljs-strong {\n+            font-weight: bold;\n+        }\n+        .hljs-subst,\n+        .hljs-title,\n+        .hljs-params,\n+        .hljs-bullet,\n+        .hljs-formula,\n+        .hljs-tag,\n+        .hljs-type {\n+            \/* ignored *\/\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/highlight.css","additions":185,"deletions":0,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+ Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ Licensed under the Universal Permissive License v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\/\n+-->\n+\n+<svg version=\"1.1\" viewBox=\"0 0 100 100\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <g fill=\"none\" stroke=\"#fff\" stroke-linecap=\"round\">\n+        <path d=\"m34.834 21.49a29.94 29.94 0 0 1 33.103 12.994 29.94 29.94 0 0 1-2.6651 35.462 29.94 29.94 0 0 1-34.674 7.9004\" stroke-width=\"7.6\"\/>\n+        <path d=\"m35.411 22.187a42.812 42.812 0 0 1-4.6466 55.023\" stroke-width=\"7.6892\"\/>\n+    <\/g>\n+<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/moon.svg","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -331,1 +331,0 @@\n-    \/\/ Make sure current element is visible in breadcrumb navigation on small displays\n@@ -333,3 +332,0 @@\n-    if (subnav && subnav.lastElementChild) {\n-        subnav.lastElementChild.scrollIntoView({ behavior: \"instant\", inline: \"start\", block: \"nearest\" });\n-    }\n@@ -354,0 +350,43 @@\n+    const themeButton = document.querySelector(\"button#theme-button\");\n+    const themePanel = document.querySelector(\"div#theme-panel\");\n+    var themePanelVisible = false;\n+    themeButton.addEventListener(\"click\", e => {\n+        if (!themePanelVisible) {\n+            let {x, y} = themeButton.getBoundingClientRect();\n+            themePanel.style.display = \"block\";\n+            if (window.innerHeight - 85 < y) {\n+                themePanel.style.top = \"\";\n+                themePanel.style.bottom = \"4px\";\n+            } else {\n+                themePanel.style.top = y + (expanded ? 0 : 36) + \"px\";\n+                themePanel.style.bottom = \"\";\n+            }\n+            themePanel.style.left = x + (expanded ? 36 : 0) + \"px\";\n+            themeButton.setAttribute(\"aria-expanded\", \"true\");\n+            themePanelVisible = true;\n+            e.stopPropagation();\n+        }\n+    });\n+    function closeThemePanel(e) {\n+        if (themePanelVisible && (!e || !themePanel.contains(e.target))) {\n+            themePanel.style.removeProperty(\"display\");\n+            themeButton.setAttribute(\"aria-expanded\", \"false\");\n+            themePanelVisible = false;\n+        }\n+    }\n+    themePanel.querySelectorAll(\"input\").forEach(input => {\n+        input.removeAttribute(\"disabled\");\n+        input.addEventListener(\"change\", e => {\n+            setTheme(e.target.value);\n+        })\n+    });\n+    const THEMES = [\"theme-light\", \"theme-dark\", \"theme-os\"];\n+    function setTheme(theme) {\n+        THEMES.forEach(t => {\n+            if (t !== theme) document.body.classList.remove(t);\n+        });\n+        document.body.classList.add(theme);\n+        localStorage.setItem(\"theme\", theme);\n+        document.getElementById(theme).checked = true;\n+    }\n+    setTheme(localStorage.getItem(\"theme\") || THEMES[0]);\n@@ -365,0 +404,1 @@\n+            closeThemePanel();\n@@ -373,0 +413,1 @@\n+            closeThemePanel();\n@@ -392,0 +433,1 @@\n+        closeThemePanel();\n@@ -406,0 +448,1 @@\n+        closeThemePanel();\n@@ -460,0 +503,1 @@\n+    document.querySelector(\"body\").addEventListener(\"click\", closeThemePanel);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js.template","additions":48,"deletions":4,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -426,1 +426,2 @@\n-            .append($(\"<div\/>\")\n+            .append($(\"<a\/>\")\n+                .attr(\"href\", item.indexItem ? pathtoroot + getURL(item.indexItem, item.category) : null)\n@@ -518,1 +519,1 @@\n-            }, 1000);\n+            }, 500);\n@@ -534,0 +535,5 @@\n+            for (var e = event.originalEvent; e != null; e = e.originalEvent) {\n+                if (e.type === \"click\") {\n+                    return;\n+                }\n+            }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/search.js.template","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -196,0 +196,4 @@\n+doclet.theme.select_theme=Select Theme\n+doclet.theme.light=Light\n+doclet.theme.dark=Dark\n+doclet.theme.system=System Setting\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,22 @@\n+    \/* Navigation bar and content area dimensions *\/\n+    --top-nav-height: 44px;\n+    --sub-nav-height: 36px;\n+    --nav-height: calc(var(--top-nav-height) + var(--sub-nav-height));\n+    --max-content-width: 1500px;\n+    --content-margin: 0 auto;\n+    \/* Inline SVG icons for dark theme *\/\n+    --right-svg-dark: url('data:image\/svg+xml; utf8, \\\n+    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"100\" height=\"100\"> \\\n+    <path d=\"m35.763 5.058 38.675 36.885a12.596 12.596 90 0 1 0 18.23L35.763 97.058v-18.32l27.055-25.431a2.975 2.975 90.09 0 0 .007-4.33L35.763 23.38Z\" \\\n+    style=\"fill:%23fff;stroke-width:.285806\" transform=\"translate(-5.292 -1.058)\"\/> \\\n+    <\/svg>');\n+    --glass-svg-dark: url('data:image\/svg+xml; utf8, \\\n+    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 100 100\"> \\\n+    <path d=\"M66.37 55.005C64.415 58.958 60.147 63.321 56.153 66l32.478 33.456L99.377 88.99Z\" style=\"fill:%23a1d3ff\"\/>\\\n+    <circle cx=\"35.072\" cy=\"35.072\" r=\"30.635\" style=\"fill:none;stroke:%23a1d3ff;stroke-width:8\"\/><\/svg>');\n+    --x-svg-dark: url('data:image\/svg+xml; utf8, \\\n+    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 100 100\">\\\n+    <path d=\"m8 8 84 84\" style=\"stroke:%23e0e0e0;stroke-width:15\"\/>\\\n+    <path d=\"M8 92 92 8\" style=\"stroke:%23e0e0e0;stroke-width:15\"\/><\/svg>');\n+}\n+body {\n@@ -37,1 +59,1 @@\n-    --detail-background-color: #ffffff;\n+    --detail-background-color: var(--body-background-color);\n@@ -79,1 +101,1 @@\n-    --search-input-placeholder-color: #909090;\n+    --search-input-placeholder-color: #757575;\n@@ -81,1 +103,2 @@\n-    --search-tag-highlight-color: #ffff66;\n+    --search-tag-background-color: #ffff66;\n+    --search-tag-text-color: var(--block-text-color);\n@@ -89,6 +112,152 @@\n-    \/* Navigation bar dimensions *\/\n-    --top-nav-height: 44px;\n-    --sub-nav-height: 36px;\n-    --nav-height: calc(var(--top-nav-height) + var(--sub-nav-height));\n-    --max-content-width: 1500px;\n-    --content-margin: 0 auto;\n+}\n+\n+body.theme-dark {\n+    --body-text-color: #e8e8e8;\n+    --block-text-color: #e8e8e8;\n+    --body-background-color: #222528;\n+    --section-background-color: var(--body-background-color);\n+    --detail-background-color: var(--body-background-color);\n+    --code-background-color: #303940;\n+    --mark-background-color: #313131;\n+    --detail-block-color: #f4f4f4;\n+    --navbar-background-color: #395A6F;\n+    --navbar-text-color: #ffffff;\n+    --subnav-background-color: #3d454d;\n+    --subnav-link-color: #d8dcdf;\n+    --member-heading-background-color: var(--subnav-background-color);\n+    --selected-background-color: #f8981d;\n+    --selected-text-color: #253441;\n+    --selected-link-color: #4a698a;\n+    --table-header-color: #38444d;\n+    --even-row-color: #222528;\n+    --odd-row-color: #2d3135;\n+    --title-color: #fff;\n+    --link-color: #94badb;\n+    --link-color-active: #ffb45b;\n+    --toc-background-color: #31363c;\n+    --toc-highlight-color: var(--subnav-background-color);\n+    --toc-hover-color: #3f4146;\n+    --snippet-background-color: #2d363c;\n+    --snippet-text-color: var(--block-text-color);\n+    --snippet-highlight-color: #f7c590;\n+    --pre-background-color: var(--snippet-background-color);\n+    --pre-text-color: var(--snippet-text-color);\n+    --border-color: #444444;\n+    --table-border-color: #717171;\n+    --tab-border-radius: 2px 2px 0 0;\n+    --search-input-background-color: #303030;\n+    --search-input-text-color: #d0d0d0;\n+    --search-input-placeholder-color: #979797;\n+    --search-tag-background-color: #c6c61e;\n+    --search-tag-text-color: #282828;\n+    --button-border-color: #909090;\n+    --button-active-filter: brightness(96%);\n+    --button-focus-filter: brightness(104%);\n+    --invalid-tag-background-color: #ffe6e6;\n+    --invalid-tag-text-color: #000000;\n+    div.main-grid img {\n+        filter: invert(100%) brightness(160%);\n+    }\n+}\n+\n+\/*\n+ * Dark theme\n+ *\/\n+@media (prefers-color-scheme: dark) {\n+    body {\n+        --body-text-color: #e8e8e8;\n+        --block-text-color: #e8e8e8;\n+        --body-background-color: #222528;\n+        --section-background-color: var(--body-background-color);\n+        --detail-background-color: var(--body-background-color);\n+        --code-background-color: #303940;\n+        --mark-background-color: #313131;\n+        --detail-block-color: #f4f4f4;\n+        --navbar-background-color: #395A6F;\n+        --navbar-text-color: #ffffff;\n+        --subnav-background-color: #3d454d;\n+        --subnav-link-color: #d8dcdf;\n+        --member-heading-background-color: var(--subnav-background-color);\n+        --selected-background-color: #f8981d;\n+        --selected-text-color: #253441;\n+        --selected-link-color: #4a698a;\n+        --table-header-color: #38444d;\n+        --even-row-color: #222528;\n+        --odd-row-color: #2d3135;\n+        --title-color: #fff;\n+        --link-color: #94badb;\n+        --link-color-active: #ffb45b;\n+        --toc-background-color: #31363c;\n+        --toc-highlight-color: var(--subnav-background-color);\n+        --toc-hover-color: #3f4146;\n+        --snippet-background-color: #2d363c;\n+        --snippet-text-color: var(--block-text-color);\n+        --snippet-highlight-color: #f7c590;\n+        --pre-background-color: var(--snippet-background-color);\n+        --pre-text-color: var(--snippet-text-color);\n+        --border-color: #444444;\n+        --table-border-color: #717171;\n+        --tab-border-radius: 2px 2px 0 0;\n+        --search-input-background-color: #303030;\n+        --search-input-text-color: #d0d0d0;\n+        --search-input-placeholder-color: #979797;\n+        --search-tag-background-color: #c6c61e;\n+        --search-tag-text-color: #282828;\n+        --button-border-color: #909090;\n+        --button-active-filter: brightness(96%);\n+        --button-focus-filter: brightness(104%);\n+        --invalid-tag-background-color: #ffe6e6;\n+        --invalid-tag-text-color: #000000;\n+        div.main-grid img {\n+            filter: invert(100%) brightness(160%);\n+        }\n+    }\n+\n+    body.theme-light {\n+        --body-text-color: #282828;\n+        --block-text-color: #282828;\n+        --body-background-color: #ffffff;\n+        --section-background-color: var(--body-background-color);\n+        --detail-background-color: var(--body-background-color);\n+        --code-background-color: #f5f5f5;\n+        --mark-background-color: #f7f7f7;\n+        --detail-block-color: #f4f4f4;\n+        --navbar-background-color: #4D7A97;\n+        --navbar-text-color: #ffffff;\n+        --subnav-background-color: #dee3e9;\n+        --subnav-link-color: #47688a;\n+        --member-heading-background-color: var(--subnav-background-color);\n+        --selected-background-color: #f8981d;\n+        --selected-text-color: #253441;\n+        --selected-link-color: #4a698a;\n+        --table-header-color: #ebeff4;\n+        --even-row-color: #ffffff;\n+        --odd-row-color: #f0f0f2;\n+        --title-color: #2c4557;\n+        --link-color: #437291;\n+        --link-color-active: #bb7a2a;\n+        --toc-background-color: #f8f8f8;\n+        --toc-highlight-color: var(--subnav-background-color);\n+        --toc-hover-color: #e9ecf0;\n+        --snippet-background-color: #f2f2f4;\n+        --snippet-text-color: var(--block-text-color);\n+        --snippet-highlight-color: #f7c590;\n+        --pre-background-color: var(--snippet-background-color);\n+        --pre-text-color: var(--snippet-text-color);\n+        --border-color: #e6e6e6;\n+        --table-border-color: #000000;\n+        --tab-border-radius: 2px 2px 0 0;\n+        --search-input-background-color: #ffffff;\n+        --search-input-text-color: #000000;\n+        --search-input-placeholder-color: #757575;\n+        --search-tag-background-color: #ffff66;\n+        --search-tag-text-color: var(--block-text-color);\n+        --button-border-color: #b0b8c8;\n+        --button-active-filter: brightness(96%);\n+        --button-focus-filter: brightness(104%);\n+        --invalid-tag-background-color: #ffe6e6;\n+        --invalid-tag-text-color: #000000;\n+        div.main-grid img {\n+            filter: none;\n+        }\n+    }\n@@ -189,1 +358,1 @@\n-    padding:0 20px;\n+    padding:0 20px 0 10px;\n@@ -218,0 +387,1 @@\n+    position: relative;\n@@ -239,0 +409,62 @@\n+button#theme-button {\n+    position: relative;\n+    top: -9.5px;\n+    width: 32px;\n+    height: 32px;\n+    padding: 6px;\n+    margin-left: -6px;\n+    background-color: transparent;\n+    border: 1px solid transparent;\n+    border-radius: 6px;\n+    cursor: pointer;\n+}\n+button#theme-button:hover,\n+button#theme-button:focus-visible {\n+    border: 1px solid var(--button-border-color);\n+}\n+button#theme-button img {\n+    display: none;\n+    width: 18px;\n+}\n+body.theme-light button#theme-button img.theme-light {\n+    display: inline;\n+}\n+body.theme-dark button#theme-button img.theme-dark {\n+    display: inline;\n+}\n+@media (prefers-color-scheme: dark) {\n+    body.theme-os button#theme-button img.theme-dark {\n+        display: inline;\n+    }\n+}\n+@media (prefers-color-scheme: light) {\n+    body.theme-os button#theme-button img.theme-light {\n+        display: inline;\n+    }\n+}\n+div#theme-panel {\n+    display: none;\n+    position: fixed;\n+    z-index: 8;\n+    background-color: var(--toc-background-color);\n+    color: var(--body-text-color);\n+    padding: 4px;\n+    white-space: nowrap;\n+    border: 1px solid var(--border-color);\n+    border-radius: 4px;\n+    box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);\n+}\n+div#theme-panel div:first-child {\n+    font-weight: bold;\n+    font-size: 16px;\n+}\n+div#theme-panel div {\n+    padding: 8px;\n+}\n+div#theme-panel label {\n+    margin-right: 8px;\n+    cursor: pointer;\n+}\n+div#theme-panel input {\n+    margin-right: 4px;\n+}\n@@ -255,1 +487,0 @@\n-    overflow:hidden;\n@@ -257,1 +488,1 @@\n-    height: var(--sub-nav-height);\n+    min-height: var(--sub-nav-height);\n@@ -261,2 +492,1 @@\n-    line-height: 1.8;\n-    display: inline-flex;\n+    line-height: 1.7;\n@@ -264,3 +494,0 @@\n-    scroll-snap-type: x mandatory;\n-    scroll-padding-left: 13px;\n-    scrollbar-width: none;\n@@ -268,2 +495,2 @@\n-    white-space: nowrap;\n-    margin:0;\n+    margin: 4px 0;\n+    min-height: 28px;\n@@ -276,1 +503,3 @@\n-    scroll-snap-align: start;\n+    display: inline-block;\n+    padding: 2px 0;\n+    margin-right: -4px;\n@@ -284,0 +513,11 @@\n+body.theme-dark ol.sub-nav-list li:not(:first-child) {\n+    background-image: var(--right-svg-dark);\n+}\n+@media (prefers-color-scheme: dark) {\n+    ol.sub-nav-list li:not(:first-child) {\n+        background-image: var(--right-svg-dark);\n+    }\n+    body.theme-light ol.sub-nav-list li:not(:first-child) {\n+        background-image: url(\"right.svg\");\n+    }\n+}\n@@ -293,1 +533,2 @@\n-    margin: 0 15px;\n+    margin: 4.5px 15px auto 5px;\n+    padding: 1px 0;\n@@ -365,1 +606,1 @@\n-    filter: invert(100%) sepia(4%) saturate(98%) hue-rotate(212deg) brightness(160%) contrast(160%);\n+    filter: invert(100%) brightness(160%);\n@@ -997,1 +1238,1 @@\n-.ui-autocomplete > li > div {\n+.ui-autocomplete > li > a {\n@@ -1001,1 +1242,1 @@\n-.ui-autocomplete > li.result-item > div {\n+.ui-autocomplete > li.result-item > a {\n@@ -1012,0 +1253,1 @@\n+    color: var(--block-text-color);\n@@ -1018,1 +1260,1 @@\n-    color: #404040;\n+    color: var(--block-text-color);\n@@ -1025,0 +1267,1 @@\n+.ui-menu .ui-state-active .search-result-label,\n@@ -1026,1 +1269,1 @@\n-    color: #383838;\n+    color: var(--selected-text-color);\n@@ -1045,0 +1288,11 @@\n+body.theme-dark input[type=\"text\"] {\n+    background-image: var(--glass-svg-dark);\n+}\n+@media (prefers-color-scheme: dark) {\n+    input[type=\"text\"] {\n+        background-image: var(--glass-svg-dark);\n+    }\n+    body.theme-light input[type=\"text\"] {\n+        background-image: url('glass.svg');\n+    }\n+}\n@@ -1072,0 +1326,15 @@\n+body.theme-dark input#reset-search,\n+body.theme-dark input.reset-filter,\n+body.theme-dark input#page-search-reset {\n+    background-image: var(--x-svg-dark);\n+}\n+@media (prefers-color-scheme: dark) {\n+    input#reset-search, input.reset-filter, input#page-search-reset {\n+        background-image: var(--x-svg-dark);\n+    }\n+    body.theme-light input#reset-search,\n+    body.theme-light input.reset-filter,\n+    body.theme-light input#page-search-reset {\n+        background-image: url('x.svg');\n+    }\n+}\n@@ -1104,0 +1373,1 @@\n+    color: #282828;\n@@ -1112,1 +1382,2 @@\n-    background-color:var(--search-tag-highlight-color);\n+    background-color:var(--search-tag-background-color);\n+    color:var(--search-tag-text-color);\n@@ -1116,1 +1387,2 @@\n-    background-color: var(--search-tag-highlight-color);\n+    background-color: var(--search-tag-background-color);\n+    color:var(--search-tag-text-color);\n@@ -1163,0 +1435,1 @@\n+    color: var(--selected-text-color);\n@@ -1171,1 +1444,0 @@\n-    color: #404040;\n@@ -1505,11 +1777,0 @@\n-    nav.toc a:link, nav.toc a:visited {\n-        text-decoration:none;\n-        color:var(--link-color);\n-    }\n-    nav.toc a[href]:hover, nav.toc a[href]:focus {\n-        text-decoration:none;\n-        color:var(--link-color-active);\n-    }\n-    :root {\n-        scroll-behavior: auto;\n-    }\n@@ -1587,1 +1848,1 @@\n-    .ui-autocomplete > li > div,\n+    .ui-autocomplete > li > a,\n@@ -1589,1 +1850,1 @@\n-    .ui-autocomplete > li.result-item > div {\n+    .ui-autocomplete > li.result-item > a {\n@@ -1606,1 +1867,0 @@\n-        padding: 0 16px;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":303,"deletions":43,"binary":false,"changes":346,"status":"modified"},{"patch":"@@ -0,0 +1,22 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+ Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ Licensed under the Universal Permissive License v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\/\n+-->\n+\n+<svg version=\"1.1\" viewBox=\"0 0 100 100\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <g fill=\"none\" stroke=\"#fff\" stroke-linecap=\"round\">\n+        <circle cx=\"49.932\" cy=\"50.193\" r=\"24.947\" stroke-width=\"7.6\"\/>\n+        <path d=\"m50.882 5.5255v10.822\" stroke-width=\"7.533\"\/>\n+        <path d=\"m24.315 74.134-7.6524 7.6524\" stroke-width=\"7.533\"\/>\n+        <path d=\"m75.461 73.989 7.6524 7.6524\" stroke-width=\"7.533\"\/>\n+        <path d=\"m18.223 16.442c7.6524 7.6524 7.6524 7.6524 7.6524 7.6524\" stroke-width=\"7.533\"\/>\n+        <path d=\"m83.27 19.68-7.6524 7.6524\" stroke-width=\"7.533\"\/>\n+        <path d=\"m50.014 84.417v10.822\" stroke-width=\"7.533\"\/>\n+        <path d=\"m95.53 49.53h-10.822\" stroke-width=\"7.533\"\/>\n+        <path d=\"m15.446 49.162h-10.822\" stroke-width=\"7.533\"\/>\n+    <\/g>\n+<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/sun.svg","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -11,3 +11,3 @@\n-    <path d=\"m8 8 84 84\" style=\"fill:#c6c6c6;fill-opacity:1;stroke:#505050;stroke-width:15;stroke-dasharray:none;stroke-opacity:1\"\/>\n-    <path d=\"M8 92 92 8\" style=\"fill:#000;stroke:#505050;stroke-width:15;stroke-dasharray:none;stroke-opacity:1\"\/>\n-<\/svg>\n+    <path d=\"m8 8 84 84\" style=\"stroke:#505050;stroke-width:15\"\/>\n+    <path d=\"M8 92 92 8\" style=\"stroke:#505050;stroke-width:15\"\/>\n+<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/x.svg","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -118,0 +118,6 @@\n+    \/** The name of the moon icon for the dark theme. *\/\n+    public static final DocPath MOON_SVG = DocPath.create(\"moon.svg\");\n+\n+    \/** The name of the sun icon for the light theme. *\/\n+    public static final DocPath SUN_SVG = DocPath.create(\"sun.svg\");\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -206,0 +206,1 @@\n+        RADIO,\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/HtmlAttr.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -589,2 +589,1 @@\n-        return new HtmlTree(HtmlTag.FOOTER)\n-                .setRole(HtmlAttr.Role.CONTENTINFO);\n+        return new HtmlTree(HtmlTag.FOOTER);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/HtmlTree.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -65,1 +63,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jdeps\/share\/classes\/module-info.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,2 +405,2 @@\n-     * @throws OpaqueFrameException if this thread is a suspended virtual thread and the\n-     * target VM was unable to pop the frames.\n+     * @throws OpaqueFrameException if the target VM is unable to pop this frame\n+     * (e.g. a virtual thread is suspended, but not at an event).\n@@ -487,2 +487,2 @@\n-     * @throws OpaqueFrameException if this thread is a suspended virtual thread and the\n-     * target VM is unable to force the method to return.\n+     * @throws OpaqueFrameException if the target VM is unable to force the method to return\n+     * (e.g. a virtual thread is suspended, but not at an event).\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ThreadReference.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -398,16 +398,13 @@\n-                if (thread.isVirtual()) {\n-                    \/\/ We first need to find out if the current frame is native, or if the\n-                    \/\/ previous frame is native, in which case we throw NativeMethodException\n-                    for (int i = 0; i < 2; i++) {\n-                        StackFrameImpl sf;\n-                        try {\n-                            sf = (StackFrameImpl)thread.frame(i);\n-                        } catch (IndexOutOfBoundsException e) {\n-                            \/\/ This should never happen, but we need to check for it.\n-                            break;\n-                        }\n-                        sf.validateStackFrame();\n-                        MethodImpl meth = (MethodImpl)sf.location().method();\n-                        if (meth.isNative()) {\n-                            throw new NativeMethodException();\n-                        }\n+                \/\/ We first need to find out if the current frame is native, or if the\n+                \/\/ previous frame is native, in which case we throw NativeMethodException\n+                for (int i = 0; i < 2; i++) {\n+                    StackFrame sf;\n+                    try {\n+                        sf = thread.frame(i);\n+                    } catch (IndexOutOfBoundsException e) {\n+                        \/\/ This should never happen, but we need to check for it.\n+                        break;\n+                    }\n+                    Method meth = sf.location().method();\n+                    if (meth.isNative()) {\n+                        throw new NativeMethodException();\n@@ -415,5 +412,3 @@\n-                    \/\/ No native frames involved. Must have been due to thread\n-                    \/\/ not being mounted.\n-                    throw new OpaqueFrameException();\n-                } else {\n-                    throw new NativeMethodException();\n+                \/\/ No native frames involved. Must have been due to virtual thread\n+                \/\/ not being mounted or some other reason such as failure to deopt.\n+                throw new OpaqueFrameException();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/StackFrameImpl.java","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -600,3 +600,1 @@\n-                if (isVirtual() && !meth.isNative()) {\n-                    throw new OpaqueFrameException();\n-                } else {\n+                if (meth.isNative()) {\n@@ -604,0 +602,2 @@\n+                } else {\n+                    throw new OpaqueFrameException();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ThreadReferenceImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-                descriptors.add(String.valueOf(object));\n+                values.add(String.valueOf(object));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/AnnotationElement.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-     * Returns the settings that specifies how a recording is configured.\n+     * Returns the settings that specify how a recording is configured.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Configuration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-     * @return {@code true} if by default the event should be enabled by default, {@code false} otherwise\n+     * @return {@code true} if by default the event should be enabled, {@code false} otherwise\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Enabled.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-            label = platformEventType.getLabel();;\n+            label = platformEventType.getLabel();\n@@ -229,1 +229,1 @@\n-     * Returns the list of human-readable names that makes up the categories for\n+     * Returns the list of human-readable names that make up the categories for\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-     * This method is also be invoked when a listener is added to an already\n+     * This method is also invoked when a listener is added to an already\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/FlightRecorderListener.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * The following example shows how configure, start, stop and dump recording data to disk.\n+ * The following example shows how to configure, start, stop and dump recording data to disk.\n@@ -141,1 +141,1 @@\n-     * @param configuration configuration that contains the settings to be use, not\n+     * @param configuration configuration that contains the settings to be used, not\n@@ -342,1 +342,1 @@\n-     * with the {@link #setMaxAge(Duration)} method and the {@link #setMaxSize(long)}method.\n+     * with the {@link #setMaxAge(Duration)} method and the {@link #setMaxSize(long)} method.\n@@ -618,1 +618,1 @@\n-     * If multiple events with same name (for example, the same class is loaded\n+     * If multiple events with the same name (for example, the same class is loaded\n@@ -620,1 +620,1 @@\n-     * name is disabled. To disable a specific class, use the\n+     * name are disabled. To disable a specific class, use the\n@@ -656,1 +656,1 @@\n-     * @param eventClass the event to enable, not {@code null}\n+     * @param eventClass the event to disable, not {@code null}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Recording.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-     * Specifies that events arrives in chronological order, sorted by the time\n+     * Specifies that events arrive in chronological order, sorted by the time\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-     * @return an immutable list of added event types, not {@code null}\n+     * @return an immutable list of removed event types, not {@code null}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/MetadataEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-     * Returns the class this method belongs to, if it belong to a Java frame.\n+     * Returns the class this method belongs to, if it belongs to a Java frame.\n@@ -102,1 +102,1 @@\n-     * expressions).\n+     * expression).\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedMethod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-        if (object == null || object.getClass().isAssignableFrom(clazz)) {\n+        if (object == null || object.getClass() == clazz) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedObject.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * The following example shows how read and print all events in a recording file.\n+ * The following example shows how to read and print all events in a recording file.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -235,2 +235,2 @@\n-     * If neither maximum limit or the maximum age is set, the size of the\n-     * recording may grow indefinitely if events are on\n+     * If neither the maximum limit nor the maximum age is set, the size of the\n+     * recording may grow indefinitely if events are not consumed.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * parameters is passed to a method that throws other exceptions, such as\n+ * parameter is passed to a method that throws other exceptions, such as\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-            eventType.setThrottler(new Throttler(eventType));\n+            eventType.setThrottler(new Throttler());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-                list.add(o);\n+                list.add(o == NULL_OBJECT ? null : o);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/LongMap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.jfr.events.ActiveSettingEvent;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.jfr.FlightRecorderPermission;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PrivateAccess.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.file.Paths;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ChunkFilename.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.jfr.internal.MetadataRepository;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/FlushTask.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+        @SuppressWarnings({ \"unchecked\"})\n@@ -61,2 +61,2 @@\n-            if (keys instanceof Set set) {\n-                set.add(o);\n+            if (keys instanceof Set<?> set) {\n+                ((Set<Object>) set).add(o);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Histogram.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.BiConsumer;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryParser.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,3 +43,3 @@\n-         SELECT E.id, LAST_BATCH(E.value), LAST_BATCH(T.value),\n-                LAST_BATCH(S.value), LAST_BATCH(P.value),\n-                LAST_BATCH(C.value), LAST_BATCH(U.value)\n+         SELECT E.id, LAST(E.value), LAST(T.value),\n+                LAST(S.value), LAST(P.value),\n+                LAST(C.value), LAST(U.value)\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,0 @@\n-import static jdk.jfr.internal.util.TimespanUnit.SECONDS;\n-import static jdk.jfr.internal.util.TimespanUnit.MILLISECONDS;\n-\n@@ -44,1 +41,0 @@\n-import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/CPUThrottleSetting.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private volatile static boolean initialized;\n+    private static volatile boolean initialized;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/MethodSetting.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,0 @@\n-    public Throttler(PlatformEventType t) {\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/Throttler.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-    public static <T> Predicate<T> matchAny(List<Predicate<T>> filters) {\n+    public static <T> Predicate<T> matchAll(List<Predicate<T>> filters) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Filters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,1 +206,1 @@\n-                filter =  Filters.matchAny(filters);\n+                filter = Filters.matchAll(filters);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Metadata.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Array;\n@@ -294,1 +295,1 @@\n-                printValue(frame, null, \"\");\n+                printJavaFrame(frame, \"\");\n@@ -326,1 +327,1 @@\n-    private void printArray(Object[] array) {\n+    private void printArray(Object[] array, ValueDescriptor field) {\n@@ -331,1 +332,1 @@\n-            printValue(array[i], null, i + 1 < array.length ? \", \" : \"\");\n+            printValue(array[i], field, i + 1 < array.length ? \", \" : \"\");\n@@ -339,37 +340,9 @@\n-        if (value == null) {\n-            println(\"N\/A\" + postFix);\n-            return;\n-        }\n-        if (value instanceof RecordedObject) {\n-            if (value instanceof RecordedThread rt) {\n-                printThread(rt, postFix);\n-                return;\n-            }\n-            if (value instanceof RecordedClass rc) {\n-                printClass(rc, postFix);\n-                return;\n-            }\n-            if (value instanceof RecordedClassLoader rcl) {\n-                printClassLoader(rcl, postFix);\n-                return;\n-            }\n-            if (value instanceof RecordedFrame frame) {\n-                if (frame.isJavaFrame()) {\n-                    printJavaFrame((RecordedFrame) value, postFix);\n-                    return;\n-                }\n-            }\n-            if (value instanceof RecordedMethod rm) {\n-                println(formatMethod(rm));\n-                return;\n-            }\n-            if (field.getTypeName().equals(TYPE_OLD_OBJECT)) {\n-                printOldObject((RecordedObject) value);\n-                return;\n-            }\n-             print((RecordedObject) value, postFix);\n-            return;\n-        }\n-        if (value.getClass().isArray()) {\n-            printArray((Object[]) value);\n-            return;\n+        switch (value) {\n+            case null -> println(\"N\/A\" + postFix);\n+            case RecordedObject object -> printRecordedObject(object, field, postFix);\n+            case Number number -> printNumber(number, field);\n+            case String text -> println(\"\\\"\" + text + \"\\\"\");\n+            case Duration duration -> printDuration(duration);\n+            case OffsetDateTime dateTime -> printOffsetDateTime(dateTime);\n+            case Object[] array -> printArray(array, field);\n+            default -> println(value);\n@@ -377,0 +350,1 @@\n+    }\n@@ -378,29 +352,9 @@\n-        if (value instanceof Double d) {\n-            if (Double.isNaN(d) || d == Double.NEGATIVE_INFINITY) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-        if (value instanceof Float f) {\n-            if (Float.isNaN(f) || f == Float.NEGATIVE_INFINITY) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-        if (value instanceof Long l) {\n-            if (l == Long.MIN_VALUE) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-        if (value instanceof Integer i) {\n-            if (i == Integer.MIN_VALUE) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-\n-        if (field.getContentType() != null) {\n-            if (printFormatted(field, value)) {\n-                return;\n-            }\n+    private void printRecordedObject(RecordedObject struct, ValueDescriptor field, String postFix) {\n+        switch (struct) {\n+            case RecordedThread rt -> printThread(rt, postFix);\n+            case RecordedClass rc -> printClass(rc, postFix);\n+            case RecordedClassLoader rcl -> printClassLoader(rcl, postFix);\n+            case RecordedFrame rf when rf.isJavaFrame() -> printJavaFrame(rf, postFix);\n+            case RecordedMethod rm -> println(formatMethod(rm));\n+            case RecordedObject ro when field.getTypeName().equals(TYPE_OLD_OBJECT) -> printOldObject(ro);\n+            default -> print(struct, postFix);\n@@ -408,0 +362,1 @@\n+    }\n@@ -409,3 +364,7 @@\n-        String text = String.valueOf(value);\n-        if (value instanceof String) {\n-            text = \"\\\"\" + text + \"\\\"\";\n+    private void printNumber(Number number, ValueDescriptor field) {\n+        switch (number) {\n+            case Double d when Double.isNaN(d) || d == Double.NEGATIVE_INFINITY -> println(\"N\/A\");\n+            case Float f when Float.isNaN(f) || f == Float.NEGATIVE_INFINITY -> println(\"N\/A\");\n+            case Long l when l == Long.MIN_VALUE -> println(\"N\/A\");\n+            case Integer i when i == Integer.MIN_VALUE -> println(\"N\/A\");\n+            default -> printFormatted(field, number);\n@@ -413,1 +372,0 @@\n-        println(text);\n@@ -549,16 +507,4 @@\n-    private boolean printFormatted(ValueDescriptor field, Object value) {\n-        if (value instanceof Duration d) {\n-            if (d.getSeconds() == Long.MIN_VALUE && d.getNano() == 0)  {\n-                println(\"N\/A\");\n-                return true;\n-            }\n-            if (d.equals(ChronoUnit.FOREVER.getDuration())) {\n-                println(\"Forever\");\n-                return true;\n-            }\n-            if (showExact) {\n-                println(String.format(\"%.9f s\", (double) d.toNanos() \/ 1_000_000_000));\n-            } else {\n-                println(ValueFormatter.formatDuration(d));\n-            }\n-            return true;\n+    private void printOffsetDateTime(OffsetDateTime dateTime) {\n+        if (dateTime.equals(OffsetDateTime.MIN)) {\n+            println(\"N\/A\");\n+            return;\n@@ -566,11 +512,11 @@\n-        if (value instanceof OffsetDateTime odt) {\n-            if (odt.equals(OffsetDateTime.MIN))  {\n-                println(\"N\/A\");\n-                return true;\n-            }\n-            if (showExact) {\n-                println(TIME_FORMAT_EXACT.format(odt));\n-            } else {\n-                println(TIME_FORMAT.format(odt));\n-            }\n-            return true;\n+        if (showExact) {\n+            println(TIME_FORMAT_EXACT.format(dateTime));\n+        } else {\n+            println(TIME_FORMAT.format(dateTime));\n+        }\n+    }\n+\n+    private void printDuration(Duration duration) {\n+        if (duration.getSeconds() == Long.MIN_VALUE && duration.getNano() == 0) {\n+            println(\"N\/A\");\n+            return;\n@@ -578,4 +524,16 @@\n-        Percentage percentage = field.getAnnotation(Percentage.class);\n-        if (percentage != null) {\n-            if (value instanceof Number n) {\n-                double p = 100 * n.doubleValue();\n+        if (duration.equals(ChronoUnit.FOREVER.getDuration())) {\n+            println(\"Forever\");\n+            return;\n+        }\n+        if (showExact) {\n+            println(String.format(\"%.9f s\", (double) duration.toNanos() \/ 1_000_000_000));\n+        } else {\n+            println(ValueFormatter.formatDuration(duration));\n+        }\n+    }\n+\n+    private void printFormatted(ValueDescriptor field, Number number) {\n+        if (field.getContentType() != null) {\n+            Percentage percentage = field.getAnnotation(Percentage.class);\n+            if (percentage != null) {\n+                double p = 100 * number.doubleValue();\n@@ -587,1 +545,1 @@\n-                return true;\n+                return;\n@@ -589,10 +547,10 @@\n-        }\n-        DataAmount dataAmount = field.getAnnotation(DataAmount.class);\n-        if (dataAmount != null && value instanceof Number number) {\n-            boolean frequency = field.getAnnotation(Frequency.class) != null;\n-            String unit = dataAmount.value();\n-            boolean bits = unit.equals(DataAmount.BITS);\n-            boolean bytes = unit.equals(DataAmount.BYTES);\n-            if (bits || bytes) {\n-                formatMemory(number.longValue(), bytes, frequency);\n-                return true;\n+            DataAmount dataAmount = field.getAnnotation(DataAmount.class);\n+            if (dataAmount != null) {\n+                boolean frequency = field.getAnnotation(Frequency.class) != null;\n+                String unit = dataAmount.value();\n+                boolean bits = unit.equals(DataAmount.BITS);\n+                boolean bytes = unit.equals(DataAmount.BYTES);\n+                if (bits || bytes) {\n+                    printMemory(number.longValue(), bytes, frequency);\n+                    return;\n+                }\n@@ -600,5 +558,3 @@\n-        }\n-        MemoryAddress memoryAddress = field.getAnnotation(MemoryAddress.class);\n-        if (memoryAddress != null) {\n-            if (value instanceof Number n) {\n-                long d = n.longValue();\n+            MemoryAddress memoryAddress = field.getAnnotation(MemoryAddress.class);\n+            if (memoryAddress != null) {\n+                long d = number.longValue();\n@@ -606,1 +562,1 @@\n-                return true;\n+                return;\n@@ -608,6 +564,4 @@\n-        }\n-        Frequency frequency = field.getAnnotation(Frequency.class);\n-        if (frequency != null) {\n-            if (value instanceof Number) {\n-                println(value + \" Hz\");\n-                return true;\n+            Frequency frequency = field.getAnnotation(Frequency.class);\n+            if (frequency != null) {\n+                println(number + \" Hz\");\n+                return;\n@@ -616,2 +570,1 @@\n-\n-        return false;\n+        println(number);\n@@ -620,1 +573,1 @@\n-    private void formatMemory(long value, boolean bytesUnit, boolean frequency) {\n+    private void printMemory(long value, boolean bytesUnit, boolean frequency) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/PrettyWriter.java","additions":83,"deletions":130,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,1 @@\n-            eventWriter.setEventFilter(Filters.matchAny(eventFilters));\n+            eventWriter.setEventFilter(Filters.matchAll(eventFilters));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Print.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-        return Filters.matchAny(filters);\n+        return Filters.matchAll(filters);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Scrub.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,4 @@\n+    public final void println(Object object) {\n+        println(String.valueOf(object));\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/StructuredWriter.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.jfr.internal.Type;\n@@ -267,10 +266,9 @@\n-        try {\n-            Logger.log(LogTag.JFR_METHODTRACE, LogLevel.DEBUG, \"Method tracer initialization started.\");\n-            Thread current = Thread.currentThread();\n-            JVM.exclude(current);\n-            long methodId = 16384126;\n-            long classId = methodId >> 16;\n-            ClassLoader cl = null;\n-            String className = \" java\/lang\/String\";\n-            Module m = String.class.getModule();\n-            var is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"java\/lang\/String.class\");\n+        Logger.log(LogTag.JFR_METHODTRACE, LogLevel.DEBUG, \"Method tracer initialization started.\");\n+        Thread current = Thread.currentThread();\n+        JVM.exclude(current);\n+        long methodId = 16384126;\n+        long classId = methodId >> 16;\n+        ClassLoader cl = null;\n+        String className = \"java\/lang\/String\";\n+        Module m = String.class.getModule();\n+        try (var is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"java\/lang\/String.class\")) {\n@@ -278,1 +276,0 @@\n-            is.close();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/PlatformTracer.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.jfr.internal.settings.CPUThrottleSetting;\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/TimespanRate.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * fields that matches the data types of the payload. Metadata about fields,\n+ * fields that match the data types of the payload. Metadata about fields,\n@@ -235,1 +235,1 @@\n- * parameters is passed to a method that throws other exceptions, such as\n+ * parameters are passed to a method that throws other exceptions, such as\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -34,1 +32,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jfr\/share\/classes\/module-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -56,1 +54,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jlink\/share\/classes\/module-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -358,1 +358,1 @@\n-        var srcPath = pkg.asPackageApplicationLayout().orElseThrow().resolveAt(env.appImageDir()).desktopIntegrationDirectory().resolve(fileName);\n+        var srcPath = env.asApplicationLayout().orElseThrow().desktopIntegrationDirectory().resolve(fileName);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -43,2 +44,20 @@\n-        return create(ApplicationLayout.super.resolveAt(root),\n-                resolveNullablePath(root, libAppLauncher()));\n+        return (LinuxApplicationLayout)ApplicationLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout unresolve() {\n+        return (LinuxApplicationLayout)ApplicationLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(ApplicationLayout.super.resetRootDirectory(), libAppLauncher());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return create(ApplicationLayout.super.map(mapper), mapNullablePath(mapper, libAppLauncher()));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxApplicationLayout.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\/\/ Must be publc to allow access from AppImageLayout.toPathGroup()\n+\/\/ Must be public to allow access from AppImageLayout.toPathGroup()\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxApplicationLayoutMixin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -354,2 +354,1 @@\n-                AppImageLayout.toPathGroup(pkg.packageLayout().resolveAt(\n-                        env.appImageDir())).sizeInBytes() >> 10));\n+                AppImageLayout.toPathGroup(env.appImageLayout()).sizeInBytes() >> 10));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.jpackage.internal.model.LinuxApplication;\n@@ -37,0 +38,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -55,1 +57,1 @@\n-        final var pkg = pkgBuilder.create();\n+        final var tmpPkg = pkgBuilder.create();\n@@ -57,1 +59,1 @@\n-        final var stdPkgType = pkg.asStandardPackageType();\n+        final var stdPkgType = tmpPkg.asStandardPackageType();\n@@ -59,1 +61,1 @@\n-            validatePackageName(pkg.packageName(), stdPkgType.orElseThrow());\n+            validatePackageName(tmpPkg.packageName(), stdPkgType.orElseThrow());\n@@ -62,3 +64,10 @@\n-        var reply = create(pkg, pkg.packageLayout());\n-        if (reply.isInstallDirInUsrTree()) {\n-            reply = create(pkg, usrTreePackageLayout(pkg.relativeInstallDir(), pkg.packageName()));\n+        final AppImageLayout relativeInstalledLayout;\n+        if (create(tmpPkg).isInstallDirInUsrTree()) {\n+            final var usrTreeLayout = usrTreePackageLayout(tmpPkg.relativeInstallDir(), tmpPkg.packageName());\n+            if (tmpPkg.isRuntimeInstaller()) {\n+                relativeInstalledLayout = RuntimeLayout.create(usrTreeLayout.runtimeDirectory());\n+            } else {\n+                relativeInstalledLayout = usrTreeLayout;\n+            }\n+        } else {\n+            relativeInstalledLayout = tmpPkg.appImageLayout().resolveAt(tmpPkg.relativeInstallDir()).resetRootDirectory();\n@@ -67,1 +76,6 @@\n-        return reply;\n+        final var app = ApplicationBuilder.overrideAppImageLayout(pkgBuilder.app(), relativeInstalledLayout);\n+\n+        return create(pkgBuilder\n+                .app(LinuxApplication.create(app))\n+                .installedPackageLayout(relativeInstalledLayout.resolveAt(Path.of(\"\/\")).resetRootDirectory())\n+                .create());\n@@ -70,1 +84,1 @@\n-    private LinuxPackage create(Package pkg, AppImageLayout pkgLayout) throws ConfigException {\n+    private LinuxPackage create(Package pkg) throws ConfigException {\n@@ -72,1 +86,0 @@\n-                pkgLayout,\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBuilder.java","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-    @Override\n-    AppImageLayout packageLayout();\n-\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxPackage.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,5 +34,0 @@\n-    \/**\n-     * Overrides {@link Package#packageLayout()}.\n-     *\/\n-    AppImageLayout packageLayout();\n-\n@@ -91,1 +86,1 @@\n-    record Stub(AppImageLayout packageLayout, String menuGroupName,\n+    record Stub(String menuGroupName,\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxPackageMixin.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n@@ -47,0 +49,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -53,1 +56,1 @@\n-    static Consumer<Path> createSigner(MacApplication app, CodesignConfig signingCfg) {\n+    static Consumer<MacBundle> createSigner(MacApplication app, CodesignConfig signingCfg) {\n@@ -70,1 +73,1 @@\n-        SignFilter(Application app, Path appImage) {\n+        SignFilter(Application app, MacBundle appImage) {\n@@ -75,1 +78,1 @@\n-                return appLayout.resolveAt(appImage);\n+                return appLayout.resolveAt(appImage.root());\n@@ -101,1 +104,6 @@\n-    private void sign(MacApplication app, Path appImage) throws CodesignException, IOException {\n+    private void sign(MacApplication app, MacBundle appImage) throws CodesignException, IOException {\n+        if (!appImage.isValid()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        app = normalizeAppImageLayout(app);\n@@ -105,1 +113,1 @@\n-        try (var content = Files.walk(appImage)) {\n+        try (var content = Files.walk(appImage.root())) {\n@@ -121,1 +129,1 @@\n-            return appLayout.resolveAt(appImage);\n+            return appLayout.resolveAt(appImage.root());\n@@ -124,1 +132,1 @@\n-        final var frameworkPath = appImage.resolve(\"Contents\/Frameworks\");\n+        final var frameworkPath = appImage.contentsDir().resolve(\"Frameworks\");\n@@ -134,1 +142,1 @@\n-        codesigners.accept(appImage);\n+        codesigners.accept(appImage.root());\n@@ -238,0 +246,14 @@\n+    private static MacApplication normalizeAppImageLayout(MacApplication app) {\n+        switch (app.imageLayout()) {\n+            case MacApplicationLayout macLayout -> {\n+                return MacApplicationBuilder.overrideAppImageLayout(app, APPLICATION_LAYOUT);\n+            }\n+            case RuntimeLayout macLayout -> {\n+                return MacApplicationBuilder.overrideAppImageLayout(app, RUNTIME_BUNDLE_LAYOUT);\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-                 env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+                 env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n@@ -49,1 +49,1 @@\n-                 env = BuildEnv.withAppImageDir(BuildEnvFromParams.BUILD_ENV.fetchFrom(params), output);\n+                 env = BuildEnv.withAppImageDir(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params), output);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppBundler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -98,2 +99,7 @@\n-        final var mixin = new MacApplicationMixin.Stub(validatedIcon(), validatedBundleName(),\n-                validatedBundleIdentifier(), validatedCategory(), appStore, createSigningConfig());\n+        final var mixin = new MacApplicationMixin.Stub(\n+                validatedIcon(),\n+                validatedBundleName(),\n+                validatedBundleIdentifier(),\n+                validatedCategory(),\n+                appStore,\n+                createSigningConfig());\n@@ -104,0 +110,11 @@\n+    static MacApplication overrideAppImageLayout(MacApplication app, AppImageLayout appImageLayout) {\n+        final var mixin = new MacApplicationMixin.Stub(\n+                app.icon(),\n+                app.bundleName(),\n+                app.bundleIdentifier(),\n+                app.category(),\n+                app.appStore(),\n+                app.signingConfig());\n+        return MacApplication.create(ApplicationBuilder.overrideAppImageLayout(app, appImageLayout), mixin);\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationBuilder.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -38,1 +39,2 @@\n-                .create(MacApplicationLayout.class, layout, new MacApplicationLayoutMixin.Stub(runtimeRootDir));\n+                .create(MacApplicationLayout.class, layout,\n+                        new MacApplicationLayoutMixin.Stub(runtimeRootDir));\n@@ -43,2 +45,1 @@\n-        return create(ApplicationLayout.super.resolveAt(root),\n-                resolveNullablePath(root, runtimeRootDirectory()));\n+        return (MacApplicationLayout)ApplicationLayout.super.resolveAt(root);\n@@ -46,0 +47,20 @@\n+\n+    @Override\n+    default MacApplicationLayout unresolve() {\n+        return (MacApplicationLayout)ApplicationLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default MacApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(ApplicationLayout.super.resetRootDirectory(), runtimeRootDirectory());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default MacApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return create(ApplicationLayout.super.map(mapper), mapNullablePath(mapper, runtimeRootDirectory()));\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationLayout.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\/\/ Must be publc to allow access from AppImageLayout.toPathGroup()\n+\/\/ Must be public to allow access from AppImageLayout.toPathGroup()\n@@ -33,1 +33,2 @@\n-     * Path to the root Java runtime directory in the application image.\n+     * Returns path to the root Java runtime directory in the application image.\n+     * <p>\n@@ -35,0 +36,2 @@\n+     *\n+     * @return the path to the root Java runtime directory in the application image\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationLayoutMixin.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import jdk.jpackage.internal.model.MacPackage;\n+\n+final class MacBuildEnvFromParams {\n+\n+    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n+        return BuildEnvFromParams.create(params, MacPackagingPipeline.APPLICATION_LAYOUT::resolveAt, MacPackage::guessRuntimeLayout);\n+    });\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBuildEnvFromParams.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -76,2 +77,14 @@\n-    static MacBundle fromAppImageLayout(AppImageLayout layout) {\n-        return new MacBundle(layout.rootDirectory());\n+    static Optional<MacBundle> fromAppImageLayout(AppImageLayout layout) {\n+        final var root = layout.rootDirectory();\n+        final var bundleSubdir = root.relativize(layout.runtimeDirectory());\n+        final var contentsDirname = Path.of(\"Contents\");\n+        var bundleRoot = root;\n+        for (int i = 0; i != bundleSubdir.getNameCount(); i++) {\n+            var nameComponent = bundleSubdir.getName(i);\n+            if (contentsDirname.equals(nameComponent)) {\n+                return Optional.of(new MacBundle(bundleRoot));\n+            } else {\n+                bundleRoot = bundleRoot.resolve(nameComponent);\n+            }\n+        }\n+        return Optional.empty();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBundle.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-        final var superPkgBuilder = pkgBuilder.pkgBuilder();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackageBuilder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import static jdk.jpackage.internal.model.MacPackage.RUNTIME_PACKAGE_LAYOUT;\n+import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n@@ -48,1 +48,0 @@\n-import java.nio.file.Files;\n@@ -67,0 +66,1 @@\n+import jdk.jpackage.internal.model.MacPackage;\n@@ -78,7 +78,3 @@\n-        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(params).map(predefinedRuntimeImage -> {\n-            if (Files.isDirectory(RUNTIME_PACKAGE_LAYOUT.resolveAt(predefinedRuntimeImage).runtimeDirectory())) {\n-                return RUNTIME_PACKAGE_LAYOUT;\n-            } else {\n-                return RuntimeLayout.DEFAULT;\n-            }\n-        });\n+        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(params)\n+                .map(MacPackage::guessRuntimeLayout)\n+                .map(RuntimeLayout::unresolve);\n@@ -91,1 +87,1 @@\n-        }), APPLICATION_LAYOUT, predefinedRuntimeLayout);\n+        }), APPLICATION_LAYOUT, RUNTIME_BUNDLE_LAYOUT, predefinedRuntimeLayout);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromParams.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.jpackage.internal.MacPackagingPipeline.LayoutUtils.packagerLayout;\n+\n@@ -29,0 +31,1 @@\n+import jdk.jpackage.internal.model.MacApplication;\n@@ -48,1 +51,9 @@\n-        final var pkg = pkgBuilder.create();\n+\n+        final var app = (MacApplication)pkgBuilder.app();\n+\n+        var pkg = pkgBuilder.create();\n+\n+        pkgBuilder.app(MacApplicationBuilder.overrideAppImageLayout(app, packagerLayout(pkg)))\n+                .installedPackageLayout(pkg.installedPackageLayout());\n+\n+        pkg = pkgBuilder.create();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackageBuilder.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.io.UncheckedIOException;\n@@ -52,0 +53,1 @@\n+import java.util.function.UnaryOperator;\n@@ -56,0 +58,1 @@\n+import jdk.jpackage.internal.PackagingPipeline.AppImageTaskAction;\n@@ -101,4 +104,0 @@\n-    static AppImageLayout packagingLayout(Package pkg) {\n-        return pkg.appImageLayout().resolveAt(pkg.relativeInstallDir().getFileName());\n-    }\n-\n@@ -107,9 +106,2 @@\n-                .appContextMapper(appContext -> {\n-                    return new TaskContextProxy(appContext, true, false);\n-                })\n-                .pkgContextMapper(appContext -> {\n-                    final var isRuntimeInstaller = pkg.map(Package::isRuntimeInstaller).orElse(false);\n-                    final var withPredefinedAppImage = pkg.flatMap(Package::predefinedAppImage).isPresent();\n-                    return new TaskContextProxy(appContext, false, isRuntimeInstaller || withPredefinedAppImage);\n-                })\n-                .appImageLayoutForPackaging(MacPackagingPipeline::packagingLayout)\n+                .contextMapper(pkg.map(MacPackagingPipeline::mapPackageTaskContext)\n+                        .orElseGet(MacPackagingPipeline::mapAppTaskContext))\n@@ -159,1 +151,1 @@\n-                .appImageAction(MacPackagingPipeline::sign)\n+                .appImageAction(LayoutUtils.withBundleLayout(MacPackagingPipeline::sign))\n@@ -165,1 +157,1 @@\n-                .appImageAction(MacPackagingPipeline::sign)\n+                .appImageAction(LayoutUtils.withBundleLayout(MacPackagingPipeline::sign))\n@@ -185,1 +177,0 @@\n-                builder.appImageLayoutForPackaging(Package::appImageLayout);\n@@ -239,2 +230,49 @@\n-    private static void copyAppImage(MacPackage pkg, AppImageDesc srcAppImage,\n-            AppImageDesc dstAppImage) throws IOException {\n+    static final class LayoutUtils {\n+        \/**\n+         * Returns unresolved app image layout for the specified package for use with\n+         * the signing function defined in {@link MacPackagingPipeline} class and\n+         * {@link MacPkgPackager} and {@link MacDmgPackager} packagers.\n+         * <p>\n+         * Paths of the result app image layout will start with the bundle name. E.g.:\n+         * for a package with relative installation directory set to\n+         * {@code \"Applications\/Acme\/MyApp.app\"} and the \"launchers\" directory of an\n+         * application layout set to {@code \"Contents\/MacOS\"}, the result application\n+         * layout object will be such that the value of its \"launchers\" directory will\n+         * be {@code \"MyApp.app\/Contents\/MacOS\"}. The root directory of the result app\n+         * image layout will be an empty path ({@link Path.of(\"\")}), i.e. the app image\n+         * layout will be unresolved.\n+         *\n+         * @param pkg the package\n+         * @return the unresolved app image layout for the specified package suitable\n+         *         for the use with macosx packaging pipeline and packagers\n+         *\/\n+        static AppImageLayout packagerLayout(Package pkg) {\n+            return pkg.appImageLayout().resolveAt(pkg.relativeInstallDir().getFileName()).resetRootDirectory();\n+        }\n+\n+        static <T extends AppImageLayout> AppImageBuildEnv<MacApplication, T> fromPackagerLayout(AppImageBuildEnv<MacApplication, T> cfg) {\n+\n+            var bundleDirectoryName = cfg.envLayout().runtimeDirectory().getName(0);\n+            var bundleLayout = cfg.envLayout().map(bundleDirectoryName::relativize).resetRootDirectory();\n+            var bundleRoot = cfg.env().appImageDir().resolve(bundleDirectoryName);\n+            var app = MacApplicationBuilder.overrideAppImageLayout(cfg.app(), bundleLayout);\n+            var env = BuildEnv.withAppImageLayout(cfg.env(), bundleLayout.resolveAt(bundleRoot));\n+\n+            return new AppImageBuildEnv<>(env, app);\n+        }\n+\n+        static <T extends AppImageLayout> AppImageTaskAction<MacApplication, T> withBundleLayout(AppImageTaskAction<MacApplication, T> action) {\n+            return new AppImageTaskAction<>() {\n+                @Override\n+                public void execute(AppImageBuildEnv<MacApplication, T> env) throws IOException, PackagerException {\n+                    if (!env.envLayout().runtimeDirectory().getName(0).equals(Path.of(\"Contents\"))) {\n+                        env = LayoutUtils.fromPackagerLayout(env);\n+                    }\n+                    action.execute(env);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static void copyAppImage(MacPackage pkg, AppImageLayout srcAppImage,\n+            AppImageLayout dstAppImage) throws IOException {\n@@ -244,1 +282,6 @@\n-        var inputRootDirectory = srcAppImage.resolvedAppImagelayout().rootDirectory();\n+        final Optional<MacBundle> srcMacBundle;\n+        if (pkg.isRuntimeInstaller()) {\n+            srcMacBundle = MacBundle.fromAppImageLayout(srcAppImage);\n+        } else {\n+            srcMacBundle = Optional.empty();\n+        }\n@@ -246,1 +289,1 @@\n-        if (pkg.isRuntimeInstaller() && MacBundle.isDirectoryMacBundle(inputRootDirectory)) {\n+        srcMacBundle.ifPresentOrElse(inputBundle -> {\n@@ -249,7 +292,15 @@\n-            FileUtils.copyRecursive(\n-                    inputRootDirectory,\n-                    dstAppImage.resolvedAppImagelayout().rootDirectory(),\n-                    LinkOption.NOFOLLOW_LINKS);\n-        } else {\n-            PackagingPipeline.copyAppImage(srcAppImage, dstAppImage, !predefinedAppImageSigned);\n-        }\n+            try {\n+                FileUtils.copyRecursive(\n+                        inputBundle.root(),\n+                        MacBundle.fromAppImageLayout(dstAppImage).orElseThrow().root(),\n+                        LinkOption.NOFOLLOW_LINKS);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }, () -> {\n+            try {\n+                PackagingPipeline.copyAppImage(srcAppImage, dstAppImage, !predefinedAppImageSigned);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        });\n@@ -275,4 +326,17 @@\n-    private static void runPostAppImageUserScript(PackageBuildEnv<Package, AppImageLayout> env) throws IOException {\n-        PackagingPipeline.runPostAppImageUserScript(new PackageBuildEnv<>(\n-                BuildEnv.withAppImageDir(env.env(), env.env().appImageDir().resolve(env.envLayout().rootDirectory())),\n-                env.pkg(), env.pkg().appImageLayout(), env.outputDir()));\n+    private static void runPostAppImageUserScript(PackageBuildEnv<Package, AppImageLayout> cfg) throws IOException {\n+        var appCfg = LayoutUtils.fromPackagerLayout(\n+                new AppImageBuildEnv<>(cfg.env(), (MacApplication)cfg.pkg().app()));\n+\n+        var pkg = cfg.pkg(); pkg = new Package.Stub(\n+                appCfg.app(),\n+                pkg.type(),\n+                pkg.packageName(),\n+                pkg.description(),\n+                pkg.version(),\n+                pkg.aboutURL(),\n+                pkg.licenseFile(),\n+                pkg.predefinedAppImage(),\n+                pkg.installedPackageLayout(),\n+                pkg.relativeInstallDir());\n+\n+        PackagingPipeline.runPostAppImageUserScript(new PackageBuildEnv<>(appCfg.env(), pkg, cfg.outputDir()));\n@@ -334,1 +398,1 @@\n-        final var infoPlistFile = MacBundle.fromAppImageLayout(env.resolvedLayout()).infoPlistFile();\n+        final var infoPlistFile = MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow().infoPlistFile();\n@@ -387,2 +451,1 @@\n-            final var appImageDir = env.resolvedLayout().rootDirectory();\n-            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(appImageDir);\n+            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow());\n@@ -470,1 +533,1 @@\n-            return new MacBundle(env.resolvedLayout().rootDirectory());\n+            return MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow();\n@@ -501,0 +564,15 @@\n+    private static UnaryOperator<PackagingPipeline.TaskContext> mapAppTaskContext() {\n+        return ctx -> {\n+            return new TaskContextProxy(ctx, true, false);\n+        };\n+    }\n+\n+    private static UnaryOperator<PackagingPipeline.TaskContext> mapPackageTaskContext(Package pkg) {\n+        return ctx -> {\n+            final var isRuntimeInstaller = pkg.isRuntimeInstaller();\n+            final var withPredefinedAppImage = pkg.predefinedAppImage().isPresent();\n+            return new TaskContextProxy(ctx, false, isRuntimeInstaller || withPredefinedAppImage);\n+        };\n+    }\n+\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackagingPipeline.java","additions":113,"deletions":35,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.nio.file.Files;\n@@ -32,2 +33,0 @@\n-    MacApplication app();\n-\n@@ -35,7 +34,1 @@\n-    default AppImageLayout appImageLayout() {\n-        if (isRuntimeInstaller()) {\n-            return RUNTIME_PACKAGE_LAYOUT;\n-        } else {\n-            return Package.super.appImageLayout();\n-        }\n-    }\n+    MacApplication app();\n@@ -51,1 +44,15 @@\n-    public static final RuntimeLayout RUNTIME_PACKAGE_LAYOUT = RuntimeLayout.create(Path.of(\"Contents\/Home\"));\n+    \/**\n+     * Guesses layout of a runtime image at the given path.\n+     *\n+     * @param path the path to a runtime image\n+     * @return the runtime image layout resolved at the given path\n+     *\/\n+    public static RuntimeLayout guessRuntimeLayout(Path path) {\n+        if (Files.isDirectory(RUNTIME_BUNDLE_LAYOUT.resolveAt(path).runtimeDirectory())) {\n+            return RUNTIME_BUNDLE_LAYOUT.resolveAt(path);\n+        } else {\n+            return RuntimeLayout.DEFAULT.resolveAt(path);\n+        }\n+    }\n+\n+    public static final RuntimeLayout RUNTIME_BUNDLE_LAYOUT = RuntimeLayout.create(Path.of(\"Contents\/Home\"));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacPackage.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -156,3 +156,24 @@\n-        return new Launcher.Stub(launcher.name(), Optional.of(startupInfo),\n-                launcher.fileAssociations(), launcher.isService(), launcher.description(),\n-                launcher.icon(), launcher.defaultIconResourceName(), launcher.extraAppImageFileData());\n+        return new Launcher.Stub(\n+                launcher.name(),\n+                Optional.of(startupInfo),\n+                launcher.fileAssociations(),\n+                launcher.isService(),\n+                launcher.description(),\n+                launcher.icon(),\n+                launcher.defaultIconResourceName(),\n+                launcher.extraAppImageFileData());\n+    }\n+\n+    static Application overrideAppImageLayout(Application app, AppImageLayout appImageLayout) {\n+        return new Application.Stub(\n+                app.name(),\n+                app.description(),\n+                app.version(),\n+                app.vendor(),\n+                app.copyright(),\n+                app.srcDir(),\n+                app.contentDirs(),\n+                Objects.requireNonNull(appImageLayout),\n+                app.runtimeBuilder(),\n+                app.launchers(),\n+                app.extraAppImageFileData());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationBuilder.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            env.app().runtimeBuilder().orElseThrow().createRuntime(env.resolvedLayout());\n+            env.app().runtimeBuilder().orElseThrow().create(env.resolvedLayout());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationImageUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -31,0 +33,3 @@\n+\/**\n+ * Build environment.\n+ *\/\n@@ -33,0 +38,5 @@\n+    \/**\n+     * Returns root directory for intermediate build files.\n+     *\n+     * @return the root directory for intermediate build files\n+     *\/\n@@ -35,0 +45,5 @@\n+    \/**\n+     * Returns <code>true<\/code> if the build should be verbose output.\n+     *\n+     * @return <code>true<\/code> if the build should be verbose output\n+     *\/\n@@ -37,0 +52,7 @@\n+    \/**\n+     * Returns the path of the resource directory or an empty {@link Optional}\n+     * instance if none is configured with the build.\n+     *\n+     * @return the path of the resource directory or an empty {@link Optional}\n+     *         instance if non is configured with the build\n+     *\/\n@@ -40,1 +62,1 @@\n-     * Returns path to application image directory.\n+     * Returns the path of the app image directory of this build.\n@@ -42,2 +64,1 @@\n-     * The return value is supposed to be used as a parameter for\n-     * ApplicationLayout#resolveAt function.\n+     * @return the path of the app image directory of this build\n@@ -46,1 +67,1 @@\n-        return buildRoot().resolve(\"image\");\n+        return appImageLayout().rootDirectory();\n@@ -49,0 +70,20 @@\n+    \/**\n+     * Returns resolved app image layout of the app image directory. The return\n+     * layout is resolved at {@link #appImageDir()} path.\n+     *\n+     * @return the resolved app image layout of the app image directory\n+     *\/\n+    AppImageLayout appImageLayout();\n+\n+    default Optional<ApplicationLayout> asApplicationLayout() {\n+        if (appImageLayout() instanceof ApplicationLayout layout) {\n+            return Optional.of(layout);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Returns a path to a directory for intermediate configuration files.\n+     * @return the path to the directory for intermediate configuration files\n+     *\/\n@@ -53,0 +94,7 @@\n+    \/**\n+     * Creates an {@link OverridableResource} instance for the given resource name.\n+     *\n+     * @param defaultName the resource name\n+     * @return the {@link OverridableResource} instance wrapping a resource with the\n+     *         given name\n+     *\/\n@@ -59,2 +107,8 @@\n-    static BuildEnv create(Path buildRoot, Optional<Path> resourceDir, boolean verbose, Class<?> resourceLocator) {\n-        return new Internal.DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, Optional.empty());\n+    static BuildEnv withAppImageLayout(BuildEnv env, AppImageLayout appImageLayout) {\n+        return ((Internal.DefaultBuildEnv)env).copyWithAppImageLayout(appImageLayout);\n+    }\n+\n+    static BuildEnv create(Path buildRoot, Optional<Path> resourceDir, boolean verbose,\n+            Class<?> resourceLocator, AppImageLayout appImageLayout) {\n+        return new Internal.DefaultBuildEnv(buildRoot, resourceDir, verbose,\n+                resourceLocator, appImageLayout);\n@@ -64,2 +118,3 @@\n-        private static record DefaultBuildEnv(Path buildRoot, Optional<Path> resourceDir,\n-                boolean verbose, Class<?> resourceLocator, Optional<Path> optAppImageDir) implements BuildEnv {\n+        private record DefaultBuildEnv(Path buildRoot, Optional<Path> resourceDir,\n+                boolean verbose, Class<?> resourceLocator,\n+                AppImageLayout appImageLayout) implements BuildEnv {\n@@ -71,1 +126,1 @@\n-                Objects.requireNonNull(optAppImageDir);\n+                Objects.requireNonNull(appImageLayout);\n@@ -74,2 +129,2 @@\n-            DefaultBuildEnv copyWithAppImageDir(Path appImageDir) {\n-                return new DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, Optional.of(appImageDir));\n+            DefaultBuildEnv copyWithAppImageDir(Path v) {\n+                return copyWithAppImageLayout(appImageLayout.unresolve().resolveAt(v));\n@@ -78,3 +133,2 @@\n-            @Override\n-            public Path appImageDir() {\n-                return optAppImageDir.orElseGet(BuildEnv.super::appImageDir);\n+            DefaultBuildEnv copyWithAppImageLayout(AppImageLayout v) {\n+                return new DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, v);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnv.java","additions":68,"deletions":14,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -34,0 +35,1 @@\n+import jdk.jpackage.internal.model.Package;\n@@ -43,2 +45,0 @@\n-        Objects.requireNonNull(appImageDir);\n-\n@@ -60,2 +60,2 @@\n-        return BuildEnv.withAppImageDir(BuildEnv.create(root, Optional.ofNullable(resourceDir),\n-                verbose, ResourceLocator.class), appImageDir);\n+        return BuildEnv.create(root, Optional.ofNullable(resourceDir), verbose,\n+                ResourceLocator.class, resolvedAppImageLayout());\n@@ -79,0 +79,5 @@\n+    BuildEnvBuilder appImageLayout(AppImageLayout v) {\n+        appImageLayout = v;\n+        return this;\n+    }\n+\n@@ -81,0 +86,1 @@\n+        appImageLayout = app.imageLayout();\n@@ -84,1 +90,1 @@\n-    BuildEnvBuilder appImageDirForPackage() {\n+    BuildEnvBuilder appImageDirFor(Package pkg) {\n@@ -86,0 +92,1 @@\n+        appImageLayout = pkg.appImageLayout();\n@@ -89,0 +96,5 @@\n+    private AppImageLayout resolvedAppImageLayout() {\n+        Objects.requireNonNull(appImageLayout);\n+        return Optional.ofNullable(appImageDir).map(appImageLayout.unresolve()::resolveAt).orElse(appImageLayout);\n+    }\n+\n@@ -94,0 +106,1 @@\n+    private AppImageLayout appImageLayout;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvBuilder.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT;\n@@ -29,0 +29,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n@@ -33,0 +34,1 @@\n+import java.nio.file.Path;\n@@ -34,0 +36,2 @@\n+import java.util.function.Function;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -35,0 +39,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -38,1 +43,3 @@\n-    static BuildEnv create(Map<String, ? super Object> params) throws ConfigException {\n+    static BuildEnv create(Map<String, ? super Object> params,\n+            Function<Path, ApplicationLayout> predefinedAppImageLayoutProvider,\n+            Function<Path, RuntimeLayout> predefinedRuntimeImageLayoutProvider) throws ConfigException {\n@@ -50,1 +57,2 @@\n-            PREDEFINED_RUNTIME_IMAGE.copyInto(params, builder::appImageDir);\n+            var layout = predefinedRuntimeImageLayoutProvider.apply(PREDEFINED_RUNTIME_IMAGE.findIn(params).orElseThrow());\n+            builder.appImageLayout(layout);\n@@ -52,1 +60,2 @@\n-            PREDEFINED_APP_IMAGE.copyInto(params, builder::appImageDir);\n+            var layout = predefinedAppImageLayoutProvider.apply(PREDEFINED_APP_IMAGE.findIn(params).orElseThrow());\n+            builder.appImageLayout(layout);\n@@ -54,1 +63,1 @@\n-            builder.appImageDirForPackage();\n+            builder.appImageDirFor(pkg.orElseThrow());\n@@ -62,2 +71,3 @@\n-    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(\n-            BuildEnv.class, BuildEnvFromParams::create);\n+    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n+        return create(params, PLATFORM_APPLICATION_LAYOUT::resolveAt, RuntimeLayout.DEFAULT::resolveAt);\n+    });\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvFromParams.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        return createApplicationBuilder(params, launcherMapper, appLayout, Optional.of(RuntimeLayout.DEFAULT));\n+        return createApplicationBuilder(params, launcherMapper, appLayout, RuntimeLayout.DEFAULT, Optional.of(RuntimeLayout.DEFAULT));\n@@ -87,1 +87,2 @@\n-            ApplicationLayout appLayout, Optional<RuntimeLayout> predefinedRuntimeLayout) throws ConfigException, IOException {\n+            ApplicationLayout appLayout, RuntimeLayout runtimeLayout,\n+            Optional<RuntimeLayout> predefinedRuntimeLayout) throws ConfigException, IOException {\n@@ -107,1 +108,1 @@\n-            appBuilder.appImageLayout(predefinedRuntimeLayout.orElseThrow());\n+            appBuilder.appImageLayout(runtimeLayout);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    public void createRuntime(AppImageLayout appImageLayout) throws PackagerException {\n+    public void create(AppImageLayout appImageLayout) throws PackagerException {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkRuntimeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -89,0 +90,1 @@\n+                validatedInstalledPackageLayout(relativeInstallDir),\n@@ -92,0 +94,9 @@\n+    PackageBuilder app(Application v) {\n+        app = v;\n+        return this;\n+    }\n+\n+    Application app() {\n+        return app;\n+    }\n+\n@@ -172,0 +183,9 @@\n+    PackageBuilder installedPackageLayout(AppImageLayout v) {\n+        installedPackageLayout = v;\n+        return this;\n+    }\n+\n+    Optional<AppImageLayout> installedPackageLayout() {\n+        return Optional.ofNullable(installedPackageLayout);\n+    }\n+\n@@ -176,0 +196,15 @@\n+    private AppImageLayout validatedInstalledPackageLayout(Path relativeInstallDir) {\n+        return installedPackageLayout().orElseGet(() -> {\n+            var theInstallDir = relativeInstallDir;\n+            if (type instanceof StandardPackageType stdType) {\n+                switch (stdType) {\n+                    case LINUX_DEB, LINUX_RPM, MAC_DMG, MAC_PKG -> {\n+                        theInstallDir = Path.of(\"\/\").resolve(theInstallDir);\n+                    }\n+                    default -> {}\n+                }\n+            }\n+            return app.imageLayout().resolveAt(theInstallDir).resetRootDirectory();\n+        });\n+    }\n+\n@@ -238,0 +273,1 @@\n+    private Application app;\n@@ -246,0 +282,1 @@\n+    private AppImageLayout installedPackageLayout;\n@@ -248,1 +285,0 @@\n-    private final Application app;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackageBuilder.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n@@ -41,1 +42,0 @@\n-import java.util.function.Function;\n@@ -44,0 +44,1 @@\n+import java.util.stream.Stream;\n@@ -65,1 +66,1 @@\n-        execute(appContextMapper.apply(createTaskContext(env, app)));\n+        execute(contextMapper.apply(createTaskContext(env, app)));\n@@ -84,2 +85,1 @@\n-        execute((StartupParameters)createPackagingTaskContext(env, pkg, outputDir,\n-                taskConfig, appImageLayoutForPackaging.apply(pkg)));\n+        execute((StartupParameters)createPackagingTaskContext(env, pkg, outputDir, taskConfig));\n@@ -95,1 +95,1 @@\n-        execute(pkgContextMapper.apply(createTaskContext((PackagingTaskContext)startupParameters)));\n+        execute(contextMapper.apply(createTaskContext((PackagingTaskContext)startupParameters)));\n@@ -138,1 +138,6 @@\n-    record AppImageBuildEnv<T extends Application, U extends AppImageLayout>(BuildEnv env, T app, U envLayout) {\n+    record AppImageBuildEnv<T extends Application, U extends AppImageLayout>(BuildEnv env, T app) {\n+        @SuppressWarnings(\"unchecked\")\n+        U envLayout() {\n+            return (U)app.imageLayout();\n+        }\n+\n@@ -141,1 +146,1 @@\n-            return (U)envLayout.resolveAt(env.appImageDir());\n+            return (U)env.appImageLayout();\n@@ -145,1 +150,1 @@\n-    record PackageBuildEnv<T extends Package, U extends AppImageLayout>(BuildEnv env, T pkg, U envLayout, Path outputDir) {\n+    record PackageBuildEnv<T extends Package, U extends AppImageLayout>(BuildEnv env, T pkg, Path outputDir) {\n@@ -147,2 +152,2 @@\n-        U resolvedLayout() {\n-            return (U)envLayout.resolveAt(env.appImageDir());\n+        U envLayout() {\n+            return (U)pkg.appImageLayout();\n@@ -151,2 +156,3 @@\n-        AppImageBuildEnv<Application, U> appImageBuildEnv() {\n-            return new AppImageBuildEnv<>(env, pkg.app(), envLayout);\n+        @SuppressWarnings(\"unchecked\")\n+        U resolvedLayout() {\n+            return (U)env.appImageLayout();\n@@ -168,1 +174,1 @@\n-        void execute(T pkg, AppImageDesc srcAppImage, AppImageDesc dstAppImage) throws IOException, PackagerException;\n+        void execute(T pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException, PackagerException;\n@@ -198,0 +204,5 @@\n+            private TaskBuilder(TaskID id, TaskConfig config) {\n+                this(id);\n+                config.action().ifPresent(this::setAction);\n+            }\n+\n@@ -228,0 +239,4 @@\n+            boolean hasAction() {\n+                return action != null;\n+            }\n+\n@@ -286,0 +301,6 @@\n+        Stream<TaskBuilder> configuredTasks() {\n+            return taskConfig.entrySet().stream().map(e -> {\n+                return new TaskBuilder(e.getKey(), e.getValue());\n+            });\n+        }\n+\n@@ -293,17 +314,1 @@\n-            appContextMapper(v);\n-            pkgContextMapper(v);\n-            return this;\n-        }\n-\n-        Builder appContextMapper(UnaryOperator<TaskContext> v) {\n-            appContextMapper = v;\n-            return this;\n-        }\n-\n-        Builder pkgContextMapper(UnaryOperator<TaskContext> v) {\n-            pkgContextMapper = v;\n-            return this;\n-        }\n-\n-        Builder appImageLayoutForPackaging(Function<Package, AppImageLayout> v) {\n-            appImageLayoutForPackaging = v;\n+            contextMapper = v;\n@@ -321,6 +326,1 @@\n-            return createPackagingTaskContext(env, pkg, outputDir, taskConfig,\n-                    validatedAppImageLayoutForPackaging().apply(pkg));\n-        }\n-\n-        private Function<Package, AppImageLayout> validatedAppImageLayoutForPackaging() {\n-            return Optional.ofNullable(appImageLayoutForPackaging).orElse(Package::packageLayout);\n+            return createPackagingTaskContext(env, pkg, outputDir, taskConfig);\n@@ -331,3 +331,1 @@\n-                    Optional.ofNullable(appContextMapper).orElse(UnaryOperator.identity()),\n-                    Optional.ofNullable(pkgContextMapper).orElse(UnaryOperator.identity()),\n-                    validatedAppImageLayoutForPackaging());\n+                    Optional.ofNullable(contextMapper).orElse(UnaryOperator.identity()));\n@@ -339,3 +337,1 @@\n-        private UnaryOperator<TaskContext> appContextMapper;\n-        private UnaryOperator<TaskContext> pkgContextMapper;\n-        private Function<Package, AppImageLayout> appImageLayoutForPackaging;\n+        private UnaryOperator<TaskContext> contextMapper;\n@@ -407,1 +403,1 @@\n-    static void copyAppImage(Package pkg, AppImageDesc srcAppImage, AppImageDesc dstAppImage) throws IOException {\n+    static void copyAppImage(Package pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException {\n@@ -411,1 +407,1 @@\n-    static void copyAppImage(AppImageDesc srcAppImage, AppImageDesc dstAppImage,\n+    static void copyAppImage(AppImageLayout srcAppImage, AppImageLayout dstAppImage,\n@@ -413,2 +409,1 @@\n-        final var srcLayout = srcAppImage.resolvedAppImagelayout();\n-        final var srcLayoutPathGroup = AppImageLayout.toPathGroup(srcLayout);\n+        final var srcLayoutPathGroup = toPathGroup(srcAppImage);\n@@ -416,1 +411,1 @@\n-        if (removeAppImageFile && srcLayout instanceof ApplicationLayout appLayout) {\n+        if (removeAppImageFile && srcAppImage instanceof ApplicationLayout appLayout) {\n@@ -421,1 +416,1 @@\n-        srcLayoutPathGroup.copy(AppImageLayout.toPathGroup(dstAppImage.resolvedAppImagelayout()), LinkOption.NOFOLLOW_LINKS);\n+        srcLayoutPathGroup.copy(toPathGroup(dstAppImage), LinkOption.NOFOLLOW_LINKS);\n@@ -435,2 +430,1 @@\n-            UnaryOperator<TaskContext> appContextMapper, UnaryOperator<TaskContext> pkgContextMapper,\n-            Function<Package, AppImageLayout> appImageLayoutForPackaging) {\n+            UnaryOperator<TaskContext> contextMapper) {\n@@ -439,3 +433,1 @@\n-        this.appContextMapper = Objects.requireNonNull(appContextMapper);\n-        this.pkgContextMapper = Objects.requireNonNull(pkgContextMapper);\n-        this.appImageLayoutForPackaging = Objects.requireNonNull(appImageLayoutForPackaging);\n+        this.contextMapper = Objects.requireNonNull(contextMapper);\n@@ -445,1 +437,1 @@\n-        return new DefaultTaskContext(taskGraph, env, app, app.asApplicationLayout(), Optional.empty());\n+        return new DefaultTaskContext(taskGraph, env, app, Optional.empty());\n@@ -449,3 +441,2 @@\n-        final var pkgEnv = BuildEnv.withAppImageDir(packagingContext.env.env(), packagingContext.srcAppImage.path());\n-        return new DefaultTaskContext(taskGraph, pkgEnv, packagingContext.env.pkg.app(),\n-                packagingContext.srcAppImage.asApplicationLayout(), Optional.of(packagingContext));\n+        return new DefaultTaskContext(taskGraph, packagingContext.env(),\n+                packagingContext.pkg().app(), Optional.of(packagingContext));\n@@ -455,1 +446,1 @@\n-            Path outputDir, Map<TaskID, TaskConfig> taskConfig, AppImageLayout appImageLayoutForPackaging) {\n+            Path outputDir, Map<TaskID, TaskConfig> taskConfig) {\n@@ -460,1 +451,3 @@\n-        Objects.requireNonNull(appImageLayoutForPackaging);\n+        if (pkg.appImageLayout().isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n@@ -462,2 +455,2 @@\n-        final AppImageDesc srcAppImageDesc;\n-        final AppImageDesc dstAppImageDesc;\n+        final AppImageLayout srcLayout;\n+        final AppImageLayout dstLayout;\n@@ -466,3 +459,2 @@\n-            \/\/ appImageDir() should point to a directory where the application image will be created.\n-            srcAppImageDesc = new AppImageDesc(appImageLayoutForPackaging, env.appImageDir());\n-            dstAppImageDesc = srcAppImageDesc;\n+            srcLayout = pkg.appImageLayout().resolveAt(env.appImageDir());\n+            dstLayout = srcLayout;\n@@ -470,2 +462,17 @@\n-            srcAppImageDesc = new AppImageDesc(pkg.app().imageLayout(),\n-                    pkg.predefinedAppImage().orElseThrow(UnsupportedOperationException::new));\n+            srcLayout = pkg.predefinedAppImage().map(predefinedAppImage -> {\n+                \/\/ Will create a package from the predefined app image.\n+                if (predefinedAppImage.equals(env.appImageDir())) {\n+                    return env.appImageLayout();\n+                } else {\n+                    return pkg.appImageLayout().resolveAt(predefinedAppImage);\n+                }\n+            }).orElseGet(() -> {\n+                \/\/ No predefined app image and no runtime builder.\n+                \/\/ This should be runtime packaging.\n+                if (pkg.isRuntimeInstaller()) {\n+                    return env.appImageLayout();\n+                } else {\n+                    \/\/ Can't create app image without runtime builder.\n+                    throw new UnsupportedOperationException();\n+                }\n+            });\n@@ -474,3 +481,3 @@\n-                \/\/ \"copy app image\" task action is undefined indicating\n-                \/\/ the package will use provided app image as-is.\n-                dstAppImageDesc = srcAppImageDesc;\n+                \/\/ \"copy app image\" task action is empty indicating\n+                \/\/ the package will use provided app image in place.\n+                dstLayout = srcLayout;\n@@ -478,1 +485,1 @@\n-                dstAppImageDesc = new AppImageDesc(appImageLayoutForPackaging, env.buildRoot().resolve(\"image\"));\n+                dstLayout = pkg.appImageLayout().resolveAt(env.buildRoot().resolve(\"image\"));\n@@ -482,4 +489,1 @@\n-        final var pkgEnv = new PackageBuildEnv<>(\n-                BuildEnv.withAppImageDir(env, dstAppImageDesc.path()), pkg, dstAppImageDesc.appImageLayout(), outputDir);\n-\n-        return new PackagingTaskContext(pkgEnv, srcAppImageDesc);\n+        return new PackagingTaskContext(BuildEnv.withAppImageLayout(env, dstLayout), pkg, outputDir, srcLayout);\n@@ -503,0 +507,6 @@\n+        } catch (ExceptionBox ex) {\n+            throw new PackagerException(ex.getCause());\n+        } catch (RuntimeException ex) {\n+            throw ex;\n+        } catch (PackagerException ex) {\n+            throw ex;\n@@ -504,7 +514,1 @@\n-            if (ex instanceof PackagerException pex) {\n-                throw pex;\n-            } else if (ex instanceof ExceptionBox bex) {\n-                throw new PackagerException(bex.getCause());\n-            } else {\n-                throw new PackagerException(ex);\n-            }\n+            throw new PackagerException(ex);\n@@ -514,2 +518,2 @@\n-    private record PackagingTaskContext(PackageBuildEnv<Package, AppImageLayout> env,\n-            AppImageDesc srcAppImage) implements TaskContext, StartupParameters {\n+    private record PackagingTaskContext(BuildEnv env, Package pkg, Path outputDir,\n+            AppImageLayout srcAppImage) implements TaskContext, StartupParameters {\n@@ -519,0 +523,2 @@\n+            Objects.requireNonNull(pkg);\n+            Objects.requireNonNull(outputDir);\n@@ -524,1 +530,1 @@\n-            return env.env;\n+            return env;\n@@ -541,1 +547,1 @@\n-                ((PackageTaskAction<Package, AppImageLayout>)taskAction).execute(env);\n+                ((PackageTaskAction<Package, AppImageLayout>)taskAction).execute(pkgBuildEnv());\n@@ -543,2 +549,2 @@\n-                ((CopyAppImageTaskAction<Package>)taskAction).execute(env.pkg(),\n-                        srcAppImage, new AppImageDesc(env.envLayout(), env.env().appImageDir()));\n+                ((CopyAppImageTaskAction<Package>)taskAction).execute(pkg(),\n+                        srcAppImage, env.appImageLayout());\n@@ -551,1 +557,5 @@\n-            return env.appImageBuildEnv();\n+            return new AppImageBuildEnv<>(env, pkg.app());\n+        }\n+\n+        PackageBuildEnv<Package, AppImageLayout> pkgBuildEnv() {\n+            return new PackageBuildEnv<>(env, pkg, outputDir);\n@@ -556,1 +566,1 @@\n-            Optional<ApplicationLayout> appLayout, Optional<PackagingTaskContext> pkg) implements TaskContext {\n+            Optional<PackagingTaskContext> pkg) implements TaskContext {\n@@ -562,1 +572,0 @@\n-            Objects.requireNonNull(appLayout);\n@@ -574,2 +583,2 @@\n-            } else if (pkg.isEmpty() && isPackageTask) {\n-                \/\/ Building application image, skip packaging tasks.\n+            } else if (pkg.isEmpty() && (isPackageTask || isCopyAppImageTask)) {\n+                \/\/ Building application image, skip packaging and copying app image tasks.\n@@ -577,2 +586,2 @@\n-            } else if (app.runtimeBuilder().isEmpty() && isBuildApplicationImageTask && !isCopyAppImageTask) {\n-                \/\/ Runtime builder is not present, skip building application image tasks.\n+            } else if (pkg.isPresent() && app.runtimeBuilder().isEmpty() && isBuildApplicationImageTask && !isCopyAppImageTask) {\n+                \/\/ Building a package, runtime builder is not present, skip building application image tasks.\n@@ -599,1 +608,1 @@\n-                pkg.orElseThrow().execute(taskAction);\n+                pkg.orElseThrow(UnsupportedOperationException::new).execute(taskAction);\n@@ -615,1 +624,1 @@\n-            return new AppImageBuildEnv<>(env, app, (T)appLayout.orElseThrow());\n+            return new AppImageBuildEnv<>(env, app);\n@@ -625,5 +634,1 @@\n-                try {\n-                    context.execute(config.action.orElseThrow());\n-                } catch (ExceptionBox ex) {\n-                    throw ExceptionBox.rethrowUnchecked(ex);\n-                }\n+                context.execute(config.action.orElseThrow());\n@@ -637,3 +642,1 @@\n-    private final Function<Package, AppImageLayout> appImageLayoutForPackaging;\n-    private final UnaryOperator<TaskContext> appContextMapper;\n-    private final UnaryOperator<TaskContext> pkgContextMapper;\n+    private final UnaryOperator<TaskContext> contextMapper;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagingPipeline.java","additions":107,"deletions":104,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n@@ -32,0 +35,1 @@\n+import java.util.Objects;\n@@ -33,0 +37,1 @@\n+import java.util.function.UnaryOperator;\n@@ -35,2 +40,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n@@ -44,3 +47,8 @@\n- *\n- * The layout is \"unresolved\" if the root directory is an empty string and\n- * \"resolved\" otherwise.\n+ * <p>\n+ * The layout is \"unresolved\" if the root directory is an empty path\n+ * ({@code Path.of(\"\")}) and \"resolved\" otherwise.\n+ * <p>\n+ * The return value of the {@link #runtimeDirectory()} method call is always a\n+ * path starting with the path returned by the {@link #rootDirectory()} method\n+ * call. Public methods without parameters and with the return type {@link Path}\n+ * in the derived interfaces must comply to this constrain.\n@@ -59,1 +67,1 @@\n-     * Root directory of this app image.\n+     * Root directory of this app image layout.\n@@ -62,1 +70,1 @@\n-     * @return the root directory of this app image\n+     * @return the root directory of this app image layout\n@@ -67,1 +75,21 @@\n-     * Creates a copy of this app image resolved at the given root directory.\n+     * Returns a copy of this app image layout with the root directory set to an empty\n+     * path ({@code Path.of(\"\")}) or this instance if its root directory is already\n+     * an empty path.\n+     *\n+     * @return an app image layout with the root directory set to an empty path\n+     *\/\n+    AppImageLayout resetRootDirectory();\n+\n+    \/**\n+     * Returns <code>true<\/code> if the root directory of this app image layout is\n+     * not an empty path, i.e, if it is not equal to <code>Path.of(\"\")<\/code>.\n+     *\n+     * @return <code>true<\/code> if the root directory of this app image layout is\n+     *         not an empty path\n+     *\/\n+    default boolean isResolved() {\n+        return !rootDirectory().equals(Path.of(\"\"));\n+    }\n+\n+    \/**\n+     * Creates a copy of this app image layout resolved at the given root directory.\n@@ -70,1 +98,29 @@\n-     * @return a copy of this app image resolved at the given root directory\n+     * @return a copy of this app image layout resolved at the given root directory\n+     *\/\n+    default AppImageLayout resolveAt(Path root) {\n+        return map(root::resolve);\n+    }\n+\n+    \/**\n+     * Returns a copy of this app image layout resolved such that its root directory\n+     * is set to an empty path ({@code Path.of(\"\")}) or this instance if its root\n+     * directory is already an empty path.\n+     *\n+     * @return an app image layout resolved at {@code Path.of(\"\")} path\n+     *\/\n+    default AppImageLayout unresolve() {\n+        if (isResolved()) {\n+            final var root = rootDirectory();\n+            return map(root::relativize);\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a copy of this app image layout with the specified mapper applied to\n+     * every path.\n+     *\n+     * @param mapper the mapper to use with every path in this app image layout.\n+     * @return the copy of this app image layout with the specified mapper applied\n+     *         to every path\n@@ -72,1 +128,1 @@\n-    AppImageLayout resolveAt(Path root);\n+    AppImageLayout map(UnaryOperator<Path> mapper);\n@@ -76,1 +132,1 @@\n-    *\/\n+     *\/\n@@ -79,0 +135,17 @@\n+        public Stub {\n+            Objects.requireNonNull(rootDirectory);\n+        }\n+\n+        public Stub(Path runtimeDirectory) {\n+            this(Path.of(\"\"), runtimeDirectory);\n+        }\n+\n+        @Override\n+        public AppImageLayout resetRootDirectory() {\n+            if (isResolved()) {\n+                return new Stub(runtimeDirectory);\n+            } else {\n+                return this;\n+            }\n+        }\n+\n@@ -80,2 +153,2 @@\n-        public AppImageLayout resolveAt(Path base) {\n-            return new Stub(resolveNullablePath(base, rootDirectory), resolveNullablePath(base, runtimeDirectory));\n+        public AppImageLayout map(UnaryOperator<Path> mapper) {\n+            return new Stub(mapNullablePath(mapper, rootDirectory), mapNullablePath(mapper, runtimeDirectory));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/AppImageLayout.java","additions":86,"deletions":13,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -31,0 +31,1 @@\n+import java.util.function.UnaryOperator;\n@@ -45,1 +46,20 @@\n-        return buildFrom(this).resolveAt(root).create();\n+        return (ApplicationLayout)AppImageLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default ApplicationLayout unresolve() {\n+        return (ApplicationLayout)AppImageLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default ApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return buildFrom(this).rootDirectory(\"\").create();\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default ApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return buildFrom(this).mutate(mapper).create();\n@@ -116,8 +136,8 @@\n-        public Builder resolveAt(Path base) {\n-            rootDirectory(resolveNullablePath(base, rootDirectory));\n-            launchersDirectory(resolveNullablePath(base, launchersDirectory));\n-            appDirectory(resolveNullablePath(base, appDirectory));\n-            runtimeDirectory(resolveNullablePath(base, runtimeDirectory));\n-            appModsDirectory(resolveNullablePath(base, appModsDirectory));\n-            desktopIntegrationDirectory(resolveNullablePath(base, desktopIntegrationDirectory));\n-            contentDirectory(resolveNullablePath(base, contentDirectory));\n+        public Builder mutate(UnaryOperator<Path> mapper) {\n+            rootDirectory(mapNullablePath(mapper, rootDirectory));\n+            launchersDirectory(mapNullablePath(mapper, launchersDirectory));\n+            appDirectory(mapNullablePath(mapper, appDirectory));\n+            runtimeDirectory(mapNullablePath(mapper, runtimeDirectory));\n+            appModsDirectory(mapNullablePath(mapper, appModsDirectory));\n+            desktopIntegrationDirectory(mapNullablePath(mapper, desktopIntegrationDirectory));\n+            contentDirectory(mapNullablePath(mapper, contentDirectory));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ApplicationLayout.java","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n- * The interface specifies the source app image layout with two transformations:\n- * package app image layout and installed app image layout.\n+ * The interface specifies the source app image and the installed app image layouts.\n@@ -39,7 +38,0 @@\n- * Package app image layout is the source app image layout resolved at the\n- * relative installation directory of the package. Additionally, to resolve the\n- * source layout, some packages may transform the source layout.\n- * <p>\n- * Use {@link #packageLayout()} or {@link #asPackageApplicationLayout()} to get\n- * the package app image layout.\n- * <p>\n@@ -58,1 +50,0 @@\n- * <th>Package app image layout<\/th>\n@@ -65,1 +56,0 @@\n- * <td>Duke\/bin\/foo.exe Duke\/app\/foo.jar<\/td>\n@@ -70,1 +60,0 @@\n- * <td>opt\/duke\/bin\/foo opt\/duke\/lib\/app\/foo.jar<\/td>\n@@ -76,1 +65,0 @@\n- * <td>Applications\/Duke.app\/Contents\/MacOS\/foo Applications\/Duke.app\/Contents\/app\/foo.jar<\/td>\n@@ -172,1 +160,0 @@\n-     * @see #packageLayout\n@@ -196,38 +183,0 @@\n-    \/**\n-     * Gets the layout of the installed app image of the application resolved at the\n-     * relative installation directory of this package.\n-     *\n-     * @return the layout of the installed app image of the application resolved at\n-     *         the relative installation directory of this package\n-     *\n-     * @see #relativeInstallDir\n-     * @see #appImageLayout\n-     * @see #installedPackageLayout\n-     *\/\n-    default AppImageLayout packageLayout() {\n-        return appImageLayout().resolveAt(relativeInstallDir());\n-    }\n-\n-    \/**\n-     * Returns the layout of the installed app image of the application resolved at\n-     * the relative installation directory of this package as\n-     * {@link ApplicationLayout} type or an empty {@link Optional} instance if the\n-     * layout object is of incompatible type.\n-     * <p>\n-     * Returns an empty {@link Optional} instance if {@link #isRuntimeInstaller()}\n-     * returns <code>true<\/code>.\n-     *\n-     * @return the layout of the installed app image of the application resolved at\n-     *         the relative installation directory of this package as\n-     *         {@link ApplicationLayout} type\n-     *\n-     * @see #packageLayout\n-     *\/\n-    default Optional<ApplicationLayout> asPackageApplicationLayout() {\n-        if (packageLayout() instanceof ApplicationLayout layout) {\n-            return Optional.of(layout);\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n@@ -240,1 +189,0 @@\n-     * @see #packageLayout\n@@ -242,16 +190,1 @@\n-    default AppImageLayout installedPackageLayout() {\n-        return asStandardPackageType().map(stdType -> {\n-            switch (stdType) {\n-                case LINUX_DEB, LINUX_RPM, MAC_DMG, MAC_PKG -> {\n-                    return packageLayout().resolveAt(Path.of(\"\/\"));\n-                }\n-                case WIN_EXE, WIN_MSI -> {\n-                    return packageLayout();\n-                }\n-                default -> {\n-                    \/\/ Should never get here\n-                    throw new IllegalStateException();\n-                }\n-            }\n-        }).orElseThrow(UnsupportedOperationException::new);\n-    }\n+    AppImageLayout installedPackageLayout();\n@@ -337,1 +270,1 @@\n-            Path relativeInstallDir) implements Package {\n+            AppImageLayout installedPackageLayout, Path relativeInstallDir) implements Package {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/Package.java","additions":3,"deletions":70,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    void createRuntime(AppImageLayout appImageLayout) throws PackagerException;\n+    void create(AppImageLayout appImageLayout) throws PackagerException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -42,2 +43,21 @@\n-        return create(new AppImageLayout.Stub(resolveNullablePath(root, rootDirectory()),\n-                resolveNullablePath(root, runtimeDirectory())));\n+        return (RuntimeLayout)AppImageLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default RuntimeLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(runtimeDirectory());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default RuntimeLayout unresolve() {\n+        return (RuntimeLayout)AppImageLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default RuntimeLayout map(UnaryOperator<Path> mapper) {\n+        return create(new RuntimeLayout.Stub(mapNullablePath(mapper, rootDirectory()),\n+                mapNullablePath(mapper, runtimeDirectory())));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeLayout.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-public class ResourceLocator {\n-    public ResourceLocator() {\n+public final class ResourceLocator {\n+    private ResourceLocator() {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/ResourceLocator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -473,0 +473,17 @@\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(entries);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        PathGroup other = (PathGroup) obj;\n+        return Objects.equals(entries, other.entries);\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PathGroup.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -29,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -50,2 +52,7 @@\n-    public static Path resolveNullablePath(Path base, Path path) {\n-        return Optional.ofNullable(path).map(base::resolve).orElse(null);\n+    public static Path mapNullablePath(UnaryOperator<Path> mapper, Path path) {\n+        Objects.requireNonNull(mapper);\n+        if (path != null) {\n+            return mapper.apply(path);\n+        } else {\n+            return null;\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PathUtils.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.jpackage.internal.model.Package;\n@@ -50,1 +49,0 @@\n-                .appImageLayoutForPackaging(Package::appImageLayout)\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinPackagingPipeline.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+                pkg.installedPackageLayout(),\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinExePackage.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.javac.PreviewFeature;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/JShellConsole.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -68,1 +66,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jshell\/share\/classes\/module-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,1 +166,1 @@\n-     * {@code \"Garbage collection performed by the JVM\"\"}.\n+     * {@code \"Garbage collection performed by the JVM\"}.\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/EventTypeInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.nio.file.Paths;\n@@ -50,1 +51,1 @@\n- * Specify which events should be enabled and what kind information each\n+ * Specify which events should be enabled and what kind of information each\n@@ -62,1 +63,1 @@\n- * The following table shows the options names to use with {@link #setRecordingOptions(long, Map)}\n+ * The following table shows the option names to use with {@link #setRecordingOptions(long, Map)}\n@@ -70,1 +71,1 @@\n- * <th scope=\"col\">Descripion<\/th>\n+ * <th scope=\"col\">Description<\/th>\n@@ -110,1 +111,1 @@\n- * <td>Specifies the size, measured in bytes, at which data is kept in disk\n+ * <td>Specifies the size, measured in bytes, at which data is kept in the disk\n@@ -134,2 +135,2 @@\n- * is relative to the working directory where the target JVM was started.}<\/td>\n- * <td>{@code \"c:\\recording\\recotding.jfr\"},<br>\n+ * is relative to the working directory where the target JVM was started.<\/td>\n+ * <td>{@code \"c:\\recording\\recording.jfr\"},<br>\n@@ -148,1 +149,1 @@\n- * <td>Sets how long the recording should be running<\/td>\n+ * <td>Specifies the duration of the recording.<\/td>\n@@ -290,1 +291,1 @@\n-     * <th scope=\"col\">Descripion<\/th>\n+     * <th scope=\"col\">Description<\/th>\n@@ -340,1 +341,1 @@\n-     * To be able to read from a running recording the value must be set<\/td>\n+     * To be able to read from a running recording the value must be set to<\/td>\n@@ -358,1 +359,1 @@\n-     * @throws IllegalArgumentException if a recording with the iD doesn't\n+     * @throws IllegalArgumentException if a recording with the ID doesn't\n@@ -428,1 +429,1 @@\n-     * @param recordingId the ID of the recordings to get settings for\n+     * @param recordingId the ID of the recording to get settings for\n@@ -525,1 +526,1 @@\n-     * Returns the list of the available recordings, not necessarily running.\n+     * Returns the list of available recordings, not necessarily running.\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/FlightRecorderMXBean.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-     * {@code \"The duration an event must exceed to be be recorded\"}).\n+     * {@code \"The duration an event must exceed to be recorded\"}).\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/SettingDescriptorInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1713,1 +1713,2 @@\n-                          [\"fmovs\", \"fmov\", \"sw\"], [\"fmovd\", \"fmov\", \"dx\"]])\n+                          [\"fmovs\", \"fmov\", \"sw\"], [\"fmovd\", \"fmov\", \"dx\"],\n+                          [\"fmovwh\", \"fmov\", \"hw\"], [\"fmovhw\", \"fmov\", \"wh\"]])\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -446,1 +446,1 @@\n-TEST(BasicShenandoahSimpleBitMapTest, minimum_test) {\n+TEST_F(ShenandoahSimpleBitMapTest, minimum_test) {\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahSimpleBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+        int ri = reversed.length();\n@@ -131,1 +132,1 @@\n-          ASSERT_EQ(e, reversed.pop());\n+          ASSERT_EQ(e, reversed.at(--ri));\n@@ -133,0 +134,1 @@\n+        ASSERT_EQ(ri, 0);\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zArray.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-      if (!compare_limits(a->category_limit(NMTUtil::index_to_tag(i)),\n-                          b->category_limit(NMTUtil::index_to_tag(i)))) {\n+      if (!compare_limits(a->mem_tag_limit(NMTUtil::index_to_tag(i)),\n+                          b->mem_tag_limit(NMTUtil::index_to_tag(i)))) {\n@@ -95,1 +95,1 @@\n-TEST(NMT, MallocLimitCategoryEnumNames) {\n+TEST(NMT, MallocLimitMemTagEnumNames) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_malloclimit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,2 +91,2 @@\n-    int category = i % (mt_number_of_tags - 1);\n-    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MemTag)category);\n+    int mtag = i % (mt_number_of_tags - 1);\n+    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MemTag)mtag);\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_totals.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#############################################################################\n+#\n+# List of quarantined tests failing with jvmti stress agent in any mode.\n+#\n+#############################################################################\n+\n+\n+compiler\/macronodes\/TestTopInMacroElimination.java      8362832 generic-all\n+\n+gc\/stringdedup\/TestStringDeduplicationAgeThreshold.java 8362562 generic-all\n+gc\/stringdedup\/TestStringDeduplicationInterned.java     8362562 generic-all\n+gc\/stringdedup\/TestStringDeduplicationPrintOptions.java 8362562 generic-all\n+\n+\n+serviceability\/jvmti\/events\/SingleStep\/singlestep02\/singlestep02.java       8362350 generic-all\n+vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t007\/TestDescription.java\t8362350 generic-all\n+\n+# Incompatbile tests\n+\n+# IR\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v016-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v016-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v032-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v032-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v016-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v016-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v032-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v032-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v004-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v004-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v008-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v008-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v016-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v016-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-A            0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-U            0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v004-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v004-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v008-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v008-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v016-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v016-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v032-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v032-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v064-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v064-U           0000000 generic-all\n+\n+# Requires solo jvmti capabilities\n+\n+compiler\/jvmci\/events\/JvmciShutdownEventTest.java                           0000000 generic-all\n+\n+# jdwp\n+runtime\/6294277\/SourceDebugExtension.java                                   0000000 generic-all\n+\n+# heap stats\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorArrayAllSampledTest.java                  0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorEventOnOffTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorGCParallelTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorGCSerialTest.java                         0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorGCTest.java                               0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorIllegalArgumentTest.java                  0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInitialAllocationTest.java                0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInterpreterArrayTest.java                 0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInterpreterObjectTest.java                0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorMultiArrayTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorNoCapabilityTest.java                     0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorRecursiveTest.java                        0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatArrayCorrectnessTest.java             0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatIntervalTest.java                     0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatObjectCorrectnessTest.java            0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatSimpleTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorTest.java                                 0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadDisabledTest.java                   0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadOnOffTest.java                      0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadTest.java                           0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorTwoAgentsTest.java                        0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorVMEventsTest.java#id0                     0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorVMEventsTest.java#id1                     0000000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-jvmti-stress-agent.txt","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8358781\n+ * @summary Regression test for -XX:-TypeProfileCasts crash\n+ * @requires vm.debug\n+ * @run main\/othervm -XX:-TypeProfileCasts -XX:CompileThresholdScaling=0.01\n+ *                   compiler.arguments.TestProfileCasts\n+ *\/\n+package compiler.arguments;\n+\n+public class TestProfileCasts {\n+    static class Foo {\n+    }\n+\n+    private static void test(Object o) {\n+        if (o instanceof Foo) {\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 100; i++) {\n+            test(new Foo());\n+            test(null);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestProfileCasts.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361842\n+ * @summary Verify the effectiveness of the `VerifyIntrinsicChecks` VM flag\n+ *          through (bypassing `StringCoding::encodeAsciiArray`, and) feeding\n+ *          invalid input to an intrinsified `StringCoding::encodeAsciiArray0`\n+ *          (note the `0` suffix!).\n+ * @library \/compiler\/patches\n+ * @library \/test\/lib\n+ * @build java.base\/java.lang.Helper\n+ * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n+ *          development flag\n+ * @requires vm.debug == true & vm.flavor == \"server\" & !vm.graal.enabled\n+ * @run main\/othervm compiler.intrinsics.TestVerifyIntrinsicChecks verify\n+ *\/\n+\n+package compiler.intrinsics;\n+\n+import java.lang.Helper;\n+import java.time.Instant;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public final class TestVerifyIntrinsicChecks {\n+\n+    public static void main(String[] args) throws Exception {\n+        switch (args[0]) {\n+            case \"verify\" -> {\n+                log(\"Starting JVM in a separate process to verify the crash\");\n+                OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n+                        \"-Xcomp\",\n+                        \"-XX:-TieredCompilation\",\n+                        \"-XX:CompileCommand=inline,java.lang.StringCoding::encodeAsciiArray0\",\n+                        \"-XX:+VerifyIntrinsicChecks\",\n+                        \"--patch-module\", \"java.base=%s\/java.base\".formatted(System.getProperty(\"test.patch.path\")),\n+                        \"compiler.intrinsics.TestVerifyIntrinsicChecks\",\n+                        \"crash\");\n+                outputAnalyzer.shouldContain(\"unexpected null in intrinsic\");\n+                outputAnalyzer.shouldNotHaveExitValue(0);\n+            }\n+            case \"crash\" -> {\n+                log(\"Triggering the crash\");\n+                warmUpIntrinsicMethod();\n+                violateIntrinsicMethodContract();\n+            }\n+            default -> throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    private static void warmUpIntrinsicMethod() {\n+        log(\"Warming up the intrinsic method\");\n+        char[] sa = createAsciiChars(8192);\n+        byte[] sp = new byte[4096];\n+        for (int i = 0; i < 1_000; i++) {\n+            Helper.StringCodingEncodeAsciiArray0(sa, i, sp, 0, sp.length - i);\n+        }\n+    }\n+\n+    private static char[] createAsciiChars(int length) {\n+        char[] buffer = new char[length];\n+        for (int i = 0; i < length; i++) {\n+            buffer[i] = (char) (i % '\\u0080');\n+        }\n+        return buffer;\n+    }\n+\n+    private static void violateIntrinsicMethodContract() {\n+        log(\"Violating the intrinsic method contract (sa=null)\");\n+        Helper.StringCodingEncodeAsciiArray0(null, 1, null, 1, 1);\n+    }\n+\n+    private synchronized static void log(String format, Object... args) {\n+        Object[] extendedArgs = new Object[2 + args.length];\n+        extendedArgs[0] = Instant.now();\n+        extendedArgs[1] = Thread.currentThread().getName();\n+        System.arraycopy(args, 0, extendedArgs, extendedArgs.length - args.length, args.length);\n+        String extendedFormat = \"%%s [%%s] %s%%n\".formatted(format);\n+        System.out.printf(extendedFormat, extendedArgs);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestVerifyIntrinsicChecks.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+\n@@ -49,2 +50,20 @@\n-\/**\n- * This test was derived from compiler.intrinsics.string.TestHasNegatives\n+\n+\/*\n+ * @test\n+ * @bug 8281146\n+ * @summary Verify `StringCoding::countPositives` intrinsic Java wrapper checks\n+ *          by enabling the ones in the VM intrinsic using\n+ *          `-XX:+VerifyIntrinsicChecks`\n+ * @comment This does not check out-of-range conditions. The\n+ *          `-XX:+VerifyIntrinsicChecks` version of this test simply ensures\n+ *          that the VM intrinsic will produce no spurious errors.\n+ * @key randomness\n+ * @library \/compiler\/patches\n+ * @library \/test\/lib\n+ * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n+ *          development flag\n+ * @requires vm.debug == true\n+ * @build java.base\/java.lang.Helper\n+ * @run main\/othervm\n+ *      -XX:+VerifyIntrinsicChecks\n+ *      compiler.intrinsics.string.TestCountPositives\n@@ -52,0 +71,1 @@\n+\n@@ -56,1 +76,0 @@\n-import java.util.stream.IntStream;\n@@ -60,0 +79,3 @@\n+\/**\n+ * This test was derived from {@link TestHasNegatives}.\n+ *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestCountPositives.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,20 @@\n+\/*\n+ * @test\n+ * @bug 6896617 8274242\n+ * @summary Verify `sun.nio.cs.ISO_8859_1.Encoder::encodeISOArray` intrinsic\n+ *          Java wrapper checks by enabling the ones in the VM intrinsic using\n+ *          `-XX:+VerifyIntrinsicChecks`\n+ * @comment This does not check out-of-range conditions. The\n+ *          `-XX:+VerifyIntrinsicChecks` version of this test simply ensures\n+ *          that the VM intrinsic will produce no spurious errors.\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n+ *          development flag\n+ * @requires vm.debug == true\n+ * @run main\/othervm\/timeout=1200\n+ *      -XX:+VerifyIntrinsicChecks\n+ *      --add-opens=java.base\/sun.nio.cs=ALL-UNNAMED -Xbatch -Xmx256m\n+ *      compiler.intrinsics.string.TestEncodeIntrinsics\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestEncodeIntrinsics.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+\n@@ -49,0 +50,21 @@\n+\/*\n+ * @test\n+ * @bug 8054307\n+ * @summary Verify `StringCoding::hasNegatives` intrinsic Java wrapper checks\n+ *          by enabling the ones in the VM intrinsic using\n+ *          `-XX:+VerifyIntrinsicChecks`\n+ * @comment This does not check out-of-range conditions. The\n+ *          `-XX:+VerifyIntrinsicChecks` version of this test simply ensures\n+ *          that the VM intrinsic will produce no spurious errors.\n+ * @key randomness\n+ * @library \/compiler\/patches\n+ * @library \/test\/lib\n+ * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n+ *          development flag\n+ * @requires vm.debug == true\n+ * @build java.base\/java.lang.Helper\n+ * @run main\/othervm\n+ *      -XX:+VerifyIntrinsicChecks\n+ *      compiler.intrinsics.string.TestHasNegatives\n+ *\/\n+\n@@ -53,1 +75,0 @@\n-import java.util.stream.IntStream;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestHasNegatives.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jtreg.SkippedException;\n@@ -352,0 +353,1 @@\n+        checkCompatibleFlags();\n@@ -778,0 +780,8 @@\n+    private void checkCompatibleFlags() {\n+        for (String flag : Utils.getTestJavaOpts()) {\n+            if (flag.contains(\"-agentpath\")) {\n+                throw new SkippedException(\"Can't run test with agent.\");\n+            }\n+        }\n+    }\n+\n@@ -784,0 +794,3 @@\n+            if (flag.contains(\"agentpath\")) {\n+                throw new SkippedException(\"Can't run test with -javaagent\");\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n@@ -384,1 +384,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n@@ -420,1 +420,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n@@ -456,1 +456,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.ADD_I, \"1\"})\n@@ -492,1 +492,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.ADD_I, \"1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/InvariantCodeMotionReassociateAddSub.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -709,3 +709,5 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n-    \/\/ Interestingly, it now vectorizes for native, but not for arrays.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -723,3 +725,5 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n-    \/\/ Interestingly, it now vectorizes for native, but not for arrays.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -801,6 +805,0 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.ADD_VI,        \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"false\", \"AlignVector\", \"false\" },\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -810,1 +808,1 @@\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"true\", \"AlignVector\", \"false\" },\n+        applyIf = { \"AlignVector\", \"false\" },\n@@ -813,2 +811,0 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n@@ -826,6 +822,0 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.ADD_VI,        \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"false\", \"AlignVector\", \"false\" },\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -835,1 +825,1 @@\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"true\", \"AlignVector\", \"false\" },\n+        applyIf = { \"AlignVector\", \"false\" },\n@@ -838,2 +828,0 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":12,"deletions":24,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Scenario;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+\/*\n+ * @test\n+ * @bug 8356176\n+ * @summary Test vectorization of loops over MemorySegment with unaligned access\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentByteSizeLongLoopLimit\n+ *\/\n+\n+\n+public class TestMemorySegmentByteSizeLongLoopLimit {\n+    public static int SIZE = 10_000;\n+\n+    public static int[] a = new int[SIZE];\n+    public static long[] b = new long[SIZE];\n+\n+    public static MemorySegment msA = MemorySegment.ofArray(a);\n+    public static MemorySegment msB = MemorySegment.ofArray(b);\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\",        \"> 0\",\n+                  IRNode.STORE_VECTOR,                          \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    public static void test() {\n+        for (long i = 0; i < msA.byteSize() \/ 8L; i++) {\n+            int v = msA.get(ValueLayout.JAVA_INT_UNALIGNED, i * 4L);\n+            msB.set(ValueLayout.JAVA_LONG_UNALIGNED, i * 8L, v + 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentByteSizeLongLoopLimit.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+\/*\n+ * @test\n+ * @bug 8356176\n+ * @summary Test vectorization of loops over MemorySegment stored in field\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentField\n+ *\/\n+\n+public class TestMemorySegmentField {\n+    static int SIZE = 10_000;\n+    static MemorySegment MS = Arena.ofAuto().allocate(SIZE * 4);\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    static int zeroInvarI = 0;\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    public static void testFields() {\n+        int invar = zeroInvarI;\n+        for (long i = 0; i < MS.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = MS.get(ValueLayout.JAVA_BYTE, adr);\n+            MS.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentField.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -42,0 +42,5 @@\n+    @jdk.internal.vm.annotation.ForceInline\n+    public static int StringCodingEncodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len) {\n+        return StringCoding.encodeAsciiArray0(sa, sp, da, dp, len);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/patches\/java.base\/java\/lang\/Helper.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-    \/\/ The ConvI2L can be split through the AddI, creating a mix of\n+    \/\/ The ConvI2L can be pushed through the AddI, creating a mix of\n@@ -135,2 +135,1 @@\n-        counts = {IRNode.POPULATE_INDEX, \"=0\"})\n-    \/\/ See: JDK-8332878\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n@@ -158,2 +157,1 @@\n-        counts = {IRNode.POPULATE_INDEX, \"=0\"})\n-    \/\/ See: JDK-8332878\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                output.shouldContain(\"(sent by safepoint timeout handler\");\n+                output.shouldContain(\"(sent by safepoint timeout handler)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/Safepoint\/TestAbortVMOnSafepointTimeout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -260,0 +260,10 @@\n+\n+        \/\/ Training run with -XX:+PrintTieredEvents (see JDK-8362530).\n+        printTestCase(\"Training run with -XX:+PrintTieredEvents\");\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=record\",\n+            \"-XX:+PrintTieredEvents\",\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-cp\", appJar, helloClass);\n+        out = CDSTestUtils.executeAndLog(pb, \"train-with-tiered-events\");\n+        out.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotFlags\/AOTFlags.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+                    \"share\/interpreter\",\n","filename":"test\/hotspot\/jtreg\/sources\/TestIncludesAreSorted.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#############################################################################\n+#\n+# List of quarantined tests failing with jvmti stress agent in any mode.\n+#\n+#############################################################################\n+\n+\n+sun\/security\/ssl\/SSLEngineImpl\/SSLEngineKeyLimit.java                       8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java                         8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTNoSessionCreation.java              8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTParallel.java                       8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTSequence.java                       8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/ResumptionUpdateBoundValues.java            8362658 generic-all\n+sun\/security\/ssl\/SSLSocketImpl\/SSLSocketKeyLimit.java                       8362658 generic-all\n+\n+\n+# List of tests incompatible with jvmti stress agent or requiring more investigation\n+\n+com\/sun\/jdi\/EATests.java#id0                                                0000000 generic-all\n+com\/sun\/jdi\/ThreadMemoryLeakTest.java                                       0000000 generic-all\n+\n+# weak referenced are not cleared\n+java\/lang\/WeakPairMap\/Driver.java                                           0000000 generic-all\n+java\/lang\/ref\/ReachabilityFenceTest.java                                    0000000 generic-all\n","filename":"test\/jdk\/ProblemList-jvmti-stress-agent.txt","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,3 @@\n- * @bug 8256321\n- * @summary Verifies profile properties are the same before\/after activation\n+ * @bug 8256321 8359380\n+ * @summary Verifies built-in profile properties are the same before and after\n+ *          activation and in copies of built-in profiles\n@@ -49,6 +50,9 @@\n-        \/\/ check default values, before profile activation\n-        test(srgb, TYPE_RGB, 3, CLASS_DISPLAY);\n-        test(gray, TYPE_GRAY, 1, CLASS_DISPLAY);\n-        test(xyz, TYPE_XYZ, 3, CLASS_ABSTRACT);\n-        test(lrgb, TYPE_RGB, 3, CLASS_DISPLAY);\n-        test(pycc, TYPE_3CLR, 3, CLASS_COLORSPACECONVERSION);\n+        \/\/ checks default values before built-in profiles are activated\n+        test(srgb, gray, xyz, lrgb, pycc);\n+\n+        \/\/ activates built-in profiles and creates copies\n+        ICC_Profile srgbCopy = ICC_Profile.getInstance(srgb.getData());\n+        ICC_Profile grayCopy = ICC_Profile.getInstance(gray.getData());\n+        ICC_Profile xyzCopy = ICC_Profile.getInstance(xyz.getData());\n+        ICC_Profile lrgbCopy = ICC_Profile.getInstance(lrgb.getData());\n+        ICC_Profile pyccCopy = ICC_Profile.getInstance(pycc.getData());\n@@ -56,6 +60,6 @@\n-        \/\/ activate profiles\n-        srgb.getData();\n-        gray.getData();\n-        xyz.getData();\n-        lrgb.getData();\n-        pycc.getData();\n+        \/\/ checks default values after profile activation\n+        test(srgb, gray, xyz, lrgb, pycc);\n+\n+        \/\/ checks default values in copies of the built-in profiles\n+        test(srgbCopy, grayCopy, xyzCopy, lrgbCopy, pyccCopy);\n+    }\n@@ -63,1 +67,3 @@\n-        \/\/ check default values, after profile activation\n+    private static void test(ICC_Profile srgb, ICC_Profile gray,\n+                             ICC_Profile xyz, ICC_Profile lrgb,\n+                             ICC_Profile pycc) {\n","filename":"test\/jdk\/java\/awt\/color\/CheckDefaultProperties.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    private static final String EXCEPTION_MSG = \"Built-in profile cannot be modified\";\n+    private static final String EXCEPTION_MSG = \"Can't modify built-in profile\";\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/BuiltInProfileCheck\/BuiltInProfileCheck.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_ColorSpace;\n+import java.awt.color.ICC_Profile;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.BufferedImageOp;\n+import java.awt.image.ColorConvertOp;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+\n+\/**\n+ * @test\n+ * @bug 8272860 8359380\n+ * @summary Verifies that ICC_Profile methods work correctly after a\n+ *          ColorConvertOp transformation\n+ * @library \/test\/lib\n+ *\/\n+public final class GetProfileDataAfterTransform {\n+\n+    private static final int[] CSS = {\n+            ColorSpace.CS_CIEXYZ, ColorSpace.CS_GRAY,\n+            ColorSpace.CS_LINEAR_RGB, ColorSpace.CS_PYCC, ColorSpace.CS_sRGB\n+    };\n+\n+    \/**\n+     * The main process records expected get*() values before conversion and\n+     * passes them to a subprocess, which verifies it after the transform.\n+     *\n+     * @param  args If empty, the main process runs all color space pairs and\n+     *         spawns subprocesses. If not empty, args[0] and args[1] are source\n+     *         and target color space constants, followed by expected profile\n+     *         values to validate in the subprocess.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            for (int csFrom : CSS) {\n+                for (int csTo : CSS) {\n+                    var from = (ICC_ColorSpace) ColorSpace.getInstance(csFrom);\n+                    var to = (ICC_ColorSpace) ColorSpace.getInstance(csTo);\n+\n+                    ICC_Profile profileFrom = from.getProfile();\n+                    ICC_Profile profileTo = to.getProfile();\n+\n+                    List<String> cmd = new ArrayList<>();\n+                    cmd.add(GetProfileDataAfterTransform.class.getSimpleName());\n+\n+                    cmd.add(String.valueOf(csFrom));\n+                    cmd.add(String.valueOf(csTo));\n+\n+                    for (ICC_Profile p : List.of(profileFrom, profileTo)) {\n+                        cmd.add(String.valueOf(p.getPCSType()));\n+                        cmd.add(String.valueOf(p.getProfileClass()));\n+                        cmd.add(String.valueOf(p.getMinorVersion()));\n+                        cmd.add(String.valueOf(p.getMajorVersion()));\n+                        cmd.add(String.valueOf(p.getColorSpaceType()));\n+                        cmd.add(String.valueOf(p.getNumComponents()));\n+                    }\n+\n+                    OutputAnalyzer output = ProcessTools.executeTestJava(cmd);\n+                    output.shouldHaveExitValue(0).stdoutShouldBeEmpty()\n+                          .stderrShouldBeEmpty();\n+                }\n+            }\n+        } else {\n+            int csFrom = Integer.parseInt(args[0]);\n+            int csTo = Integer.parseInt(args[1]);\n+            var from = (ICC_ColorSpace) ColorSpace.getInstance(csFrom);\n+            var to = (ICC_ColorSpace) ColorSpace.getInstance(csTo);\n+\n+            BufferedImageOp op = new ColorConvertOp(from, to, null);\n+            \/\/ Note from.getProfile() and to.getProfile() are not loaded yet!\n+            op.filter(new BufferedImage(10, 10, TYPE_INT_RGB),\n+                      new BufferedImage(10, 10, TYPE_INT_RGB));\n+\n+            test(from.getProfile(), args, 2);\n+            test(to.getProfile(), args, 8);\n+        }\n+    }\n+\n+    private static void test(ICC_Profile profile, String[] args, int offset) {\n+        \/\/ Uncomment when JDK-8272860 is fixed\n+        \/\/ if (profile.getData() == null) {\n+        \/\/    throw new RuntimeException(\"Profile data is null\");\n+        \/\/ }\n+        if (profile.getPCSType() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong PCStype\");\n+        }\n+        if (profile.getProfileClass() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong ProfileClass\");\n+        }\n+        if (profile.getMinorVersion() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong MinorVersion\");\n+        }\n+        if (profile.getMajorVersion() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong MajorVersion\");\n+        }\n+        if (profile.getColorSpaceType() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong ColorSpaceType\");\n+        }\n+        if (profile.getNumComponents() != Integer.parseInt(args[offset])) {\n+            throw new RuntimeException(\"Wrong NumComponents\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/GetProfileDataAfterTransform.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,0 @@\n-#ifdef _AIX\n@@ -77,3 +76,0 @@\n-#else\n-        printf(\"%X %X\\n\", act.sa_flags, act.sa_mask);\n-#endif\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/childSignalDisposition\/exePrintSignalDisposition.c","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,2 @@\n-        lst.add(\"myCookie2=bar; path=\/dir; expires=Tue, 19 Aug 2025 16:00:00 GMT\");\n-        lst.add(\"myCookie3=test; path=\/dir; expires=Tue Aug 19 2025 16:00:00 GMT-0100\");\n+        lst.add(\"myCookie2=bar; path=\/dir; expires=Fri, 19 Aug 4242 16:00:00 GMT\");\n+        lst.add(\"myCookie3=test; path=\/dir; expires=Fri Aug 19 4242 16:00:00 GMT-0100\");\n@@ -67,1 +67,2 @@\n-            fail(\"Should have 5 cookies. Got only \"+ cookies.size() + \", expires probably didn't parse correctly\");\n+            fail(\"unexpected cookies: \" + cookies + \", should have 5 cookies. Got only \"\n+                    + cookies.size() + \", expires probably didn't parse correctly\");\n","filename":"test\/jdk\/java\/net\/CookieHandler\/B6644726.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-public class ProxyServer extends Thread implements Closeable {\n+public final class ProxyServer implements Closeable {\n@@ -100,3 +100,1 @@\n-    public ProxyServer(Integer port,\n-                       Boolean debug,\n-                       Credentials credentials)\n+    private ProxyServer(Integer port, Boolean debug, Credentials credentials)\n@@ -111,8 +109,1 @@\n-        setName(\"ProxyListener\");\n-        setDaemon(true);\n-        connections = new CopyOnWriteArrayList<Connection>();\n-        start();\n-    }\n-\n-    public ProxyServer(String s) {\n-        credentials = null;\n+        Thread.ofPlatform().name(\"ProxyListener\").daemon().start(this::run);\n@@ -151,1 +142,1 @@\n-    public void run() {\n+    private void run() {\n@@ -659,4 +650,5 @@\n-        ProxyServer ps = new ProxyServer(port, debug);\n-        System.out.println(\"Proxy server listening on port \" + ps.getPort());\n-        while (true) {\n-            Thread.sleep(5000);\n+        try (ProxyServer ps = new ProxyServer(port, debug)) {\n+            System.out.println(\"Proxy server listening on port \" + ps.getPort());\n+            while (true) {\n+                Thread.sleep(5000);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxyServer.java","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires (os.family == \"linux\" | os.family == \"mac\")\n+ * @requires (os.family == \"linux\" | os.family == \"mac\" | os.family == \"aix\")\n","filename":"test\/jdk\/java\/nio\/file\/DirectoryStream\/SecureDS.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8362448\n+ * @summary Verify DecimalFormat::format on doubles.\n+ * @run junit DoubleFormattingTest\n+ * @run junit\/othervm -Djdk.compat.DecimalFormat=true DoubleFormattingTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.util.Formatter;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class DoubleFormattingTest {\n+\n+    private static final boolean COMPAT = Boolean.getBoolean(\"jdk.compat.DecimalFormat\");\n+\n+    static Stream<Arguments> testFormat() {\n+        return Stream.of(\n+                Arguments.of(4.8726570057E288, 0),\n+                Arguments.of(7.3879E20, 0),\n+                Arguments.of(1.9400994884341945E25, 0),\n+                Arguments.of(6.3E-322, 324)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testFormat(double v, int minFractionDigits) {\n+        DecimalFormat df = (DecimalFormat) NumberFormat.getNumberInstance(Locale.ROOT);\n+        df.setGroupingUsed(false);\n+        df.setMinimumFractionDigits(minFractionDigits);\n+        String actual = df.format(v);\n+        Formatter fmt = new Formatter(Locale.ROOT);\n+        fmt.format(\"%.\" + minFractionDigits + \"f\", v);\n+        String expected = fmt.toString();\n+        if (COMPAT) {\n+            assertNotEquals(expected, actual);\n+        } else {\n+            assertEquals(expected, actual);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/DoubleFormattingTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8361638\n@@ -40,0 +41,1 @@\n+import static java.lang.constant.ConstantDescs.*;\n@@ -50,0 +52,1 @@\n+import java.util.Collections;\n@@ -53,5 +56,0 @@\n-import static java.lang.constant.ConstantDescs.CD_Double;\n-import static java.lang.constant.ConstantDescs.CD_Integer;\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_String;\n-\n@@ -64,0 +62,24 @@\n+    @Test\n+    void testExceptionalContracts() throws Throwable {\n+        generateTryCatchMethod(catchBuilder -> {\n+            Consumer<CodeBuilder.BlockCodeBuilder> handler = tb -> tb.pop().aconst_null().areturn();\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catching(CD_NPE, null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(null, handler));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(List.of(), null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(Collections.singletonList(null), null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingAll(null));\n+            catchBuilder.catchingMulti(List.of(CD_IOOBE, CD_NPE), tb -> {\n+                tb.invokevirtual(CD_Object, \"toString\", MTD_String);\n+                tb.astore(1);\n+            });\n+            catchBuilder.catchingAll(tb -> tb.pop().loadConstant(\"all\").areturn());\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catching(CD_int, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catching(CD_NPE, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catching(null, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingMulti(List.of(), handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingMulti(List.of(CD_Exception, CD_IOOBE), handler));\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catchingMulti(List.of(CD_long, CD_Throwable), handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingAll(handler));\n+        });\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.incubator.vector.Float16;\n@@ -159,0 +160,25 @@\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill_halffloat(int s, ToHalffloatF f) {\n+        return fill_halffloat(new short[s], f);\n+    }\n+\n+    static short[] fill_halffloat(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        if (a.length > 7) {\n+            a[0] = Float16.float16ToRawShortBits(Float16.MAX_VALUE);\n+            a[1] = Float16.float16ToRawShortBits(Float16.MIN_VALUE);\n+            a[2] = Float16.float16ToRawShortBits(Float16.NEGATIVE_INFINITY);\n+            a[3] = Float16.float16ToRawShortBits(Float16.POSITIVE_INFINITY);\n+            a[4] = Float16.float16ToRawShortBits(Float16.NaN);\n+            a[5] = (short)0.0;\n+            a[6] = Short.MIN_VALUE;\n+        }\n+        return a;\n+    }\n+\n+\n@@ -183,0 +209,4 @@\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16(i)\", (int s) -> fill_halffloat(s, i -> (short) (i * 100 + 1)))\n+    );\n+\n@@ -202,0 +232,3 @@\n+        else if (src == Float16.class) {\n+            return HALFFLOAT_GENERATORS;\n+        }\n@@ -209,1 +242,1 @@\n-        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Float16.class)) {\n@@ -213,1 +246,1 @@\n-            for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+            for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Float16.class)) {\n@@ -228,1 +261,1 @@\n-        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Float16.class)) {\n@@ -233,1 +266,1 @@\n-                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Float16.class)) {\n@@ -248,1 +281,1 @@\n-        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+        for (Class<?> srcE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Float16.class)) {\n@@ -251,1 +284,1 @@\n-                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class)) {\n+                for (Class<?> dstE : List.of(byte.class, short.class, int.class, long.class, float.class, double.class, Float16.class)) {\n@@ -264,1 +297,0 @@\n-\n@@ -274,1 +306,2 @@\n-        else if (to == float.class)\n+        \/\/ Treat halffloat as float.\n+        else if (to == float.class || to == Float16.class)\n@@ -285,1 +318,1 @@\n-        else if (from == short.class)\n+        else if (from == short.class || from == Float16.class)\n@@ -302,1 +335,1 @@\n-        else if (to == short.class)\n+        else if (to == short.class || to == Float16.class)\n@@ -338,0 +371,2 @@\n+                                    VectorSpecies srcSpecies,\n+                                    VectorSpecies dstSpecies,\n@@ -339,0 +374,4 @@\n+        if (srcSpecies.elementType() == dstSpecies.elementType()) {\n+            System.arraycopy(src, srcPos, dest, destPos, length);\n+            return;\n+        }\n@@ -341,1 +380,8 @@\n-            Array.set(dest, destPos + i, c.apply(v));\n+            if (srcSpecies.elementType() == Float16.class) {\n+                v = (Number) Float.float16ToFloat(v.shortValue());\n+            }\n+            v = (Number) c.apply(v);\n+            if (dstSpecies.elementType() == Float16.class) {\n+                v = (Number) Float16.valueOf(v.floatValue());\n+            }\n+            Array.set(dest, destPos + i, v);\n@@ -423,2 +469,8 @@\n-        Object expected = Array.newInstance(destSpecies.elementType(), out_len);\n-        Object actual = Array.newInstance(destSpecies.elementType(), out_len);\n+        Object expected = null, actual = null;\n+        if (destSpecies.elementType() == Float16.class) {\n+            expected = Array.newInstance(short.class, out_len);\n+            actual = Array.newInstance(short.class, out_len);\n+        } else {\n+            expected = Array.newInstance(destSpecies.elementType(), out_len);\n+            actual = Array.newInstance(destSpecies.elementType(), out_len);\n+        }\n@@ -435,1 +487,1 @@\n-                copyConversionArray(in, i, expected, start_idx + j, src_species_len, convertValue);\n+                copyConversionArray(in, i, expected, start_idx + j, src_species_len, srcSpecies, destSpecies, convertValue);\n@@ -438,1 +490,1 @@\n-                copyConversionArray(in, start_idx + i, expected, j, dst_species_len, convertValue);\n+                copyConversionArray(in, start_idx + i, expected, j, dst_species_len, srcSpecies, destSpecies, convertValue);\n@@ -472,2 +524,8 @@\n-        Object expected = Array.newInstance(dstSpecies.elementType(), out_len);\n-        Object actual = Array.newInstance(dstSpecies.elementType(), out_len);\n+        Object expected = null, actual = null;\n+        if (dstSpecies.elementType() == Float16.class) {\n+            expected = Array.newInstance(short.class, out_len);\n+            actual = Array.newInstance(short.class, out_len);\n+        } else {\n+            expected = Array.newInstance(dstSpecies.elementType(), out_len);\n+            actual = Array.newInstance(dstSpecies.elementType(), out_len);\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorConversionTest.java","additions":75,"deletions":17,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n-import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n@@ -39,2 +40,1 @@\n-    static final VectorSpecies<Float> SPECIES =\n-            FloatVector.SPECIES_256;\n+    static final VectorSpecies<Float16> SPECIES = HalffloatVector.SPECIES_256;\n@@ -43,3 +43,3 @@\n-    static float[] a = new float[SIZE];\n-    static float[] b = new float[SIZE];\n-    static float[] c = new float[SIZE];\n+    static short[] a = new short[SIZE];\n+    static short[] b = new short[SIZE];\n+    static short[] c = new short[SIZE];\n@@ -49,2 +49,3 @@\n-            a[i] = 1f;\n-            b[i] = 2f;\n+            a[i] = Float16.float16ToRawShortBits(Float16.valueOf((float)i));\n+            b[i] = Float16.float16ToRawShortBits(Float16.valueOf((float)i));\n+            c[i] = Float16.float16ToRawShortBits(Float16.valueOf((float)i));\n@@ -56,2 +57,2 @@\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n@@ -62,11 +63,1 @@\n-    static final int[] IDENTITY_INDEX_MAPPING = IntStream.range(0, SPECIES.length()).toArray();\n-\n-    static void workloadIndexMapped() {\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i, IDENTITY_INDEX_MAPPING, 0);\n-            FloatVector bv = FloatVector.fromArray(SPECIES, b, i, IDENTITY_INDEX_MAPPING, 0);\n-            av.add(bv).intoArray(c, i, IDENTITY_INDEX_MAPPING, 0);\n-        }\n-    }\n-\n-        for (int i = 0; i < 30_0000; i++) {\n+        for (int i = 0; i < 10_0000; i++) {\n@@ -77,5 +68,3 @@\n-            if (c[i] != a[i] + b[i])\n-                throw new AssertionError();\n-        }\n-\n-        Arrays.fill(c, 0.0f);\n+            Float16 hfa = Float16.shortBitsToFloat16(a[i]);\n+            Float16 hfb = Float16.shortBitsToFloat16(b[i]);\n+            Float16 hfc = Float16.shortBitsToFloat16(c[i]);\n@@ -83,5 +72,2 @@\n-        for (int i = 0; i < 30_0000; i++) {\n-            workloadIndexMapped();\n-        }\n-        for (int i = 0; i < a.length; i++) {\n-            if (c[i] != a[i] + b[i])\n+            if (hfc.floatValue() != (hfa.floatValue() + hfb.floatValue())) {\n+                System.out.println(\"RES: \" + hfc.floatValue() + \" EXPECTED: \" + (hfa.floatValue() + hfb.floatValue()));\n@@ -89,0 +75,1 @@\n+            }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AddTest.java","additions":19,"deletions":32,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,0 +969,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -1022,1 +1026,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1026,1 +1030,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1030,1 +1034,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,0 +969,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -1022,1 +1026,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1026,1 +1030,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1030,1 +1034,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,0 +969,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -1022,1 +1026,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1026,1 +1030,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1030,1 +1034,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,0 +969,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -1022,1 +1026,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1026,1 +1030,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1030,1 +1034,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -974,0 +974,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -1027,1 +1031,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1031,1 +1035,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1035,1 +1039,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1061,0 +1061,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -1079,1 +1083,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1083,1 +1087,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1087,1 +1091,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1121,0 +1125,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1124,1 +1132,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1128,1 +1136,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1132,1 +1140,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1159,1 +1167,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1163,1 +1171,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1167,1 +1175,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1061,0 +1061,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -1079,1 +1083,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1083,1 +1087,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1087,1 +1091,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1121,0 +1125,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1124,1 +1132,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1128,1 +1136,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1132,1 +1140,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1159,1 +1167,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1163,1 +1171,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1167,1 +1175,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1061,0 +1061,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -1079,1 +1083,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1083,1 +1087,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1087,1 +1091,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1121,0 +1125,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1124,1 +1132,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1128,1 +1136,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1132,1 +1140,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1159,1 +1167,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1163,1 +1171,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1167,1 +1175,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1061,0 +1061,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -1079,1 +1083,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1083,1 +1087,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1087,1 +1091,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1121,0 +1125,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1124,1 +1132,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1128,1 +1136,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1132,1 +1140,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1159,1 +1167,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1163,1 +1171,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1167,1 +1175,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1066,0 +1066,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -1084,1 +1088,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1088,1 +1092,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1092,1 +1096,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1126,0 +1130,4 @@\n+    static double genValue(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1129,1 +1137,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1133,1 +1141,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1137,1 +1145,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1164,1 +1172,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1168,1 +1176,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1172,1 +1180,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1061,0 +1061,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -1079,1 +1083,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1083,1 +1087,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1087,1 +1091,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1121,0 +1125,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1124,1 +1132,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1128,1 +1136,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1132,1 +1140,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1170,1 +1178,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1174,1 +1182,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1178,1 +1186,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1061,0 +1061,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -1079,1 +1083,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1083,1 +1087,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1087,1 +1091,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1121,0 +1125,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1124,1 +1132,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1128,1 +1136,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1132,1 +1140,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1170,1 +1178,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1174,1 +1182,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1178,1 +1186,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1061,0 +1061,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -1079,1 +1083,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1083,1 +1087,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1087,1 +1091,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1121,0 +1125,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1124,1 +1132,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1128,1 +1136,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1132,1 +1140,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1170,1 +1178,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1174,1 +1182,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1178,1 +1186,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1061,0 +1061,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -1079,1 +1083,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1083,1 +1087,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1087,1 +1091,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1121,0 +1125,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1124,1 +1132,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1128,1 +1136,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1132,1 +1140,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1170,1 +1178,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1174,1 +1182,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1178,1 +1186,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1066,0 +1066,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -1084,1 +1088,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1088,1 +1092,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1092,1 +1096,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1126,0 +1130,4 @@\n+    static float genValue(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1129,1 +1137,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1133,1 +1141,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1137,1 +1145,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1175,1 +1183,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1179,1 +1187,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1183,1 +1191,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,1014 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat128VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat128VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 128);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {\n+        return SPECIES.shuffleFromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {\n+        s.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n+        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {\n+        s.intoMemorySegment(mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+   @Test(dataProvider = \"shuffleIntProvider\")\n+   static void loadStoreShuffleArray(IntFunction<int[]> fa) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       for (int i = 0; i < a.length; i++) {\n+          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);\n+       }\n+\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffleIntoArray(shuffle, r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);\n+           shuffleIntoArray(shuffle, r, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           shuffleFromArray(a, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntMemorySegmentProvider\")\n+   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,\n+                                      IntFunction<MemorySegment> fb,\n+                                      ByteOrder bo) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);\n+       MemorySegment r = fb.apply((int) a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4; \/\/An integer for every lane is read out. So 4 bytes per lane\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n+               shuffle.intoMemorySegment(r, i, bo);\n+           }\n+       }\n+\n+       for (int i = 0; i < l \/ 4; i++) {\n+           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n+               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle =\n+                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           VectorShuffle<Float16> shuffle =\n+                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat128VectorLoadStoreTests.java","additions":1014,"deletions":0,"binary":false,"changes":1014,"status":"added"},{"patch":"@@ -0,0 +1,3256 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Halffloat128VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat128VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+    \/\/ for floating point addition reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;\n+\n+    \/\/ for floating point multiplication reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 128);\n+\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            short ir = Float16.shortToRawShortBits(r[i]);\n+            short ia = Float16.shortToRawShortBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            short relativeErrorFactor) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            short relativeError) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        Float16 act = Float16.shortBitsToFloat16(actual);\n+        Float16 exp = Float16.shortBitsToFloat16(expected);\n+        if (Float16.isNaN(exp) && !Float16.isNaN(act)) {\n+            return false;\n+        } else if (!Float16.isNaN(exp) && Float16.isNaN(act)) {\n+             return false;\n+        }\n+\n+        Float16 low = Float16.nextDown(exp);\n+        Float16 high = Float16.nextUp(exp);\n+\n+        if (Float16.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float16.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Float16.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"short[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)0.01 + ((short)i \/ (i + 1)));\n+            }),\n+            withToString(\"short[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (short)0.01 + ((short)i \/ (i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        return switch(i % 8) {\n+            case 0  -> Float16.MAX_VALUE;\n+            case 1  -> Float16.MIN_VALUE;\n+            case 2  -> Float16.NEGATIVE_INFINITY;\n+            case 3  -> Float16.POSITIVE_INFINITY;\n+            case 4  -> Float16.NaN;\n+            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);\n+            case 6  -> (short)0.0;\n+            default -> (short)-0.0;\n+        };\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(1))).broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Float16.float16ToRawShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::MUL);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::DIV);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat128VectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat128VectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat128VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat128VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat128VectorTests::FMA);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat128VectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sin(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sin(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::SIN, Halffloat128VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.exp(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.exp(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::EXP, Halffloat128VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log1p(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG1P, Halffloat128VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG, Halffloat128VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log10(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log10(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG10, Halffloat128VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.expm1(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::EXPM1, Halffloat128VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cos(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cos(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::COS, Halffloat128VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tan(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tan(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::TAN, Halffloat128VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sinh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::SINH, Halffloat128VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cosh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::COSH, Halffloat128VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tanh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::TANH, Halffloat128VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.asin(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.asin(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ASIN, Halffloat128VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.acos(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.acos(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ACOS, Halffloat128VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ATAN, Halffloat128VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::CBRT, Halffloat128VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::HYPOT, Halffloat128VectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::POW, Halffloat128VectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::pow, Halffloat128VectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::ATAN2, Halffloat128VectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::POW, Halffloat128VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::pow, Halffloat128VectorTests::strictpow);\n+    }\n+\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat128VectorTests::ADDReduceLong, Halffloat128VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat128VectorTests::ADDReduceLongMasked, Halffloat128VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat128VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat128VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat128VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_128_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Float16.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat128VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat128VectorTests.java","additions":3256,"deletions":0,"binary":false,"changes":3256,"status":"added"},{"patch":"@@ -0,0 +1,1014 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat256VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat256VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 256);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {\n+        return SPECIES.shuffleFromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {\n+        s.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n+        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {\n+        s.intoMemorySegment(mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+   @Test(dataProvider = \"shuffleIntProvider\")\n+   static void loadStoreShuffleArray(IntFunction<int[]> fa) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       for (int i = 0; i < a.length; i++) {\n+          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);\n+       }\n+\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffleIntoArray(shuffle, r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);\n+           shuffleIntoArray(shuffle, r, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           shuffleFromArray(a, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntMemorySegmentProvider\")\n+   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,\n+                                      IntFunction<MemorySegment> fb,\n+                                      ByteOrder bo) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);\n+       MemorySegment r = fb.apply((int) a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4; \/\/An integer for every lane is read out. So 4 bytes per lane\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n+               shuffle.intoMemorySegment(r, i, bo);\n+           }\n+       }\n+\n+       for (int i = 0; i < l \/ 4; i++) {\n+           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n+               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle =\n+                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           VectorShuffle<Float16> shuffle =\n+                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat256VectorLoadStoreTests.java","additions":1014,"deletions":0,"binary":false,"changes":1014,"status":"added"},{"patch":"@@ -0,0 +1,3256 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Halffloat256VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat256VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+    \/\/ for floating point addition reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;\n+\n+    \/\/ for floating point multiplication reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 256);\n+\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            short ir = Float16.shortToRawShortBits(r[i]);\n+            short ia = Float16.shortToRawShortBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            short relativeErrorFactor) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            short relativeError) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        Float16 act = Float16.shortBitsToFloat16(actual);\n+        Float16 exp = Float16.shortBitsToFloat16(expected);\n+        if (Float16.isNaN(exp) && !Float16.isNaN(act)) {\n+            return false;\n+        } else if (!Float16.isNaN(exp) && Float16.isNaN(act)) {\n+             return false;\n+        }\n+\n+        Float16 low = Float16.nextDown(exp);\n+        Float16 high = Float16.nextUp(exp);\n+\n+        if (Float16.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float16.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Float16.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"short[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)0.01 + ((short)i \/ (i + 1)));\n+            }),\n+            withToString(\"short[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (short)0.01 + ((short)i \/ (i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        return switch(i % 8) {\n+            case 0  -> Float16.MAX_VALUE;\n+            case 1  -> Float16.MIN_VALUE;\n+            case 2  -> Float16.NEGATIVE_INFINITY;\n+            case 3  -> Float16.POSITIVE_INFINITY;\n+            case 4  -> Float16.NaN;\n+            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);\n+            case 6  -> (short)0.0;\n+            default -> (short)-0.0;\n+        };\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(1))).broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Float16.float16ToRawShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::MUL);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::DIV);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat256VectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat256VectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat256VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat256VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat256VectorTests::FMA);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat256VectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sin(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sin(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::SIN, Halffloat256VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.exp(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.exp(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::EXP, Halffloat256VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log1p(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG1P, Halffloat256VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG, Halffloat256VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log10(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log10(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG10, Halffloat256VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.expm1(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::EXPM1, Halffloat256VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cos(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cos(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::COS, Halffloat256VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tan(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tan(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::TAN, Halffloat256VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sinh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::SINH, Halffloat256VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cosh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::COSH, Halffloat256VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tanh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::TANH, Halffloat256VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.asin(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.asin(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ASIN, Halffloat256VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.acos(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.acos(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ACOS, Halffloat256VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ATAN, Halffloat256VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::CBRT, Halffloat256VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::HYPOT, Halffloat256VectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::POW, Halffloat256VectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::pow, Halffloat256VectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::ATAN2, Halffloat256VectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::POW, Halffloat256VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::pow, Halffloat256VectorTests::strictpow);\n+    }\n+\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat256VectorTests::ADDReduceLong, Halffloat256VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat256VectorTests::ADDReduceLongMasked, Halffloat256VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat256VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat256VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat256VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_256_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Float16.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat256VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat256VectorTests.java","additions":3256,"deletions":0,"binary":false,"changes":3256,"status":"added"},{"patch":"@@ -0,0 +1,1014 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat512VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat512VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 512);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {\n+        return SPECIES.shuffleFromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {\n+        s.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n+        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {\n+        s.intoMemorySegment(mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+   @Test(dataProvider = \"shuffleIntProvider\")\n+   static void loadStoreShuffleArray(IntFunction<int[]> fa) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       for (int i = 0; i < a.length; i++) {\n+          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);\n+       }\n+\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffleIntoArray(shuffle, r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);\n+           shuffleIntoArray(shuffle, r, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           shuffleFromArray(a, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntMemorySegmentProvider\")\n+   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,\n+                                      IntFunction<MemorySegment> fb,\n+                                      ByteOrder bo) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);\n+       MemorySegment r = fb.apply((int) a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4; \/\/An integer for every lane is read out. So 4 bytes per lane\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n+               shuffle.intoMemorySegment(r, i, bo);\n+           }\n+       }\n+\n+       for (int i = 0; i < l \/ 4; i++) {\n+           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n+               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle =\n+                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           VectorShuffle<Float16> shuffle =\n+                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat512VectorLoadStoreTests.java","additions":1014,"deletions":0,"binary":false,"changes":1014,"status":"added"},{"patch":"@@ -0,0 +1,3256 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Halffloat512VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat512VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+    \/\/ for floating point addition reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;\n+\n+    \/\/ for floating point multiplication reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 512);\n+\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            short ir = Float16.shortToRawShortBits(r[i]);\n+            short ia = Float16.shortToRawShortBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            short relativeErrorFactor) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            short relativeError) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        Float16 act = Float16.shortBitsToFloat16(actual);\n+        Float16 exp = Float16.shortBitsToFloat16(expected);\n+        if (Float16.isNaN(exp) && !Float16.isNaN(act)) {\n+            return false;\n+        } else if (!Float16.isNaN(exp) && Float16.isNaN(act)) {\n+             return false;\n+        }\n+\n+        Float16 low = Float16.nextDown(exp);\n+        Float16 high = Float16.nextUp(exp);\n+\n+        if (Float16.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float16.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Float16.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"short[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)0.01 + ((short)i \/ (i + 1)));\n+            }),\n+            withToString(\"short[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (short)0.01 + ((short)i \/ (i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        return switch(i % 8) {\n+            case 0  -> Float16.MAX_VALUE;\n+            case 1  -> Float16.MIN_VALUE;\n+            case 2  -> Float16.NEGATIVE_INFINITY;\n+            case 3  -> Float16.POSITIVE_INFINITY;\n+            case 4  -> Float16.NaN;\n+            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);\n+            case 6  -> (short)0.0;\n+            default -> (short)-0.0;\n+        };\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(1))).broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Float16.float16ToRawShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::MUL);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::DIV);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat512VectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat512VectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat512VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat512VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat512VectorTests::FMA);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat512VectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sin(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sin(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::SIN, Halffloat512VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.exp(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.exp(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::EXP, Halffloat512VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log1p(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG1P, Halffloat512VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG, Halffloat512VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log10(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log10(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG10, Halffloat512VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.expm1(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::EXPM1, Halffloat512VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cos(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cos(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::COS, Halffloat512VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tan(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tan(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::TAN, Halffloat512VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sinh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::SINH, Halffloat512VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cosh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::COSH, Halffloat512VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tanh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::TANH, Halffloat512VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.asin(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.asin(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ASIN, Halffloat512VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.acos(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.acos(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ACOS, Halffloat512VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ATAN, Halffloat512VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::CBRT, Halffloat512VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::HYPOT, Halffloat512VectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::POW, Halffloat512VectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::pow, Halffloat512VectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::ATAN2, Halffloat512VectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::POW, Halffloat512VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::pow, Halffloat512VectorTests::strictpow);\n+    }\n+\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat512VectorTests::ADDReduceLong, Halffloat512VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat512VectorTests::ADDReduceLongMasked, Halffloat512VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat512VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat512VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat512VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_512_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Float16.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat512VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat512VectorTests.java","additions":3256,"deletions":0,"binary":false,"changes":3256,"status":"added"},{"patch":"@@ -0,0 +1,1014 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat64VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat64VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 64);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {\n+        return SPECIES.shuffleFromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {\n+        s.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n+        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {\n+        s.intoMemorySegment(mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+   @Test(dataProvider = \"shuffleIntProvider\")\n+   static void loadStoreShuffleArray(IntFunction<int[]> fa) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       for (int i = 0; i < a.length; i++) {\n+          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);\n+       }\n+\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffleIntoArray(shuffle, r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);\n+           shuffleIntoArray(shuffle, r, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           shuffleFromArray(a, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntMemorySegmentProvider\")\n+   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,\n+                                      IntFunction<MemorySegment> fb,\n+                                      ByteOrder bo) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);\n+       MemorySegment r = fb.apply((int) a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4; \/\/An integer for every lane is read out. So 4 bytes per lane\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n+               shuffle.intoMemorySegment(r, i, bo);\n+           }\n+       }\n+\n+       for (int i = 0; i < l \/ 4; i++) {\n+           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n+               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle =\n+                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           VectorShuffle<Float16> shuffle =\n+                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat64VectorLoadStoreTests.java","additions":1014,"deletions":0,"binary":false,"changes":1014,"status":"added"},{"patch":"@@ -0,0 +1,3256 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Halffloat64VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat64VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+    \/\/ for floating point addition reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;\n+\n+    \/\/ for floating point multiplication reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 64);\n+\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            short ir = Float16.shortToRawShortBits(r[i]);\n+            short ia = Float16.shortToRawShortBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            short relativeErrorFactor) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            short relativeError) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        Float16 act = Float16.shortBitsToFloat16(actual);\n+        Float16 exp = Float16.shortBitsToFloat16(expected);\n+        if (Float16.isNaN(exp) && !Float16.isNaN(act)) {\n+            return false;\n+        } else if (!Float16.isNaN(exp) && Float16.isNaN(act)) {\n+             return false;\n+        }\n+\n+        Float16 low = Float16.nextDown(exp);\n+        Float16 high = Float16.nextUp(exp);\n+\n+        if (Float16.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float16.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Float16.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"short[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)0.01 + ((short)i \/ (i + 1)));\n+            }),\n+            withToString(\"short[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (short)0.01 + ((short)i \/ (i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        return switch(i % 8) {\n+            case 0  -> Float16.MAX_VALUE;\n+            case 1  -> Float16.MIN_VALUE;\n+            case 2  -> Float16.NEGATIVE_INFINITY;\n+            case 3  -> Float16.POSITIVE_INFINITY;\n+            case 4  -> Float16.NaN;\n+            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);\n+            case 6  -> (short)0.0;\n+            default -> (short)-0.0;\n+        };\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(1))).broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Float16.float16ToRawShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::MUL);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::DIV);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat64VectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat64VectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat64VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat64VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat64VectorTests::FMA);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat64VectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sin(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sin(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::SIN, Halffloat64VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.exp(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.exp(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::EXP, Halffloat64VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log1p(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG1P, Halffloat64VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG, Halffloat64VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log10(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log10(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG10, Halffloat64VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.expm1(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::EXPM1, Halffloat64VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cos(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cos(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::COS, Halffloat64VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tan(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tan(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::TAN, Halffloat64VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sinh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::SINH, Halffloat64VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cosh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::COSH, Halffloat64VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tanh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::TANH, Halffloat64VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.asin(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.asin(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ASIN, Halffloat64VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.acos(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.acos(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ACOS, Halffloat64VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ATAN, Halffloat64VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::CBRT, Halffloat64VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::HYPOT, Halffloat64VectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::POW, Halffloat64VectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::pow, Halffloat64VectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::ATAN2, Halffloat64VectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::POW, Halffloat64VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::pow, Halffloat64VectorTests::strictpow);\n+    }\n+\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat64VectorTests::ADDReduceLong, Halffloat64VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat64VectorTests::ADDReduceLongMasked, Halffloat64VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat64VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat64VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat64VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_64_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Float16.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat64VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat64VectorTests.java","additions":3256,"deletions":0,"binary":false,"changes":3256,"status":"added"},{"patch":"@@ -0,0 +1,1021 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm --add-opens jdk.incubator.vector\/jdk.incubator.vector=ALL-UNNAMED\n+ *      -XX:-TieredCompilation HalffloatMaxVectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class HalffloatMaxVectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+\n+    static VectorShape getMaxBit() {\n+        return VectorShape.S_Max_BIT;\n+    }\n+\n+    private static final int Max = 256;  \/\/ juts so we can do N\/Max\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ Max);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = HALFFLOAT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ELEMENT_LAYOUT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ELEMENT_LAYOUT);\n+    }\n+\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromArray(int[] a, int i) {\n+        return SPECIES.shuffleFromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoArray(VectorShuffle<Float16> s, int[] a, int i) {\n+        s.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static VectorShuffle<Float16> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n+        return VectorShuffle.fromMemorySegment(SPECIES, mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static void shuffleIntoMemorySegment(VectorShuffle<Float16> s, MemorySegment mem, int i, ByteOrder bo) {\n+        s.intoMemorySegment(mem, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromArray(a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Float16> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Float16> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        \/\/ Tests the species method and the equivalent vector method it defers to\n+        return (HalffloatVector) SPECIES.fromMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float16> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float16.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float16.SIZE);\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Float16> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Float16> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+   @Test(dataProvider = \"shuffleIntProvider\")\n+   static void loadStoreShuffleArray(IntFunction<int[]> fa) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       for (int i = 0; i < a.length; i++) {\n+          Assert.assertEquals(testPartiallyWrapIndex(SPECIES, a[i]), r[i]);\n+       }\n+\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void storeShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffleIntoArray(shuffle, r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           VectorShuffle<Float16> shuffle = shuffleFromArray(a, index);\n+           shuffleIntoArray(shuffle, r, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntProviderForIOOBE\")\n+   static void loadShuffleArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       int[] a = fa.apply(SPECIES.length());\n+       int[] r = new int[a.length];\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < a.length; i += SPECIES.length()) {\n+               VectorShuffle<Float16> shuffle = shuffleFromArray(a, i);\n+               shuffle.intoArray(r, i);\n+           }\n+       }\n+\n+       int index = fi.apply(a.length);\n+       boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+       try {\n+           shuffleFromArray(a, index);\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntMemorySegmentProvider\")\n+   static void loadStoreShuffleMemorySegment(IntFunction<int[]> fa,\n+                                      IntFunction<MemorySegment> fb,\n+                                      ByteOrder bo) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), fb);\n+       MemorySegment r = fb.apply((int) a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4; \/\/An integer for every lane is read out. So 4 bytes per lane\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n+               shuffle.intoMemorySegment(r, i, bo);\n+           }\n+       }\n+\n+       for (int i = 0; i < l \/ 4; i++) {\n+           int ai = a.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           int ri = r.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED.withOrder(bo), i);\n+           Assert.assertEquals(testPartiallyWrapIndex(SPECIES, ai), ri);\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleLoadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n+               shuffle.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           shuffleFromMemorySegment(a, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+   @Test(dataProvider = \"shuffleIntByteProviderForIOOBE\")\n+   static void shuffleStoreMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+       MemorySegment a = toShuffleSegment(SPECIES, fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i));\n+       MemorySegment r = Arena.ofAuto().allocate(a.byteSize());\n+\n+       int l = (int) a.byteSize();\n+       int s = SPECIES.length() * 4;\n+\n+       for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+           for (int i = 0; i < l; i += s) {\n+               VectorShuffle<Float16> shuffle =\n+                       VectorShuffle.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+               shuffleIntoMemorySegment(shuffle, r, i, ByteOrder.nativeOrder());\n+           }\n+       }\n+\n+       int index = fi.apply((int) a.byteSize());\n+       boolean shouldFail = isIndexOutOfBounds(s, index, (int) a.byteSize());\n+       try {\n+           VectorShuffle<Float16> shuffle =\n+                   VectorShuffle.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+           shuffleIntoMemorySegment(shuffle, r, index, ByteOrder.nativeOrder());\n+           if (shouldFail) {\n+               Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+           }\n+       } catch (IndexOutOfBoundsException e) {\n+           if (!shouldFail) {\n+               Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+           }\n+       }\n+   }\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/HalffloatMaxVectorLoadStoreTests.java","additions":1021,"deletions":0,"binary":false,"changes":1021,"status":"added"},{"patch":"@@ -0,0 +1,3245 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation HalffloatMaxVectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class HalffloatMaxVectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Float16> SPECIES =\n+                HalffloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static VectorShape getMaxBit() {\n+        return VectorShape.S_Max_BIT;\n+    }\n+\n+    private static final int Max = 256;  \/\/ juts so we can do N\/Max\n+\n+    \/\/ for floating point addition reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_ADD = (short)10.0;\n+\n+    \/\/ for floating point multiplication reduction ops that may introduce rounding errors\n+    private static final short RELATIVE_ROUNDING_ERROR_FACTOR_MUL = (short)50.0;\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ Max);\n+\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            short ir = Float16.shortToRawShortBits(r[i]);\n+            short ia = Float16.shortToRawShortBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        assertReductionArraysEquals(r, rc, a, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa,\n+                                            short relativeErrorFactor) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor);\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), Math.ulp(rc) * relativeErrorFactor, \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), Math.ulp(r[i]) * relativeErrorFactor, \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        assertReductionArraysEqualsMasked(r, rc, a, mask, f, fa, (short)0.0);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa,\n+                                            short relativeError) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] *\n+relativeError));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), Math.abs(rc * relativeError), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), Math.abs(r[i] * relativeError), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        Float16 act = Float16.shortBitsToFloat16(actual);\n+        Float16 exp = Float16.shortBitsToFloat16(expected);\n+        if (Float16.isNaN(exp) && !Float16.isNaN(act)) {\n+            return false;\n+        } else if (!Float16.isNaN(exp) && Float16.isNaN(act)) {\n+             return false;\n+        }\n+\n+        Float16 low = Float16.nextDown(exp);\n+        Float16 high = Float16.nextUp(exp);\n+\n+        if (Float16.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float16.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Float16.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Float16.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static short genValue(int i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static short genValue(long i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"Float16[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Float16.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Float16[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(-i * 5));\n+            }),\n+            withToString(\"Float16[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> genValue(i * 5));\n+            }),\n+            withToString(\"Float16[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n+            }),\n+            withToString(\"short[0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)0.01 + ((short)i \/ (i + 1)));\n+            }),\n+            withToString(\"short[i -> i % 17 == 0 ? cornerCaseValue(i) : 0.01 + (i \/ (i + 1))]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i % 17 == 0 ? cornerCaseValue(i) : (short)0.01 + ((short)i \/ (i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return HALFFLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToHalffloatF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToHalffloatF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToHalffloatF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        return switch(i % 8) {\n+            case 0  -> Float16.MAX_VALUE;\n+            case 1  -> Float16.MIN_VALUE;\n+            case 2  -> Float16.NEGATIVE_INFINITY;\n+            case 3  -> Float16.POSITIVE_INFINITY;\n+            case 4  -> Float16.NaN;\n+            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);\n+            case 6  -> (short)0.0;\n+            default -> (short)-0.0;\n+        };\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(1))).broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Float16> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Float16.float16ToRawShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static short[]\n+    bothToArray(HalffloatVector a, HalffloatVector b) {\n+        short[] r = new short[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        HalffloatVector a = io.add((short)1); \/\/[1,2]\n+        HalffloatVector b = a.neg();  \/\/[-1,-2]\n+        short[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<Float16> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<Float16> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        HalffloatVector zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        HalffloatVector zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        short[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        short[] manual = new short[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<Float16> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<Float16> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        HalffloatVector uab0 = zab0.rearrange(unz0,zab1);\n+        HalffloatVector uab1 = zab0.rearrange(unz1,zab1);\n+        short[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        HalffloatVector io = (HalffloatVector) SPECIES.broadcast(0).addIndex(1);\n+        HalffloatVector io2 = (HalffloatVector) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::MUL);\n+    }\n+\n+    static short DIV(short a, short b) {\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::DIV);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, HalffloatMaxVectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    static short SQRT(short a) {\n+        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sin(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sin(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::SIN, HalffloatMaxVectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.exp(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.exp(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::EXP, HalffloatMaxVectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log1p(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG1P, HalffloatMaxVectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG, HalffloatMaxVectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.log10(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.log10(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10HalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG10, HalffloatMaxVectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.expm1(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1HalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::EXPM1, HalffloatMaxVectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cos(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cos(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::COS, HalffloatMaxVectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tan(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tan(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::TAN, HalffloatMaxVectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.sinh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::SINH, HalffloatMaxVectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cosh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::COSH, HalffloatMaxVectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.tanh(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::TANH, HalffloatMaxVectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.asin(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.asin(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ASIN, HalffloatMaxVectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.acos(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.acos(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ACOS, HalffloatMaxVectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.atan(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ATAN, HalffloatMaxVectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::CBRT, HalffloatMaxVectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::HYPOT, HalffloatMaxVectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::POW, HalffloatMaxVectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::pow, HalffloatMaxVectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2HalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::ATAN2, HalffloatMaxVectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::POW, HalffloatMaxVectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::pow, HalffloatMaxVectorTests::strictpow);\n+    }\n+\n+\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloatMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Float16> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                HalffloatMaxVectorTests::ADDReduceLong, HalffloatMaxVectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                HalffloatMaxVectorTests::ADDReduceLongMasked, HalffloatMaxVectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloatMaxVectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector idxv = HalffloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloatMaxVectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean band(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.and(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::band);\n+    }\n+\n+    static boolean bor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskOrHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.or(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::bor);\n+    }\n+\n+    static boolean bxor(boolean a, boolean b) {\n+        return a != b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskXorHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.xor(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::bxor);\n+    }\n+\n+    static boolean bandNot(boolean a, boolean b) {\n+        return a & !b;\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskAndNotHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.andNot(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::bandNot);\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloatMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloatMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloatMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloatMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_Max_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Float16.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Float16.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Float16.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloatMaxVectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/HalffloatMaxVectorTests.java","additions":3245,"deletions":0,"binary":false,"changes":3245,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,0 +969,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -1012,1 +1016,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1016,1 +1020,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1020,1 +1024,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,0 +969,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -1012,1 +1016,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1016,1 +1020,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1020,1 +1024,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,0 +969,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -1012,1 +1016,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1016,1 +1020,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1020,1 +1024,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,0 +969,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -1012,1 +1016,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1016,1 +1020,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1020,1 +1024,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -974,0 +974,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -1017,1 +1021,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1021,1 +1025,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1025,1 +1029,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -926,0 +926,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -944,1 +948,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -948,1 +952,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -952,1 +956,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1002,1 +1006,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1006,1 +1010,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1010,1 +1014,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -926,0 +926,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -944,1 +948,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -948,1 +952,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -952,1 +956,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1002,1 +1006,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1006,1 +1010,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1010,1 +1014,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -926,0 +926,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -944,1 +948,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -948,1 +952,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -952,1 +956,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1002,1 +1006,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1006,1 +1010,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1010,1 +1014,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -926,0 +926,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -944,1 +948,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -948,1 +952,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -952,1 +956,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1002,1 +1006,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1006,1 +1010,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1010,1 +1014,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -931,0 +931,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -949,1 +953,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -953,1 +957,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -957,1 +961,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1007,1 +1011,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1011,1 +1015,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1015,1 +1019,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,0 +969,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -1012,1 +1016,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1016,1 +1020,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1020,1 +1024,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1568,1 +1572,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1570,1 +1574,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,0 +969,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -1012,1 +1016,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1016,1 +1020,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1020,1 +1024,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1568,1 +1572,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1570,1 +1574,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,0 +969,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -1012,1 +1016,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1016,1 +1020,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1020,1 +1024,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1568,1 +1572,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1570,1 +1574,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -969,0 +969,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -1012,1 +1016,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1016,1 +1020,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1020,1 +1024,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1568,1 +1572,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1570,1 +1574,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -974,0 +974,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -1017,1 +1021,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1021,1 +1025,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1025,1 +1029,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1573,1 +1577,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1575,1 +1579,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-generate_perf_tests=$1\n+generate_perf_tests=$2\n@@ -72,0 +72,1 @@\n+unary_math_hf_template=\"Unary-op-hf-math\"\n@@ -73,0 +74,1 @@\n+binary_math_hf_template=\"Binary-op-hf-math\"\n@@ -74,0 +76,1 @@\n+binary_math_hf_broadcast_template=\"Binary-Broadcast-op-hf-math\"\n@@ -431,196 +434,229 @@\n-# ALU binary ops.\n-# Here \"ADD+add+withMask\" says VectorOperator name is \"ADD\", and we have a dedicate method too named 'add', and add() is also available with mask variant.\n-gen_binary_alu_op \"ADD+add+withMask\" \"a + b\"\n-gen_binary_alu_op \"SUB+sub+withMask\" \"a - b\"\n-gen_binary_alu_op \"MUL+mul+withMask\" \"a \\* b\"\n-gen_binary_alu_op \"DIV+div+withMask\" \"a \\\/ b\" \"FP\"\n-gen_op_tmpl \"Binary-op_bitwise-div\" \"DIV+div+withMask\" \"a \\\/ b\" \"BITWISE\"\n-gen_op_tmpl \"Binary-Masked-op_bitwise-div\" \"DIV+div+withMask\" \"a \\\/ b\" \"BITWISE\"\n-gen_binary_alu_op \"FIRST_NONZERO\" \"{#if[FP]?Double.doubleToLongBits}(a)!=0?a:b\"\n-gen_binary_alu_op \"AND+and\"   \"a \\& b\"  \"BITWISE\"\n-gen_binary_alu_op \"AND_NOT\" \"a \\& ~b\" \"BITWISE\"\n-gen_binary_alu_op \"OR+or\"    \"a | b\"   \"BITWISE\"\n-# Missing:        \"OR_UNCHECKED\"\n-gen_binary_alu_op \"XOR\"   \"a ^ b\"   \"BITWISE\"\n-gen_binary_alu_op \"COMPRESS_BITS\" \"\\$Boxtype\\$.compress(a, b)\" \"intOrLong\"\n-gen_binary_alu_op \"EXPAND_BITS\" \"\\$Boxtype\\$.expand(a, b)\" \"intOrLong\"\n-# Generate the broadcast versions\n-gen_binary_alu_bcst_op \"add+withMask\" \"a + b\"\n-gen_binary_alu_bcst_op \"sub+withMask\" \"a - b\"\n-gen_binary_alu_bcst_op \"mul+withMask\" \"a \\* b\"\n-gen_binary_alu_bcst_op \"div+withMask\" \"a \\\/ b\" \"FP\"\n-gen_op_tmpl \"Binary-Broadcast-op_bitwise-div\" \"div+withMask\" \"a \\\/ b\" \"BITWISE\"\n-gen_op_tmpl \"Binary-Broadcast-Masked-op_bitwise-div\" \"div+withMask\" \"a \\\/ b\" \"BITWISE\"\n-gen_binary_alu_bcst_op \"OR+or\"    \"a | b\"   \"BITWISE\"\n-gen_binary_alu_bcst_op \"AND+and\"    \"a \\& b\"   \"BITWISE\"\n-gen_binary_alu_bcst_long_op \"OR\"     \"a | b\"   \"BITWISE\"\n-gen_binary_alu_bcst_long_op \"ADD\"    \"a + b\"\n-\n-# Shifts\n-gen_binary_alu_op \"LSHL\" \"(a << b)\" \"intOrLong\"\n-gen_binary_alu_op \"LSHL\" \"(a << (b \\& 0x7))\" \"byte\"\n-gen_binary_alu_op \"LSHL\" \"(a << (b \\& 0xF))\" \"short\"\n-gen_binary_alu_op \"ASHR\" \"(a >> b)\" \"intOrLong\"\n-gen_binary_alu_op \"ASHR\" \"(a >> (b \\& 0x7))\" \"byte\"\n-gen_binary_alu_op \"ASHR\" \"(a >> (b \\& 0xF))\" \"short\"\n-gen_binary_alu_op \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n-gen_binary_alu_op \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 0x7))\" \"byte\"\n-gen_binary_alu_op \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 0xF))\" \"short\"\n-gen_shift_op  \"LSHL\" \"(a << b)\" \"intOrLong\"\n-gen_shift_op  \"LSHL\" \"(a << (b \\& 7))\" \"byte\"\n-gen_shift_op  \"LSHL\" \"(a << (b \\& 15))\" \"short\"\n-gen_shift_op  \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n-gen_shift_op  \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 7))\" \"byte\"\n-gen_shift_op  \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 15))\" \"short\"\n-gen_shift_op  \"ASHR\" \"(a >> b)\" \"intOrLong\"\n-gen_shift_op  \"ASHR\" \"(a >> (b \\& 7))\" \"byte\"\n-gen_shift_op  \"ASHR\" \"(a >> (b \\& 15))\" \"short\"\n-gen_binary_alu_op \"ROR\" \"ROR_scalar(a,b)\" \"BITWISE\"\n-gen_binary_alu_op \"ROL\" \"ROL_scalar(a,b)\" \"BITWISE\"\n-gen_shift_op  \"ROR\" \"ROR_scalar(a, b)\" \"BITWISE\"\n-gen_shift_op  \"ROL\" \"ROL_scalar(a, b)\" \"BITWISE\"\n-\n-# Constant Shifts\n-gen_shift_cst_op  \"LSHR\" \"(a >>> CONST_SHIFT)\" \"intOrLong\"\n-gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFF) >>> CONST_SHIFT)\" \"byte\"\n-gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFFFF) >>> CONST_SHIFT)\" \"short\"\n-gen_shift_cst_op  \"LSHL\" \"(a << CONST_SHIFT)\" \"BITWISE\"\n-gen_shift_cst_op  \"ASHR\" \"(a >> CONST_SHIFT)\" \"BITWISE\"\n-gen_shift_cst_op  \"ROR\" \"ROR_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n-gen_shift_cst_op  \"ROL\" \"ROL_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n-\n-# Binary operation with one memory operand\n-gen_binary_alu_mem_op \"MIN+min+withMask\", \"Math.min(a, b)\"\n-gen_binary_alu_mem_op \"MAX+max+withMask\", \"Math.max(a, b)\"\n-\n-# Masked reductions.\n-gen_binary_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n-gen_binary_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n-gen_binary_op \"UMIN\" \"VectorMath.minUnsigned(a, b)\" \"BITWISE\"\n-gen_binary_op \"UMAX\" \"VectorMath.maxUnsigned(a, b)\" \"BITWISE\"\n-gen_saturating_binary_op \"SADD\" \"VectorMath.addSaturating(a, b)\" \"BITWISE\"\n-gen_saturating_binary_op \"SSUB\" \"VectorMath.subSaturating(a, b)\" \"BITWISE\"\n-gen_saturating_binary_op \"SUADD\" \"VectorMath.addSaturatingUnsigned(a, b)\" \"BITWISE\"\n-gen_saturating_binary_op \"SUSUB\" \"VectorMath.subSaturatingUnsigned(a, b)\" \"BITWISE\"\n-gen_binary_bcst_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n-gen_binary_bcst_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n-gen_saturating_binary_op_associative \"SUADD\" \"VectorMath.addSaturatingUnsigned(a, b)\" \"BITWISE\"\n-\n-# Reductions.\n-gen_reduction_op \"AND\" \"\\&\" \"BITWISE\" \"-1\"\n-gen_reduction_op \"OR\" \"|\" \"BITWISE\" \"0\"\n-gen_reduction_op \"XOR\" \"^\" \"BITWISE\" \"0\"\n-gen_reduction_op \"ADD\" \"+\" \"\" \"0\"\n-gen_reduction_op \"MUL\" \"*\" \"\" \"1\"\n-gen_reduction_op_func \"MIN\" \"(\\$type\\$) Math.min\" \"\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n-gen_reduction_op_func \"MAX\" \"(\\$type\\$) Math.max\" \"\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n-gen_reduction_op_func \"UMIN\" \"(\\$type\\$) VectorMath.minUnsigned\" \"BITWISE\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n-gen_reduction_op_func \"UMAX\" \"(\\$type\\$) VectorMath.maxUnsigned\" \"BITWISE\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n-gen_reduction_op_func \"FIRST_NONZERO\" \"firstNonZero\" \"\" \"(\\$type\\$) 0\"\n-\n-# Boolean reductions.\n-gen_bool_reduction_op \"anyTrue\" \"|\" \"BITWISE\" \"false\"\n-gen_bool_reduction_op \"allTrue\" \"\\&\" \"BITWISE\" \"true\"\n-\n-# Saturating reductions.\n-gen_saturating_reduction_op \"SUADD\" \"(\\$type\\$) VectorMath.addSaturatingUnsigned\" \"BITWISE\" \"0\"\n-\n-#Insert\n-gen_with_op \"withLane\" \"\" \"\" \"\"\n-\n-# Tests\n-gen_op_tmpl $test_template \"IS_DEFAULT\" \"bits(a)==0\"\n-gen_op_tmpl $test_template \"IS_NEGATIVE\" \"bits(a)<0\"\n-gen_op_tmpl $test_template \"IS_FINITE\" \"\\$Boxtype\\$.isFinite(a)\" \"FP\"\n-gen_op_tmpl $test_template \"IS_NAN\" \"\\$Boxtype\\$.isNaN(a)\" \"FP\"\n-gen_op_tmpl $test_template \"IS_INFINITE\" \"\\$Boxtype\\$.isInfinite(a)\" \"FP\"\n-\n-# Compares\n-gen_compare_op \"LT+lt\" \"lt\"\n-gen_compare_op \"GT\" \"gt\"\n-gen_compare_op \"EQ+eq\" \"eq\"\n-gen_compare_op \"NE\" \"neq\"\n-gen_compare_op \"LE\" \"le\"\n-gen_compare_op \"GE\" \"ge\"\n-\n-gen_compare_op \"ULT\" \"ult\" \"BITWISE\"\n-gen_compare_op \"UGT\" \"ugt\" \"BITWISE\"\n-gen_compare_op \"ULE\" \"ule\" \"BITWISE\"\n-gen_compare_op \"UGE\" \"uge\" \"BITWISE\"\n-\n-\n-gen_compare_bcst_op \"LT\" \"<\"\n-gen_compare_bcst_op \"EQ\" \"==\"\n-\n-# Blend.\n-gen_op_tmpl $blend \"blend\" \"\"\n-\n-# Rearrange\n-gen_op_tmpl $rearrange_template \"rearrange\" \"\"\n-\n-# Compress\/Expand\n-gen_op_tmpl $compressexpand_template \"compress_expand\" \"\"\n-\n-# Get\n-gen_get_op \"lane\" \"\"\n-\n-# Broadcast\n-gen_op_tmpl $broadcast_template \"broadcast\" \"\"\n-\n-# Zero\n-gen_op_tmpl $zero_template \"zero\" \"\"\n-\n-# Slice\n-gen_op_tmpl $slice_template \"sliceUnary\" \"\"\n-gen_op_tmpl $slice1_template \"sliceBinary\" \"\"\n-gen_op_tmpl $slice1_masked_template \"slice\" \"\"\n-\n-# Unslice\n-gen_op_tmpl $unslice_template \"unsliceUnary\" \"\"\n-gen_op_tmpl $unslice1_template \"unsliceBinary\" \"\"\n-gen_op_tmpl $unslice1_masked_template \"unslice\" \"\"\n-\n-# Math\n-gen_op_tmpl $unary_math_template \"SIN\" \"Math.sin((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"EXP\" \"Math.exp((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"LOG1P\" \"Math.log1p((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"LOG\" \"Math.log((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"LOG10\" \"Math.log10((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"EXPM1\" \"Math.expm1((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"COS\" \"Math.cos((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"TAN\" \"Math.tan((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"SINH\" \"Math.sinh((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"COSH\" \"Math.cosh((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"TANH\" \"Math.tanh((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"ASIN\" \"Math.asin((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"ACOS\" \"Math.acos((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"ATAN\" \"Math.atan((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"CBRT\" \"Math.cbrt((double)a)\" \"FP\"\n-gen_op_tmpl $binary_math_template \"HYPOT\" \"Math.hypot((double)a, (double)b)\" \"FP\"\n-gen_op_tmpl $binary_math_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n-gen_op_tmpl $binary_math_template \"ATAN2\" \"Math.atan2((double)a, (double)b)\" \"FP\"\n-gen_op_tmpl $binary_math_broadcast_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n-\n-# Ternary operations.\n-gen_ternary_alu_op \"FMA+fma\" \"Math.fma(a, b, c)\" \"FP\"\n-gen_ternary_alu_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n-gen_ternary_alu_bcst_op \"FMA\" \"Math.fma(a, b, c)\" \"FP\"\n-gen_ternary_alu_bcst_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n-gen_ternary_alu_double_bcst_op \"FMA+fma\" \"Math.fma(a, b, c)\" \"FP\"\n-gen_ternary_alu_double_bcst_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n-\n-# Unary operations.\n-gen_unary_alu_op \"NEG+neg\" \"-((\\$type\\$)a)\"\n-gen_unary_alu_op \"ABS+abs\" \"Math.abs((\\$type\\$)a)\"\n-gen_unary_alu_op \"NOT+not\" \"~((\\$type\\$)a)\" \"BITWISE\"\n-gen_unary_alu_op \"ZOMO\" \"(a==0?0:-1)\" \"BITWISE\"\n-gen_unary_alu_op \"SQRT+sqrt\" \"Math.sqrt((double)a)\" \"FP\"\n-gen_unary_alu_op \"BIT_COUNT\" \"\\$Boxtype\\$.bitCount(a)\" \"intOrLong\"\n-gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFF)\" \"byte\"\n-gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFFFF)\" \"short\"\n-gen_unary_alu_op \"TRAILING_ZEROS_COUNT\" \"TRAILING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n-gen_unary_alu_op \"LEADING_ZEROS_COUNT\" \"LEADING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n-gen_unary_alu_op \"REVERSE\" \"REVERSE_scalar(a)\" \"BITWISE\"\n-gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"intOrLong\"\n-gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"short\"\n-gen_unary_alu_op \"REVERSE_BYTES\" \"a\" \"byte\"\n+if [ \"$1\" == \"ALL_PRIM_TYPES\" ]; then\n+  # ALU binary ops.\n+  # Here \"ADD+add+withMask\" says VectorOperator name is \"ADD\", and we have a dedicate method too named 'add', and add() is also available with mask variant.\n+  gen_binary_alu_op \"ADD+add+withMask\" \"a + b\"\n+  gen_binary_alu_op \"SUB+sub+withMask\" \"a - b\"\n+  gen_binary_alu_op \"MUL+mul+withMask\" \"a \\* b\"\n+  gen_binary_alu_op \"DIV+div+withMask\" \"a \\\/ b\" \"FP\"\n+  gen_op_tmpl \"Binary-op_bitwise-div\" \"DIV+div+withMask\" \"a \\\/ b\" \"BITWISE\"\n+  gen_op_tmpl \"Binary-Masked-op_bitwise-div\" \"DIV+div+withMask\" \"a \\\/ b\" \"BITWISE\"\n+  gen_binary_alu_op \"FIRST_NONZERO\" \"{#if[FP]?Double.doubleToLongBits}(a)!=0?a:b\"\n+  gen_binary_alu_op \"AND+and\"   \"a \\& b\"  \"BITWISE\"\n+  gen_binary_alu_op \"AND_NOT\" \"a \\& ~b\" \"BITWISE\"\n+  gen_binary_alu_op \"OR+or\"    \"a | b\"   \"BITWISE\"\n+  # Missing:        \"OR_UNCHECKED\"\n+  gen_binary_alu_op \"XOR\"   \"a ^ b\"   \"BITWISE\"\n+  gen_binary_alu_op \"COMPRESS_BITS\" \"\\$Boxtype\\$.compress(a, b)\" \"intOrLong\"\n+  gen_binary_alu_op \"EXPAND_BITS\" \"\\$Boxtype\\$.expand(a, b)\" \"intOrLong\"\n+  # Generate the broadcast versions\n+  gen_binary_alu_bcst_op \"add+withMask\" \"a + b\"\n+  gen_binary_alu_bcst_op \"sub+withMask\" \"a - b\"\n+  gen_binary_alu_bcst_op \"mul+withMask\" \"a \\* b\"\n+  gen_binary_alu_bcst_op \"div+withMask\" \"a \\\/ b\" \"FP\"\n+  gen_op_tmpl \"Binary-Broadcast-op_bitwise-div\" \"div+withMask\" \"a \\\/ b\" \"BITWISE\"\n+  gen_op_tmpl \"Binary-Broadcast-Masked-op_bitwise-div\" \"div+withMask\" \"a \\\/ b\" \"BITWISE\"\n+  gen_binary_alu_bcst_op \"OR+or\"    \"a | b\"   \"BITWISE\"\n+  gen_binary_alu_bcst_op \"AND+and\"    \"a \\& b\"   \"BITWISE\"\n+  gen_binary_alu_bcst_long_op \"OR\"     \"a | b\"   \"BITWISE\"\n+  gen_binary_alu_bcst_long_op \"ADD\"    \"a + b\"\n+\n+  # Shifts\n+  gen_binary_alu_op \"LSHL\" \"(a << b)\" \"intOrLong\"\n+  gen_binary_alu_op \"LSHL\" \"(a << (b \\& 0x7))\" \"byte\"\n+  gen_binary_alu_op \"LSHL\" \"(a << (b \\& 0xF))\" \"short\"\n+  gen_binary_alu_op \"ASHR\" \"(a >> b)\" \"intOrLong\"\n+  gen_binary_alu_op \"ASHR\" \"(a >> (b \\& 0x7))\" \"byte\"\n+  gen_binary_alu_op \"ASHR\" \"(a >> (b \\& 0xF))\" \"short\"\n+  gen_binary_alu_op \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n+  gen_binary_alu_op \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 0x7))\" \"byte\"\n+  gen_binary_alu_op \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 0xF))\" \"short\"\n+  gen_shift_op  \"LSHL\" \"(a << b)\" \"intOrLong\"\n+  gen_shift_op  \"LSHL\" \"(a << (b \\& 7))\" \"byte\"\n+  gen_shift_op  \"LSHL\" \"(a << (b \\& 15))\" \"short\"\n+  gen_shift_op  \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n+  gen_shift_op  \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 7))\" \"byte\"\n+  gen_shift_op  \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 15))\" \"short\"\n+  gen_shift_op  \"ASHR\" \"(a >> b)\" \"intOrLong\"\n+  gen_shift_op  \"ASHR\" \"(a >> (b \\& 7))\" \"byte\"\n+  gen_shift_op  \"ASHR\" \"(a >> (b \\& 15))\" \"short\"\n+  gen_binary_alu_op \"ROR\" \"ROR_scalar(a,b)\" \"BITWISE\"\n+  gen_binary_alu_op \"ROL\" \"ROL_scalar(a,b)\" \"BITWISE\"\n+  gen_shift_op  \"ROR\" \"ROR_scalar(a, b)\" \"BITWISE\"\n+  gen_shift_op  \"ROL\" \"ROL_scalar(a, b)\" \"BITWISE\"\n+\n+  # Constant Shifts\n+  gen_shift_cst_op  \"LSHR\" \"(a >>> CONST_SHIFT)\" \"intOrLong\"\n+  gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFF) >>> CONST_SHIFT)\" \"byte\"\n+  gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFFFF) >>> CONST_SHIFT)\" \"short\"\n+  gen_shift_cst_op  \"LSHL\" \"(a << CONST_SHIFT)\" \"BITWISE\"\n+  gen_shift_cst_op  \"ASHR\" \"(a >> CONST_SHIFT)\" \"BITWISE\"\n+  gen_shift_cst_op  \"ROR\" \"ROR_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n+  gen_shift_cst_op  \"ROL\" \"ROL_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n+\n+  # Binary operation with one memory operand\n+  gen_binary_alu_mem_op \"MIN+min+withMask\", \"Math.min(a, b)\"\n+  gen_binary_alu_mem_op \"MAX+max+withMask\", \"Math.max(a, b)\"\n+  \n+  # Masked reductions.\n+  gen_binary_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n+  gen_binary_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n+  gen_binary_op \"UMIN\" \"VectorMath.minUnsigned(a, b)\" \"BITWISE\"\n+  gen_binary_op \"UMAX\" \"VectorMath.maxUnsigned(a, b)\" \"BITWISE\"\n+  gen_saturating_binary_op \"SADD\" \"VectorMath.addSaturating(a, b)\" \"BITWISE\"\n+  gen_saturating_binary_op \"SSUB\" \"VectorMath.subSaturating(a, b)\" \"BITWISE\"\n+  gen_saturating_binary_op \"SUADD\" \"VectorMath.addSaturatingUnsigned(a, b)\" \"BITWISE\"\n+  gen_saturating_binary_op \"SUSUB\" \"VectorMath.subSaturatingUnsigned(a, b)\" \"BITWISE\"\n+  gen_binary_bcst_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n+  gen_binary_bcst_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n+  gen_saturating_binary_op_associative \"SUADD\" \"VectorMath.addSaturatingUnsigned(a, b)\" \"BITWISE\"\n+  \n+  # Reductions.\n+  gen_reduction_op \"AND\" \"\\&\" \"BITWISE\" \"-1\"\n+  gen_reduction_op \"OR\" \"|\" \"BITWISE\" \"0\"\n+  gen_reduction_op \"XOR\" \"^\" \"BITWISE\" \"0\"\n+  gen_reduction_op \"ADD\" \"+\" \"\" \"0\"\n+  gen_reduction_op \"MUL\" \"*\" \"\" \"1\"\n+  gen_reduction_op_func \"MIN\" \"(\\$type\\$) Math.min\" \"\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n+  gen_reduction_op_func \"MAX\" \"(\\$type\\$) Math.max\" \"\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n+  gen_reduction_op_func \"UMIN\" \"(\\$type\\$) VectorMath.minUnsigned\" \"BITWISE\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n+  gen_reduction_op_func \"UMAX\" \"(\\$type\\$) VectorMath.maxUnsigned\" \"BITWISE\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n+  gen_reduction_op_func \"FIRST_NONZERO\" \"firstNonZero\" \"\" \"(\\$type\\$) 0\"\n+\n+  # Boolean reductions.\n+  gen_bool_reduction_op \"anyTrue\" \"|\" \"BITWISE\" \"false\"\n+  gen_bool_reduction_op \"allTrue\" \"\\&\" \"BITWISE\" \"true\"\n+\n+  # Saturating reductions.\n+  gen_saturating_reduction_op \"SUADD\" \"(\\$type\\$) VectorMath.addSaturatingUnsigned\" \"BITWISE\" \"0\"\n+  \n+  #Insert\n+  gen_with_op \"withLane\" \"\" \"\" \"\"\n+\n+  # Tests\n+  gen_op_tmpl $test_template \"IS_DEFAULT\" \"bits(a)==0\"\n+  gen_op_tmpl $test_template \"IS_NEGATIVE\" \"bits(a)<0\"\n+  gen_op_tmpl $test_template \"IS_FINITE\" \"\\$Boxtype\\$.isFinite(a)\" \"FP\"\n+  gen_op_tmpl $test_template \"IS_NAN\" \"\\$Boxtype\\$.isNaN(a)\" \"FP\"\n+  gen_op_tmpl $test_template \"IS_INFINITE\" \"\\$Boxtype\\$.isInfinite(a)\" \"FP\"\n+\n+  # Compares\n+  gen_compare_op \"LT+lt\" \"lt\"\n+  gen_compare_op \"GT\" \"gt\"\n+  gen_compare_op \"EQ+eq\" \"eq\"\n+  gen_compare_op \"NE\" \"neq\"\n+  gen_compare_op \"LE\" \"le\"\n+  gen_compare_op \"GE\" \"ge\"\n+\n+  gen_compare_op \"ULT\" \"ult\" \"BITWISE\"\n+  gen_compare_op \"UGT\" \"ugt\" \"BITWISE\"\n+  gen_compare_op \"ULE\" \"ule\" \"BITWISE\"\n+  gen_compare_op \"UGE\" \"uge\" \"BITWISE\"\n+  \n+  gen_compare_bcst_op \"LT\" \"<\"\n+  gen_compare_bcst_op \"EQ\" \"==\"\n+\n+  # Blend.\n+  gen_op_tmpl $blend \"blend\" \"\"\n+\n+  # Rearrange\n+  gen_op_tmpl $rearrange_template \"rearrange\" \"\"\n+\n+  # Compress\/Expand\n+  gen_op_tmpl $compressexpand_template \"compress_expand\" \"\"\n+\n+  # Get\n+  gen_get_op \"lane\" \"\"\n+\n+  # Broadcast\n+  gen_op_tmpl $broadcast_template \"broadcast\" \"\"\n+\n+  # Zero\n+  gen_op_tmpl $zero_template \"zero\" \"\"\n+\n+  # Slice\n+  gen_op_tmpl $slice_template \"sliceUnary\" \"\"\n+  gen_op_tmpl $slice1_template \"sliceBinary\" \"\"\n+  gen_op_tmpl $slice1_masked_template \"slice\" \"\"\n+\n+  # Unslice\n+  gen_op_tmpl $unslice_template \"unsliceUnary\" \"\"\n+  gen_op_tmpl $unslice1_template \"unsliceBinary\" \"\"\n+  gen_op_tmpl $unslice1_masked_template \"unslice\" \"\"\n+\n+  # Math\n+  gen_op_tmpl $unary_math_template \"SIN\" \"Math.sin((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"EXP\" \"Math.exp((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"LOG1P\" \"Math.log1p((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"LOG\" \"Math.log((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"LOG10\" \"Math.log10((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"EXPM1\" \"Math.expm1((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"COS\" \"Math.cos((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"TAN\" \"Math.tan((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"SINH\" \"Math.sinh((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"COSH\" \"Math.cosh((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"TANH\" \"Math.tanh((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"ASIN\" \"Math.asin((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"ACOS\" \"Math.acos((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"ATAN\" \"Math.atan((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"CBRT\" \"Math.cbrt((double)a)\" \"FP\"\n+  gen_op_tmpl $binary_math_template \"HYPOT\" \"Math.hypot((double)a, (double)b)\" \"FP\"\n+  gen_op_tmpl $binary_math_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n+  gen_op_tmpl $binary_math_template \"ATAN2\" \"Math.atan2((double)a, (double)b)\" \"FP\"\n+  gen_op_tmpl $binary_math_broadcast_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n+\n+  # Ternary operations.\n+  gen_ternary_alu_op \"FMA+fma\" \"Math.fma(a, b, c)\" \"FP\"\n+  gen_ternary_alu_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n+  gen_ternary_alu_bcst_op \"FMA\" \"Math.fma(a, b, c)\" \"FP\"\n+  gen_ternary_alu_bcst_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n+  gen_ternary_alu_double_bcst_op \"FMA+fma\" \"Math.fma(a, b, c)\" \"FP\"\n+  gen_ternary_alu_double_bcst_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n+\n+  # Unary operations.\n+  gen_unary_alu_op \"NEG+neg\" \"-((\\$type\\$)a)\"\n+  gen_unary_alu_op \"ABS+abs\" \"Math.abs((\\$type\\$)a)\"\n+  gen_unary_alu_op \"NOT+not\" \"~((\\$type\\$)a)\" \"BITWISE\"\n+  gen_unary_alu_op \"ZOMO\" \"(a==0?0:-1)\" \"BITWISE\"\n+  gen_unary_alu_op \"SQRT+sqrt\" \"Math.sqrt((double)a)\" \"FP\"\n+  gen_unary_alu_op \"BIT_COUNT\" \"\\$Boxtype\\$.bitCount(a)\" \"intOrLong\"\n+  gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFF)\" \"byte\"\n+  gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFFFF)\" \"short\"\n+  gen_unary_alu_op \"TRAILING_ZEROS_COUNT\" \"TRAILING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n+  gen_unary_alu_op \"LEADING_ZEROS_COUNT\" \"LEADING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n+  gen_unary_alu_op \"REVERSE\" \"REVERSE_scalar(a)\" \"BITWISE\"\n+  gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"intOrLong\"\n+  gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"short\"\n+  gen_unary_alu_op \"REVERSE_BYTES\" \"a\" \"byte\"\n+\n+elif [ \"$1\" == \"HALF_FLOAT_TYPE\" ]; then\n+  gen_binary_alu_op \"ADD\" \"Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_binary_alu_op \"SUB\" \"Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_binary_alu_op \"MUL\" \"Float.floatToFloat16(Float.float16ToFloat(a) \\* Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_binary_alu_op \"DIV\" \"Float.floatToFloat16(Float.float16ToFloat(a) \\\/ Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_binary_alu_op \"MAX\" \"Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b)))\" \"Halffloat\"\n+  gen_binary_alu_op \"MIN\" \"Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b)))\" \"Halffloat\"\n+  gen_unary_alu_op \"ABS+abs\" \"Math.abs(a)\" \"Halffloat\"\n+  gen_unary_alu_op \"NEG+neg\" \"-a\" \"Halffloat\"\n+  gen_ternary_alu_op \"FMA+fma\" \"Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c)))\" \"Halffloat\"\n+  gen_unary_alu_op \"SQRT+sqrt\" \"Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a)))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"SIN\" \"Math.sin(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"EXP\" \"Math.exp(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"LOG1P\" \"Math.log1p(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"LOG\" \"Math.log(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"LOG10\" \"Math.log10(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"EXPM1\" \"Math.expm1(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"COS\" \"Math.cos(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"TAN\" \"Math.tan(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"SINH\" \"Math.sinh(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"COSH\" \"Math.cosh(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"TANH\" \"Math.tanh(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"ASIN\" \"Math.asin(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"ACOS\" \"Math.acos(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"ATAN\" \"Math.atan(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"CBRT\" \"Math.cbrt(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $binary_math_hf_template \"HYPOT\" \"Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_op_tmpl $binary_math_hf_template \"POW+pow\" \"Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_op_tmpl $binary_math_hf_template \"ATAN2\" \"Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_op_tmpl $binary_math_broadcast_template \"POW+pow\" \"Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_op_tmpl $blend \"blend\" \"Halffloat\"\n+fi\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":233,"deletions":197,"binary":false,"changes":430,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,5 +29,2 @@\n-case $* in\n-'')             CLASS_FILTER='*';;\n---generate*)    CLASS_FILTER=${2-'*'};;\n---help|*)       echo \"Usage: $0 [--generate [file]]\"; exit 1;;\n-esac\n+generate_test_cases() {\n+  Log false \"Generating Vector API tests, $(date)\\n\"\n@@ -35,1 +32,5 @@\n-. config.sh\n+  # Compile SPP\n+  Log true \"Compiling SPP... \"\n+  compilation=$(${JAVAC} -d . \"${JDK_SRC_HOME}\/make\/jdk\/src\/classes\/build\/tools\/spp\/Spp.java\")\n+  Log false \"$compilation\\n\"\n+  Log true \"done\\n\"\n@@ -37,5 +38,6 @@\n-# Detect whether to generate the performance tests\n-generate_perf_tests=false\n-if [ -d \"$PERF_DEST\" ]; then\n-  generate_perf_tests=true\n-fi\n+  array=()\n+  if [ $1 == \"ALL_PRIM_TYPES\" ]; then\n+    array=(\"byte\" \"short\" \"int\" \"long\" \"float\" \"double\")\n+  elif [ $1 == \"HALF_FLOAT_TYPE\" ]; then\n+    array=(\"halffloat\")\n+  fi\n@@ -43,92 +45,2 @@\n-# First, generate the template file.\n-bash .\/gen-template.sh $generate_perf_tests\n-\n-Log false \"Generating Vector API tests, $(date)\\n\"\n-\n-# Compile SPP\n-Log true \"Compiling SPP... \"\n-compilation=$(${JAVAC} -d . \"${JDK_SRC_HOME}\/make\/jdk\/src\/classes\/build\/tools\/spp\/Spp.java\")\n-Log false \"$compilation\\n\"\n-Log true \"done\\n\"\n-\n-# For each type\n-for type in byte short int long float double\n-do\n-  Type=\"$(tr '[:lower:]' '[:upper:]' <<< ${type:0:1})${type:1}\"\n-  TYPE=\"$(tr '[:lower:]' '[:upper:]' <<< ${type})\"\n-  args=\"-K$type -Dtype=$type -DType=$Type -DTYPE=$TYPE\"\n-\n-  Boxtype=$Type\n-  Wideboxtype=$Boxtype\n-  MaxValue=MAX_VALUE\n-  MinValue=MIN_VALUE\n-\n-  kind=BITWISE\n-\n-  bitstype=$type\n-  Bitstype=$Type\n-  Boxbitstype=$Boxtype\n-\n-  fptype=$type\n-  Fptype=$Type\n-  Boxfptype=$Boxtype\n-\n-  case $type in\n-    byte)\n-      Wideboxtype=Byte\n-      args=\"$args -KbyteOrShort\"\n-      ;;\n-    short)\n-      Wideboxtype=Short\n-      args=\"$args -KbyteOrShort\"\n-      ;;\n-    int)\n-      Boxtype=Integer\n-      Wideboxtype=Integer\n-      fptype=float\n-      Fptype=Float\n-      Boxfptype=Float\n-      args=\"$args -KintOrLong\"\n-      ;;\n-    long)\n-      Wideboxtype=Long\n-      fptype=double\n-      Fptype=Double\n-      Boxfptype=Double\n-      args=\"$args -KintOrLong\"\n-      ;;\n-    float)\n-      kind=FP\n-      bitstype=int\n-      Bitstype=Int\n-      Boxbitstype=Integer\n-      Wideboxtype=Float\n-      MaxValue=POSITIVE_INFINITY\n-      MinValue=NEGATIVE_INFINITY\n-      ;;\n-    double)\n-      kind=FP\n-      bitstype=long\n-      Bitstype=Long\n-      Boxbitstype=Long\n-      Wideboxtype=Double\n-      MaxValue=POSITIVE_INFINITY\n-      MinValue=NEGATIVE_INFINITY\n-      ;;\n-  esac\n-\n-  args=\"$args -K$kind -K$Type -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype -DMaxValue=$MaxValue -DMinValue=$MinValue\"\n-  args=\"$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype\"\n-  args=\"$args -Dfptype=$fptype -DFptype=$Fptype -DBoxfptype=$Boxfptype\"\n-\n-  abstractvectortype=${typeprefix}${Type}Vector\n-  abstractvectorteststype=${typeprefix}${Type}VectorTests\n-  abstractbitsvectortype=${typeprefix}${Bitstype}Vector\n-  abstractfpvectortype=${typeprefix}${Fptype}Vector\n-  args=\"$args -Dabstractvectortype=$abstractvectortype -Dabstractvectorteststype=$abstractvectorteststype -Dabstractbitsvectortype=$abstractbitsvectortype -Dabstractfpvectortype=$abstractfpvectortype\"\n-\n-  # Generate tests for operations\n-  # For each size\n-  Log true \"${Type}:\"\n-\n-  for bits in 64 128 256 512 Max\n+  # For each type\n+  for type in ${array[@]}\n@@ -136,29 +48,105 @@\n-    vectortype=${typeprefix}${Type}${bits}Vector\n-    vectorteststype=${typeprefix}${Type}${bits}VectorTests\n-    vectorbenchtype=${typeprefix}${Type}${bits}Vector\n-    masktype=${typeprefix}${Type}${bits}Mask\n-    bitsvectortype=${typeprefix}${Bitstype}${bits}Vector\n-    fpvectortype=${typeprefix}${Fptype}${bits}Vector\n-    shape=S${bits}Bit\n-    Shape=S_${bits}_BIT\n-    if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n-      args=\"$args -KByteMax\"\n-    fi\n-    bitargs=\"$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape\"\n-    if [ $bits == 'Max' ]; then\n-      bitargs=\"$bitargs -KMaxBit\"\n-    fi\n-\n-    # Generate jtreg tests\n-    case $vectorteststype in\n-    $CLASS_FILTER)\n-      Log true \" ${bits}_jtreg $vectorteststype.java\"\n-      Log false \"${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${TEMPLATE_FILE} -o$vectorteststype.java \"\n-      TEST_DEST_FILE=\"${vectorteststype}.java\"\n-      rm -f ${TEST_DEST_FILE}\n-      ${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs \\\n-        -i${TEMPLATE_FILE} \\\n-        -o${TEST_DEST_FILE}\n-      if [ VAR_OS_ENV==windows.cygwin ]; then\n-        tr -d  '\\r' < ${TEST_DEST_FILE} > temp\n-        mv temp ${TEST_DEST_FILE}\n+    Type=\"$(tr '[:lower:]' '[:upper:]' <<< ${type:0:1})${type:1}\"\n+    TYPE=\"$(tr '[:lower:]' '[:upper:]' <<< ${type})\"\n+    args=\"-K$type -Dtype=$type -DType=$Type -DTYPE=$TYPE\"\n+\n+    Boxtype=$Type\n+    Wideboxtype=$Boxtype\n+    MaxValue=MAX_VALUE\n+    MinValue=MIN_VALUE\n+    ElementType=$Type\n+    kind=BITWISE\n+    VecEleType=$Type\n+    bitstype=$type\n+    Bitstype=$Type\n+    Boxbitstype=$Boxtype\n+    fptype=$type\n+    Fptype=$Type\n+    Boxfptype=$Boxtype\n+    ClassType=$type\n+\n+    case $type in\n+      byte)\n+        Wideboxtype=Byte\n+        args=\"$args -KbyteOrShort\"\n+        ;;\n+      short)\n+        Wideboxtype=Short\n+        args=\"$args -KbyteOrShort\"\n+        ;;\n+      int)\n+        ElementType=Int\n+        VecEleType=Integer\n+        Boxtype=Integer\n+        Wideboxtype=Integer\n+        fptype=float\n+        Fptype=Float\n+        Boxfptype=Float\n+        args=\"$args -KintOrLong\"\n+        ;;\n+      long)\n+        Wideboxtype=Long\n+        fptype=double\n+        Fptype=Double\n+        Boxfptype=Double\n+        args=\"$args -KintOrLong\"\n+        ;;\n+      float)\n+        kind=FP\n+        bitstype=int\n+        Bitstype=Int\n+        Boxbitstype=Integer\n+        Wideboxtype=Float\n+        MaxValue=POSITIVE_INFINITY\n+        MinValue=NEGATIVE_INFINITY\n+        ;;\n+      double)\n+        kind=FP\n+        bitstype=long\n+        Bitstype=Long\n+        Boxbitstype=Long\n+        Wideboxtype=Double\n+        MaxValue=POSITIVE_INFINITY\n+        MinValue=NEGATIVE_INFINITY\n+        ;;\n+      halffloat)\n+        VecEleType=Short\n+        ClassType=Float16\n+        kind=FP\n+        bitstype=short\n+        Bitstype=Short\n+        Boxbitstype=Short\n+        Wideboxtype=Float16\n+        args=\"$args -Dtype=short -DType=Halffloat -DTYPE=HALFFLOAT -DElementType=Halffloat\"\n+        ;;\n+      esac\n+\n+    args=\"$args -K$kind -K$Type -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype -DMaxValue=$MaxValue -DMinValue=$MinValue\"\n+    args=\"$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype -DElementType=$Type -DVecEleType=$VecEleType -DClassType=$ClassType\"\n+    args=\"$args -Dfptype=$fptype -DFptype=$Fptype -DBoxfptype=$Boxfptype\"\n+\n+    abstractvectortype=${typeprefix}${Type}Vector\n+    abstractvectorteststype=${typeprefix}${Type}VectorTests\n+    abstractbitsvectortype=${typeprefix}${Bitstype}Vector\n+    abstractfpvectortype=${typeprefix}${Fptype}Vector\n+    args=\"$args -Dabstractvectortype=$abstractvectortype -Dabstractvectorteststype=$abstractvectorteststype -Dabstractbitsvectortype=$abstractbitsvectortype -Dabstractfpvectortype=$abstractfpvectortype\"\n+\n+    # Generate tests for operations\n+    # For each size\n+    Log true \"${Type}:\"\n+\n+    for bits in 64 128 256 512 Max\n+    do\n+      vectortype=${typeprefix}${Type}${bits}Vector\n+      vectorteststype=${typeprefix}${Type}${bits}VectorTests\n+      vectorbenchtype=${typeprefix}${Type}${bits}Vector\n+      masktype=${typeprefix}${Type}${bits}Mask\n+      bitsvectortype=${typeprefix}${Bitstype}${bits}Vector\n+      fpvectortype=${typeprefix}${Fptype}${bits}Vector\n+      shape=S${bits}Bit\n+      Shape=S_${bits}_BIT\n+      if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n+        args=\"$args -KByteMax\"\n+      fi\n+      bitargs=\"$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape\"\n+      if [ $bits == 'Max' ]; then\n+        bitargs=\"$bitargs -KMaxBit\"\n@@ -166,5 +154,2 @@\n-      ;;\n-    esac\n-    if [ $generate_perf_tests == true ]; then\n-      # Generate jmh performance tests\n-      case $vectorbenchtype in\n+      # Generate jtreg tests\n+      case $vectorteststype in\n@@ -173,4 +158,4 @@\n-        Log true \" ${bits}_jmh $vectorbenchtype.java\"\n-        Log false \"${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${PERF_TEMPLATE_FILE} -o${vectorteststype}Perf.java \"\n-        PERF_DEST_FILE=\"${PERF_DEST}\/${vectorbenchtype}.java\"\n-        rm -f ${PERF_DEST_FILE}\n+        Log true \" ${bits}_jtreg $vectorteststype.java\"\n+        Log false \"${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${TEMPLATE_FILE} -o$vectorteststype.java \"\n+        TEST_DEST_FILE=\"${vectorteststype}.java\"\n+        rm -f ${TEST_DEST_FILE}\n@@ -178,0 +163,18 @@\n+          -i${TEMPLATE_FILE} \\\n+          -o${TEST_DEST_FILE}\n+        if [ VAR_OS_ENV==windows.cygwin ]; then\n+          tr -d  '\\r' < ${TEST_DEST_FILE} > temp\n+          mv temp ${TEST_DEST_FILE}\n+        fi\n+        ;;\n+      esac\n+\n+        if [ $generate_perf_tests == true ]; then\n+          # Generate jmh performance tests\n+          case $vectorbenchtype in\n+          $CLASS_FILTER)\n+          Log true \" ${bits}_jmh $vectorbenchtype.java\"\n+          Log false \"${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${PERF_TEMPLATE_FILE} -o${vectorteststype}Perf.java \"\n+          PERF_DEST_FILE=\"${PERF_DEST}\/${vectorbenchtype}.java\"\n+          rm -f ${PERF_DEST_FILE}\n+          ${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs \\\n@@ -180,0 +183,19 @@\n+          if [ VAR_OS_ENV==windows.cygwin ]; then\n+            tr -d  '\\r' < ${PERF_DEST_FILE} > temp\n+            mv temp ${PERF_DEST_FILE}\n+          fi\n+            ;;\n+          esac\n+        fi\n+    done\n+\n+      if [ $generate_perf_tests == true ]; then\n+        # Generate jmh performance tests\n+        case ${Type}Scalar in\n+        $CLASS_FILTER)\n+        Log true \" scalar ${Type}Scalar.java\"\n+        PERF_DEST_FILE=\"${PERF_DEST}\/${Type}Scalar.java\"\n+        rm -f ${PERF_DEST_FILE}\n+        ${JAVA} -cp . ${SPP_CLASSNAME} -nel $args \\\n+        -i${PERF_SCALAR_TEMPLATE_FILE} \\\n+        -o${PERF_DEST_FILE}\n@@ -184,22 +206,22 @@\n-        ;;\n-      esac\n-    fi\n-  done\n-\n-  if [ $generate_perf_tests == true ]; then\n-    # Generate jmh performance tests\n-    case ${Type}Scalar in\n-    $CLASS_FILTER)\n-    Log true \" scalar ${Type}Scalar.java\"\n-    PERF_DEST_FILE=\"${PERF_DEST}\/${Type}Scalar.java\"\n-    rm -f ${PERF_DEST_FILE}\n-    ${JAVA} -cp . ${SPP_CLASSNAME} -nel $args \\\n-      -i${PERF_SCALAR_TEMPLATE_FILE} \\\n-      -o${PERF_DEST_FILE}\n-    if [ VAR_OS_ENV==windows.cygwin ]; then\n-      tr -d  '\\r' < ${PERF_DEST_FILE} > temp\n-      mv temp ${PERF_DEST_FILE}\n-    fi\n-      ;;\n-    esac\n-  fi\n+          ;;\n+        esac\n+      fi\n+    # Generate tests for loads and stores\n+    # For each size\n+    for bits in 64 128 256 512 Max\n+    do\n+      vectortype=${typeprefix}${Type}${bits}Vector\n+      vectorteststype=${typeprefix}${Type}${bits}VectorLoadStoreTests\n+      vectorbenchtype=${typeprefix}${Type}${bits}VectorLoadStore\n+      masktype=${typeprefix}${Type}${bits}Mask\n+      bitsvectortype=${typeprefix}${Bitstype}${bits}Vector\n+      fpvectortype=${typeprefix}${Fptype}${bits}Vector\n+      shape=S${bits}Bit\n+      Shape=S_${bits}_BIT\n+      if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n+        args=\"$args -KByteMax\"\n+      fi\n+      bitargs=\"$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape\"\n+      if [ $bits == 'Max' ]; then\n+        bitargs=\"$bitargs -KMaxBit\"\n+      fi\n@@ -207,23 +229,3 @@\n-  # Generate tests for loads and stores\n-  # For each size\n-  for bits in 64 128 256 512 Max\n-  do\n-    vectortype=${typeprefix}${Type}${bits}Vector\n-    vectorteststype=${typeprefix}${Type}${bits}VectorLoadStoreTests\n-    vectorbenchtype=${typeprefix}${Type}${bits}VectorLoadStore\n-    masktype=${typeprefix}${Type}${bits}Mask\n-    bitsvectortype=${typeprefix}${Bitstype}${bits}Vector\n-    fpvectortype=${typeprefix}${Fptype}${bits}Vector\n-    shape=S${bits}Bit\n-    Shape=S_${bits}_BIT\n-    if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n-      args=\"$args -KByteMax\"\n-    fi\n-    bitargs=\"$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape\"\n-    if [ $bits == 'Max' ]; then\n-      bitargs=\"$bitargs -KMaxBit\"\n-    fi\n-\n-    # Generate\n-    case $vectorteststype in\n-    $CLASS_FILTER)\n+      # Generate\n+      case $vectorteststype in\n+      $CLASS_FILTER)\n@@ -235,2 +237,2 @@\n-        -itemplates\/X-LoadStoreTest.java.template \\\n-        -o${TEST_DEST_FILE}\n+      -itemplates\/X-LoadStoreTest.java.template \\\n+      -o${TEST_DEST_FILE}\n@@ -241,2 +243,7 @@\n-      ;;\n-    esac\n+        ;;\n+      esac\n+\n+      # TODO: Generate jmh performance tests for LoadStore variants\n+    done\n+\n+    Log true \" done\\n\"\n@@ -244,1 +251,7 @@\n-    # TODO: Generate jmh performance tests for LoadStore variants\n+}\n+\n+case $* in\n+'')             CLASS_FILTER='*';;\n+--generate*)    CLASS_FILTER=${2-'*'};;\n+--help|*)       echo \"Usage: $0 [--generate [file]]\"; exit 1;;\n+esac\n@@ -247,1 +260,1 @@\n-  Log true \" done\\n\"\n+. config.sh\n@@ -249,1 +262,5 @@\n-done\n+# Detect whether to generate the performance tests\n+generate_perf_tests=true\n+if [ -d \"$PERF_DEST\" ]; then\n+  generate_perf_tests=true\n+fi\n@@ -251,0 +268,7 @@\n+# First, generate the template files.\n+gen_type=\"ALL_PRIM_TYPES\"\n+gen_half_type=\"HALF_FLOAT_TYPE\"\n+bash gen-template.sh \"ALL_PRIM_TYPES\" $generate_perf_tests\n+generate_test_cases \"ALL_PRIM_TYPES\"\n+bash gen-template.sh \"HALF_FLOAT_TYPE\" $generate_perf_tests\n+generate_test_cases \"HALF_FLOAT_TYPE\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":218,"deletions":194,"binary":false,"changes":412,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+#if[Halffloat]\n+import jdk.incubator.vector.Halffloat;\n+#end[Halffloat]\n@@ -51,1 +54,1 @@\n-    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+    $type$[] fill(IntFunction<$VecEleType$> f) {\n@@ -67,0 +70,8 @@\n+    static $type$ genValue(int i) {\n+#if[Halffloat]\n+        return Halffloat.valueOf(i);\n+#else[Halffloat]\n+        return ($type$) i;\n+#end[Halffloat]\n+    }\n+\n@@ -69,4 +80,4 @@\n-        as = fill(i -> ($type$)(2*i));\n-        bs = fill(i -> ($type$)(i+1));\n-        cs = fill(i -> ($type$)(i+5));\n-        rs = fill(i -> ($type$)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-header.template","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,3 @@\n+#if[Halffloat]\n+import jdk.incubator.vector.Float16;\n+#end[Halffloat]\n@@ -77,1 +80,1 @@\n-        return $Boxtype$.compare(a, ($type$) 0) != 0 ? a : b;\n+        return $Wideboxtype$.compare(a, ($type$) 0) != 0 ? a : b;\n@@ -87,1 +90,1 @@\n-    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+    $type$[] fill(IntFunction<$VecEleType$> f) {\n@@ -99,0 +102,8 @@\n+    static $type$ genValue(int i) {\n+#if[Halffloat]\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+#else[Halffloat]\n+        return ($type$) i;\n+#end[Halffloat]\n+    }\n+\n@@ -102,6 +113,4 @@\n-\n-        a = fill(i -> ($type$)(2*i));\n-        b = fill(i -> ($type$)(i+1));\n-        c = fill(i -> ($type$)(i+5));\n-        r = fill(i -> ($type$)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-header.template","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,14 @@\n+\n+    static $type$ [[TEST]]($type$ a, $type$ b) {\n+        return Float16.float16ToRawShortBits((Float16.valueOf((float) [[TEST_OP]])));\n+    }\n+\n+    static $type$ strict[[TEST]]($type$ a, $type$ b) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Strict[[TEST_OP]]));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+[[KERNEL]]\n+        assertArraysEqualsWithinOneUlp(r, a, b, $vectorteststype$::[[TEST]], $vectorteststype$::strict[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Binary-op-hf-math.template","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -13,0 +13,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+#else[Halffloat]\n@@ -14,0 +17,1 @@\n+#end[Halffloat]\n@@ -29,0 +33,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+#else[Halffloat]\n@@ -30,0 +37,1 @@\n+#end[Halffloat]\n@@ -126,0 +134,3 @@\n+#if[Halffloat]\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+#else[Halffloat]\n@@ -127,0 +138,1 @@\n+#end[Halffloat]\n@@ -165,0 +177,3 @@\n+#if[Halffloat]\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+#else[Halffloat]\n@@ -166,0 +181,1 @@\n+#end[Halffloat]\n@@ -702,1 +718,1 @@\n-        VectorSpecies species = vsh.withLanes($type$.class);\n+        VectorSpecies species = vsh.withLanes($ClassType$.class);\n@@ -709,1 +725,1 @@\n-        assert(av.species().elementType() == $type$.class);\n+        assert(av.species().elementType() == $ClassType$.class);\n@@ -727,1 +743,1 @@\n-        VectorSpecies species = av.species().withLanes($type$.class);\n+        VectorSpecies species = av.species().withLanes($ClassType$.class);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,14 @@\n+\n+    static $type$ [[TEST]]($type$ a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) [[TEST_OP]]));\n+    }\n+\n+    static $type$ strict[[TEST]]($type$ a) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf((float) Strict[[TEST_OP]]));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa) {\n+[[KERNEL]]\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::[[TEST]], $vectorteststype$::strict[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Unary-op-hf-math.template","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,4 @@\n+#if[Halffloat]\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n+#end[Halffloat]\n@@ -82,1 +86,1 @@\n-                $Type$Vector.SPECIES_MAX;\n+                $ElementType$Vector.SPECIES_MAX;\n@@ -85,1 +89,1 @@\n-                $Type$Vector.SPECIES_$bits$;\n+                $ElementType$Vector.SPECIES_$bits$;\n@@ -886,0 +890,20 @@\n+#if[Halffloat]\n+        Float16 act = Float16.shortBitsToFloat16(actual);\n+        Float16 exp = Float16.shortBitsToFloat16(expected);\n+        if (Float16.isNaN(exp) && !Float16.isNaN(act)) {\n+            return false;\n+        } else if (!Float16.isNaN(exp) && Float16.isNaN(act)) {\n+             return false;\n+        }\n+\n+        Float16 low = Float16.nextDown(exp);\n+        Float16 high = Float16.nextUp(exp);\n+\n+        if (Float16.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float16.compare(high, exp) < 0) {\n+            return false;\n+        }\n+#else[Halffloat]\n@@ -902,0 +926,1 @@\n+#end[Halffloat]\n@@ -911,1 +936,1 @@\n-                Assert.assertTrue($Type$.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                Assert.assertTrue($Wideboxtype$.compare(r[i], mathf.apply(a[i])) == 0 ||\n@@ -915,1 +940,1 @@\n-            Assert.assertTrue($Type$.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue($Wideboxtype$.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n@@ -925,1 +950,1 @@\n-                Assert.assertTrue($Type$.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                Assert.assertTrue($Wideboxtype$.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n@@ -929,1 +954,1 @@\n-            Assert.assertTrue($Type$.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue($Wideboxtype$.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -940,1 +965,1 @@\n-                Assert.assertTrue($Type$.compare(r[i],\n+                Assert.assertTrue($Wideboxtype$.compare(r[i],\n@@ -946,1 +971,1 @@\n-            Assert.assertTrue($Type$.compare(r[i],\n+            Assert.assertTrue($Wideboxtype$.compare(r[i],\n@@ -1142,0 +1167,8 @@\n+    static $type$ genValue(int i) {\n+#if[Halffloat]\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+#else[Halffloat]\n+        return ($type$) i;\n+#end[Halffloat]\n+    }\n+\n@@ -1160,1 +1193,1 @@\n-            withToString(\"$type$[-i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[-i * 5]\", (int s) -> {\n@@ -1162,1 +1195,1 @@\n-                            i -> ($type$)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1164,1 +1197,1 @@\n-            withToString(\"$type$[i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[i * 5]\", (int s) -> {\n@@ -1166,1 +1199,1 @@\n-                            i -> ($type$)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1168,1 +1201,1 @@\n-            withToString(\"$type$[i + 1]\", (int s) -> {\n+            withToString(\"$ClassType$[i + 1]\", (int s) -> {\n@@ -1170,1 +1203,1 @@\n-                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+                            i -> ((($type$)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1172,1 +1205,1 @@\n-            withToString(\"$type$[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"$ClassType$[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1184,0 +1217,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+#else[Halffloat]\n@@ -1185,0 +1221,1 @@\n+#end[Halffloat]\n@@ -1208,0 +1245,8 @@\n+    static $type$ genValue(long i) {\n+#if[Halffloat]\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+#else[Halffloat]\n+        return ($type$) i;\n+#end[Halffloat]\n+    }\n+\n@@ -1209,1 +1254,1 @@\n-            withToString(\"$type$[-i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[-i * 5]\", (int s) -> {\n@@ -1211,1 +1256,1 @@\n-                            i -> ($type$)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1213,1 +1258,1 @@\n-            withToString(\"$type$[i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[i * 5]\", (int s) -> {\n@@ -1215,1 +1260,1 @@\n-                            i -> ($type$)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1217,1 +1262,1 @@\n-            withToString(\"$type$[i + 1]\", (int s) -> {\n+            withToString(\"$ClassType$[i + 1]\", (int s) -> {\n@@ -1219,1 +1264,1 @@\n-                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+                            i -> ((($type$)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1221,1 +1266,1 @@\n-            withToString(\"$type$[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"$ClassType$[cornerCaseValue(i)]\", (int s) -> {\n@@ -1246,0 +1291,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+#else[Halffloat]\n@@ -1247,0 +1295,1 @@\n+#end[Halffloat]\n@@ -1258,0 +1307,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+#else[Halffloat]\n@@ -1259,0 +1311,1 @@\n+#end[Halffloat]\n@@ -1267,1 +1320,1 @@\n-        return {#if[FP]? $Type$.$type$To$Bitstype$Bits(e): e};\n+        return {#if[FP]? $Wideboxtype$.$type$To$Bitstype$Bits(e): e};\n@@ -1271,1 +1324,1 @@\n-            withToString(\"$type$[-i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[-i * 5]\", (int s) -> {\n@@ -1273,1 +1326,1 @@\n-                            i -> ($type$)(-i * 5));\n+                            i -> genValue(-i * 5));\n@@ -1275,1 +1328,1 @@\n-            withToString(\"$type$[i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[i * 5]\", (int s) -> {\n@@ -1277,1 +1330,1 @@\n-                            i -> ($type$)(i * 5));\n+                            i -> genValue(i * 5));\n@@ -1279,1 +1332,1 @@\n-            withToString(\"$type$[i + 1]\", (int s) -> {\n+            withToString(\"$ClassType$[i + 1]\", (int s) -> {\n@@ -1281,1 +1334,1 @@\n-                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+                            i -> ((($type$)(i + 1) == 0) ? genValue(1) : genValue(i + 1)));\n@@ -1812,0 +1865,38 @@\n+#if[Halffloat]\n+\n+    static boolean eq(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Float16 at = Float16.shortBitsToFloat16(a);\n+        Float16 bt = Float16.shortBitsToFloat16(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+#else[Halffloat]\n@@ -1836,0 +1927,1 @@\n+#end[Halffloat]\n@@ -1856,1 +1948,1 @@\n-        return $Boxtype$.compare(a, ($type$) 0) != 0 ? a : b;\n+        return $VecEleType$.compare(a, ($type$) 0) != 0 ? a : b;\n@@ -1861,0 +1953,17 @@\n+#if[Halffloat]\n+        $abstractvectortype$ three = $abstractvectortype$.broadcast(SPECIES, Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        $abstractvectortype$ three2 = ($abstractvectortype$) SPECIES.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three2).allTrue());\n+        $abstractvectortype$ three3 = three2.broadcast(Float16.float16ToRawShortBits(Float16.valueOf(1))).broadcast(Float16.float16ToRawShortBits(Float16.valueOf(-3)));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        $abstractvectortype$ higher = three.addIndex(scale);\n+        VectorMask<$Wideboxtype$> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Float16.float16ToRawShortBits(Float16.valueOf(-1)))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        $type$ max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+#else[Halffloat]\n@@ -1873,1 +1982,1 @@\n-        VectorMask<$Boxtype$> m = three.compare(VectorOperators.LE, higher);\n+        VectorMask<$Wideboxtype$> m = three.compare(VectorOperators.LE, higher);\n@@ -1883,0 +1992,1 @@\n+#end[Halffloat]\n@@ -1902,2 +2012,2 @@\n-        VectorShuffle<$Boxtype$> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n-        VectorShuffle<$Boxtype$> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        VectorShuffle<$Wideboxtype$> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<$Wideboxtype$> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n@@ -1914,2 +2024,2 @@\n-        VectorShuffle<$Boxtype$> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n-        VectorShuffle<$Boxtype$> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        VectorShuffle<$Wideboxtype$> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<$Wideboxtype$> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n@@ -1959,1 +2069,1 @@\n-#if[byteOrShort]\n+#if[byte]\n@@ -1965,1 +2075,1 @@\n-#else[byteOrShort]\n+#else[byte]\n@@ -1976,1 +2086,1 @@\n-#end[byteOrShort]\n+#end[byte]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":149,"deletions":39,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+#if[FP16]\n+import jdk.incubator.vector.Float16;\n+import jdk.incubator.vector.HalffloatVector;\n+#end[FP16]\n@@ -64,1 +68,1 @@\n-                $Type$Vector.SPECIES_MAX;\n+                $ElementType$Vector.SPECIES_MAX;\n@@ -67,1 +71,1 @@\n-                $Type$Vector.SPECIES_$bits$;\n+                $ElementType$Vector.SPECIES_$bits$;\n@@ -72,0 +76,3 @@\n+#if[Halffloat]\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+#else[Halffloat]\n@@ -73,0 +80,1 @@\n+#end[Halffloat]\n@@ -273,1 +281,1 @@\n-    static VectorShuffle<$Boxtype$> shuffleFromArray(int[] a, int i) {\n+    static VectorShuffle<$Wideboxtype$> shuffleFromArray(int[] a, int i) {\n@@ -278,1 +286,1 @@\n-    static void shuffleIntoArray(VectorShuffle<$Boxtype$> s, int[] a, int i) {\n+    static void shuffleIntoArray(VectorShuffle<$Wideboxtype$> s, int[] a, int i) {\n@@ -283,1 +291,1 @@\n-    static VectorShuffle<$Boxtype$> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n+    static VectorShuffle<$Wideboxtype$> shuffleFromMemorySegment(MemorySegment mem, int i, ByteOrder bo) {\n@@ -288,1 +296,1 @@\n-    static void shuffleIntoMemorySegment(VectorShuffle<$Boxtype$> s, MemorySegment mem, int i, ByteOrder bo) {\n+    static void shuffleIntoMemorySegment(VectorShuffle<$Wideboxtype$> s, MemorySegment mem, int i, ByteOrder bo) {\n@@ -299,1 +307,1 @@\n-    static $abstractvectortype$ fromArray($type$[] a, int i, VectorMask<$Boxtype$> m) {\n+    static $abstractvectortype$ fromArray($type$[] a, int i, VectorMask<$Wideboxtype$> m) {\n@@ -309,1 +317,1 @@\n-    static void intoArray($abstractvectortype$ v, $type$[] a, int i, VectorMask<$Boxtype$> m) {\n+    static void intoArray($abstractvectortype$ v, $type$[] a, int i, VectorMask<$Wideboxtype$> m) {\n@@ -320,1 +328,1 @@\n-    static $abstractvectortype$ fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n+    static $abstractvectortype$ fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<$Wideboxtype$> m) {\n@@ -330,1 +338,1 @@\n-    static void intoMemorySegment($abstractvectortype$ v, MemorySegment a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n+    static void intoMemorySegment($abstractvectortype$ v, MemorySegment a, int i, ByteOrder bo, VectorMask<$Wideboxtype$> m) {\n@@ -408,1 +416,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -435,1 +443,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -463,1 +471,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -496,1 +504,1 @@\n-                VectorMask<$Boxtype$> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, i);\n@@ -526,2 +534,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Boxtype$.SIZE));\n-        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Boxtype$.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Wideboxtype$.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Wideboxtype$.SIZE);\n@@ -555,2 +563,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Boxtype$.SIZE));\n-        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Boxtype$.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Wideboxtype$.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Wideboxtype$.SIZE);\n@@ -592,1 +600,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -619,2 +627,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Boxtype$.SIZE));\n-        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Boxtype$.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Wideboxtype$.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Wideboxtype$.SIZE);\n@@ -622,1 +630,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -650,2 +658,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Boxtype$.SIZE));\n-        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Boxtype$.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Wideboxtype$.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Wideboxtype$.SIZE);\n@@ -653,1 +661,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -701,1 +709,1 @@\n-        VectorMask<$Boxtype$> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+        VectorMask<$Wideboxtype$> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n@@ -717,1 +725,1 @@\n-                VectorMask<$Boxtype$> vmask = SPECIES.loadMask(a, i);\n+                VectorMask<$Wideboxtype$> vmask = SPECIES.loadMask(a, i);\n@@ -732,1 +740,1 @@\n-               VectorShuffle<$Boxtype$> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+               VectorShuffle<$Wideboxtype$> shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n@@ -750,1 +758,1 @@\n-               VectorShuffle<$Boxtype$> shuffle = shuffleFromArray(a, i);\n+               VectorShuffle<$Wideboxtype$> shuffle = shuffleFromArray(a, i);\n@@ -758,1 +766,1 @@\n-           VectorShuffle<$Boxtype$> shuffle = shuffleFromArray(a, index);\n+           VectorShuffle<$Wideboxtype$> shuffle = shuffleFromArray(a, index);\n@@ -777,1 +785,1 @@\n-               VectorShuffle<$Boxtype$> shuffle = shuffleFromArray(a, i);\n+               VectorShuffle<$Wideboxtype$> shuffle = shuffleFromArray(a, i);\n@@ -808,1 +816,1 @@\n-               VectorShuffle<$Boxtype$> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n+               VectorShuffle<$Wideboxtype$> shuffle = VectorShuffle.fromMemorySegment(SPECIES, a, i, bo);\n@@ -829,1 +837,1 @@\n-               VectorShuffle<$Boxtype$> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n+               VectorShuffle<$Wideboxtype$> shuffle = shuffleFromMemorySegment(a, i, ByteOrder.nativeOrder());\n@@ -858,1 +866,1 @@\n-               VectorShuffle<$Boxtype$> shuffle =\n+               VectorShuffle<$Wideboxtype$> shuffle =\n@@ -867,1 +875,1 @@\n-           VectorShuffle<$Boxtype$> shuffle =\n+           VectorShuffle<$Wideboxtype$> shuffle =\n@@ -960,1 +968,1 @@\n-    static $abstractvectortype$ fromCharArray(char[] a, int i, VectorMask<$Boxtype$> m) {\n+    static $abstractvectortype$ fromCharArray(char[] a, int i, VectorMask<$Wideboxtype$> m) {\n@@ -970,1 +978,1 @@\n-    static void intoCharArray($abstractvectortype$ v, char[] a, int i, VectorMask<$Boxtype$> m) {\n+    static void intoCharArray($abstractvectortype$ v, char[] a, int i, VectorMask<$Wideboxtype$> m) {\n@@ -1047,1 +1055,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -1074,1 +1082,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n@@ -1102,1 +1110,1 @@\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":48,"deletions":40,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n+import org.junit.jupiter.api.Assumptions;\n@@ -32,1 +34,0 @@\n-import org.opentest4j.TestSkippedException;\n@@ -57,0 +58,1 @@\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n@@ -217,0 +219,1 @@\n+        Helper helper;\n@@ -218,5 +221,2 @@\n-            Helper helper = Helper.newHelper();\n-            if (helper == null) {\n-                throw new TestSkippedException(\"Cannot create test helper (exploded image?)\");\n-            }\n-            return helper;\n+            boolean isLinkableRuntime = LinkableRuntimeImage.isLinkableRuntime();\n+            helper = Helper.newHelper(isLinkableRuntime);\n@@ -226,0 +226,2 @@\n+        Assumptions.assumeTrue(helper != null, \"Cannot create test helper, skipping test!\");\n+        return helper;\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ImageReaderTest.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -146,2 +146,0 @@\n-        Asserts.assertGT((long) re.getValue(\"elements\"), 0L, \"No elements\");\n-        Asserts.assertGT((long) re.getValue(\"size\"), 0L, \"Empty size\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestFlush.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -413,0 +413,1 @@\n+        launcher.addToolArg(\"--exact\");\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestPrintContextual.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        for (var i = 0; i < 10_000; i++) {\n+        for (var i = 0; i < 1000; i++) {\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/IncludeRandom.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -65,2 +67,1 @@\n-            System.out.println(\"No support of DH KeyPairGenerator, skipping\");\n-            return;\n+           throw new SkippedException(\"No support of DH KeyPairGenerator, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/SupportedDHKeys.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jtreg.SkippedException;\n@@ -47,2 +48,1 @@\n-            System.out.println(\"DH not supported, skipping\");\n-            return;\n+            throw new SkippedException(\"DH not supported, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/TestDH.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jtreg.SkippedException;\n@@ -79,2 +80,1 @@\n-            System.out.println(\"DH not supported, skipping\");\n-            return;\n+            throw new SkippedException(\"DH not supported, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/TestInterop.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import jtreg.SkippedException;\n+\n@@ -93,2 +95,1 @@\n-            System.out.println(\"DH not supported, skipping\");\n-            return;\n+            throw new SkippedException(\"DH not supported, skipping\");\n@@ -96,0 +97,1 @@\n+\n@@ -97,2 +99,0 @@\n-            DHPublicKeySpec publicSpec;\n-            DHPrivateKeySpec privateSpec;\n@@ -109,1 +109,1 @@\n-            if (Arrays.equals(s2, n2) == false) {\n+            if (!Arrays.equals(s2, n2)) {\n@@ -117,1 +117,1 @@\n-            if (Arrays.equals(s3, n3) == false) {\n+            if (!Arrays.equals(s3, n3)) {\n@@ -126,21 +126,0 @@\n-\n-\/*\n-        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DH\", provider);\n-        kpg.initialize(512);\n-\/\/        KeyPair kp1 = kpg.generateKeyPair();\n-\/\/      System.out.println(kp1.getPublic());\n-\/\/      System.out.println(kp1.getPrivate());\n-        while (true) {\n-            KeyAgreement ka = KeyAgreement.getInstance(\"DH\", provider);\n-            ka.init(pr1);\n-            KeyPair kp2 = kpg.generateKeyPair();\n-            ka.doPhase(kp2.getPublic(), true);\n-            byte[] sec = ka.generateSecret();\n-            if (sec.length == 64) {\n-                System.out.println(kp2.getPrivate());\n-                System.out.println(kp2.getPublic());\n-                System.out.println(toString(sec));\n-                break;\n-            }\n-        }\n-\/**\/\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/TestShort.java","additions":7,"deletions":28,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -62,2 +64,1 @@\n-            System.out.println(\"No supported of DH KeyPairGenerator, skipping\");\n-            return;\n+            throw new SkippedException(\"DH (DiffieHellman) is not supported in KeyPairGenerator, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/UnsupportedDHKeys.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8309841\n+ * @bug 8309841 8365559\n@@ -43,0 +43,2 @@\n+    private static final String WEAK_UNSIGNED\n+            = \"The jar will be treated as unsigned, because it is signed with a weak algorithm that is now disabled\";\n@@ -45,0 +47,5 @@\n+        t8309841();\n+        t8365559();\n+    }\n+\n+    static void t8309841() throws Exception {\n@@ -92,0 +99,8 @@\n+    }\n+\n+    static void t8365559() throws Exception {\n+        JarUtils.createJarFile(\n+                Path.of(\"c.jar\"),\n+                Path.of(\".\"),\n+                Files.writeString(Path.of(\"c\"), \"c\"));\n+        SecurityTools.keytool(\"-genkeypair -storepass changeit -keystore ks -alias w -dname CN=w -keyalg ec\");\n@@ -93,0 +108,12 @@\n+        \/\/ Sign the JAR using an already disabled signature algorithm SHA1withECDSA.\n+        \/\/ The file can still be signed but verification will treat it as unsigned.\n+        SecurityTools.jarsigner(\"-storepass changeit -keystore ks c.jar w -sigalg SHA1withECDSA\")\n+                        .shouldContain(\"the -sigalg option is considered a security risk and is disabled.\");\n+\n+        SecurityTools.jarsigner(\"-verify c.jar\")\n+                .shouldContain(WEAK_UNSIGNED)\n+                .shouldNotContain(NONEXISTENT_ENTRIES_FOUND);\n+        SecurityTools.jarsigner(\"-verify -verbose c.jar\")\n+                .shouldContain(WEAK_UNSIGNED)\n+                .shouldNotContain(NONEXISTENT_ENTRIES_FOUND)\n+                .shouldNotContain(\"Warning: nonexistent signed entries:\");\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/RemovedFiles.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/helpers-test\n+lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/junit\/tools\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,5 +45,4 @@\n-    public static void testClassFilePath(String... args) {\n-        var appDesc = args[0];\n-        var expectedClassFilePath = Path.of(args[1]);\n-        TKit.assertEquals(expectedClassFilePath.toString(), JavaAppDesc.parse(\n-                appDesc).classFilePath().toString(), null);\n+    public static void testClassFilePath(String appDesc, String expectedClassFile) {\n+        var expectedClassFilePath = Path.of(expectedClassFile);\n+        TKit.assertEquals(expectedClassFilePath.toString(),\n+                JavaAppDesc.parse(appDesc).classFilePath().toString(), null);\n@@ -58,0 +57,6 @@\n+            createTestCase(\"bye.jar:!\", appDesc -> {\n+                return appDesc\n+                        .setBundleFileName(\"bye.jar\")\n+                        .setClassName(\"Hello\")\n+                        .setWithMainClass(true);\n+            }),\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JavaAppDescTest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1177,4 +1177,9 @@\n-            TKit.assertStringListEquals(\n-                    addLauncherNames().stream().sorted().toList(),\n-                    aif.addLaunchers().keySet().stream().sorted().toList(),\n-                    \"Check additional launcher names\");\n+            \/\/ Don't compare the add launchers configured on the command line with the\n+            \/\/ add launchers listed in the `.jpackage.xml` file if the latter comes from\n+            \/\/ a predefined app image.\n+            if (!hasArgument(\"--app-image\")) {\n+                TKit.assertStringListEquals(\n+                        addLauncherNames().stream().sorted().toList(),\n+                        aif.addLaunchers().keySet().stream().sorted().toList(),\n+                        \"Check additional launcher names\");\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,2 @@\n+lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/junit\/tools\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/TEST.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.model.AppImageLayoutTest;\n+import jdk.jpackage.internal.model.ApplicationLayoutTest;\n+import org.junit.jupiter.api.Test;\n+\n+public class LinuxApplicationLayoutTest {\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    public static LinuxApplicationLayout createLayout() {\n+        return LinuxApplicationLayout.create(ApplicationLayoutTest.createLayout(),\n+                Path.of(\"libapplauncher.so\"));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/jdk.jpackage\/jdk\/jpackage\/internal\/LinuxApplicationLayoutTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test LinuxApplicationLayout\n+ * @requires (os.family == \"linux\")\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/LinuxApplicationLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.LinuxApplicationLayoutTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/junit.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.model.AppImageLayoutTest;\n+import jdk.jpackage.internal.model.ApplicationLayoutTest;\n+import org.junit.jupiter.api.Test;\n+\n+public class MacApplicationLayoutTest {\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    public static MacApplicationLayout createLayout() {\n+        return MacApplicationLayout.create(ApplicationLayoutTest.createLayout(),\n+                Path.of(\"Contents\/runtime\"));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/jdk.jpackage\/jdk\/jpackage\/internal\/MacApplicationLayoutTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test MacApplicationLayoutTest\n+ * @requires (os.family == \"mac\")\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/MacApplicationLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.MacApplicationLayoutTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/junit.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+\n+public class BuildEnvTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"image\"})\n+    public void testUnresolvedAppImageLayout(Path appImageDir) {\n+        final var rootDir = Path.of(\"\");\n+\n+        final var env = BuildEnv.create(rootDir, Optional.empty(), true,\n+                BuildEnvTest.class, RuntimeLayout.DEFAULT.resolveAt(appImageDir).resetRootDirectory());\n+\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(Path.of(\"\"), env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertTrue(env.verbose());\n+    }\n+\n+    @Test\n+    public void testResolvedAppImageLayout() {\n+        final var rootDir = Path.of(\"\/oof\");\n+        final var appImageDir = Path.of(\"\/foo\/bar\");\n+\n+        final var layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir);\n+        final var env = BuildEnv.create(rootDir, Optional.empty(), true, BuildEnvTest.class, layout);\n+\n+        assertSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(Path.of(\"\/foo\/bar\"), env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertTrue(env.verbose());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"\/foo\/bar\"})\n+    public void test_withAppImageDir(Path appImageDir) {\n+        final var rootDir = Path.of(\"\/oof\");\n+\n+        final var layout = RuntimeLayout.DEFAULT;\n+        final var env = BuildEnv.withAppImageDir(BuildEnv.create(rootDir,\n+                Optional.empty(), false, BuildEnvTest.class, layout), appImageDir);\n+\n+        assertNotSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(appImageDir, env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertFalse(env.verbose());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_withAppImageLayout(boolean resolved) {\n+        final var rootDir = Path.of(\"\/oof\");\n+\n+        final var appImageDir = Path.of(\"\/foo\/bar\");\n+\n+        final AppImageLayout layout;\n+        if (resolved) {\n+            layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir);\n+        } else {\n+            layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir).resetRootDirectory();\n+        }\n+\n+        final var env = BuildEnv.withAppImageLayout(BuildEnv.create(rootDir,\n+                Optional.empty(), false, BuildEnvTest.class, RuntimeLayout.DEFAULT), layout);\n+\n+        assertSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertFalse(env.verbose());\n+    }\n+\n+    @Test\n+    public void test_asApplicationLayout() {\n+        final var rootDir = Path.of(\"r\");\n+\n+        assertTrue(BuildEnv.create(rootDir, Optional.empty(), false,\n+                BuildEnvTest.class, RuntimeLayout.DEFAULT).asApplicationLayout().isEmpty());\n+\n+        var layout = ApplicationLayout.build().setAll(\"foo\").create();\n+        assertSame(layout, BuildEnv.create(rootDir, Optional.empty(), false,\n+                BuildEnvTest.class, layout).asApplicationLayout().orElseThrow());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/BuildEnvTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,872 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import jdk.jpackage.internal.PackagingPipeline.BuildApplicationTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.CopyAppImageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.NoArgTaskAction;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskAction;\n+import jdk.jpackage.internal.PackagingPipeline.TaskContext;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.RuntimeBuilder;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+\n+public class PackagingPipelineTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testBuildApplication(boolean withRuntimeBuilder, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1, withRuntimeBuilder ? Optional.of(TestRuntimeBuilder.INSTANCE) : Optional.empty());\n+        final var env = buildEnv(workDir.resolve(\"build\")).appImageDirFor(app).create();\n+\n+        \/\/ Build application image in `env.appImageDir()` directory.\n+        final var builder = buildPipeline();\n+        if (app.runtimeBuilder().isEmpty()) {\n+            builder.task(BuildApplicationTaskID.RUNTIME).noaction().add();\n+        }\n+\n+        builder.create().execute(env, app);\n+\n+        assertEquals(app.appImageDirName(), env.appImageDir().getFileName());\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(env, app);\n+        }));\n+\n+        List<TaskID> expectedActions = new ArrayList<>();\n+        if (app.runtimeBuilder().isPresent()) {\n+            expectedActions.add(BuildApplicationTaskID.RUNTIME);\n+        }\n+        expectedActions.addAll(List.of(BuildApplicationTaskID.LAUNCHERS, BuildApplicationTaskID.CONTENT));\n+\n+        assertEquals(expectedActions, executedTaskActions);\n+\n+        final ExpectedAppImage expectedAppImage;\n+        if (withRuntimeBuilder) {\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(\"launchers\/my-launcher\", TestLauncher.CONTENT)\n+                    .file(\"runtime\/my-runtime\", TestRuntimeBuilder.CONTENT);\n+        } else {\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(\"launchers\/my-launcher\", TestLauncher.CONTENT);\n+        }\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(env.appImageDir()));\n+    }\n+\n+    @Test\n+    void testCopyApplication(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var srcApp = createApp(TEST_LAYOUT_1, TestRuntimeBuilder.INSTANCE);\n+\n+        final var srcEnv = buildEnv(workDir.resolve(\"build\")).appImageDirFor(srcApp).create();\n+\n+        \/\/ Build application image in `srcEnv.appImageDir()` directory.\n+        buildPipeline().create().execute(srcEnv, srcApp);\n+\n+        final var dstApp = createApp(TEST_LAYOUT_2, TestRuntimeBuilder.INSTANCE);\n+\n+        final var dstEnv = buildEnv(workDir.resolve(\"build-2\"))\n+                .appImageLayout(dstApp.imageLayout().resolveAt(workDir.resolve(\"a\/b\/c\")))\n+                .create();\n+\n+        \/\/ Copy application image from `srcEnv.appImageDir()` into `dstEnv.appImageDir()`\n+        \/\/ with layout transformation.\n+        \/\/ This test exercises flexibility of the packaging pipeline.\n+        final var builder = buildPipeline()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).applicationAction(cfg -> {\n+                    assertSame(dstApp, cfg.app());\n+                    assertEquals(dstEnv.appImageDir(), cfg.env().appImageLayout().rootDirectory());\n+                    assertFalse(Files.exists(dstEnv.appImageDir()));\n+                    PackagingPipeline.copyAppImage(srcEnv.appImageLayout(), cfg.env().appImageLayout(), false);\n+                }).add();\n+\n+        \/\/ Disable the default \"build application image\" actions of the tasks which\n+        \/\/ are the dependencies of `PrimaryTaskID.BUILD_APPLICATION_IMAGE` task as\n+        \/\/ their output will be overwritten in the custom action of this task.\n+        builder.taskGraphSnapshot().getAllTailsOf(PrimaryTaskID.BUILD_APPLICATION_IMAGE).forEach(taskId -> {\n+            builder.task(taskId).noaction().add();\n+        });\n+\n+        builder.create().execute(dstEnv, dstApp);\n+\n+        AppImageLayout.toPathGroup(dstEnv.appImageLayout()).paths().forEach(path -> {\n+            assertTrue(Files.exists(path));\n+        });\n+\n+        assertEquals(Path.of(\"c\"), dstEnv.appImageDir().getFileName());\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(dstEnv, dstApp);\n+        }));\n+\n+        assertEquals(List.of(PrimaryTaskID.BUILD_APPLICATION_IMAGE), executedTaskActions);\n+\n+        final ExpectedAppImage expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(\"q\/launchers\/my-launcher\", TestLauncher.CONTENT)\n+                .file(\"qqq\/runtime\/my-runtime\", TestRuntimeBuilder.CONTENT);\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(dstEnv.appImageDir()));\n+    }\n+\n+    @Test\n+    void testCreatePackage(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var outputDir = workDir.resolve(\"bundles\");\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1_WITH_INSTALL_DIR, TestRuntimeBuilder.INSTANCE)).create();\n+        final var env = buildEnv(workDir.resolve(\"build\")).appImageDirFor(pkg).create();\n+\n+        final var builder = buildPipeline();\n+\n+        \/\/ Will create an app image in `env.appImageDir()` directory with `pkg.appImageLayout()` layout.\n+        \/\/ Will convert the created app image into a package.\n+        builder.create().execute(env, pkg, outputDir);\n+\n+        final var expected = createTestPackageFileContents(env.appImageLayout());\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"testCreatePackage:\\n---\\n%s\\n---\", actual));\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(env, pkg, outputDir);\n+        }));\n+\n+        assertEquals(List.of(\n+                BuildApplicationTaskID.RUNTIME,\n+                BuildApplicationTaskID.LAUNCHERS,\n+                BuildApplicationTaskID.CONTENT,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE\n+        ), executedTaskActions);\n+\n+        final var expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(TEST_INSTALL_DIR.resolve(\"launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                .file(TEST_INSTALL_DIR.resolve(\"runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(env.appImageDir()));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testCreateRuntimeInstaller(boolean transformLayout, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final AppImageLayout srcLayout;\n+        if (transformLayout) {\n+            \/\/ Create an application layout such that the runtime directory doesn't\n+            \/\/ have a common parent with other directories otherwise the runtime directory\n+            \/\/ will be skipped when copying the app image layout as path groups because\n+            \/\/ the destination app image layout is of type RuntimeLayout and have only\n+            \/\/ the runtime directory.\n+            srcLayout = ApplicationLayout.build()\n+                    .launchersDirectory(\"launchers\")\n+                    .appDirectory(\"lib\")\n+                    .runtimeDirectory(\"runtime\")\n+                    .appModsDirectory(\"lib\")\n+                    .contentDirectory(\"lib\")\n+                    .desktopIntegrationDirectory(\"lib\")\n+                    .create();\n+        } else {\n+            srcLayout = RuntimeLayout.DEFAULT;\n+        }\n+\n+        \/\/ Create a runtime image in `env.appImageDir()` directory.\n+        final var env = buildEnv(workDir.resolve(\"build\"))\n+                .appImageLayout(srcLayout)\n+                .appImageDir(workDir.resolve(\"rt\"))\n+                .create();\n+        TestRuntimeBuilder.INSTANCE.create(env.appImageLayout());\n+\n+        final var pipeline = buildPackage(createApp(\n+                RuntimeLayout.DEFAULT.resolveAt(TEST_INSTALL_DIR).resetRootDirectory())).create();\n+\n+        final var expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(TEST_INSTALL_DIR.resolve(\"my-runtime\"), TestRuntimeBuilder.CONTENT);\n+\n+        createAndVerifyPackage(buildPipeline(), pipeline, env, workDir.resolve(\"bundles\"),\n+                String.format(\"testCreateRuntimeInstaller(%s)\", transformLayout), expectedAppImage,\n+                CopyAppImageTaskID.COPY,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE);\n+    }\n+\n+    private enum ExternalAppImageMode {\n+\n+        \/\/ Copy predefined app image from `BuildEnv.appImageDir()`.\n+        \/\/ Layout of the predefined app image is `BuildEnv.appImageLayout()` and\n+        \/\/ its unresolved variant equals to `Package.appImageLayout()`.\n+        COPY_FROM_BUILD_ENV,\n+\n+        \/\/ Copy predefined app image from some directory.\n+        \/\/ Layout of the predefined app image is `Package.appImageLayout()`.\n+        COPY,\n+\n+        \/\/ Copy predefined app image from `BuildEnv.appImageDir()`.\n+        \/\/ Layout of the predefined app image is `BuildEnv.appImageLayout()` and\n+        \/\/ its unresolved variant is NOT equal to `Package.appImageLayout()`.\n+        TRANSFORM_FROM_BUILD_ENV,\n+        ;\n+\n+        static final Set<ExternalAppImageMode> FROM_BUILD_ENV = Set.of(\n+                COPY_FROM_BUILD_ENV, TRANSFORM_FROM_BUILD_ENV);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ExternalAppImageMode.class)\n+    void testCreatePackageFromExternalAppImage(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final ApplicationLayout appLayout;\n+        final ExpectedAppImage expectedAppImage;\n+        if (ExternalAppImageMode.TRANSFORM_FROM_BUILD_ENV == mode) {\n+            appLayout = TEST_LAYOUT_2_WITH_INSTALL_DIR;\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(TEST_INSTALL_DIR.resolve(\"q\/launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                    .file(TEST_INSTALL_DIR.resolve(\"qqq\/runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        } else {\n+            appLayout = TEST_LAYOUT_1_WITH_INSTALL_DIR;\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(TEST_INSTALL_DIR.resolve(\"launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                    .file(TEST_INSTALL_DIR.resolve(\"runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        }\n+\n+        final BuildEnv env;\n+        final Path predefinedAppImage;\n+        if (ExternalAppImageMode.FROM_BUILD_ENV.contains(mode)) {\n+            \/\/ External app image is stored in the build env app image directory.\n+            env = setupBuildEnvForExternalAppImage(workDir);\n+            predefinedAppImage = env.appImageDir();\n+        } else {\n+            \/\/ External app image is stored outside of the build env app image directory\n+            \/\/ and should have the same layout as the app's app image layout.\n+            env = buildEnv(workDir.resolve(\"build\"))\n+                    .appImageDir(workDir)\n+                    \/\/ Always need some app image layout.\n+                    .appImageLayout(new AppImageLayout.Stub(Path.of(\"\")))\n+                    .create();\n+            final var externalAppImageLayout = appLayout.resolveAt(workDir.resolve(\"app-image\"));\n+            TestRuntimeBuilder.INSTANCE.create(externalAppImageLayout);\n+            TestLauncher.INSTANCE.create(externalAppImageLayout);\n+            predefinedAppImage = externalAppImageLayout.rootDirectory();\n+        }\n+\n+        final var pkg = buildPackage(createApp(appLayout))\n+                .predefinedAppImage(predefinedAppImage)\n+                .create();\n+\n+        createAndVerifyPackage(buildPipeline(), pkg, env, workDir.resolve(\"bundles\"),\n+                String.format(\"testCreatePackageFromExternalAppImage(%s)\", mode), expectedAppImage,\n+                CopyAppImageTaskID.COPY,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(names={\"COPY\", \"COPY_FROM_BUILD_ENV\"})\n+    void testCreatePackageFromExternalAppImageNoCopyAction(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final ApplicationLayout appLayout = TEST_LAYOUT_1_WITH_INSTALL_DIR;\n+\n+        final BuildEnv env;\n+        final ApplicationLayout predefinedAppImageLayout;\n+        if (ExternalAppImageMode.FROM_BUILD_ENV.contains(mode)) {\n+            \/\/ External app image is stored in the build env app image directory.\n+            env = setupBuildEnvForExternalAppImage(workDir);\n+            predefinedAppImageLayout = env.asApplicationLayout().orElseThrow();\n+        } else {\n+            \/\/ External app image is stored outside of the build env app image directory\n+            \/\/ and should have the same layout as the app's app image layout.\n+            env = buildEnv(workDir.resolve(\"build\"))\n+                    .appImageDir(workDir)\n+                    \/\/ Always need some app image layout.\n+                    .appImageLayout(new AppImageLayout.Stub(Path.of(\"\")))\n+                    .create();\n+            predefinedAppImageLayout = appLayout.resolveAt(workDir.resolve(\"app-image\"));\n+            TestRuntimeBuilder.INSTANCE.create(predefinedAppImageLayout);\n+            TestLauncher.INSTANCE.create(predefinedAppImageLayout);\n+        }\n+\n+        final var pkg = buildPackage(createApp(appLayout))\n+                .predefinedAppImage(predefinedAppImageLayout.rootDirectory())\n+                .create();\n+\n+        final var outputDir = workDir.resolve(\"bundles\");\n+\n+        final var builder = buildPipeline().configuredTasks().filter(task -> {\n+            return CopyAppImageTaskID.COPY.equals(task.task());\n+        }).findFirst().orElseThrow().noaction().add();\n+\n+        final var startupParameters = builder.createStartupParameters(env, pkg, outputDir);\n+\n+        builder.create().execute(startupParameters);\n+\n+        final var expected = createTestPackageFileContents(predefinedAppImageLayout);\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"%s:\\n---\\n%s\\n---\",\n+                String.format(\"testCreatePackageFromExternalAppImage(%s)\", mode), actual));\n+\n+        final ExpectedAppImage expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(predefinedAppImageLayout.unresolve().launchersDirectory().resolve(\"my-launcher\"), TestLauncher.CONTENT)\n+                .file(predefinedAppImageLayout.unresolve().runtimeDirectory().resolve(\"my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(pkg.predefinedAppImage().orElseThrow()));\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(startupParameters);\n+        }));\n+        assertEquals(List.of(\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE), actualExecutedTaskActions);\n+    }\n+\n+    @Test\n+    void testCreatePackageFromExternalAppImageWithoutExternalAppImageError(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var env = setupBuildEnvForExternalAppImage(workDir);\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1_WITH_INSTALL_DIR)).create();\n+        final var pipeline = buildPipeline().create();\n+\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> pipeline.execute(env, pkg, workDir));\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_RuntimeException() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new RuntimeException(\"foo\");\n+        final var ex = testExceptionRethrow(expectedException, expectedException.getClass(), () -> {\n+            throw expectedException;\n+        });\n+        assertSame(expectedException, ex);\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_PackagerException() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new PackagerException(\"param.vendor.default\");\n+        final var ex = testExceptionRethrow(expectedException, expectedException.getClass(), () -> {\n+            throw expectedException;\n+        });\n+        assertSame(expectedException, ex);\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_Exception() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new Exception(\"foo\");\n+        final var ex = testExceptionRethrow(expectedException, PackagerException.class, () -> {\n+            rethrowUnchecked(expectedException);\n+        });\n+        assertSame(expectedException, ex.getCause());\n+    }\n+\n+    @Test\n+    void testAppImageAction() throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        final var executed = new boolean[1];\n+\n+        PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).appImageAction(ctx -> {\n+                    assertSame(app, ctx.app());\n+                    assertSame(env, ctx.env());\n+                    executed[0] = true;\n+                }).add().create().execute(env, app);\n+\n+        assertTrue(executed[0]);\n+    }\n+\n+    @Test\n+    void testAppImageActionWithPackage() throws PackagerException, IOException {\n+\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1, TestRuntimeBuilder.INSTANCE)).create();\n+        final var env = dummyBuildEnv();\n+\n+        final var executed = new boolean[1];\n+\n+        final var builder = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.PACKAGE).add();\n+\n+        final var startupParameters = builder.createStartupParameters(env,  pkg,  Path.of(\"\"));\n+\n+        builder.task(PrimaryTaskID.PACKAGE).appImageAction(ctx -> {\n+            assertSame(pkg.app(), ctx.app());\n+            assertSame(startupParameters.packagingEnv(), ctx.env());\n+            executed[0] = true;\n+        }).add().create().execute(startupParameters);\n+\n+        assertTrue(executed[0]);\n+    }\n+\n+    @Test\n+    void testPackageActionWithApplication() throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        final var pipeline = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).packageAction(ctx -> {\n+                    throw new AssertionError();\n+                }).add().create();\n+\n+        \/\/ If the pipeline is building an application, it can not execute actions that take a package as an argument.\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> pipeline.execute(env, app));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testContextMapper(boolean allowAll) throws PackagerException, IOException {\n+\n+        var builder = PackagingPipeline.buildStandard().contextMapper(ctx -> {\n+            return new TaskContext() {\n+                @Override\n+                public boolean test(TaskID task) {\n+                    return allowAll;\n+                }\n+\n+                @Override\n+                public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+                    if (!allowAll) {\n+                        throw new AssertionError();\n+                    }\n+                    ctx.execute(taskAction);\n+                }\n+            };\n+        });\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(dummyBuildEnv(), createApp(TEST_LAYOUT_1));\n+        }));\n+\n+        List<TaskID> expectedExecutedTaskActions;\n+\n+        if (allowAll) {\n+            expectedExecutedTaskActions = List.of(\n+                    BuildApplicationTaskID.RUNTIME,\n+                    BuildApplicationTaskID.LAUNCHERS,\n+                    BuildApplicationTaskID.CONTENT,\n+                    BuildApplicationTaskID.APP_IMAGE_FILE,\n+                    CopyAppImageTaskID.COPY,\n+                    PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT);\n+        } else {\n+            expectedExecutedTaskActions = List.of();\n+        }\n+\n+        assertEquals(expectedExecutedTaskActions, actualExecutedTaskActions);\n+    }\n+\n+    public static List<PackagingPipeline.TaskID> dryRun(PackagingPipeline.Builder builder,\n+            Consumer<PackagingPipeline.Builder> callback) {\n+\n+        List<PackagingPipeline.TaskID> executedTaskActions = new ArrayList<>();\n+        builder.configuredTasks().filter(PackagingPipeline.Builder.TaskBuilder::hasAction).forEach(taskBuilder -> {\n+            var taskId = taskBuilder.task();\n+            taskBuilder.action(() -> {\n+                executedTaskActions.add(taskId);\n+            }).add();\n+        });\n+\n+        callback.accept(builder);\n+\n+        return executedTaskActions;\n+    }\n+\n+    private static Exception testExceptionRethrow(Exception expectedException,\n+            Class<? extends Exception> expectedCatchExceptionType,\n+            NoArgTaskAction throwAction) throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        var pipeline = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).action(throwAction).add().create();\n+\n+        return assertThrowsExactly(expectedCatchExceptionType, () -> pipeline.execute(env,  app));\n+    }\n+\n+    private static BuildEnv setupBuildEnvForExternalAppImage(Path workDir) throws ConfigException {\n+        \/\/ Create an app image in `env.appImageDir()` directory.\n+        final var env = buildEnv(workDir.resolve(\"build\"))\n+                .appImageLayout(TEST_LAYOUT_1.resolveAt(Path.of(\"a\/b\/c\")).resetRootDirectory())\n+                .appImageDir(workDir.resolve(\"app-image\"))\n+                .create();\n+        TestRuntimeBuilder.INSTANCE.create(env.appImageLayout());\n+        TestLauncher.INSTANCE.create((ApplicationLayout)env.appImageLayout());\n+\n+        return env;\n+    }\n+\n+    private static void createAndVerifyPackage(PackagingPipeline.Builder builder, Package pkg,\n+            BuildEnv env, Path outputDir, String logMsgHeader, ExpectedAppImage expectedAppImage,\n+            TaskID... expectedExecutedTaskActions) throws PackagerException, IOException {\n+        Objects.requireNonNull(logMsgHeader);\n+\n+        final var startupParameters = builder.createStartupParameters(env, pkg, outputDir);\n+\n+        assertNotSameAppImageDirs(env, startupParameters.packagingEnv());\n+\n+        \/\/ Will create an app image in `startupParameters.packagingEnv().appImageDir()` directory\n+        \/\/ with `pkg.appImageLayout()` layout using an app image (runtime image) from `env.appImageDir()` as input.\n+        \/\/ Will convert the created app image into a package.\n+        \/\/ Will not overwrite the contents of `env.appImageDir()` directory.\n+        builder.create().execute(startupParameters);\n+\n+        final var packagingAppImageDir = startupParameters.packagingEnv().appImageDir();\n+\n+        final var expected = createTestPackageFileContents(pkg.appImageLayout().resolveAt(packagingAppImageDir));\n+\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"%s:\\n---\\n%s\\n---\", logMsgHeader, actual));\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(packagingAppImageDir));\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(startupParameters);\n+        }));\n+\n+        assertEquals(List.of(expectedExecutedTaskActions), actualExecutedTaskActions);\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout) {\n+        return createApp(appImageLayout, Optional.empty());\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout, RuntimeBuilder runtimeBuilder) {\n+        return createApp(appImageLayout, Optional.of(runtimeBuilder));\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout, Optional<RuntimeBuilder> runtimeBuilder) {\n+        Objects.requireNonNull(appImageLayout);\n+        Objects.requireNonNull(runtimeBuilder);\n+        if (appImageLayout.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new Application.Stub(\n+                \"foo\",\n+                \"My app\",\n+                \"1.0\",\n+                \"Acme\",\n+                \"copyright\",\n+                Optional.empty(),\n+                List.of(),\n+                appImageLayout,\n+                runtimeBuilder,\n+                List.of(),\n+                Map.of());\n+    }\n+\n+\n+    private static final class PackageBuilder {\n+        PackageBuilder(Application app) {\n+            this.app = Objects.requireNonNull(app);\n+        }\n+\n+        Package create() {\n+            return new Package.Stub(\n+                    app,\n+                    new PackageType() {},\n+                    \"the-package\",\n+                    \"My package\",\n+                    \"1.0\",\n+                    Optional.empty(),\n+                    Optional.empty(),\n+                    Optional.ofNullable(predefinedAppImage),\n+                    null,\n+                    TEST_INSTALL_DIR);\n+        }\n+\n+        PackageBuilder predefinedAppImage(Path v) {\n+            predefinedAppImage = v;\n+            return this;\n+        }\n+\n+        private Path predefinedAppImage;\n+        private final Application app;\n+    }\n+\n+\n+    private static PackageBuilder buildPackage(Application app) {\n+        return new PackageBuilder(app);\n+    }\n+\n+    private static BuildEnvBuilder buildEnv(Path rootDir) {\n+        return new BuildEnvBuilder(rootDir);\n+    }\n+\n+    private static BuildEnv dummyBuildEnv() {\n+        return BuildEnv.create(Path.of(\"foo\"), Optional.empty(), false, PackagingPipeline.class, RuntimeLayout.DEFAULT);\n+    }\n+\n+    private static PackagingPipeline.Builder buildPipeline() {\n+        return PackagingPipeline.buildStandard()\n+                \/\/ Disable building the app image file (.jpackage.xml) as we don't have launchers in the test app.\n+                .task(BuildApplicationTaskID.APP_IMAGE_FILE).noaction().add()\n+                .task(BuildApplicationTaskID.LAUNCHERS).applicationAction(cfg -> {\n+                    TestLauncher.INSTANCE.create(cfg.resolvedLayout());\n+                }).add()\n+                .task(PrimaryTaskID.PACKAGE).packageAction(cfg -> {\n+                    var str = createTestPackageFileContents(cfg.resolvedLayout());\n+                    var packageFile = cfg.outputDir().resolve(cfg.pkg().packageFileNameWithSuffix());\n+                    Files.createDirectories(packageFile.getParent());\n+                    Files.writeString(packageFile, str);\n+                }).add();\n+    }\n+\n+    private static String createTestPackageFileContents(AppImageLayout pkgLayout) throws IOException {\n+        return ExpectedAppImage.load(pkgLayout.rootDirectory()).toString();\n+    }\n+\n+    private static void assertNotSameAppImageDirs(BuildEnv a, BuildEnv b) {\n+        assertNotEquals(a.appImageDir(), b.appImageDir());\n+        assertEquals(a.buildRoot(), b.buildRoot());\n+        assertEquals(a.configDir(), b.configDir());\n+        assertEquals(a.resourceDir(), b.resourceDir());\n+    }\n+\n+\n+    private static final class TestRuntimeBuilder implements RuntimeBuilder {\n+        @Override\n+        public void create(AppImageLayout appImageLayout) {\n+            assertTrue(appImageLayout.isResolved());\n+            try {\n+                Files.createDirectories(appImageLayout.runtimeDirectory());\n+                Files.writeString(runtimeFile(appImageLayout), CONTENT);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private static Path runtimeFile(AppImageLayout appImageLayout) {\n+            return appImageLayout.runtimeDirectory().resolve(\"my-runtime\");\n+        }\n+\n+        static final String CONTENT = \"this is the runtime\";\n+\n+        static final TestRuntimeBuilder INSTANCE = new TestRuntimeBuilder();\n+    }\n+\n+\n+    private static final class TestLauncher {\n+        public void create(ApplicationLayout appLayout) {\n+            assertTrue(appLayout.isResolved());\n+            try {\n+                Files.createDirectories(appLayout.launchersDirectory());\n+                Files.writeString(launcherFile(appLayout), CONTENT);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private static Path launcherFile(ApplicationLayout appLayout) {\n+            return appLayout.launchersDirectory().resolve(\"my-launcher\");\n+        }\n+\n+        static final String CONTENT = \"this is the launcher\";\n+\n+        static final TestLauncher INSTANCE = new TestLauncher();\n+    }\n+\n+\n+    private static final class ExpectedAppImage {\n+\n+        static ExpectedAppImage build() {\n+            return new ExpectedAppImage(new HashSet<>());\n+        }\n+\n+        static ExpectedAppImage load(Path appImageRoot) throws IOException {\n+            try (var walk = Files.walk(appImageRoot)) {\n+                return new ExpectedAppImage(walk.sorted().map(path -> {\n+                    var relativePath = appImageRoot.relativize(path);\n+                    if (Files.isDirectory(path)) {\n+                        return new Directory(relativePath);\n+                    } else {\n+                        return new File(relativePath, toSupplier(() -> Files.readString(path)).get());\n+                    }\n+                }).collect(Collectors.toSet()));\n+            }\n+        }\n+\n+        ExpectedAppImage file(Path path, String content) {\n+            return add(new File(path, content));\n+        }\n+\n+        ExpectedAppImage file(String path, String content) {\n+            return file(Path.of(path), content);\n+        }\n+\n+        ExpectedAppImage dir(Path path) {\n+            return add(new Directory(path));\n+        }\n+\n+        ExpectedAppImage dir(String path) {\n+            return dir(Path.of(path));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return items.stream().map(AppImageItem::toString).sorted().collect(Collectors.joining(\"\\n\"));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(items);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if ((obj == null) || (getClass() != obj.getClass())) {\n+                return false;\n+            }\n+            ExpectedAppImage other = (ExpectedAppImage) obj;\n+            return Objects.equals(items, other.items);\n+        }\n+\n+        private ExpectedAppImage(Set<AppImageItem> items) {\n+            this.items = Objects.requireNonNull(items);\n+        }\n+\n+        private ExpectedAppImage add(AppImageItem v) {\n+            var path = v.path();\n+            if (path.isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            items.add(v);\n+            while (path.getNameCount() > 1) {\n+                items.add(new Directory(path = path.getParent()));\n+            }\n+            return this;\n+        }\n+\n+        private interface AppImageItem {\n+            Path path();\n+        }\n+\n+        private record File(Path path, String content) implements AppImageItem {\n+\n+            File {\n+                Objects.requireNonNull(path);\n+                Objects.requireNonNull(content);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return String.format(\"%s[%s]\", path, content);\n+            }\n+        }\n+\n+        private record Directory(Path path) implements AppImageItem {\n+\n+            Directory {\n+                Objects.requireNonNull(path);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return path.toString();\n+            }\n+        }\n+\n+        private final Set<AppImageItem> items;\n+    }\n+\n+\n+    private static final ApplicationLayout TEST_LAYOUT_1 = ApplicationLayout.build()\n+            .launchersDirectory(\"launchers\")\n+            .appDirectory(\"\")\n+            .runtimeDirectory(\"runtime\")\n+            .appModsDirectory(\"\")\n+            .contentDirectory(\"\")\n+            .desktopIntegrationDirectory(\"\")\n+            .create();\n+\n+    private static final ApplicationLayout TEST_LAYOUT_2 = ApplicationLayout.build()\n+            .launchersDirectory(\"q\/launchers\")\n+            .appDirectory(\"\")\n+            .runtimeDirectory(\"qqq\/runtime\")\n+            .appModsDirectory(\"\")\n+            .contentDirectory(\"\")\n+            .desktopIntegrationDirectory(\"\")\n+            .create();\n+\n+    private static final Path TEST_INSTALL_DIR = Path.of(\"Acme\/My app\");\n+\n+    private static final ApplicationLayout TEST_LAYOUT_1_WITH_INSTALL_DIR =\n+            TEST_LAYOUT_1.resolveAt(TEST_INSTALL_DIR).resetRootDirectory();\n+\n+    private static final ApplicationLayout TEST_LAYOUT_2_WITH_INSTALL_DIR =\n+            TEST_LAYOUT_2.resolveAt(TEST_INSTALL_DIR).resetRootDirectory();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/PackagingPipelineTest.java","additions":872,"deletions":0,"binary":false,"changes":872,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n@@ -27,1 +28,1 @@\n-import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n@@ -32,0 +33,1 @@\n+import jdk.jpackage.internal.util.PathGroup;\n@@ -51,1 +53,1 @@\n-        final var pathGroup = AppImageLayout.toPathGroup(layout);\n+        final var pathGroup = toPathGroup(layout);\n@@ -59,1 +61,28 @@\n-        final var dir = Path.of(\"foo\/bar\");\n+        testResolveAt(new AppImageLayout.Stub(Path.of(\"foo\")));\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        testResolveAtRepeat(new AppImageLayout.Stub(Path.of(\"foo\")));\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        testUnresolve(new AppImageLayout.Stub(Path.of(\"runtime\")));\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        testEmptyRootDirectory(new AppImageLayout.Stub(Path.of(\"rt\")));\n+    }\n+\n+    public static void testResolveAt(AppImageLayout testee) {\n+\n+        var dir = Path.of(\"foo\/bar\");\n+\n+        assertLayout(testee.resolveAt(dir), true, testee, dir);\n+    }\n+\n+    public static void testResolveAtRepeat(AppImageLayout testee) {\n+\n+        var resolvedLayout = testee.resolveAt(Path.of(\"b\/c\")).resolveAt(Path.of(\"a\"));\n@@ -61,1 +90,20 @@\n-        final var layout = new AppImageLayout.Stub(Path.of(\"\"), Path.of(\"runtime\"));\n+        assertLayout(resolvedLayout, true, testee, Path.of(\"a\/b\/c\"));\n+    }\n+\n+    public static void testUnresolve(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        var resolvedLayout = testee.resolveAt(Path.of(\"foo\/bar\"));\n+        var layout = resolvedLayout.unresolve();\n+\n+        assertLayout(layout, false, testee, Path.of(\"\"));\n+\n+        resolvedLayout = testee.resolveAt(Path.of(\"\").toAbsolutePath());\n+        layout = resolvedLayout.unresolve();\n+\n+        assertLayout(layout, false, testee, Path.of(\"\"));\n+\n+        assertSame(testee, testee.unresolve());\n+    }\n@@ -63,1 +111,4 @@\n-        final var resolvedLayout = layout.resolveAt(dir);\n+    public static void testEmptyRootDirectory(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n@@ -65,1 +116,1 @@\n-        assertNotSame(layout, resolvedLayout);\n+        assertEmptyRootDirectory(testee);\n@@ -67,2 +118,25 @@\n-        assertEquals(dir.resolve(layout.rootDirectory()), resolvedLayout.rootDirectory());\n-        assertEquals(dir.resolve(layout.runtimeDirectory()), resolvedLayout.runtimeDirectory());\n+        final var resolved = testee.resolveAt(Path.of(\"t\"));\n+\n+        assertEmptyRootDirectory(resolved);\n+    }\n+\n+    private static void assertEmptyRootDirectory(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            var newLayout = testee.resetRootDirectory();\n+            assertLayout(newLayout, false, Path.of(\"\"), toPathGroup(testee));\n+        } else {\n+            assertSame(testee, testee.resetRootDirectory());\n+        }\n+    }\n+\n+    private static void assertLayout(AppImageLayout actual, boolean expectedResolved,\n+            AppImageLayout base, Path baseResolveAt) {\n+        assertLayout(actual, expectedResolved, baseResolveAt.resolve(base.rootDirectory()),\n+                toPathGroup(base).resolveAt(baseResolveAt));\n+    }\n+\n+    private static void assertLayout(AppImageLayout actual, boolean expectedResolved,\n+            Path expectedRootDir, PathGroup expectedPaths) {\n+        assertEquals(expectedResolved, actual.isResolved());\n+        assertEquals(expectedRootDir, actual.rootDirectory());\n+        assertEquals(expectedPaths, toPathGroup(actual));\n@@ -70,0 +144,1 @@\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java","additions":83,"deletions":8,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n@@ -31,2 +34,0 @@\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -39,1 +40,31 @@\n-    public void test(boolean move, Path tempDir) throws IOException {\n+    @Test\n+    public void testMove(@TempDir Path tempDir) throws IOException {\n+        test(true, tempDir);\n+    }\n+\n+    @Test\n+    public void testCopy(@TempDir Path tempDir) throws IOException {\n+        test(false, tempDir);\n+    }\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    private static void test(boolean move, Path tempDir) throws IOException {\n@@ -58,8 +89,1 @@\n-        final var layout = ApplicationLayout.build()\n-                .launchersDirectory(\"bin\")\n-                .appDirectory(\"lib\/app\")\n-                .runtimeDirectory(\"runtime\")\n-                .appModsDirectory(\"mods\")\n-                .contentDirectory(\"content\")\n-                .desktopIntegrationDirectory(\"lib\/apps\")\n-                .create();\n+        final var layout = createLayout();\n@@ -103,8 +127,9 @@\n-    @Test\n-    public void testMove(@TempDir Path tempDir) throws IOException {\n-        test(true, tempDir);\n-    }\n-\n-    @Test\n-    public void testCopy(@TempDir Path tempDir) throws IOException {\n-        test(false, tempDir);\n+    public static ApplicationLayout createLayout() {\n+        return ApplicationLayout.build()\n+                .launchersDirectory(\"bin\")\n+                .appDirectory(\"lib\/app\")\n+                .runtimeDirectory(\"runtime\")\n+                .appModsDirectory(\"mods\")\n+                .contentDirectory(\"content\")\n+                .desktopIntegrationDirectory(\"lib\/apps\")\n+                .create();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java","additions":44,"deletions":19,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -68,0 +68,8 @@\n+    @Test\n+    public void equals() {\n+        assertEquals(new PathGroup(Map.of()), new PathGroup(Map.of()));\n+        assertEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))));\n+        assertNotEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"foo\", Path.of(\"rab\"))));\n+        assertNotEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"Foo\", Path.of(\"bar\"))));\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/PathGroupTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,4 +43,6 @@\n-    static {\n-        if (System.getProperty(\"test.src\") == null) {\n-            \/\/ Was called by somebody else but not by jtreg\n-            System.setProperty(\"test.src\", Path.of(\"@@openJdkDir@@\/test\/jdk\/tools\/jpackage\").toString());\n+    public static class TestSrcInitializer {\n+        static {\n+            if (System.getProperty(\"test.src\") == null) {\n+                \/\/ Was called by somebody else but not by jtreg\n+                System.setProperty(\"test.src\", Path.of(\"@@openJdkDir@@\/test\/jdk\/tools\/jpackage\").toString());\n+            }\n@@ -87,0 +89,4 @@\n+    static {\n+        new TestSrcInitializer();\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/tools\/jdk\/jpackage\/test\/JUnitAdapter.java","additions":10,"deletions":4,"binary":false,"changes":14,"previous_filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JUnitAdapter.java","status":"renamed"},{"patch":"@@ -27,1 +27,2 @@\n- * @compile\/module=jdk.jpackage jdk\/jpackage\/internal\/ExecutableOSVersionTest.java\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/ExecutableOSVersionTest.java\n","filename":"test\/jdk\/tools\/jpackage\/junit\/windows\/junit.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -425,1 +425,6 @@\n-        return \"\" + WB.isCDSIncluded();\n+        boolean noJvmtiAdded = allFlags()\n+                .filter(s -> s.startsWith(\"-agentpath\"))\n+                .findAny()\n+                .isEmpty();\n+\n+        return \"\" + (noJvmtiAdded && WB.isCDSIncluded());\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -146,0 +146,3 @@\n+        \/\/ used for themes\n+        removeAll(styleSheetNames, \"theme-dark\", \"theme-light\", \"theme-os\");\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/checkStylesheetClasses\/CheckStylesheetClasses.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                    <footer role=\"contentinfo\"> \"\"\",\n+                    <footer> \"\"\",\n@@ -116,1 +116,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -153,1 +153,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlLandmarkRegions\/TestHtmlLandmarkRegions.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -112,1 +112,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -153,1 +153,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -174,1 +174,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -202,1 +202,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -223,1 +223,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -246,1 +246,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -282,1 +282,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -302,1 +302,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -340,1 +340,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -390,1 +390,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -431,1 +431,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -463,1 +463,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -490,1 +490,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -517,1 +517,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -555,1 +555,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -584,1 +584,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlVersion\/TestHtmlVersion.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8196027 8196202 8320458\n+ * @bug 8196027 8196202 8320458 8342705\n@@ -90,0 +90,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -101,0 +104,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -112,0 +118,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -123,0 +132,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -134,0 +146,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -145,0 +160,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -157,0 +175,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/..\/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/..\/resour\\\n+                    ce-files\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -169,0 +190,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/..\/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/..\/resour\\\n+                    ce-files\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNavigation\/TestModuleNavigation.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *           8342705\n@@ -73,0 +74,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -84,0 +88,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -95,0 +102,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -106,0 +116,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -117,0 +130,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -342,0 +358,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -353,0 +372,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -364,0 +386,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -375,0 +400,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -414,0 +442,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -429,0 +460,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNavigation\/TestNavigation.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -129,0 +129,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -130,12 +133,0 @@\n-                    <\/div>\n-                    <\/div>\n-                    <div class=\"sub-nav\">\n-                    <div class=\"nav-content\">\n-                    <ol class=\"sub-nav-list\"><\/ol>\n-                    <div class=\"nav-list-search\"><input type=\"text\" id=\"search-input\" disabled place\\\n-                    holder=\"Search documentation (type \/)\" aria-label=\"Search in documentation\" auto\\\n-                    complete=\"off\" spellcheck=\"false\"><input type=\"reset\" id=\"reset-search\" disabled\\\n-                     value=\"Reset\"><\/div>\n-                    <\/div>\n-                    <\/div>\n-                    <!-- ========= END OF TOP NAVBAR ========= -->\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSpecTag\/TestSpecTag.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -95,1 +95,2 @@\n-                        background-color:var(--search-tag-highlight-color);\n+                        background-color:var(--search-tag-background-color);\n+                        color:var(--search-tag-text-color);\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testStylesheet\/TestStylesheet.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -212,0 +212,1 @@\n+            \"resource-files\/moon.svg\",\n@@ -214,0 +215,1 @@\n+            \"resource-files\/sun.svg\",\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/APITest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n+import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -133,4 +133,5 @@\n-            log.warning(LintWarnings.DivZero);\n-            log.warning(tree.pos, LintWarnings.DivZero);\n-            log.warning(tree.pos(), LintWarnings.DivZero);\n-            log.warning(nil, LintWarnings.DivZero);\n+            \/\/ some warnings that will be emitted during parsing\n+            log.warning(Warnings.ExtraneousSemicolon);\n+            log.warning(tree.pos, Warnings.ExtraneousSemicolon);\n+            log.warning(tree.pos(), Warnings.ExtraneousSemicolon);\n+            log.warning(nil, Warnings.ExtraneousSemicolon);\n","filename":"test\/langtools\/tools\/javac\/6304921\/TestLog.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -733,1 +733,0 @@\n-                \"module-info.java:3:18: compiler.warn.module.not.found: M1\",\n@@ -735,0 +734,1 @@\n+                \"module-info.java:3:18: compiler.warn.module.not.found: M1\",\n","filename":"test\/langtools\/tools\/javac\/ImportModule.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-T6400189a.java:14:35: compiler.warn.unchecked.call.mbr.of.raw.type: <T>getAnnotation(java.lang.Class<T>), java.lang.reflect.Constructor\n+T6400189a.java:14:35: compiler.warn.unchecked.call.mbr.of.raw.type: <T>getAnnotation(java.lang.Class<T>), java.lang.reflect.Constructor\n","filename":"test\/langtools\/tools\/javac\/OverrideChecks\/6400189\/T6400189a.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-T6400189b.java:24:24: compiler.warn.unchecked.call.mbr.of.raw.type: <T>m(T6400189b<T>), T6400189b.B\n+T6400189b.java:24:24: compiler.warn.unchecked.call.mbr.of.raw.type: <T>m(T6400189b<T>), T6400189b.B\n","filename":"test\/langtools\/tools\/javac\/OverrideChecks\/6400189\/T6400189b.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,0 +1,2 @@\n+DanglingDocCommentsClass.java:15:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass.java:19:5: compiler.warn.dangling.doc.comment\n@@ -5,2 +7,0 @@\n-DanglingDocCommentsClass.java:15:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsClass.java:19:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass.enabled.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,0 +1,2 @@\n+DanglingDocCommentsClass_Line.java:21:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass_Line.java:26:5: compiler.warn.dangling.doc.comment\n@@ -5,2 +7,0 @@\n-DanglingDocCommentsClass_Line.java:21:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsClass_Line.java:26:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass_Line.enabled.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,0 @@\n-DanglingDocCommentsClass_Mixed.java:13:1: compiler.warn.dangling.doc.comment\n@@ -4,0 +3,1 @@\n+DanglingDocCommentsClass_Mixed.java:13:1: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass_Mixed.enabled.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,0 +1,3 @@\n+DanglingDocCommentsEnum.java:16:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:22:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:28:5: compiler.warn.dangling.doc.comment\n@@ -5,3 +8,0 @@\n-DanglingDocCommentsEnum.java:16:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:22:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:28:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsEnum.enabled.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-    public DocCommentTester(boolean useBreakIterator, boolean useIdentityTtransformer) {\n+    public DocCommentTester(boolean useBreakIterator, boolean useIdentityTransformer) {\n@@ -133,1 +133,1 @@\n-        this.useIdentityTransformer = useIdentityTtransformer;\n+        this.useIdentityTransformer = useIdentityTransformer;\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8298405\n+ * @bug 8298405 8356411\n@@ -662,0 +662,24 @@\n+    \/\/\/ @see Ref label\n+    \/\/\/ @see <a href=\"..\">link<a>\n+    \/\/\/ @see \"Text\"\n+    void seeTags() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: empty\n+  body: empty\n+  block tags: 3\n+    See[SEE, pos:0\n+      reference: 2\n+        Reference[REFERENCE, pos:5, Ref]\n+        RawText[MARKDOWN, pos:9, label]\n+    ]\n+    See[SEE, pos:15\n+      reference: 1\n+        RawText[MARKDOWN, pos:20, <a_href=\"..\">link<a>]\n+    ]\n+    See[SEE, pos:41\n+      reference: 1\n+        Text[TEXT, pos:46, \"Text\"]\n+    ]\n+]\n+*\/\n","filename":"test\/langtools\/tools\/javac\/doctree\/MarkdownTest.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8332858\n+ * @bug 8332858 8356411\n@@ -56,0 +56,1 @@\n+        t.testSeeTags();\n@@ -86,0 +87,13 @@\n+    private void testSeeTags() throws Exception {\n+        \/\/ @see \"Text\" does not produce a Markdown text\n+        runTest(\"\"\"\n+                \/\/\/ @see Ref label\n+                \/\/\/ @see <a href=\"..\">link<a>\n+                \/\/\/ @see \"Text\"\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"label\",\n+                \"<a href=\\\"..\\\">link<a>\");\n+    }\n+\n@@ -181,1 +195,1 @@\n-}\n+}\n","filename":"test\/langtools\/tools\/javac\/doctree\/MarkdownTransformerPositionTest.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,2 +2,3 @@\n-T7188968.java:20:9: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n-T7188968.java:21:29: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n+T7188968.java:23:24: compiler.err.cant.resolve.location: kindname.variable, unknown, , , (compiler.misc.location: kindname.class, T7188968, null)\n+T7188968.java:20:9: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n+T7188968.java:21:29: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n@@ -6,1 +7,0 @@\n-T7188968.java:23:24: compiler.err.cant.resolve.location: kindname.variable, unknown, , , (compiler.misc.location: kindname.class, T7188968, null)\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/7188968\/T7188968.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-TargetType22.java:29:21: compiler.warn.unchecked.varargs.non.reifiable.type: A\n+TargetType22.java:29:21: compiler.warn.unchecked.varargs.non.reifiable.type: A\n","filename":"test\/langtools\/tools\/javac\/lambda\/TargetType22.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify lexical lint warnings handle nested declarations with SuppressWarnings correctly\n+ * @compile\/fail\/ref=LexicalLintNesting.out -XDrawDiagnostics -Xlint:text-blocks -Werror LexicalLintNesting.java\n+ *\/\n+\n+\/\/@SuppressWarnings(\"text-blocks\")\n+public class LexicalLintNesting {\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s1 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s2 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    public static class Nested1 {\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s3 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s4 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        public static class Nested1A {\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s5 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s6 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s7 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s8 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        public static class Nested1B {\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s9 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            \/* WARNING HERE *\/ String s10 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s11 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s12 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s13 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s14 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Nested2 {\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s15 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s16 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        public static class Nested2A {\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s17 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s18 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s19 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s20 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        public static class Nested2B {\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s21 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s22 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s23 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s24 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+    }\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s25 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s26 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/LexicalLintNesting.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+LexicalLintNesting.java:12:36: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:30:40: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:55:40: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:68:45: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:80:41: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:92:37: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:162:37: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+7 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/LexicalLintNesting.out","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify SuppressWarnings works for LintCategore.TEXT_BLOCKS\n+ * @compile\/fail\/ref=TextBlockSuppress.out -XDrawDiagnostics -Xlint:text-blocks -Werror TextBlockSuppress.java\n+ *\/\n+\n+public class TextBlockSuppress {\n+\n+    public static class Example1 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example2 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example3 {\n+        @SuppressWarnings(\"text-blocks\")\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example4 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example5 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example6 {\n+        public void method() {\n+            @SuppressWarnings(\"text-blocks\")\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+TextBlockSuppress.java:12:24: compiler.warn.trailing.white.space.will.be.removed\n+TextBlockSuppress.java:38:24: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n+Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n","filename":"test\/langtools\/tools\/javac\/mandatoryWarnings\/deprecated\/Test5.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n+Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n","filename":"test\/langtools\/tools\/javac\/mandatoryWarnings\/deprecated\/Test5b.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -602,1 +602,1 @@\n-                        \"module-info.java:1:19: compiler.warn.missing.deprecated.annotation\",\n+                        \"module-info.java:1:19: compiler.warn.missing.deprecated.annotation\",\n","filename":"test\/langtools\/tools\/javac\/modules\/AnnotationsOnModules.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,1 +327,3 @@\n-                            if (lint == Lint.ENABLE_PREVIEW) {\n+                            if (suppress == Suppress.YES) {\n+                                expected = Set.of();\n+                            } else if (lint == Lint.ENABLE_PREVIEW) {\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewErrors.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -590,1 +590,0 @@\n-                        \"Test.java:24:11: compiler.warn.is.preview.reflective: test()\",\n@@ -596,0 +595,1 @@\n+                        \"Test.java:24:11: compiler.warn.is.preview.reflective: test()\",\n@@ -795,0 +795,93 @@\n+    @Test \/\/JDK-8224228:\n+    public void testSuppressWarnings(Path base) throws Exception {\n+        Path apiSrc = base.resolve(\"api-src\");\n+        tb.writeJavaFiles(apiSrc,\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST)\n+                          public class Preview {\n+                              public static int test() {\n+                                return 0;\n+                              }\n+                          }\n+                          \"\"\");\n+        Path apiClasses = base.resolve(\"api-classes\");\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(apiClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiSrc.toString(),\n+                         \"-Werror\")\n+                .files(tb.findJavaFiles(apiSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc,\n+                          \"\"\"\n+                          package test;\n+                          import preview.api.Preview;\n+                          public class Test {\n+\n+                            public static class Example1 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example2 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example3 {\n+                                @SuppressWarnings(\"preview\")\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example4 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example5 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example6 {\n+                                @SuppressWarnings(\"preview\")\n+                                int x = Preview.test();     \/\/ SHOULD NOT get a warning here\n+                            }\n+                          }\n+                          \"\"\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(testClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiClasses.toString(),\n+                         \"--add-exports\", \"java.base\/preview.api=ALL-UNNAMED\",\n+                         \"--enable-preview\",\n+                         \"-Xlint:preview\",\n+                         \"-source\", String.valueOf(Runtime.version().feature()),\n+                         \"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(testSrc))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected =\n+                List.of(\"Test.java:7:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"Test.java:27:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"2 warnings\");\n+\n+        if (!log.equals(expected))\n+            throw new Exception(\"expected output not found: \" + log);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewTest.java","additions":95,"deletions":2,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -1,2 +1,0 @@\n-T7097436.java:13:20: compiler.warn.varargs.unsafe.use.varargs.param: ls\n-T7097436.java:14:25: compiler.warn.varargs.unsafe.use.varargs.param: ls\n@@ -5,0 +3,2 @@\n+T7097436.java:13:20: compiler.warn.varargs.unsafe.use.varargs.param: ls\n+T7097436.java:14:25: compiler.warn.varargs.unsafe.use.varargs.param: ls\n","filename":"test\/langtools\/tools\/javac\/varargs\/7097436\/T7097436.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+T6594914a.java:16:52: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n@@ -5,1 +6,0 @@\n-T6594914a.java:16:52: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n","filename":"test\/langtools\/tools\/javac\/warnings\/6594914\/T6594914a.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,0 +1,4 @@\n+T7090499.java:26:10: compiler.err.improperly.formed.type.inner.raw.param\n+T7090499.java:27:10: compiler.err.improperly.formed.type.inner.raw.param\n+T7090499.java:28:17: compiler.err.improperly.formed.type.inner.raw.param\n+T7090499.java:28:10: compiler.err.improperly.formed.type.inner.raw.param\n@@ -6,4 +10,0 @@\n-T7090499.java:26:10: compiler.err.improperly.formed.type.inner.raw.param\n-T7090499.java:27:10: compiler.err.improperly.formed.type.inner.raw.param\n-T7090499.java:28:17: compiler.err.improperly.formed.type.inner.raw.param\n-T7090499.java:28:10: compiler.err.improperly.formed.type.inner.raw.param\n","filename":"test\/langtools\/tools\/javac\/warnings\/7090499\/T7090499.out","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-                               \"UnneededStrictfpWarning1.java:16:28: compiler.warn.strictfp\",\n+                               \"UnneededStrictfpWarning1.java:16:28: compiler.warn.strictfp\",\n","filename":"test\/langtools\/tools\/javac\/warnings\/UnneededStrictfpWarningToolBox.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+T6480588.java:18:35: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n@@ -6,0 +7,4 @@\n+T6480588.java:30:5: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n+T6480588.java:33:25: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n+T6480588.java:33:52: compiler.warn.has.been.deprecated: DeprecatedInterface, compiler.misc.unnamed.package\n+T6480588.java:32:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n@@ -7,1 +12,1 @@\n-T6480588.java:18:35: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n+T6480588.java:29:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n@@ -13,5 +18,0 @@\n-T6480588.java:30:5: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n-T6480588.java:29:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n-T6480588.java:33:25: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n-T6480588.java:33:52: compiler.warn.has.been.deprecated: DeprecatedInterface, compiler.misc.unnamed.package\n-T6480588.java:32:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n","filename":"test\/langtools\/tools\/javac\/warnings\/suppress\/T6480588.out","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    private static final String FLAG_NAME = \"LargePageSizeInBytes\";\n+    private static final String FLAG_NAME = \"LargePageHeapSizeThreshold\";\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/vm_flags\/SizeTTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,987 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+\/*\n+*\n+ * The jtreg tests might be executed with this agent to ensure that corresponding\n+ * JDK functionality is not broken.\n+ *\n+ * IMPORTANT\n+ * The tests that are incompatible with agent should be placed\n+ * into ProblemList-jvmti-stress-agent.txt with 000000 bug.\n+ *\n+ * Test supports 2 modes:\n+ *   - standard, where the agent doesn't require debugging capabilities\n+ *   - debug, where the agent additionally test debug-related functionality\n+ *   The debug mode is incompatible with debugger tests and debug jvmti tests.\n+ *   The standard mode should be compatible with all tests except problemlisted.\n+ *\n+ *   The JVMTI agent starts jvmti agent tread that enable\/disable different\n+ *   events and call different jvmti functions concurrently with test execution.\n+ *\n+ *   The main requirement is to don't change test behaviour.\n+ *\n+ *\/\n+\n+#define JVMTI_AGENT_NAME \"JvmtiStressAgent\"\n+\n+\/* Global settings and some statistics counters *\/\n+typedef struct {\n+\n+  \/* Verbose logging support *\/\n+  jboolean is_verbose;\n+\n+  \/* If debugging functionality could be used. Set from agent args.*\/\n+  jboolean is_debugger_enabled;\n+\n+  \/* Monitor and flags to synchronize agent completion.*\/\n+  jrawMonitorID finished_lock;\n+  volatile jboolean request_agent_thread_stop;\n+  volatile jboolean is_agent_finished;\n+\n+  \/* Some settings configured in gdata_init(). *\/\n+\n+  \/* If agent enabled or not. *\/\n+  jboolean is_tracing_enabled;\n+\n+  \/* If events testing is enabled. *\/\n+  jboolean are_events_enabled;\n+\n+  \/* If interponly and frequent events testing is enabled. *\/\n+  jboolean are_frequent_events_enabled;\n+\n+  \/* Should we iterate heap *\/\n+  jboolean is_heap_iterate_enabled;\n+\n+  \/* Is Heap sampling enabled *\/\n+  jboolean is_heap_sampling_enabled;\n+\n+  jint heap_sampling_interval;\n+  jint events_interval;\n+  jint frequent_events_interval;\n+\n+  \/* Excluded events *\/\n+  jint* events_excluded;\n+  jsize events_excluded_size;\n+\n+  \/* Event statistics *\/\n+\n+  \/* The counters are racy intentionally to avoid synchronization. *\/\n+  jlong cbBreakpoint;\n+  jlong cbClassFileLoadHook;\n+  jlong cbClassLoad;\n+  jlong cbClassPrepare;\n+  jlong cbCompiledMethodLoad;\n+  jlong cbCompiledMethodUnload;\n+  jlong cbDataDumpRequest;\n+  jlong cbDynamicCodeGenerated;\n+  jlong cbException;\n+  jlong cbExceptionCatch;\n+  jlong cbFieldAccess;\n+  jlong cbFieldModification;\n+  jlong cbFramePop;\n+  jlong cbGarbageCollectionFinish;\n+  jlong cbGarbageCollectionStart;\n+  jlong cbMethodEntry;\n+  jlong cbMethodExit;\n+  jlong cbMonitorContendedEnter;\n+  jlong cbMonitorContendedEntered;\n+  jlong cbMonitorWait;\n+  jlong cbMonitorWaited;\n+  jlong cbNativeMethodBind;\n+  jlong cbObjectFree;\n+  jlong cbResourceExhausted;\n+  jlong cbSampledObjectAlloc;\n+  jlong cbSingleStep;\n+  jlong cbThreadEnd;\n+  jlong cbThreadStart;\n+  jlong cbVirtualThreadEnd;\n+  jlong cbVirtualThreadStart;\n+  jlong cbVMDeath;\n+  jlong cbVMInit;\n+  jlong cbVMObjectAlloc;\n+\n+  \/* Inspector statistics are intentionally racy. *\/\n+  jlong inspectedMethods;\n+  jlong inspectedVariables;\n+\n+  \/* File for debug output, agent shouldn't write into stdout. *\/\n+  FILE* log_file;\n+} GlobalData;\n+\n+GlobalData *gdata;\n+\n+static GlobalData*\n+gdata_init(jboolean is_debugger_enabled, jboolean is_verbose) {\n+  static GlobalData data;\n+  (void) memset(&data, 0, sizeof (GlobalData));\n+\n+  data.is_debugger_enabled = is_debugger_enabled;\n+  data.is_verbose = is_verbose;\n+\n+  data.request_agent_thread_stop = JNI_FALSE;\n+  data.is_agent_finished = JNI_FALSE;\n+\n+  \/* Set jvmti stress properties *\/\n+  data.heap_sampling_interval = 1000;\n+  data.frequent_events_interval = 10;\n+\n+  data.is_tracing_enabled = JNI_TRUE;\n+  data.are_events_enabled = JNI_TRUE;\n+  data.are_frequent_events_enabled = JNI_TRUE;\n+  \/\/ disabled so far\n+  data.is_heap_iterate_enabled = JNI_FALSE;\n+  data.is_heap_sampling_enabled = JNI_FALSE;\n+\n+\n+  if (data.is_debugger_enabled) {\n+    data.events_excluded_size = 0;\n+    data.events_excluded = nullptr;\n+  } else {\n+    data.events_excluded_size = 4;\n+    data.events_excluded = new jint[4] {\n+      JVMTI_EVENT_BREAKPOINT,\n+      JVMTI_EVENT_FIELD_ACCESS,\n+      JVMTI_EVENT_FIELD_MODIFICATION,\n+      JVMTI_EVENT_SAMPLED_OBJECT_ALLOC,\n+    };\n+  }\n+  if (data.is_verbose) {\n+    data.log_file = fopen(\"JvmtiStressAgent.out\", \"w\");\n+  }\n+\n+  return &data;\n+}\n+\n+void\n+gdata_close() {\n+  free(gdata->events_excluded);\n+  if (gdata->is_verbose) {\n+    fclose(gdata->log_file);\n+  }\n+}\n+\n+\/\/ Internal buffer length for all messages\n+#define MESSAGE_LIMIT 16384\n+\n+void\n+debug(const char* format, ...) {\n+  if (!gdata->is_verbose) {\n+    return;\n+  }\n+  char dest[MESSAGE_LIMIT];\n+  va_list argptr;\n+  va_start(argptr, format);\n+  vsnprintf(dest, MESSAGE_LIMIT, format, argptr);\n+  va_end(argptr);\n+  \/\/ Enable if needed, tests might fail with unexpected output\n+  \/\/printf(\"%s\\n\", dest);\n+  fprintf(gdata->log_file, \"%s\\n\", dest);\n+  fflush(gdata->log_file);\n+}\n+\n+\/* Some helper functions to start\/stop jvmti stress agent thread. *\/\n+void\n+check_jni_exception(JNIEnv *jni, const char *message) {\n+  jobject exception = jni->ExceptionOccurred();\n+  if (exception != nullptr) {\n+    jni->ExceptionDescribe();\n+    fatal(jni, message);\n+  }\n+}\n+\n+jclass\n+find_class(JNIEnv *jni, const char *name) {\n+  char message[MESSAGE_LIMIT];\n+  jclass clazz = jni->FindClass(name);\n+  snprintf(message, MESSAGE_LIMIT, \"Failed to find class %s.\", name);\n+  check_jni_exception(jni, message);\n+  return clazz;\n+}\n+\n+jmethodID\n+get_method_id(JNIEnv *jni, jclass clazz, const char *name, const char *sig) {\n+  char message[MESSAGE_LIMIT];\n+  jmethodID method = jni->GetMethodID(clazz, name, sig);\n+  snprintf(message, MESSAGE_LIMIT, \"Failed to find method %s.\", name);\n+  check_jni_exception(jni, message);\n+  return method;\n+}\n+\n+void\n+create_agent_thread(jvmtiEnv *jvmti, JNIEnv *jni, const char *name, jvmtiStartFunction func) {\n+\n+  check_jni_exception(jni, \"JNIException before creating Agent Thread.\");\n+  jclass clazz = find_class(jni, \"java\/lang\/Thread\");\n+  jmethodID thread_ctor = get_method_id(jni, clazz, \"<init>\",\n+                                    \"(Ljava\/lang\/String;)V\");\n+\n+  jstring name_utf = jni->NewStringUTF(name);\n+  check_jni_exception(jni, \"Error creating utf name of thread.\");\n+\n+  jthread thread = jni->NewObject(clazz, thread_ctor, name_utf);\n+  check_jni_exception(jni, \"Error during instantiation of Thread object.\");\n+  jvmtiError err = jvmti->RunAgentThread(\n+                     thread, func, nullptr, JVMTI_THREAD_NORM_PRIORITY);\n+  check_jvmti_status(jni, err, \"RunAgentThread\");\n+}\n+\n+\/*\n+ * The method blocks execution until agent thread finishes.\n+ * Should be executed during VMDeath to don't run JVMTI functionality\n+ * during dead phase.\n+ *\/\n+void\n+request_agent_thread_stop_and_wait(jvmtiEnv *jvmti, JNIEnv *jni) {\n+  RawMonitorLocker rml(jvmti, jni, gdata->finished_lock);\n+  gdata->request_agent_thread_stop = JNI_TRUE;\n+  while (!gdata->is_agent_finished) {\n+    rml.wait(1000);\n+  }\n+  debug(\"Native agent stopped\");\n+}\n+\n+\/*\n+ * The method is called by agent thread to ensure that thread correctly exits.\n+ *\/\n+static jboolean\n+should_stop(jvmtiEnv *jvmti, JNIEnv *jni) {\n+  jboolean should_stop = JNI_FALSE;\n+  RawMonitorLocker rml(jvmti, jni, gdata->finished_lock);\n+  should_stop = gdata->request_agent_thread_stop;\n+  if (should_stop == JNI_TRUE) {\n+    gdata->is_agent_finished = JNI_TRUE;\n+    rml.notify_all();\n+  }\n+  return should_stop;\n+}\n+\n+\/*\n+ * Agent stress functions. The agent is stopped in VMDeath only and should be\n+ * always ready to get JVMTI_ERROR_THREAD_NOT_ALIVE error.\n+ *\/\n+\n+\/* Read stack, frames, method, variables, etc. *\/\n+static void\n+walk_stack(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  debug(\"In walk_stack: %p\", thread);\n+\n+  jvmtiFrameInfo frames[5];\n+  jint count = 0;\n+  err = jvmti->GetStackTrace(thread, 0, 5, frames, &count);\n+  if (err == JVMTI_ERROR_THREAD_NOT_ALIVE || err == JVMTI_ERROR_WRONG_PHASE) {\n+    return;\n+  }\n+  check_jvmti_error(err, \"GetStackTrace\");\n+\n+  debug(\"Stack depth: %d\", count);\n+\n+  for (int frame_index = 0; frame_index < count; frame_index++) {\n+    char *method_name = nullptr;\n+    jint method_modifiers = 0;\n+    err = jvmti->GetMethodName(frames[frame_index].method, &method_name, nullptr, nullptr);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_status(jni, err, \"GetMethodName\");\n+\n+    err = jvmti->GetMethodModifiers(frames[frame_index].method, &method_modifiers);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_status(jni, err, \"GetMethodModifiers\");\n+\n+    debug(\"Inspecting method: %s, %d\", method_name, method_modifiers);\n+    deallocate(jvmti, jni, method_name);\n+\n+    jvmtiLocalVariableEntry* table = nullptr;\n+    jint entry_count = 0;\n+    err = jvmti->GetLocalVariableTable(frames[frame_index].method, &entry_count, &table);\n+    if (err == JVMTI_ERROR_NATIVE_METHOD || err == JVMTI_ERROR_ABSENT_INFORMATION\n+            || err == JVMTI_ERROR_WRONG_PHASE) {\n+      continue;\n+    }\n+    check_jvmti_status(jni, err, \"GetLocalVariableTable\");\n+\n+    gdata->inspectedMethods += 1;\n+    gdata->inspectedVariables += entry_count;\n+\n+    debug(\"Variables: \");\n+    for (int cnt = 0; cnt < entry_count; cnt++) {\n+      debug(\" %s  %d\", table[cnt].name, table[cnt].slot);\n+      deallocate(jvmti, jni, table[cnt].name);\n+      deallocate(jvmti, jni, table[cnt].signature);\n+      deallocate(jvmti, jni, table[cnt].generic_signature);\n+    }\n+    deallocate(jvmti, jni, table);\n+  }\n+  debug(\"---- End of stack inspection %d -----\", count);\n+}\n+\n+\/* Iterate with walk_stack through all thread. *\/\n+static void JNICALL\n+walk_all_threads_stacks(jvmtiEnv *jvmti, JNIEnv *jni) {\n+    jint threads_count = 0;\n+    jthread *threads = nullptr;\n+    jvmtiError err = JVMTI_ERROR_NONE;\n+    debug(\"Inspect:  Starting cycle...\");\n+    err = jvmti->GetAllThreads(&threads_count, &threads);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_status(jni, err, \"GetAllThreads\");\n+    for (int t = 0; t < (int)threads_count; t++) {\n+      jvmtiThreadInfo info;\n+      debug(\"Inspecting thread num %d at addr [%p]\",t, threads[t]);\n+      err = jvmti->GetThreadInfo(threads[t], &info);\n+      if (err == JVMTI_ERROR_WRONG_PHASE) {\n+        return;\n+      }\n+      check_jvmti_status(jni, err, \"GetThreadInfo\");\n+      \/\/ Skip agent thread itself and JFR threads to avoid potential deadlocks\n+      if (strstr(info.name, JVMTI_AGENT_NAME) == nullptr\n+          && strstr(info.name, \"JFR\") == nullptr) {\n+        \/\/ The non-intrusive actions are allowed to ensure that results of target\n+        \/\/ thread are not affected.\n+        jthread thread = threads[t];\n+        walk_stack(jvmti, jni, thread);\n+\n+        \/\/ Suspend\/resume are solo capabilities and are treated like debugging\n+        if (gdata->is_debugger_enabled) {\n+          debug(\"Inspect: Trying to suspend thread %s\", info.name);\n+          err = jvmti->SuspendThread(thread);\n+          if (err == JVMTI_ERROR_WRONG_PHASE) {\n+            return;\n+          }\n+          if (err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+            debug(\"Inspect:  thread %s is not alive. Skipping.\", info.name);\n+            continue;\n+          }\n+          check_jvmti_status(jni, err, \"SuspendThread\");\n+          debug(\"Inspect:  Suspended thread %s\", info.name);\n+\n+          walk_stack(jvmti, jni, thread);\n+\n+          debug(\"Inspect: Trying to resume thread %s\", info.name);\n+          err = jvmti->ResumeThread(thread);\n+          if (err == JVMTI_ERROR_WRONG_PHASE) {\n+            return;\n+          }\n+          check_jvmti_status(jni, err, \"ResumeThread\");\n+          debug(\"Inspect:  Resumed thread %s\", info.name);\n+        }\n+\n+      }\n+      deallocate(jvmti, jni, info.name);\n+      jni->DeleteLocalRef(info.thread_group);\n+      jni->DeleteLocalRef(info.context_class_loader);\n+      jni->DeleteLocalRef(threads[t]);\n+    }\n+    deallocate(jvmti, jni, threads);\n+}\n+\n+\/* Heap inspection helpers. *\/\n+static jint JNICALL\n+heap_iteration_callback(jlong class_tag, jlong size, jlong* tag_ptr, jint length, void* user_data) {\n+  int* count = (int*) user_data;\n+  *count += 1;\n+  return JVMTI_VISIT_OBJECTS;\n+}\n+\n+static jint\n+get_heap_info(jvmtiEnv *jvmti, JNIEnv *jni, jclass klass) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  int count = 0;\n+  jvmtiHeapCallbacks callbacks;\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  callbacks.heap_iteration_callback = &heap_iteration_callback;\n+  err = jvmti->IterateThroughHeap(0, klass, &callbacks, &count);\n+  if (err == JVMTI_ERROR_WRONG_PHASE) {\n+    return count;\n+  }\n+  check_jvmti_status(jni, err, \"IterateThroughHeap\");\n+  return count;\n+}\n+\n+\n+\/*\n+ * Events testing helper functions.\n+ *\/\n+\n+\n+int\n+is_event_frequent(int event) {\n+  \/\/ Should include all interpreter-only events and all frequent events.\n+  return event == JVMTI_EVENT_SINGLE_STEP\n+      || event == JVMTI_EVENT_METHOD_ENTRY\n+      || event == JVMTI_EVENT_METHOD_EXIT\n+      || event == JVMTI_EVENT_FRAME_POP\n+      || event == JVMTI_EVENT_FIELD_ACCESS\n+      || event == JVMTI_EVENT_FIELD_MODIFICATION\n+      || event == JVMTI_EVENT_EXCEPTION_CATCH\n+      || event == JVMTI_EVENT_EXCEPTION\n+  ;\n+}\n+\n+int\n+is_event_excluded(int event) {\n+  for (int i = 0; i < gdata->events_excluded_size; i++) {\n+    if (event == gdata->events_excluded[i]) {\n+      return JNI_TRUE;\n+    }\n+  }\n+  return JNI_FALSE;\n+}\n+\n+static void\n+enable_events(jvmtiEnv *jvmti, jboolean update_frequent_events) {\n+ debug(\"Enabling events\\n\");\n+  for(int event = JVMTI_MIN_EVENT_TYPE_VAL; event < JVMTI_MAX_EVENT_TYPE_VAL; event++) {\n+    if (is_event_excluded(event)) {\n+      debug(\"Event %d excluded.\", event);\n+      continue;\n+    }\n+    if (is_event_frequent(event) != update_frequent_events ) {\n+      debug(\"Event %d is not enabled as frequent\/slow.\", event);\n+      continue;\n+    }\n+    jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+        static_cast<jvmtiEvent>(event), nullptr);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_error(err, \"SetEventNotificationMode\");\n+  }\n+  debug(\"Enabling events done\\n\");\n+}\n+\n+static void\n+enable_frequent_events(jvmtiEnv *jvmti) {\n+  enable_events(jvmti, JNI_TRUE);\n+}\n+\n+static void\n+enable_common_events(jvmtiEnv *jvmti) {\n+  enable_events(jvmti,JNI_FALSE);\n+}\n+\n+\n+static void\n+disable_all_events(jvmtiEnv *jvmti) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  for (int event = JVMTI_MIN_EVENT_TYPE_VAL; event < JVMTI_MAX_EVENT_TYPE_VAL; event++) {\n+    \/\/ VM_DEATH is used to stop agent\n+    if (event == JVMTI_EVENT_VM_DEATH) {\n+      continue;\n+    }\n+    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, static_cast<jvmtiEvent>(event), nullptr);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_error(err, \"SetEventNotificationMode\");\n+  }\n+}\n+\n+\/*\n+ * The JVMTI agent main loop.\n+ *\/\n+\n+static void JNICALL\n+stress_agent(jvmtiEnv *jvmti, JNIEnv *jni, void *p) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  debug(\"Debugger: Thread started.\");\n+  while (!should_stop(jvmti, jni)) {\n+\n+    if (gdata->are_events_enabled) {\n+      enable_common_events(jvmti);\n+    }\n+\n+    \/\/ Iterate through heap and get some statistics\n+    if (gdata->is_heap_iterate_enabled) {\n+      jclass kls = find_class(jni, \"java\/lang\/String\");\n+      jlong obj_count = get_heap_info(jvmti, jni, kls);\n+      debug(\"Debugger: Heap info: %d\", obj_count);\n+    }\n+\n+\n+    \/\/ requires can_generate_sampled_object_alloc_events\n+    \/\/ which is solo capability\n+    if (gdata->is_heap_sampling_enabled) {\n+      err = jvmti->SetHeapSamplingInterval(gdata->heap_sampling_interval);\n+      if (err == JVMTI_ERROR_WRONG_PHASE) {\n+        return;\n+      }\n+      check_jvmti_status(jni, err, \"SetHeapSamplingInterval\");\n+    }\n+\n+    if (gdata->is_tracing_enabled) {\n+      walk_all_threads_stacks(jvmti, jni);\n+    }\n+\n+    sleep_ms(gdata->events_interval);\n+\n+    err = jvmti->SetHeapSamplingInterval(0);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    if (gdata->is_heap_sampling_enabled) {\n+      check_jvmti_status(jni, err, \"SetHeapSamplingInterval\");\n+    }\n+\n+    if (gdata->are_frequent_events_enabled) {\n+      enable_frequent_events(jvmti);\n+      sleep_ms(gdata->frequent_events_interval);\n+    }\n+    disable_all_events(jvmti);\n+    sleep_ms(gdata->events_interval);\n+  }\n+  debug(\"Debugger: Thread finished.\");\n+}\n+\n+\n+\/*\n+ *  Events section.\n+ *  Most of the events just increase counter and print debug info.\n+ *  The VMInit\/VMDeath are also start and stop jvmti stress agent.\n+ *\/\n+\n+static void\n+register_event(jlong *event) {\n+  (*event)++;\n+}\n+\n+static void JNICALL\n+cbVMInit(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbVMInit);\n+  debug(\"Event cbVMInit\\n\");\n+  create_agent_thread(jvmti, jni, JVMTI_AGENT_NAME, &stress_agent);\n+}\n+\n+static void JNICALL\n+cbVMDeath(jvmtiEnv *jvmti, JNIEnv *jni) {\n+  register_event(&gdata->cbVMDeath);\n+  debug(\"Event cbVMDeath\\n\");\n+  request_agent_thread_stop_and_wait(jvmti, jni);\n+  destroy_raw_monitor(jvmti, jni, gdata->finished_lock);\n+}\n+\n+static void JNICALL\n+cbThreadStart(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadStart);\n+  debug(\"Event cbThreadStart\\n\");\n+}\n+\n+static void JNICALL\n+cbThreadEnd(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadEnd);\n+  debug(\"Event cbThreadEnd\\n\");\n+}\n+\n+static void JNICALL\n+cbVirtualThreadStart(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadStart);\n+  debug(\"Event cbThreadStart\\n\");\n+}\n+\n+static void JNICALL\n+cbVirtualThreadEnd(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadEnd);\n+  debug(\"Event cbThreadEnd\\n\");\n+}\n+\n+static void JNICALL\n+cbClassFileLoadHook(jvmtiEnv *jvmti, JNIEnv* jni,\n+                    jclass class_being_redefined, jobject loader,\n+                    const char* name, jobject protection_domain,\n+                    jint class_data_len, const unsigned char *class_data,\n+                    jint *new_class_data_len, unsigned char **new_class_data) {\n+  \/* TODO uncomment for more stress\n+  unsigned char* new_class_data_copy = (unsigned char*) malloc(class_data_len);\n+  memcpy(new_class_data_copy, class_data, class_data_len);\n+  *new_class_data_len = class_data_len;\n+  *new_class_data = new_class_data_copy;\n+  *\/\n+  register_event(&gdata->cbClassFileLoadHook);\n+  debug(\"Event cbClassFileLoadHook\\n\");\n+}\n+\n+static void JNICALL\n+cbClassLoad(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jclass klass) {\n+  register_event(&gdata->cbClassLoad);\n+  debug(\"Event cbClassLoad\\n\");\n+}\n+\n+static void JNICALL\n+cbClassPrepare(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jclass klass) {\n+  register_event(&gdata->cbClassPrepare);\n+  debug(\"Event cbClassPrepare\\n\");\n+}\n+\n+static void JNICALL\n+cbDataDumpRequest(jvmtiEnv *jvmti) {\n+  register_event(&gdata->cbDataDumpRequest);\n+  debug(\"Event cbDataDumpRequest\\n\");\n+}\n+\n+static void JNICALL\n+cbException(jvmtiEnv *jvmti,\n+            JNIEnv *jni,\n+            jthread thread,\n+            jmethodID method,\n+            jlocation location,\n+            jobject exception,\n+            jmethodID catch_method,\n+            jlocation catch_location) {\n+  register_event(&gdata->cbException);\n+  debug(\"Event cbException\\n\");\n+}\n+\n+static void JNICALL\n+cbExceptionCatch(jvmtiEnv *jvmti, JNIEnv *jni,\n+                 jthread thread, jmethodID method, jlocation location,\n+                 jobject exception) {\n+  register_event(&gdata->cbExceptionCatch);\n+  debug(\"Event cbExceptionCatch\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorWait(jvmtiEnv *jvmti, JNIEnv *jni,\n+              jthread thread, jobject object, jlong timeout) {\n+  register_event(&gdata->cbMonitorWait);\n+  debug(\"Event cbMonitorWait\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorWaited(jvmtiEnv *jvmti, JNIEnv *jni,\n+                jthread thread, jobject object, jboolean timed_out) {\n+  register_event(&gdata->cbMonitorWaited);\n+  debug(\"Event cbMonitorWaited\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorContendedEnter(jvmtiEnv *jvmti, JNIEnv *jni,\n+                        jthread thread, jobject object) {\n+  register_event(&gdata->cbMonitorContendedEnter);\n+  debug(\"Event cbMonitorContendedEnter\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorContendedEntered(jvmtiEnv *jvmti, JNIEnv* jni,\n+                          jthread thread, jobject object) {\n+  register_event(&gdata->cbMonitorContendedEntered);\n+  debug(\"Event cbMonitorContendedEntered\\n\");\n+}\n+\n+static void JNICALL\n+cbGarbageCollectionStart(jvmtiEnv *jvmti) {\n+  register_event(&gdata->cbGarbageCollectionStart);\n+  debug(\"Event cbGarbageCollectionStart\\n\");\n+}\n+\n+static void JNICALL\n+cbGarbageCollectionFinish(jvmtiEnv *jvmti) {\n+  register_event(&gdata->cbGarbageCollectionFinish);\n+  debug(\"Event cbGarbageCollectionFinish\\n\");\n+}\n+\n+static void JNICALL\n+cbObjectFree(jvmtiEnv *jvmti, jlong tag) {\n+  register_event(&gdata->cbObjectFree);\n+  debug(\"Event cbObjectFree\\n\");\n+}\n+\n+static void JNICALL\n+cbBreakpoint(jvmtiEnv *jvmti,\n+             JNIEnv *jni,\n+             jthread thread,\n+             jmethodID method,\n+             jlocation location) {\n+  register_event(&gdata->cbBreakpoint);\n+  debug(\"Event cbBreakpoint\\n\");\n+}\n+\n+static void JNICALL\n+cbSingleStep(jvmtiEnv *jvmti,\n+             JNIEnv *jni,\n+             jthread thread,\n+             jmethodID method,\n+             jlocation location) {\n+  register_event(&gdata->cbSingleStep);\n+  debug(\"Event cbSingleStep\\n\");\n+}\n+\n+static void JNICALL\n+cbFieldAccess(jvmtiEnv *jvmti,\n+              JNIEnv *jni,\n+              jthread thread,\n+              jmethodID method,\n+              jlocation location,\n+              jclass field_klass,\n+              jobject object,\n+              jfieldID field) {\n+  register_event(&gdata->cbFieldAccess);\n+  debug(\"Event cbFieldAccess\\n\");\n+}\n+\n+static void JNICALL\n+cbFieldModification(jvmtiEnv *jvmti,\n+                    JNIEnv *jni,\n+                    jthread thread,\n+                    jmethodID method,\n+                    jlocation location,\n+                    jclass field_klass,\n+                    jobject object,\n+                    jfieldID field,\n+                    char signature_type,\n+                    jvalue new_value) {\n+  register_event(&gdata->cbFieldModification);\n+  debug(\"Event cbFieldModification\\n\");\n+}\n+\n+static void JNICALL\n+cbFramePop(jvmtiEnv *jvmti,\n+           JNIEnv *jni,\n+           jthread thread,\n+           jmethodID method,\n+           jboolean was_popped_by_exception) {\n+  register_event(&gdata->cbFramePop);\n+  debug(\"Event cbFramePop\\n\");\n+}\n+\n+static void JNICALL\n+cbMethodEntry(jvmtiEnv *jvmti,\n+              JNIEnv *jni,\n+              jthread thread,\n+              jmethodID method) {\n+  register_event(&gdata->cbMethodEntry);\n+  debug(\"Event cbMethodEntry\\n\");\n+}\n+\n+static void JNICALL\n+cbMethodExit(jvmtiEnv *jvmti,\n+             JNIEnv *jni,\n+             jthread thread,\n+             jmethodID method,\n+             jboolean was_popped_by_exception,\n+             jvalue return_value) {\n+  register_event(&gdata->cbMethodExit);\n+  debug(\"Event cbMethodExit\\n\");\n+}\n+\n+static void JNICALL\n+cbNativeMethodBind(jvmtiEnv *jvmti,\n+                   JNIEnv *jni,\n+                   jthread thread,\n+                   jmethodID method,\n+                   void* address,\n+                   void** new_address_ptr) {\n+  register_event(&gdata->cbNativeMethodBind);\n+  debug(\"Event cbNativeMethodBind\\n\");\n+}\n+\n+static void JNICALL\n+cbCompiledMethodLoad(jvmtiEnv *jvmti,\n+                     jmethodID method,\n+                     jint code_size,\n+                     const void* code_addr,\n+                     jint map_length,\n+                     const jvmtiAddrLocationMap* map,\n+                     const void* compile_info) {\n+  register_event(&gdata->cbCompiledMethodLoad);\n+  debug(\"Event cbCompiledMethodLoad\\n\");\n+}\n+\n+static void JNICALL\n+cbCompiledMethodUnload(jvmtiEnv *jvmti,\n+                       jmethodID method,\n+                       const void* code_addr) {\n+  register_event(&gdata->cbCompiledMethodUnload);\n+  debug(\"Event cbCompiledMethodUnload\\n\");\n+}\n+\n+static void JNICALL\n+cbDynamicCodeGenerated(jvmtiEnv *jvmti,\n+                       const char* name,\n+                       const void* address,\n+                       jint length) {\n+  register_event(&gdata->cbDynamicCodeGenerated);\n+  debug(\"Event cbDynamicCodeGenerated\\n\");\n+}\n+\n+static void JNICALL\n+cbResourceExhausted(jvmtiEnv *jvmti,\n+                    JNIEnv *jni,\n+                    jint flags,\n+                    const void* reserved,\n+                    const char* description) {\n+  register_event(&gdata->cbResourceExhausted);\n+  debug(\"Event cbResourceExhausted\\n\");\n+}\n+\n+static void JNICALL\n+cbVMObjectAlloc(jvmtiEnv *jvmti,\n+                JNIEnv *jni,\n+                jthread thread,\n+                jobject object,\n+                jclass object_klass,\n+                jlong size) {\n+  register_event(&gdata->cbVMObjectAlloc);\n+  debug(\"Event cbVMObjectAlloc\\n\");\n+}\n+\n+static void JNICALL\n+cbSampledObjectAlloc(jvmtiEnv *jvmti,\n+                     JNIEnv *jni,\n+                     jthread thread,\n+                     jobject object,\n+                     jclass object_klass,\n+                     jlong size) {\n+  register_event(&gdata->cbSampledObjectAlloc);\n+  debug(\"Event cbSampledObjectAlloc\\n\");\n+}\n+\n+\n+\n+static void\n+set_callbacks(jvmtiEnv *jvmti, jboolean on) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiEventCallbacks callbacks;\n+\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  if (on == JNI_FALSE) {\n+    err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+    check_jvmti_error(err, \"SetEventCallbacks\");\n+    return;\n+  }\n+  callbacks.Breakpoint = &cbBreakpoint;\n+  callbacks.ClassFileLoadHook = &cbClassFileLoadHook;\n+  callbacks.ClassLoad = &cbClassLoad;\n+  callbacks.ClassPrepare = &cbClassPrepare;\n+  callbacks.CompiledMethodLoad = &cbCompiledMethodLoad;\n+  callbacks.CompiledMethodUnload = &cbCompiledMethodUnload;\n+  callbacks.DataDumpRequest = &cbDataDumpRequest;\n+  callbacks.DynamicCodeGenerated = &cbDynamicCodeGenerated;\n+  callbacks.Exception = &cbException;\n+  callbacks.ExceptionCatch = &cbExceptionCatch;\n+  callbacks.FieldAccess = &cbFieldAccess;\n+  callbacks.FieldModification = &cbFieldModification;\n+  callbacks.FramePop = &cbFramePop;\n+  callbacks.GarbageCollectionFinish = &cbGarbageCollectionFinish;\n+  callbacks.GarbageCollectionStart = &cbGarbageCollectionStart;\n+  callbacks.MethodEntry = &cbMethodEntry;\n+  callbacks.MethodExit = &cbMethodExit;\n+  callbacks.MonitorContendedEnter = &cbMonitorContendedEnter;\n+  callbacks.MonitorContendedEntered = &cbMonitorContendedEntered;\n+  callbacks.MonitorWait = &cbMonitorWait;\n+  callbacks.MonitorWaited = &cbMonitorWaited;\n+  callbacks.NativeMethodBind = &cbNativeMethodBind;\n+  callbacks.ObjectFree = &cbObjectFree;\n+  callbacks.ResourceExhausted = &cbResourceExhausted;\n+  callbacks.SampledObjectAlloc = &cbSampledObjectAlloc;\n+  callbacks.SingleStep = &cbSingleStep;\n+  callbacks.ThreadEnd = &cbThreadEnd;\n+  callbacks.ThreadStart = &cbThreadStart;\n+  callbacks.VirtualThreadEnd = &cbVirtualThreadEnd;\n+  callbacks.VirtualThreadStart = &cbVirtualThreadStart;\n+  callbacks.VMDeath = &cbVMDeath;\n+  callbacks.VMInit = &cbVMInit;\n+  callbacks.VMObjectAlloc = &cbVMObjectAlloc;\n+  err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+}\n+\n+static\n+void get_capabilities(jvmtiEnv *jvmti) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiCapabilities capabilities;\n+  (void) memset(&capabilities, 0, sizeof (capabilities));\n+  err = jvmti->GetPotentialCapabilities(&capabilities);\n+\n+  if (!gdata->is_debugger_enabled) {\n+    \/\/init_always_solo_capabilities\n+    capabilities.can_suspend = false;\n+\n+    \/\/ onload_solo\n+    capabilities.can_generate_breakpoint_events = false;\n+    capabilities.can_generate_field_access_events = false;\n+    capabilities.can_generate_field_modification_events = false;\n+  }\n+\n+  capabilities.can_generate_early_vmstart = false;\n+\n+  check_jvmti_error(err, \"GetPotentialCapabilities\");\n+  err = jvmti->AddCapabilities(&capabilities);\n+  check_jvmti_error(err, \"AddCapabilities\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti = nullptr;\n+  jint res = vm->GetEnv((void **) &jvmti, JVMTI_VERSION_21);\n+  if (res != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+\n+  jboolean is_debugger_enabled = JNI_TRUE;\n+  jboolean is_verbose = JNI_FALSE;\n+\n+  if (options != nullptr) {\n+    char *opts = strdup(options);\n+    char *token = strtok(opts, \",\");\n+\n+    while (token != nullptr) {\n+      if (strncmp(token, \"debugger=\", 9) == 0) {\n+        if (strcmp(token + 9, \"true\") == 0) {\n+          is_debugger_enabled = JNI_TRUE;\n+        } else {\n+          is_debugger_enabled = JNI_FALSE;\n+        }\n+      }\n+      if (strncmp(token, \"verbose\", 7) == 0) {\n+        is_verbose = JNI_TRUE;\n+      }\n+      token = strtok(nullptr, \",\");\n+    }\n+    free(opts);\n+  }\n+  gdata = gdata_init(is_debugger_enabled, is_verbose);\n+  get_capabilities(jvmti);\n+  gdata->finished_lock = create_raw_monitor(jvmti, \"Finished lock\");\n+  set_callbacks(jvmti, JNI_TRUE);\n+  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+    JVMTI_EVENT_VM_INIT, nullptr);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Agent_OnUnload(JavaVM *vm) {\n+  if (!gdata->request_agent_thread_stop) {\n+    printf(\"Agent_OnUnload happened before requested stop.\\n\");\n+  }\n+  gdata_close();\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/libJvmtiStressAgent.cpp","additions":987,"deletions":0,"binary":false,"changes":987,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n-    private static final String OPENSSL_BUNDLE_VERSION = \"3.0.14\";\n+    private static final String OPENSSL_BUNDLE_VERSION = \"3.5.1\";\n","filename":"test\/lib\/jdk\/test\/lib\/security\/OpensslArtifactFetcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (byte)(2*i));\n-        b = fill(i -> (byte)(i+1));\n-        c = fill(i -> (byte)(i+5));\n-        r = fill(i -> (byte)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -955,0 +957,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1205,0 +1271,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1429,0 +1540,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1491,0 +1666,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte128Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (byte)(2*i));\n-        b = fill(i -> (byte)(i+1));\n-        c = fill(i -> (byte)(i+5));\n-        r = fill(i -> (byte)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -955,0 +957,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1205,0 +1271,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1429,0 +1540,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1491,0 +1666,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte256Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (byte)(2*i));\n-        b = fill(i -> (byte)(i+1));\n-        c = fill(i -> (byte)(i+5));\n-        r = fill(i -> (byte)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -955,0 +957,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1205,0 +1271,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1429,0 +1540,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1491,0 +1666,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte512Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (byte)(2*i));\n-        b = fill(i -> (byte)(i+1));\n-        c = fill(i -> (byte)(i+5));\n-        r = fill(i -> (byte)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -955,0 +957,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1205,0 +1271,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1429,0 +1540,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1491,0 +1666,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte64Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (byte)(2*i));\n-        b = fill(i -> (byte)(i+1));\n-        c = fill(i -> (byte)(i+5));\n-        r = fill(i -> (byte)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -955,0 +957,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1205,0 +1271,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1429,0 +1540,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1491,0 +1666,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteMaxVector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+    static byte genValue(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -67,4 +71,4 @@\n-        as = fill(i -> (byte)(2*i));\n-        bs = fill(i -> (byte)(i+1));\n-        cs = fill(i -> (byte)(i+5));\n-        rs = fill(i -> (byte)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteScalar.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (double)(2*i));\n-        b = fill(i -> (double)(i+1));\n-        c = fill(i -> (double)(i+5));\n-        r = fill(i -> (double)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -281,0 +283,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double128Vector.java","additions":73,"deletions":7,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (double)(2*i));\n-        b = fill(i -> (double)(i+1));\n-        c = fill(i -> (double)(i+5));\n-        r = fill(i -> (double)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -281,0 +283,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double256Vector.java","additions":73,"deletions":7,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (double)(2*i));\n-        b = fill(i -> (double)(i+1));\n-        c = fill(i -> (double)(i+5));\n-        r = fill(i -> (double)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -281,0 +283,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double512Vector.java","additions":73,"deletions":7,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (double)(2*i));\n-        b = fill(i -> (double)(i+1));\n-        c = fill(i -> (double)(i+5));\n-        r = fill(i -> (double)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -281,0 +283,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double64Vector.java","additions":73,"deletions":7,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (double)(2*i));\n-        b = fill(i -> (double)(i+1));\n-        c = fill(i -> (double)(i+5));\n-        r = fill(i -> (double)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -281,0 +283,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleMaxVector.java","additions":73,"deletions":7,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+    static double genValue(int i) {\n+        return (double) i;\n+    }\n+\n@@ -66,4 +70,4 @@\n-        as = fill(i -> (double)(2*i));\n-        bs = fill(i -> (double)(i+1));\n-        cs = fill(i -> (double)(i+5));\n-        rs = fill(i -> (double)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleScalar.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (float)(2*i));\n-        b = fill(i -> (float)(i+1));\n-        c = fill(i -> (float)(i+5));\n-        r = fill(i -> (float)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -281,0 +283,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float128Vector.java","additions":73,"deletions":7,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (float)(2*i));\n-        b = fill(i -> (float)(i+1));\n-        c = fill(i -> (float)(i+5));\n-        r = fill(i -> (float)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -281,0 +283,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float256Vector.java","additions":73,"deletions":7,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (float)(2*i));\n-        b = fill(i -> (float)(i+1));\n-        c = fill(i -> (float)(i+5));\n-        r = fill(i -> (float)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -281,0 +283,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float512Vector.java","additions":73,"deletions":7,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (float)(2*i));\n-        b = fill(i -> (float)(i+1));\n-        c = fill(i -> (float)(i+5));\n-        r = fill(i -> (float)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -281,0 +283,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float64Vector.java","additions":73,"deletions":7,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -78,6 +82,4 @@\n-\n-        a = fill(i -> (float)(2*i));\n-        b = fill(i -> (float)(i+1));\n-        c = fill(i -> (float)(i+5));\n-        r = fill(i -> (float)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -281,0 +283,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatMaxVector.java","additions":73,"deletions":7,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+    static float genValue(int i) {\n+        return (float) i;\n+    }\n+\n@@ -66,4 +70,4 @@\n-        as = fill(i -> (float)(2*i));\n-        bs = fill(i -> (float)(i+1));\n-        cs = fill(i -> (float)(i+5));\n-        rs = fill(i -> (float)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatScalar.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,750 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Float16;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Halffloat128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float16> SPECIES = HalffloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Float16.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    static short genValue(int i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Halffloat128Vector.java","additions":750,"deletions":0,"binary":false,"changes":750,"status":"added"},{"patch":"@@ -0,0 +1,750 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Float16;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Halffloat256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float16> SPECIES = HalffloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Float16.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    static short genValue(int i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Halffloat256Vector.java","additions":750,"deletions":0,"binary":false,"changes":750,"status":"added"},{"patch":"@@ -0,0 +1,750 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Float16;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Halffloat512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float16> SPECIES = HalffloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Float16.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    static short genValue(int i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Halffloat512Vector.java","additions":750,"deletions":0,"binary":false,"changes":750,"status":"added"},{"patch":"@@ -0,0 +1,750 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Float16;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Halffloat64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float16> SPECIES = HalffloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Float16.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    static short genValue(int i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Halffloat64Vector.java","additions":750,"deletions":0,"binary":false,"changes":750,"status":"added"},{"patch":"@@ -0,0 +1,750 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Float16;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class HalffloatMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float16> SPECIES = HalffloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Float16.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    static short genValue(int i) {\n+        return Float16.float16ToRawShortBits(Float16.valueOf(i));\n+    }\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float16> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/HalffloatMaxVector.java","additions":750,"deletions":0,"binary":false,"changes":750,"status":"added"},{"patch":"@@ -0,0 +1,498 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+import jdk.incubator.vector.VectorMath;\n+\n+import jdk.incubator.vector.Halffloat;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class HalffloatScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static short bits(short e) {\n+        return Halffloat.shortToShortBits(e);\n+    }\n+\n+    short[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    static short genValue(int i) {\n+        return Halffloat.valueOf(i);\n+    }\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RAND.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> as;\n+    final IntFunction<short[]> fb = vl -> bs;\n+    final IntFunction<short[]> fc = vl -> cs;\n+    final IntFunction<short[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(Math.abs(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(Math.abs(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(-a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(-a) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] cs = fc.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                short c = cs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] cs = fc.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                short c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a))));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(Float.floatToFloat16((float) Math.sqrt(Float.float16ToFloat(a)))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/HalffloatScalar.java","additions":498,"deletions":0,"binary":false,"changes":498,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (int)(2*i));\n-        b = fill(i -> (int)(i+1));\n-        c = fill(i -> (int)(i+5));\n-        r = fill(i -> (int)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -1027,0 +1029,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1277,0 +1343,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1501,0 +1612,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1563,0 +1738,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int128Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (int)(2*i));\n-        b = fill(i -> (int)(i+1));\n-        c = fill(i -> (int)(i+5));\n-        r = fill(i -> (int)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -1027,0 +1029,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1277,0 +1343,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1501,0 +1612,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1563,0 +1738,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int256Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (int)(2*i));\n-        b = fill(i -> (int)(i+1));\n-        c = fill(i -> (int)(i+5));\n-        r = fill(i -> (int)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -1027,0 +1029,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1277,0 +1343,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1501,0 +1612,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1563,0 +1738,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int512Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (int)(2*i));\n-        b = fill(i -> (int)(i+1));\n-        c = fill(i -> (int)(i+5));\n-        r = fill(i -> (int)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -1027,0 +1029,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1277,0 +1343,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1501,0 +1612,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1563,0 +1738,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int64Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (int)(2*i));\n-        b = fill(i -> (int)(i+1));\n-        c = fill(i -> (int)(i+5));\n-        r = fill(i -> (int)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -1027,0 +1029,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1277,0 +1343,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1501,0 +1612,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1563,0 +1738,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntMaxVector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+    static int genValue(int i) {\n+        return (int) i;\n+    }\n+\n@@ -67,4 +71,4 @@\n-        as = fill(i -> (int)(2*i));\n-        bs = fill(i -> (int)(i+1));\n-        cs = fill(i -> (int)(i+5));\n-        rs = fill(i -> (int)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntScalar.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (long)(2*i));\n-        b = fill(i -> (long)(i+1));\n-        c = fill(i -> (long)(i+5));\n-        r = fill(i -> (long)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -1027,0 +1029,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1277,0 +1343,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1501,0 +1612,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1563,0 +1738,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long128Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (long)(2*i));\n-        b = fill(i -> (long)(i+1));\n-        c = fill(i -> (long)(i+5));\n-        r = fill(i -> (long)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -1027,0 +1029,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1277,0 +1343,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1501,0 +1612,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1563,0 +1738,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long256Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (long)(2*i));\n-        b = fill(i -> (long)(i+1));\n-        c = fill(i -> (long)(i+5));\n-        r = fill(i -> (long)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -1027,0 +1029,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1277,0 +1343,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1501,0 +1612,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1563,0 +1738,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long512Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (long)(2*i));\n-        b = fill(i -> (long)(i+1));\n-        c = fill(i -> (long)(i+5));\n-        r = fill(i -> (long)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -1027,0 +1029,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1277,0 +1343,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1501,0 +1612,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1563,0 +1738,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long64Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (long)(2*i));\n-        b = fill(i -> (long)(i+1));\n-        c = fill(i -> (long)(i+5));\n-        r = fill(i -> (long)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -1027,0 +1029,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1277,0 +1343,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1501,0 +1612,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1563,0 +1738,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongMaxVector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+    static long genValue(int i) {\n+        return (long) i;\n+    }\n+\n@@ -67,4 +71,4 @@\n-        as = fill(i -> (long)(2*i));\n-        bs = fill(i -> (long)(i+1));\n-        cs = fill(i -> (long)(i+5));\n-        rs = fill(i -> (long)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongScalar.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (short)(2*i));\n-        b = fill(i -> (short)(i+1));\n-        c = fill(i -> (short)(i+5));\n-        r = fill(i -> (short)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -955,0 +957,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1205,0 +1271,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1429,0 +1540,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1491,0 +1666,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short128Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (short)(2*i));\n-        b = fill(i -> (short)(i+1));\n-        c = fill(i -> (short)(i+5));\n-        r = fill(i -> (short)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -955,0 +957,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1205,0 +1271,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1429,0 +1540,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1491,0 +1666,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short256Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (short)(2*i));\n-        b = fill(i -> (short)(i+1));\n-        c = fill(i -> (short)(i+5));\n-        r = fill(i -> (short)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -955,0 +957,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1205,0 +1271,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1429,0 +1540,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1491,0 +1666,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short512Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (short)(2*i));\n-        b = fill(i -> (short)(i+1));\n-        c = fill(i -> (short)(i+5));\n-        r = fill(i -> (short)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -955,0 +957,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1205,0 +1271,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1429,0 +1540,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1491,0 +1666,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short64Vector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -94,6 +98,4 @@\n-\n-        a = fill(i -> (short)(2*i));\n-        b = fill(i -> (short)(i+1));\n-        c = fill(i -> (short)(i+5));\n-        r = fill(i -> (short)0);\n-\n+        a = fill(i -> genValue(2*i));\n+        b = fill(i -> genValue(i+1));\n+        c = fill(i -> genValue(i+5));\n+        r = fill(i -> genValue(0));\n@@ -955,0 +957,64 @@\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1205,0 +1271,45 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n@@ -1429,0 +1540,64 @@\n+    @Benchmark\n+    public void UMINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n@@ -1491,0 +1666,50 @@\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortMaxVector.java","additions":232,"deletions":7,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+    static short genValue(int i) {\n+        return (short) i;\n+    }\n+\n@@ -67,4 +71,4 @@\n-        as = fill(i -> (short)(2*i));\n-        bs = fill(i -> (short)(i+1));\n-        cs = fill(i -> (short)(i+5));\n-        rs = fill(i -> (short)0);\n+        as = fill(i -> genValue(2*i));\n+        bs = fill(i -> genValue(i+1));\n+        cs = fill(i -> genValue(i+5));\n+        rs = fill(i -> genValue(0));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortScalar.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"}]}