{"files":[{"patch":"@@ -369,1 +369,6 @@\n-        VectorMask<E> badMask =\n+        VectorMask<E> badMask = null, badMask2 = null;\n+        if (vectorSpecies().elementType() == Halffloat.class) {\n+            badMask =\n+                iota.compare(GE, iota.broadcast(Float.floatToFloat16((float)indexLimit)));\n+        } else {\n+            badMask =\n@@ -371,0 +376,1 @@\n+        }\n@@ -380,1 +386,5 @@\n-            VectorMask<E> badMask2 =\n+            if (vectorSpecies().elementType() == Halffloat.class) {\n+                badMask2 =\n+                    iota.compare(LT, iota.broadcast(Float.floatToFloat16((float)firstGoodIndex)));\n+            } else {\n+                badMask2 =\n@@ -382,0 +392,1 @@\n+            }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\/\/import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -141,1 +141,1 @@\n-        return bits;\n+        return shortToRawShortBits(bits);\n@@ -154,0 +154,22 @@\n+\n+    \/**\n+       Compares two halffloats\n+     * @param h1 value to be compared\n+     * @param h2 value to be compared\n+     * @return 0, 1, -1\n+    *\/\n+    public static int compare(short h1, short h2) {\n+        float f1 = Float.float16ToFloat(h1);\n+        float f2 = Float.float16ToFloat(h2);\n+        return Float.compare(f1, f2);\n+    }\n+\n+    \/**\n+     * Checks if value is NaN\n+     * @param hf value to be compared\n+     * @return boolean\n+    *\/\n+    public boolean isNaN(Halffloat hf) {\n+        float f1 = hf.floatValue();\n+        return Float.isNaN(f1);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -824,1 +824,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n@@ -826,1 +826,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n@@ -828,1 +828,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n@@ -830,1 +830,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n@@ -832,1 +832,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(),Halffloat.valueOf(b).floatValue())));\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -834,1 +834,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(),Halffloat.valueOf(b).floatValue())));\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -1032,2 +1032,1 @@\n-                    Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(),\n-                    Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+                    Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n@@ -1930,6 +1929,6 @@\n-            case BT_eq -> Halffloat.valueOf(a).floatValue() == Halffloat.valueOf(b).floatValue();\n-            case BT_ne -> Halffloat.valueOf(a).floatValue() != Halffloat.valueOf(b).floatValue();\n-            case BT_lt -> Halffloat.valueOf(a).floatValue() < Halffloat.valueOf(b).floatValue();\n-            case BT_le -> Halffloat.valueOf(a).floatValue() <= Halffloat.valueOf(b).floatValue();\n-            case BT_gt -> Halffloat.valueOf(a).floatValue() > Halffloat.valueOf(b).floatValue();\n-            case BT_ge -> Halffloat.valueOf(a).floatValue() >= Halffloat.valueOf(b).floatValue();\n+            case BT_eq -> Float.float16ToFloat(a) == Float.float16ToFloat(b);\n+            case BT_ne -> Float.float16ToFloat(a) != Float.float16ToFloat(b);\n+            case BT_lt -> Float.float16ToFloat(a) < Float.float16ToFloat(b);\n+            case BT_le -> Float.float16ToFloat(a) <= Float.float16ToFloat(b);\n+            case BT_gt -> Float.float16ToFloat(a) > Float.float16ToFloat(b);\n+            case BT_ge -> Float.float16ToFloat(a) >= Float.float16ToFloat(b);\n@@ -2068,1 +2067,1 @@\n-                return v.add(sc == 1 ? iota : iota.mul(sc));\n+                return v.add(sc == 1 ? iota : iota.mul(Halffloat.valueOf((float) sc)));\n@@ -2639,1 +2638,1 @@\n-                    toBits(v.rOp((short)0, m, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue()))));\n+                    toBits(v.rOp((short)0, m, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b))));\n@@ -2641,1 +2640,1 @@\n-                    toBits(v.rOp((short)1, m, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue()))));\n+                    toBits(v.rOp((short)1, m, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(b) * Float.float16ToFloat(b))));\n@@ -2643,1 +2642,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue()))));\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n@@ -2645,1 +2644,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue()))));\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatVector.java","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -4021,1 +4021,1 @@\n-        LaneType flt = LaneType.SHORT.asFloating();\n+        LaneType flt = LaneType.HALFFLOAT.asFloating();\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n@@ -993,1 +993,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n@@ -995,1 +995,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n@@ -997,1 +997,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n@@ -999,1 +999,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(),Halffloat.valueOf(b).floatValue())));\n+                    v0.bOp(v1, vm, (i, a, b) -> Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -1001,1 +1001,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(),Halffloat.valueOf(b).floatValue())));\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -1370,2 +1370,1 @@\n-                    Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(),\n-                    Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+                    Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n@@ -2541,6 +2540,6 @@\n-            case BT_eq -> Halffloat.valueOf(a).floatValue() == Halffloat.valueOf(b).floatValue();\n-            case BT_ne -> Halffloat.valueOf(a).floatValue() != Halffloat.valueOf(b).floatValue();\n-            case BT_lt -> Halffloat.valueOf(a).floatValue() < Halffloat.valueOf(b).floatValue();\n-            case BT_le -> Halffloat.valueOf(a).floatValue() <= Halffloat.valueOf(b).floatValue();\n-            case BT_gt -> Halffloat.valueOf(a).floatValue() > Halffloat.valueOf(b).floatValue();\n-            case BT_ge -> Halffloat.valueOf(a).floatValue() >= Halffloat.valueOf(b).floatValue();\n+            case BT_eq -> Float.float16ToFloat(a) == Float.float16ToFloat(b);\n+            case BT_ne -> Float.float16ToFloat(a) != Float.float16ToFloat(b);\n+            case BT_lt -> Float.float16ToFloat(a) < Float.float16ToFloat(b);\n+            case BT_le -> Float.float16ToFloat(a) <= Float.float16ToFloat(b);\n+            case BT_gt -> Float.float16ToFloat(a) > Float.float16ToFloat(b);\n+            case BT_ge -> Float.float16ToFloat(a) >= Float.float16ToFloat(b);\n@@ -2696,0 +2695,3 @@\n+#if[FP16]\n+                return v.add(sc == 1 ? iota : iota.mul(Halffloat.valueOf((float) sc)));\n+#else[FP16]\n@@ -2697,0 +2699,1 @@\n+#end[FP16]\n@@ -3421,1 +3424,1 @@\n-                    toBits(v.rOp(($type$)0, m, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue()))));\n+                    toBits(v.rOp(($type$)0, m, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b))));\n@@ -3423,1 +3426,1 @@\n-                    toBits(v.rOp(($type$)1, m, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue()))));\n+                    toBits(v.rOp(($type$)1, m, (i, a, b) -> Float.floatToFloat16(Float.float16ToFloat(b) * Float.float16ToFloat(b))));\n@@ -3425,1 +3428,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue()))));\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> Float.floatToFloat16(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n@@ -3427,1 +3430,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue()))));\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b)))));\n@@ -5393,0 +5396,3 @@\n+#if[short]\n+        LaneType flt = LaneType.HALFFLOAT.asFloating();\n+#else[short]\n@@ -5394,0 +5400,1 @@\n+#end[short]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":25,"deletions":18,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static byte valueOf(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -953,1 +957,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -957,1 +961,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -961,1 +965,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static byte valueOf(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -953,1 +957,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -957,1 +961,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -961,1 +965,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static byte valueOf(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -953,1 +957,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -957,1 +961,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -961,1 +965,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static byte valueOf(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -953,1 +957,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -957,1 +961,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -961,1 +965,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -905,0 +905,4 @@\n+    static byte valueOf(int i) {\n+        return (byte) i;\n+    }\n+\n@@ -958,1 +962,1 @@\n-                            i -> (byte)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -962,1 +966,1 @@\n-                            i -> (byte)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -966,1 +970,1 @@\n-                            i -> (((byte)(i + 1) == 0) ? 1 : (byte)(i + 1)));\n+                            i -> (((byte)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static double valueOf(int i) {\n+        return (double) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static double valueOf(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1071,1 +1079,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1075,1 +1083,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1079,1 +1087,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static double valueOf(int i) {\n+        return (double) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static double valueOf(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1071,1 +1079,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1075,1 +1083,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1079,1 +1087,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static double valueOf(int i) {\n+        return (double) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static double valueOf(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1071,1 +1079,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1075,1 +1083,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1079,1 +1087,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static double valueOf(int i) {\n+        return (double) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static double valueOf(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1071,1 +1079,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1075,1 +1083,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1079,1 +1087,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -978,0 +978,4 @@\n+    static double valueOf(int i) {\n+        return (double) i;\n+    }\n+\n@@ -996,1 +1000,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1000,1 +1004,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1004,1 +1008,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1038,0 +1042,4 @@\n+    static double valueOf(long i) {\n+        return (double) i;\n+    }\n+\n@@ -1041,1 +1049,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1043,1 +1051,1 @@\n-            withToString(\"double[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1045,1 +1053,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1047,1 +1055,1 @@\n-            withToString(\"double[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1049,1 +1057,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1051,1 +1059,1 @@\n-            withToString(\"double[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1076,1 +1084,1 @@\n-                            i -> (double)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1080,1 +1088,1 @@\n-                            i -> (double)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1084,1 +1092,1 @@\n-                            i -> (((double)(i + 1) == 0) ? 1 : (double)(i + 1)));\n+                            i -> (((double)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static float valueOf(int i) {\n+        return (float) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static float valueOf(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1082,1 +1090,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1086,1 +1094,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1090,1 +1098,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static float valueOf(int i) {\n+        return (float) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static float valueOf(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1082,1 +1090,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1086,1 +1094,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1090,1 +1098,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static float valueOf(int i) {\n+        return (float) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static float valueOf(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1082,1 +1090,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1086,1 +1094,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1090,1 +1098,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -973,0 +973,4 @@\n+    static float valueOf(int i) {\n+        return (float) i;\n+    }\n+\n@@ -991,1 +995,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -995,1 +999,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -999,1 +1003,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1033,0 +1037,4 @@\n+    static float valueOf(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1036,1 +1044,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1038,1 +1046,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1040,1 +1048,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1042,1 +1050,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1082,1 +1090,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1086,1 +1094,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1090,1 +1098,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -978,0 +978,4 @@\n+    static float valueOf(int i) {\n+        return (float) i;\n+    }\n+\n@@ -996,1 +1000,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1000,1 +1004,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1004,1 +1008,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1038,0 +1042,4 @@\n+    static float valueOf(long i) {\n+        return (float) i;\n+    }\n+\n@@ -1041,1 +1049,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1043,1 +1051,1 @@\n-            withToString(\"float[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1045,1 +1053,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1047,1 +1055,1 @@\n-            withToString(\"float[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1049,1 +1057,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1051,1 +1059,1 @@\n-            withToString(\"float[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1087,1 +1095,1 @@\n-                            i -> (float)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1091,1 +1099,1 @@\n-                            i -> (float)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1095,1 +1103,1 @@\n-                            i -> (((float)(i + 1) == 0) ? 1 : (float)(i + 1)));\n+                            i -> (((float)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.HalffloatVector;\n@@ -72,1 +72,1 @@\n-    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n@@ -141,1 +141,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -155,1 +155,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -165,1 +165,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -173,1 +173,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -183,1 +183,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -194,1 +194,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n@@ -204,1 +204,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -213,1 +213,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -234,1 +234,1 @@\n-    interface ToShortF {\n+    interface ToHalffloatF {\n@@ -238,1 +238,1 @@\n-    static short[] fill(int s , ToShortF f) {\n+    static short[] fill(int s , ToHalffloatF f) {\n@@ -242,1 +242,1 @@\n-    static short[] fill(short[] a, ToShortF f) {\n+    static short[] fill(short[] a, ToHalffloatF f) {\n@@ -459,1 +459,113 @@\n-    \/\/ TODO: Fix and Enable loadStoreMemorySegment, loadMemorySegmentIOOBE, storeMemorySegmentIOOBE, loadStoreMemorySegmentMask\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n@@ -647,1 +759,1 @@\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -657,1 +769,1 @@\n-            SHORT_GENERATORS.stream().map(fa -> {\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat128VectorLoadStoreTests.java","additions":128,"deletions":16,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||\n@@ -735,1 +735,1 @@\n-            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n@@ -745,1 +745,1 @@\n-                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n@@ -749,1 +749,1 @@\n-            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -760,1 +760,1 @@\n-                Assert.assertTrue(Short.compare(r[i],\n+                Assert.assertTrue(Halffloat.compare(r[i],\n@@ -766,1 +766,1 @@\n-            Assert.assertTrue(Short.compare(r[i],\n+            Assert.assertTrue(Halffloat.compare(r[i],\n@@ -976,0 +976,4 @@\n+    static short valueOf(int i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n@@ -991,2 +995,2 @@\n-    static final List<IntFunction<short[]>> INT_SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -994,1 +998,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -996,1 +1000,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -998,1 +1002,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1000,1 +1004,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1002,1 +1006,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1004,1 +1008,1 @@\n-            withToString(\"short[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1014,1 +1018,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n@@ -1036,2 +1040,6 @@\n-    static final List<IntFunction<short[]>> LONG_SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static short valueOf(long i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -1039,1 +1047,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1041,1 +1049,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1043,1 +1051,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1045,1 +1053,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1047,1 +1055,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1049,1 +1057,1 @@\n-            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1060,1 +1068,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n@@ -1071,1 +1079,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n@@ -1082,2 +1090,2 @@\n-    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -1085,1 +1093,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1087,1 +1095,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1089,1 +1097,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1091,1 +1099,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1093,1 +1101,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1095,1 +1103,1 @@\n-            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1103,3 +1111,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_PAIRS =\n-        Stream.of(SHORT_GENERATORS.get(0)).\n-                flatMap(fa -> SHORT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n@@ -1115,3 +1123,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_TRIPLES =\n-        SHORT_GENERATOR_PAIRS.stream().\n-                flatMap(pair -> SHORT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n@@ -1122,1 +1130,1 @@\n-        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1128,1 +1136,1 @@\n-        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1135,1 +1143,1 @@\n-                flatMap(fm -> SHORT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n@@ -1143,1 +1151,1 @@\n-        return SHORT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n@@ -1150,1 +1158,1 @@\n-                flatMap(fm -> SHORT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n@@ -1158,1 +1166,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -1166,1 +1174,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1174,1 +1182,1 @@\n-        return INT_SHORT_GENERATORS.stream().\n+        return INT_HALFFLOAT_GENERATORS.stream().\n@@ -1181,1 +1189,1 @@\n-        return LONG_SHORT_GENERATORS.stream().\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n@@ -1215,1 +1223,1 @@\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1225,1 +1233,1 @@\n-                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1231,1 +1239,1 @@\n-    static final List<BiFunction<Integer,Integer,short[]>> SHORT_SHUFFLE_GENERATORS = List.of(\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n@@ -1244,2 +1252,2 @@\n-        return SHORT_SHUFFLE_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1254,2 +1262,2 @@\n-                flatMap(fm -> SHORT_SHUFFLE_GENERATORS.stream().\n-                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1261,1 +1269,1 @@\n-    static final List<IntFunction<short[]>> SHORT_COMPARE_GENERATORS = List.of(\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n@@ -1288,2 +1296,2 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_TEST_GENERATOR_ARGS =\n-        SHORT_COMPARE_GENERATORS.stream().\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n@@ -1295,1 +1303,1 @@\n-        return SHORT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n@@ -1302,1 +1310,1 @@\n-                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n@@ -1308,3 +1316,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_COMPARE_GENERATOR_PAIRS =\n-        SHORT_COMPARE_GENERATORS.stream().\n-                flatMap(fa -> SHORT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n@@ -1315,1 +1323,1 @@\n-        return SHORT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1322,1 +1330,1 @@\n-                flatMap(fm -> SHORT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n@@ -1328,1 +1336,1 @@\n-    interface ToShortF {\n+    interface ToHalffloatF {\n@@ -1332,1 +1340,1 @@\n-    static short[] fill(int s , ToShortF f) {\n+    static short[] fill(int s , ToHalffloatF f) {\n@@ -1336,1 +1344,1 @@\n-    static short[] fill(short[] a, ToShortF f) {\n+    static short[] fill(short[] a, ToHalffloatF f) {\n@@ -1421,1 +1429,23 @@\n-    \/\/ TODO: Fix and Enable smokeTest1, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        Class<?> ETYPE = short.class;\n+        if (ETYPE == double.class || ETYPE == long.class)\n+            scale = 1000000;\n+        else if (ETYPE == byte.class && SPECIES.length() >= 64)\n+            scale = 1;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n@@ -1475,0 +1505,15 @@\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n@@ -1477,1 +1522,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n@@ -1518,1 +1563,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n@@ -1559,1 +1604,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n@@ -1600,1 +1645,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n@@ -1641,1 +1686,1 @@\n-        return (short)(Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -1682,1 +1727,1 @@\n-        return (short)(Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+        return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -1835,1 +1880,1 @@\n-        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n@@ -1839,1 +1884,1 @@\n-        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n@@ -2431,10 +2476,115 @@\n-    \/\/ TODO: Fix and Enable ltHalffloat128VectorTestsBroadcastSmokeTest\n-    \/\/ TODO: Fix and Enable eqHalffloat128VectorTestsBroadcastMaskedSmokeTest\n-    \/\/ TODO: Fix and Enable toLongArrayHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable toDoubleArrayHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable toStringHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable hashCodeHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat128VectorTests\n-    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat128VectorTestsMasked\n-    \/\/ TODO: Fix and Enable BroadcastLongHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable blendHalffloat128VectorTestsBroadcastLongSmokeTest\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat128VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n@@ -2443,11 +2593,307 @@\n-    \/\/ TODO: Fix and Enable SelectFromHalffloat128VectorTests\n-    \/\/ TODO: Fix and Enable SelectFromHalffloat128VectorTestsMaskedSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleMiscellaneousHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleToStringHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleEqualsHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskEqualsHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskEqHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskHashCodeHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskTrueCountHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskLastTrueHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskFirstTrueHalffloat128VectorTestsSmokeTest\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat128VectorTests::ADDReduceLong, Halffloat128VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat128VectorTests::ADDReduceLongMasked, Halffloat128VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat128VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat128VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat128VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat128VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat128VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat128VectorTests::maskFirstTrue);\n+    }\n@@ -2500,13 +2946,117 @@\n-    \/\/ TODO: Fix and Enable indexInRangeHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable indexInRangeLongHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable loopBoundHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable loopBoundLongHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ElementSizeHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable VectorShapeHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ShapeWithLanesHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ElementTypeHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable SpeciesElementSizeHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable VectorTypeHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable WithLanesHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable WithShapeHalffloat128VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable MaskAllTrueHalffloat128VectorTestsSmokeTest\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat128VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat128VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_128_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Halffloat.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat128VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat128VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat128VectorTests.java","additions":661,"deletions":111,"binary":false,"changes":772,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.HalffloatVector;\n@@ -72,1 +72,1 @@\n-    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n@@ -141,1 +141,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -155,1 +155,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -165,1 +165,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -173,1 +173,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -183,1 +183,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -194,1 +194,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n@@ -204,1 +204,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -213,1 +213,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -234,1 +234,1 @@\n-    interface ToShortF {\n+    interface ToHalffloatF {\n@@ -238,1 +238,1 @@\n-    static short[] fill(int s , ToShortF f) {\n+    static short[] fill(int s , ToHalffloatF f) {\n@@ -242,1 +242,1 @@\n-    static short[] fill(short[] a, ToShortF f) {\n+    static short[] fill(short[] a, ToHalffloatF f) {\n@@ -459,1 +459,113 @@\n-    \/\/ TODO: Fix and Enable loadStoreMemorySegment, loadMemorySegmentIOOBE, storeMemorySegmentIOOBE, loadStoreMemorySegmentMask\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n@@ -647,1 +759,1 @@\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -657,1 +769,1 @@\n-            SHORT_GENERATORS.stream().map(fa -> {\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat256VectorLoadStoreTests.java","additions":128,"deletions":16,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||\n@@ -735,1 +735,1 @@\n-            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n@@ -745,1 +745,1 @@\n-                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n@@ -749,1 +749,1 @@\n-            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -760,1 +760,1 @@\n-                Assert.assertTrue(Short.compare(r[i],\n+                Assert.assertTrue(Halffloat.compare(r[i],\n@@ -766,1 +766,1 @@\n-            Assert.assertTrue(Short.compare(r[i],\n+            Assert.assertTrue(Halffloat.compare(r[i],\n@@ -976,0 +976,4 @@\n+    static short valueOf(int i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n@@ -991,2 +995,2 @@\n-    static final List<IntFunction<short[]>> INT_SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -994,1 +998,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -996,1 +1000,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -998,1 +1002,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1000,1 +1004,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1002,1 +1006,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1004,1 +1008,1 @@\n-            withToString(\"short[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1014,1 +1018,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n@@ -1036,2 +1040,6 @@\n-    static final List<IntFunction<short[]>> LONG_SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static short valueOf(long i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -1039,1 +1047,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1041,1 +1049,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1043,1 +1051,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1045,1 +1053,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1047,1 +1055,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1049,1 +1057,1 @@\n-            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1060,1 +1068,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n@@ -1071,1 +1079,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n@@ -1082,2 +1090,2 @@\n-    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -1085,1 +1093,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1087,1 +1095,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1089,1 +1097,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1091,1 +1099,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1093,1 +1101,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1095,1 +1103,1 @@\n-            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1103,3 +1111,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_PAIRS =\n-        Stream.of(SHORT_GENERATORS.get(0)).\n-                flatMap(fa -> SHORT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n@@ -1115,3 +1123,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_TRIPLES =\n-        SHORT_GENERATOR_PAIRS.stream().\n-                flatMap(pair -> SHORT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n@@ -1122,1 +1130,1 @@\n-        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1128,1 +1136,1 @@\n-        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1135,1 +1143,1 @@\n-                flatMap(fm -> SHORT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n@@ -1143,1 +1151,1 @@\n-        return SHORT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n@@ -1150,1 +1158,1 @@\n-                flatMap(fm -> SHORT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n@@ -1158,1 +1166,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -1166,1 +1174,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1174,1 +1182,1 @@\n-        return INT_SHORT_GENERATORS.stream().\n+        return INT_HALFFLOAT_GENERATORS.stream().\n@@ -1181,1 +1189,1 @@\n-        return LONG_SHORT_GENERATORS.stream().\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n@@ -1215,1 +1223,1 @@\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1225,1 +1233,1 @@\n-                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1231,1 +1239,1 @@\n-    static final List<BiFunction<Integer,Integer,short[]>> SHORT_SHUFFLE_GENERATORS = List.of(\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n@@ -1244,2 +1252,2 @@\n-        return SHORT_SHUFFLE_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1254,2 +1262,2 @@\n-                flatMap(fm -> SHORT_SHUFFLE_GENERATORS.stream().\n-                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1261,1 +1269,1 @@\n-    static final List<IntFunction<short[]>> SHORT_COMPARE_GENERATORS = List.of(\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n@@ -1288,2 +1296,2 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_TEST_GENERATOR_ARGS =\n-        SHORT_COMPARE_GENERATORS.stream().\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n@@ -1295,1 +1303,1 @@\n-        return SHORT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n@@ -1302,1 +1310,1 @@\n-                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n@@ -1308,3 +1316,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_COMPARE_GENERATOR_PAIRS =\n-        SHORT_COMPARE_GENERATORS.stream().\n-                flatMap(fa -> SHORT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n@@ -1315,1 +1323,1 @@\n-        return SHORT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1322,1 +1330,1 @@\n-                flatMap(fm -> SHORT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n@@ -1328,1 +1336,1 @@\n-    interface ToShortF {\n+    interface ToHalffloatF {\n@@ -1332,1 +1340,1 @@\n-    static short[] fill(int s , ToShortF f) {\n+    static short[] fill(int s , ToHalffloatF f) {\n@@ -1336,1 +1344,1 @@\n-    static short[] fill(short[] a, ToShortF f) {\n+    static short[] fill(short[] a, ToHalffloatF f) {\n@@ -1421,1 +1429,23 @@\n-    \/\/ TODO: Fix and Enable smokeTest1, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        Class<?> ETYPE = short.class;\n+        if (ETYPE == double.class || ETYPE == long.class)\n+            scale = 1000000;\n+        else if (ETYPE == byte.class && SPECIES.length() >= 64)\n+            scale = 1;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n@@ -1475,0 +1505,15 @@\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n@@ -1477,1 +1522,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n@@ -1518,1 +1563,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n@@ -1559,1 +1604,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n@@ -1600,1 +1645,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n@@ -1641,1 +1686,1 @@\n-        return (short)(Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -1682,1 +1727,1 @@\n-        return (short)(Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+        return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -1835,1 +1880,1 @@\n-        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n@@ -1839,1 +1884,1 @@\n-        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n@@ -2431,10 +2476,115 @@\n-    \/\/ TODO: Fix and Enable ltHalffloat256VectorTestsBroadcastSmokeTest\n-    \/\/ TODO: Fix and Enable eqHalffloat256VectorTestsBroadcastMaskedSmokeTest\n-    \/\/ TODO: Fix and Enable toLongArrayHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable toDoubleArrayHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable toStringHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable hashCodeHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat256VectorTests\n-    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat256VectorTestsMasked\n-    \/\/ TODO: Fix and Enable BroadcastLongHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable blendHalffloat256VectorTestsBroadcastLongSmokeTest\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat256VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n@@ -2443,11 +2593,307 @@\n-    \/\/ TODO: Fix and Enable SelectFromHalffloat256VectorTests\n-    \/\/ TODO: Fix and Enable SelectFromHalffloat256VectorTestsMaskedSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleMiscellaneousHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleToStringHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleEqualsHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskEqualsHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskEqHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskHashCodeHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskTrueCountHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskLastTrueHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskFirstTrueHalffloat256VectorTestsSmokeTest\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat256VectorTests::ADDReduceLong, Halffloat256VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat256VectorTests::ADDReduceLongMasked, Halffloat256VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat256VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat256VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat256VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat256VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat256VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat256VectorTests::maskFirstTrue);\n+    }\n@@ -2500,13 +2946,117 @@\n-    \/\/ TODO: Fix and Enable indexInRangeHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable indexInRangeLongHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable loopBoundHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable loopBoundLongHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ElementSizeHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable VectorShapeHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ShapeWithLanesHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ElementTypeHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable SpeciesElementSizeHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable VectorTypeHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable WithLanesHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable WithShapeHalffloat256VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable MaskAllTrueHalffloat256VectorTestsSmokeTest\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat256VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat256VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_256_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Halffloat.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat256VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat256VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat256VectorTests.java","additions":661,"deletions":111,"binary":false,"changes":772,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.HalffloatVector;\n@@ -72,1 +72,1 @@\n-    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n@@ -141,1 +141,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -155,1 +155,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -165,1 +165,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -173,1 +173,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -183,1 +183,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -194,1 +194,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n@@ -204,1 +204,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -213,1 +213,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -234,1 +234,1 @@\n-    interface ToShortF {\n+    interface ToHalffloatF {\n@@ -238,1 +238,1 @@\n-    static short[] fill(int s , ToShortF f) {\n+    static short[] fill(int s , ToHalffloatF f) {\n@@ -242,1 +242,1 @@\n-    static short[] fill(short[] a, ToShortF f) {\n+    static short[] fill(short[] a, ToHalffloatF f) {\n@@ -459,1 +459,113 @@\n-    \/\/ TODO: Fix and Enable loadStoreMemorySegment, loadMemorySegmentIOOBE, storeMemorySegmentIOOBE, loadStoreMemorySegmentMask\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n@@ -647,1 +759,1 @@\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -657,1 +769,1 @@\n-            SHORT_GENERATORS.stream().map(fa -> {\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat512VectorLoadStoreTests.java","additions":128,"deletions":16,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||\n@@ -735,1 +735,1 @@\n-            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n@@ -745,1 +745,1 @@\n-                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n@@ -749,1 +749,1 @@\n-            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -760,1 +760,1 @@\n-                Assert.assertTrue(Short.compare(r[i],\n+                Assert.assertTrue(Halffloat.compare(r[i],\n@@ -766,1 +766,1 @@\n-            Assert.assertTrue(Short.compare(r[i],\n+            Assert.assertTrue(Halffloat.compare(r[i],\n@@ -976,0 +976,4 @@\n+    static short valueOf(int i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n@@ -991,2 +995,2 @@\n-    static final List<IntFunction<short[]>> INT_SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -994,1 +998,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -996,1 +1000,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -998,1 +1002,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1000,1 +1004,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1002,1 +1006,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1004,1 +1008,1 @@\n-            withToString(\"short[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1014,1 +1018,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n@@ -1036,2 +1040,6 @@\n-    static final List<IntFunction<short[]>> LONG_SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static short valueOf(long i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -1039,1 +1047,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1041,1 +1049,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1043,1 +1051,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1045,1 +1053,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1047,1 +1055,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1049,1 +1057,1 @@\n-            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1060,1 +1068,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n@@ -1071,1 +1079,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n@@ -1082,2 +1090,2 @@\n-    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -1085,1 +1093,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1087,1 +1095,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1089,1 +1097,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1091,1 +1099,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1093,1 +1101,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1095,1 +1103,1 @@\n-            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1103,3 +1111,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_PAIRS =\n-        Stream.of(SHORT_GENERATORS.get(0)).\n-                flatMap(fa -> SHORT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n@@ -1115,3 +1123,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_TRIPLES =\n-        SHORT_GENERATOR_PAIRS.stream().\n-                flatMap(pair -> SHORT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n@@ -1122,1 +1130,1 @@\n-        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1128,1 +1136,1 @@\n-        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1135,1 +1143,1 @@\n-                flatMap(fm -> SHORT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n@@ -1143,1 +1151,1 @@\n-        return SHORT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n@@ -1150,1 +1158,1 @@\n-                flatMap(fm -> SHORT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n@@ -1158,1 +1166,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -1166,1 +1174,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1174,1 +1182,1 @@\n-        return INT_SHORT_GENERATORS.stream().\n+        return INT_HALFFLOAT_GENERATORS.stream().\n@@ -1181,1 +1189,1 @@\n-        return LONG_SHORT_GENERATORS.stream().\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n@@ -1215,1 +1223,1 @@\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1225,1 +1233,1 @@\n-                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1231,1 +1239,1 @@\n-    static final List<BiFunction<Integer,Integer,short[]>> SHORT_SHUFFLE_GENERATORS = List.of(\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n@@ -1244,2 +1252,2 @@\n-        return SHORT_SHUFFLE_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1254,2 +1262,2 @@\n-                flatMap(fm -> SHORT_SHUFFLE_GENERATORS.stream().\n-                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1261,1 +1269,1 @@\n-    static final List<IntFunction<short[]>> SHORT_COMPARE_GENERATORS = List.of(\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n@@ -1288,2 +1296,2 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_TEST_GENERATOR_ARGS =\n-        SHORT_COMPARE_GENERATORS.stream().\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n@@ -1295,1 +1303,1 @@\n-        return SHORT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n@@ -1302,1 +1310,1 @@\n-                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n@@ -1308,3 +1316,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_COMPARE_GENERATOR_PAIRS =\n-        SHORT_COMPARE_GENERATORS.stream().\n-                flatMap(fa -> SHORT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n@@ -1315,1 +1323,1 @@\n-        return SHORT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1322,1 +1330,1 @@\n-                flatMap(fm -> SHORT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n@@ -1328,1 +1336,1 @@\n-    interface ToShortF {\n+    interface ToHalffloatF {\n@@ -1332,1 +1340,1 @@\n-    static short[] fill(int s , ToShortF f) {\n+    static short[] fill(int s , ToHalffloatF f) {\n@@ -1336,1 +1344,1 @@\n-    static short[] fill(short[] a, ToShortF f) {\n+    static short[] fill(short[] a, ToHalffloatF f) {\n@@ -1421,1 +1429,23 @@\n-    \/\/ TODO: Fix and Enable smokeTest1, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        Class<?> ETYPE = short.class;\n+        if (ETYPE == double.class || ETYPE == long.class)\n+            scale = 1000000;\n+        else if (ETYPE == byte.class && SPECIES.length() >= 64)\n+            scale = 1;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n@@ -1475,0 +1505,15 @@\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n@@ -1477,1 +1522,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n@@ -1518,1 +1563,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n@@ -1559,1 +1604,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n@@ -1600,1 +1645,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n@@ -1641,1 +1686,1 @@\n-        return (short)(Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -1682,1 +1727,1 @@\n-        return (short)(Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+        return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -1835,1 +1880,1 @@\n-        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n@@ -1839,1 +1884,1 @@\n-        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n@@ -2431,10 +2476,115 @@\n-    \/\/ TODO: Fix and Enable ltHalffloat512VectorTestsBroadcastSmokeTest\n-    \/\/ TODO: Fix and Enable eqHalffloat512VectorTestsBroadcastMaskedSmokeTest\n-    \/\/ TODO: Fix and Enable toLongArrayHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable toDoubleArrayHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable toStringHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable hashCodeHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat512VectorTests\n-    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat512VectorTestsMasked\n-    \/\/ TODO: Fix and Enable BroadcastLongHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable blendHalffloat512VectorTestsBroadcastLongSmokeTest\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat512VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n@@ -2443,11 +2593,307 @@\n-    \/\/ TODO: Fix and Enable SelectFromHalffloat512VectorTests\n-    \/\/ TODO: Fix and Enable SelectFromHalffloat512VectorTestsMaskedSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleMiscellaneousHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleToStringHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleEqualsHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskEqualsHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskEqHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskHashCodeHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskTrueCountHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskLastTrueHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskFirstTrueHalffloat512VectorTestsSmokeTest\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat512VectorTests::ADDReduceLong, Halffloat512VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat512VectorTests::ADDReduceLongMasked, Halffloat512VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat512VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat512VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat512VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat512VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat512VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat512VectorTests::maskFirstTrue);\n+    }\n@@ -2500,13 +2946,117 @@\n-    \/\/ TODO: Fix and Enable indexInRangeHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable indexInRangeLongHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable loopBoundHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable loopBoundLongHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ElementSizeHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable VectorShapeHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ShapeWithLanesHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ElementTypeHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable SpeciesElementSizeHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable VectorTypeHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable WithLanesHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable WithShapeHalffloat512VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable MaskAllTrueHalffloat512VectorTestsSmokeTest\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat512VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat512VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_512_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Halffloat.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat512VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat512VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat512VectorTests.java","additions":661,"deletions":111,"binary":false,"changes":772,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.HalffloatVector;\n@@ -72,1 +72,1 @@\n-    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n@@ -141,1 +141,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -155,1 +155,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -165,1 +165,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -173,1 +173,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -183,1 +183,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -194,1 +194,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n@@ -204,1 +204,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -213,1 +213,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -234,1 +234,1 @@\n-    interface ToShortF {\n+    interface ToHalffloatF {\n@@ -238,1 +238,1 @@\n-    static short[] fill(int s , ToShortF f) {\n+    static short[] fill(int s , ToHalffloatF f) {\n@@ -242,1 +242,1 @@\n-    static short[] fill(short[] a, ToShortF f) {\n+    static short[] fill(short[] a, ToHalffloatF f) {\n@@ -459,1 +459,113 @@\n-    \/\/ TODO: Fix and Enable loadStoreMemorySegment, loadMemorySegmentIOOBE, storeMemorySegmentIOOBE, loadStoreMemorySegmentMask\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n@@ -647,1 +759,1 @@\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -657,1 +769,1 @@\n-            SHORT_GENERATORS.stream().map(fa -> {\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat64VectorLoadStoreTests.java","additions":128,"deletions":16,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||\n@@ -735,1 +735,1 @@\n-            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n@@ -745,1 +745,1 @@\n-                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n@@ -749,1 +749,1 @@\n-            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -760,1 +760,1 @@\n-                Assert.assertTrue(Short.compare(r[i],\n+                Assert.assertTrue(Halffloat.compare(r[i],\n@@ -766,1 +766,1 @@\n-            Assert.assertTrue(Short.compare(r[i],\n+            Assert.assertTrue(Halffloat.compare(r[i],\n@@ -976,0 +976,4 @@\n+    static short valueOf(int i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n@@ -991,2 +995,2 @@\n-    static final List<IntFunction<short[]>> INT_SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -994,1 +998,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -996,1 +1000,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -998,1 +1002,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1000,1 +1004,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1002,1 +1006,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1004,1 +1008,1 @@\n-            withToString(\"short[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1014,1 +1018,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n@@ -1036,2 +1040,6 @@\n-    static final List<IntFunction<short[]>> LONG_SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static short valueOf(long i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -1039,1 +1047,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1041,1 +1049,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1043,1 +1051,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1045,1 +1053,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1047,1 +1055,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1049,1 +1057,1 @@\n-            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1060,1 +1068,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n@@ -1071,1 +1079,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n@@ -1082,2 +1090,2 @@\n-    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -1085,1 +1093,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1087,1 +1095,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1089,1 +1097,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1091,1 +1099,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1093,1 +1101,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1095,1 +1103,1 @@\n-            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1103,3 +1111,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_PAIRS =\n-        Stream.of(SHORT_GENERATORS.get(0)).\n-                flatMap(fa -> SHORT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n@@ -1115,3 +1123,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_TRIPLES =\n-        SHORT_GENERATOR_PAIRS.stream().\n-                flatMap(pair -> SHORT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n@@ -1122,1 +1130,1 @@\n-        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1128,1 +1136,1 @@\n-        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1135,1 +1143,1 @@\n-                flatMap(fm -> SHORT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n@@ -1143,1 +1151,1 @@\n-        return SHORT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n@@ -1150,1 +1158,1 @@\n-                flatMap(fm -> SHORT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n@@ -1158,1 +1166,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -1166,1 +1174,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1174,1 +1182,1 @@\n-        return INT_SHORT_GENERATORS.stream().\n+        return INT_HALFFLOAT_GENERATORS.stream().\n@@ -1181,1 +1189,1 @@\n-        return LONG_SHORT_GENERATORS.stream().\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n@@ -1215,1 +1223,1 @@\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1225,1 +1233,1 @@\n-                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1231,1 +1239,1 @@\n-    static final List<BiFunction<Integer,Integer,short[]>> SHORT_SHUFFLE_GENERATORS = List.of(\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n@@ -1244,2 +1252,2 @@\n-        return SHORT_SHUFFLE_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1254,2 +1262,2 @@\n-                flatMap(fm -> SHORT_SHUFFLE_GENERATORS.stream().\n-                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1261,1 +1269,1 @@\n-    static final List<IntFunction<short[]>> SHORT_COMPARE_GENERATORS = List.of(\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n@@ -1288,2 +1296,2 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_TEST_GENERATOR_ARGS =\n-        SHORT_COMPARE_GENERATORS.stream().\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n@@ -1295,1 +1303,1 @@\n-        return SHORT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n@@ -1302,1 +1310,1 @@\n-                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n@@ -1308,3 +1316,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_COMPARE_GENERATOR_PAIRS =\n-        SHORT_COMPARE_GENERATORS.stream().\n-                flatMap(fa -> SHORT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n@@ -1315,1 +1323,1 @@\n-        return SHORT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1322,1 +1330,1 @@\n-                flatMap(fm -> SHORT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n@@ -1328,1 +1336,1 @@\n-    interface ToShortF {\n+    interface ToHalffloatF {\n@@ -1332,1 +1340,1 @@\n-    static short[] fill(int s , ToShortF f) {\n+    static short[] fill(int s , ToHalffloatF f) {\n@@ -1336,1 +1344,1 @@\n-    static short[] fill(short[] a, ToShortF f) {\n+    static short[] fill(short[] a, ToHalffloatF f) {\n@@ -1421,1 +1429,23 @@\n-    \/\/ TODO: Fix and Enable smokeTest1, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        Class<?> ETYPE = short.class;\n+        if (ETYPE == double.class || ETYPE == long.class)\n+            scale = 1000000;\n+        else if (ETYPE == byte.class && SPECIES.length() >= 64)\n+            scale = 1;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n@@ -1475,0 +1505,15 @@\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n@@ -1477,1 +1522,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n@@ -1518,1 +1563,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n@@ -1559,1 +1604,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n@@ -1600,1 +1645,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n@@ -1641,1 +1686,1 @@\n-        return (short)(Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -1682,1 +1727,1 @@\n-        return (short)(Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+        return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -1835,1 +1880,1 @@\n-        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n@@ -1839,1 +1884,1 @@\n-        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n@@ -2431,10 +2476,115 @@\n-    \/\/ TODO: Fix and Enable ltHalffloat64VectorTestsBroadcastSmokeTest\n-    \/\/ TODO: Fix and Enable eqHalffloat64VectorTestsBroadcastMaskedSmokeTest\n-    \/\/ TODO: Fix and Enable toLongArrayHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable toDoubleArrayHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable toStringHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable hashCodeHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat64VectorTests\n-    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat64VectorTestsMasked\n-    \/\/ TODO: Fix and Enable BroadcastLongHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable blendHalffloat64VectorTestsBroadcastLongSmokeTest\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloat64VectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n@@ -2443,11 +2593,307 @@\n-    \/\/ TODO: Fix and Enable SelectFromHalffloat64VectorTests\n-    \/\/ TODO: Fix and Enable SelectFromHalffloat64VectorTestsMaskedSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleMiscellaneousHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleToStringHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleEqualsHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskEqualsHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskEqHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskHashCodeHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskTrueCountHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskLastTrueHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskFirstTrueHalffloat64VectorTestsSmokeTest\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                Halffloat64VectorTests::ADDReduceLong, Halffloat64VectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                Halffloat64VectorTests::ADDReduceLongMasked, Halffloat64VectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloat64VectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloat64VectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, Halffloat64VectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloat64VectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloat64VectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, Halffloat64VectorTests::maskFirstTrue);\n+    }\n@@ -2500,13 +2946,117 @@\n-    \/\/ TODO: Fix and Enable indexInRangeHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable indexInRangeLongHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable loopBoundHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable loopBoundLongHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ElementSizeHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable VectorShapeHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ShapeWithLanesHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ElementTypeHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable SpeciesElementSizeHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable VectorTypeHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable WithLanesHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable WithShapeHalffloat64VectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable MaskAllTrueHalffloat64VectorTestsSmokeTest\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloat64VectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloat64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloat64VectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloat64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_64_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Halffloat.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloat64VectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloat64VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat64VectorTests.java","additions":661,"deletions":111,"binary":false,"changes":772,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.HalffloatVector;\n@@ -79,1 +79,1 @@\n-    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n@@ -148,1 +148,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -162,1 +162,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -172,1 +172,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -180,1 +180,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -190,1 +190,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -201,1 +201,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().\n@@ -211,1 +211,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -220,1 +220,1 @@\n-        var f = SHORT_GENERATORS.get(0);\n+        var f = HALFFLOAT_GENERATORS.get(0);\n@@ -241,1 +241,1 @@\n-    interface ToShortF {\n+    interface ToHalffloatF {\n@@ -245,1 +245,1 @@\n-    static short[] fill(int s , ToShortF f) {\n+    static short[] fill(int s , ToHalffloatF f) {\n@@ -249,1 +249,1 @@\n-    static short[] fill(short[] a, ToShortF f) {\n+    static short[] fill(short[] a, ToHalffloatF f) {\n@@ -466,1 +466,113 @@\n-    \/\/ TODO: Fix and Enable loadStoreMemorySegment, loadMemorySegmentIOOBE, storeMemorySegmentIOOBE, loadStoreMemorySegmentMask\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n+        short[] _a = fa.apply(SPECIES.length());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+\n+\n+        r = fb.apply((int) a.byteSize());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n+            }\n+        }\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n+    }\n+\n@@ -654,1 +766,1 @@\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -664,1 +776,1 @@\n-            SHORT_GENERATORS.stream().map(fa -> {\n+            HALFFLOAT_GENERATORS.stream().map(fa -> {\n","filename":"test\/jdk\/jdk\/incubator\/vector\/HalffloatMaxVectorLoadStoreTests.java","additions":128,"deletions":16,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -736,1 +736,1 @@\n-                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0 ||\n@@ -740,1 +740,1 @@\n-            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n@@ -750,1 +750,1 @@\n-                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n@@ -754,1 +754,1 @@\n-            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(Halffloat.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n@@ -765,1 +765,1 @@\n-                Assert.assertTrue(Short.compare(r[i],\n+                Assert.assertTrue(Halffloat.compare(r[i],\n@@ -771,1 +771,1 @@\n-            Assert.assertTrue(Short.compare(r[i],\n+            Assert.assertTrue(Halffloat.compare(r[i],\n@@ -981,0 +981,4 @@\n+    static short valueOf(int i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n@@ -996,2 +1000,2 @@\n-    static final List<IntFunction<short[]>> INT_SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static final List<IntFunction<short[]>> INT_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -999,1 +1003,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1001,1 +1005,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1003,1 +1007,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1005,1 +1009,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1007,1 +1011,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1009,1 +1013,1 @@\n-            withToString(\"short[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1019,1 +1023,1 @@\n-                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n@@ -1041,2 +1045,6 @@\n-    static final List<IntFunction<short[]>> LONG_SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static short valueOf(long i) {\n+        return (short) Halffloat.valueOf(i);\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -1044,1 +1052,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1046,1 +1054,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1048,1 +1056,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1050,1 +1058,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1052,1 +1060,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1054,1 +1062,1 @@\n-            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1065,1 +1073,1 @@\n-                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n@@ -1076,1 +1084,1 @@\n-                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n@@ -1087,2 +1095,2 @@\n-    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n-            withToString(\"short[-i * 5]\", (int s) -> {\n+    static final List<IntFunction<short[]>> HALFFLOAT_GENERATORS = List.of(\n+            withToString(\"Halffloat[-i * 5]\", (int s) -> {\n@@ -1090,1 +1098,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1092,1 +1100,1 @@\n-            withToString(\"short[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1094,1 +1102,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1096,1 +1104,1 @@\n-            withToString(\"short[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1098,1 +1106,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1100,1 +1108,1 @@\n-            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1108,3 +1116,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_PAIRS =\n-        Stream.of(SHORT_GENERATORS.get(0)).\n-                flatMap(fa -> SHORT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_PAIRS =\n+        Stream.of(HALFFLOAT_GENERATORS.get(0)).\n+                flatMap(fa -> HALFFLOAT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n@@ -1120,3 +1128,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_TRIPLES =\n-        SHORT_GENERATOR_PAIRS.stream().\n-                flatMap(pair -> SHORT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_GENERATOR_TRIPLES =\n+        HALFFLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> HALFFLOAT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n@@ -1127,1 +1135,1 @@\n-        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1133,1 +1141,1 @@\n-        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1140,1 +1148,1 @@\n-                flatMap(fm -> SHORT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATOR_PAIRS.stream().map(lfa -> {\n@@ -1148,1 +1156,1 @@\n-        return SHORT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+        return HALFFLOAT_GENERATOR_TRIPLES.stream().map(List::toArray).\n@@ -1155,1 +1163,1 @@\n-                flatMap(fm -> SHORT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATOR_TRIPLES.stream().map(lfa -> {\n@@ -1163,1 +1171,1 @@\n-        return SHORT_GENERATORS.stream().\n+        return HALFFLOAT_GENERATORS.stream().\n@@ -1171,1 +1179,1 @@\n-                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1179,1 +1187,1 @@\n-        return INT_SHORT_GENERATORS.stream().\n+        return INT_HALFFLOAT_GENERATORS.stream().\n@@ -1186,1 +1194,1 @@\n-        return LONG_SHORT_GENERATORS.stream().\n+        return LONG_HALFFLOAT_GENERATORS.stream().\n@@ -1220,1 +1228,1 @@\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1230,1 +1238,1 @@\n-                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1236,1 +1244,1 @@\n-    static final List<BiFunction<Integer,Integer,short[]>> SHORT_SHUFFLE_GENERATORS = List.of(\n+    static final List<BiFunction<Integer,Integer,short[]>> HALFFLOAT_SHUFFLE_GENERATORS = List.of(\n@@ -1249,2 +1257,2 @@\n-        return SHORT_SHUFFLE_GENERATORS.stream().\n-                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+        return HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1259,2 +1267,2 @@\n-                flatMap(fm -> SHORT_SHUFFLE_GENERATORS.stream().\n-                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                flatMap(fm -> HALFFLOAT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> HALFFLOAT_GENERATORS.stream().map(fa -> {\n@@ -1266,1 +1274,1 @@\n-    static final List<IntFunction<short[]>> SHORT_COMPARE_GENERATORS = List.of(\n+    static final List<IntFunction<short[]>> HALFFLOAT_COMPARE_GENERATORS = List.of(\n@@ -1293,2 +1301,2 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_TEST_GENERATOR_ARGS =\n-        SHORT_COMPARE_GENERATORS.stream().\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_TEST_GENERATOR_ARGS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n@@ -1300,1 +1308,1 @@\n-        return SHORT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+        return HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n@@ -1307,1 +1315,1 @@\n-                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n@@ -1313,3 +1321,3 @@\n-    static final List<List<IntFunction<short[]>>> SHORT_COMPARE_GENERATOR_PAIRS =\n-        SHORT_COMPARE_GENERATORS.stream().\n-                flatMap(fa -> SHORT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+    static final List<List<IntFunction<short[]>>> HALFFLOAT_COMPARE_GENERATOR_PAIRS =\n+        HALFFLOAT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> HALFFLOAT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n@@ -1320,1 +1328,1 @@\n-        return SHORT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+        return HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n@@ -1327,1 +1335,1 @@\n-                flatMap(fm -> SHORT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                flatMap(fm -> HALFFLOAT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n@@ -1333,1 +1341,1 @@\n-    interface ToShortF {\n+    interface ToHalffloatF {\n@@ -1337,1 +1345,1 @@\n-    static short[] fill(int s , ToShortF f) {\n+    static short[] fill(int s , ToHalffloatF f) {\n@@ -1341,1 +1349,1 @@\n-    static short[] fill(short[] a, ToShortF f) {\n+    static short[] fill(short[] a, ToHalffloatF f) {\n@@ -1426,1 +1434,23 @@\n-    \/\/ TODO: Fix and Enable smokeTest1, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+    @Test\n+    static void smokeTest1() {\n+        HalffloatVector three = HalffloatVector.broadcast(SPECIES, Halffloat.valueOf(-3));\n+        HalffloatVector three2 = (HalffloatVector) SPECIES.broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three2).allTrue());\n+        HalffloatVector three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        Class<?> ETYPE = short.class;\n+        if (ETYPE == double.class || ETYPE == long.class)\n+            scale = 1000000;\n+        else if (ETYPE == byte.class && SPECIES.length() >= 64)\n+            scale = 1;\n+        HalffloatVector higher = three.addIndex(scale);\n+        VectorMask<Halffloat> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        short max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+    }\n@@ -1480,0 +1510,15 @@\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+    }\n+\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n@@ -1482,1 +1527,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n@@ -1523,1 +1568,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n@@ -1564,1 +1609,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n@@ -1605,1 +1650,1 @@\n-        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n@@ -1646,1 +1691,1 @@\n-        return (short)(Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -1687,1 +1732,1 @@\n-        return (short)(Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+        return (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n@@ -1840,1 +1885,1 @@\n-        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n@@ -1844,1 +1889,1 @@\n-        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+        return (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n@@ -2436,10 +2481,115 @@\n-    \/\/ TODO: Fix and Enable ltHalffloatMaxVectorTestsBroadcastSmokeTest\n-    \/\/ TODO: Fix and Enable eqHalffloatMaxVectorTestsBroadcastMaskedSmokeTest\n-    \/\/ TODO: Fix and Enable toLongArrayHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable toDoubleArrayHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable toStringHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable hashCodeHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ADDReduceLongHalffloatMaxVectorTests\n-    \/\/ TODO: Fix and Enable ADDReduceLongHalffloatMaxVectorTestsMasked\n-    \/\/ TODO: Fix and Enable BroadcastLongHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable blendHalffloatMaxVectorTestsBroadcastLongSmokeTest\n+    static short blend(short a, short b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::blend);\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void ltHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void eqHalffloatMaxVectorTestsBroadcastMaskedSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            VectorMask<Halffloat> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoIntUnaryOpProvider\")\n+    static void toIntArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void toLongArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toDoubleArrayHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void toStringHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void hashCodeHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            short subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n@@ -2448,11 +2598,307 @@\n-    \/\/ TODO: Fix and Enable SelectFromHalffloatMaxVectorTests\n-    \/\/ TODO: Fix and Enable SelectFromHalffloatMaxVectorTestsMaskedSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleMiscellaneousHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleToStringHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleEqualsHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskEqualsHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskEqHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskHashCodeHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskTrueCountHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskLastTrueHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable maskFirstTrueHalffloatMaxVectorTestsSmokeTest\n+    static long ADDReduceLong(short[] a, int idx) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong(short[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceLongHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                HalffloatMaxVectorTests::ADDReduceLong, HalffloatMaxVectorTests::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked(short[] a, int idx, boolean[] mask) {\n+        short res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked(short[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ADDReduceLongHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                HalffloatMaxVectorTests::ADDReduceLongMasked, HalffloatMaxVectorTests::ADDReduceAllLongMasked);\n+    }\n+\n+    @Test(dataProvider = \"shorttoLongUnaryOpProvider\")\n+    static void BroadcastLongHalffloatMaxVectorTestsSmokeTest(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void blendHalffloatMaxVectorTestsBroadcastLongSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::blend);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromProvider\")\n+    static void SelectFromHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                           BiFunction<Integer,Integer,short[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpSelectFromMaskProvider\")\n+    static void SelectFromHalffloatMaxVectorTestsMaskedSmokeTest(IntFunction<short[]> fa,\n+                                                           BiFunction<Integer,Integer,short[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneousHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToStringHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEqualsHalffloatMaxVectorTestsSmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqualsHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEqHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCodeHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCountHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrueHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrueHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, HalffloatMaxVectorTests::maskFirstTrue);\n+    }\n@@ -2489,13 +2935,117 @@\n-    \/\/ TODO: Fix and Enable indexInRangeHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable indexInRangeLongHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable loopBoundHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable loopBoundLongHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ElementSizeHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable VectorShapeHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ShapeWithLanesHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable ElementTypeHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable SpeciesElementSizeHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable VectorTypeHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable WithLanesHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable WithShapeHalffloatMaxVectorTestsSmokeTest\n-    \/\/ TODO: Fix and Enable MaskAllTrueHalffloatMaxVectorTestsSmokeTest\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeHalffloatMaxVectorTestsSmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongHalffloatMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundHalffloatMaxVectorTestsSmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongHalffloatMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSizeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShapeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.S_Max_BIT));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanesHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementTypeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementType() == Halffloat.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSizeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().elementSize() == Halffloat.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorTypeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanesHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes(Halffloat.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShapeHalffloatMaxVectorTestsSmokeTest() {\n+        HalffloatVector av = HalffloatVector.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrueHalffloatMaxVectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/HalffloatMaxVectorTests.java","additions":661,"deletions":111,"binary":false,"changes":772,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static int valueOf(int i) {\n+        return (int) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static int valueOf(int i) {\n+        return (int) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static int valueOf(int i) {\n+        return (int) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static int valueOf(int i) {\n+        return (int) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -905,0 +905,4 @@\n+    static int valueOf(int i) {\n+        return (int) i;\n+    }\n+\n@@ -948,1 +952,1 @@\n-                            i -> (int)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -952,1 +956,1 @@\n-                            i -> (int)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -956,1 +960,1 @@\n-                            i -> (((int)(i + 1) == 0) ? 1 : (int)(i + 1)));\n+                            i -> (((int)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -857,0 +857,4 @@\n+    static long valueOf(int i) {\n+        return (long) i;\n+    }\n+\n@@ -875,1 +879,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -879,1 +883,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -883,1 +887,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -933,1 +937,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -937,1 +941,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -941,1 +945,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -857,0 +857,4 @@\n+    static long valueOf(int i) {\n+        return (long) i;\n+    }\n+\n@@ -875,1 +879,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -879,1 +883,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -883,1 +887,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -933,1 +937,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -937,1 +941,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -941,1 +945,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -857,0 +857,4 @@\n+    static long valueOf(int i) {\n+        return (long) i;\n+    }\n+\n@@ -875,1 +879,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -879,1 +883,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -883,1 +887,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -933,1 +937,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -937,1 +941,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -941,1 +945,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -857,0 +857,4 @@\n+    static long valueOf(int i) {\n+        return (long) i;\n+    }\n+\n@@ -875,1 +879,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -879,1 +883,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -883,1 +887,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -933,1 +937,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -937,1 +941,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -941,1 +945,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -862,0 +862,4 @@\n+    static long valueOf(int i) {\n+        return (long) i;\n+    }\n+\n@@ -880,1 +884,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -884,1 +888,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -888,1 +892,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -938,1 +942,1 @@\n-                            i -> (long)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -942,1 +946,1 @@\n-                            i -> (long)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -946,1 +950,1 @@\n-                            i -> (((long)(i + 1) == 0) ? 1 : (long)(i + 1)));\n+                            i -> (((long)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static short valueOf(int i) {\n+        return (short) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1385,1 +1389,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1387,1 +1391,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static short valueOf(int i) {\n+        return (short) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1385,1 +1389,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1387,1 +1391,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static short valueOf(int i) {\n+        return (short) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1385,1 +1389,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1387,1 +1391,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    static short valueOf(int i) {\n+        return (short) i;\n+    }\n+\n@@ -943,1 +947,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -947,1 +951,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -951,1 +955,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1385,1 +1389,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1387,1 +1391,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -905,0 +905,4 @@\n+    static short valueOf(int i) {\n+        return (short) i;\n+    }\n+\n@@ -948,1 +952,1 @@\n-                            i -> (short)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -952,1 +956,1 @@\n-                            i -> (short)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -956,1 +960,1 @@\n-                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+                            i -> (((short)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1390,1 +1394,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1392,1 +1396,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -586,6 +586,6 @@\n-  gen_binary_alu_op \"ADD\" \"Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue()))\" \"Halffloat\"\n-  gen_binary_alu_op \"SUB\" \"Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue()))\" \"Halffloat\"\n-  gen_binary_alu_op \"MUL\" \"Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \\* Halffloat.valueOf(b).floatValue()))\" \"Halffloat\"\n-  gen_binary_alu_op \"DIV\" \"Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \\\/ Halffloat.valueOf(b).floatValue()))\" \"Halffloat\"\n-  gen_binary_alu_op \"MAX\" \"Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue()))\" \"Halffloat\"\n-  gen_binary_alu_op \"MIN\" \"Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue()))\" \"Halffloat\"\n+  gen_binary_alu_op \"ADD\" \"Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_binary_alu_op \"SUB\" \"Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_binary_alu_op \"MUL\" \"Float.floatToFloat16(Float.float16ToFloat(a) \\* Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_binary_alu_op \"DIV\" \"Float.floatToFloat16(Float.float16ToFloat(a) \\\/ Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_binary_alu_op \"MAX\" \"Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b)))\" \"Halffloat\"\n+  gen_binary_alu_op \"MIN\" \"Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b)))\" \"Halffloat\"\n@@ -594,1 +594,1 @@\n-  gen_ternary_alu_op \"FMA+fma\" \"Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue()))\" \"Halffloat\"\n+  gen_ternary_alu_op \"FMA+fma\" \"Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c)))\" \"Halffloat\"\n@@ -615,0 +615,1 @@\n+  gen_op_tmpl $blend \"blend\" \"Halffloat\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+    ClassType=$type\n+    LayoutType=$TYPE\n@@ -114,0 +116,2 @@\n+        ClassType=Halffloat\n+        LayoutType=SHORT\n@@ -119,1 +123,1 @@\n-        args=\"$args -Dtype=short -DType=Short -DTYPE=SHORT -DElementType=Halffloat\"\n+        args=\"$args -Dtype=short -DType=Halffloat -DTYPE=HALFFLOAT -DElementType=Halffloat\"\n@@ -124,2 +128,2 @@\n-    args=\"$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype -DElementType=$Type -DVecEleType=$VecEleType\"\n-    args=\"$args -Dfptype=$fptype -DFptype=$Fptype -DBoxfptype=$Boxfptype\"\n+    args=\"$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype -DElementType=$Type -DVecEleType=$VecEleType -DClassType=$ClassType\"\n+    args=\"$args -Dfptype=$fptype -DFptype=$Fptype -DBoxfptype=$Boxfptype -DLayoutType=$LayoutType\"\n@@ -172,1 +176,0 @@\n-      if [ $1 == \"ALL_PRIM_TYPES\" ]; then\n@@ -191,1 +194,0 @@\n-      fi\n@@ -194,1 +196,0 @@\n-    if [ $1 == \"ALL_PRIM_TYPES\" ]; then\n@@ -212,1 +213,0 @@\n-    fi\n@@ -267,1 +267,1 @@\n-generate_perf_tests=false\n+generate_perf_tests=true\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+#if[Halffloat]\n+import jdk.incubator.vector.Halffloat;\n+#end[Halffloat]\n@@ -50,1 +53,1 @@\n-    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+    $type$[] fill(IntFunction<$VecEleType$> f) {\n@@ -68,0 +71,6 @@\n+#if[Halffloat]\n+        as = fill(i -> Halffloat.valueOf(2*i));\n+        bs = fill(i -> Halffloat.valueOf(i+1));\n+        cs = fill(i -> Halffloat.valueOf(i+5));\n+        rs = fill(i -> Halffloat.valueOf(0));\n+#else[Halffloat]\n@@ -72,0 +81,1 @@\n+#end[Halffloat]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-header.template","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,3 @@\n+#if[Halffloat]\n+import jdk.incubator.vector.Halffloat;\n+#end[Halffloat]\n@@ -87,1 +90,1 @@\n-    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+    $type$[] fill(IntFunction<$VecEleType$> f) {\n@@ -103,0 +106,6 @@\n+#if[Halffloat]\n+        a = fill(i -> Halffloat.valueOf(2*i));\n+        b = fill(i -> Halffloat.valueOf(i+1));\n+        c = fill(i -> Halffloat.valueOf(i+5));\n+        r = fill(i -> Halffloat.valueOf(0));\n+#else[Halffloat]\n@@ -107,0 +116,1 @@\n+#end[Halffloat]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-header.template","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-#if[!Halffloat]\n@@ -14,0 +13,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i]));\n+#else[Halffloat]\n@@ -15,0 +17,1 @@\n+#end[Halffloat]\n@@ -30,0 +33,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i]));\n+#else[Halffloat]\n@@ -31,0 +37,1 @@\n+#end[Halffloat]\n@@ -127,0 +134,3 @@\n+#if[Halffloat]\n+            res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+#else[Halffloat]\n@@ -128,0 +138,1 @@\n+#end[Halffloat]\n@@ -166,0 +177,3 @@\n+#if[Halffloat]\n+                res = Float.floatToFloat16(Float.float16ToFloat(res) + Float.float16ToFloat(a[i]));\n+#else[Halffloat]\n@@ -167,0 +181,1 @@\n+#end[Halffloat]\n@@ -236,12 +251,0 @@\n-#else[!Halffloat]\n-    \/\/ TODO: Fix and Enable lt$vectorteststype$BroadcastSmokeTest\n-    \/\/ TODO: Fix and Enable eq$vectorteststype$BroadcastMaskedSmokeTest\n-    \/\/ TODO: Fix and Enable toLongArray$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable toDoubleArray$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable toString$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable hashCode$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable ADDReduceLong$vectorteststype$\n-    \/\/ TODO: Fix and Enable ADDReduceLong$vectorteststype$Masked\n-    \/\/ TODO: Fix and Enable BroadcastLong$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable blend$vectorteststype$BroadcastLongSmokeTest\n-#end[!Halffloat]\n@@ -293,1 +296,0 @@\n-#if[!Halffloat]\n@@ -500,13 +502,0 @@\n-#else[!Halffloat]\n-    \/\/ TODO: Fix and Enable SelectFrom$vectorteststype$\n-    \/\/ TODO: Fix and Enable SelectFrom$vectorteststype$MaskedSmokeTest\n-    \/\/ TODO: Fix and Enable shuffleMiscellaneous$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable shuffleToString$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable shuffleEquals$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable maskEquals$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable maskEq$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable maskHashCode$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable maskTrueCount$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable maskLastTrue$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable maskFirstTrue$vectorteststype$SmokeTest\n-#end[!Halffloat]\n@@ -561,1 +550,0 @@\n-#if[!Halffloat]\n@@ -636,1 +624,1 @@\n-        VectorSpecies species = vsh.withLanes($type$.class);\n+        VectorSpecies species = vsh.withLanes($ClassType$.class);\n@@ -643,1 +631,1 @@\n-        assert(av.species().elementType() == $type$.class);\n+        assert(av.species().elementType() == $ClassType$.class);\n@@ -661,1 +649,1 @@\n-        VectorSpecies species = av.species().withLanes($type$.class);\n+        VectorSpecies species = av.species().withLanes($ClassType$.class);\n@@ -679,15 +667,0 @@\n-#else[!Halffloat]\n-    \/\/ TODO: Fix and Enable indexInRange$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable indexInRangeLong$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable loopBound$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable loopBoundLong$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable ElementSize$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable VectorShape$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable ShapeWithLanes$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable ElementType$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable SpeciesElementSize$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable VectorType$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable WithLanes$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable WithShape$vectorteststype$SmokeTest\n-    \/\/ TODO: Fix and Enable MaskAllTrue$vectorteststype$SmokeTest\n-#end[!Halffloat]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":19,"deletions":46,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1038,0 +1038,8 @@\n+    static $type$ valueOf(int i) {\n+#if[Halffloat]\n+        return (short) Halffloat.valueOf(i);\n+#else[Halffloat]\n+        return ($type$) i;\n+#end[Halffloat]\n+    }\n+\n@@ -1056,1 +1064,1 @@\n-            withToString(\"$type$[-i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[-i * 5]\", (int s) -> {\n@@ -1058,1 +1066,1 @@\n-                            i -> ($type$)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1060,1 +1068,1 @@\n-            withToString(\"$type$[i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[i * 5]\", (int s) -> {\n@@ -1062,1 +1070,1 @@\n-                            i -> ($type$)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1064,1 +1072,1 @@\n-            withToString(\"$type$[i + 1]\", (int s) -> {\n+            withToString(\"$ClassType$[i + 1]\", (int s) -> {\n@@ -1066,1 +1074,1 @@\n-                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+                            i -> ((($type$)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1068,1 +1076,1 @@\n-            withToString(\"$type$[intCornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"$ClassType$[intCornerCaseValue(i)]\", (int s) -> {\n@@ -1080,0 +1088,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(r[i], (int)Float.float16ToFloat(a[i+offs]));\n+#else[Halffloat]\n@@ -1081,0 +1092,1 @@\n+#end[Halffloat]\n@@ -1104,0 +1116,8 @@\n+    static $type$ valueOf(long i) {\n+#if[Halffloat]\n+        return (short) Halffloat.valueOf(i);\n+#else[Halffloat]\n+        return ($type$) i;\n+#end[Halffloat]\n+    }\n+\n@@ -1105,1 +1125,1 @@\n-            withToString(\"$type$[-i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[-i * 5]\", (int s) -> {\n@@ -1107,1 +1127,1 @@\n-                            i -> ($type$)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1109,1 +1129,1 @@\n-            withToString(\"$type$[i * 5]\", (int s) -> {\n+            withToString(\"Halffloat[i * 5]\", (int s) -> {\n@@ -1111,1 +1131,1 @@\n-                            i -> ($type$)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1113,1 +1133,1 @@\n-            withToString(\"$type$[i + 1]\", (int s) -> {\n+            withToString(\"Halffloat[i + 1]\", (int s) -> {\n@@ -1115,1 +1135,1 @@\n-                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+                            i -> ((($type$)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1117,1 +1137,1 @@\n-            withToString(\"$type$[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"Halffloat[cornerCaseValue(i)]\", (int s) -> {\n@@ -1142,0 +1162,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(r[i], (long)Float.float16ToFloat(a[i+offs]));\n+#else[Halffloat]\n@@ -1143,0 +1166,1 @@\n+#end[Halffloat]\n@@ -1154,0 +1178,3 @@\n+#if[Halffloat]\n+                Assert.assertEquals(r[i], (double)Float.float16ToFloat(a[i+offs]));\n+#else[Halffloat]\n@@ -1155,0 +1182,1 @@\n+#end[Halffloat]\n@@ -1167,1 +1195,1 @@\n-            withToString(\"$type$[-i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[-i * 5]\", (int s) -> {\n@@ -1169,1 +1197,1 @@\n-                            i -> ($type$)(-i * 5));\n+                            i -> valueOf(-i * 5));\n@@ -1171,1 +1199,1 @@\n-            withToString(\"$type$[i * 5]\", (int s) -> {\n+            withToString(\"$ClassType$[i * 5]\", (int s) -> {\n@@ -1173,1 +1201,1 @@\n-                            i -> ($type$)(i * 5));\n+                            i -> valueOf(i * 5));\n@@ -1175,1 +1203,1 @@\n-            withToString(\"$type$[i + 1]\", (int s) -> {\n+            withToString(\"$ClassType$[i + 1]\", (int s) -> {\n@@ -1177,1 +1205,1 @@\n-                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+                            i -> ((($type$)(i + 1) == 0) ? valueOf(1) : valueOf(i + 1)));\n@@ -1179,1 +1207,1 @@\n-            withToString(\"$type$[cornerCaseValue(i)]\", (int s) -> {\n+            withToString(\"$ClassType$[cornerCaseValue(i)]\", (int s) -> {\n@@ -1668,3 +1696,0 @@\n-#if[Halffloat]\n-    \/\/ TODO: Fix and Enable smokeTest1, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n-#else[Halffloat]\n@@ -1673,0 +1698,22 @@\n+#if[Halffloat]\n+        $abstractvectortype$ three = $abstractvectortype$.broadcast(SPECIES, Halffloat.valueOf(-3));\n+        $abstractvectortype$ three2 = ($abstractvectortype$) SPECIES.broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three2).allTrue());\n+        $abstractvectortype$ three3 = three2.broadcast(Halffloat.valueOf(1)).broadcast(Halffloat.valueOf(-3));\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        Class<?> ETYPE = $type$.class;\n+        if (ETYPE == double.class || ETYPE == long.class)\n+            scale = 1000000;\n+        else if (ETYPE == byte.class && SPECIES.length() >= 64)\n+            scale = 1;\n+        $abstractvectortype$ higher = three.addIndex(scale);\n+        VectorMask<$Boxtype$> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min((Halffloat.valueOf(-1))).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+        $type$ max = higher.reduceLanes(VectorOperators.MAX);\n+        assert((short) Float.float16ToFloat(max) == -3 + scale * (SPECIES.length()-1));\n+#else[Halffloat]\n@@ -1695,1 +1742,0 @@\n-    }\n@@ -1697,0 +1743,1 @@\n+    }\n@@ -1750,1 +1797,0 @@\n-#if[!Halffloat]\n@@ -1773,1 +1819,1 @@\n-#if[byteOrShort]\n+#if[byte]\n@@ -1779,1 +1825,1 @@\n-#else[byteOrShort]\n+#else[byte]\n@@ -1790,1 +1836,1 @@\n-#end[byteOrShort]\n+#end[byte]\n@@ -1792,1 +1838,0 @@\n-#end[!Halffloat]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":75,"deletions":30,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-            ms.set(ValueLayout.JAVA_$TYPE$, i * SPECIES.elementSize() \/ 8 , a[i]);\n+            ms.set(ValueLayout.JAVA_$LayoutType$, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -256,1 +256,1 @@\n-        return ms.toArray(ValueLayout.JAVA_$TYPE$);\n+        return ms.toArray(ValueLayout.JAVA_$LayoutType$);\n@@ -485,1 +485,0 @@\n-#if[!Halffloat]\n@@ -599,3 +598,0 @@\n-#else[!Halffloat]\n-    \/\/ TODO: Fix and Enable loadStoreMemorySegment, loadMemorySegmentIOOBE, storeMemorySegmentIOOBE, loadStoreMemorySegmentMask\n-#end[!Halffloat]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,748 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Halffloat128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Halffloat.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> Halffloat.valueOf(2*i));\n+        b = fill(i -> Halffloat.valueOf(i+1));\n+        c = fill(i -> Halffloat.valueOf(i+5));\n+        r = fill(i -> Halffloat.valueOf(0));\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Halffloat128Vector.java","additions":748,"deletions":0,"binary":false,"changes":748,"status":"added"},{"patch":"@@ -0,0 +1,748 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Halffloat256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Halffloat.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> Halffloat.valueOf(2*i));\n+        b = fill(i -> Halffloat.valueOf(i+1));\n+        c = fill(i -> Halffloat.valueOf(i+5));\n+        r = fill(i -> Halffloat.valueOf(0));\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Halffloat256Vector.java","additions":748,"deletions":0,"binary":false,"changes":748,"status":"added"},{"patch":"@@ -0,0 +1,748 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Halffloat512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Halffloat.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> Halffloat.valueOf(2*i));\n+        b = fill(i -> Halffloat.valueOf(i+1));\n+        c = fill(i -> Halffloat.valueOf(i+5));\n+        r = fill(i -> Halffloat.valueOf(0));\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Halffloat512Vector.java","additions":748,"deletions":0,"binary":false,"changes":748,"status":"added"},{"patch":"@@ -0,0 +1,748 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Halffloat64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Halffloat.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> Halffloat.valueOf(2*i));\n+        b = fill(i -> Halffloat.valueOf(i+1));\n+        c = fill(i -> Halffloat.valueOf(i+5));\n+        r = fill(i -> Halffloat.valueOf(0));\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Halffloat64Vector.java","additions":748,"deletions":0,"binary":false,"changes":748,"status":"added"},{"patch":"@@ -0,0 +1,748 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class HalffloatMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Halffloat> SPECIES = HalffloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static short firstNonZero(short a, short b) {\n+        return Halffloat.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> Halffloat.valueOf(2*i));\n+        b = fill(i -> Halffloat.valueOf(i+1));\n+        c = fill(i -> Halffloat.valueOf(i+5));\n+        r = fill(i -> Halffloat.valueOf(0));\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/HalffloatMaxVector.java","additions":748,"deletions":0,"binary":false,"changes":748,"status":"added"},{"patch":"@@ -0,0 +1,493 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import jdk.incubator.vector.Halffloat;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class HalffloatScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static short bits(short e) {\n+        return Halffloat.shortToShortBits(e);\n+    }\n+\n+    short[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> Halffloat.valueOf(2*i));\n+        bs = fill(i -> Halffloat.valueOf(i+1));\n+        cs = fill(i -> Halffloat.valueOf(i+5));\n+        rs = fill(i -> Halffloat.valueOf(0));\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> as;\n+    final IntFunction<short[]> fb = vl -> bs;\n+    final IntFunction<short[]> fc = vl -> cs;\n+    final IntFunction<short[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) + Float.float16ToFloat(b)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) - Float.float16ToFloat(b)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) * Float.float16ToFloat(b)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Float.float16ToFloat(a) \/ Float.float16ToFloat(b)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAXMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Math.max(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MINMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Halffloat.valueOf(Math.min(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(Math.abs(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(Math.abs(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(-a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(-a) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] cs = fc.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                short c = cs[i];\n+                rs[i] = (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] cs = fc.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                short c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(Float.floatToFloat16(Math.fma(Float.float16ToFloat(a), Float.float16ToFloat(b), Float.float16ToFloat(c))));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a)))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/HalffloatScalar.java","additions":493,"deletions":0,"binary":false,"changes":493,"status":"added"}]}