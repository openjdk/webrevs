{"files":[{"patch":"@@ -57,0 +57,5 @@\n+        <dependency>\n+            <groupId>org.openjdk.jcstress<\/groupId>\n+            <artifactId>jcstress-samples<\/artifactId>\n+            <version>${project.version}<\/version>\n+        <\/dependency>\n@@ -65,1 +70,1 @@\n-        <jmh.version>1.36<\/jmh.version>\n+        <jmh.version>1.37<\/jmh.version>\n","filename":"jcstress-benchmarks\/pom.xml","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jcstress;\n+\n+import org.openjdk.jcstress.samples.primitives.lazy.*;\n+import org.openjdk.jcstress.samples.primitives.lazy.shared.Lazy;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 5, jvmArgs = {\"-Xmx1g\", \"-Xms1g\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+public class LazyBench {\n+\n+    Lazy<Object> lazy;\n+\n+    @Param({\"broken-factory\", \"broken-nulls\", \"basic\", \"broken-one-shot\", \"wrapper-one-shot\", \"fenced-one-shot\"})\n+    String impl;\n+\n+    public Lazy<Object> createLazy() {\n+        switch (impl) {\n+            case \"broken-factory\":\n+                return new Lazy_01_BrokenFactory.BrokenFactoryLazy<>(() -> new Object());\n+            case \"broken-nulls\":\n+                return new Lazy_02_BrokenNulls.BrokenNullsLazy<>(() -> new Object());\n+            case \"basic\":\n+                return new Lazy_03_Basic.BasicLazy<>(() -> new Object());\n+            case \"broken-one-shot\":\n+                return new Lazy_04_BrokenOneShot.BrokenOneShotLazy<>(() -> new Object());\n+            case \"wrapper-one-shot\":\n+                return new Lazy_05_WrapperOneShot.FinalWrapperLazy<>(() -> new Object());\n+            case \"fenced-one-shot\":\n+                return new Lazy_06_FencedOneShot.FencedOneShot<>(() -> new Object());\n+            default:\n+                throw new IllegalArgumentException(\"Unknown factory: \" + impl);\n+        }\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        lazy = createLazy();\n+    }\n+\n+    @Benchmark\n+    public Object uncontended() {\n+        return lazy.get();\n+    }\n+\n+    @Benchmark\n+    @Threads(Threads.MAX)\n+    public Object contended() {\n+        return lazy.get();\n+    }\n+\n+}\n","filename":"jcstress-benchmarks\/src\/main\/java\/org\/openjdk\/jcstress\/LazyBench.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jcstress;\n+\n+import org.openjdk.jcstress.samples.primitives.singletons.shared.FinalSingleton;\n+import org.openjdk.jcstress.samples.primitives.singletons.*;\n+import org.openjdk.jcstress.samples.primitives.singletons.shared.Factory;\n+import org.openjdk.jcstress.samples.primitives.singletons.shared.Singleton;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 5, jvmArgs = {\"-Xmx1g\", \"-Xms1g\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+public class SingletonBench {\n+\n+    Factory<Singleton> factory;\n+\n+    @Param({\"unsynchronized\", \"broken-volatile\", \"inefficient-cas\", \"inefficient-synchronized\",\n+            \"dcl\", \"acquire-release-dcl\", \"broken-non-volatile-dcl\", \"final-wrapper\", \"holder\",\n+            \"thread-local-witness\"})\n+    String impl;\n+\n+    public Factory<Singleton> createFactory() {\n+        switch (impl) {\n+            case \"unsynchronized\":\n+                return new Singleton_01_BrokenUnsynchronized.Unsynchronized<>();\n+            case \"broken-volatile\":\n+                return new Singleton_02_BrokenVolatile.VolatileS<>();\n+            case \"inefficient-cas\":\n+                return new Singleton_03_InefficientCAS.CAS<>();\n+            case \"inefficient-synchronized\":\n+                return new Singleton_04_InefficientSynchronized.Synchronized<>();\n+            case \"dcl\":\n+                return new Singleton_05_DCL.DCL<>();\n+            case \"acquire-release-dcl\":\n+                return new Singleton_06_AcquireReleaseDCL.AcquireReleaseDCL<>();\n+            case \"broken-non-volatile-dcl\":\n+                return new Singleton_07_BrokenNonVolatileDCL.NonVolatileDCL<>();\n+            case \"final-wrapper\":\n+                return new Singleton_08_FinalWrapper.FinalWrapper<>();\n+            case \"holder\":\n+                return new Singleton_09_Holder.FinalHolderHolder();\n+            case \"thread-local-witness\":\n+                return new Singleton_10_ThreadLocalWitness.ThreadLocalWitness<>();\n+            default:\n+                throw new IllegalArgumentException(\"Unknown factory: \" + impl);\n+        }\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        factory = createFactory();\n+    }\n+\n+    @Benchmark\n+    public Object uncontended() {\n+        return factory.get(() -> new FinalSingleton(\"data\"));\n+    }\n+\n+    @Benchmark\n+    @Threads(Threads.MAX)\n+    public Object contended() {\n+        return factory.get(() -> new FinalSingleton(\"data\"));\n+    }\n+\n+}\n","filename":"jcstress-benchmarks\/src\/main\/java\/org\/openjdk\/jcstress\/SingletonBench.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -62,1 +62,1 @@\n-    static class BrokenFactoryLazy<T> implements Lazy<T> {\n+    public static class BrokenFactoryLazy<T> implements Lazy<T> {\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/primitives\/lazy\/Lazy_01_BrokenFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    static class BrokenNullsLazy<T> implements Lazy<T> {\n+    public static class BrokenNullsLazy<T> implements Lazy<T> {\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/primitives\/lazy\/Lazy_02_BrokenNulls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    static class BasicLazy<T> implements Lazy<T> {\n+    public static class BasicLazy<T> implements Lazy<T> {\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/primitives\/lazy\/Lazy_03_Basic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    static class BrokenOneShotLazy<T> implements Lazy<T> {\n+    public static class BrokenOneShotLazy<T> implements Lazy<T> {\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/primitives\/lazy\/Lazy_04_BrokenOneShot.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    static class FinalWrapperLazy<T> implements Lazy<T> {\n+    public static class FinalWrapperLazy<T> implements Lazy<T> {\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/primitives\/lazy\/Lazy_05_WrapperOneShot.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.samples.primitives.lazy;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.LL_Result;\n+import org.openjdk.jcstress.infra.results.L_Result;\n+import org.openjdk.jcstress.samples.primitives.lazy.shared.Holder;\n+import org.openjdk.jcstress.samples.primitives.lazy.shared.HolderFactory;\n+import org.openjdk.jcstress.samples.primitives.lazy.shared.Lazy;\n+import org.openjdk.jcstress.samples.primitives.lazy.shared.NullHolderFactory;\n+\n+import java.lang.invoke.VarHandle;\n+import java.util.function.Supplier;\n+\n+import static org.openjdk.jcstress.annotations.Expect.ACCEPTABLE;\n+\n+public class Lazy_06_FencedOneShot {\n+\n+   \/*\n+        How to run this test:\n+            $ java -jar jcstress-samples\/target\/jcstress.jar -t Lazy_06\n+    *\/\n+\n+    \/*\n+        ----------------------------------------------------------------------------------------------------------\n+\n+        There is an alternative to Lazy_05_WrapperOneShot: emulating the final field semantics by using\n+        the explicit fence in constructor. Note this is a very sharp-edged tool, because it forces us to\n+        think outside the formal language guarantees. JDK sometimes do this trick in class libraries,\n+        where the code is under 100% JDK control and can be amended at any time, if broken.\n+\n+        This example is provided for completeness. Reliable code should not use the constructions like this,\n+        unless there is a quick way to fix it when it is proven to be broken.\n+     *\/\n+\n+    public static class FencedOneShot<T> implements Lazy<T> {\n+        private volatile Supplier<T> factory;\n+        private T instance;\n+\n+        public FencedOneShot(Supplier<T> factory) {\n+            this.factory = factory;\n+            VarHandle.storeStoreFence();\n+        }\n+\n+        @Override\n+        public T get() {\n+            if (factory == null) {\n+                return instance;\n+            }\n+\n+            synchronized (this) {\n+                if (factory != null) {\n+                    instance = factory.get();\n+                    factory = null;\n+                }\n+                return instance;\n+            }\n+        }\n+    }\n+\n+    \/*\n+        This works well in basic tests.\n+\n+        x86_64, AArch64:\n+              RESULT      SAMPLES     FREQ      EXPECT  DESCRIPTION\n+          data, data  722,475,464  100.00%  Acceptable  Trivial.\n+     *\/\n+\n+    @JCStressTest\n+    @State\n+    @Outcome(id = \"data, data\", expect = ACCEPTABLE, desc = \"Trivial.\")\n+    public static class Basic {\n+        Lazy<Holder> lazy = new FencedOneShot<>(new HolderFactory());\n+        @Actor public void actor1(LL_Result r) { r.r1 = Lazy.map(lazy); }\n+        @Actor public void actor2(LL_Result r) { r.r2 = Lazy.map(lazy); }\n+    }\n+\n+    \/*\n+        This keeps handling null-s well.\n+\n+        x86_64, AArch64:\n+                            RESULT      SAMPLES     FREQ      EXPECT  DESCRIPTION\n+          null-holder, null-holder  805,962,184  100.00%  Acceptable  Seeing a null holder.\n+     *\/\n+\n+    @JCStressTest\n+    @State\n+    @Outcome(id = \"null-holder, null-holder\", expect = ACCEPTABLE, desc = \"Seeing a null holder.\")\n+    public static class NullHolder {\n+        Lazy<Holder> lazy = new FencedOneShot<>(new NullHolderFactory());\n+        @Actor public void actor1(LL_Result r) { r.r1 = Lazy.map(lazy); }\n+        @Actor public void actor2(LL_Result r) { r.r2 = Lazy.map(lazy); }\n+    }\n+\n+    \/*\n+        And, of course, it survives races on Lazy instance itself.\n+\n+        x86_64, AArch64:\n+             RESULT        SAMPLES     FREQ      EXPECT  DESCRIPTION\n+               data    645,079,245   30.00%  Acceptable  Trivial.\n+          null-lazy  1,505,528,059   70.00%  Acceptable  Lazy instance not seen yet.\n+     *\/\n+\n+    @JCStressTest\n+    @State\n+    @Outcome(id = \"data\",      expect = ACCEPTABLE, desc = \"Trivial.\")\n+    @Outcome(id = \"null-lazy\", expect = ACCEPTABLE, desc = \"Lazy instance not seen yet.\")\n+    public static class RacyOneWay {\n+        Lazy<Holder> lazy;\n+        @Actor public void actor1()           { lazy = new FencedOneShot<>(new HolderFactory()); }\n+        @Actor public void actor2(L_Result r) { r.r1 = Lazy.map(lazy); }\n+    }\n+\n+    \/*\n+       x86_64, AArch64:\n+                    RESULT        SAMPLES     FREQ      EXPECT  DESCRIPTION\n+                data, data    527,940,924   12.44%  Acceptable  Trivial.\n+           data, null-lazy    610,097,483   14.37%  Acceptable  Lazy instance not seen yet.\n+           null-lazy, data    731,296,132   17.23%  Acceptable  Lazy instance not seen yet.\n+      null-lazy, null-lazy  2,375,169,585   55.96%  Acceptable  Lazy instance not seen yet.\n+     *\/\n+\n+    @JCStressTest\n+    @State\n+    @Outcome(id = \"data, data\", expect = ACCEPTABLE, desc = \"Trivial.\")\n+    @Outcome(id = {\"null-lazy, data\", \"data, null-lazy\", \"null-lazy, null-lazy\"}, expect = ACCEPTABLE, desc = \"Lazy instance not seen yet.\")\n+    public static class RacyTwoWay {\n+        Lazy<Holder> lazy;\n+        @Actor public void actor1() { lazy = new FencedOneShot<>(new HolderFactory()); }\n+        @Actor public void actor2(LL_Result r) { r.r1 = Lazy.map(lazy); }\n+        @Actor public void actor3(LL_Result r) { r.r2 = Lazy.map(lazy); }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/primitives\/lazy\/Lazy_06_FencedOneShot.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+# Lazy Performance\n+\n+While these samples are here to reason about correctness, a common question is also about the relative\n+performance of these implementations. Without going too deep into perf analysis, `LazyBench` from\n+`jcstress-benchmarks` would show something like this on beefy AArch64 machine.\n+\n+## Uncontended Case\n+\n+```\n+Benchmark                        (impl)  Mode  Cnt  Score    Error  Units\n+LazyBench.uncontended    broken-factory  avgt   25  1.004 ±  0.080  ns\/op\n+LazyBench.uncontended      broken-nulls  avgt   25  0.891 ±  0.022  ns\/op\n+LazyBench.uncontended             basic  avgt   25  1.038 ±  0.030  ns\/op\n+LazyBench.uncontended   broken-one-shot  avgt   25  1.040 ±  0.045  ns\/op\n+LazyBench.uncontended  wrapper-one-shot  avgt   25  1.295 ±  0.048  ns\/op\n+LazyBench.uncontended   fenced-one-shot  avgt   25  1.068 ±  0.027  ns\/op\n+```\n+\n+### Broken Nulls\n+\n+This test is ahead of other tests, because it has to do only a single read on the fast path:\n+\n+```\n+   5.49%  ↗   0x0000ffff6fed14c0:   ldr        w10, [x15, #12]             ; get field \"lazy\"\n+   4.99%  │   0x0000ffff6fed14c4:   ldr        w14, [x10, #8]              ; typecheck for Lazy subtype\n+  15.96%  │   0x0000ffff6fed14c8:   cmp        w14, w12\n+          │   0x0000ffff6fed14cc:   b.ne       0x0000ffff6fed1540  \/\/ b.any\n+  15.35%  │   0x0000ffff6fed14d0:   mov        x13, x10\n+   1.92%  │   0x0000ffff6fed14d4:   add        x10, x13, #0x10\n+   5.02%  │   0x0000ffff6fed14d8:   ldar       w10, [x10]                  ; get field \"instance\"     <--- HERE\n+   5.93%  │   0x0000ffff6fed14dc:   cbz        w10, 0x0000ffff6fed1568     ; null check \"instance\"\n+          |                       <poof: our result is in w10, blackholed>\n+  16.60%  │   0x0000ffff6fed14e0:   ldarb      w14, [x11]                  ; JMH: get field \"isDone\"\n+   5.15%  │   0x0000ffff6fed14e4:   ldr        x10, [x28, #48]             ; JVM: safepoint poll, part 1\n+          │   0x0000ffff6fed14e8:   add        x19, x19, #0x1              ; JMH: ops++\n+   4.78%  │   0x0000ffff6fed14ec:   ldr        wzr, [x10]                  ; JVM: safepoint poll, part 2\n+  10.98%  ╰   0x0000ffff6fed14f0:   cbz        w14, 0x0000ffff6fed14c0     ; JMH: loop\n+```\n+\n+### Basic\n+\n+The variants of `basic` test, including `broken-one-shot`, `fenced-one-shot`, `broken-factory` show the same fast path,\n+where the cost is the atomic load of `factory`, and non-atomic load of `instance`:\n+\n+```\n+   4.76%  ↗   0x0000ffff83ed09c0:   ldr        w11, [x15, #12]             ; get field \"lazy\"\n+   4.30%  │   0x0000ffff83ed09c4:   ldr        w13, [x11, #8]              ; typecheck for Lazy subtype\n+  16.76%  │   0x0000ffff83ed09c8:   cmp        w13, w10\n+          │   0x0000ffff83ed09cc:   b.ne       0x0000ffff83ed0a44\n+  13.52%  │   0x0000ffff83ed09d0:   add        x13, x11, #0xc\n+   4.67%  │   0x0000ffff83ed09d4:   ldarb      w14, [x13]                  ; get field \"factory\"       <--- HERE\n+   4.83%  │   0x0000ffff83ed09d8:   cbz        w14, 0x0000ffff83ed0a6c     ; null check \"factory\"\n+  13.45%  │   0x0000ffff83ed09dc:   ldarb      w13, [x12]                  ; JMH: get field \"isDone\"\n+   4.06%  │   0x0000ffff83ed09e0:   ldr        w14, [x11, #20]             ; get field \"instance\"      <--- AND HERE\n+   0.50%  │   0x0000ffff83ed09e4:   mov        x11, x14                    \n+          |                       <poof: our result is in x11, blackholed>\n+   4.43%  │   0x0000ffff83ed09e8:   ldr        x14, [x28, #48]             ; JVM: safepoint poll, part 1\n+   0.55%  │   0x0000ffff83ed09ec:   add        x19, x19, #0x1              ; JMH: ops++\n+   4.10%  │   0x0000ffff83ed09f0:   ldr        wzr, [x14]                  ; JVM: safepoint poll, part 2\n+  15.08%  ╰   0x0000ffff83ed09f4:   cbz        w13, 0x0000ffff83ed09c0     ; JMH: loop\n+```\n+\n+### Wrapper One Shot\n+\n+This test is a bit behind other tests, because it has to do the additional memory dereference on fast path:\n+\n+```\n+   3.70%  ↗   0x0000ffff83ed0510:   ldr        w10, [x13, #12]             ; get field \"lazy\"\n+   3.19%  │   0x0000ffff83ed0514:   ldr        w12, [x10, #8]              ; typecheck for Lazy subtype\n+   4.23%  │   0x0000ffff83ed0518:   cmp        w12, w15\n+          │   0x0000ffff83ed051c:   b.ne       0x0000ffff83ed05c8  \/\/ b.any\n+   4.21%  │   0x0000ffff83ed0520:   mov        x12, x10\n+   3.22%  │   0x0000ffff83ed0524:   ldr        w10, [x12, #12]             ; get field \"wrapper\"      <--- HERE\n+   0.46%  │   0x0000ffff83ed0528:   mov        x14, x10                    ; null check \"wrapper\"\n+   2.84%  │   0x0000ffff83ed052c:   cbz        w10, 0x0000ffff83ed05a4\n+   3.50%  │   0x0000ffff83ed0530:   add        x10, x14, #0xc\n+   3.74%  │   0x0000ffff83ed0534:   ldar       w10, [x10]                  ; get field \"factory\"      <--- AND HERE\n+  30.34%  │   0x0000ffff83ed0538:   cbnz       w10, 0x0000ffff83ed05f0     ; null check \"factory\"\n+  15.99%  │   0x0000ffff83ed053c:   ldarb      w14, [x11]                  : JMH: get field \"isDone\"\n+   3.35%  │   0x0000ffff83ed0540:   ldr        w12, [x12, #16]             ; get field \"instance\"     <--- AND HERE\n+   0.57%  │   0x0000ffff83ed0544:   mov        x10, x12\n+          |                       <poof: our result is in x10, blackholed>\n+   3.65%  │   0x0000ffff83ed0548:   ldr        x12, [x28, #48]             ; JVM: safepoint poll, part 1\n+          │   0x0000ffff83ed054c:   add        x19, x19, #0x1              ; JMH: ops++\n+   3.85%  │   0x0000ffff83ed0550:   ldr        wzr, [x12]                  ; JVM: safepoint poll, part 2\n+   3.90%  ╰   0x0000ffff83ed0554:   cbz        w14, 0x0000ffff83ed0510     ; JMH: loop\n+```\n+\n+## Contended Case\n+\n+```\n+Benchmark                        (impl)  Mode  Cnt  Score    Error  Units\n+LazyBench.contended      broken-factory  avgt   25  1.011 ±  0.048  ns\/op\n+LazyBench.contended        broken-nulls  avgt   25  0.903 ±  0.016  ns\/op\n+LazyBench.contended               basic  avgt   25  1.027 ±  0.023  ns\/op\n+LazyBench.contended     broken-one-shot  avgt   25  1.016 ±  0.021  ns\/op\n+LazyBench.contended    wrapper-one-shot  avgt   25  1.295 ±  0.013  ns\/op\n+LazyBench.contended     fenced-one-shot  avgt   25  1.038 ±  0.026  ns\/op\n+```\n+\n+As expected, all test behave similarly under contention.\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/primitives\/lazy\/performance.md","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -61,1 +61,1 @@\n-                return w.value;\n+                return w.instance;\n@@ -68,1 +68,1 @@\n-                return wrapper.value;\n+                return wrapper.instance;\n@@ -73,3 +73,3 @@\n-            public final T value;\n-            public Wrapper(T value) {\n-                this.value = value;\n+            public final T instance;\n+            public Wrapper(T instance) {\n+                this.instance = instance;\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/primitives\/singletons\/Singleton_08_FinalWrapper.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    static class ThreadLocalWitness<T> implements Factory<T> {\n+    public static class ThreadLocalWitness<T> implements Factory<T> {\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/primitives\/singletons\/Singleton_10_ThreadLocalWitness.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+# Singleton Performance\n+\n+While these samples are here to reason about correctness, a common question is also about the relative\n+performance of these implementations. Without going too deep into perf analysis, `SingletonBench` from\n+`jcstress-benchmarks` would show something like this on beefy AArch64 machine.\n+\n+## Uncontended Case\n+\n+```\n+\n+Benchmark                                     (impl)  Mode  Cnt     Score      Error  Units\n+\n+SingletonBench.uncontended            unsynchronized  avgt   25     0.886 ±    0.020  ns\/op\n+SingletonBench.uncontended           broken-volatile  avgt   25     1.032 ±    0.032  ns\/op\n+SingletonBench.uncontended           inefficient-cas  avgt   25     1.487 ±    0.027  ns\/op\n+SingletonBench.uncontended  inefficient-synchronized  avgt   25    19.590 ±    0.243  ns\/op\n+SingletonBench.uncontended                       dcl  avgt   25     0.913 ±    0.059  ns\/op\n+SingletonBench.uncontended       acquire-release-dcl  avgt   25     0.989 ±    0.051  ns\/op\n+SingletonBench.uncontended   broken-non-volatile-dcl  avgt   25     0.867 ±    0.014  ns\/op\n+SingletonBench.uncontended             final-wrapper  avgt   25     1.038 ±    0.035  ns\/op\n+SingletonBench.uncontended                    holder  avgt   25     0.654 ±    0.018  ns\/op\n+SingletonBench.uncontended      thread-local-witness  avgt   25     2.710 ±    0.013  ns\/op\n+```\n+\n+### Holder\n+\n+Holder is beyond reach, because JIT compilers are able to fold the whole thing to a\n+constant access.\n+\n+```\n+   7.10%  ↗   0x0000ffff67ba0d00:   ldr        w10, [x15, #12]             ; get field `factory`\n+   7.10%  │   0x0000ffff67ba0d04:   ldr        w13, [x10, #8]              ; type-check `factory`\n+  25.75%  │   0x0000ffff67ba0d08:   cmp        w13, w14\n+          │   0x0000ffff67ba0d0c:   b.ne       0x0000ffff67ba0d74  \n+          |                       <poof: \"constant load\" was blackholed>\n+  22.83%  │   0x0000ffff67ba0d10:   ldarb      w10, [x12]                  ; JMH: get field `isDone`\n+   7.20%  │   0x0000ffff67ba0d14:   ldr        x13, [x28, #48]             ; JVM: safepoint poll, part 1\n+   0.00%  │   0x0000ffff67ba0d18:   add        x20, x20, #0x1              ; JMH: ops++\n+   7.13%  │   0x0000ffff67ba0d1c:   ldr        wzr, [x13]                  ; JVM: safepoint poll, part 2\n+  19.59%  ╰   0x0000ffff67ba0d20:   cbz        w10, 0x0000ffff67ba0d00     ; JMH: not done?\n+```\n+\n+### DCLs\n+\n+Double-checked locking idioms are nearly as fast. The cost they pay are going through\n+the acquire-load.\n+\n+```\n+   4.04%  ↗   0x0000ffff9fb95880:   ldr        w10, [x15, #12]             ; get field `factory`\n+   4.81%  │   0x0000ffff9fb95884:   ldr        w14, [x10, #8]              ; type-check `factory`\n+  18.26%  │   0x0000ffff9fb95888:   cmp        w14, w12\n+          │   0x0000ffff9fb9588c:   b.ne       0x0000ffff9fb95904\n+  13.05%  │   0x0000ffff9fb95890:   mov        x13, x10                    ; get field `factory.instance`\n+   2.04%  │   0x0000ffff9fb95894:   add        x10, x13, #0xc\n+   4.20%  │   0x0000ffff9fb95898:   ldar       w10, [x10]                  ;    <--- note ldar (acquiring load)\n+   9.88%  │   0x0000ffff9fb9589c:   cbz        w10, 0x0000ffff9fb9592c     ; null-check `factory.instance`\n+          |                       <poof: w10 is our result, blackholed>\n+  10.19%  │   0x0000ffff9fb958a0:   ldarb      w14, [x11]                  ; JMH: get field `isDone`\n+   4.48%  │   0x0000ffff9fb958a4:   ldr        x10, [x28, #48]             ; JVM: safepoint poll, part 1\n+          │   0x0000ffff9fb958a8:   add        x19, x19, #0x1              ; JMH: ops++\n+   4.48%  │   0x0000ffff9fb958ac:   ldr        wzr, [x10]                  ; JVM: safepoint poll, part 2\n+  15.49%  ╰   0x0000ffff9fb958b0:   cbz        w14, 0x0000ffff9fb95880     ; JMH: not done?\n+```\n+\n+### Wrappers (Final and CAS)\n+\n+Wrappers are a little behind, because they need another memory dereference to reach the `instance`.\n+\n+```\n+   3.92%  ↗   0x0000ffff6bdc5700:   ldr        w10, [x16, #12]             ; get field `factory`\n+   3.50%  │   0x0000ffff6bdc5704:   ldr        w14, [x10, #8]              ; type-check `factory`\n+   6.75%  │   0x0000ffff6bdc5708:   cmp        w14, w12\n+          │   0x0000ffff6bdc570c:   b.ne       0x0000ffff6bdc5780\n+   6.72%  │   0x0000ffff6bdc5710:   mov        x13, x10                    \n+   3.67%  │   0x0000ffff6bdc5714:   ldr        w10, [x13, #12]             ; get field `wrapper`\n+   4.60%  │   0x0000ffff6bdc5718:   ldr        w15, [x10, #12]             ; get field `wrapper.instance`\n+          │                      <poof: w15 is our result, blackholed>\n+  45.00%  │   0x0000ffff6bdc571c:   ldarb      w10, [x11]                  ; JMH: get field `isDone`\n+   3.41%  │   0x0000ffff6bdc5720:   mov        x13, x15                    \n+   3.40%  │   0x0000ffff6bdc5724:   ldr        x13, [x28, #48]             ; JVM: safepoint poll, part 1\n+   1.26%  │   0x0000ffff6bdc5728:   add        x19, x19, #0x1              ; JMH: ops++\n+   3.58%  │   0x0000ffff6bdc572c:   ldr        wzr, [x13]                  ; JVM: safepoint poll, part 2\n+   4.84%  ╰   0x0000ffff6bdc5730:   cbz        w10, 0x0000ffff6bdc5700     ; JMH: not done?\n+```\n+\n+CAS example gets the same, but also pays for the cost of acquiring load.\n+\n+### ThreadLocal\n+\n+`ThreadLocal.get` on the fast path costs extra.\n+\n+```\n+   1.67%  ↗   0x0000ffff6fdc6b60:   ldr        w11, [x13, #12]             ; get field `factory`\n+   1.67%  │   0x0000ffff6fdc6b64:   ldr        w12, [x11, #8]              ; type-check `factory`\n+   1.26%  │   0x0000ffff6fdc6b68:   cmp        w12, w10\n+          │   0x0000ffff6fdc6b6c:   b.ne       0x0000ffff6fdc6c2c  \/\/ b.any\n+   1.78%  │   0x0000ffff6fdc6b70:   mov        x15, x11                    \n+   1.22%  │   0x0000ffff6fdc6b74:   ldr        w12, [x15, #12]             ; ThreadLocal.get begins...\n+   1.46%  │   0x0000ffff6fdc6b78:   ldr        w18, [x16, #72]             \n+   1.56%  │   0x0000ffff6fdc6b7c:   ldr        w11, [x12, #8]              \n+   1.80%  │   0x0000ffff6fdc6b80:   cmp        w11, w1\n+          │   0x0000ffff6fdc6b84:   b.ne       0x0000ffff6fdc6c54  \/\/ b.any\n+   1.62%  │   0x0000ffff6fdc6b88:   mov        x0, x12                     \n+   1.69%  │   0x0000ffff6fdc6b8c:   ldr        w14, [x18, #20]             \n+   1.67%  │   0x0000ffff6fdc6b90:   ldr        w12, [x14, #12]             \n+   1.76%  │   0x0000ffff6fdc6b94:   ldr        w11, [x0, #12]\n+          │   0x0000ffff6fdc6b98:   sub        w4, w12, #0x1\n+   1.33%  │   0x0000ffff6fdc6b9c:   and        w11, w11, w4                \n+   1.47%  │   0x0000ffff6fdc6ba0:   mov        x4, x14                     \n+          │   0x0000ffff6fdc6ba4:   add        x4, x4, w11, sxtw #2\n+   1.33%  │   0x0000ffff6fdc6ba8:   cbz        w12, 0x0000ffff6fdc6c7c\n+   1.53%  │   0x0000ffff6fdc6bac:   ldr        w14, [x4, #16]              \n+   8.44%  │   0x0000ffff6fdc6bb0:   ldr        w12, [x14, #12]             \n+  34.02%  │   0x0000ffff6fdc6bb4:   cmp        x12, x0\n+          │   0x0000ffff6fdc6bb8:   b.ne       0x0000ffff6fdc6cb0          ; ThreadLocal.get ends.\n+  12.81%  │   0x0000ffff6fdc6bbc:   ldr        w11, [x14, #28]             ; get field `instance`\n+   2.22%  │   0x0000ffff6fdc6bc0:   cbz        w11, 0x0000ffff6fdc6cec    \n+          │                      <poof: w11 is our result, blackholed> \n+   2.00%  │   0x0000ffff6fdc6bc4:   ldarb      w11, [x3]                   ; JMH: get field `isDone`\n+   1.46%  │   0x0000ffff6fdc6bc8:   ldr        w14, [x15, #16]\n+          │   0x0000ffff6fdc6bcc:   mov        x12, x14                    \n+   1.49%  │   0x0000ffff6fdc6bd0:   ldr        x12, [x28, #48]             ; JVM: safepoint poll, part 1 \n+          │   0x0000ffff6fdc6bd4:   add        x19, x19, #0x1              ; JMH: ops++\n+   1.47%  │   0x0000ffff6fdc6bd8:   ldr        wzr, [x12]                  ; JVM: safepoint poll, part 2\n+   1.42%  ╰   0x0000ffff6fdc6bdc:   cbz        w11, 0x0000ffff6fdc6b60     ; JMH: not done?\n+```\n+\n+### Synchronized\n+\n+Synchronized case takes a lock on fast-path and that lock acquisition costs extra.\n+\n+The actual hot block would be CAS on acquring the object lock:\n+\n+```\n+          ╭   0x0000ffff6fdc6158:   b.eq       0x0000ffff6fdc617c  \/\/ b.none\n+   0.18%  │   0x0000ffff6fdc615c:   ldr        x10, [x14]\n+   0.34%  │╭  0x0000ffff6fdc6160:   tbnz       w10, #1, 0x0000ffff6fdc618c\n+   0.54%  ││  0x0000ffff6fdc6164:   orr        x10, x10, #0x1\n+          ││  0x0000ffff6fdc6168:   eor        x11, x10, #0x1\n+   0.29%  ││  0x0000ffff6fdc616c:   mov        x8, x10\n+   0.36%  ││  0x0000ffff6fdc6170:   casa       x8, x11, [x14]\n+  24.92%  ││  0x0000ffff6fdc6174:   cmp        x8, x10\n+   0.18%  ││  0x0000ffff6fdc6178:   b.ne       0x0000ffff6fdc61b8  \/\/ b.any\n+   4.95%  ↘│  0x0000ffff6fdc617c:   str        x14, [x28, x12]\n+   0.22%   │  0x0000ffff6fdc6180:   add        w12, w12, #0x8\n+   0.20%   │  0x0000ffff6fdc6184:   str        w12, [x28, #1800]\n+   0.22%   │  0x0000ffff6fdc6188:   b          0x0000ffff6fdc61b8\n+           ↘  0x0000ffff6fdc618c:   add        x12, x10, #0x3e\n+```\n+\n+## Contended Case\n+\n+```\n+Benchmark                                     (impl)  Mode  Cnt     Score      Error  Units\n+\n+SingletonBench.contended              unsynchronized  avgt   25     0.888 ±    0.013  ns\/op\n+SingletonBench.contended             broken-volatile  avgt   25     1.047 ±    0.021  ns\/op\n+SingletonBench.contended             inefficient-cas  avgt   25     1.495 ±    0.011  ns\/op\n+SingletonBench.contended    inefficient-synchronized  avgt   25  6854.528 ± 1603.611  ns\/op\n+SingletonBench.contended                         dcl  avgt   25     0.941 ±    0.044  ns\/op\n+SingletonBench.contended         acquire-release-dcl  avgt   25     1.030 ±    0.085  ns\/op\n+SingletonBench.contended     broken-non-volatile-dcl  avgt   25     0.901 ±    0.019  ns\/op\n+SingletonBench.contended               final-wrapper  avgt   25     1.056 ±    0.020  ns\/op\n+SingletonBench.contended                      holder  avgt   25     0.689 ±    0.028  ns\/op\n+SingletonBench.contended        thread-local-witness  avgt   25     2.679 ±    0.031  ns\/op\n+```\n+\n+All tests behave similarly under contention, except `synchronized` case, which falls victim\n+to major scalability bottleneck.\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/primitives\/singletons\/performance.md","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"}]}