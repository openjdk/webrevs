{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import org.openjdk.jcstress.infra.grading.FailFastKiller;\n@@ -69,1 +70,8 @@\n-        TestResultCollector mux = MuxCollector.of(printer, diskCollector);\n+        FailFastKiller failFastKiller = null;\n+        TestResultCollector mux;\n+        if (opts.isFailFast()) {\n+            failFastKiller = new FailFastKiller(opts, new PrintWriter(out, true), config.configs);\n+            mux = MuxCollector.of(printer, diskCollector, failFastKiller);\n+        } else {\n+            mux = MuxCollector.of(printer, diskCollector);\n+        }\n@@ -74,0 +82,3 @@\n+        if (failFastKiller!=null) {\n+            failFastKiller.setExecutor(executor);\n+        }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/JCStress.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -49,0 +49,4 @@\n+\n+    public static final String FAIL_FAST_TESTS = \"failFast\";\n+    public static final String FAIL_FAST_VARIANTS = \"failFAST\";\n+\n@@ -69,0 +73,2 @@\n+    private String failFastTests;\n+    private String failFastVariants;\n@@ -153,0 +159,9 @@\n+        OptionSpec<String> optFaiFastTests = parser.accepts(FAIL_FAST_TESTS, \"Tells the framework to exit after specified number of failures. \" +\n+                        \"It can be absolute number, to simply set deadline. It can be suffixed by %. The deadline is then percent from al tests, \" +\n+                        \"or by %%, when the deadline will be calculated not from all tests, but from summ of currently finished tests. Soft errors do not count\/\")\n+                .withRequiredArg().ofType(String.class).describedAs(\"N\");\n+\n+        OptionSpec<String> optFaiFastVariants = parser.accepts(FAIL_FAST_VARIANTS, \"Same as \" + FAIL_FAST_TESTS + \" only the calculation is based on all test variants. \" +\n+                        \"See listing to clear up difference.\")\n+                .withRequiredArg().ofType(String.class).describedAs(\"N\");\n+\n@@ -168,0 +183,7 @@\n+        if (set.has(FAIL_FAST_TESTS) && set.has(FAIL_FAST_VARIANTS)) {\n+            System.err.println(\"Only one from \" + FAIL_FAST_TESTS +\" and \" + FAIL_FAST_VARIANTS +\n+                    \" is allowed. You had set both.\");\n+            System.err.println();\n+            return false;\n+        }\n+\n@@ -263,0 +285,3 @@\n+        this.failFastTests = orDefault(set.valueOf(optFaiFastTests), null);\n+        this.failFastVariants = orDefault(set.valueOf(optFaiFastVariants), null);\n+\n@@ -395,0 +420,21 @@\n+    public boolean isFailFast() {\n+        checkFailFast();\n+        return getFailFast() != null;\n+    }\n+\n+    public String getFailFast() {\n+        checkFailFast();\n+        return isFailFastAllVariants()?failFastVariants:failFastTests;\n+    }\n+\n+    public boolean isFailFastAllVariants() {\n+        checkFailFast();\n+        return failFastVariants != null;\n+    }\n+\n+    private void checkFailFast() {\n+        if (failFastVariants!=null && failFastTests != null) {\n+            throw new IllegalArgumentException(\"Both \" + FAIL_FAST_TESTS + \" and \" + FAIL_FAST_VARIANTS + \" was declared, that is illegal\");\n+        }\n+    }\n+\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/Options.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    private boolean diedFast = false;\n@@ -145,1 +146,0 @@\n-\n@@ -170,0 +170,4 @@\n+            if (diedFast) {\n+                cleanup();\n+                return;\n+            }\n@@ -172,0 +176,4 @@\n+        cleanup();\n+    }\n+\n+    private void cleanup() {\n@@ -218,0 +226,8 @@\n+    public void setDiedFast() {\n+        diedFast=true;\n+    }\n+\n+    public boolean isDiedFast() {\n+        return diedFast;\n+    }\n+\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/TestExecutor.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import org.openjdk.jcstress.infra.collectors.TestResultCollector;\n@@ -44,1 +43,1 @@\n-public class ConsoleReportPrinter implements TestResultCollector {\n+public class ConsoleReportPrinter extends CountingResultCollector {\n@@ -65,4 +64,0 @@\n-    private long passed;\n-    private long failed;\n-    private long softErrors;\n-    private long hardErrors;\n@@ -106,25 +101,1 @@\n-        TestGrading grading = r.grading();\n-\n-        boolean inHardError = false;\n-        switch (r.status()) {\n-            case TIMEOUT_ERROR:\n-            case CHECK_TEST_ERROR:\n-            case TEST_ERROR:\n-            case VM_ERROR:\n-                hardErrors++;\n-                inHardError = true;\n-                break;\n-            case API_MISMATCH:\n-                softErrors++;\n-                break;\n-            case NORMAL:\n-                if (grading.isPassed) {\n-                    passed++;\n-                } else {\n-                    failed++;\n-                }\n-                break;\n-            default:\n-                throw new IllegalStateException(\"Illegal status: \" + r.status());\n-        }\n-\n+        boolean inHardError = countResult(r);\n@@ -133,2 +104,2 @@\n-                !grading.isPassed ||\n-                grading.hasInteresting ||\n+                !r.grading().isPassed ||\n+                r.grading().hasInteresting ||\n@@ -219,0 +190,5 @@\n+        if (executor.isDiedFast()) {\n+            output.println(\"****************************************************\");\n+            output.println(\"To much failures occurred. Failing fast as requested\");\n+            output.println(\"****************************************************\");\n+        }\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/grading\/ConsoleReportPrinter.java","additions":9,"deletions":33,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.infra.grading;\n+\n+import org.openjdk.jcstress.infra.collectors.TestResult;\n+import org.openjdk.jcstress.infra.collectors.TestResultCollector;\n+\n+\n+\n+public abstract class  CountingResultCollector implements TestResultCollector {\n+\n+    protected long total;\n+    protected long passed;\n+    protected long failed;\n+    protected long softErrors;\n+    protected long hardErrors;\n+\n+    protected boolean countResult(TestResult r) {\n+        TestGrading grading = r.grading();\n+        total ++;\n+        boolean inHardError = false;\n+        switch (r.status()) {\n+            case TIMEOUT_ERROR:\n+            case CHECK_TEST_ERROR:\n+            case TEST_ERROR:\n+            case VM_ERROR:\n+                hardErrors++;\n+                inHardError = true;\n+                break;\n+            case API_MISMATCH:\n+                softErrors++;\n+                break;\n+            case NORMAL:\n+                if (grading.isPassed) {\n+                    passed++;\n+                } else {\n+                    failed++;\n+                }\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Illegal status: \" + r.status());\n+        }\n+        return inHardError;\n+    }\n+}\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/grading\/CountingResultCollector.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2005, 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.infra.grading;\n+\n+import org.openjdk.jcstress.Options;\n+import org.openjdk.jcstress.TestExecutor;\n+import org.openjdk.jcstress.infra.collectors.TestResult;\n+import org.openjdk.jcstress.infra.runners.TestConfig;\n+\n+import java.io.PrintWriter;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\n+public class FailFastKiller extends CountingResultCollector {\n+\n+    private final PrintWriter output;\n+    private final String originalValue;\n+    private final Map<String, Integer> tests;\n+    private final Set<String> failures = new HashSet<>();\n+    private final List<TestConfig> variants;\n+    private final boolean isFailFastAllVariants;\n+    private final double userValue;\n+    private final boolean relative;\n+    private final boolean superRelative;\n+\n+    private TestExecutor executor;\n+    private double absoluteThreshold = 1;\n+    private double relativeThreshold = 1;\n+    private int usedTotal = -1;\n+\n+\n+    public FailFastKiller(Options opts, PrintWriter pw, List<TestConfig> finalVariants) {\n+        this.output = pw;\n+        output.println(\"  FailFast attached as:\");\n+        this.originalValue = opts.getFailFast();\n+        this.userValue = Double.valueOf(originalValue.replaceAll(\"%*\", \"\"));\n+        this.relative = originalValue.endsWith(\"%\");\n+        this.superRelative = originalValue.endsWith(\"%%\");\n+        this.isFailFastAllVariants = opts.isFailFastAllVariants();\n+        this.variants = Collections.unmodifiableList(finalVariants);\n+        this.tests = groupVariants(finalVariants);\n+        if (isFailFastAllVariants) {\n+            output.println(\"    all variants, \" + originalValue);\n+            usedTotal = variants.size();\n+        } else {\n+            output.println(\"    whole tests, \" + originalValue);\n+            usedTotal = tests.size();\n+        }\n+        if (superRelative) {\n+            relativeThreshold = userValue;\n+            absoluteThreshold = -1;\n+            output.println(\"    The suite will terminate once failure rate reaches \" + getRelativeThresholdNice()\n+                    + \"% of *currently* finished number of tests\/variants\");\n+        } else {\n+            if (relative) {\n+                relativeThreshold = userValue;\n+                if (isFailFastAllVariants) {\n+                    absoluteThreshold = (relativeThreshold * (double) variants.size()) \/ 100d;\n+                } else {\n+                    absoluteThreshold = (relativeThreshold * (double) tests.size()) \/ 100d;\n+                }\n+            } else {\n+                absoluteThreshold = (long) userValue;\n+                if (isFailFastAllVariants) {\n+                    relativeThreshold = (absoluteThreshold * 100d) \/ (double) variants.size();\n+                } else {\n+                    relativeThreshold = (absoluteThreshold * 100d) \/ (double) tests.size();\n+                }\n+            }\n+            output.println(\"    The suite will terminate once failure rate reaches \" + getRelativeThresholdNice() + \"% (\"\n+                    + getAbsoluteThresholdNice() + \") of total tests\/variants (\" + usedTotal + \")\");\n+        }\n+        output.println();\n+    }\n+\n+    private static Map<String, Integer> groupVariants(List<TestConfig> finalVariants) {\n+        Map<String, Integer> tests = new HashMap<>();\n+        for (TestConfig testVariant : finalVariants) {\n+            int counter = tests.getOrDefault(testVariant.name, 0);\n+            counter++;\n+            tests.put(testVariant.name, counter);\n+        }\n+        return tests;\n+    }\n+\n+    @Override\n+    public synchronized void add(TestResult r) {\n+        addResult(r);\n+    }\n+\n+    private void addResult(TestResult r) {\n+        int groupCounter = tests.get(r.getName());\n+        \/\/we are counting each group down, so we can assure that the group is finished\n+        tests.put(r.getName(), groupCounter-1);\n+        long wasFailed = hardErrors + failed;\n+        countResult(r);\n+        long isFailed = hardErrors + failed;\n+        if (isFailed > wasFailed) {\n+            failures.add(r.getName());\n+        }\n+        verifyState(r);\n+    }\n+\n+    private void verifyState(TestResult r) {\n+        long totalFailed = failed + hardErrors;\n+        if (System.getProperty(\"jcstress.failfast.countsoft\") != null) {\n+            totalFailed += softErrors;\n+        }\n+        if (superRelative) {\n+            double totalFinishedUpToNow;\n+            if (isFailFastAllVariants) {\n+                totalFinishedUpToNow = passed + failed + softErrors + hardErrors;\n+            } else {\n+                totalFinishedUpToNow = tests.values().stream().filter(a -> a <= 0).collect(Collectors.counting());\n+            }\n+            double currentAbsoluteThreshold = (relativeThreshold * totalFinishedUpToNow) \/ 100d;\n+            \/\/there must be enough finished to get to some reasonable numbers\n+            if (currentAbsoluteThreshold > 1 && totalFailed > currentAbsoluteThreshold) {\n+                executor.setDiedFast();\n+            }\n+        } else {\n+            if (isFailFastAllVariants) {\n+                if (totalFailed > absoluteThreshold) {\n+                    executor.setDiedFast();\n+                }\n+            } else {\n+                \/\/we have to ensure, that all tests in current group finished\n+                if (failures.size() > absoluteThreshold && tests.get(r.getName()) <= 0) {\n+                    executor.setDiedFast();\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setExecutor(TestExecutor executor) {\n+        this.executor = executor;\n+    }\n+\n+    private String getAbsoluteThresholdNice() {\n+        return String.format(\"%.0f\", absoluteThreshold);\n+    }\n+\n+    private String getRelativeThresholdNice() {\n+        return String.format(\"%.2f\", relativeThreshold);\n+    }\n+\n+}\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/grading\/FailFastKiller.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"}]}