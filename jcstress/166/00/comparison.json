{"files":[{"patch":"@@ -37,1 +37,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n@@ -186,1 +185,1 @@\n-            UNSAFE.fullFence(); \/\/ \"SeqCst\" store\n+            VarHandle.fullFence(); \/\/ \"SeqCst\" store\n@@ -192,1 +191,1 @@\n-            UNSAFE.fullFence(); \/\/ \"SeqCst\" store\n+            VarHandle.fullFence(); \/\/ \"SeqCst\" store\n@@ -199,1 +198,1 @@\n-            UNSAFE.loadFence(); \/\/ \"SeqCst\" load x\n+            VarHandle.acquireFence(); \/\/ \"SeqCst\" load x\n@@ -201,1 +200,1 @@\n-            UNSAFE.loadFence(); \/\/ \"SeqCst\" load y\n+            VarHandle.acquireFence(); \/\/ \"SeqCst\" load y\n@@ -207,1 +206,1 @@\n-            UNSAFE.loadFence(); \/\/ \"SeqCst\" load y\n+            VarHandle.acquireFence(); \/\/ \"SeqCst\" load y\n@@ -209,1 +208,1 @@\n-            UNSAFE.loadFence(); \/\/ \"SeqCst\" load x\n+            VarHandle.acquireFence(); \/\/ \"SeqCst\" load x\n@@ -252,1 +251,1 @@\n-            UNSAFE.fullFence(); \/\/ \"SeqCst\" store\n+            VarHandle.fullFence(); \/\/ \"SeqCst\" store\n@@ -258,1 +257,1 @@\n-            UNSAFE.fullFence(); \/\/ \"SeqCst\" store\n+            VarHandle.fullFence(); \/\/ \"SeqCst\" store\n@@ -264,1 +263,1 @@\n-            UNSAFE.fullFence(); \/\/ \"SeqCst\" load x, part 1\n+            VarHandle.fullFence(); \/\/ \"SeqCst\" load x, part 1\n@@ -266,1 +265,1 @@\n-            UNSAFE.fullFence(); \/\/ \"SeqCst\" load x, part 2 (subsumed); \"SeqCst\" load y, part 1\n+            VarHandle.fullFence(); \/\/ \"SeqCst\" load x, part 2 (subsumed); \"SeqCst\" load y, part 1\n@@ -268,1 +267,1 @@\n-            UNSAFE.loadFence(); \/\/ \"SeqCst\" load y, part 2\n+            VarHandle.acquireFence(); \/\/ \"SeqCst\" load y, part 2\n@@ -273,1 +272,1 @@\n-            UNSAFE.fullFence();\n+            VarHandle.fullFence();\n@@ -275,1 +274,1 @@\n-            UNSAFE.fullFence(); \/\/ subsumes loadFence\n+            VarHandle.fullFence(); \/\/ subsumes loadFence\n@@ -277,1 +276,1 @@\n-            UNSAFE.loadFence();\n+            VarHandle.acquireFence();\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_02_MultiCopyAtomic.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -34,1 +36,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n@@ -86,1 +87,1 @@\n-        If fence-like effects are required in low-level concurrency code, then Unsafe.*Fence should be used instead.\n+        If fence-like effects are required in low-level concurrency code, then VarHandle.*Fence should be used instead.\n@@ -107,1 +108,1 @@\n-            UNSAFE.storeFence();\n+            VarHandle.releaseFence();\n@@ -114,1 +115,1 @@\n-            UNSAFE.loadFence();\n+            VarHandle.acquireFence();\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_14_SynchronizedAreNotFences.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -35,1 +37,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n@@ -109,1 +110,1 @@\n-            UNSAFE.storeFence();\n+            VarHandle.acquireFence();\n@@ -116,1 +117,1 @@\n-            UNSAFE.loadFence();\n+            VarHandle.acquireFence();\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/advanced\/AdvancedJMM_15_VolatilesAreNotFences.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.ByteOrder;\n@@ -37,1 +38,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n@@ -268,1 +268,2 @@\n-    public static class UnsafeCrossCacheLine {\n+    public static class CrossCacheLine {\n+        private static final VarHandle VH = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());\n@@ -270,17 +271,1 @@\n-        public static final int SIZE = 256;\n-        public static final long ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset(byte[].class);\n-        public static final long ARRAY_BASE_SCALE = UNSAFE.arrayIndexScale(byte[].class);\n-\n-        byte[] ss = new byte[SIZE];\n-        long off = ARRAY_BASE_OFFSET + ARRAY_BASE_SCALE * ThreadLocalRandom.current().nextInt(SIZE - 4);\n-\n-        @Actor\n-        public void writer() {\n-            UNSAFE.putInt(ss, off, 0xFFFFFFFF);\n-        }\n-\n-        @Actor\n-        public void reader(I_Result r) {\n-            r.r1 = UNSAFE.getInt(ss, off);\n-        }\n-    }\n+        private static final int BYTE_SIZE = 256;\n@@ -288,0 +273,1 @@\n+        int off = ThreadLocalRandom.current().nextInt(BYTE_SIZE - Integer.BYTES);\n@@ -289,37 +275,1 @@\n-    \/\/ ======================================= EARLY VALHALLA EXAMPLES BELOW =======================================\n-    \/\/ These require Valhalla JDK builds.\n-\n-    \/*\n-      ----------------------------------------------------------------------------------------------------------\n-\n-        While most modern hardware implementation provide access atomicity for all Java primitive types,\n-        the issue with access atomicity raises it ugly head again with Project Valhalla, which strives\n-        to introduce multi-field classes that behave like primitives. There, reading the entirety of\n-        the \"inlined\" (\"flattened\") primitive type is sometimes not possible, because the effective\n-        data type width is too large. Therefore, we would normally see access atomicity violations.\n-\n-        Indeed, on x86_64 this happens:\n-          RESULT        SAMPLES     FREQ       EXPECT  DESCRIPTION\n-            0, 0    790,816,955   22.90%   Acceptable  Seeing the default value: writer had not acted yet.\n-            0, 1      2,154,875    0.06%  Interesting  Other cases are allowed, because reads\/writes are not ato...\n-            1, 0      2,385,714    0.07%  Interesting  Other cases are allowed, because reads\/writes are not ato...\n-            1, 1  2,658,516,120   76.97%   Acceptable  Seeing the full value.\n-     *\/\n-\n-    \/*\n-    @JCStressTest\n-    @Outcome(id = \"0, 0\", expect = ACCEPTABLE, desc = \"Seeing the default value: writer had not acted yet.\")\n-    @Outcome(id = \"1, 1\", expect = ACCEPTABLE, desc = \"Seeing the full value.\")\n-    @Outcome(expect = ACCEPTABLE_INTERESTING, desc = \"Other cases are allowed, because reads\/writes are not atomic.\")\n-    @State\n-    public static class Values {\n-        static primitive class Value {\n-            long x;\n-            long y;\n-            public Value(long x, long y) {\n-                this.x = x;\n-                this.y = y;\n-            }\n-        }\n-\n-        Value v = Value.default;\n+        byte[] ss = new byte[BYTE_SIZE];\n@@ -329,1 +279,1 @@\n-            v = new Value(1, 1);\n+            VH.set(ss, off, 0xFFFFFFFF);\n@@ -333,104 +283,2 @@\n-        public void reader(JJ_Result r) {\n-            Value tv = v;\n-            r.r1 = tv.x;\n-            r.r2 = tv.y;\n-        }\n-    }\n-     *\/\n-\n-    \/*\n-      ----------------------------------------------------------------------------------------------------------\n-\n-        As usual, marking the primitive field \"volatile\" regains the access atomicity. In current implementations,\n-        this happens by forbidding the \"flattening\" of the inline type.\n-\n-        x86_64:\n-          RESULT        SAMPLES     FREQ      EXPECT  DESCRIPTION\n-            0, 0  2,780,487,683   84.19%  Acceptable  Seeing the default value: writer had not acted yet.\n-            1, 1    522,202,621   15.81%  Acceptable  Seeing the full value.\n-     *\/\n-\n-    \/*\n-\n-    @JCStressTest\n-    @Outcome(id = \"0, 0\", expect = ACCEPTABLE, desc = \"Seeing the default value: writer had not acted yet.\")\n-    @Outcome(id = \"1, 1\", expect = ACCEPTABLE, desc = \"Seeing the full value.\")\n-    @Outcome(expect = FORBIDDEN, desc = \"Other cases are forbidden.\")\n-    @State\n-    public static class VolatileValues {\n-        static primitive class Value {\n-            long x;\n-            long y;\n-            public Value(long x, long y) {\n-                this.x = x;\n-                this.y = y;\n-            }\n-        }\n-\n-        volatile Value v = Value.default;\n-\n-        @Actor\n-        public void writer() {\n-            v = new Value(1, 1);\n-        }\n-\n-        @Actor\n-        public void reader(JJ_Result r) {\n-            Value tv = v;\n-            r.r1 = tv.x;\n-            r.r2 = tv.y;\n-        }\n-    }\n-     *\/\n-\n-    \/*\n-      ----------------------------------------------------------------------------------------------------------\n-\n-        The awkward case is when the primitive field is not marked specifically, so field layouter flattens\n-        the type, but then the the primitive field is used as \"opaque\". In this case, the implementation\n-        has to enforce atomicity by e.g. locking.\n-\n-        x86_64:\n-            RESULT        SAMPLES     FREQ      EXPECT  DESCRIPTION\n-              0, 0    542,416,624   25.36%  Acceptable  Seeing the default value: writer had not acted yet.\n-              1, 1  1,596,364,560   74.64%  Acceptable  Seeing the full value.\n-     *\/\n-\n-    \/*\n-    @JCStressTest\n-    @Outcome(id = \"0, 0\", expect = ACCEPTABLE, desc = \"Seeing the default value: writer had not acted yet.\")\n-    @Outcome(id = \"1, 1\", expect = ACCEPTABLE, desc = \"Seeing the full value.\")\n-    @Outcome(expect = FORBIDDEN, desc = \"Other cases are forbidden.\")\n-    @State\n-    public static class OpaqueValues {\n-        static primitive class Value {\n-            long x;\n-            long y;\n-            public Value(long x, long y) {\n-                this.x = x;\n-                this.y = y;\n-            }\n-        }\n-\n-        Value v = Value.default;\n-\n-        static final VarHandle VH;\n-\n-        static {\n-            try {\n-                VH = MethodHandles.lookup().findVarHandle(OpaqueValues.class, \"v\", Value.class);\n-            } catch (NoSuchFieldException | IllegalAccessException e) {\n-                throw new IllegalStateException(e);\n-            }\n-        }\n-\n-        @Actor\n-        public void writer() {\n-            VH.setOpaque(this, new Value(1, 1));\n-        }\n-\n-        @Actor\n-        public void reader(JJ_Result r) {\n-            Value tv = (Value) VH.getOpaque(this);\n-            r.r1 = tv.x;\n-            r.r2 = tv.y;\n+        public void reader(I_Result r) {\n+            r.r1 = (int)VH.get(ss, off);\n@@ -439,1 +287,0 @@\n-    *\/\n","filename":"jcstress-samples\/src\/main\/java\/org\/openjdk\/jcstress\/samples\/jmm\/basic\/BasicJMM_02_AccessAtomicity.java","additions":9,"deletions":162,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.tests.atomicity.crosscache;\n+\n+import org.openjdk.jcstress.annotations.*;\n+import org.openjdk.jcstress.infra.results.I_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+@JCStressTest\n+@Description(\"Tests if VarHandle breaks the atomicity while doing cross cache-line reads\/writes.\")\n+@Outcome(id = \"0\",  expect = Expect.ACCEPTABLE, desc = \"Seeing the default value, this is a legal race.\")\n+@Outcome(id = \"-1\", expect = Expect.ACCEPTABLE, desc = \"Seeing the full value, this is a legal behavior.\")\n+@State\n+public class VarHandleIntAtomicityTest {\n+\n+    private static final VarHandle VH = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());\n+\n+    \/** Array size: 256 bytes inevitably crosses the cache line on most implementations *\/\n+    public static final int SIZE = 256;\n+\n+    public final byte[] bytes;\n+    public final int offset;\n+\n+    public VarHandleIntAtomicityTest() {\n+        bytes = new byte[SIZE];\n+        offset = ThreadLocalRandom.current().nextInt(SIZE - Integer.BYTES) \/ Integer.BYTES * Integer.BYTES;\n+    }\n+\n+    @Actor\n+    public void actor1() {\n+        VH.set(bytes, offset, 0xFFFFFFFF);\n+    }\n+\n+    @Actor\n+    public void actor2(I_Result r) {\n+        r.r1 = (int)VH.get(bytes, offset);\n+    }\n+\n+}\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/atomicity\/crosscache\/VarHandleIntAtomicityTest.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -34,2 +36,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n-\n@@ -60,1 +60,1 @@\n-        UNSAFE.storeFence();\n+        VarHandle.releaseFence();\n@@ -68,1 +68,1 @@\n-        UNSAFE.loadFence();\n+        VarHandle.acquireFence();\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/fences\/FencedAcquireReleaseTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -35,2 +37,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n-\n@@ -55,1 +55,1 @@\n-        UNSAFE.fullFence();\n+        VarHandle.fullFence();\n@@ -62,1 +62,1 @@\n-        UNSAFE.fullFence();\n+        VarHandle.fullFence();\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/fences\/FencedDekkerTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -34,2 +36,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n-\n@@ -59,1 +59,1 @@\n-        UNSAFE.storeFence();\n+        VarHandle.releaseFence();\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/fences\/FencedPublicationTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -34,2 +36,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n-\n@@ -59,1 +59,1 @@\n-        UNSAFE.storeFence();\n+        VarHandle.releaseFence();\n@@ -67,1 +67,1 @@\n-        UNSAFE.loadFence();\n+        VarHandle.acquireFence();\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/fences\/FencedReadTwiceTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -34,2 +36,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n-\n@@ -48,1 +48,1 @@\n-            UNSAFE.storeFence();\n+            VarHandle.releaseFence();\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/init\/primitives\/fenced\/BooleanFencedTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -34,2 +36,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n-\n@@ -48,1 +48,1 @@\n-            UNSAFE.storeFence();\n+            VarHandle.releaseFence();\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/init\/primitives\/fenced\/ByteFencedTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -34,2 +36,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n-\n@@ -48,1 +48,1 @@\n-            UNSAFE.storeFence();\n+            VarHandle.releaseFence();\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/init\/primitives\/fenced\/CharFencedTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -34,2 +36,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n-\n@@ -48,1 +48,1 @@\n-            UNSAFE.storeFence();\n+            VarHandle.releaseFence();\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/init\/primitives\/fenced\/DoubleFencedTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -34,2 +36,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n-\n@@ -48,1 +48,1 @@\n-            UNSAFE.storeFence();\n+            VarHandle.releaseFence();\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/init\/primitives\/fenced\/FloatFencedTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -34,2 +36,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n-\n@@ -48,1 +48,1 @@\n-            UNSAFE.storeFence();\n+            VarHandle.releaseFence();\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/init\/primitives\/fenced\/IntFencedTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -34,2 +36,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n-\n@@ -48,1 +48,1 @@\n-            UNSAFE.storeFence();\n+            VarHandle.releaseFence();\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/init\/primitives\/fenced\/LongFencedTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.invoke.VarHandle;\n+\n@@ -34,2 +36,0 @@\n-import static org.openjdk.jcstress.util.UnsafeHolder.UNSAFE;\n-\n@@ -48,1 +48,1 @@\n-            UNSAFE.storeFence();\n+            VarHandle.releaseFence();\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/init\/primitives\/fenced\/ShortFencedTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.tests.interrupt;\n+\n+import org.openjdk.jcstress.annotations.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+@Outcome(id = \"TERMINATED\", expect = Expect.ACCEPTABLE, desc = \"The thread had successfully terminated.\")\n+@Outcome(id = \"STALE\",      expect = Expect.FORBIDDEN,  desc = \"Thread had failed to respond.\")\n+public class VarHandleBusyLoopTest {\n+    static final VarHandle VH;\n+\n+    static {\n+        try {\n+            VH = MethodHandles.lookup().findVarHandle(VarHandleBusyLoopTest.class, \"isStopped\", boolean.class);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private boolean isStopped;\n+\n+    @JCStressTest(Mode.Termination)\n+    @JCStressMeta(VarHandleBusyLoopTest.class)\n+    @State\n+    public static class Opaque_Opaque extends VarHandleBusyLoopTest {\n+        @Signal public void signal() { VH.setOpaque(this, true); }\n+        @Actor  public void actor1() { while (!(boolean) VH.getOpaque(this)); }\n+    }\n+\n+    @JCStressTest(Mode.Termination)\n+    @JCStressMeta(VarHandleBusyLoopTest.class)\n+    @State\n+    public static class Opaque_Acquire extends VarHandleBusyLoopTest {\n+        @Signal public void signal() { VH.setOpaque(this, true); }\n+        @Actor  public void actor1() { while (!(boolean) VH.getAcquire(this)); }\n+    }\n+\n+    @JCStressTest(Mode.Termination)\n+    @JCStressMeta(VarHandleBusyLoopTest.class)\n+    @State\n+    public static class Opaque_Volatile extends VarHandleBusyLoopTest {\n+        @Signal public void signal() { VH.setOpaque(this, true); }\n+        @Actor  public void actor1() { while (!(boolean) VH.getVolatile(this)); }\n+    }\n+\n+    @JCStressTest(Mode.Termination)\n+    @JCStressMeta(VarHandleBusyLoopTest.class)\n+    @State\n+    public static class Release_Opaque extends VarHandleBusyLoopTest {\n+        @Signal public void signal() { VH.setRelease(this, true); }\n+        @Actor  public void actor1() { while (!(boolean) VH.getOpaque(this)); }\n+    }\n+\n+    @JCStressTest(Mode.Termination)\n+    @JCStressMeta(VarHandleBusyLoopTest.class)\n+    @State\n+    public static class Release_Acquire extends VarHandleBusyLoopTest {\n+        @Signal public void signal() { VH.setRelease(this, true); }\n+        @Actor  public void actor1() { while (!(boolean) VH.getAcquire(this)); }\n+    }\n+\n+    @JCStressTest(Mode.Termination)\n+    @JCStressMeta(VarHandleBusyLoopTest.class)\n+    @State\n+    public static class Release_Volatile extends VarHandleBusyLoopTest {\n+        @Signal public void signal() { VH.setRelease(this, true); }\n+        @Actor  public void actor1() { while (!(boolean) VH.getVolatile(this)); }\n+    }\n+\n+    @JCStressTest(Mode.Termination)\n+    @JCStressMeta(VarHandleBusyLoopTest.class)\n+    @State\n+    public static class Volatile_Opaque extends VarHandleBusyLoopTest {\n+        @Signal public void signal() { VH.setVolatile(this, true); }\n+        @Actor  public void actor1() { while (!(boolean) VH.getOpaque(this)); }\n+    }\n+\n+    @JCStressTest(Mode.Termination)\n+    @JCStressMeta(VarHandleBusyLoopTest.class)\n+    @State\n+    public static class Volatile_Acquire extends VarHandleBusyLoopTest {\n+        @Signal public void signal() { VH.setVolatile(this, true); }\n+        @Actor  public void actor1() { while (!(boolean) VH.getAcquire(this)); }\n+    }\n+\n+    @JCStressTest(Mode.Termination)\n+    @JCStressMeta(VarHandleBusyLoopTest.class)\n+    @State\n+    public static class Volatile_Volatile extends VarHandleBusyLoopTest {\n+        @Signal public void signal() { VH.setVolatile(this, true); }\n+        @Actor  public void actor1() { while (!(boolean) VH.getVolatile(this)); }\n+    }\n+\n+}\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/interrupt\/VarHandleBusyLoopTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.tests.tearing;\n+\n+import org.openjdk.jcstress.annotations.*;\n+import org.openjdk.jcstress.infra.results.III_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+@Description(\"Tests the word-tearing guarantees for byte[] via VarHandles.\")\n+@Outcome(id = \"0, 128, 128\", expect = Expect.ACCEPTABLE, desc = \"Seeing all updates intact.\")\n+@State\n+public class VarHandleArrayInterleaveTest {\n+\n+    private static final VarHandle VH = MethodHandles.arrayElementVarHandle(byte[].class);\n+\n+    \/** Array size: 256 bytes inevitably crosses the cache line on most implementations *\/\n+    public static final int SIZE = 256;\n+\n+    byte[] ss = new byte[SIZE];\n+\n+    public void summary(III_Result r) {\n+        for (byte s : ss) {\n+            switch (s) {\n+                case 0:\n+                    r.r1++;\n+                    break;\n+                case 1:\n+                    r.r2++;\n+                    break;\n+                case 2:\n+                    r.r3++;\n+                    break;\n+                default:\n+                    throw new IllegalStateException(String.valueOf(s));\n+            }\n+        }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleArrayInterleaveTest.class)\n+    @State\n+    public static class Plain_Plain extends VarHandleArrayInterleaveTest {\n+        @Actor public void actor1() { for (int i = 0; i < ss.length; i += 2) VH.set(ss, i, (byte) 1); }\n+        @Actor public void actor2() { for (int i = 1; i < ss.length; i += 2) VH.set(ss, i, (byte) 2); }\n+        @Arbiter public void arbiter(III_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleArrayInterleaveTest.class)\n+    @State\n+    public static class Plain_Opaque extends VarHandleArrayInterleaveTest {\n+        @Actor public void actor1() { for (int i = 0; i < ss.length; i += 2) VH.set(ss, i, (byte) 1); }\n+        @Actor public void actor2() { for (int i = 1; i < ss.length; i += 2) VH.setOpaque(ss, i, (byte) 2); }\n+        @Arbiter public void arbiter(III_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleArrayInterleaveTest.class)\n+    @State\n+    public static class Plain_Release extends VarHandleArrayInterleaveTest {\n+        @Actor public void actor1() { for (int i = 0; i < ss.length; i += 2) VH.set(ss, i, (byte) 1); }\n+        @Actor public void actor2() { for (int i = 1; i < ss.length; i += 2) VH.setRelease(ss, i, (byte) 2); }\n+        @Arbiter public void arbiter(III_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleArrayInterleaveTest.class)\n+    @State\n+    public static class Plain_Volatile extends VarHandleArrayInterleaveTest {\n+        @Actor public void actor1() { for (int i = 0; i < ss.length; i += 2) VH.set(ss, i, (byte) 1); }\n+        @Actor public void actor2() { for (int i = 1; i < ss.length; i += 2) VH.setVolatile(ss, i, (byte) 2); }\n+        @Arbiter public void arbiter(III_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleArrayInterleaveTest.class)\n+    @State\n+    public static class Opaque_Opaque extends VarHandleArrayInterleaveTest {\n+        @Actor public void actor1() { for (int i = 0; i < ss.length; i += 2) VH.setOpaque(ss, i, (byte) 1); }\n+        @Actor public void actor2() { for (int i = 1; i < ss.length; i += 2) VH.setOpaque(ss, i, (byte) 2); }\n+        @Arbiter public void arbiter(III_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleArrayInterleaveTest.class)\n+    @State\n+    public static class Opaque_Release extends VarHandleArrayInterleaveTest {\n+        @Actor public void actor1() { for (int i = 0; i < ss.length; i += 2) VH.setOpaque(ss, i, (byte) 1); }\n+        @Actor public void actor2() { for (int i = 1; i < ss.length; i += 2) VH.setRelease(ss, i, (byte) 2); }\n+        @Arbiter public void arbiter(III_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleArrayInterleaveTest.class)\n+    @State\n+    public static class Opaque_Volatile extends VarHandleArrayInterleaveTest {\n+        @Actor public void actor1() { for (int i = 0; i < ss.length; i += 2) VH.setOpaque(ss, i, (byte) 1); }\n+        @Actor public void actor2() { for (int i = 1; i < ss.length; i += 2) VH.setVolatile(ss, i, (byte) 2); }\n+        @Arbiter public void arbiter(III_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleArrayInterleaveTest.class)\n+    @State\n+    public static class Release_Release extends VarHandleArrayInterleaveTest {\n+        @Actor public void actor1() { for (int i = 0; i < ss.length; i += 2) VH.setRelease(ss, i, (byte) 1); }\n+        @Actor public void actor2() { for (int i = 1; i < ss.length; i += 2) VH.setRelease(ss, i, (byte) 2); }\n+        @Arbiter public void arbiter(III_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleArrayInterleaveTest.class)\n+    @State\n+    public static class Release_Volatile extends VarHandleArrayInterleaveTest {\n+        @Actor public void actor1() { for (int i = 0; i < ss.length; i += 2) VH.setRelease(ss, i, (byte) 1); }\n+        @Actor public void actor2() { for (int i = 1; i < ss.length; i += 2) VH.setVolatile(ss, i, (byte) 2); }\n+        @Arbiter public void arbiter(III_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleArrayInterleaveTest.class)\n+    @State\n+    public static class Volatile_Volatile extends VarHandleArrayInterleaveTest {\n+        @Actor public void actor1() { for (int i = 0; i < ss.length; i += 2) VH.setVolatile(ss, i, (byte) 1); }\n+        @Actor public void actor2() { for (int i = 1; i < ss.length; i += 2) VH.setVolatile(ss, i, (byte) 2); }\n+        @Arbiter public void arbiter(III_Result r) { summary(r); }\n+    }\n+}\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/tearing\/VarHandleArrayInterleaveTest.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.tests.tearing;\n+\n+import org.openjdk.jcstress.annotations.*;\n+import org.openjdk.jcstress.infra.results.II_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+@Description(\"Tests the word-tearing guarantees for byte[] via VarHandle.\")\n+@Outcome(id = \"-1431655766, 1431655765\", expect = Expect.ACCEPTABLE, desc = \"Seeing all updates intact.\")\n+public class VarHandleIntTearingTest {\n+\n+    private static final VarHandle VH = MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.nativeOrder());\n+\n+    \/** Array size: 256 bytes inevitably crosses the cache line on most implementations *\/\n+    private static final int SIZE = 256;\n+\n+    int offset1;\n+    int offset2;\n+\n+    byte[] bytes;\n+\n+    public VarHandleIntTearingTest() {\n+        bytes = new byte[SIZE];\n+        offset1 = ThreadLocalRandom.current().nextInt(SIZE - Integer.BYTES*2);\n+        offset1 = offset1 \/ Integer.BYTES * Integer.BYTES;\n+        offset2 = offset1 + Integer.BYTES;\n+    }\n+\n+    public void summary(II_Result r) {\n+        r.r1 = (int)VH.get(bytes, offset1);\n+        r.r2 = (int)VH.get(bytes, offset2);\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleIntTearingTest.class)\n+    @State\n+    public static class Plain_Plain extends VarHandleIntTearingTest {\n+        @Actor public void actor1() { VH.set(bytes, offset1, 0xAAAAAAAA); }\n+        @Actor public void actor2() { VH.set(bytes, offset2, 0x55555555); }\n+        @Arbiter public void arbiter1(II_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleIntTearingTest.class)\n+    @State\n+    public static class Plain_Opaque extends VarHandleIntTearingTest {\n+        @Actor public void actor1() { VH.set(bytes, offset1, 0xAAAAAAAA); }\n+        @Actor public void actor2() { VH.setOpaque(bytes, offset2, 0x55555555); }\n+        @Arbiter public void arbiter1(II_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleIntTearingTest.class)\n+    @State\n+    public static class Plain_Release extends VarHandleIntTearingTest {\n+        @Actor public void actor1() { VH.set(bytes, offset1, 0xAAAAAAAA); }\n+        @Actor public void actor2() { VH.setRelease(bytes, offset2, 0x55555555); }\n+        @Arbiter public void arbiter1(II_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleIntTearingTest.class)\n+    @State\n+    public static class Plain_Volatile extends VarHandleIntTearingTest {\n+        @Actor public void actor1() { VH.set(bytes, offset1, 0xAAAAAAAA); }\n+        @Actor public void actor2() { VH.setVolatile(bytes, offset2, 0x55555555); }\n+        @Arbiter public void arbiter1(II_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleIntTearingTest.class)\n+    @State\n+    public static class Opaque_Opaque extends VarHandleIntTearingTest {\n+        @Actor public void actor1() { VH.setOpaque(bytes, offset1, 0xAAAAAAAA); }\n+        @Actor public void actor2() { VH.setOpaque(bytes, offset2, 0x55555555); }\n+        @Arbiter public void arbiter1(II_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleIntTearingTest.class)\n+    @State\n+    public static class Opaque_Release extends VarHandleIntTearingTest {\n+        @Actor public void actor1() { VH.setOpaque(bytes, offset1, 0xAAAAAAAA); }\n+        @Actor public void actor2() { VH.setRelease(bytes, offset2, 0x55555555); }\n+        @Arbiter public void arbiter1(II_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleIntTearingTest.class)\n+    @State\n+    public static class Opaque_Volatile extends VarHandleIntTearingTest {\n+        @Actor public void actor1() { VH.setOpaque(bytes, offset1, 0xAAAAAAAA); }\n+        @Actor public void actor2() { VH.setVolatile(bytes, offset2, 0x55555555); }\n+        @Arbiter public void arbiter1(II_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleIntTearingTest.class)\n+    @State\n+    public static class Release_Release extends VarHandleIntTearingTest {\n+        @Actor public void actor1() { VH.setRelease(bytes, offset1, 0xAAAAAAAA); }\n+        @Actor public void actor2() { VH.setRelease(bytes, offset2, 0x55555555); }\n+        @Arbiter public void arbiter1(II_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleIntTearingTest.class)\n+    @State\n+    public static class Release_Volatile extends VarHandleIntTearingTest {\n+        @Actor public void actor1() { VH.setRelease(bytes, offset1, 0xAAAAAAAA); }\n+        @Actor public void actor2() { VH.setVolatile(bytes, offset2, 0x55555555); }\n+        @Arbiter public void arbiter1(II_Result r) { summary(r); }\n+    }\n+\n+    @JCStressTest\n+    @JCStressMeta(VarHandleIntTearingTest.class)\n+    @State\n+    public static class Volatile_Volatile extends VarHandleIntTearingTest {\n+        @Actor public void actor1() { VH.setVolatile(bytes, offset1, 0xAAAAAAAA); }\n+        @Actor public void actor2() { VH.setVolatile(bytes, offset2, 0x55555555); }\n+        @Arbiter public void arbiter1(II_Result r) { summary(r); }\n+    }\n+\n+}\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/tearing\/VarHandleIntTearingTest.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.tests.varhandles;\n+\n+import org.openjdk.jcstress.annotations.Actor;\n+import org.openjdk.jcstress.annotations.Description;\n+import org.openjdk.jcstress.annotations.Expect;\n+import org.openjdk.jcstress.annotations.JCStressTest;\n+import org.openjdk.jcstress.annotations.Outcome;\n+import org.openjdk.jcstress.annotations.State;\n+import org.openjdk.jcstress.infra.results.JJ_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+@JCStressTest\n+@Description(\"Tests if VarHandle.getAndAddLong is racy\")\n+@Outcome(id = \"1, 2\", expect = Expect.ACCEPTABLE, desc = \"T1 -> T2 execution\")\n+@Outcome(id = \"0, 0\", expect = Expect.ACCEPTABLE, desc = \"T2 -> T1 execution\")\n+@Outcome(id = \"0, 2\", expect = Expect.ACCEPTABLE, desc = \"T2 reads the result early\")\n+@State\n+public class AddLong1 {\n+\n+    static final VarHandle VH;\n+\n+    static {\n+        try {\n+            VH = MethodHandles.lookup().findVarHandle(AddLong1.class, \"x\", long.class);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    long x;\n+    volatile int written;\n+\n+    @Actor\n+    public void actor1() {\n+        VH.getAndAdd(this, 1L << 1);\n+        written = 1;\n+    }\n+\n+    @Actor\n+    public void actor2(JJ_Result r) {\n+        r.r1 = written;\n+        r.r2 = (long)VH.get(this);\n+    }\n+\n+}\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/varhandles\/AddLong1.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.tests.varhandles;\n+\n+import org.openjdk.jcstress.annotations.*;\n+import org.openjdk.jcstress.infra.results.JJ_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+@JCStressTest\n+@Description(\"Tests if VarHandle.getAndAddLong is racy\")\n+@Outcome(id = \"1, 4398046511104\", expect = Expect.ACCEPTABLE, desc = \"T1 -> T2 execution\")\n+@Outcome(id = \"0, 0\",             expect = Expect.ACCEPTABLE, desc = \"T2 -> T1 execution\")\n+@Outcome(id = \"0, 4398046511104\", expect = Expect.ACCEPTABLE, desc = \"T2 reads the result early\")\n+@State\n+public class AddLong42 {\n+\n+    static final VarHandle VH;\n+\n+    static {\n+        try {\n+            VH = MethodHandles.lookup().findVarHandle(AddLong42.class, \"x\", long.class);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    long x;\n+    volatile int written;\n+\n+    @Actor\n+    public void actor1() {\n+        VH.getAndAdd(this, 1L << 42);\n+        written = 1;\n+    }\n+\n+    @Actor\n+    public void actor2(JJ_Result r) {\n+        r.r1 = written;\n+        r.r2 = (long)VH.get(this);\n+    }\n+\n+}\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/varhandles\/AddLong42.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.tests.varhandles;\n+\n+import org.openjdk.jcstress.annotations.*;\n+import org.openjdk.jcstress.infra.results.III_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+\/**\n+ * Test if volatile write-read induces happens-before if in between two non-volatile reads.\n+ *\n+ * @author Aleksey Shipilev (shade@redhat.com)\n+ *\/\n+@JCStressTest\n+@Outcome(id = \"0, 0, 0\", expect = Expect.ACCEPTABLE, desc = \"Default value for the fields. Observers are allowed to see the default value for the field, because there is the data race between reader and writer.\")\n+@Outcome(id = \"0, 1, 0\", expect = Expect.FORBIDDEN,  desc = \"Volatile write to $y had happened, and update to $x had been lost.\")\n+@Outcome(id = \"1, 1, 0\", expect = Expect.FORBIDDEN,  desc = \"Volatile write to $y had happened, and update to $x had been lost.\")\n+@Outcome(id = \"1, 0, 0\", expect = Expect.ACCEPTABLE, desc = \"Write to $y is still in flight, can see inconsistent $x.\")\n+@Outcome(id = \"0, 0, 1\", expect = Expect.ACCEPTABLE, desc = \"Write to $y is still in flight, $x is arriving late.\")\n+@Outcome(id = \"1, 0, 1\", expect = Expect.ACCEPTABLE, desc = \"Write to $y is still in flight, $x has arrived.\")\n+@Outcome(id = \"0, 1, 1\", expect = Expect.ACCEPTABLE, desc = \"The writes appear the the writers' order.\")\n+@Outcome(id = \"1, 1, 1\", expect = Expect.ACCEPTABLE, desc = \"Both updates are visible.\")\n+@Ref(\"https:\/\/bugs.openjdk.java.net\/browse\/JDK-8175887\")\n+@State\n+public class ReadTwiceOverVolatileReadTest {\n+\n+    static final VarHandle VH;\n+\n+    static {\n+        try {\n+            VH = MethodHandles.lookup().findVarHandle(ReadTwiceOverVolatileReadTest.class, \"y\", int.class);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    int x;\n+    volatile int y;\n+\n+    @Actor\n+    public void actor1() {\n+        x = 1;\n+        VH.setVolatile(this, 1);\n+    }\n+\n+    @Actor\n+    public void actor2(III_Result r) {\n+        r.r1 = x;\n+        r.r2 = (int) VH.getVolatile(this);\n+        r.r3 = x;\n+    }\n+\n+}\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/varhandles\/ReadTwiceOverVolatileReadTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.tests.varhandles;\n+\n+import org.openjdk.jcstress.annotations.*;\n+import org.openjdk.jcstress.infra.results.II_Result;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+@JCStressTest\n+@Description(\"Tests if Unsafe.putOrderedInt is in-order\")\n+@Outcome(id = \"1, 1\", expect = Expect.ACCEPTABLE, desc = \"T1 -> T2 execution\")\n+@Outcome(id = \"0, 0\", expect = Expect.ACCEPTABLE, desc = \"T2 -> T1 execution\")\n+@Outcome(id = \"0, 1\", expect = Expect.ACCEPTABLE, desc = \"T2 observes TOP early\")\n+@State\n+public class SetReleaseTwice {\n+\n+    static final VarHandle VH_LOCK, VH_TOP;\n+\n+    static {\n+        try {\n+            VH_LOCK = MethodHandles.lookup().findVarHandle(SetReleaseTwice.class, \"lock\", int.class);\n+            VH_TOP  = MethodHandles.lookup().findVarHandle(SetReleaseTwice.class, \"top\", int.class);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    volatile int lock;\n+    int top;\n+\n+    @Actor\n+    public void actor1() {\n+        VH_TOP.setRelease(this, 1);\n+        VH_LOCK.setRelease(this, 1);\n+    }\n+\n+    @Actor\n+    public void actor2(II_Result r) {\n+        r.r1 = (int)VH_LOCK.getAcquire(this);\n+        r.r2 = (int)VH_TOP.get(this);\n+    }\n+\n+}\n","filename":"tests-custom\/src\/main\/java\/org\/openjdk\/jcstress\/tests\/varhandles\/SetReleaseTwice.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"}]}