{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import org.openjdk.jcstress.infra.grading.XMLReportPrinter;\n@@ -160,2 +161,8 @@\n-        new TextReportPrinter(opts, collector).work();\n-        new HTMLReportPrinter(opts, collector, out).work();\n+        new TextReportPrinter(opts.verbosity(), collector).work();\n+        new HTMLReportPrinter(opts.getResultDest(), collector, out).work();\n+        if (XMLReportPrinter.getSparse(out)!=null) {\n+            new XMLReportPrinter(opts.getResultDest(), collector, out, XMLReportPrinter.getSparse(out)).work();\n+        } else {\n+            new XMLReportPrinter(opts.getResultDest(), collector, out, false).work();\n+            new XMLReportPrinter(opts.getResultDest(), collector, out, true).work();\n+        }\n@@ -165,0 +172,1 @@\n+\n@@ -255,1 +263,1 @@\n-                testsToPrint.add(test.toDetailedTest());\n+                testsToPrint.add(test.toDetailedTest(true));\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/JCStress.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import org.openjdk.jcstress.Options;\n@@ -60,1 +59,1 @@\n-    public HTMLReportPrinter(Options opts, InProcessCollector collector, PrintStream out) {\n+    public HTMLReportPrinter(String resultDir, InProcessCollector collector, PrintStream out) {\n@@ -62,1 +61,1 @@\n-        this.resultDir = opts.getResultDest();\n+        this.resultDir = resultDir;\n@@ -65,1 +64,5 @@\n-        out.println(\"  HTML report generated at \" + dir.getAbsolutePath() + File.separator + \"index.html\");\n+        out.println(\"  HTML report generated at \" + dir.getAbsolutePath() + File.separator + getMainFileName());\n+    }\n+\n+    private String getMainFileName() {\n+        return \"index.html\";\n@@ -72,1 +75,1 @@\n-        PrintWriter output = new PrintWriter(resultDir + \"\/index.html\");\n+        PrintWriter output = new PrintWriter(resultDir + File.separator + getMainFileName());\n@@ -174,1 +177,1 @@\n-    private SortedMap<String, String> getEnv(List<TestResult> ts) {\n+    static SortedMap<String, String> getEnv(List<TestResult> ts) {\n@@ -356,4 +359,1 @@\n-        sorted.sort(Comparator\n-                .comparing((TestResult t) -> t.getConfig().getCompileMode())\n-                .thenComparing((TestResult t) -> t.getConfig().getSchedulingClass().toString())\n-                .thenComparing((TestResult t) -> StringUtils.join(t.getConfig().jvmArgs, \",\")));\n+        resultsOrder(sorted);\n@@ -495,0 +495,7 @@\n+    static void resultsOrder(List<TestResult> sorted) {\n+        sorted.sort(Comparator\n+                .comparing((TestResult t) -> t.getConfig().getCompileMode())\n+                .thenComparing((TestResult t) -> t.getConfig().getSchedulingClass().toString())\n+                .thenComparing((TestResult t) -> StringUtils.join(t.getConfig().jvmArgs, \",\")));\n+    }\n+\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/grading\/HTMLReportPrinter.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -86,0 +86,7 @@\n+    }\n+    public static Multimap<String, TestResult> byDetailedName(Collection<TestResult> src) {\n+        Multimap<String, TestResult> result = new HashMultimap<>();\n+        for (TestResult r : mergedByConfig(src)) {\n+            result.put(r.getConfig().toDetailedTest(false), r);\n+        }\n+        return result;\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/grading\/ReportUtils.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    public TextReportPrinter(Options opts, InProcessCollector collector) {\n+    public TextReportPrinter(Verbosity verbosity, InProcessCollector collector) {\n@@ -54,1 +54,1 @@\n-        this.verbosity = opts.verbosity();\n+        this.verbosity = verbosity;\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/grading\/TextReportPrinter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,681 @@\n+\/*\n+ * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jcstress.infra.grading;\n+\n+\n+import org.openjdk.jcstress.annotations.Expect;\n+import org.openjdk.jcstress.infra.TestInfo;\n+import org.openjdk.jcstress.infra.collectors.InProcessCollector;\n+import org.openjdk.jcstress.infra.collectors.TestResult;\n+import org.openjdk.jcstress.infra.runners.TestConfig;\n+import org.openjdk.jcstress.infra.runners.TestList;\n+import org.openjdk.jcstress.os.SchedulingClass;\n+import org.openjdk.jcstress.util.Multimap;\n+import org.openjdk.jcstress.vm.CompileMode;\n+import org.w3c.dom.Document;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+import javax.xml.validation.Validator;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+\n+public class XMLReportPrinter {\n+\n+    private enum JunitResult {\n+        pass, failure, error, skipped\n+    }\n+\n+    \/\/how to deal with sofrt errors like api mishmash or similar\n+    public static final String SOFT_ERROR_AS = \"jcstress.report.xml.softErrorAs\"; \/\/pass\/fail\/skip\/error defaults to skip\n+    \/\/how to deal with hard errors. Those may be timout, but also segfaulting vm\n+    public static final String HARD_ERROR_AS = \"jcstress.report.xml.hardErrorAs\"; \/\/pass\/fail\/skip\/error defaults to fail\n+    \/\/only for full (non-saprse) output, will wrap each family by its <testsuite name>\n+    public static final String USE_TESTSUITES = \"jcstress.report.xml.sparse.testsuites\";\n+    \/\/in case of sued testsuiotes, will not replicate the name of suite in test name.\n+    \/\/it is not stripped by default for sake of comparisns\n+    public static final String TESTSUITES_STRIPNAMES = \"jcstress.report.xml.sparse.stripNames\";\n+    \/\/will repritn system and jvm info in each test (may significantly waste sapce)\n+    public static final String DUPLICATE_PROPERTIES = \"jcstress.report.xml.properties.dupliate\";\n+    \/\/will move stdout\/err to failure\/error message for failures\/errors and omit for passes\n+    \/\/this is for tools,m which do nto show stdout\/err properly\n+    \/\/also it is saving a bit of space, but is loosing the granularity\n+    public static final String STDOUTERR_TO_FAILURE = \"jcstress.report.xml.souterr2failure\";\n+    \/\/will validate final xmls\n+    public static final String VALIDATE = \"jcstress.report.xml.validate\";\n+    \/\/will keep non standart (but widelyused) elements uncomment\n+    public static final String UNCOMMENT_NONSTANDART = \"jcstress.report.xml.nonstandart\";\n+    \/\/by default both reports are printed. By setting it to true or false, will include only sparse ot full\n+    public static final String SPARSE = \"jcstress.report.xml.sparse\"; \/\/true\/false\/null\n+\n+    private final String resultDir;\n+    private final InProcessCollector collector;\n+    private final boolean sparse;\n+    private final PrintStream out;\n+\n+    public XMLReportPrinter(String resultDir, InProcessCollector collector, PrintStream out, boolean sparse) {\n+        \/\/sparse true -ALL_MATCHING\n+        \/\/sparse false - as ALL_MATCHING_COMBINATIONS\n+        \/\/jednou smichat, jednou ne. Varovani kolik jich bude\n+        \/\/-xml true\/false, defaults to sparse\n+        this.collector = collector;\n+        this.resultDir = resultDir;\n+        this.sparse = sparse;\n+        File dir = new File(resultDir);\n+        dir.mkdirs();\n+        out.println(\"  \" + getSparseString() + \" XML report generated at \" + dir.getAbsolutePath() + File.separator + getMainFileName());\n+        this.out = out;\n+    }\n+\n+    private static JunitResult getSoftErrorAs() {\n+        if (System.getProperty(XMLReportPrinter.SOFT_ERROR_AS) == null) {\n+            return JunitResult.skipped;\n+        }\n+        return Enum.valueOf(JunitResult.class, System.getProperty(XMLReportPrinter.SOFT_ERROR_AS));\n+    }\n+\n+    private static JunitResult getHardErrorAs() {\n+        if (System.getProperty(XMLReportPrinter.HARD_ERROR_AS) == null) {\n+            return JunitResult.failure;\n+        }\n+        return Enum.valueOf(JunitResult.class, System.getProperty(XMLReportPrinter.HARD_ERROR_AS));\n+    }\n+\n+    public static Boolean getSparse(PrintStream out) {\n+        String sparse = System.getProperty(SPARSE);\n+        if (sparse == null) {\n+            return null;\n+        } else {\n+            if (\"true\".equals(sparse) || \"false\".equals(sparse)) {\n+                return Boolean.getBoolean(XMLReportPrinter.SPARSE);\n+            } else {\n+                if (out != null) {\n+                    out.println(\"Invalid \" + SPARSE + \" value of \" + sparse + \"Should be true\/false or missing\");\n+                }\n+                return null;\n+            }\n+        }\n+    }\n+\n+\n+    private static boolean isTestsuiteUsed() {\n+        return System.getProperty(XMLReportPrinter.USE_TESTSUITES) != null;\n+    }\n+\n+    private static boolean isStdoutErrToFailure() {\n+        return System.getProperty(XMLReportPrinter.STDOUTERR_TO_FAILURE) != null;\n+    }\n+\n+    private static boolean isStripNames() {\n+        return System.getProperty(XMLReportPrinter.TESTSUITES_STRIPNAMES) != null;\n+    }\n+\n+    private static boolean isValidate() {\n+        return System.getProperty(XMLReportPrinter.VALIDATE) != null;\n+    }\n+\n+    private static boolean isDuplicateProperties() {\n+        return System.getProperty(XMLReportPrinter.DUPLICATE_PROPERTIES) != null;\n+    }\n+\n+    private static boolean isXsdLenient() {\n+        return System.getProperty(XMLReportPrinter.UNCOMMENT_NONSTANDART) != null;\n+    }\n+\n+    private static String printProperty(String key, boolean value) {\n+        return printProperty(key, \"\" + value);\n+    }\n+\n+    private static String printProperty(String key, String value) {\n+        return \"<property name='\" + key + \"' value='\" + value + \"'\/>\";\n+    }\n+\n+    private static String getBaseProperties(List<TestResult> sorted) {\n+        StringBuilder sb = new StringBuilder();\n+        for (Map.Entry<String, String> entry : HTMLReportPrinter.getEnv(sorted).entrySet()) {\n+            sb.append(\"          \" + printProperty(entry.getKey(), entry.getValue())).append(\"\\n\");\n+        }\n+        return sb.toString();\n+    }\n+\n+\n+    private static String getSeed(TestResult r) {\n+        if (r.getConfig().getSeed() != null) {\n+            return (\"          \" + printProperty(\"seed\", getCleanSeed(r)) + \"\\n\");\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static String getCleanSeed(TestResult r) {\n+        String[] args = r.getConfig().getSeed().split(\"=\");\n+        if (args.length > 1) {\n+            return args[1];\n+        }\n+        return args[0];\n+    }\n+\n+    private static String getRefs(TestInfo test) {\n+        StringBuilder sb = new StringBuilder();\n+        for (String ref : test.refs()) {\n+            if (ref != null) {\n+                sb.append(\"          \" + printProperty(\"bug\", ref)).append(\"\\n\");\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static String getTestDescription(TestInfo test) {\n+        if (test.description() != null && !test.description().equals(\"null\")) {\n+            return \"          \" + printProperty(\"description\", test.description() + \"\\n\");\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private String getMainFileName() {\n+        return \"junit-\" + getSparseString() + \".xml\";\n+    }\n+\n+    private String getSparseString() {\n+        return sparse ? \"sparse\" : \"full\";\n+    }\n+\n+    public void work() throws FileNotFoundException {\n+        List<TestResult> byName = sparse ? ReportUtils.mergedByName(collector.getTestResults()) : new ArrayList<>(collector.getTestResults());\n+        Collections.sort(byName, Comparator.comparing(TestResult::getName));\n+\n+        String filePath = resultDir + File.separator + getMainFileName();\n+        PrintWriter output = new PrintWriter(filePath);\n+\n+        output.println(\"<?xml version='1.0' encoding='UTF-8'?>\");\n+        output.println(\"<testsuites>\");\n+        if (isMainTestsuite()) {\n+            String header = printTestSuiteHeader(byName, \"jcstress\");\n+            output.println(\"  \" + header);\n+            printMainproperties(output, byName);\n+        }\n+        byName = ReportUtils.mergedByName(collector.getTestResults());\n+        Collections.sort(byName, Comparator.comparing(TestResult::getName));\n+        emitTestReports(ReportUtils.byName(collector.getTestResults()), output);\n+        if (isMainTestsuite()) {\n+            output.println(\"  <\/testsuite>\");\n+        }\n+        output.println(\"<\/testsuites>\");\n+        output.flush();\n+        output.close();\n+        if (isValidate()) {\n+            validate(filePath);\n+        }\n+    }\n+\n+    private void printMainproperties(PrintWriter output, List<TestResult> byName) {\n+        output.println(\"  <properties>\");\n+        output.print(getBaseProperties(byName));\n+        \/\/FIXME print all properties, if 7903889 got ever implemented\n+        printXmlReporterProperties(output);\n+        output.println(\"  <\/properties>\");\n+    }\n+\n+    private boolean isMainTestsuite() {\n+        if (sparse) {\n+            return true;\n+        } else {\n+            if (!isTestsuiteUsed()) {\n+                return true;\n+            } else {\n+                return isXsdLenient();\n+            }\n+        }\n+    }\n+\n+    private static String printTestSuiteHeader(List<TestResult> results, String name) {\n+        Map<JunitResult, List<TestResult>> reordered = countJunitResults(results);\n+        String hostname = \"localhost\";\n+        try {\n+            hostname = InetAddress.getLocalHost().getHostName();\n+        } catch (Exception ex) {\n+            \/\/no interest\n+        }\n+        String prefix = \"\";\n+        String passed = \" passed='\" + reordered.get(JunitResult.pass).size() + \"'\";\n+        if (!isXsdLenient()) {\n+            prefix = \"<!--\" + passed + \"-->\\n\";\n+            passed = \"\";\n+        }\n+        return prefix + \"<testsuite name='\" + name + \"'\" +\n+                \" tests='\" + results.size() + \"'\" +\n+                \" failures='\" + reordered.get(JunitResult.failure).size() + \"'\" +\n+                \" errors='\" + reordered.get(JunitResult.error).size() + \"'\" +\n+                \" skipped='\" + reordered.get(JunitResult.skipped).size() + \"' \" +\n+                passed +\n+                \" time='\" + getTime(results, false) + \"'\" +\n+                \" timestamp='\" + new Date().toString() + \"' \" +\n+                \" hostname='\" + hostname + \"'>\";\n+    }\n+\n+    private static Map<JunitResult, List<TestResult>> countJunitResults(List<TestResult> results) {\n+        List<TestResult> passed = new ArrayList<>();\n+        List<TestResult> failed = new ArrayList<>();\n+        List<TestResult> error = new ArrayList<>();\n+        List<TestResult> skipped = new ArrayList<>();\n+        Map<JunitResult, List<TestResult>> sorted = new HashMap<>();\n+        sorted.put(JunitResult.pass, passed);\n+        sorted.put(JunitResult.error, error);\n+        sorted.put(JunitResult.failure, failed);\n+        sorted.put(JunitResult.skipped, skipped);\n+        for (TestResult result : results) {\n+            switch (testToJunitResult(result)) {\n+                case pass:\n+                    passed.add(result);\n+                    break;\n+                case failure:\n+                    failed.add(result);\n+                    break;\n+                case error:\n+                    error.add(result);\n+                    break;\n+                case skipped:\n+                    skipped.add(result);\n+                    break;\n+                default:\n+                    throw new RuntimeException(\"Unknown JunitResult: \" + result.status() + \"\/\" + testToJunitResult(result));\n+            }\n+        }\n+        int checksum = passed.size() + failed.size() + error.size() + skipped.size();\n+        if (checksum != results.size()) {\n+            throw new RuntimeException(\"Missed tests in summ-up: \" + checksum + \", was supposed to be: \" + results.size());\n+        }\n+        return sorted;\n+    }\n+\n+    private void printXmlReporterProperties(PrintWriter output) {\n+        output.println(\"    \" + printProperty(\"sparse\", sparse));\n+        output.println(\"    \" + printProperty(USE_TESTSUITES, isTestsuiteUsed()));\n+        output.println(\"    \" + printProperty(TESTSUITES_STRIPNAMES, isStripNames()));\n+        output.println(\"    \" + printProperty(SOFT_ERROR_AS, getSoftErrorAs().toString()));\n+        output.println(\"    \" + printProperty(HARD_ERROR_AS, getHardErrorAs().toString()));\n+        output.println(\"    \" + printProperty(DUPLICATE_PROPERTIES, isDuplicateProperties()));\n+        output.println(\"    \" + printProperty(UNCOMMENT_NONSTANDART, isXsdLenient()));\n+        output.println(\"    \" + printProperty(STDOUTERR_TO_FAILURE, isStdoutErrToFailure()));\n+        output.println(\"    \" + printProperty(SPARSE, Objects.toString(getSparse(null))));\n+    }\n+\n+    private void emitTestReports(Multimap<String, TestResult> multiByName, PrintWriter local) {\n+        multiByName.keys().stream().forEach(name -> {\n+            TestInfo test = TestList.getInfo(name);\n+            emitTestReport(local, multiByName.get(name), test, name);\n+        });\n+    }\n+\n+    private void emitTestReport(PrintWriter outw, Collection<TestResult> results, TestInfo test, String suiteCandidate) {\n+        \/\/in sparse mode we print only test.name as test, with result based on cumulative\n+        \/\/otherwise we will be printing only its individual combinations (to mach the summary)\n+        if (sparse) {\n+            List<TestResult> sorted = new ArrayList<>(results);\n+            HTMLReportPrinter.resultsOrder(sorted);\n+            outw.println(\"  \" + getOpenTestcase(results, test.name()));\n+            if (isXsdLenient()) {\n+                printPropertiesPerTest(outw, test, null, sorted);\n+            }\n+            printMainTestBody(outw, sorted, true);\n+            outw.println(\"<\/testcase>\");\n+        } else {\n+            List<TestResult> sorted = new ArrayList<>(results);\n+            HTMLReportPrinter.resultsOrder(sorted);\n+            if (isTestsuiteUsed()) {\n+                String header = printTestSuiteHeader(sorted, suiteCandidate);\n+                outw.println(header);\n+                if (!isMainTestsuite()) {\n+                    printMainproperties(outw, sorted);\n+                }\n+            }\n+            for (TestResult r : sorted) {\n+                String testName = r.getConfig().toDetailedTest(false);\n+                if (isTestsuiteUsed() && isStripNames()) {\n+                    testName = r.getConfig().getTestVariant(false);\n+                }\n+                outw.println(\"  \" + getOpenTestcase(Arrays.asList(r), testName));\n+                if (isXsdLenient()) {\n+                    printPropertiesPerTest(outw, test, r, sorted);\n+                }\n+                printMainTestBody(outw, Arrays.asList(r), null);\n+                outw.println(\"<\/testcase>\");\n+            }\n+            if (isTestsuiteUsed()) {\n+                outw.println(\"  <\/testsuite>\");\n+            }\n+        }\n+\n+    }\n+\n+    private static String getOpenTestcase(Collection<TestResult> results, String test) {\n+        return \"<testcase classname='jcstress' name='\" + test + \"' time='\" + getTime(results, false) + \"'>\";\n+    }\n+\n+    private static String getTime(Collection<TestResult> results, boolean toNicestring) {\n+        double sum = 0;\n+        for (TestResult resul : results) {\n+            sum += resul.getTotalCount();\n+        }\n+        if (toNicestring) {\n+            if (sum > 10) {\n+                return \"10^\" + (long) Math.floor((Math.log10(sum)));\n+            } else {\n+                return String.valueOf(sum);\n+            }\n+        } else {\n+            return \"\" + sum;\n+        }\n+    }\n+\n+    private static void printPropertiesPerTest(PrintWriter outw, TestInfo test, TestResult result, List<TestResult> sorted) {\n+        String props = printPropertiesPerTest(test, result, sorted);\n+        if (!props.isEmpty()) {\n+            outw.println(\"      <properties>\");\n+            outw.print(props);\n+            outw.println(\"      <\/properties>\");\n+        }\n+    }\n+\n+    private static String printPropertiesPerTest(TestInfo test, TestResult result, List<TestResult> sorted) {\n+        StringBuilder sb = new StringBuilder();\n+        String description = getTestDescription(test);\n+        if (description != null && !description.isEmpty()) {\n+            sb.append(description);\n+        }\n+        String refs = getRefs(test);\n+        if (refs != null && !refs.isEmpty()) {\n+            sb.append(refs);\n+        }\n+        if (result != null) {\n+            String seed = getSeed(result);\n+            if (seed != null && !seed.isEmpty()) {\n+                sb.append(seed);\n+            }\n+        }\n+        if (result != null) {\n+            if (result.grading().hasInteresting) {\n+                sb.append(\"          \" + printProperty(\"interesting\", true) + \"\\n\");\n+            }\n+        } else {\n+            boolean anyIntresting = getAnyInteresting(sorted);\n+            if (anyIntresting) {\n+                sb.append(\"          \" + printProperty(\"interesting\", true) + \"\\n\");\n+            }\n+        }\n+\n+        if (isDuplicateProperties()) {\n+            String baseProps = getBaseProperties(sorted);\n+            if (baseProps != null && !baseProps.isEmpty()) {\n+                sb.append(baseProps);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static boolean getAnyInteresting(List<TestResult> results) {\n+        for (TestResult result : results) {\n+            if (result.grading().hasInteresting) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static void printMainTestBody(PrintWriter outw, List<TestResult> results, Boolean header) {\n+        Set<String> keys = new TreeSet<>();\n+        for (TestResult result : results) {\n+            keys.addAll(result.getStateKeys());\n+        }\n+        printStatusElement(outw, results, keys, header);\n+        if (!isStdoutErrToFailure()) {\n+            printSystemOutElement(outw, results, header);\n+            printSystemErrElement(outw, results, header);\n+        }\n+    }\n+\n+    private static void printStatusElement(PrintWriter outw, List<TestResult> results, Set<String> keys, Boolean header) {\n+        JunitResult junitResult = testsToJunitResult(results);\n+        if (junitResult == JunitResult.failure || junitResult == JunitResult.error) {\n+            outw.println(\"<\" + junitResult + \"><![CDATA[\");\n+            for (TestResult result : results) {\n+                if (!isXsdLenient()) {\n+                    if (result.getConfig() != null && result.getConfig().getSeed() != null) {\n+                        outw.println(result.getConfig().getSeed());\n+                    }\n+                    if (result.grading() != null && result.grading().hasInteresting) {\n+                        outw.println(\"interesting\");\n+                    }\n+                }\n+                outw.println(result.getConfig().toDetailedTest(false));\n+                printHtmlInfo(result, outw, keys);\n+                if (isStdoutErrToFailure()) {\n+                    printMessages(outw, result, header);\n+                    printVmOut(outw, result, null);\n+                    printVmErr(outw, result, header);\n+                }\n+            }\n+            outw.println(\"]]><\/\" + junitResult + \">\");\n+        }\n+        if (junitResult == JunitResult.skipped) {\n+            if (isXsdLenient()) {\n+                outw.println(\" <skipped message='api missmastch?' \/>\");\n+            } else {\n+                outw.println(\" <!-- api missmastch -->\");\n+                outw.println(\" <skipped\/>\");\n+            }\n+        }\n+    }\n+\n+    private static void printSystemErrElement(PrintWriter outw, Collection<TestResult> results, Boolean header) {\n+        outw.println(\"<system-err><![CDATA[\");\n+        for (TestResult r : results) {\n+            printVmErr(outw, r, header);\n+        }\n+        outw.println(\"]]><\/system-err>\\n\");\n+    }\n+\n+    private static void printSystemOutElement(PrintWriter outw, Collection<TestResult> results, Boolean header) {\n+        outw.println(\"<system-out><![CDATA[\");\n+        for (TestResult r : results) {\n+            printMessages(outw, r, header);\n+            printVmOut(outw, r, null);\n+        }\n+        outw.println(\"]]><\/system-out>\");\n+    }\n+\n+    private static void printVmErr(PrintWriter outw, TestResult result, Boolean header) {\n+        printTestLines(result.getVmErr(), outw, result, header);\n+    }\n+\n+    private static void printVmOut(PrintWriter outw, TestResult result, Boolean header) {\n+        printTestLines(result.getVmOut(), outw, result, header);\n+    }\n+\n+    private static void printMessages(PrintWriter outw, TestResult result, Boolean header) {\n+        printTestLines(result.getMessages(), outw, result, header);\n+    }\n+\n+    private static void printTestLines(List<String> lines, PrintWriter outw, TestResult originalResult, Boolean header) {\n+        if (!lines.isEmpty()) {\n+            resultHeader(outw, originalResult, header);\n+            for (String data : lines) {\n+                outw.println(data);\n+            }\n+            outw.println();\n+        }\n+    }\n+\n+    private static void printHtmlInfo(TestResult result, PrintWriter out, Set<String> keys) {\n+        String color = ReportUtils.statusToPassed(result) ? \"green\" : \"red\";\n+        String label = ReportUtils.statusToLabel(result);\n+        out.println(\"html signatue: \" + color + \" - \" + label);\n+        getGradings(result, out, keys);\n+    }\n+\n+    private static void getGradings(TestResult result, PrintWriter out, Set<String> keys) {\n+        for (String key : keys) {\n+            GradingResult c = result.grading().gradingResults.get(key);\n+            if (c != null) {\n+                out.println(selectHtmlGradingColor(c.expect, c.count == 0) + \"\/\" + c.count + \"\");\n+            } else {\n+                out.println(selectHtmlGradingColor(Expect.ACCEPTABLE, true) + \"\/0\");\n+            }\n+        }\n+    }\n+\n+    private static void resultHeader(PrintWriter outw, TestResult r, Boolean full) {\n+        if (full != null) {\n+            TestConfig cfg = r.getConfig();\n+            if (full) {\n+                outw.println(cfg.toDetailedTest(false));\n+            } else {\n+                outw.println(\"CompileMode: \" + CompileMode.description(cfg.compileMode, cfg.actorNames));\n+                outw.println(\"SchedulingClass\" + SchedulingClass.description(cfg.shClass, cfg.actorNames));\n+                outw.println(\"\");\n+                if (!cfg.jvmArgs.isEmpty()) {\n+                    outw.println(\"jvmargs:\" + cfg.jvmArgs);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static String selectHtmlGradingColor(Expect type, boolean isZero) {\n+        switch (type) {\n+            case ACCEPTABLE:\n+                return isZero ? \"LIGHT_GRAY\" : \"GREEN\";\n+            case FORBIDDEN:\n+                return isZero ? \"LIGHT_GRAY\" : \"RED\";\n+            case ACCEPTABLE_INTERESTING:\n+                return isZero ? \"LIGHT_GRAY\" : \"CYAN\";\n+            case UNKNOWN:\n+                return \"RED\";\n+            default:\n+                throw new IllegalStateException();\n+        }\n+    }\n+\n+    private void validate(String xml) {\n+        try {\n+            out.println(\"Checking: \" + xml);\n+            wellFormed(xml);\n+            validByXsd(xml);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private void wellFormed(String xml) throws ParserConfigurationException, SAXException, IOException {\n+        out.println(\"Well formed?\");\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        factory.setValidating(false);\n+        factory.setNamespaceAware(true);\n+        DocumentBuilder builder = factory.newDocumentBuilder();\n+        Document document = builder.parse(new InputSource(xml));\n+        out.println(\"Well formed!\");\n+    }\n+\n+    private void validByXsd(String xml) throws ParserConfigurationException, SAXException, IOException, URISyntaxException {\n+        String url = \"https:\/\/raw.githubusercontent.com\/junit-team\/junit5\/refs\/heads\/main\/platform-tests\/src\/test\/resources\/jenkins-junit.xsd\";\n+        out.println(\"Valid by \" + url + \" ?\");\n+        SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema = factory.newSchema(new URI(url).toURL());\n+        Validator validator = schema.newValidator();\n+        validator.validate(new StreamSource(new File(xml)));\n+        out.println(\"Valid!\");\n+    }\n+\n+    public static JunitResult testsToJunitResult(Collection<TestResult> results) {\n+        boolean hadError = false;\n+        int countSkipped = 0;\n+        for (TestResult result : results) {\n+            if (testToJunitResult(result) == JunitResult.failure) {\n+                \/\/if there was failure in sub set, return whole group as failure\n+                return JunitResult.failure;\n+            }\n+            if (testToJunitResult(result) == JunitResult.error) {\n+                hadError = true;\n+            }\n+            if (testToJunitResult(result) == JunitResult.skipped) {\n+                countSkipped++;\n+            }\n+        }\n+        \/\/no failure, bute errors presented\n+        if (hadError) {\n+            return JunitResult.error;\n+        }\n+        \/\/no failure, no error, was all skipped?\n+        if (countSkipped == results.size()) {\n+            return JunitResult.skipped;\n+        }\n+        return JunitResult.pass;\n+    }\n+\n+    public static JunitResult testToJunitResult(TestResult result) {\n+        switch (result.status()) {\n+            case TIMEOUT_ERROR:\n+                return JunitResult.error;\n+            case CHECK_TEST_ERROR:\n+                return JunitResult.error;\n+            case TEST_ERROR:\n+            case VM_ERROR:\n+                return getHardErrorAs();\n+            case API_MISMATCH:\n+                return getSoftErrorAs();\n+            case NORMAL:\n+                return JunitResult.pass;\n+            default:\n+                throw new IllegalStateException(\"Illegal status: \" + result.status());\n+        }\n+    }\n+}\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/grading\/XMLReportPrinter.java","additions":681,"deletions":0,"binary":false,"changes":681,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.ArrayList;\n@@ -249,1 +250,1 @@\n-    public String toDetailedTest() {\n+    public String getTestVariant(boolean keepSeed) {\n@@ -253,3 +254,3 @@\n-        StringBuilder verboseOutput = new StringBuilder(name);\n-        verboseOutput.append(\" {\")\n-                .append(actorNames)\n+        \/\/cpumap - null in listing, no reasonable toString method => omitted\n+        StringBuilder idString = new StringBuilder();\n+        idString.append(actorNames)\n@@ -264,2 +265,29 @@\n-                .append(\", cpuMap: \").append(cpuMap)\n-                .append(\", \").append(jvmArgs)\n+                .append(\", \").append(keepSeed ? jvmArgs : maskSeed(jvmArgs)); \/\/this is intentionally last to keep remaining prefix easily searchable\n+        return idString.toString();\n+    }\n+\n+    private List<String> maskSeed(List<String> jvmArgs) {\n+        List<String> argsCopy = new ArrayList<>(jvmArgs.size());\n+        for (String arg : jvmArgs) {\n+            if (arg.startsWith(\"-XX:StressSeed=\")) {\n+                argsCopy.add(arg.replaceAll(\"[0-9]+\", \"yyyyyyyy\"));\n+            } else {\n+                argsCopy.add(arg);\n+            }\n+        }\n+        return argsCopy;\n+    }\n+\n+    public String getSeed() {\n+        for (String arg : jvmArgs) {\n+            if (arg.startsWith(\"-XX:StressSeed=\")) {\n+                return arg;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public String toDetailedTest(boolean keepSeed) {\n+        StringBuilder verboseOutput = new StringBuilder(name);\n+        verboseOutput.append(\" {\")\n+                .append(getTestVariant(keepSeed))\n@@ -269,1 +297,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/infra\/runners\/TestConfig.java","additions":35,"deletions":7,"binary":false,"changes":42,"status":"modified"}]}