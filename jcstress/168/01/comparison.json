{"files":[{"patch":"@@ -195,0 +195,23 @@\n+    private boolean skipMode(int cm, VMSupport.Config config, int threads) {\n+        if (CompileMode.isUnified(cm)) {\n+            \/\/ Do not skip unified modes.\n+            return false;\n+        }\n+        \/\/ No C1\/C2 runtime is available? Skip split compilation tests with C1\/C2.\n+        if (!config.availableRuntimes().hasC2() && CompileMode.hasC2(cm, threads)) {\n+            return true;\n+        }\n+        if (!config.availableRuntimes().hasC1() && CompileMode.hasC1(cm, threads)) {\n+            return true;\n+        }\n+        \/\/ Config should be executed only when C1\/C2 is available? Skip split compilation tests without them.\n+        if (config.requiredRuntimes().hasC2() && !CompileMode.hasC2(cm, threads)) {\n+            return true;\n+        }\n+        if (config.requiredRuntimes().hasC1() && !CompileMode.hasC1(cm, threads)) {\n+            return true;\n+        }\n+        \/\/ Do not skip by default.\n+        return false;\n+    }\n+\n@@ -196,5 +219,2 @@\n-        for (int cc : CompileMode.casesFor(info.threads(), VMSupport.c1Available(), VMSupport.c2Available())) {\n-            if (config.onlyIfC2() && !CompileMode.hasC2(cc, info.threads())) {\n-                \/\/ This configuration is expected to run only when C2 is enabled,\n-                \/\/ but compilation mode does not include C2. Can skip it to optimize\n-                \/\/ testing time.\n+        for (int cm : CompileMode.casesFor(info.threads(), VMSupport.c1Available(), VMSupport.c2Available())) {\n+            if (skipMode(cm, config, info.threads())) {\n@@ -205,1 +225,1 @@\n-                testConfigs.add(new TestConfig(opts, info, f, config.args(), cc, scl));\n+                testConfigs.add(new TestConfig(opts, info, f, config.args(), cm, scl));\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/JCStress.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -78,0 +78,4 @@\n+    public static boolean isUnified(int mode) {\n+        return mode == UNIFIED;\n+    }\n+\n@@ -88,1 +92,1 @@\n-    private static boolean hasC1(int mode, int actors) {\n+    public static boolean hasC1(int mode, int actors) {\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/vm\/CompileMode.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -394,1 +394,1 @@\n-        return new Config(l, orig.onlyIfC2(), orig.stress());\n+        return new Config(l, orig.availableRuntimes(), orig.requiredRuntimes(), orig.stress());\n@@ -401,1 +401,1 @@\n-        return new Config(l, orig.onlyIfC2(), orig.stress());\n+        return new Config(l, orig.availableRuntimes(), orig.requiredRuntimes(), orig.stress());\n@@ -411,9 +411,1 @@\n-            configs.add(new Config(jvmArgs, false, false));\n-        } else if (splitCompilation && COMPILER_DIRECTIVES_AVAILABLE) {\n-            System.out.println(\" (split compilation is requested and compiler directives are available)\");\n-            \/\/ Default global\n-            configs.add(new Config(Collections.emptyList(), false, false));\n-            if (C2_AVAILABLE) {\n-                \/\/ C2 compilations stress\n-                configs.add(new Config(C2_STRESS_JVM_FLAGS, true, true));\n-            }\n+            configs.add(new Config(jvmArgs, Runtimes.all(), Runtimes.none(), false));\n@@ -421,2 +413,1 @@\n-            \/\/ Interpreted\n-            configs.add(new Config(Arrays.asList(\"-Xint\"), false, false));\n+            configs.add(new Config(Collections.singletonList(\"-Xint\"), Runtimes.intp(), Runtimes.none(), false));\n@@ -424,2 +415,1 @@\n-                \/\/ C1\n-                configs.add(new Config(Arrays.asList(\"-XX:TieredStopAtLevel=1\"), false, false));\n+                configs.add(new Config(Collections.singletonList(\"-XX:TieredStopAtLevel=1\"), Runtimes.intpC1(), Runtimes.none(), false));\n@@ -428,4 +418,15 @@\n-                \/\/ C2\n-                configs.add(new Config(Arrays.asList(\"-XX:-TieredCompilation\"), false, false));\n-                \/\/ C2 only + stress\n-                configs.add(new Config(C2_ONLY_STRESS_JVM_FLAGS, true, true));\n+                configs.add(new Config(Collections.singletonList(\"-XX:-TieredCompilation\"), Runtimes.intpC2(), Runtimes.none(), false));\n+            }\n+\n+            List<String> c2StressFlags;\n+            if (splitCompilation && COMPILER_DIRECTIVES_AVAILABLE) {\n+                System.out.println(\" (split compilation is requested and compiler directives are available)\");\n+                configs.add(new Config(Collections.emptyList(), Runtimes.all(), Runtimes.none(), false));\n+                c2StressFlags = C2_STRESS_JVM_FLAGS;\n+            } else {\n+                c2StressFlags = C2_ONLY_STRESS_JVM_FLAGS;\n+            }\n+\n+            \/\/ Mix in appropriate C2 stress options\n+            if (C2_AVAILABLE) {\n+                configs.add(new Config(c2StressFlags, Runtimes.all(), Runtimes.C2(), true));\n@@ -622,0 +623,60 @@\n+    public static class Runtimes {\n+        static final int INT = 1 << 0;\n+        static final int C1 = 1 << 1;\n+        static final int C2 = 1 << 2;\n+        final int mod;\n+\n+        private Runtimes(int mod) {\n+            this.mod = mod;\n+        }\n+\n+        private static Runtimes none() {\n+            return new Runtimes(0);\n+        }\n+\n+        private static Runtimes all() {\n+            return new Runtimes(INT | C1 | C2);\n+        }\n+\n+        private static Runtimes intp() {\n+            return new Runtimes(INT);\n+        }\n+\n+        private static Runtimes C1() {\n+            return new Runtimes(C1);\n+        }\n+\n+        private static Runtimes C2() {\n+            return new Runtimes(C2);\n+        }\n+\n+        private static Runtimes intpC1() {\n+            return new Runtimes(INT | C1);\n+        }\n+\n+        private static Runtimes intpC2() {\n+            return new Runtimes(INT | C2);\n+        }\n+\n+        public boolean hasC1() {\n+            return (mod & C1) != 0;\n+        }\n+\n+        public boolean hasC2() {\n+            return (mod & C2) != 0;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            Runtimes runtimes = (Runtimes) o;\n+            return mod == runtimes.mod;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return mod;\n+        }\n+    }\n+\n@@ -626,1 +687,2 @@\n-        private final boolean onlyIfC2;\n+        private final Runtimes availableRuntimes;\n+        private final Runtimes requiredRuntimes;\n@@ -630,1 +692,1 @@\n-        private Config(List<String> args, boolean onlyIfC2, boolean stress) {\n+        private Config(List<String> args, Runtimes availableRuntimes, Runtimes requiredRuntimes, boolean stress) {\n@@ -632,1 +694,2 @@\n-            this.onlyIfC2 = onlyIfC2;\n+            this.availableRuntimes = availableRuntimes;\n+            this.requiredRuntimes = requiredRuntimes;\n@@ -650,2 +713,6 @@\n-        public boolean onlyIfC2() {\n-            return onlyIfC2;\n+        public Runtimes availableRuntimes() {\n+            return availableRuntimes;\n+        }\n+\n+        public Runtimes requiredRuntimes() {\n+            return requiredRuntimes;\n@@ -674,1 +741,0 @@\n-            if (this == o) return true;\n@@ -676,0 +742,1 @@\n+\n@@ -677,2 +744,3 @@\n-            return onlyIfC2 == config.onlyIfC2 &&\n-                    args.equals(config.args);\n+            return args.equals(config.args) &&\n+                    availableRuntimes.equals(config.availableRuntimes) &&\n+                    requiredRuntimes.equals(config.requiredRuntimes);\n@@ -683,1 +751,4 @@\n-            return Objects.hash(args, onlyIfC2);\n+            int result = args.hashCode();\n+            result = 31 * result + availableRuntimes.hashCode();\n+            result = 31 * result + requiredRuntimes.hashCode();\n+            return result;\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/vm\/VMSupport.java","additions":99,"deletions":28,"binary":false,"changes":127,"status":"modified"}]}