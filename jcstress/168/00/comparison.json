{"files":[{"patch":"@@ -195,0 +195,23 @@\n+    private boolean skipMode(int cm, VMSupport.Config config, TestInfo info) {\n+        if (CompileMode.isUnified(cm)) {\n+            \/\/ Do not skip unified modes\n+            return false;\n+        }\n+        \/\/ No C1\/C2 runtime is available? Skip split compilation tests with C1\/C2.\n+        if (!config.availableRuntimes().hasC2() && CompileMode.hasC2(cm, info.threads())) {\n+            return true;\n+        }\n+        if (!config.availableRuntimes().hasC1() && CompileMode.hasC1(cm, info.threads())) {\n+            return true;\n+        }\n+        \/\/ Config should be executed only when C1\/C2 is available? Skip split compilation tests without them.\n+        if (config.limitRuntimes().hasC2() && !CompileMode.hasC2(cm, info.threads())) {\n+            return true;\n+        }\n+        if (config.limitRuntimes().hasC1() && !CompileMode.hasC1(cm, info.threads())) {\n+            return true;\n+        }\n+        \/\/ Do not skip by default.\n+        return false;\n+    }\n+\n@@ -196,5 +219,3 @@\n-        for (int cc : CompileMode.casesFor(info.threads(), VMSupport.c1Available(), VMSupport.c2Available())) {\n-            if (config.onlyIfC2() && !CompileMode.hasC2(cc, info.threads())) {\n-                \/\/ This configuration is expected to run only when C2 is enabled,\n-                \/\/ but compilation mode does not include C2. Can skip it to optimize\n-                \/\/ testing time.\n+        for (int cm : CompileMode.casesFor(info.threads(), VMSupport.c1Available(), VMSupport.c2Available())) {\n+            if (skipMode(cm, config, info)) {\n+                \/\/ Skip unnecessary modes to optimize testing time.\n@@ -205,1 +226,1 @@\n-                testConfigs.add(new TestConfig(opts, info, f, config.args(), cc, scl));\n+                testConfigs.add(new TestConfig(opts, info, f, config.args(), cm, scl));\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/JCStress.java","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -78,0 +78,4 @@\n+    public static boolean isUnified(int mode) {\n+        return mode == UNIFIED;\n+    }\n+\n@@ -88,1 +92,1 @@\n-    private static boolean hasC1(int mode, int actors) {\n+    public static boolean hasC1(int mode, int actors) {\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/vm\/CompileMode.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -394,1 +394,1 @@\n-        return new Config(l, orig.onlyIfC2(), orig.stress());\n+        return new Config(l, orig.availableRuntimes(), orig.limitRuntimes(), orig.stress());\n@@ -401,1 +401,1 @@\n-        return new Config(l, orig.onlyIfC2(), orig.stress());\n+        return new Config(l, orig.availableRuntimes(), orig.limitRuntimes(), orig.stress());\n@@ -411,9 +411,1 @@\n-            configs.add(new Config(jvmArgs, false, false));\n-        } else if (splitCompilation && COMPILER_DIRECTIVES_AVAILABLE) {\n-            System.out.println(\" (split compilation is requested and compiler directives are available)\");\n-            \/\/ Default global\n-            configs.add(new Config(Collections.emptyList(), false, false));\n-            if (C2_AVAILABLE) {\n-                \/\/ C2 compilations stress\n-                configs.add(new Config(C2_STRESS_JVM_FLAGS, true, true));\n-            }\n+            configs.add(new Config(jvmArgs, Runtimes.all(), Runtimes.none(), false));\n@@ -421,2 +413,1 @@\n-            \/\/ Interpreted\n-            configs.add(new Config(Arrays.asList(\"-Xint\"), false, false));\n+            configs.add(new Config(Collections.singletonList(\"-Xint\"), Runtimes.onlyInt(), Runtimes.none(), false));\n@@ -424,2 +415,1 @@\n-                \/\/ C1\n-                configs.add(new Config(Arrays.asList(\"-XX:TieredStopAtLevel=1\"), false, false));\n+                configs.add(new Config(Collections.singletonList(\"-XX:TieredStopAtLevel=1\"), Runtimes.intC1(), Runtimes.none(), false));\n@@ -428,4 +418,15 @@\n-                \/\/ C2\n-                configs.add(new Config(Arrays.asList(\"-XX:-TieredCompilation\"), false, false));\n-                \/\/ C2 only + stress\n-                configs.add(new Config(C2_ONLY_STRESS_JVM_FLAGS, true, true));\n+                configs.add(new Config(Collections.singletonList(\"-XX:-TieredCompilation\"), Runtimes.intC2(), Runtimes.none(), false));\n+            }\n+\n+            List<String> c2StressFlags;\n+            if (splitCompilation && COMPILER_DIRECTIVES_AVAILABLE) {\n+                System.out.println(\" (split compilation is requested and compiler directives are available)\");\n+                configs.add(new Config(Collections.emptyList(), Runtimes.all(), Runtimes.none(), false));\n+                c2StressFlags = C2_STRESS_JVM_FLAGS;\n+            } else {\n+                c2StressFlags = C2_ONLY_STRESS_JVM_FLAGS;\n+            }\n+\n+            \/\/ Mix in appropriate C2 stress options\n+            if (C2_AVAILABLE) {\n+                configs.add(new Config(c2StressFlags, Runtimes.all(), Runtimes.onlyC2(), true));\n@@ -622,0 +623,47 @@\n+    public static class Runtimes {\n+        static final int INT = 1 << 0;\n+        static final int C1 = 1 << 1;\n+        static final int C2 = 1 << 2;\n+        final int mod;\n+\n+        private Runtimes(int mod) {\n+            this.mod = mod;\n+        }\n+\n+        private static Runtimes none() {\n+            return new Runtimes(0);\n+        }\n+\n+        private static Runtimes all() {\n+            return new Runtimes(INT | C1 | C2);\n+        }\n+\n+        private static Runtimes onlyInt() {\n+            return new Runtimes(INT);\n+        }\n+\n+        private static Runtimes onlyC1() {\n+            return new Runtimes(C1);\n+        }\n+\n+        private static Runtimes onlyC2() {\n+            return new Runtimes(C2);\n+        }\n+\n+        private static Runtimes intC1() {\n+            return new Runtimes(INT | C1);\n+        }\n+\n+        private static Runtimes intC2() {\n+            return new Runtimes(INT | C2);\n+        }\n+\n+        public boolean hasC1() {\n+            return (mod & C1) != 0;\n+        }\n+\n+        public boolean hasC2() {\n+            return (mod & C2) != 0;\n+        }\n+    }\n+\n@@ -626,1 +674,2 @@\n-        private final boolean onlyIfC2;\n+        private final Runtimes availableRuntimes;\n+        private final Runtimes limitRuntimes;\n@@ -630,1 +679,1 @@\n-        private Config(List<String> args, boolean onlyIfC2, boolean stress) {\n+        private Config(List<String> args, Runtimes availableRuntimes, Runtimes limitRuntimes, boolean stress) {\n@@ -632,1 +681,2 @@\n-            this.onlyIfC2 = onlyIfC2;\n+            this.availableRuntimes = availableRuntimes;\n+            this.limitRuntimes = limitRuntimes;\n@@ -650,2 +700,6 @@\n-        public boolean onlyIfC2() {\n-            return onlyIfC2;\n+        public Runtimes availableRuntimes() {\n+            return availableRuntimes;\n+        }\n+\n+        public Runtimes limitRuntimes() {\n+            return limitRuntimes;\n@@ -677,2 +731,3 @@\n-            return onlyIfC2 == config.onlyIfC2 &&\n-                    args.equals(config.args);\n+            if (config.availableRuntimes.mod != availableRuntimes.mod) return false;\n+            if (config.limitRuntimes.mod != limitRuntimes.mod) return false;\n+            return true;\n@@ -683,1 +738,1 @@\n-            return Objects.hash(args, onlyIfC2);\n+            return Objects.hash(args, availableRuntimes.mod);\n","filename":"jcstress-core\/src\/main\/java\/org\/openjdk\/jcstress\/vm\/VMSupport.java","additions":82,"deletions":27,"binary":false,"changes":109,"status":"modified"}]}