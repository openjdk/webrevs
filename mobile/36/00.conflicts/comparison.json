{"files":[{"patch":"@@ -456,0 +456,1 @@\n+#ifndef __IOS__\n@@ -460,0 +461,1 @@\n+#endif\n@@ -466,0 +468,1 @@\n+#ifndef __IOS__\n@@ -473,0 +476,6 @@\n+#else\n+    size_t nlen = strlen(user_home_dir) + 11;\n+    char *iosuser_home = NEW_C_HEAP_ARRAY(char, nlen, mtInternal);\n+    snprintf(iosuser_home, nlen, \"%s\/Documents\", user_home_dir);\n+    Arguments::set_java_home(iosuser_home);\n+#endif\n@@ -1485,0 +1494,85 @@\n+<<<<<<< HEAD\n+=======\n+static char saved_jvm_path[MAXPATHLEN] = {0};\n+\n+\/\/ Find the full path to the current module, libjvm\n+void os::jvm_path(char *buf, jint buflen) {\n+  \/\/ Error checking.\n+  if (buflen < MAXPATHLEN) {\n+    assert(false, \"must use a large-enough buffer\");\n+    buf[0] = '\\0';\n+    return;\n+  }\n+  \/\/ Lazy resolve the path to current module.\n+  if (saved_jvm_path[0] != 0) {\n+    strcpy(buf, saved_jvm_path);\n+    return;\n+  }\n+\n+  char dli_fname[MAXPATHLEN];\n+  dli_fname[0] = '\\0';\n+  bool ret = dll_address_to_library_name(\n+                                         CAST_FROM_FN_PTR(address, os::jvm_path),\n+                                         dli_fname, sizeof(dli_fname), nullptr);\n+  assert(ret, \"cannot locate libjvm\");\n+#ifdef __IOS__\n+    const char *homeDir = getenv(\"HOME\");\n+    snprintf(buf, buflen, \"%s\/Documents\/\", homeDir);\n+    return;\n+#endif\n+  char *rp = nullptr;\n+  if (ret && dli_fname[0] != '\\0') {\n+    rp = os::realpath(dli_fname, buf, buflen);\n+  }\n+  if (rp == nullptr) {\n+    return;\n+  }\n+\n+  \/\/ If executing unit tests we require JAVA_HOME to point to the real JDK.\n+  if (Arguments::executing_unit_tests()) {\n+    \/\/ Look for JAVA_HOME in the environment.\n+    char* java_home_var = ::getenv(\"JAVA_HOME\");\n+    if (java_home_var != nullptr && java_home_var[0] != 0) {\n+\n+      \/\/ Check the current module name \"libjvm\"\n+      const char* p = strrchr(buf, '\/');\n+      assert(strstr(p, \"\/libjvm\") == p, \"invalid library name\");\n+\n+      stringStream ss(buf, buflen);\n+      rp = os::realpath(java_home_var, buf, buflen);\n+      if (rp == nullptr) {\n+        return;\n+      }\n+\n+      assert((int)strlen(buf) < buflen, \"Ran out of buffer space\");\n+      \/\/ Add the appropriate library and JVM variant subdirs\n+      ss.print(\"%s\/lib\/%s\", buf, Abstract_VM_Version::vm_variant());\n+\n+      if (0 != access(buf, F_OK)) {\n+        ss.reset();\n+        ss.print(\"%s\/lib\", buf);\n+      }\n+\n+      \/\/ If the path exists within JAVA_HOME, add the JVM library name\n+      \/\/ to complete the path to JVM being overridden.  Otherwise fallback\n+      \/\/ to the path to the current library.\n+      if (0 == access(buf, F_OK)) {\n+        \/\/ Use current module name \"libjvm\"\n+        ss.print(\"\/libjvm%s\", JNI_LIB_SUFFIX);\n+        assert(strcmp(buf + strlen(buf) - strlen(JNI_LIB_SUFFIX), JNI_LIB_SUFFIX) == 0,\n+               \"buf has been truncated\");\n+      } else {\n+        \/\/ Fall back to path of current library\n+        rp = os::realpath(dli_fname, buf, buflen);\n+        if (rp == nullptr) {\n+          return;\n+        }\n+      }\n+    }\n+  }\n+\n+  strncpy(saved_jvm_path, buf, MAXPATHLEN);\n+  saved_jvm_path[MAXPATHLEN - 1] = '\\0';\n+}\n+\n+>>>>>>> a48a2f8d3627694251bc80769d932fcf85e4146d\n@@ -1694,0 +1788,3 @@\n+#ifdef __IOS__\n+      ;\n+#else\n@@ -1695,0 +1792,1 @@\n+#endif\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":98,"deletions":0,"binary":false,"changes":98,"status":"modified"}]}