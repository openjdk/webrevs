{"files":[{"patch":"@@ -1697,0 +1697,3 @@\n+        doFirst {\n+            mkdir \"$project.buildDir\/gensrc\/mtl-headers\"\n+        }\n@@ -1707,0 +1710,1 @@\n+    \/\/ D3D shaders\n@@ -1713,2 +1717,13 @@\n-        output project.file(\"$project.buildDir\/hlsl\/$name\/$pkg\")\n-        source project.file(\"$project.buildDir\/gensrc\/jsl-$lowerName\/$pkg\")\n+        output project.file(\"$project.buildDir\/hlsl\/$name\/$pkg\/d3d\/hlsl\")\n+        source project.file(\"$project.buildDir\/gensrc\/jsl-$lowerName\/$pkg\/d3d\/hlsl\")\n+    }\n+\n+    \/\/ Metal shaders\n+    def compileMSLShaders = project.task(\"compile${name}MSLShaders\",\n+            dependsOn: generateShaders,\n+            type: CompileMSLTask) {\n+        enabled = IS_MAC\n+        description = \"Compile $name MSL files into .air files\"\n+        matches = \".*\\\\.metal\"\n+        output project.file(\"$project.buildDir\/msl\/$name\/$pkg\/mtl\/msl\")\n+        source project.file(\"$project.buildDir\/gensrc\/jsl-$lowerName\/$pkg\/mtl\/msl\")\n@@ -1716,0 +1731,1 @@\n+    project.compileMSLShaders.dependsOn(compileMSLShaders)\n@@ -2360,0 +2376,4 @@\n+    project.task(\"compileMSLShaders\") {\n+        \/\/ an empty task to hang the Metal prism and decora shaders on\n+    }\n+\n@@ -2440,0 +2460,4 @@\n+    if (IS_MAC) {\n+        addNative(project, \"prismMTL\")\n+    }\n+\n@@ -2559,11 +2583,4 @@\n-    addJSL(project, \"Decora\", \"com\/sun\/scenario\/effect\/impl\/hw\/d3d\/hlsl\", decoraAddExports) { sourceDir, destinationDir ->\n-        [[fileName: \"ColorAdjust\", generator: \"CompileJSL\", outputs: \"-all\"],\n-         [fileName: \"Brightpass\", generator: \"CompileJSL\", outputs: \"-all\"],\n-         [fileName: \"SepiaTone\", generator: \"CompileJSL\", outputs: \"-all\"],\n-         [fileName: \"PerspectiveTransform\", generator: \"CompileJSL\", outputs: \"-all\"],\n-         [fileName: \"DisplacementMap\", generator: \"CompileJSL\", outputs: \"-all\"],\n-         [fileName: \"InvertMask\", generator: \"CompileJSL\", outputs: \"-all\"],\n-         [fileName: \"Blend\", generator: \"CompileBlend\", outputs: \"-all\"],\n-         [fileName: \"PhongLighting\", generator: \"CompilePhong\", outputs: \"-all\"],\n-         [fileName: \"LinearConvolve\", generator: \"CompileLinearConvolve\", outputs: \"-hw\"],\n-         [fileName: \"LinearConvolveShadow\", generator: \"CompileLinearConvolve\", outputs: \"-hw\"]].each { settings ->\n+\n+    \/\/ The GenAllDecoraShader.java class generates all the Decora shaders\n+    addJSL(project, \"Decora\", \"com\/sun\/scenario\/effect\/impl\/hw\", decoraAddExports) { sourceDir, destinationDir ->\n+        [[fileName: \"GenAllDecoraShaders\", generator: \"GenAllDecoraShaders\", outputs: \"-all\"]].each { settings ->\n@@ -2589,1 +2606,1 @@\n-    task nativeDecora(dependsOn: compileDecoraHLSLShaders, group: \"Build\") {\n+    task nativeDecora(group: \"Build\") {\n@@ -2592,0 +2609,6 @@\n+    if (IS_WINDOWS) {\n+        nativeDecora.dependsOn(compileDecoraHLSLShaders)\n+    }\n+    if (IS_MAC) {\n+        nativeDecora.dependsOn(compileDecoraMSLShaders)\n+    }\n@@ -2655,1 +2678,1 @@\n-    addJSL(project, \"Prism\", \"com\/sun\/prism\/d3d\/hlsl\", null) { sourceDir, destinationDir ->\n+    addJSL(project, \"Prism\", \"com\/sun\/prism\", null) { sourceDir, destinationDir ->\n@@ -2668,1 +2691,104 @@\n-                args = [\"-i\", sourceDir, \"-o\", destinationDir, \"-t\", \"-pkg\", \"com\/sun\/prism\", \"-d3d\", \"-es2\", \"-name\", \"$file\"]\n+                args = [\"-i\", sourceDir, \"-o\", destinationDir, \"-t\", \"-pkg\", \"com\/sun\/prism\", \"-d3d\", \"-es2\", \"-mtl\", \"-name\", \"$file\"]\n+            }\n+        }\n+    }\n+\n+    if (IS_MAC) {\n+        task compileMSLPassThroughVS(group: \"Build\") {\n+            def PASSTHROUGH_VS_SRC = file(\"src\/main\/native-prism-mtl\/msl\/PassThroughVS.metal\")\n+            doLast {\n+                mkdir \"$buildDir\/msl\"\n+                exec {\n+                    commandLine(\"${metalCompiler}\")\n+                    args += [ \"-std=${mslVersion}\" ]\n+                    args += [ \"-c\" ]\n+                    args += [ \"$PASSTHROUGH_VS_SRC\" ]\n+                    args += [ \"-o\" ]\n+                    args += [ \"$buildDir\/msl\/PassThroughVS.air\" ]\n+                }\n+            }\n+        }\n+        nativePrism.dependsOn compileMSLPassThroughVS;\n+\n+        task compileMSLClearRttShaders(group: \"Build\") {\n+            def CLEAR_RTT_VFS_SRC = file(\"src\/main\/native-prism-mtl\/msl\/ClearRttShaders.metal\")\n+            doLast {\n+                mkdir \"$buildDir\/msl\"\n+                exec {\n+                    commandLine(\"${metalCompiler}\")\n+                    args += [ \"-std=${mslVersion}\" ]\n+                    args += [ \"-c\" ]\n+                    args += [ \"$CLEAR_RTT_VFS_SRC\" ]\n+                    args += [ \"-o\" ]\n+                    args += [ \"$buildDir\/msl\/ClearRttShaders.air\" ]\n+                }\n+            }\n+        }\n+        nativePrism.dependsOn compileMSLClearRttShaders;\n+\n+        task compileMSLComputeKernels(group: \"Build\") {\n+            def COMPUTE_KERNELS_SRC = file(\"src\/main\/native-prism-mtl\/msl\/ComputeKernels.metal\")\n+            doLast {\n+                mkdir \"$buildDir\/msl\"\n+                exec {\n+                    commandLine(\"${metalCompiler}\")\n+                    args += [ \"-std=${mslVersion}\" ]\n+                    args += [ \"-c\" ]\n+                    args += [ \"$COMPUTE_KERNELS_SRC\" ]\n+                    args += [ \"-o\" ]\n+                    args += [ \"$buildDir\/msl\/ComputeKernels.air\" ]\n+                }\n+            }\n+        }\n+        nativePrism.dependsOn compileMSLComputeKernels;\n+\n+        task compileMSLPhongVS(group: \"Build\") {\n+            def PHONG_VS_SRC = file(\"src\/main\/native-prism-mtl\/msl\/PhongVS.metal\")\n+            doLast {\n+                mkdir \"$buildDir\/msl\"\n+                exec {\n+                    commandLine(\"${metalCompiler}\")\n+                    args += [ \"-std=${mslVersion}\" ]\n+                    args += [ \"-c\" ]\n+                    args += [ \"$PHONG_VS_SRC\" ]\n+                    args += [ \"-o\" ]\n+                    args += [ \"$buildDir\/msl\/PhongVS.air\" ]\n+                }\n+            }\n+        }\n+        nativePrism.dependsOn compileMSLPhongVS;\n+\n+        task compileMSLPhongPS(group: \"Build\") {\n+            def PHONG_PS_SRC = file(\"src\/main\/native-prism-mtl\/msl\/PhongPS.metal\")\n+            doLast {\n+                mkdir \"$buildDir\/msl\"\n+                exec {\n+                    commandLine(\"${metalCompiler}\")\n+                    args += [ \"-std=${mslVersion}\" ]\n+                    args += [ \"-c\" ]\n+                    args += [ \"$PHONG_PS_SRC\" ]\n+                    args += [ \"-o\" ]\n+                    args += [ \"$buildDir\/msl\/PhongPS.air\" ]\n+                }\n+            }\n+        }\n+        nativePrism.dependsOn compileMSLPhongPS;\n+\n+        task linkMSLShader(group: \"Build\") {\n+            dependsOn(compileDecoraMSLShaders,\n+                      compilePrismMSLShaders,\n+                      compileMSLPassThroughVS,\n+                      compileMSLClearRttShaders,\n+                      compileMSLComputeKernels,\n+                      compileMSLPhongVS,\n+                      compileMSLPhongPS)\n+            doLast {\n+                mkdir \"$buildDir\/msl\/com\/sun\/prism\/mtl\/msl\"\n+                def shaderFiles = fileTree(dir: \"$buildDir\/msl\", include: \"**\/*.air\")\n+                exec {\n+                    commandLine(\"${metalLinker}\")\n+                    shaderFiles.each { shaderFile ->\n+                        args += shaderFile\n+                    }\n+                    args += [ \"-o\", \"$buildDir\/msl\/com\/sun\/prism\/mtl\/msl\/jfxshaders.metallib\" ]\n+                }\n@@ -2671,0 +2797,9 @@\n+        processResources.dependsOn linkMSLShader\n+\n+        \/\/ Copy metallib file as resource\n+        def copyMetalLib = project.task(\"copyMetalLib\", type: Copy, dependsOn: linkMSLShader) {\n+            from \"$buildDir\/msl\/com\/sun\/prism\/mtl\/msl\/jfxshaders.metallib\"\n+            into \"${project.moduleDir}\/com\/sun\/prism\/mtl\/msl\"\n+        }\n+\n+        processResources.dependsOn copyMetalLib\n@@ -2683,1 +2818,0 @@\n-\n@@ -2685,0 +2819,3 @@\n+    if (IS_MAC) {\n+        nativePrism.dependsOn compilePrismMSLShaders;\n+    }\n@@ -2691,0 +2828,11 @@\n+    if (IS_MAC) {\n+        def copyShimsMetalLibTask = project.task(\"copyShimsMetalLib\", type: Copy,\n+                dependsOn: [project.tasks.getByName(\"compileFullJava\"),\n+                            project.tasks.getByName(\"processResources\")]) {\n+            from project.moduleDir\n+            into project.moduleShimsDir\n+            include \"**\/jfxshaders.metallib\"\n+        }\n+        processShimsResources.dependsOn(copyShimsMetalLibTask)\n+    }\n+\n@@ -5472,0 +5620,2 @@\n+                             \"com\/sun\/prism\/mtl\",\n+                             \"com\/sun\/scenario\/effect\/impl\/hw\/mtl\/MTLShaderSource.java\"\n@@ -5627,0 +5777,3 @@\n+            if (IS_MAC) {\n+                libs += ['prismMTL']\n+            }\n","filename":"build.gradle","additions":170,"deletions":17,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -128,0 +128,4 @@\n+\n+# Metal version, for Metal Shader compilation\n+# 2.4 is required for supporting macOS 12\n+msl.version=macos-metal2.4\n","filename":"build.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,0 +160,1 @@\n+        \"-framework\", \"Metal\",\n@@ -170,0 +171,3 @@\n+def metalCompiler\n+def metalLinker\n+\n@@ -172,0 +176,2 @@\n+    metalCompiler = \"${toolchainDir}metal\"\n+    metalLinker = \"${toolchainDir}metallib\"\n@@ -174,0 +180,26 @@\n+    ByteArrayOutputStream path = new ByteArrayOutputStream();\n+    exec {\n+        \/\/ xcrun -f --sdk macosx metal\n+        commandLine(\"xcrun\", \"-f\", \"--sdk\", \"macosx\", \"metal\");\n+        setStandardOutput(path);\n+        ignoreExitValue(true);\n+    }\n+    metalCompiler = path.toString().trim();\n+\n+    path = new ByteArrayOutputStream();\n+    exec {\n+        \/\/ xcrun -f --sdk macosx metallib\n+        commandLine(\"xcrun\", \"-f\", \"--sdk\", \"macosx\", \"metallib\");\n+        setStandardOutput(path);\n+        ignoreExitValue(true);\n+    }\n+    metalLinker = path.toString().trim();\n+\n+    if (metalCompiler == \"\" || metalLinker == \"\") {\n+        throw new GradleException(\n+            \"\"\"\n+            FAIL: Cannot find Metal Shader Language (MSL) tools: metal and metallib\n+            Please make sure that MSL tools metal and metallib are installed and available on PATH.\n+            \"\"\"\n+        );\n+    }\n@@ -179,0 +211,3 @@\n+ext.metalCompiler = metalCompiler\n+ext.metalLinker = metalLinker\n+\n@@ -249,0 +284,11 @@\n+MAC.prismMTL = [:]\n+MAC.prismMTL.javahInclude = [\"com\/sun\/prism\/mtl\/**\/*\"]\n+MAC.prismMTL.nativeSource = [\n+    file(\"${project(\"graphics\").projectDir}\/src\/main\/native-prism-mtl\")\n+]\n+MAC.prismMTL.compiler = compiler\n+MAC.prismMTL.ccFlags = [\"-I${project(\"graphics\").projectDir}\/build\/gensrc\/mtl-headers\", \"-DMACOSX\", \"-Werror=objc-method-access\", ccFlags].flatten()\n+MAC.prismMTL.linker = linker\n+MAC.prismMTL.linkFlags = [linkFlags].flatten()\n+MAC.prismMTL.lib = \"prism_mtl\"\n+\n","filename":"buildSrc\/mac.gradle","additions":47,"deletions":1,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class CompileMSLTask extends NativeCompileTask {\n+    protected File outputFile(File sourceFile) {\n+        new File(\"$output\/${sourceFile.name.replace('.metal', '.air')}\");\n+    }\n+\n+    protected void doCompile(File sourceFile, File outputFile){\n+        def headerDir = 'gensrc\/mtl-headers';\n+        def includeDir = \"$project.buildDir\/$headerDir\"\n+        project.exec({\n+            commandLine = [\"${project.metalCompiler}\", \"-Wdeprecated\", \"-std=macos-metal2.4\", \"-I\", \"$includeDir\", \"-c\", \"$sourceFile\", \"-o\", \"$outputFile\"]\n+        });\n+    }\n+}\n","filename":"buildSrc\/src\/main\/groovy\/com\/sun\/javafx\/gradle\/CompileMSLTask.groovy","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -8,0 +8,1 @@\n+\t<classpathentry kind=\"src\" path=\"build\/msl\/\"\/>\n","filename":"modules\/javafx.graphics\/.classpath","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import com.sun.scenario.effect.compiler.backend.hw.MSLBackend;\n@@ -60,2 +61,3 @@\n-    public static final int OUT_JAVA     = (1 << 2);\n-    public static final int OUT_PRISM    = (1 << 3);\n+    public static final int OUT_MTL      = (1 << 2);\n+    public static final int OUT_JAVA     = (1 << 3);\n+    public static final int OUT_PRISM    = (1 << 4);\n@@ -63,4 +65,5 @@\n-    public static final int OUT_SSE_JAVA        = (1 << 4);\n-    public static final int OUT_SSE_NATIVE      = (1 << 5);\n-    public static final int OUT_ME_JAVA         = (1 << 6);\n-    public static final int OUT_ME_NATIVE       = (1 << 7);\n+\n+    public static final int OUT_SSE_JAVA        = (1 << 5);\n+    public static final int OUT_SSE_NATIVE      = (1 << 6);\n+    public static final int OUT_ME_JAVA         = (1 << 7);\n+    public static final int OUT_ME_NATIVE       = (1 << 8);\n@@ -73,1 +76,1 @@\n-    public static final int OUT_HW_SHADERS = OUT_D3D | OUT_ES2;\n+    public static final int OUT_HW_SHADERS = OUT_D3D | OUT_ES2 | OUT_MTL;\n@@ -134,0 +137,1 @@\n+        OUT_MTL,        \"decora-mtl\/build\/gensrc\/{pkg}\/impl\/hw\/mtl\/msl\/{name}.metal\",\n@@ -224,0 +228,13 @@\n+        if ((outTypes & OUT_MTL) != 0) {\n+            File outFile = jslcinfo.getOutputFile(OUT_MTL);\n+            if (jslcinfo.force || outOfDate(outFile, sourceTime)) {\n+                if (pinfo == null) pinfo = getParserInfo(stream);\n+                MSLBackend mslBackend = new MSLBackend(pinfo.parser, pinfo.visitor);\n+                String shaderFileName = outFile.getName().replace(\".metal\", \"\");\n+                mslBackend.setShaderNameAndHeaderPath(shaderFileName, outFile.getCanonicalPath());\n+                mslBackend.scan(pinfo.program);\n+                String shader = mslBackend.getShader();\n+                write(shader, outFile);\n+            }\n+        }\n+\n@@ -386,0 +403,2 @@\n+            } else if (arg.equals(\"-mtl\")) {\n+                outTypes |= OUT_MTL;\n","filename":"modules\/javafx.graphics\/src\/jslc\/java\/com\/sun\/scenario\/effect\/compiler\/JSLC.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,531 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.scenario.effect.compiler.backend.hw;\n+\n+import com.sun.scenario.effect.compiler.JSLParser;\n+import com.sun.scenario.effect.compiler.model.CoreSymbols;\n+import com.sun.scenario.effect.compiler.model.Function;\n+import com.sun.scenario.effect.compiler.model.Param;\n+import com.sun.scenario.effect.compiler.model.Precision;\n+import com.sun.scenario.effect.compiler.model.Qualifier;\n+import com.sun.scenario.effect.compiler.model.Type;\n+import com.sun.scenario.effect.compiler.model.Variable;\n+import com.sun.scenario.effect.compiler.tree.CallExpr;\n+import com.sun.scenario.effect.compiler.tree.DiscardStmt;\n+import com.sun.scenario.effect.compiler.tree.Expr;\n+import com.sun.scenario.effect.compiler.tree.FuncDef;\n+import com.sun.scenario.effect.compiler.tree.JSLVisitor;\n+import com.sun.scenario.effect.compiler.tree.VarDecl;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import static java.util.Map.entry;\n+\n+\/*\n+ * Class that generates Metal shaders from JSL.\n+ *\/\n+\n+public class MSLBackend extends SLBackend {\n+\n+    private static String headerFilesDir = null;\n+    private static final String FRAGMENT_SHADER_HEADER_FILE_NAME = \"FragmentShaderCommon.h\";\n+    private static final StringBuilder objCHeader = new StringBuilder();\n+    private static String objCHeaderFileName;\n+    private static final String PRISM_SHADER_HEADER_FILE_NAME = \"PrismShaderCommon.h\";\n+    private static final String DECORA_SHADER_HEADER_FILE_NAME = \"DecoraShaderCommon.h\";\n+    private static final List<String> shaderFunctionNameList = new ArrayList<>();\n+\n+    private String shaderFunctionName;\n+    private String sampleTexFuncName;\n+    private String uniformStructName;\n+    private final List<String> uniformNames = new ArrayList<>();\n+    private String uniformIDsEnumName;\n+    private String uniformIDs;\n+    private int uniformIDCount;\n+    private String uniformsForShaderFile; \/\/ visitVarDecl() accumulates all the Uniforms in this string.\n+    private String uniformsForObjCFiles;\n+    private boolean isPrismShader;\n+    private boolean hasTextureVar;\n+\n+    private final List<String> helperFunctions = new ArrayList<>();\n+    private static final String MTL_HEADERS_DIR = \"\/mtl-headers\/\";\n+    private static final String MAIN = \"void main() {\";\n+\n+    private static final Map<String, String> QUAL_MAP = Map.of(\n+        \"param\", \"constant\");\n+\n+    private static final Map<String, String> texSamplerMap = new HashMap<>();\n+\n+    private static final Map<String, String> TYPE_MAP = Map.of(\n+        \"sampler\",  \"texture2d<float>\",\n+        \"lsampler\", \"texture2d<float>\",\n+        \"fsampler\", \"texture2d<float>\");\n+\n+    private static final Map<String, String> VAR_MAP = Map.ofEntries(\n+        entry(\"pos0\",                     \"in.texCoord0\"),\n+        entry(\"pos1\",                     \"in.texCoord1\"),\n+        entry(\"pixcoord\",                 \"in.position.xy\"),\n+        entry(\"color\",                    \"outFragColor\"),\n+        entry(\"jsl_vertexColor\",          \"in.fragColor\"),\n+        \/\/ The uniform variables are combined into a struct. These structs are generated while\n+        \/\/ parsing the jsl shader files and are added to the header files in mtl-headers directory.\n+        \/\/ Each fragment function receives a pointer variable named uniforms(to respective struct of Uniforms)\n+        \/\/ hence all the following uniform variable names must be replaced by uniforms.var_name.\n+        entry(\"weights\",                  \"uniforms.weights\"),\n+        entry(\"kvals\",                    \"uniforms.kvals\"),\n+        entry(\"opacity\",                  \"uniforms.opacity\"),\n+        entry(\"offset\",                   \"uniforms.offset\"),\n+        entry(\"shadowColor\",              \"uniforms.shadowColor\"),\n+        entry(\"surfaceScale\",             \"uniforms.surfaceScale\"),\n+        entry(\"level\",                    \"uniforms.level\"),\n+        entry(\"sampletx\",                 \"uniforms.sampletx\"),\n+        entry(\"wrap\",                     \"uniforms.wrap\"),\n+        entry(\"imagetx\",                  \"uniforms.imagetx\"),\n+        entry(\"contrast\",                 \"uniforms.contrast\"),\n+        entry(\"hue\",                      \"uniforms.hue\"),\n+        entry(\"saturation\",               \"uniforms.saturation\"),\n+        entry(\"brightness\",               \"uniforms.brightness\"),\n+        entry(\"tx0\",                      \"uniforms.tx0\"),\n+        entry(\"tx1\",                      \"uniforms.tx1\"),\n+        entry(\"tx2\",                      \"uniforms.tx2\"),\n+        entry(\"threshold\",                \"uniforms.threshold\"),\n+        entry(\"lightPosition\",            \"uniforms.lightPosition\"),\n+        entry(\"lightColor\",               \"uniforms.lightColor\"),\n+        entry(\"diffuseConstant\",          \"uniforms.diffuseConstant\"),\n+        entry(\"specularConstant\",         \"uniforms.specularConstant\"),\n+        entry(\"specularExponent\",         \"uniforms.specularExponent\"),\n+        entry(\"lightSpecularExponent\",    \"uniforms.lightSpecularExponent\"),\n+        entry(\"normalizedLightPosition\",  \"uniforms.normalizedLightPosition\"),\n+        entry(\"normalizedLightDirection\", \"uniforms.normalizedLightDirection\"),\n+        entry(\"fractions\",                \"uniforms.fractions\"),\n+        entry(\"oinvarcradii\",             \"uniforms.oinvarcradii\"),\n+        entry(\"iinvarcradii\",             \"uniforms.iinvarcradii\"),\n+        entry(\"precalc\",                  \"uniforms.precalc\"),\n+        entry(\"m0\",                       \"uniforms.m0\"),\n+        entry(\"m1\",                       \"uniforms.m1\"),\n+        entry(\"perspVec\",                 \"uniforms.perspVec\"),\n+        entry(\"gradParams\",               \"uniforms.gradParams\"),\n+        entry(\"idim\",                     \"uniforms.idim\"),\n+        entry(\"gamma\",                    \"uniforms.gamma\"),\n+        entry(\"xParams\",                  \"uniforms.xParams\"),\n+        entry(\"yParams\",                  \"uniforms.yParams\"),\n+        entry(\"lumaAlphaScale\",           \"uniforms.lumaAlphaScale\"),\n+        entry(\"cbCrScale\",                \"uniforms.cbCrScale\"),\n+        entry(\"innerOffset\",              \"uniforms.innerOffset\"),\n+        entry(\"content\",                  \"uniforms.content\"),\n+        entry(\"img\",                      \"uniforms.img\"),\n+        entry(\"botImg\",                   \"uniforms.botImg\"),\n+        entry(\"topImg\",                   \"uniforms.topImg\"),\n+        entry(\"bumpImg\",                  \"uniforms.bumpImg\"),\n+        entry(\"origImg\",                  \"uniforms.origImg\"),\n+        entry(\"baseImg\",                  \"uniforms.baseImg\"),\n+        entry(\"mapImg\",                   \"uniforms.mapImg\"),\n+        entry(\"colors\",                   \"uniforms.colors\"),\n+        entry(\"maskInput\",                \"uniforms.maskInput\"),\n+        entry(\"glyphColor\",               \"uniforms.glyphColor\"),\n+        entry(\"dstColor\",                 \"uniforms.dstColor\"),\n+        entry(\"maskTex\",                  \"uniforms.maskTex\"),\n+        entry(\"imageTex\",                 \"uniforms.imageTex\"),\n+        entry(\"inputTex\",                 \"uniforms.inputTex\"),\n+        entry(\"alphaTex\",                 \"uniforms.alphaTex\"),\n+        entry(\"cbTex\",                    \"uniforms.cbTex\"),\n+        entry(\"crTex\",                    \"uniforms.crTex\"),\n+        entry(\"lumaTex\",                  \"uniforms.lumaTex\"),\n+        entry(\"inputTex0\",                \"uniforms.inputTex0\"),\n+        entry(\"inputTex1\",                \"uniforms.inputTex1\")\n+    );\n+\n+    private static final Map<String, String> FUNC_MAP = Map.of(\n+        \"sample\",  \"sampleTex\",\n+        \"ddx\",     \"dfdx\",\n+        \"ddy\",     \"dfdy\",\n+        \"intcast\", \"int\");\n+\n+    public MSLBackend(JSLParser parser, JSLVisitor visitor) {\n+        super(parser, visitor);\n+    }\n+\n+    @Override\n+    protected String getQualifier(Qualifier q) {\n+        String qualifier = q.toString();\n+        return QUAL_MAP.getOrDefault(qualifier, qualifier);\n+    }\n+\n+    @Override\n+    protected String getType(Type t) {\n+        String type = t.toString();\n+        return TYPE_MAP.getOrDefault(type, type);\n+    }\n+\n+    @Override\n+    protected String getVar(String v) {\n+        return VAR_MAP.getOrDefault(v, v);\n+    }\n+\n+    @Override\n+    protected String getFuncName(String f) {\n+        return FUNC_MAP.getOrDefault(f, f);\n+    }\n+\n+    @Override\n+    protected String getPrecision(Precision p) {\n+        return p.name();\n+    }\n+\n+    @Override\n+    public void visitCallExpr(CallExpr e) {\n+        output(getFuncName(e.getFunction().getName()) + \"(\");\n+        boolean first = true;\n+        for (Expr param : e.getParams()) {\n+            if (first) {\n+                \/\/ For every user defined function, pass reference to 4 samplers and\n+                \/\/ reference to the uniforms struct.\n+                if (!CoreSymbols.getFunctions().contains(e.getFunction())) {\n+                    output(\"sampler0, sampler1, sampler2, sampler3, uniforms, \");\n+                }\n+                first = false;\n+            } else {\n+                output(\", \");\n+            }\n+            scan(param);\n+        }\n+        output(\")\");\n+    }\n+\n+    @Override\n+    public void visitFuncDef(FuncDef d) {\n+        Function func = d.getFunction();\n+        helperFunctions.add(func.getName());\n+        output(getType(func.getReturnType()) + \" \" + func.getName() + \"(\");\n+        boolean first = true;\n+        for (Param param : func.getParams()) {\n+            if (first) {\n+                \/\/ Add 4 sampler variables and \"device <Uniforms>& uniforms\" as the parameter to all user defined functions.\n+                if (!CoreSymbols.getFunctions().contains(d.getFunction())) {\n+                    output(\"sampler sampler0, sampler sampler1, sampler sampler2, sampler sampler3, device \" + uniformStructName + \"& uniforms,\\n\");\n+                }\n+                first = false;\n+            } else {\n+                output(\", \");\n+            }\n+            output(getType(param.getType()) + \" \" + param.getName());\n+        }\n+        output(\") \");\n+        scan(d.getStmt());\n+    }\n+\n+    @Override\n+    public void visitVarDecl(VarDecl d) {\n+        Variable var = d.getVariable();\n+        Qualifier qual = var.getQualifier();\n+        switch (qual) {\n+            case Qualifier.CONST -> {\n+                \/\/ example: const int i = 10;\n+                \/\/ const variables are converted into macro.\n+                \/\/ reason: In MSL, only the program scoped variables can be declared as constant(address space).\n+                \/\/ Function scope variables cannot be declared as constant.\n+                \/\/ In our shaders, there is one function scope variable 'const float third'\n+                \/\/ which causes a compilation error if all const are replaced with constant.\n+                \/\/ So alternate approach is to use macros for all const variables.\n+                output(\"#define \" + var.getName());\n+                output(\" (\");\n+                scan(d.getInit());\n+                output(\")\\n\");\n+            }\n+            case Qualifier.PARAM -> {\n+                \/\/ These are uniform variables.\n+                \/\/ In MSL, uniform variables can be declared by using function_constant attribute.\n+                \/\/ function_constant variables can only be scalar or vector type.\n+                \/\/ User defined type or array of scalar or vector cannot be declared as function_constants.\n+                \/\/ So we combine all uniform variables into a struct named Uniforms.\n+                String aUniform = \"\";\n+                Precision precision = var.getPrecision();\n+                if (precision != null) {\n+                    String precisionStr = getPrecision(precision);\n+                    if (precisionStr != null) {\n+                        aUniform += precisionStr + \" \";\n+                    }\n+                }\n+                if (getType(var.getType()).contains(\"texture2d\")) {\n+                    hasTextureVar = true;\n+                    texSamplerMap.put(var.getName(), \"sampler\" + texSamplerMap.size());\n+                }\n+                uniformNames.add(var.getName());\n+                aUniform += getType(var.getType()) + \" \" + var.getName();\n+                if (var.isArray()) {\n+                    aUniform += \"[\" + var.getArraySize() + \"]\";\n+                }\n+\n+                if (!uniformIDs.contains(var.getName())) {\n+                    uniformIDs += \"    \" + shaderFunctionName + \"_\" + var.getName() + \"_ID = \" + uniformIDCount + \",\\n\";\n+                    if (var.isArray()) {\n+                        uniformIDCount += var.getArraySize();\n+                    } else {\n+                        uniformIDCount++;\n+                    }\n+                }\n+                if (!uniformsForShaderFile.contains(var.getName())) {\n+                    uniformsForShaderFile += \"    \" + aUniform + \";\\n\";\n+                }\n+                if (!uniformsForObjCFiles.contains(var.getName())) {\n+                    uniformsForObjCFiles += \"    \" + aUniform + \";\\n\";\n+                }\n+            }\n+            case null -> super.visitVarDecl(d);\n+        }\n+    }\n+\n+    @Override\n+    public void visitDiscardStmt(DiscardStmt s) {\n+        output(\" discard_fragment();\\n\");\n+    }\n+\n+    private void updateCommonHeaders() {\n+        String shaderType = isPrismShader ? \"PRISM\" : \"DECORA\";\n+\n+        try (FileWriter objCHeaderFile = new FileWriter(headerFilesDir + objCHeaderFileName)) {\n+\n+            if (!hasTextureVar) {\n+                String unusedUniform = \"UNUSED\";\n+                uniformNames.add(unusedUniform);\n+                uniformsForObjCFiles  += \"    texture2d<float> \" + unusedUniform + \";\\n\";\n+                uniformIDs += \"    \" + shaderFunctionName + \"_\" + unusedUniform + \"_ID = \" + uniformIDCount + \",\\n\";\n+                uniformIDCount++;\n+            }\n+\n+            uniformsForObjCFiles = uniformsForObjCFiles.replace(\"texture2d<float>\", \"id<MTLTexture>\");\n+            uniformsForObjCFiles = uniformsForObjCFiles.replace(\" float2\", \" packed_float2\");\n+            uniformsForObjCFiles = uniformsForObjCFiles.replace(\" float3\", \" vector_float3\");\n+            uniformsForObjCFiles = uniformsForObjCFiles.replace(\" float4\", \" packed_float4\");\n+\n+            if (objCHeader.length() == 0) {\n+                objCHeader.append(\"#ifndef \" + shaderType + \"_SHADER_COMMON_H\\n\" +\n+                                \"#define \" + shaderType + \"_SHADER_COMMON_H\\n\\n\" +\n+                                \"#import <Metal\/Metal.h>\\n\" +\n+                                \"#import <simd\/simd.h>\\n\\n\" +\n+                                \"#ifdef MSL_BACKEND_VERBOSE\\n\" +\n+                                \"#define MSL_LOG NSLog\\n\" +\n+                                \"#else\\n\" +\n+                                \"#define MSL_LOG(...)\\n\" +\n+                                \"#endif\\n\\n\" +\n+                                \"typedef struct \" + shaderType + \"_VS_INPUT {\\n\" +\n+                                \"    packed_float2 position;\\n\" +\n+                                \"    packed_float4 color;\\n\" +\n+                                \"    packed_float2 texCoord0;\\n\" +\n+                                \"    packed_float2 texCoord1;\\n\" +\n+                                \"} \" + shaderType + \"_VS_INPUT;\" +\n+                                \"\\n\\n\");\n+            }\n+\n+            if (uniformIDs != \"\") {\n+                objCHeader.append(\"typedef enum \" + uniformIDsEnumName +\n+                    \" {\\n\" + uniformIDs + \"\\n} \" + shaderFunctionName + \"ArgumentBufferID;\\n\\n\");\n+\n+                objCHeader.append(\"typedef struct \" + uniformStructName + \" {\\n\"\n+                    + uniformsForObjCFiles + \"} \" + uniformStructName + \";\\n\\n\");\n+\n+                objCHeader.append(\"NSDictionary* get\" + shaderFunctionName + \"_Uniform_VarID_Dict() {\\n\");\n+                objCHeader.append(\"    id ids[] = {\\n\");\n+                for (String aUniformName : uniformNames) {\n+                    objCHeader.append(\"        [NSNumber numberWithInt:\" + shaderFunctionName + \"_\" +\n+                        aUniformName + \"_ID\" + \"],\\n\");\n+                }\n+                objCHeader.append(\"    };\\n\\n\");\n+                objCHeader.append(\"    NSUInteger count = sizeof(ids) \/ sizeof(id);\\n\");\n+                objCHeader.append(\"    NSArray *idArray = [NSArray arrayWithObjects:ids count:count];\\n\");\n+\n+                objCHeader.append(\"    id uniforms[] = {\\n\");\n+                for (String aUniformName : uniformNames) {\n+                    objCHeader.append(\"        @\\\"\" + aUniformName + \"\\\",\\n\");\n+                }\n+                objCHeader.append(\"    };\\n\\n\");\n+                objCHeader.append(\"    NSArray *uniformArray = [NSArray arrayWithObjects:uniforms count:count];\\n\");\n+                objCHeader.append(\"    return [NSDictionary dictionaryWithObjects:idArray forKeys:uniformArray];\\n\");\n+                objCHeader.append(\"}\\n\\n\\n\");\n+            } else {\n+                objCHeader.append(\"NSDictionary* get\" + shaderFunctionName + \"_Uniform_VarID_Dict() {\\n\");\n+                objCHeader.append(\"    return nil;\\n\");\n+                objCHeader.append(\"}\\n\\n\\n\");\n+            }\n+\n+            objCHeaderFile.write(objCHeader.toString());\n+\n+            StringBuilder getShaderDictFunc = new StringBuilder();\n+            getShaderDictFunc.append(\"NSDictionary* get\" + shaderType + \"Dict(NSString* inShaderName) {\\n\");\n+            getShaderDictFunc.append(\"    MSL_LOG(@\\\"get\" + shaderType + \"Dict \\\");\\n\");\n+            for (String aShaderName : shaderFunctionNameList) {\n+                getShaderDictFunc.append(\"    if ([inShaderName isEqualToString:@\\\"\" + aShaderName + \"\\\"]) {\\n\");\n+                getShaderDictFunc.append(\"        MSL_LOG(@\\\"get\" + shaderType + \"Dict() : calling -> get\" + aShaderName + \"_Uniform_VarID_Dict()\\\");\\n\");\n+                getShaderDictFunc.append(\"        return get\" + aShaderName + \"_Uniform_VarID_Dict();\\n\");\n+                getShaderDictFunc.append(\"    }\\n\");\n+            }\n+            getShaderDictFunc.append(\"    return nil;\\n\");\n+            getShaderDictFunc.append(\"};\\n\\n\");\n+            objCHeaderFile.write(getShaderDictFunc.toString());\n+\n+            objCHeaderFile.write(\"#endif\\n\");\n+        } catch (IOException e) {\n+            System.err.println(\"An error occurred.\");\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Override\n+    protected String getHeader() {\n+        StringBuilder header = new StringBuilder();\n+\n+        header.append(\"#include \\\"\" + FRAGMENT_SHADER_HEADER_FILE_NAME + \"\\\"\\n\\n\");\n+\n+        if (!hasTextureVar) {\n+            String unusedUniform = \"UNUSED\";\n+            uniformsForShaderFile += \"    texture2d<float> \" + unusedUniform + \";\\n\";\n+        }\n+\n+        uniformsForShaderFile = uniformsForShaderFile.replace(\" float2\", \" vector_float2\");\n+        uniformsForShaderFile = uniformsForShaderFile.replace(\" float3\", \" vector_float3\");\n+        uniformsForShaderFile = uniformsForShaderFile.replace(\" float4\", \" vector_float4\");\n+        header.append(\"typedef struct \" + uniformStructName + \" {\\n\" + uniformsForShaderFile + \"} \" + uniformStructName + \";\\n\\n\");\n+\n+        if (hasTextureVar) {\n+            header.append(\"float4 \" + sampleTexFuncName + \"(sampler textureSampler, texture2d<float> colorTexture, float2 texCoord) {\\n\");\n+            header.append(\"    return colorTexture.sample(textureSampler, texCoord);\\n\");\n+            header.append(\"}\\n\\n\");\n+        }\n+\n+        return header.toString();\n+    }\n+\n+    @Override\n+    public String getShader() {\n+        String shader = super.getShader();\n+        updateCommonHeaders();\n+        String fragmentFunctionDef = \"\\n[[fragment]] float4 \" + shaderFunctionName + \"(VS_OUTPUT in [[ stage_in ]],\";\n+        fragmentFunctionDef += \"\\n    device \" + uniformStructName + \"& uniforms [[ buffer(0) ]]\";\n+        for (int i = 0; i < texSamplerMap.size(); i++) {\n+            fragmentFunctionDef += \",\\n    sampler sampler\"+i+\" [[ sampler(\"+i+\") ]]\";\n+        }\n+        fragmentFunctionDef += \") {\";\n+\n+        fragmentFunctionDef += \"\\n\\nfloat4 outFragColor;\";\n+\n+        shader = shader.replace(MAIN, fragmentFunctionDef);\n+\n+        int indexOfClosingBraceOfMain = shader.lastIndexOf('}');\n+        shader = shader.substring(0, indexOfClosingBraceOfMain) + \"return outFragColor;\\n\\n\" +\n+                shader.substring(indexOfClosingBraceOfMain, shader.length());\n+\n+        for (String helperFunction : helperFunctions) {\n+            shader = shader.replaceAll(\"\\\\b\" + helperFunction + \"\\\\b\", shaderFunctionName + \"_\" + helperFunction);\n+        }\n+        if (hasTextureVar) {\n+            shader = shader.replaceAll(\"\\\\bsampleTex\\\\b\", sampleTexFuncName);\n+            for (Map.Entry<String,String> entry : texSamplerMap.entrySet()) {\n+                shader = shader.replaceAll(\"\\\\b\" + sampleTexFuncName + \"\\\\(uniforms.\" + entry.getKey() + \"\\\\b\",\n+                    sampleTexFuncName + \"(\" + entry.getValue() + \", uniforms.\" + entry.getKey());\n+            }\n+        }\n+        \/\/ Remove the un-required samplers out of the 4 samplers added to all user defined functions\n+        for (int i = texSamplerMap.size(); i < 4; i++) {\n+            shader = shader.replaceAll(\"sampler sampler\" + i + \", \", \"\");\n+            shader = shader.replaceAll(\"sampler\" + i + \", \", \"\");\n+        }\n+\n+        return shader;\n+    }\n+\n+    public void setShaderNameAndHeaderPath(String name, String genMetalShaderPath) {\n+        shaderFunctionName = name;\n+        shaderFunctionNameList.add(shaderFunctionName);\n+        if (headerFilesDir == null) {\n+            headerFilesDir = genMetalShaderPath.substring(0, genMetalShaderPath.indexOf(\"jsl-\"));\n+            headerFilesDir += MTL_HEADERS_DIR;\n+            writeFragmentShaderHeader();\n+        }\n+        isPrismShader = genMetalShaderPath.contains(\"jsl-prism\");\n+        resetVariables();\n+    }\n+\n+    private void writeFragmentShaderHeader() {\n+        String fragmentShaderHeader = \"\"\"\n+        #ifndef FRAGMENT_COMMON_H\n+        #define FRAGMENT_COMMON_H\n+\n+        #pragma clang diagnostic ignored \"-Wunused\"\n+\n+        #include <simd\/simd.h>\n+        #include <metal_stdlib>\n+\n+        using namespace metal;\n+\n+        struct VS_OUTPUT {\n+            float4 position [[ position ]];\n+            float4 fragColor;\n+            float2 texCoord0;\n+            float2 texCoord1;\n+        };\n+\n+        #endif\n+        \"\"\";\n+\n+        try (FileWriter fragmentShaderHeaderFile = new FileWriter(headerFilesDir + FRAGMENT_SHADER_HEADER_FILE_NAME)) {\n+            fragmentShaderHeaderFile.write(fragmentShaderHeader);\n+        } catch (IOException e) {\n+            System.err.println(\"IOException occurred while creating \" + FRAGMENT_SHADER_HEADER_FILE_NAME +\n+                \": \" + e.getMessage());\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private void resetVariables() {\n+        uniformStructName = shaderFunctionName + \"_Uniforms\";\n+        uniformIDsEnumName = shaderFunctionName + \"_ArgumentBufferID\";\n+        sampleTexFuncName = shaderFunctionName + \"_SampleTexture\";\n+\n+        texSamplerMap.clear();\n+        helperFunctions.clear();\n+        uniformNames.clear();\n+        uniformsForShaderFile = \"\";\n+        uniformsForObjCFiles = \"\";\n+        uniformIDs = \"\";\n+        uniformIDCount = 0;\n+\n+        \/\/ MTLArguemntEncoder requires the argument struct buffer to contain atleast one variable\n+        \/\/ of type: buffers, textures, samplers, or any element with the [[id]] attributeâ€™\n+        \/\/ We have some(22) prism shaders for which the Uniform struct is either empty or contains only float2's\n+        \/\/ That causes MTL_SHADER_VALIDATION to fail and causes run time crash on Ventura.\n+        \/\/ So we add a variable texture2d<float> UNUSED; to each shader which does not\n+        \/\/ already have a texture variable.\n+        hasTextureVar = false;\n+\n+        objCHeaderFileName = isPrismShader ? PRISM_SHADER_HEADER_FILE_NAME :\n+                                                DECORA_SHADER_HEADER_FILE_NAME;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/jslc\/java\/com\/sun\/scenario\/effect\/compiler\/backend\/hw\/MSLBackend.java","additions":531,"deletions":0,"binary":false,"changes":531,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Collections;\n@@ -55,0 +56,4 @@\n+    public static Set<Function> getFunctions() {\n+        return Collections.unmodifiableSet(getAllFunctions());\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/jslc\/java\/com\/sun\/scenario\/effect\/compiler\/model\/CoreSymbols.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -773,1 +773,1 @@\n-    protected abstract int _getNativeFrameBuffer(long ptr);\n+    protected abstract long _getNativeFrameBuffer(long ptr);\n@@ -778,1 +778,1 @@\n-    public int getNativeFrameBuffer() {\n+    public long getNativeFrameBuffer() {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/View.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    protected int _getNativeFrameBuffer(long ptr) {\n+    protected long _getNativeFrameBuffer(long ptr) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-    @Override native protected int _getNativeFrameBuffer(long ptr);\n+    @Override native protected long _getNativeFrameBuffer(long ptr);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/ios\/IosView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    @Override native protected int _getNativeFrameBuffer(long ptr);\n+    @Override native protected long _getNativeFrameBuffer(long ptr);\n@@ -139,5 +139,0 @@\n-    native protected long _getNativeLayer(long ptr);\n-    public long getNativeLayer() {\n-        return _getNativeLayer(getNativeView());\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/mac\/MacView.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,1 +180,1 @@\n-    protected int _getNativeFrameBuffer(long ptr) {\n+    protected long _getNativeFrameBuffer(long ptr) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/monocle\/MonocleView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    protected int _getNativeFrameBuffer(long ptr) {\n+    protected long _getNativeFrameBuffer(long ptr) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,5 @@\n-        GLSL\n+        GLSL,\n+        \/**\n+         * The pipeline supports shaders built with the Metal shader language\n+         *\/\n+        MSL\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/GraphicsPipeline.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    protected int nativeFrameBuffer;\n+    protected long nativeFrameBuffer;\n@@ -274,1 +274,1 @@\n-    public int getNativeFrameBuffer() {\n+    public long getNativeFrameBuffer() {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/PresentableState.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -447,0 +447,10 @@\n+    @Override\n+    public Shader createShader(String shaderName,\n+                               Map<String, Integer> samplers,\n+                               Map<String, Integer> params,\n+                               int maxTexCoordIndex,\n+                               boolean isPixcoordUsed,\n+                               boolean isPerVertexColorUsed) {\n+        throw new UnsupportedOperationException(\"Not supported for D3D pipeline\");\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/d3d\/D3DResourceFactory.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -243,0 +243,10 @@\n+    @Override\n+    public Shader createShader(String shaderName,\n+            Map<String, Integer> samplers,\n+            Map<String, Integer> params,\n+            int maxTexCoordIndex,\n+            boolean isPixcoordUsed,\n+            boolean isPerVertexColorUsed) {\n+        throw new UnsupportedOperationException(\"Not supported for ES2 pipeline\");\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2ResourceFactory.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    int nativeDestHandle = 0;\n+    long nativeDestHandle = 0;\n@@ -240,1 +240,3 @@\n-        return nativeDestHandle;\n+        \/\/ The nativeDestHandle holds the value returned by glGenFramebuffersEXT.\n+        \/\/ Since glGenFramebuffersEXT returns a value of type GLuint, this type cast is safe.\n+        return (int)nativeDestHandle;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2SwapChain.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+    public static final boolean metalDebug;\n@@ -189,0 +190,2 @@\n+        metalDebug = getBoolean(systemProperties, \"prism.metalDebug\", false);\n+\n@@ -208,1 +211,1 @@\n-                tryOrderArr = new String[] { \"es2\", \"sw\" };\n+                tryOrderArr = new String[] { \"es2\", \"mtl\", \"sw\" };\n@@ -343,0 +346,3 @@\n+        if (verbose) {\n+            printBooleanOption(forceUploadingPainter, \"Forcing UploadingPainter\");\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/impl\/PrismSettings.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -195,0 +195,2 @@\n+\n+        public Texture[] getLastTextures() { return lastTextures; }\n@@ -722,1 +724,1 @@\n-    private void setTexture(int texUnit, Texture tex) {\n+    protected void setTexture(int texUnit, Texture tex) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/impl\/ps\/BaseShaderContext.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,564 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.glass.ui.Screen;\n+import com.sun.javafx.geom.Rectangle;\n+import com.sun.javafx.geom.Vec3d;\n+import com.sun.javafx.geom.transform.Affine3D;\n+import com.sun.javafx.geom.transform.BaseTransform;\n+import com.sun.javafx.geom.transform.GeneralTransform3D;\n+import com.sun.javafx.sg.prism.NGCamera;\n+import com.sun.javafx.sg.prism.NGDefaultCamera;\n+import com.sun.prism.CompositeMode;\n+import com.sun.prism.Graphics;\n+import com.sun.prism.MeshView;\n+import com.sun.prism.RTTexture;\n+import com.sun.prism.RenderTarget;\n+import com.sun.prism.Texture;\n+import com.sun.prism.impl.PrismSettings;\n+import com.sun.prism.impl.ps.BaseShaderContext;\n+import com.sun.prism.ps.Shader;\n+\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+class MTLContext extends BaseShaderContext {\n+\n+    public static final int NUM_QUADS = PrismSettings.superShader ? 4096 : 256;\n+\n+    private static final int MTL_COMPMODE_CLEAR   = 0;\n+    private static final int MTL_COMPMODE_SRC     = 1;\n+    private static final int MTL_COMPMODE_SRCOVER = 2;\n+    private static final int MTL_COMPMODE_DSTOUT  = 3;\n+    private static final int MTL_COMPMODE_ADD     = 4;\n+\n+    private static final int MTL_SAMPLER_ADDR_MODE_NOP                   = -1;\n+    \/\/ CLAMP_TO_EDGE\n+    private static final int MTL_SAMPLER_ADDR_MODE_CLAMP_TO_EDGE         = 0; \/\/ MTLSamplerAddressModeClampToEdge\n+    private static final int MTL_SAMPLER_ADDR_MODE_MIRR_CLAMP_TO_EDGE    = 1; \/\/ MTLSamplerAddressModeMirrorClampToEdge\n+    \/\/ REPEAT\n+    private static final int MTL_SAMPLER_ADDR_MODE_REPEAT                = 2; \/\/ MTLSamplerAddressModeRepeat\n+    private static final int MTL_SAMPLER_ADDR_MODE_MIRR_REPEAT           = 3; \/\/ MTLSamplerAddressModeMirrorRepeat\n+    \/\/ CLAMP_TO_ZERO\n+    private static final int MTL_SAMPLER_ADDR_MODE_CLAMP_TO_ZERO         = 4; \/\/ MTLSamplerAddressModeClampToZero\n+    private static final int MTL_SAMPLER_ADDR_MODE_CLAMP_TO_BORDER_COLOR = 5; \/\/ MTLSamplerAddressModeClampToBorderColor\n+\n+    private State state;\n+    private final long pContext;\n+    private MTLRTTexture renderTarget;\n+    private MTLResourceFactory resourceFactory;\n+    private MTLPipeline pipeline;\n+\n+    private int targetWidth;\n+    private int targetHeight;\n+\n+    private Vec3d cameraPos = new Vec3d();\n+    private static float rawMatrix[] = new float[16];\n+    private GeneralTransform3D worldTx = new GeneralTransform3D();\n+    private static final Affine3D scratchAffine3DTx = new Affine3D();\n+    private GeneralTransform3D scratchTx = new GeneralTransform3D(); \/\/ Column major matrix\n+    private GeneralTransform3D projViewTx = new GeneralTransform3D(); \/\/ Column major matrix\n+\n+    private static double[] tempAdjustClipSpaceMat = new double[16];\n+\n+    private static final ByteBuffer shaderLibBuffer;\n+\n+    public final static int CULL_BACK  = 110;\n+    public final static int CULL_FRONT = 111;\n+    public final static int CULL_NONE  = 112;\n+\n+    static {\n+        final String shaderLibName = \"msl\/jfxshaders.metallib\";\n+        final Class<?> clazz = MTLContext.class;\n+\n+        try {\n+            \/\/ Get the native shader library as a stream resource and read it into\n+            \/\/ an NIO ByteBuffer. This will be passed to the native MetalContext\n+            \/\/ initialization, which will load the shader library for each device.\n+            try (var in = new BufferedInputStream(clazz.getResourceAsStream(shaderLibName))) {\n+                byte[] data = in.readAllBytes();\n+                shaderLibBuffer = ByteBuffer.allocateDirect(data.length);\n+                shaderLibBuffer.put(data);\n+            }\n+        } catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    public void setRenderTargetTexture(MTLRTTexture rtt) {\n+        renderTarget = rtt;\n+    }\n+\n+    public MTLRTTexture getRenderTargetTexture() {\n+        return renderTarget;\n+    }\n+\n+    MTLContext(Screen screen, MTLResourceFactory factory) {\n+        super(screen, factory, NUM_QUADS);\n+        resourceFactory = factory;\n+        pContext = nInitialize(shaderLibBuffer);\n+    }\n+\n+    @Override\n+    public MTLResourceFactory getResourceFactory() {\n+        return resourceFactory;\n+    }\n+\n+    protected void initState() {\n+        super.init();\n+        state = new State();\n+        nSetCompositeMode(getContextHandle(), MTL_COMPMODE_SRCOVER);\n+    }\n+\n+    long getContextHandle() {\n+        return pContext;\n+    }\n+\n+    \/**\n+     * OpenGL projection transform use z-range of [-1, 1],\n+     * while Metal expects it to be [0, 1], so we need to adjust the matrix.\n+     * (comment from D3DContext, see JDK-8123305)\n+     *\/\n+    private GeneralTransform3D adjustClipSpace(GeneralTransform3D projViewTx) {\n+        double[] m = projViewTx.get(tempAdjustClipSpaceMat);\n+        m[8] = (m[8] + m[12])\/2;\n+        m[9] = (m[9] + m[13])\/2;\n+        m[10] = (m[10] + m[14])\/2;\n+        m[11] = (m[11] + m[15])\/2;\n+        projViewTx.set(m);\n+        return projViewTx;\n+    }\n+\n+    @Override\n+    protected State updateRenderTarget(RenderTarget target, NGCamera camera, boolean depthTest) {\n+        renderTarget = (MTLRTTexture)target;\n+        int res = nUpdateRenderTarget(pContext, renderTarget.getNativeHandle(), depthTest);\n+\n+        if (res != -1) {\n+            resetLastClip(state);\n+        }\n+\n+        targetWidth = target.getPhysicalWidth();\n+        targetHeight = target.getPhysicalHeight();\n+\n+        \/\/ Validate the camera before getting its computed data\n+        if (camera instanceof NGDefaultCamera ngDefCam) {\n+            ngDefCam.validate(targetWidth, targetHeight);\n+            projViewTx = adjustClipSpace(camera.getProjViewTx(projViewTx));\n+        } else {\n+            projViewTx = adjustClipSpace(camera.getProjViewTx(projViewTx));\n+            double vw = camera.getViewWidth();\n+            double vh = camera.getViewHeight();\n+            if (targetWidth != vw || targetHeight != vh) {\n+                projViewTx.scale(vw \/ targetWidth, vh \/ targetHeight, 1.0);\n+            }\n+        }\n+\n+        \/\/ Set projection view matrix\n+        nSetProjViewMatrix(pContext, depthTest,\n+            projViewTx.get(0),  projViewTx.get(1),  projViewTx.get(2),  projViewTx.get(3),\n+            projViewTx.get(4),  projViewTx.get(5),  projViewTx.get(6),  projViewTx.get(7),\n+            projViewTx.get(8),  projViewTx.get(9),  projViewTx.get(10), projViewTx.get(11),\n+            projViewTx.get(12), projViewTx.get(13), projViewTx.get(14), projViewTx.get(15));\n+\n+        cameraPos = camera.getPositionInWorld(cameraPos);\n+        return state;\n+    }\n+\n+    @Override\n+    protected void setTexture(int texUnit, Texture tex) {\n+        if (checkDisposed()) return;\n+\n+        if (tex != null) tex.assertLocked();\n+        Texture[] lastTextures = state.getLastTextures();\n+        if (tex != lastTextures[texUnit]) {\n+            flushVertexBuffer();\n+            lastTextures[texUnit] = tex;\n+        }\n+        updateTexture(texUnit, tex);\n+    }\n+\n+    @Override\n+    protected void updateTexture(int texUnit, Texture tex) {\n+        boolean linear;\n+        int wrapMode;\n+        if (tex != null) {\n+            linear = tex.getLinearFiltering();\n+            wrapMode = switch (tex.getWrapMode()) {\n+                case CLAMP_NOT_NEEDED -> MTL_SAMPLER_ADDR_MODE_NOP;\n+\n+                case CLAMP_TO_EDGE,\n+                     CLAMP_TO_EDGE_SIMULATED,\n+                     CLAMP_TO_ZERO_SIMULATED -> MTL_SAMPLER_ADDR_MODE_CLAMP_TO_EDGE;\n+\n+                case CLAMP_TO_ZERO -> MTL_SAMPLER_ADDR_MODE_CLAMP_TO_ZERO;\n+\n+                case REPEAT,\n+                     REPEAT_SIMULATED -> MTL_SAMPLER_ADDR_MODE_REPEAT;\n+            };\n+            MTLShader.setTexture(texUnit, tex, linear, wrapMode);\n+        }\n+    }\n+\n+    @Override\n+    protected void updateShaderTransform(Shader shader, BaseTransform xform) {\n+        if (xform == null) {\n+            xform = BaseTransform.IDENTITY_TRANSFORM;\n+        }\n+\n+        scratchTx.set(projViewTx);\n+        final GeneralTransform3D perspectiveTransform = getPerspectiveTransformNoClone();\n+        if (perspectiveTransform.isIdentity()) {\n+            scratchTx = scratchTx.mul(xform);\n+        } else {\n+            scratchTx = scratchTx.mul(xform).mul(perspectiveTransform);\n+        }\n+        nSetTransform(pContext,\n+            scratchTx.get(0),  scratchTx.get(1),  scratchTx.get(2),  scratchTx.get(3),\n+            scratchTx.get(4),  scratchTx.get(5),  scratchTx.get(6),  scratchTx.get(7),\n+            scratchTx.get(8),  scratchTx.get(9),  scratchTx.get(10), scratchTx.get(11),\n+            scratchTx.get(12), scratchTx.get(13), scratchTx.get(14), scratchTx.get(15));\n+    }\n+\n+    @Override\n+    protected void updateWorldTransform(BaseTransform xform) {\n+        worldTx.setIdentity();\n+        if ((xform != null) && (!xform.isIdentity())) {\n+            worldTx.mul(xform);\n+        }\n+    }\n+\n+    @Override\n+    protected void updateClipRect(Rectangle clipRect) {\n+        if (clipRect == null || clipRect.isEmpty()) {\n+            nResetClipRect(pContext);\n+        } else {\n+            int x = clipRect.x;\n+            int y = clipRect.y;\n+            int width  = clipRect.width;\n+            int height = clipRect.height;\n+            nSetClipRect(pContext, x, y, width, height);\n+        }\n+    }\n+\n+    @Override\n+    protected void updateCompositeMode(CompositeMode mode) {\n+        int mtlCompMode = switch (mode) {\n+            case CLEAR    -> MTL_COMPMODE_CLEAR;\n+            case SRC      -> MTL_COMPMODE_SRC;\n+            case SRC_OVER -> MTL_COMPMODE_SRCOVER;\n+            case DST_OUT  -> MTL_COMPMODE_DSTOUT;\n+            case ADD      -> MTL_COMPMODE_ADD;\n+        };\n+        nSetCompositeMode(getContextHandle(), mtlCompMode);\n+    }\n+\n+    @Override\n+    public void blit(RTTexture srcRTT, RTTexture dstRTT,\n+                    int srcX0, int srcY0, int srcX1, int srcY1,\n+                    int dstX0, int dstY0, int dstX1, int dstY1) {\n+        \/\/ Verify whether we can avoid this blit when we are trying\n+        \/\/ to resolve MSAA texture into non-MSAA texture, because in case of Metal\n+        \/\/ we resolve the texture while rendering itself,\n+        \/\/ implement or change in future if necessary\n+        long dstNativeHandle = (dstRTT instanceof MTLTexture mtl) ? mtl.getNativeHandle() : 0L;\n+        long srcNativeHandle = (srcRTT instanceof MTLTexture mtl) ? mtl.getNativeHandle() : 0L;\n+        nBlit(pContext, srcNativeHandle, dstNativeHandle,\n+            srcX0, srcY0, srcX1, srcY1,\n+            dstX0, dstY0, dstX1, dstY1);\n+    }\n+\n+    @Override\n+    protected void renderQuads(float[] coordArray, byte[] colorArray, int numVertices) {\n+        nDrawIndexedQuads(getContextHandle(), coordArray, colorArray, numVertices);\n+    }\n+\n+    public void commitCurrentCommandBuffer() {\n+        nCommitCurrentCommandBuffer(pContext);\n+    }\n+\n+    public long getMetalCommandQueue() {\n+        return nGetCommandQueue(pContext);\n+    }\n+\n+    @Override\n+    protected void setDeviceParametersFor2D() {\n+        \/\/ There are no Metal rendering pipeline states changed as a\n+        \/\/ result of this call, hence the method is no-op.\n+        \/\/ But overriding the method here for any future reference.\n+    }\n+\n+    @Override\n+    protected void setDeviceParametersFor3D() {\n+        \/\/ There are no Metal rendering pipeline states changed as a\n+        \/\/ result of this call, hence the method is no-op.\n+        \/\/ But overriding the method here for any future reference.\n+    }\n+\n+    long createMTLMesh() {\n+        if (checkDisposed()) return 0;\n+        return nCreateMTLMesh(pContext);\n+    }\n+\n+    void releaseMTLMesh(long nativeHandle) {\n+        nReleaseMTLMesh(pContext, nativeHandle);\n+    }\n+\n+    boolean buildNativeGeometry(long nativeHandle, float[] vertexBuffer, int vertexBufferLength,\n+                                short[] indexBuffer, int indexBufferLength) {\n+        return nBuildNativeGeometryShort(pContext, nativeHandle, vertexBuffer,\n+            vertexBufferLength, indexBuffer, indexBufferLength);\n+    }\n+\n+    boolean buildNativeGeometry(long nativeHandle, float[] vertexBuffer, int vertexBufferLength,\n+                                int[] indexBuffer, int indexBufferLength) {\n+        return nBuildNativeGeometryInt(pContext, nativeHandle, vertexBuffer,\n+            vertexBufferLength, indexBuffer, indexBufferLength);\n+    }\n+\n+    long createMTLPhongMaterial() {\n+        return nCreateMTLPhongMaterial(pContext);\n+    }\n+\n+    void releaseMTLPhongMaterial(long nativeHandle) {\n+        nReleaseMTLPhongMaterial(pContext, nativeHandle);\n+    }\n+\n+    void setDiffuseColor(long nativePhongMaterial, float r, float g, float b, float a) {\n+        nSetDiffuseColor(pContext, nativePhongMaterial, r, g, b, a);\n+    }\n+\n+    void setSpecularColor(long nativePhongMaterial, boolean set, float r, float g, float b, float a) {\n+        nSetSpecularColor(pContext, nativePhongMaterial, set, r, g, b, a);\n+    }\n+\n+    void setMap(long nativePhongMaterial, int mapType, long nativeTexture) {\n+        nSetMap(pContext, nativePhongMaterial, mapType, nativeTexture);\n+    }\n+\n+    long createMTLMeshView(long nativeMesh) {\n+        return nCreateMTLMeshView(pContext, nativeMesh);\n+    }\n+\n+    void releaseMTLMeshView(long nativeMeshView) {\n+        nReleaseMTLMeshView(pContext, nativeMeshView);\n+    }\n+\n+    void setCullingMode(long nativeMeshView, int cullMode) {\n+        int cm;\n+        if (cullMode == MeshView.CULL_NONE) {\n+            cm = CULL_NONE;\n+        } else if (cullMode == MeshView.CULL_BACK) {\n+            cm = CULL_BACK;\n+        } else if (cullMode == MeshView.CULL_FRONT) {\n+            cm = CULL_FRONT;\n+        } else {\n+            throw new IllegalArgumentException(\"illegal value for CullMode: \" + cullMode);\n+        }\n+        nSetCullingMode(pContext, nativeMeshView, cm);\n+    }\n+\n+    void setMaterial(long nativeMeshView, long nativePhongMaterial) {\n+        nSetMaterial(pContext, nativeMeshView, nativePhongMaterial);\n+    }\n+\n+    void setWireframe(long nativeMeshView, boolean wireframe) {\n+        nSetWireframe(pContext, nativeMeshView, wireframe);\n+    }\n+\n+    void setAmbientLight(long nativeMeshView, float r, float g, float b) {\n+        nSetAmbientLight(pContext, nativeMeshView, r, g, b);\n+    }\n+\n+    void setLight(long nativeMeshView, int index, float x, float y, float z,\n+                  float r, float g, float b, float w,\n+                  float ca, float la, float qa, float isAttenuated, float maxRange,\n+                  float dirX, float dirY, float dirZ,\n+                  float innerAngle, float outerAngle, float falloff) {\n+        nSetLight(pContext, nativeMeshView, index, x, y, z, r, g, b, w,\n+                    ca, la, qa, isAttenuated, maxRange,\n+                    dirX, dirY, dirZ, innerAngle, outerAngle, falloff);\n+    }\n+\n+    void renderMeshView(long nativeMeshView, Graphics g) {\n+        \/\/ Support retina display by scaling the projViewTx and pass it to the shader.\n+        float pixelScaleFactorX = g.getPixelScaleFactorX();\n+        float pixelScaleFactorY = g.getPixelScaleFactorY();\n+        if (pixelScaleFactorX != 1.0 || pixelScaleFactorY != 1.0) {\n+            scratchTx = scratchTx.set(projViewTx);\n+            scratchTx.scale(pixelScaleFactorX, pixelScaleFactorY, 1.0);\n+            updateRawMatrix(scratchTx);\n+        } else {\n+            updateRawMatrix(projViewTx);\n+        }\n+        \/\/ printRawMatrix(\"Projection\");\n+        \/\/ Set projection view matrix\n+        nSetProjViewMatrix(pContext, g.isDepthTest(),\n+            rawMatrix[0], rawMatrix[1], rawMatrix[2], rawMatrix[3],\n+            rawMatrix[4], rawMatrix[5], rawMatrix[6], rawMatrix[7],\n+            rawMatrix[8], rawMatrix[9], rawMatrix[10], rawMatrix[11],\n+            rawMatrix[12], rawMatrix[13], rawMatrix[14], rawMatrix[15]);\n+\n+        nSetCameraPosition(pContext, cameraPos.x, cameraPos.y, cameraPos.z);\n+\n+        \/\/ Undo the SwapChain scaling done in createGraphics() because 3D needs\n+        \/\/ this information in the shader (via projViewTx)\n+        BaseTransform xform = g.getTransformNoClone();\n+        if (pixelScaleFactorX != 1.0 || pixelScaleFactorY != 1.0) {\n+            scratchAffine3DTx.setToIdentity();\n+            scratchAffine3DTx.scale(1.0 \/ pixelScaleFactorX, 1.0 \/ pixelScaleFactorY);\n+            scratchAffine3DTx.concatenate(xform);\n+            updateWorldTransform(scratchAffine3DTx);\n+        } else {\n+            updateWorldTransform(xform);\n+        }\n+\n+        updateRawMatrix(worldTx);\n+        \/\/ printRawMatrix(\"World\");\n+        nSetWorldTransform(pContext,\n+            rawMatrix[0], rawMatrix[1], rawMatrix[2], rawMatrix[3],\n+            rawMatrix[4], rawMatrix[5], rawMatrix[6], rawMatrix[7],\n+            rawMatrix[8], rawMatrix[9], rawMatrix[10], rawMatrix[11],\n+            rawMatrix[12], rawMatrix[13], rawMatrix[14], rawMatrix[15]);\n+        nRenderMeshView(pContext, nativeMeshView);\n+    }\n+\n+    private void printRawMatrix(String mesg) {\n+        System.err.println(mesg + \" = \");\n+        for (int i = 0; i < 4; i++) {\n+            System.err.println(rawMatrix[i] + \", \" + rawMatrix[i+4]\n+                + \", \" + rawMatrix[i+8] + \", \" + rawMatrix[i+12]);\n+        }\n+    }\n+\n+    private void updateRawMatrix(GeneralTransform3D src) {\n+        rawMatrix[0]  = (float)src.get(0); \/\/ Scale X\n+        rawMatrix[1]  = (float)src.get(4); \/\/ Shear Y\n+        rawMatrix[2]  = (float)src.get(8);\n+        rawMatrix[3]  = (float)src.get(12);\n+        rawMatrix[4]  = (float)src.get(1); \/\/ Shear X\n+        rawMatrix[5]  = (float)src.get(5); \/\/ Scale Y\n+        rawMatrix[6]  = (float)src.get(9);\n+        rawMatrix[7]  = (float)src.get(13);\n+        rawMatrix[8]  = (float)src.get(2);\n+        rawMatrix[9]  = (float)src.get(6);\n+        rawMatrix[10] = (float)src.get(10);\n+        rawMatrix[11] = (float)src.get(14);\n+        rawMatrix[12] = (float)src.get(3);  \/\/ Translate X\n+        rawMatrix[13] = (float)src.get(7);  \/\/ Translate Y\n+        rawMatrix[14] = (float)src.get(11);\n+        rawMatrix[15] = (float)src.get(15);\n+    }\n+\n+    public void disposeShader(long nMetalShaderRef) {\n+        nDisposeShader(nMetalShaderRef);\n+    }\n+\n+    public boolean isCurrentRTT(long texPtr) {\n+        return nIsCurrentRTT(pContext, texPtr);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        nRelease(pContext);\n+        state = null;\n+        super.dispose();\n+    }\n+\n+    \/\/ Native methods\n+\n+    private static native long nInitialize(ByteBuffer shaderLibPathStr);\n+    private static native void nCommitCurrentCommandBuffer(long context);\n+    private static native long nGetCommandQueue(long context);\n+    private static native void nDrawIndexedQuads(long context, float coords[], byte volors[], int numVertices);\n+    private static native int  nUpdateRenderTarget(long context, long texPtr, boolean depthTest);\n+\n+    private static native void nSetProjViewMatrix(long pContext, boolean isOrtho,\n+                                                    double m00, double m01, double m02, double m03,\n+                                                    double m10, double m11, double m12, double m13,\n+                                                    double m20, double m21, double m22, double m23,\n+                                                    double m30, double m31, double m32, double m33);\n+    private static native void nSetTransform(long pContext,\n+                                                  double m00, double m01, double m02, double m03,\n+                                                  double m10, double m11, double m12, double m13,\n+                                                  double m20, double m21, double m22, double m23,\n+                                                  double m30, double m31, double m32, double m33);\n+\n+    private static native void nSetCompositeMode(long context, int mode);\n+    private static native void nResetClipRect(long context);\n+    private static native void nSetClipRect(long context, int x, int y, int width, int height);\n+\n+    private static native void nSetWorldTransformToIdentity(long pContext);\n+    private static native void nSetWorldTransform(long pContext,\n+                                                  double m00, double m01, double m02, double m03,\n+                                                  double m10, double m11, double m12, double m13,\n+                                                  double m20, double m21, double m22, double m23,\n+                                                  double m30, double m31, double m32, double m33);\n+    private static native void nSetCameraPosition(long pContext, double x, double y, double z);\n+    private static native long nCreateMTLMesh(long pContext);\n+    private static native void nReleaseMTLMesh(long pContext, long nativeHandle);\n+    private static native boolean nBuildNativeGeometryShort(long pContext, long nativeHandle,\n+                                                            float[] vertexBuffer, int vertexBufferLength, short[] indexBuffer, int indexBufferLength);\n+    private static native boolean nBuildNativeGeometryInt(long pContext, long nativeHandle,\n+                                                          float[] vertexBuffer, int vertexBufferLength, int[] indexBuffer, int indexBufferLength);\n+    private static native long nCreateMTLPhongMaterial(long pContext);\n+    private static native void nReleaseMTLPhongMaterial(long pContext, long nativeHandle);\n+    private static native void nSetDiffuseColor(long pContext, long nativePhongMaterial,\n+                                                float r, float g, float b, float a);\n+    private static native void nSetSpecularColor(long pContext, long nativePhongMaterial,\n+                                                 boolean set, float r, float g, float b, float a);\n+    private static native void nSetMap(long pContext, long nativePhongMaterial,\n+                                       int mapType, long texID);\n+    private static native long nCreateMTLMeshView(long pContext, long nativeMesh);\n+    private static native void nReleaseMTLMeshView(long pContext, long nativeHandle);\n+    private static native void nSetCullingMode(long pContext, long nativeMeshView,\n+                                               int cullingMode);\n+    private static native void nSetMaterial(long pContext, long nativeMeshView,\n+                                            long nativePhongMaterialInfo);\n+    private static native void nSetWireframe(long pContext, long nativeMeshView,\n+                                             boolean wireframe);\n+    private static native void nSetAmbientLight(long pContext, long nativeMeshView,\n+                                                float r, float g, float b);\n+    private static native void nSetLight(long pContext, long nativeMeshView, int index,\n+                                         float x, float y, float z,\n+                                         float r, float g, float b, float w,\n+                                         float ca, float la, float qa,\n+                                         float isAttenuated, float maxRange,\n+                                         float dirX, float dirY, float dirZ,\n+                                         float innerAngle, float outerAngle, float falloff);\n+    private static native void nRenderMeshView(long pContext, long nativeMeshView);\n+\n+    private static native void nBlit(long pContext, long nSrcRTT, long nDstRTT,\n+                                     int srcX0, int srcY0, int srcX1, int srcY1,\n+                                     int dstX0, int dstY0, int dstX1, int dstY1);\n+\n+    private static native void nRelease(long pContext);\n+\n+    private static native boolean nIsCurrentRTT(long pContext, long texPtr);\n+    private static native void nDisposeShader(long nMetalShaderRef);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLContext.java","additions":564,"deletions":0,"binary":false,"changes":564,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+class MTLFBOTextureData extends MTLTextureData {\n+    MTLFBOTextureData(MTLContext context, long texPtr, long size) {\n+        super(context, texPtr, size);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pTexture != 0L && !mtlContext.isDisposed()) {\n+            if (mtlContext.isCurrentRTT(pTexture)) {\n+                mtlContext.flushVertexBuffer();\n+            }\n+            \/\/ Release of native MetalTexture will be handled by Glass,\n+            \/\/ so no need to call super.dispose()\n+            pTexture = 0L;\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLFBOTextureData.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.prism.RenderTarget;\n+import com.sun.prism.impl.ps.BaseShaderGraphics;\n+import com.sun.prism.paint.Color;\n+\n+class MTLGraphics extends BaseShaderGraphics {\n+\n+    private final MTLContext context;\n+\n+    private MTLGraphics(MTLContext context, RenderTarget target) {\n+        super(context, target);\n+        this.context = context;\n+    }\n+\n+    static MTLGraphics create(MTLContext context, RenderTarget target) {\n+        return target == null ? null : new MTLGraphics(context, target);\n+    }\n+\n+    @Override\n+    public void clear(Color color) {\n+        float r = color.getRedPremult();\n+        float g = color.getGreenPremult();\n+        float b = color.getBluePremult();\n+        float a = color.getAlpha();\n+\n+        context.validateClearOp(this);\n+        getRenderTarget().setOpaque(color.isOpaque());\n+        nClear(context.getContextHandle(), r, g, b, a, isDepthBuffer());\n+    }\n+\n+    @Override\n+    public void sync() {\n+        context.flushVertexBuffer();\n+        context.commitCurrentCommandBuffer();\n+    }\n+\n+    \/\/ Native methods\n+    private static native void nClear(long pContext, float red, float green, float blue, float alpha, boolean clearDepth);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLGraphics.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.prism.impl.BaseMesh;\n+import com.sun.prism.impl.Disposer;\n+\n+class MTLMesh extends BaseMesh {\n+\n+    static int count = 0;\n+\n+    private final MTLContext context;\n+    private final long nativeHandle;\n+\n+    private MTLMesh(MTLContext context, long nativeHandle, Disposer.Record disposerRecord) {\n+        super(disposerRecord);\n+        this.context = context;\n+        this.nativeHandle = nativeHandle;\n+        count++;\n+    }\n+\n+    static MTLMesh create(MTLContext context) {\n+        long nativeHandle = context.createMTLMesh();\n+        return new MTLMesh(context, nativeHandle, new MTLMeshDisposerRecord(context, nativeHandle));\n+    }\n+\n+    long getNativeHandle() {\n+        return nativeHandle;\n+    }\n+\n+    @Override\n+    public boolean isValid() {\n+        return !context.isDisposed();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disposerRecord.dispose();\n+        count--;\n+    }\n+\n+    @Override\n+    public int getCount() {\n+        return count;\n+    }\n+\n+    @Override\n+    public boolean buildNativeGeometry(float[] vertexBuffer, int vertexBufferLength,\n+            int[] indexBufferInt, int indexBufferLength) {\n+        return context.buildNativeGeometry(nativeHandle, vertexBuffer,\n+                vertexBufferLength, indexBufferInt, indexBufferLength);\n+    }\n+\n+    @Override\n+    public boolean buildNativeGeometry(float[] vertexBuffer, int vertexBufferLength,\n+            short[] indexBufferShort, int indexBufferLength) {\n+        return context.buildNativeGeometry(nativeHandle, vertexBuffer,\n+                vertexBufferLength, indexBufferShort, indexBufferLength);\n+    }\n+\n+    private static class MTLMeshDisposerRecord implements Disposer.Record {\n+\n+        private final MTLContext context;\n+        private long nativeHandle;\n+\n+        MTLMeshDisposerRecord(MTLContext context, long nativeHandle) {\n+            this.context = context;\n+            this.nativeHandle = nativeHandle;\n+        }\n+\n+        void traceDispose() {}\n+\n+        @Override\n+        public void dispose() {\n+            if (nativeHandle != 0L && !context.isDisposed()) {\n+                traceDispose();\n+                context.releaseMTLMesh(nativeHandle);\n+                nativeHandle = 0L;\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLMesh.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.prism.Graphics;\n+import com.sun.prism.Material;\n+import com.sun.prism.impl.BaseMeshView;\n+import com.sun.prism.impl.Disposer;\n+\n+class MTLMeshView extends BaseMeshView {\n+\n+    static int count = 0;\n+\n+    private final MTLContext context;\n+    private final long nativeHandle;\n+\n+    \/\/ A mesh could be shared among similar MTLMeshView's.\n+    \/\/ The native side of mesh holds necessary data required for rendering.\n+    \/\/ TODO: 3D - Need a mechanism to \"decRefCount\" Mesh and Material\n+    \/\/            if we need to do eager clean up\n+    final private MTLMesh mesh;\n+    private MTLPhongMaterial material;\n+\n+    private MTLMeshView(MTLContext context, long nativeHandle, MTLMesh mesh,\n+            Disposer.Record disposerRecord) {\n+        super(disposerRecord);\n+        this.context = context;\n+        this.mesh = mesh;\n+        this.nativeHandle = nativeHandle;\n+        count++;\n+    }\n+\n+    static MTLMeshView create(MTLContext context, MTLMesh mesh) {\n+        long nativeHandle = context.createMTLMeshView(mesh.getNativeHandle());\n+        return new MTLMeshView(context, nativeHandle, mesh, new MTLMeshViewDisposerRecord(context, nativeHandle));\n+    }\n+\n+    @Override\n+    public void setCullingMode(int cullingMode) {\n+        context.setCullingMode(nativeHandle, cullingMode);\n+    }\n+\n+    @Override\n+    public void setMaterial(Material material) {\n+        context.setMaterial(nativeHandle,\n+                ((MTLPhongMaterial) material).getNativeHandle());\n+        this.material = (MTLPhongMaterial) material;\n+    }\n+\n+    @Override\n+    public void setWireframe(boolean wireframe) {\n+        context.setWireframe(nativeHandle, wireframe);\n+    }\n+\n+    @Override\n+    public void setAmbientLight(float r, float g, float b) {\n+        context.setAmbientLight(nativeHandle, r, g, b);\n+    }\n+\n+    @Override\n+    public void setLight(int index, float x, float y, float z, float r, float g, float b, float w,\n+            float ca, float la, float qa, float isAttenuated, float maxRange, float dirX, float dirY, float dirZ,\n+            float innerAngle, float outerAngle, float falloff) {\n+        if (index >= 0 && index <= 2) {\n+            context.setLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, isAttenuated, maxRange,\n+                    dirX, dirY, dirZ, innerAngle, outerAngle, falloff);\n+        }\n+    }\n+\n+    @Override\n+    public void render(Graphics g) {\n+        material.lockTextureMaps();\n+        context.renderMeshView(nativeHandle, g);\n+        material.unlockTextureMaps();\n+    }\n+\n+    @Override\n+    public boolean isValid() {\n+        return !context.isDisposed();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        \/\/ TODO: 3D - Need a mechanism to \"decRefCount\" Mesh and Material\n+        material = null;\n+        disposerRecord.dispose();\n+        count--;\n+    }\n+\n+    public int getCount() {\n+        return count;\n+    }\n+\n+    private static class MTLMeshViewDisposerRecord implements Disposer.Record {\n+\n+        private final MTLContext context;\n+        private long nativeHandle;\n+\n+        MTLMeshViewDisposerRecord(MTLContext context, long nativeHandle) {\n+            this.context = context;\n+            this.nativeHandle = nativeHandle;\n+        }\n+\n+        void traceDispose() {}\n+\n+        @Override\n+        public void dispose() {\n+            if (nativeHandle != 0L && !context.isDisposed()) {\n+                traceDispose();\n+                context.releaseMTLMeshView(nativeHandle);\n+                nativeHandle = 0L;\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLMeshView.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.javafx.PlatformUtil;\n+import com.sun.javafx.logging.PlatformLogger;\n+import com.sun.prism.Image;\n+import com.sun.prism.PhongMaterial;\n+import com.sun.prism.Texture;\n+import com.sun.prism.TextureMap;\n+import com.sun.prism.impl.BasePhongMaterial;\n+import com.sun.prism.impl.Disposer;\n+\n+class MTLPhongMaterial extends BasePhongMaterial {\n+\n+    static int count = 0;\n+\n+    private final MTLContext context;\n+    private final long nativeHandle;\n+    private final TextureMap maps[] = new TextureMap[MAX_MAP_TYPE];\n+\n+    private MTLPhongMaterial(MTLContext context, long nativeHandle,\n+            Disposer.Record disposerRecord) {\n+        super(disposerRecord);\n+        this.context = context;\n+        this.nativeHandle = nativeHandle;\n+        count++;\n+    }\n+\n+    static MTLPhongMaterial create(MTLContext context) {\n+        long nativeHandle = context.createMTLPhongMaterial();\n+        return new MTLPhongMaterial(context, nativeHandle, new MTLPhongMaterialDisposerRecord(context, nativeHandle));\n+    }\n+\n+    long getNativeHandle() {\n+        return nativeHandle;\n+    }\n+\n+    @Override\n+    public void setDiffuseColor(float r, float g, float b, float a) {\n+        context.setDiffuseColor(nativeHandle, r, g, b, a);\n+    }\n+\n+    @Override\n+    public void setSpecularColor(boolean set, float r, float g, float b, float a) {\n+        context.setSpecularColor(nativeHandle, set, r, g, b, a);\n+    }\n+\n+    @Override\n+    public void setTextureMap(TextureMap map) {\n+        maps[map.getType().ordinal()] = map;\n+    }\n+\n+    private Texture setupTexture(TextureMap map, boolean useMipmap) {\n+        Image image = map.getImage();\n+        Texture texture = (image == null) ? null\n+                : context.getResourceFactory().getCachedTexture(image, Texture.WrapMode.REPEAT, useMipmap);\n+        long hTexture = 0;\n+        if (texture instanceof MTLTexture mtlTex) {\n+            hTexture = mtlTex.getNativeHandle();\n+        }\n+        context.setMap(nativeHandle, map.getType().ordinal(), hTexture);\n+        return texture;\n+    }\n+\n+    @Override\n+    public void lockTextureMaps() {\n+        for (int i = 0; i < MAX_MAP_TYPE; i++) {\n+            Texture texture = maps[i].getTexture();\n+            if (!maps[i].isDirty() && texture != null) {\n+                texture.lock();\n+                if (!texture.isSurfaceLost()) {\n+                    continue;\n+                }\n+            }\n+            \/\/ Enable mipmap if platform isn't embedded and map is diffuse or self illum\n+            boolean useMipmap = (!PlatformUtil.isEmbedded()) && (i == PhongMaterial.DIFFUSE || i == PhongMaterial.SELF_ILLUM);\n+            texture = setupTexture(maps[i], useMipmap);\n+            maps[i].setTexture(texture);\n+            maps[i].setDirty(false);\n+            if (maps[i].getImage() != null && texture == null) {\n+                String logname = PhongMaterial.class.getName();\n+                PlatformLogger.getLogger(logname).warning(\n+                        \"Warning: Low on texture resources. Cannot create texture.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void unlockTextureMaps() {\n+        for (int i = 0; i < MAX_MAP_TYPE; i++) {\n+            Texture texture = maps[i].getTexture();\n+            if (texture != null) {\n+                texture.unlock();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean isValid() {\n+        return !context.isDisposed();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disposerRecord.dispose();\n+        count--;\n+    }\n+\n+    public int getCount() {\n+        return count;\n+    }\n+\n+    private static class MTLPhongMaterialDisposerRecord implements Disposer.Record {\n+\n+        private final MTLContext context;\n+        private long nativeHandle;\n+\n+        MTLPhongMaterialDisposerRecord(MTLContext context, long nativeHandle) {\n+            this.context = context;\n+            this.nativeHandle = nativeHandle;\n+        }\n+\n+        void traceDispose() {}\n+\n+        @Override\n+        public void dispose() {\n+            if (nativeHandle != 0L && !context.isDisposed()) {\n+                traceDispose();\n+                context.releaseMTLPhongMaterial(nativeHandle);\n+                nativeHandle = 0L;\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLPhongMaterial.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.glass.ui.Screen;\n+import com.sun.glass.utils.NativeLibLoader;\n+import com.sun.prism.GraphicsPipeline;\n+import com.sun.prism.ResourceFactory;\n+import com.sun.prism.impl.PrismSettings;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+\n+public class MTLPipeline extends GraphicsPipeline {\n+\n+    private static MTLPipeline theInstance;\n+    private static MTLResourceFactory mtlResourceFactory;\n+\n+    static {\n+        String libName = \"prism_mtl\";\n+\n+        if (PrismSettings.verbose) {\n+            System.err.println(\"Loading native metal library, named: \" + libName);\n+        }\n+        NativeLibLoader.loadLibrary(libName);\n+        if (PrismSettings.verbose) {\n+            System.err.println(\"Succeeded: Loading native metal library.\");\n+        }\n+        theInstance = new MTLPipeline();\n+    }\n+\n+    private MTLPipeline() {}\n+\n+    public static MTLPipeline getInstance() {\n+        return theInstance;\n+    }\n+\n+    @Override\n+    public boolean init() {\n+        Map<String, Long> devDetails = new HashMap<>();\n+        setDeviceDetails(devDetails);\n+        return true;\n+    }\n+\n+    @Override\n+    public int getAdapterOrdinal(Screen screen) {\n+        return 0;\n+    }\n+\n+    @Override\n+    public ResourceFactory getDefaultResourceFactory(List<Screen> screens) {\n+        \/\/ This creates only one resource factory, all the Metal resources like\n+        \/\/ MTLBuffer, MTLTexture and created and handled in native Metal classes.\n+        return getResourceFactory(Screen.getMainScreen());\n+    }\n+\n+    @Override\n+    public ResourceFactory getResourceFactory(Screen screen) {\n+        \/\/ All the Metal resources like MTLBuffer, MTLTexture are created\n+        \/\/ and handled on native side of Metal impl.\n+        \/\/ So, a common ResourceFactory instance across screens is sufficient.\n+        if (mtlResourceFactory == null) {\n+            mtlResourceFactory = new MTLResourceFactory(screen);\n+\n+            \/\/ This enables sharing of MTLCommandQueue between PRISM and GLASS\n+            Map<String, Long> devDetails = MTLPipeline.getInstance().getDeviceDetails();\n+            devDetails.put(\"mtlCommandQueue\",\n+                                mtlResourceFactory.getContext().getMetalCommandQueue());\n+        }\n+        return mtlResourceFactory;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (mtlResourceFactory != null) {\n+            mtlResourceFactory.dispose();\n+            mtlResourceFactory = null;\n+        }\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public boolean is3DSupported() {\n+        return true;\n+    }\n+\n+    @Override\n+    public final boolean isMSAASupported() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isVsyncSupported() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean supportsShaderType(ShaderType type) {\n+        return switch (type) {\n+            case MSL -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    @Override\n+    public boolean supportsShaderModel(ShaderModel model) {\n+        return switch (model) {\n+            case SM3 -> true;\n+            default -> false;\n+        };\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLPipeline.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.glass.ui.Screen;\n+import com.sun.prism.Graphics;\n+import com.sun.prism.Image;\n+import com.sun.prism.MediaFrame;\n+import com.sun.prism.PixelFormat;\n+import com.sun.prism.RTTexture;\n+import com.sun.prism.ReadbackRenderTarget;\n+import com.sun.prism.Texture;\n+\n+import java.nio.Buffer;\n+import java.nio.IntBuffer;\n+\n+\n+class MTLRTTexture extends MTLTexture<MTLTextureData>\n+                       implements RTTexture, ReadbackRenderTarget {\n+    private final int[] pixels;\n+    private final int  rttWidth;\n+    private final int  rttHeight;\n+    private final long nTexPtr;\n+\n+    private boolean opaque;\n+    private final boolean MSAA;\n+\n+    private MTLRTTexture(MTLContext context, MTLTextureResource<MTLTextureData> resource,\n+                         WrapMode wrapMode,\n+                         int physicalWidth, int physicalHeight,\n+                         int contentX, int contentY,\n+                         int contentWidth, int contentHeight,\n+                         int maxContentWidth, int maxContentHeight, boolean msaa) {\n+\n+        super(context, resource, PixelFormat.BYTE_BGRA_PRE, wrapMode,\n+                physicalWidth, physicalHeight,\n+                contentX, contentY,\n+                contentWidth, contentHeight,\n+                maxContentWidth, maxContentHeight, false);\n+        rttWidth  = contentWidth;\n+        rttHeight = contentHeight;\n+        pixels  = new int[rttWidth * rttHeight];\n+        nTexPtr = resource.getResource().getResource();\n+        opaque  = false;\n+        MSAA    = msaa;\n+\n+        \/\/ pixels array contains all 0s by default\n+        \/\/ Initialize native texture to clear color (0,0,0,0) using pixels\n+        nInitRTT(nTexPtr, pixels);\n+    }\n+\n+    static MTLRTTexture create(MTLContext context,\n+                               int physicalWidth, int physicalHeight,\n+                               int contentWidth, int contentHeight,\n+                               WrapMode wrapMode, boolean msaa,\n+                               long size) {\n+        long nPtr = nCreateRT(context.getContextHandle(),\n+                physicalWidth, physicalHeight,\n+                contentWidth, contentHeight,\n+                wrapMode, msaa);\n+        MTLTextureData textData = new MTLRTTextureData(context, nPtr, size);\n+        MTLTextureResource<MTLTextureData> resource = new MTLTextureResource<>(textData, true);\n+        return new MTLRTTexture(context, resource, wrapMode,\n+                physicalWidth, physicalHeight,\n+                0, 0,\n+                contentWidth, contentHeight,\n+                contentWidth, contentHeight, msaa);\n+    }\n+\n+    static MTLRTTexture create(MTLContext context, long pTex, int width, int height, long size) {\n+        long nPtr = nCreateRT2(context.getContextHandle(), pTex, width, height);\n+\n+        MTLTextureData textData = new MTLFBOTextureData(context, nPtr, size);\n+        MTLTextureResource<MTLTextureData> resource = new MTLTextureResource<>(textData, false);\n+\n+        return new MTLRTTexture(context, resource, WrapMode.CLAMP_NOT_NEEDED,\n+                width, height,\n+                0, 0,\n+                width, height,\n+                width, height, false);\n+    }\n+\n+    @Override\n+    public long getNativeHandle() {\n+        return nTexPtr;\n+    }\n+\n+    @Override\n+    public Texture getBackBuffer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public int[] getPixels() {\n+        \/\/ Flush the VB before reading the pixels.\n+        getContext().flushVertexBuffer();\n+        nReadPixels(nTexPtr, pixels);\n+        return pixels;\n+    }\n+\n+    @Override\n+    public boolean readPixels(Buffer pix) {\n+        \/\/ The call from Canvas rendering expects IntBuffer, which is implemented here.\n+        \/\/ In future, if needed, need to implement pix as ByteBuffer\n+        if (pix instanceof IntBuffer pixBuf) {\n+            nReadPixelsFromRTT(nTexPtr, pixBuf);\n+            \/\/ pix = IntBuffer.wrap(pixels);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isVolatile() {\n+        return false;\n+    }\n+\n+    @Override\n+    public Screen getAssociatedScreen() {\n+        return getContext().getAssociatedScreen();\n+    }\n+\n+    @Override\n+    public Graphics createGraphics() {\n+        return MTLGraphics.create(getContext(), this);\n+    }\n+\n+    @Override\n+    public boolean isOpaque() {\n+        return opaque;\n+    }\n+\n+    @Override\n+    public void setOpaque(boolean opaque) {\n+        this.opaque = opaque;\n+    }\n+\n+    @Override\n+    public boolean isMSAA() {\n+        return MSAA;\n+    }\n+\n+    \/\/ Native methods\n+\n+    private static native long nCreateRT(long context, int pw, int ph, int cw, int ch,\n+                                         WrapMode wrapMode, boolean msaa);\n+    private static native long nCreateRT2(long context, long pTex, int pw, int ph);\n+    private static native void nReadPixels(long nativeHandle, int[] pixBuffer);\n+    private static native void nReadPixelsFromRTT(long nativeHandle, IntBuffer pixBuffer);\n+    private static native long nGetPixelDataPtr(long nativeHandle);\n+    private static native void nInitRTT(long pTex, int[] pix);\n+\n+\n+    \/\/ Unsupported Operation methods\n+\n+    @Override\n+    public boolean readPixels(Buffer pixels, int x, int y, int width, int height) {\n+        throw new UnsupportedOperationException(\"Not implemented\");\n+    }\n+\n+    @Override\n+    public void setContentWidth(int contentWidth) {\n+        throw new UnsupportedOperationException(\"Not implemented\");\n+    }\n+\n+    @Override\n+    public void setContentHeight(int contentHeight) {\n+        throw new UnsupportedOperationException(\"Not implemented\");\n+    }\n+\n+    @Override\n+    public boolean getUseMipmap() {\n+        throw new UnsupportedOperationException(\"Not implemented\");\n+    }\n+\n+    @Override\n+    public Texture getSharedTexture(WrapMode altMode) {\n+        throw new UnsupportedOperationException(\"Not implemented\");\n+    }\n+\n+    @Override\n+    public void update(Image img) {\n+        throw new UnsupportedOperationException(\"update() not supported for RTTextures\");\n+    }\n+\n+    @Override\n+    public void update(Image img, int dstx, int dsty) {\n+        throw new UnsupportedOperationException(\"update() not supported for RTTextures\");\n+    }\n+\n+    @Override\n+    public void update(Image img, int dstx, int dsty, int srcw, int srch) {\n+        throw new UnsupportedOperationException(\"update() not supported for RTTextures\");\n+    }\n+\n+    @Override\n+    public void update(Image img, int dstx, int dsty, int srcw, int srch, boolean skipFlush) {\n+        throw new UnsupportedOperationException(\"update() not supported for RTTextures\");\n+    }\n+\n+    @Override\n+    public void update(Buffer buffer, PixelFormat format, int dstx, int dsty, int srcx, int srcy,\n+                       int srcw, int srch, int srcscan, boolean skipFlush) {\n+        throw new UnsupportedOperationException(\"update() not supported for RTTextures\");\n+    }\n+\n+    @Override\n+    public void update(MediaFrame frame, boolean skipFlush) {\n+        throw new UnsupportedOperationException(\"update() not supported for RTTextures\");\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLRTTexture.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+class MTLRTTextureData extends MTLTextureData {\n+\n+    MTLRTTextureData(MTLContext context, long texPtr, long size) {\n+        super(context, texPtr, size);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pTexture != 0L && !mtlContext.isDisposed()) {\n+            if (mtlContext.isCurrentRTT(pTexture)) {\n+                mtlContext.flushVertexBuffer();\n+            }\n+        }\n+        super.dispose();\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLRTTextureData.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+public interface MTLRenderTarget {\n+    long getResourceHandle();\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLRenderTarget.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,422 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.glass.ui.Screen;\n+import com.sun.prism.MediaFrame;\n+import com.sun.prism.Mesh;\n+import com.sun.prism.MeshView;\n+import com.sun.prism.MultiTexture;\n+import com.sun.prism.PhongMaterial;\n+import com.sun.prism.PixelFormat;\n+import com.sun.prism.Presentable;\n+import com.sun.prism.PresentableState;\n+import com.sun.prism.RTTexture;\n+import com.sun.prism.Texture.Usage;\n+import com.sun.prism.Texture.WrapMode;\n+import com.sun.prism.Texture;\n+import com.sun.prism.impl.PrismSettings;\n+import com.sun.prism.impl.TextureResourcePool;\n+import com.sun.prism.impl.ps.BaseShaderFactory;\n+import com.sun.prism.ps.Shader;\n+import com.sun.prism.ps.ShaderFactory;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.lang.reflect.Method;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+\n+class MTLResourceFactory extends BaseShaderFactory {\n+\n+    private final MTLContext context;\n+\n+    MTLResourceFactory(Screen screen) {\n+        context = new MTLContext(screen, this);\n+        context.initState();\n+        if (PrismSettings.noClampToZero && PrismSettings.verbose) {\n+            System.err.println(\"prism.noClampToZero not supported by MTL\");\n+        }\n+    }\n+\n+    static int nextPowerOfTwo(int val, int max) {\n+        if (val > max) {\n+            return 0;\n+        }\n+\n+        \/\/ check if number is power of 2\n+        if ((val & (val - 1)) == 0) {\n+            return val;\n+        }\n+\n+        int i = 1;\n+        while (i < val) {\n+            i <<= 1; \/\/ i *= 2;\n+        }\n+        return i;\n+    }\n+\n+    public MTLContext getContext() {\n+        return context;\n+    }\n+\n+    private void checkTextureSize(int width, int height) {\n+        int maxSize = getMaximumTextureSize();\n+        if (width <= 0 || height <= 0 ||\n+            width > maxSize || height > maxSize) {\n+            throw new RuntimeException(\"Illegal texture dimensions (\" + width + \"x\" + height + \")\");\n+        }\n+    }\n+\n+    @Override\n+    public Shader createShader(String pixelShaderName, InputStream pixelShaderCode, Map<String, Integer> samplers,\n+                               Map<String, Integer> params, int maxTexCoordIndex,\n+                               boolean isPixcoordUsed, boolean isPerVertexColorUsed) {\n+        try {\n+            return createShader(pixelShaderName, samplers, params, maxTexCoordIndex,\n+                                isPixcoordUsed, isPerVertexColorUsed);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            throw new UnsupportedOperationException(\"Failed to create a prism shader\");\n+        }\n+    }\n+\n+    @Override\n+    public Shader createShader(String shaderName, Map<String, Integer> samplers,\n+                               Map<String, Integer> params, int maxTexCoordIndex,\n+                               boolean isPixcoordUsed, boolean isPerVertexColorUsed) {\n+        return MTLShader.createShader(getContext(), shaderName, samplers,\n+                params, maxTexCoordIndex, isPixcoordUsed, isPerVertexColorUsed);\n+    }\n+\n+    @Override\n+    public Shader createStockShader(String shaderName) {\n+        Objects.requireNonNull(shaderName, \"Shader name not be null\");\n+        try {\n+            if (PrismSettings.verbose) {\n+                System.err.println(\"MTLResourceFactory: Prism - createStockShader: \" + shaderName);\n+            }\n+            Class<?> klass = Class.forName(\"com.sun.prism.shader.\" + shaderName + \"_Loader\");\n+            Method m = klass.getMethod(\"loadShader\", new Class[] {ShaderFactory.class, String.class, InputStream.class});\n+            InputStream nameStream = new ByteArrayInputStream(shaderName.getBytes());\n+            return (Shader) m.invoke(null, new Object[]{this, shaderName, nameStream});\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            throw new InternalError(\"Error loading stock shader \" + shaderName);\n+        }\n+    }\n+\n+    @Override\n+    public TextureResourcePool<?> getTextureResourcePool() {\n+        return MTLVramPool.getInstance();\n+    }\n+\n+    @Override\n+    public Texture createTexture(PixelFormat formatHint, Texture.Usage usageHint,\n+                                 Texture.WrapMode wrapMode, int w, int h) {\n+        return createTexture(formatHint, usageHint, wrapMode, w, h, false);\n+    }\n+\n+    @Override\n+    public Texture createTexture(PixelFormat formatHint, Texture.Usage usageHint,\n+                                 Texture.WrapMode wrapMode, int w, int h, boolean useMipmap) {\n+\n+        if (checkDisposed()) return null;\n+\n+        if (!isFormatSupported(formatHint)) {\n+            throw new UnsupportedOperationException(\n+                \"Pixel format \" + formatHint +\n+                    \" not supported on this device\");\n+        }\n+\n+        if (formatHint == PixelFormat.MULTI_YCbCr_420) {\n+            throw new UnsupportedOperationException(\"MULTI_YCbCr_420 textures require a MediaFrame\");\n+        }\n+\n+        int allocw, alloch;\n+        if (PrismSettings.forcePow2) {\n+            allocw = nextPowerOfTwo(w, Integer.MAX_VALUE);\n+            alloch = nextPowerOfTwo(h, Integer.MAX_VALUE);\n+        } else {\n+            allocw = w;\n+            alloch = h;\n+        }\n+\n+        checkTextureSize(allocw, alloch);\n+\n+        int bpp = formatHint.getBytesPerPixelUnit();\n+        if (allocw >= (Integer.MAX_VALUE \/ alloch \/ bpp)) {\n+            throw new RuntimeException(\"Illegal texture dimensions (\" + allocw + \"x\" + alloch + \")\");\n+        }\n+\n+        MTLVramPool pool = MTLVramPool.getInstance();\n+        long size = pool.estimateTextureSize(allocw, alloch, formatHint);\n+        if (!pool.prepareForAllocation(size)) {\n+            return null;\n+        }\n+\n+        long pResource = nCreateTexture(context.getContextHandle() ,\n+                formatHint.ordinal(), usageHint.ordinal(),\n+                false, allocw, alloch, 0, useMipmap);\n+\n+        if (pResource == 0L) {\n+            return null;\n+        }\n+\n+        MTLTextureData textData = new MTLTextureData(context, pResource, size);\n+        MTLTextureResource<MTLTextureData> resource = new MTLTextureResource<>(textData, true);\n+\n+        \/\/ contentX and contentY is set as 0 unlike D3D\/ES2.\n+        \/\/ The wrap mode are addressed, can be mapped to D3D\/ES2 only if necessary.\n+        return new MTLTexture<MTLTextureData>(getContext(), resource, formatHint, wrapMode, allocw, alloch, 0, 0, allocw, alloch, useMipmap);\n+    }\n+\n+    @Override\n+    public Texture createTexture(MediaFrame frame) {\n+        frame.holdFrame();\n+\n+        try {\n+            int width = frame.getWidth();\n+            int height = frame.getHeight();\n+            int texWidth = frame.getEncodedWidth();\n+            int texHeight = frame.getEncodedHeight();\n+            PixelFormat texFormat = frame.getPixelFormat();\n+\n+            checkTextureSize(texWidth, texHeight);\n+\n+            int bpp = texFormat.getBytesPerPixelUnit();\n+            if (texWidth >= (Integer.MAX_VALUE \/ texHeight \/ bpp)) {\n+                throw new RuntimeException(\"Illegal texture dimensions (\" + texWidth + \"x\" + texHeight + \")\");\n+            }\n+\n+            if (texFormat == PixelFormat.MULTI_YCbCr_420) {\n+                \/\/ Create a MultiTexture\n+                MultiTexture tex = new MultiTexture(texFormat, WrapMode.CLAMP_TO_EDGE, width, height);\n+\n+                \/\/ create\/add the subtextures\n+                \/\/ Textures: 0 = luma, 1 = Chroma blue, 2 = Chroma red, 3 = alpha\n+                for (int index = 0; index < frame.planeCount(); index++) {\n+                    int subWidth = texWidth;\n+                    int subHeight =  texHeight;\n+\n+                    if (index == PixelFormat.YCBCR_PLANE_CHROMABLUE\n+                            || index == PixelFormat.YCBCR_PLANE_CHROMARED)\n+                    {\n+                        subWidth \/= 2;\n+                        subHeight \/= 2;\n+                    }\n+\n+                    Texture subTex = createTexture(PixelFormat.BYTE_ALPHA, Usage.DYNAMIC, WrapMode.CLAMP_TO_EDGE,\n+                                                      subWidth, subHeight);\n+\n+                    if (subTex == null) {\n+                        tex.dispose();\n+                        return null;\n+                    }\n+\n+                    tex.setTexture(subTex, index);\n+                }\n+\n+                \/\/ Note : Solid_TexuteYV12.metal shader that is used to render this pixel format\n+                \/\/ expects 4 texture parameters\n+                \/\/ Generate alpha texture artificially if it is unavailable in the MediaFrame\n+                if (frame.planeCount() == 3) {\n+\n+                    Texture subTex = createTexture(PixelFormat.BYTE_ALPHA, Usage.DYNAMIC, WrapMode.CLAMP_TO_EDGE,\n+                                                   texWidth, texHeight);\n+\n+                    if (subTex == null) {\n+                        tex.dispose();\n+                        return null;\n+                    }\n+\n+                    byte[] arr = new byte[texWidth * texHeight];\n+                    Arrays.fill(arr, (byte)255);\n+                    ByteBuffer pixels = ByteBuffer.wrap(arr);\n+                    subTex.update(pixels, PixelFormat.BYTE_ALPHA, 0, 0, 0, 0,\n+                                  texWidth, texHeight, texWidth, true);\n+\n+                    tex.setTexture(subTex, 3);\n+                }\n+                return tex;\n+            } \/\/ PixelFormat.MULTI_YCbCr_420\n+\n+            Texture tex = createTexture(texFormat, Usage.DEFAULT, WrapMode.CLAMP_TO_EDGE, texWidth, texHeight);\n+\n+            return tex;\n+        } finally {\n+            frame.releaseFrame();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isFormatSupported(PixelFormat format) {\n+        return switch (format) {\n+            case BYTE_RGB,\n+                 BYTE_GRAY,\n+                 BYTE_ALPHA,\n+                 BYTE_BGRA_PRE,\n+                 BYTE_APPLE_422,\n+                 INT_ARGB_PRE,\n+                 FLOAT_XYZW -> true;\n+\n+            case MULTI_YCbCr_420 -> false;\n+        };\n+    }\n+\n+    @Override\n+    public int getMaximumTextureSize() {\n+        \/\/ This value can be fetched from the MTLDevice.\n+        \/\/ This value comes from Metal feature set tables\n+        return 16384; \/\/ For MTLGPUFamilyApple3 and above\n+    }\n+\n+    @Override\n+    public int getRTTWidth(int w, Texture.WrapMode wrapMode) {\n+        \/\/ Below debugging logic replicates D3DResoureFactory\n+        \/\/ if (PrismSettings.forcePow2) {\n+        \/\/     w = nextPowerOfTwo(w, Integer.MAX_VALUE);\n+        \/\/ }\n+        return w;\n+    }\n+\n+    @Override\n+    public int getRTTHeight(int h, Texture.WrapMode wrapMode) {\n+        \/\/ Below debugging logic replicates D3DResoureFactory\n+        \/\/ if (PrismSettings.forcePow2) {\n+        \/\/     h = nextPowerOfTwo(h, Integer.MAX_VALUE);\n+        \/\/ }\n+        return h;\n+    }\n+\n+    @Override\n+    public RTTexture createRTTexture(int width, int height, Texture.WrapMode wrapMode) {\n+        return createRTTexture(width, height, wrapMode, false);\n+    }\n+\n+    static int nextPowerOf64(int val, int max) {\n+        \/\/ Using a random value for width or height of texture results in this error:\n+        \/\/ -> validateStrideTextureParameters:1512: failed assertion\n+        \/\/ -> Linear texture: bytesPerRow (XXXX) must be aligned to 256 bytes,\n+        \/\/ This implies that the width and height of a texture must be multiple of 64 pixels.\n+        if (val > max) {\n+            return 0;\n+        }\n+        int minPixelsRow = 64;\n+        if (val % minPixelsRow != 0) {\n+            int times = val \/ minPixelsRow;\n+            val = minPixelsRow * (times + 1);\n+        }\n+        return val;\n+    }\n+\n+    @Override\n+    public RTTexture createRTTexture(int width, int height, Texture.WrapMode wrapMode, boolean msaa) {\n+        int createw = width;\n+        int createh = height;\n+\n+        if (PrismSettings.forcePow2) {\n+            createw = nextPowerOfTwo(createw, Integer.MAX_VALUE);\n+            createh = nextPowerOfTwo(createh, Integer.MAX_VALUE);\n+        }\n+\n+        checkTextureSize(createw, createh);\n+\n+        PixelFormat format = PixelFormat.INT_ARGB_PRE;\n+        int bpp = format.getBytesPerPixelUnit();\n+        if (createw >= (Integer.MAX_VALUE \/ createh \/ bpp)) {\n+            throw new RuntimeException(\"Illegal texture dimensions (\" + createw + \"x\" + createh + \")\");\n+        }\n+        \/\/ We don't create PowerOf64 textures in D3D\/OpenGL but\n+        \/\/ earlier implementation of Metal required RT texture of pow64.\n+        \/\/ Removed usage of nextPowerOf64 as part of JDK-8311225 and\n+        \/\/ verified Ensemble8 and demos are running fine.\n+        \/\/ If usage of nextPowerOf64 is not needed we should remove it in future.\n+        \/\/ createw = nextPowerOf64(createw, 8192);\n+        \/\/ createh = nextPowerOf64(createh, 8192);\n+\n+        MTLVramPool pool = MTLVramPool.getInstance();\n+        long size = pool.estimateRTTextureSize(createw, createh, false);\n+        if (!pool.prepareForAllocation(size)) {\n+            return null;\n+        }\n+\n+        MTLRTTexture rtt = MTLRTTexture.create(context, createw, createh, width, height, wrapMode, msaa, size);\n+        return rtt;\n+    }\n+\n+    @Override\n+    public boolean isCompatibleTexture(Texture tex) {\n+        return tex instanceof MTLTexture;\n+    }\n+\n+    @Override\n+    public Presentable createPresentable(PresentableState pState) {\n+        if (checkDisposed()) {\n+            return null;\n+        }\n+        checkTextureSize(pState.getRenderWidth(), pState.getRenderHeight());\n+        return new MTLSwapChain(getContext(), pState);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        context.dispose();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public PhongMaterial createPhongMaterial() {\n+        if (checkDisposed()) return null;\n+        return MTLPhongMaterial.create(context);\n+    }\n+\n+    @Override\n+    public MeshView createMeshView(Mesh mesh) {\n+        if (checkDisposed()) return null;\n+        return MTLMeshView.create(context, (MTLMesh) mesh);\n+    }\n+\n+    @Override\n+    public Mesh createMesh() {\n+        if (checkDisposed()) return null;\n+        return MTLMesh.create(context);\n+    }\n+\n+    static void releaseTexture(long resource) {\n+        nReleaseTexture(resource);\n+    }\n+\n+    \/\/ Native methods\n+\n+    static native long nCreateTexture(long pContext, int format, int hint, boolean isRTT,\n+                                      int width, int height, int samples, boolean useMipmap);\n+\n+    static native void nReleaseTexture(long pTexture);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLResourceFactory.java","additions":422,"deletions":0,"binary":false,"changes":422,"status":"added"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.prism.Texture;\n+import com.sun.prism.ps.Shader;\n+\n+import java.lang.ref.WeakReference;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class MTLShader implements Shader {\n+\n+    private long nMetalShaderRef;\n+    private final MTLContext context;\n+    private final String fragmentFunctionName;\n+    private final Map<Integer, String> samplers = new HashMap<>();\n+    private final Map<String, Integer> uniformNameIdMap;\n+    private final Map<Integer, WeakReference<Object>> textureIdRefMap = new HashMap<>();\n+\n+    private static final Map<String, MTLShader> shaderMap = new HashMap<>();\n+    private static MTLShader currentEnabledShader;\n+\n+    private MTLShader(MTLContext context, String fragmentFunctionName) {\n+        this.fragmentFunctionName = fragmentFunctionName;\n+        this.context = context;\n+\n+        nMetalShaderRef = nCreateMetalShader(context.getContextHandle(), fragmentFunctionName);\n+        if (nMetalShaderRef != 0) {\n+            shaderMap.put(fragmentFunctionName, this);\n+        } else {\n+            throw new InternalError(\"Failed to create the Shader : \" + fragmentFunctionName);\n+        }\n+        uniformNameIdMap = nGetUniformNameIdMap(nMetalShaderRef);\n+    }\n+\n+    public static Shader createShader(MTLContext ctx, String fragFuncName, Map<String, Integer> samplers,\n+                                      Map<String, Integer> params, int maxTexCoordIndex,\n+                                      boolean isPixcoordUsed, boolean isPerVertexColorUsed) {\n+        if (shaderMap.containsKey(fragFuncName)) {\n+            return shaderMap.get(fragFuncName);\n+        } else {\n+            MTLShader shader = new MTLShader(ctx, fragFuncName);\n+            shader.storeSamplers(samplers);\n+            return shader;\n+        }\n+    }\n+\n+    public static MTLShader createShader(MTLContext ctx, String fragFuncName) {\n+        if (shaderMap.containsKey(fragFuncName)) {\n+            return shaderMap.get(fragFuncName);\n+        } else {\n+            return new MTLShader(ctx, fragFuncName);\n+        }\n+    }\n+\n+    private void storeSamplers(Map<String, Integer> samplers) {\n+        samplers.forEach((name, id) -> this.samplers.put(id, name));\n+    }\n+\n+    @Override\n+    public void enable() {\n+        currentEnabledShader = this;\n+        nEnable(nMetalShaderRef);\n+    }\n+\n+    @Override\n+    public void disable() {\n+        \/\/ There are no disable calls coming from BaseShaderContext.\n+        \/\/ So this is a no-op. We can call disable on lastShader in\n+        \/\/ BaseShaderContext.checkState() but that will be a common change for\n+        \/\/ all pipelines.\n+        nDisable(nMetalShaderRef);\n+    }\n+\n+    @Override\n+    public boolean isValid() {\n+        return nMetalShaderRef != 0;\n+    }\n+\n+    public static void setTexture(int texUnit, Texture tex, boolean isLinear, int wrapMode) {\n+        if (currentEnabledShader.textureIdRefMap.get(texUnit) != null &&\n+            currentEnabledShader.textureIdRefMap.get(texUnit).get() == tex) return;\n+\n+        currentEnabledShader.textureIdRefMap.put(texUnit, new WeakReference<>(tex));\n+        MTLTexture<?> mtlTex = (MTLTexture<?>)tex;\n+        nSetTexture(currentEnabledShader.nMetalShaderRef, texUnit,\n+                currentEnabledShader.uniformNameIdMap.get(currentEnabledShader.samplers.get(texUnit)),\n+                mtlTex.getNativeHandle(), isLinear, wrapMode);\n+    }\n+\n+    @Override\n+    public void setConstant(String name, int i0) {\n+        nSetInt(nMetalShaderRef, uniformNameIdMap.get(name), i0);\n+    }\n+\n+    @Override\n+    public void setConstant(String name, int i0, int i1) {\n+        throw new UnsupportedOperationException(\"Not implemented yet.\");\n+    }\n+\n+    @Override\n+    public void setConstant(String name, int i0, int i1, int i2) {\n+        throw new UnsupportedOperationException(\"Not implemented yet.\");\n+    }\n+\n+    @Override\n+    public void setConstant(String name, int i0, int i1, int i2, int i3) {\n+        throw new UnsupportedOperationException(\"Not implemented yet.\");\n+    }\n+\n+    @Override\n+    public void setConstants(String name, IntBuffer buf, int off, int count) {\n+        throw new UnsupportedOperationException(\"Not implemented yet.\");\n+    }\n+\n+    @Override\n+    public void setConstant(String name, float f0) {\n+        nSetFloat1(nMetalShaderRef, uniformNameIdMap.get(name), f0);\n+    }\n+\n+    @Override\n+    public void setConstant(String name, float f0, float f1) {\n+        nSetFloat2(nMetalShaderRef, uniformNameIdMap.get(name), f0, f1);\n+    }\n+\n+    @Override\n+    public void setConstant(String name, float f0, float f1, float f2) {\n+        nSetFloat3(nMetalShaderRef, uniformNameIdMap.get(name), f0, f1, f2);\n+    }\n+\n+    @Override\n+    public void setConstant(String name, float f0, float f1, float f2, float f3) {\n+        nSetFloat4(nMetalShaderRef, uniformNameIdMap.get(name), f0, f1, f2, f3);\n+    }\n+\n+    @Override\n+    public void setConstants(String name, FloatBuffer buf, int off, int count) {\n+        boolean direct = buf.isDirect();\n+        if (direct) {\n+            nSetConstantsBuf(nMetalShaderRef, uniformNameIdMap.get(name),\n+                                buf, buf.position() * 4, count * 4);\n+        } else {\n+            count = 4 * count;\n+            float[] values = new float[count];\n+            buf.get(off, values, 0, count);\n+            nSetConstants(nMetalShaderRef, uniformNameIdMap.get(name), values, count);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (isValid()) {\n+            context.disposeShader(nMetalShaderRef);\n+            shaderMap.remove(fragmentFunctionName);\n+            nMetalShaderRef = 0;\n+            textureIdRefMap.clear();\n+            uniformNameIdMap.clear();\n+            samplers.clear();\n+        }\n+    }\n+\n+    \/\/ Native methods\n+\n+    private static native long nCreateMetalShader(long context, String fragFuncName);\n+    private static native Map<String, Integer>  nGetUniformNameIdMap(long nMetalShader);\n+    private static native void nEnable(long nMetalShader);\n+    private static native void nDisable(long nMetalShader);\n+\n+    private static native void nSetTexture(long nMetalShader, int texID, int uniformID,\n+                                           long texPtr, boolean isLinear, int wrapMode);\n+\n+    private static native void nSetInt(long nMetalShader, int uniformID, int i0);\n+\n+    private static native void nSetFloat1(long nMetalShader, int uniformID, float f0);\n+    private static native void nSetFloat2(long nMetalShader, int uniformID,\n+                                            float f0, float f1);\n+    private static native void nSetFloat3(long nMetalShader, int uniformID,\n+                                            float f0, float f1, float f2);\n+    private static native void nSetFloat4(long nMetalShader, int uniformID,\n+                                            float f0, float f1, float f2, float f3);\n+\n+    private static native void nSetConstants(long nMetalShader, int uniformID,\n+                                            float[] values, int size);\n+    private static native void nSetConstantsBuf(long nMetalShader, int uniformID,\n+                                    Object values, int valuesByteOffset, int size);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLShader.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.glass.ui.Screen;\n+import com.sun.javafx.geom.Rectangle;\n+import com.sun.prism.Graphics;\n+import com.sun.prism.GraphicsResource;\n+import com.sun.prism.Presentable;\n+import com.sun.prism.PresentableState;\n+import com.sun.prism.impl.PrismSettings;\n+\n+public class MTLSwapChain implements MTLRenderTarget, Presentable, GraphicsResource {\n+\n+    private final PresentableState pState;\n+    private final MTLContext pContext;\n+    private MTLRTTexture stableBackbuffer;\n+    private final float pixelScaleFactorX;\n+    private final float pixelScaleFactorY;\n+    private boolean needsResize;\n+    private int w, h;\n+\n+    public MTLSwapChain(MTLContext context, PresentableState state) {\n+        pContext = context;\n+        pState = state;\n+        pixelScaleFactorX = state.getRenderScaleX();\n+        pixelScaleFactorY = state.getRenderScaleY();\n+\n+        w = state.getRenderWidth();\n+        h = state.getRenderHeight();\n+    }\n+\n+    @Override\n+    public boolean lockResources(PresentableState state) {\n+        if (pState != state ||\n+            pixelScaleFactorX != state.getRenderScaleX() ||\n+            pixelScaleFactorY != state.getRenderScaleY()) {\n+            return true;\n+        }\n+        needsResize = (w != state.getRenderWidth() || h != state.getRenderHeight());\n+\n+        \/\/ the stableBackbuffer will be used as the render target\n+        if (stableBackbuffer != null && !needsResize) {\n+            stableBackbuffer.lock();\n+            if (stableBackbuffer.isSurfaceLost()) {\n+                stableBackbuffer = null;\n+                \/\/ For resizes we can keep the back buffer, but if we lose\n+                \/\/ the back buffer then we need the caller to know that a\n+                \/\/ new buffer is coming so that the entire scene can be\n+                \/\/ redrawn.  To force this, we return true and the Presentable\n+                \/\/ is recreated and repainted in its entirety.\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean prepare(Rectangle dirtyregion) {\n+        MTLContext context = getContext();\n+        context.flushVertexBuffer();\n+        MTLGraphics g = MTLGraphics.create(context, stableBackbuffer);\n+        if (g == null) {\n+            return false;\n+        }\n+        stableBackbuffer.unlock();\n+        return true;\n+    }\n+\n+    public MTLContext getContext() {\n+        return pContext;\n+    }\n+\n+    @Override\n+    public boolean present() {\n+        MTLContext context = getContext();\n+        if (context.isDisposed()) {\n+            return false;\n+        }\n+        context.commitCurrentCommandBuffer();\n+        return true;\n+    }\n+\n+    @Override\n+    public float getPixelScaleFactorX() {\n+        return pixelScaleFactorX;\n+    }\n+\n+    @Override\n+    public float getPixelScaleFactorY() {\n+        return pixelScaleFactorY;\n+    }\n+\n+    @Override\n+    public Screen getAssociatedScreen() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Graphics createGraphics() {\n+        if (pState.getNativeFrameBuffer() == 0) {\n+            System.err.println(\"Native backbuffer texture from Glass is nil.\");\n+            return null;\n+        }\n+\n+        needsResize = (w != pState.getRenderWidth() || h != pState.getRenderHeight());\n+        \/\/ the stableBackbuffer will be used as the render target\n+        if (stableBackbuffer == null || needsResize) {\n+            \/\/ note that we will take care of calling\n+            \/\/ forceRenderTarget() for the hardware backbuffer and\n+            \/\/ reset the needsResize flag at present() time...\n+            if (stableBackbuffer != null) {\n+                getContext().flushVertexBuffer();\n+                stableBackbuffer.dispose();\n+                stableBackbuffer = null;\n+            }\n+            w = pState.getRenderWidth();\n+            h = pState.getRenderHeight();\n+\n+            long pTex = pState.getNativeFrameBuffer();\n+\n+            stableBackbuffer = MTLRTTexture.create(getContext(), pTex, w, h, 0);\n+            if (PrismSettings.dirtyOptsEnabled) {\n+                stableBackbuffer.contentsUseful();\n+            }\n+            \/\/ copyFullBuffer = true;\n+        }\n+\n+        Graphics g = MTLGraphics.create(getContext(), stableBackbuffer);\n+        if (g == null) {\n+            return null;\n+        }\n+        g.scale(pixelScaleFactorX, pixelScaleFactorY);\n+        return g;\n+    }\n+\n+    @Override\n+    public boolean isOpaque() {\n+        \/\/ JDK-8364672\n+        return false;\n+    }\n+\n+    @Override\n+    public void setOpaque(boolean opaque) {\n+        \/\/ JDK-8364672\n+    }\n+\n+    @Override\n+    public boolean isMSAA() {\n+        return false;\n+    }\n+\n+    @Override\n+    public int getPhysicalWidth() {\n+        return pState.getOutputWidth();\n+    }\n+\n+    @Override\n+    public int getPhysicalHeight() {\n+        return pState.getOutputHeight();\n+    }\n+\n+    @Override\n+    public int getContentX() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getContentY() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getContentWidth() {\n+        return pState.getOutputWidth();\n+    }\n+\n+    @Override\n+    public int getContentHeight() {\n+        return pState.getOutputHeight();\n+    }\n+\n+    @Override\n+    public long getResourceHandle() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (stableBackbuffer != null) {\n+            stableBackbuffer.dispose();\n+            stableBackbuffer = null;\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLSwapChain.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.prism.MediaFrame;\n+import com.sun.prism.PixelFormat;\n+import com.sun.prism.Texture;\n+import com.sun.prism.impl.BaseTexture;\n+\n+import java.nio.Buffer;\n+import java.nio.ByteBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+\n+class MTLTexture<T extends MTLTextureData> extends BaseTexture<MTLTextureResource<T>> {\n+\n+    private final MTLContext context;\n+    private final long texPtr;\n+\n+    MTLTexture(MTLContext context, MTLTextureResource<T> resource,\n+               PixelFormat format, WrapMode wrapMode,\n+               int physicalWidth, int physicalHeight,\n+               int contentX, int contentY, int contentWidth, int contentHeight,\n+               boolean useMipmap) {\n+\n+        super(resource, format, wrapMode,\n+              physicalWidth, physicalHeight,\n+              contentX, contentY, contentWidth, contentHeight, useMipmap);\n+        this.context = context;\n+        texPtr = resource.getResource().getResource();\n+    }\n+\n+    MTLTexture(MTLContext context, MTLTextureResource<T> resource,\n+               PixelFormat format, WrapMode wrapMode,\n+               int physicalWidth, int physicalHeight,\n+               int contentX, int contentY, int contentWidth, int contentHeight,\n+               int maxContentWidth, int maxContentHeight, boolean useMipmap) {\n+\n+        super(resource, format, wrapMode,\n+              physicalWidth, physicalHeight,\n+              contentX, contentY, contentWidth, contentHeight,\n+              maxContentWidth, maxContentHeight, useMipmap);\n+        this.context = context;\n+        texPtr = resource.getResource().getResource();\n+    }\n+\n+    public long getNativeHandle() {\n+        return texPtr;\n+    }\n+\n+    public MTLContext getContext() {\n+        return context;\n+    }\n+\n+    \/\/ We don't handle mipmap in shared texture yet.\n+    private MTLTexture(MTLTexture<T> sharedTex, WrapMode newMode) {\n+        super(sharedTex, newMode, false);\n+        this.context = sharedTex.context;\n+        this.texPtr = sharedTex.texPtr;\n+    }\n+\n+    @Override\n+    protected Texture createSharedTexture(WrapMode newMode) {\n+        return new MTLTexture<>(this, newMode);\n+    }\n+\n+    private void updateTextureInt(Buffer buffer, PixelFormat format,\n+                                int dstx, int dsty,\n+                                int srcx, int srcy,\n+                                int srcw, int srch,\n+                                int srcscan) {\n+        if (format == PixelFormat.INT_ARGB_PRE) {\n+            IntBuffer buf = (IntBuffer) buffer;\n+            int[] arr = buf.hasArray() ? buf.array() : null;\n+            nUpdateInt(getNativeHandle(), buf, arr,\n+                       dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported INT PixelFormat: \" + format);\n+        }\n+    }\n+\n+    private void updateTextureFloat(Buffer buffer, PixelFormat format,\n+                                int dstx, int dsty,\n+                                int srcx, int srcy,\n+                                int srcw, int srch,\n+                                int srcscan) {\n+        if (format == PixelFormat.FLOAT_XYZW) {\n+            FloatBuffer buf = (FloatBuffer) buffer;\n+            float[] arr = buf.hasArray() ? buf.array() : null;\n+            nUpdateFloat(getNativeHandle(), buf, arr,\n+                         dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported FLOAT PixelFormat: \" + format);\n+        }\n+    }\n+\n+    private void updateTextureByte(Buffer buffer, PixelFormat format,\n+                                int dstx, int dsty,\n+                                int srcx, int srcy,\n+                                int srcw, int srch,\n+                                int srcscan) {\n+        ByteBuffer buf = (ByteBuffer) buffer;\n+        buf.rewind();\n+        byte[] arr = buf.hasArray() ? buf.array() : null;\n+\n+        switch (format) {\n+            case PixelFormat.BYTE_BGRA_PRE,\n+                 PixelFormat.BYTE_ALPHA ->\n+                nUpdate(getNativeHandle(), buf, arr,\n+                        dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n+\n+            case PixelFormat.BYTE_RGB -> {\n+                \/\/ Convert 24-bit RGB to 32-bit BGRA\n+                \/\/ Metal does not support 24-bit format\n+                \/\/ hence `arr` data needs to be converted to BGRA format\n+                if (arr == null) {\n+                    arr = new byte[buf.remaining()];\n+                    buf.get(arr);\n+                }\n+                byte[] arr32Bit = new byte[srcw * srch * 4];\n+                int dstIndex = 0;\n+                int index = 0;\n+\n+                int rowStride = srcw * 3;\n+                int totalBytes = srch * rowStride;\n+\n+                for (int rowIndex = 0; rowIndex < totalBytes; rowIndex += rowStride) {\n+                    for (int colIndex = 0; colIndex < rowStride; colIndex += 3) {\n+                        index = rowIndex + colIndex;\n+                        arr32Bit[dstIndex++] = arr[index + 2];\n+                        arr32Bit[dstIndex++] = arr[index + 1];\n+                        arr32Bit[dstIndex++] = arr[index];\n+                        arr32Bit[dstIndex++] = (byte)255;\n+                    }\n+                }\n+                nUpdate(getNativeHandle(), null, arr32Bit,\n+                        dstx, dsty, srcx, srcy, srcw, srch, srcw * 4);\n+            }\n+\n+            case PixelFormat.BYTE_GRAY -> {\n+                \/\/ Suitable 8-bit native formats are MTLPixelFormatA8Unorm & MTLPixelFormatR8Unorm.\n+                \/\/ These formats do not work well with our generated shader - Texture_RGB.\n+                \/\/ hence `arr` data is converted to BGRA format here.\n+                \/\/ In future, if needed for performance reason:\n+                \/\/ Texture_RGB shader can be tweaked to fill up R,G,B fields from single byte grayscale value.\n+                \/\/ Care must be taken not to break current behavior of this shader.\n+                if (arr == null) {\n+                    arr = new byte[buf.remaining()];\n+                    buf.get(arr);\n+                }\n+                byte[] arr32Bit = new byte[srcw * srch * 4];\n+                int dstIndex = 0;\n+                int index = 0;\n+                int totalBytes = srch * srcw;\n+\n+                for (int rowIndex = 0; rowIndex < totalBytes; rowIndex += srcw) {\n+                    for (int colIndex = 0; colIndex < srcw; colIndex++) {\n+                        index = rowIndex + colIndex;\n+                        arr32Bit[dstIndex++] = arr[index];\n+                        arr32Bit[dstIndex++] = arr[index];\n+                        arr32Bit[dstIndex++] = arr[index];\n+                        arr32Bit[dstIndex++] = (byte) 255;\n+                    }\n+                }\n+                nUpdate(getNativeHandle(), null, arr32Bit,\n+                        dstx, dsty, srcx, srcy, srcw, srch, srcw * 4);\n+            }\n+\n+            case PixelFormat.MULTI_YCbCr_420,\n+                 PixelFormat.BYTE_APPLE_422 ->\n+                throw new IllegalArgumentException(\"Unsupported PixelFormat \" + format);\n+        }\n+    }\n+\n+    @Override\n+    public void update(Buffer buffer, PixelFormat format,\n+                        int dstx, int dsty,\n+                        int srcx, int srcy,\n+                        int srcw, int srch,\n+                        int srcscan, boolean skipFlush) {\n+\n+        switch (format.getDataType()) {\n+            case PixelFormat.DataType.INT -> updateTextureInt(buffer, format,\n+                dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n+\n+            case PixelFormat.DataType.FLOAT -> updateTextureFloat(buffer, format,\n+                dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n+\n+            case PixelFormat.DataType.BYTE -> updateTextureByte(buffer, format,\n+                dstx, dsty, srcx, srcy, srcw, srch, srcscan);\n+        }\n+    }\n+\n+\n+    @Override\n+    public void update(MediaFrame frame, boolean skipFlush) {\n+        if (frame.getPixelFormat() == PixelFormat.MULTI_YCbCr_420 ||\n+            frame.getPixelFormat() != PixelFormat.BYTE_APPLE_422) {\n+            \/\/ Shouldn't have gotten this far\n+            throw new IllegalArgumentException(\"Unsupported format: \" + frame.getPixelFormat());\n+        }\n+\n+        frame.holdFrame();\n+\n+        ByteBuffer pixels = frame.getBufferForPlane(0);\n+        byte[] arr = pixels.hasArray() ? pixels.array() : null;\n+        if (arr == null) {\n+            arr = new byte[pixels.remaining()];\n+            pixels.get(arr);\n+        }\n+\n+        nUpdateYUV422(this.getNativeHandle(),\n+                      arr, 0, 0, 0, 0,\n+                      frame.getEncodedWidth(), frame.getEncodedHeight(),\n+                      frame.strideForPlane(0));\n+\n+        frame.releaseFrame();\n+    }\n+\n+\n+    \/\/ Native methods\n+\n+    private static native void nUpdate(long pResource, ByteBuffer buf, byte[] pixels,\n+                                       int dstx, int dsty, int srcx, int srcy,\n+                                       int w, int h, int stride);\n+\n+    private static native void nUpdateFloat(long pResource, FloatBuffer buf, float[] pixels,\n+                                            int dstx, int dsty, int srcx, int srcy,\n+                                            int w, int h, int stride);\n+\n+    private static native void nUpdateInt(long pResource, IntBuffer buf, int[] pixels,\n+                                          int dstx, int dsty, int srcx, int srcy,\n+                                          int w, int h, int stride);\n+\n+    private static native void nUpdateYUV422(long pResource, byte[] pixels,\n+                                             int dstx, int dsty, int srcx, int srcy,\n+                                             int w, int h, int stride);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLTexture.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.prism.impl.Disposer;\n+import java.util.Objects;\n+\n+class MTLTextureData implements Disposer.Record {\n+    protected final MTLContext mtlContext;\n+    protected long pTexture;\n+    private long size;\n+\n+    MTLTextureData(MTLContext context, long texPtr, long textureSize) {\n+        Objects.requireNonNull(context, \"MTLContext must not be null\");\n+        if (texPtr == 0L) {\n+            throw new IllegalArgumentException(\"Texture cannot be null\");\n+        }\n+        mtlContext = context;\n+        pTexture = texPtr;\n+        size = textureSize;\n+    }\n+\n+    public long getResource() {\n+        return pTexture;\n+    }\n+\n+    public long getSize() {\n+        return size;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pTexture != 0L && !mtlContext.isDisposed()) {\n+            MTLResourceFactory.releaseTexture(pTexture);\n+            pTexture = 0L;\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLTextureData.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.prism.impl.DisposerManagedResource;\n+\n+class MTLTextureResource<T extends MTLTextureData> extends DisposerManagedResource<T> {\n+\n+    private final boolean canDispose;\n+\n+    MTLTextureResource(T resource, boolean canDispose) {\n+        super(resource, MTLVramPool.getInstance(), resource);\n+        this.canDispose = canDispose;\n+    }\n+\n+    @Override\n+    public void free() {\n+        if (resource != null && canDispose) {\n+            resource.dispose();\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLTextureResource.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.prism.mtl;\n+\n+import com.sun.prism.PixelFormat;\n+import com.sun.prism.impl.BaseResourcePool;\n+import com.sun.prism.impl.PrismSettings;\n+import com.sun.prism.impl.TextureResourcePool;\n+\n+class MTLVramPool extends BaseResourcePool<MTLTextureData>\n+               implements TextureResourcePool<MTLTextureData> {\n+\n+    private static final MTLVramPool theInstance = new MTLVramPool();\n+\n+    public static MTLVramPool getInstance() {\n+        return theInstance;\n+    }\n+\n+    private MTLVramPool() {\n+        super(PrismSettings.targetVram, PrismSettings.maxVram);\n+    }\n+\n+    @Override\n+    public long estimateTextureSize(int width, int height, PixelFormat format) {\n+        return (long) width * height * format.getBytesPerPixelUnit();\n+    }\n+\n+    @Override\n+    public long estimateRTTextureSize(int width, int height, boolean hasDepth) {\n+        \/\/ REMIND: need to deal with size of depth buffer, etc.\n+        return ((long) width) * ((long) height) * 4L;\n+    }\n+\n+    @Override\n+    public long size(MTLTextureData resource) {\n+        return resource.getSize();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MTL Vram Pool\";\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/mtl\/MTLVramPool.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,10 @@\n+    }\n+\n+    @Override\n+    public Shader createShader(String shaderName,\n+                               Map<String, Integer> samplers,\n+                               Map<String, Integer> params,\n+                               int maxTexCoordIndex,\n+                               boolean isPixcoordUsed,\n+                               boolean isPerVertexColorUsed) {\n+        return new DummyShader(context, params);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/null3d\/DummyResourceFactory.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,9 @@\n+\n+    \/\/ This method is added only for MTL pipeline.\n+    public Shader createShader(String shaderName,\n+                               Map<String, Integer> samplers,\n+                               Map<String, Integer> params,\n+                               int maxTexCoordIndex,\n+                               boolean isPixcoordUsed,\n+                               boolean isPerVertexColorUsed);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/ps\/ShaderFactory.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -544,1 +544,6 @@\n-        DIRECT3D(\"Direct3D\");\n+        DIRECT3D(\"Direct3D\"),\n+        \/**\n+         * Indicates that this {@code Effect} is being accelerated in\n+         * graphics hardware via Metal.\n+         *\/\n+        METAL(\"Metal\");\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/scenario\/effect\/Effect.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.scenario.effect.impl.hw.mtl;\n+\n+import com.sun.scenario.effect.Effect.AccelType;\n+import com.sun.scenario.effect.impl.hw.ShaderSource;\n+import java.io.InputStream;\n+\n+public class MTLShaderSource implements ShaderSource {\n+\n+    @Override\n+    public InputStream loadSource(String name) {\n+        \/\/ MSL shaders are compiled and linked into a MTLLibrary at build time.\n+        \/\/ At runtime, shaders get loaded from that library as needed.\n+        \/\/ throw new UnsupportedOperationException(\"Metal shader source is not available at runtime.\");\n+        return null;\n+    }\n+\n+    @Override\n+    public AccelType getAccelType() {\n+        return AccelType.METAL;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/scenario\/effect\/impl\/hw\/mtl\/MTLShaderSource.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -476,0 +476,2 @@\n+        }  else if (pipe.supportsShader(ShaderType.MSL, ShaderModel.SM3)) {\n+            shaderSource = createShaderSource(rootPkg + \".impl.hw.mtl.MTLShaderSource\");\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/scenario\/effect\/impl\/prism\/ps\/PPSRenderer.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * This class is used as a common entry point for generating Decora shaders.\n+ *\/\n+\n+public class GenAllDecoraShaders {\n+\n+    private static final String [][] compileShaders = {\n+            {\"CompileJSL\", \"-all\", \"ColorAdjust\"},\n+            {\"CompileJSL\", \"-all\", \"Brightpass\"},\n+            {\"CompileJSL\", \"-all\", \"SepiaTone\"},\n+            {\"CompileJSL\", \"-all\", \"PerspectiveTransform\"},\n+            {\"CompileJSL\", \"-all\", \"DisplacementMap\"},\n+            {\"CompileJSL\", \"-all\", \"InvertMask\"},\n+            {\"CompileBlend\", \"-all\", \"Blend\"},\n+            {\"CompilePhong\", \"-all\", \"PhongLighting\"},\n+            {\"CompileLinearConvolve\", \"-hw\", \"LinearConvolve\"},\n+            {\"CompileLinearConvolve\", \"-hw\", \"LinearConvolveShadow\"}\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < compileShaders.length; i++) {\n+            args[7] = compileShaders[i][1]; \/\/ types of shaders to be generated\n+            args[8] = compileShaders[i][2]; \/\/ jsl shader file name\n+            Class<?> cls = Class.forName(compileShaders[i][0]);\n+            Method meth = cls.getMethod(\"main\", String[].class);\n+            meth.invoke(null, (Object) args);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/jsl-decora\/GenAllDecoraShaders.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -472,0 +472,1 @@\n+        nameMap.put(JSLC.OUT_MTL, \"prism-mtl\/build\/gensrc\/{pkg}\/mtl\/msl\/{name}.metal\");\n","filename":"modules\/javafx.graphics\/src\/main\/jsl-prism\/CompileJSL.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,1 @@\n-JNIEXPORT jint JNICALL Java_com_sun_glass_ui_ios_IosView__1getNativeFrameBuffer\n+JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_ios_IosView__1getNativeFrameBuffer\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/ios\/GlassView.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import <Foundation\/Foundation.h>\n+\n+#import <OpenGL\/gl.h>\n+#import <OpenGL\/OpenGL.h>\n+\n+@interface GlassCGLFrameBufferObject : NSObject\n+{\n+    GLuint _width;\n+    GLuint _height;\n+\n+    GLuint _texture;\n+    GLuint _fbo;\n+    GLuint _fboToRestore;\n+    BOOL   _isSwPipe;\n+}\n+\n+- (void)blitFromFBO:(GlassCGLFrameBufferObject*)other_fbo;\n+- (GLuint)texture;\n+- (GLuint)fbo;\n+- (void)setIsSwPipe:(BOOL)isSwPipe;\n+- (GLuint)width;\n+- (GLuint)height;\n+- (void)bindForWidth:(GLuint)width andHeight:(GLuint)height;\n+- (void)unbind;\n+- (void)blitForWidth:(GLuint)width andHeight:(GLuint)height;\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassCGLFrameBufferObject.h","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-#import \"GlassFrameBufferObject.h\"\n+#import \"GlassCGLFrameBufferObject.h\"\n@@ -43,1 +43,1 @@\n-@implementation GlassFrameBufferObject\n+@implementation GlassCGLFrameBufferObject\n@@ -123,1 +123,1 @@\n-            LOG(\"           GlassFrameBufferObject created Texture: %d\", self->_texture);\n+            LOG(\"           GlassCGLFrameBufferObject created Texture: %d\", self->_texture);\n@@ -141,1 +141,1 @@\n-            LOG(\"           GlassFrameBufferObject created FBO: %d\", self->_fbo);\n+            LOG(\"           GlassCGLFrameBufferObject created FBO: %d\", self->_fbo);\n@@ -227,1 +227,1 @@\n-    LOG(\"           GlassFrameBufferObject bindForWidth:%d andHeight:%d\", width, height);\n+    LOG(\"           GlassCGLFrameBufferObject bindForWidth:%d andHeight:%d\", width, height);\n@@ -258,1 +258,1 @@\n-        LOG(\"           GlassFrameBufferObject unbind\");\n+        LOG(\"           GlassCGLFrameBufferObject unbind\");\n@@ -282,1 +282,1 @@\n-    LOG(\"           GlassFrameBufferObject blitForWidth:%d andHeight:%d [%p]\", width, height, self);\n+    LOG(\"           GlassCGLFrameBufferObject blitForWidth:%d andHeight:%d [%p]\", width, height, self);\n@@ -315,1 +315,1 @@\n-- (void)blitFromFBO:(GlassFrameBufferObject*)other_fbo\n+- (void)blitFromFBO:(GlassCGLFrameBufferObject*)other_fbo\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassCGLFrameBufferObject.m","additions":9,"deletions":9,"binary":false,"changes":18,"previous_filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassFrameBufferObject.m","status":"renamed"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import <OpenGL\/gl.h>\n+#import <OpenGL\/OpenGL.h>\n+#import \"GlassOffscreen.h\"\n+#import \"GlassCGLFrameBufferObject.h\"\n+\n+@interface GlassCGLOffscreen : GlassOffscreen\n+{\n+    CGLContextObj               _ctx;\n+    CGLContextObj               _ctxToRestore;\n+\n+    GlassCGLFrameBufferObject*  _fbo;\n+\n+    GLboolean                   _dirty;\n+    NSUInteger          _drawCounter; \/\/ draw counter, so that we only bind\/unbind offscreen once\n+    GLuint              _texture;\n+    GLuint              _width;\n+    GLuint              _height;\n+    GLuint              _textureWidth;\n+    GLuint              _textureHeight;\n+    NSView* glassView;\n+}\n+\n+- (id)initWithContext:(CGLContextObj)ctx\n+          andIsSwPipe:(BOOL)isSwPipe;\n+- (CGLContextObj)getContext;\n+- (GLuint)texture;\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassCGLOffscreen.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"GlassCGLOffscreen.h\"\n+\n+@implementation GlassCGLOffscreen\n+\n+static NSArray *allModes = nil;\n+\n+- (id)initWithContext:(CGLContextObj)ctx\n+          andIsSwPipe:(BOOL)isSwPipe\n+{\n+    self = [super init];\n+    if (self != nil)\n+    {\n+        self->_drawCounter = 0;\n+        self->_texture = 0;\n+        self->_ctx = CGLRetainContext(ctx);\n+\n+        [self setContext];\n+        {\n+            self->_fbo = [[GlassCGLFrameBufferObject alloc] init];\n+            if (self->_fbo == nil)\n+            {\n+                \/\/ TODO: implement PBuffer if needed\n+                \/\/ self->_fbo = [[GlassPBuffer alloc] init];\n+            }\n+            [(GlassCGLFrameBufferObject*)self->_fbo setIsSwPipe:(BOOL)isSwPipe];\n+        }\n+        [self unsetContext];\n+        if (allModes == nil) {\n+            allModes = [[NSArray arrayWithObjects:NSDefaultRunLoopMode,\n+                                                  NSEventTrackingRunLoopMode,\n+                                                  NSModalPanelRunLoopMode, nil] retain];\n+        }\n+    }\n+    return self;\n+}\n+\n+- (CGLContextObj)getContext\n+{\n+    return self->_ctx;\n+}\n+\n+- (void)dealloc\n+{\n+    if (self->_texture != 0)\n+    {\n+        [self bindForWidth:(GLuint)[self->glassView bounds].size.width\n+                 andHeight:(GLuint)[self->glassView bounds].size.height];\n+        glDeleteTextures(1, &self->_texture);\n+        [self unbind];\n+    }\n+    [self setContext];\n+    [(NSObject*)self->_fbo release];\n+    self->_fbo = NULL;\n+    [self unsetContext];\n+\n+    CGLReleaseContext(self->_ctx);\n+    self->_ctx = NULL;\n+\n+    [super dealloc];\n+}\n+\n+- (unsigned int)width\n+{\n+    return [self->_fbo width];\n+}\n+\n+- (unsigned int)height\n+{\n+    return [self->_fbo height];\n+}\n+\n+- (jlong)fbo\n+{\n+    return (jlong)[self->_fbo fbo];\n+}\n+\n+- (void)setContext\n+{\n+    self->_ctxToRestore = CGLGetCurrentContext();\n+    CGLLockContext(self->_ctx);\n+    CGLSetCurrentContext(self->_ctx);\n+}\n+\n+- (void)unsetContext\n+{\n+    CGLSetCurrentContext(self->_ctxToRestore);\n+    CGLUnlockContext(self->_ctx);\n+}\n+\n+- (void)bindForWidth:(GLuint)width\n+           andHeight:(GLuint)height\n+{\n+    assert(self->_drawCounter >= 0);\n+    if (self->_drawCounter == 0)\n+    {\n+        self->_width = width;\n+        self->_height = height;\n+        [self setContext];\n+        [self->_fbo bindForWidth:width andHeight:height];\n+    }\n+    self->_drawCounter++;\n+}\n+\n+- (void)flush:(GlassOffscreen*)glassOffScreen\n+{\n+    assert(self->_drawCounter > 0);\n+    self->_drawCounter--;\n+    if (self->_drawCounter == 0)\n+    {\n+        [self unbind];\n+        [(GlassCGLOffscreen*)glassOffScreen blitFromOffscreen:(GlassCGLOffscreen*)self];\n+        if ([NSThread isMainThread]) {\n+            [[(GlassCGLOffscreen*)glassOffScreen getLayer] setNeedsDisplay];\n+        } else {\n+            [[(GlassCGLOffscreen*)glassOffScreen getLayer]\n+                performSelectorOnMainThread:@selector(setNeedsDisplay)\n+                                 withObject:nil\n+                              waitUntilDone:NO\n+                                      modes:allModes];\n+        }\n+    }\n+}\n+\n+- (void)pushPixels:(void*)pixels\n+         withWidth:(unsigned int)width\n+        withHeight:(unsigned int)height\n+        withScaleX:(float)scalex\n+        withScaleY:(float)scaley\n+            ofView:(NSView*)view\n+{\n+    assert(self->_drawCounter > 0);\n+\n+    if (self->_texture == 0)\n+    {\n+        glGenTextures(1, &self->_texture);\n+    }\n+    self->glassView = view;\n+    BOOL uploaded = NO;\n+    if ((self->_textureWidth != width) || (self->_textureHeight != height))\n+    {\n+        uploaded = YES;\n+\n+        self->_textureWidth = width;\n+        self->_textureHeight = height;\n+\n+        \/\/ GL_EXT_texture_rectangle is defined in OS X 10.6 GL headers, so we can depend on GL_TEXTURE_RECTANGLE_EXT being available\n+        glBindTexture(GL_TEXTURE_RECTANGLE_EXT, self->_texture);\n+        glTexParameteri(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n+        glTexParameteri(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n+        glTexParameteri(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_WRAP_S, GL_CLAMP);\n+        glTexParameteri(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_WRAP_T, GL_CLAMP);\n+        glTexImage2D(GL_TEXTURE_RECTANGLE_EXT, 0, GL_RGBA8, (GLsizei)self->_textureWidth, (GLsizei)self->_textureHeight,\n+                        0, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, pixels);\n+    }\n+\n+    glEnable(GL_TEXTURE_RECTANGLE_EXT);\n+    glBindTexture(GL_TEXTURE_RECTANGLE_EXT, self->_texture);\n+    {\n+        if (uploaded == NO)\n+        {\n+            glTexSubImage2D(GL_TEXTURE_RECTANGLE_EXT, 0, 0, 0, (GLsizei)self->_textureWidth, (GLsizei)self->_textureHeight,\n+                                GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, pixels);\n+        }\n+\n+        GLfloat w = self->_textureWidth;\n+        GLfloat h = self->_textureHeight;\n+\n+        NSSize size = [self->glassView bounds].size;\n+        size.width *= scalex;\n+        size.height *= scaley;\n+        if ((size.width != w) || (size.height != h))\n+        {\n+            \/\/ This could happen on live resize, clear the FBO to avoid rendering garbage\n+            glClear(GL_COLOR_BUFFER_BIT);\n+        }\n+\n+        glMatrixMode(GL_PROJECTION);\n+        glPushMatrix();\n+        glLoadIdentity();\n+        glOrtho(0.0f, size.width, size.height, 0.0f, -1.0f, 1.0f);\n+        {\n+            glMatrixMode(GL_MODELVIEW);\n+            glPushMatrix();\n+            glLoadIdentity();\n+            {\n+                glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE); \/\/ copy\n+\n+                glBegin(GL_QUADS);\n+                {\n+                    glTexCoord2f(0.0f, 0.0f); glVertex2f(0.0f, 0.0f);\n+                    glTexCoord2f(   w, 0.0f); glVertex2f(   w, 0.0f);\n+                    glTexCoord2f(   w,    h); glVertex2f(   w,    h);\n+                    glTexCoord2f(0.0f,    h); glVertex2f(0.0f,    h);\n+                }\n+                glEnd();\n+            }\n+            glMatrixMode(GL_MODELVIEW);\n+            glPopMatrix();\n+        }\n+        glMatrixMode(GL_PROJECTION);\n+        glPopMatrix();\n+    }\n+    glBindTexture(GL_TEXTURE_RECTANGLE_EXT, 0);\n+    glDisable(GL_TEXTURE_RECTANGLE_EXT);\n+\n+    glFinish();\n+}\n+\n+- (void)unbind\n+{\n+    [self->_fbo unbind];\n+    [self unsetContext];\n+}\n+\n+- (GLuint)texture\n+{\n+    return [self->_fbo texture];\n+}\n+\n+- (void)blitForWidth:(GLuint)width\n+           andHeight:(GLuint)height\n+{\n+    {\n+#if 1\n+        glClearColor(self->_backgroundR, self->_backgroundG, self->_backgroundB, self->_backgroundA);\n+        glClear(GL_COLOR_BUFFER_BIT);\n+#else\n+        \/\/ for debugging, change clear color every 0.5 seconds\n+        static int counterFps = 0;\n+        static int counterColor = 0;\n+        counterFps++;\n+        if ((counterFps%(60\/2)) == 0)\n+        {\n+            counterColor++;\n+        }\n+        switch (counterColor%3)\n+        {\n+            case 0:\n+                glClearColor(1.0f, 0.0f, 0.0f, 1.0f);\n+                break;\n+            case 1:\n+                glClearColor(0.0f, 1.0f, 0.0f, 1.0f);\n+                break;\n+            case 2:\n+                glClearColor(0.0f, 0.0f, 1.0f, 1.0f);\n+                break;\n+        }\n+        glClear(GL_COLOR_BUFFER_BIT);\n+#endif\n+        [self->_fbo blitForWidth:width\n+                       andHeight:height];\n+\n+        self->_dirty = GL_FALSE;\n+    }\n+}\n+\n+- (GLboolean)isDirty\n+{\n+    return self->_dirty;\n+}\n+\n+- (void)blit\n+{\n+    [self blitForWidth:[self->_fbo width]\n+             andHeight:[self->_fbo height]];\n+}\n+\n+- (void)blitFromOffscreen:(GlassCGLOffscreen*)other_offscreen\n+{\n+    [self setContext];\n+    {\n+        [(GlassCGLFrameBufferObject*)self->_fbo blitFromFBO:(GlassCGLFrameBufferObject*)other_offscreen->_fbo];\n+        self->_dirty = GL_TRUE;\n+    }\n+    [self unsetContext];\n+}\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassCGLOffscreen.m","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import <Foundation\/Foundation.h>\n-\n-#import <OpenGL\/gl.h>\n-#import <OpenGL\/OpenGL.h>\n-\n-#import \"GlassOffscreen.h\"\n-\n-@interface GlassFrameBufferObject : NSObject <GlassOffscreenProtocol>\n-{\n-    GLuint _width;\n-    GLuint _height;\n-\n-    GLuint _texture;\n-    GLuint _fbo;\n-    GLuint _fboToRestore;\n-    BOOL   _isSwPipe;\n-}\n-\n-- (void)blitFromFBO:(GlassFrameBufferObject*)other_fbo;\n-- (GLuint)texture;\n-- (GLuint)fbo;\n-- (void)setIsSwPipe:(BOOL)isSwPipe;\n-\n-@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassFrameBufferObject.h","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"GlassOffscreen.h\"\n+\n+@interface GlassLayer : CALayer\n+{\n+    GlassOffscreen *painterOffScreen;\n+    GlassOffscreen *glassOffScreen;\n+    BOOL isHiDPIAware;\n+}\n+\n+- (id)initGlassLayer:(NSObject*)ctx\n+    andClientContext:(NSObject*)clCtx\n+         mtlQueuePtr:(long)mtlCommandQueuePtr\n+      withHiDPIAware:(BOOL)HiDPIAware\n+        withIsSwPipe:(BOOL)isSwPipe;\n+\n+- (GlassOffscreen*)getPainterOffscreen;\n+- (void)bindForWidth:(unsigned int)width\n+           andHeight:(unsigned int)height;\n+- (void)end;\n+- (void)pushPixels:(void*)pixels\n+         withWidth:(unsigned int)width\n+        withHeight:(unsigned int)height\n+        withScaleX:(float)scalex\n+        withScaleY:(float)scaley\n+            ofView:(NSView*)view;\n+\n+- (void)notifyScaleFactorChanged:(CGFloat)scale;\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassLayer.h","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"GlassLayer.h\"\n+#import \"GlassMacros.h\"\n+#import \"GlassScreen.h\"\n+#import \"GlassLayerCGL.h\"\n+#import \"GlassLayerMTL.h\"\n+\n+\/\/#define VERBOSE\n+#ifndef VERBOSE\n+    #define LOG(MSG, ...)\n+#else\n+    #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);\n+#endif\n+\n+@implementation GlassLayer\n+\n+static NSArray *allModes = nil;\n+\n+- (id)initGlassLayer:(NSObject*)ctx\n+    andClientContext:(NSObject*)clCtx\n+         mtlQueuePtr:(long)mtlCommandQueuePtr\n+      withHiDPIAware:(BOOL)HiDPIAware\n+        withIsSwPipe:(BOOL)isSwPipe\n+{\n+    LOG(\"GlassLayer initGlassLayer]\");\n+    self = [super init];\n+    if (self != nil)\n+    {\n+        if (mtlCommandQueuePtr != 0l) { \/\/ MTL\n+            GlassLayerMTL* mtlLayer = [[GlassLayerMTL alloc] init:mtlCommandQueuePtr\n+                                                     withIsSwPipe:isSwPipe];\n+            self->painterOffScreen = [mtlLayer getPainterOffscreen];\n+            self->glassOffScreen = nil;\n+            [self addSublayer:mtlLayer];\n+        } else {\n+            GlassLayerCGL* cglLayer = [[GlassLayerCGL alloc] initWithSharedContext:(CGLContextObj)ctx\n+                                                                  andClientContext:(CGLContextObj)clCtx\n+                                                                    withHiDPIAware:HiDPIAware\n+                                                                      withIsSwPipe:isSwPipe];\n+            self->painterOffScreen = [cglLayer getPainterOffscreen];\n+            self->glassOffScreen = [cglLayer getGlassOffscreen];\n+            [self addSublayer:cglLayer];\n+        }\n+        self->isHiDPIAware = HiDPIAware;\n+        LOG(\"   GlassLayer context: %p\", ctx);\n+\n+        [self setAutoresizingMask:(kCALayerWidthSizable | kCALayerHeightSizable)];\n+        [self setContentsGravity:kCAGravityTopLeft];\n+\n+        \/\/ Initially the view is not in any window yet, so using the\n+        \/\/ screens[0]'s scale is a good starting point (this is most probably\n+        \/\/ the notebook's main LCD display which is HiDPI-capable).\n+        \/\/ Note that mainScreen is the screen with the current app bar focus\n+        \/\/ in Mavericks and later OS so it will likely not match the screen\n+        \/\/ we initially show windows on if an app is started from an external\n+        \/\/ monitor.\n+        [self notifyScaleFactorChanged:GetScreenScaleFactor([[NSScreen screens] objectAtIndex:0])];\n+\n+        [self setMasksToBounds:YES];\n+        [self setNeedsDisplayOnBoundsChange:YES];\n+        [self setAnchorPoint:CGPointMake(0.0f, 0.0f)];\n+\n+        if (allModes == nil) {\n+            allModes = [[NSArray arrayWithObjects:NSDefaultRunLoopMode,\n+                                                  NSEventTrackingRunLoopMode,\n+                                                  NSModalPanelRunLoopMode, nil] retain];\n+        }\n+    }\n+    return self;\n+}\n+\n+- (void)dealloc\n+{\n+    [super dealloc];\n+}\n+\n+- (void)notifyScaleFactorChanged:(CGFloat)scale\n+{\n+    if (self->isHiDPIAware) {\n+        if ([self.sublayers[0] respondsToSelector:@selector(setContentsScale:)]) {\n+            [self.sublayers[0] setContentsScale: scale];\n+        }\n+    }\n+}\n+\n+- (void)end\n+{\n+    [self->painterOffScreen flush:self->glassOffScreen];\n+}\n+\n+- (void)bindForWidth:(unsigned int)width\n+           andHeight:(unsigned int)height\n+{\n+    [self->painterOffScreen bindForWidth:width\n+                               andHeight:height];\n+}\n+\n+- (GlassOffscreen*)getPainterOffscreen\n+{\n+    return self->painterOffScreen;\n+}\n+\n+- (void)pushPixels:(void*)pixels\n+         withWidth:(unsigned int)width\n+        withHeight:(unsigned int)height\n+        withScaleX:(float)scalex\n+        withScaleY:(float)scaley\n+            ofView:(NSView*)view\n+{\n+    [self->painterOffScreen pushPixels:pixels\n+                             withWidth:width\n+                            withHeight:height\n+                            withScaleX:scalex\n+                            withScaleY:scaley\n+                                ofView:view];\n+}\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassLayer.m","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import <OpenGL\/gl.h>\n-#import <OpenGL\/OpenGL.h>\n-\n-#import \"GlassOffscreen.h\"\n-\n-@interface GlassLayer3D : CAOpenGLLayer\n-{\n-    GlassOffscreen *_glassOffscreen;\n-    GlassOffscreen *_painterOffscreen;\n-\n-    BOOL isHiDPIAware;\n-}\n-\n-- (id)initWithSharedContext:(CGLContextObj)ctx\n-           andClientContext:(CGLContextObj)clCtx\n-             withHiDPIAware:(BOOL)HiDPIAware\n-             withIsSwPipe:(BOOL)isSwPipe;\n-\n-- (GlassOffscreen*)getPainterOffscreen;\n-- (GlassOffscreen*)getGlassOffscreen;\n-- (void)hostOffscreen:(GlassOffscreen*)offscreen;\n-- (void)flush;\n-\n-- (void)notifyScaleFactorChanged:(CGFloat)scale;\n-\n-@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassLayer3D.h","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,190 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import \"GlassLayer3D.h\"\n-\n-#import \"GlassMacros.h\"\n-#import \"GlassScreen.h\"\n-\n-\/\/#define VERBOSE\n-#ifndef VERBOSE\n-    #define LOG(MSG, ...)\n-#else\n-    #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);\n-#endif\n-\n-@implementation GlassLayer3D\n-\n-static NSArray *allModes = nil;\n-\n-- (id)initWithSharedContext:(CGLContextObj)ctx\n-           andClientContext:(CGLContextObj)clCtx\n-             withHiDPIAware:(BOOL)HiDPIAware\n-             withIsSwPipe:(BOOL)isSwPipe\n-{\n-    LOG(\"GlassLayer3D initWithSharedContext]\");\n-    self = [super init];\n-    if (self != nil)\n-    {\n-        self->_painterOffscreen = [[GlassOffscreen alloc] initWithContext:clCtx andIsSwPipe:isSwPipe];\n-        self->_glassOffscreen = [[GlassOffscreen alloc] initWithContext:ctx andIsSwPipe:isSwPipe];\n-        [self->_glassOffscreen setLayer:self];\n-        LOG(\"   GlassLayer3D context: %p\", ctx);\n-\n-        self->isHiDPIAware = HiDPIAware;\n-\n-        [self setAsynchronous:NO];\n-        [self setAutoresizingMask:(kCALayerWidthSizable|kCALayerHeightSizable)];\n-        [self setContentsGravity:kCAGravityTopLeft];\n-\n-        \/\/ Initially the view is not in any window yet, so using the\n-        \/\/ screens[0]'s scale is a good starting point (this is most probably\n-        \/\/ the notebook's main LCD display which is HiDPI-capable).\n-        \/\/ Note that mainScreen is the screen with the current app bar focus\n-        \/\/ in Mavericks and later OS so it will likely not match the screen\n-        \/\/ we initially show windows on if an app is started from an external\n-        \/\/ monitor.\n-        [self notifyScaleFactorChanged:GetScreenScaleFactor([[NSScreen screens] objectAtIndex:0])];\n-\n-        [self setMasksToBounds:YES];\n-        [self setNeedsDisplayOnBoundsChange:YES];\n-        [self setAnchorPoint:CGPointMake(0.0f, 0.0f)];\n-\n-        if (allModes == nil) {\n-            allModes = [[NSArray arrayWithObjects:NSDefaultRunLoopMode,\n-                                                  NSEventTrackingRunLoopMode,\n-                                                  NSModalPanelRunLoopMode, nil] retain];\n-        }\n-\n-        self.colorspace = CGColorSpaceCreateWithName(kCGColorSpaceSRGB);\n-    }\n-    return self;\n-}\n-\n-- (void)dealloc\n-{\n-    [self->_glassOffscreen release];\n-    self->_glassOffscreen = nil;\n-\n-    [self->_painterOffscreen release];\n-    self->_painterOffscreen = nil;\n-\n-    [super dealloc];\n-}\n-\n-- (void)notifyScaleFactorChanged:(CGFloat)scale\n-{\n-    if (self->isHiDPIAware) {\n-        if ([self respondsToSelector:@selector(setContentsScale:)]) {\n-            [self setContentsScale: scale];\n-        }\n-    }\n-}\n-\n-\/\/- (void)setBounds:(CGRect)bounds\n-\/\/{\n-\/\/    LOG(\"GlassLayer3D setBounds:%s\", [NSStringFromRect(NSRectFromCGRect(bounds)) UTF8String]);\n-\/\/    [super setBounds:bounds];\n-\/\/}\n-\n-- (BOOL)canDrawInCGLContext:(CGLContextObj)glContext pixelFormat:(CGLPixelFormatObj)pixelFormat forLayerTime:(CFTimeInterval)timeInterval displayTime:(const CVTimeStamp *)timeStamp\n-{\n-    return [self->_glassOffscreen isDirty];\n-}\n-\n-- (CGLContextObj)copyCGLContextForPixelFormat:(CGLPixelFormatObj)pixelFormat\n-{\n-    return CGLRetainContext([self->_glassOffscreen getContext]);\n-}\n-\n-- (CGLPixelFormatObj)copyCGLPixelFormatForDisplayMask:(uint32_t)mask\n-{\n-    return CGLRetainPixelFormat(CGLGetPixelFormat([self->_glassOffscreen getContext]));\n-}\n-\n-- (void)drawInCGLContext:(CGLContextObj)glContext pixelFormat:(CGLPixelFormatObj)pixelFormat forLayerTime:(CFTimeInterval)timeInterval displayTime:(const CVTimeStamp *)timeStamp\n-{\n-    \/\/ glContext is already set as current by now and locked by Quartz internaly\n-    LOG(\"GlassLayer3D drawInCGLContext]\");\n-    LOG(\"   current context: %p\", CGLGetCurrentContext());\n-#ifdef VERBOSE\n-    {\n-        GLint fbo = 0; \/\/ default to screen\n-        glGetIntegerv(GL_FRAMEBUFFER_BINDING_EXT, (GLint*)&fbo);\n-        LOG(\"   fbo: %d\", fbo);\n-    }\n-#endif\n-    \/\/ the viewport is already set for us here, so just blit\n-\n-#if 0\n-    \/\/ this will stretch the offscreen to cover all the surface\n-    \/\/ ie., live resizing \"appears\" better, but the blit area is not at 1:1 scale\n-    [self->_glassOffscreen blit];\n-#else\n-    \/\/ we blit only in the area we rendered in\n-    GLint params[] = { 0, 0, 0, 0 };\n-    glGetIntegerv(GL_VIEWPORT, params);\n-    if ((params[2] > 0) && ((params[3] > 0)))\n-    {\n-        [self->_glassOffscreen blitForWidth:(GLuint)params[2] andHeight:(GLuint)params[3]];\n-    }\n-#endif\n-\n-    \/\/ the default implementation of the method flushes the context.\n-    [super drawInCGLContext:glContext pixelFormat:pixelFormat forLayerTime:timeInterval displayTime:timeStamp];\n-    LOG(\"\\n\");\n-}\n-\n-- (void)flush\n-{\n-    [(GlassOffscreen*)_glassOffscreen blitFromOffscreen:(GlassOffscreen*)_painterOffscreen];\n-    if ([NSThread isMainThread]) {\n-        [[self->_glassOffscreen getLayer] setNeedsDisplay];\n-    } else {\n-        [[self->_glassOffscreen getLayer] performSelectorOnMainThread:@selector(setNeedsDisplay)\n-                                                           withObject:nil\n-                                                        waitUntilDone:NO\n-                                                                modes:allModes];\n-    }\n-}\n-\n-- (GlassOffscreen*)getPainterOffscreen\n-{\n-    return self->_painterOffscreen;\n-}\n-\n-- (GlassOffscreen*)getGlassOffscreen\n-{\n-    return self->_glassOffscreen;\n-}\n-\n-- (void)hostOffscreen:(GlassOffscreen*)offscreen\n-{\n-    [self->_glassOffscreen release];\n-    self->_glassOffscreen = [offscreen retain];\n-    [self->_glassOffscreen setLayer:self];\n-}\n-\n-@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassLayer3D.m","additions":0,"deletions":190,"binary":false,"changes":190,"status":"deleted"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import <OpenGL\/gl.h>\n+#import <OpenGL\/OpenGL.h>\n+\n+#import \"GlassOffscreen.h\"\n+\n+\/\/ GlassLayerCGL is not subclass of GlassLayer, it is a subLayer\n+\/\/ and it handles CALayer's OpenGL specific drawing logic\n+@interface GlassLayerCGL : CAOpenGLLayer\n+{\n+    GlassOffscreen *_glassOffscreen;\n+    GlassOffscreen *_painterOffscreen;\n+\n+    BOOL isHiDPIAware;\n+}\n+\n+- (id)initWithSharedContext:(CGLContextObj)ctx\n+           andClientContext:(CGLContextObj)clCtx\n+             withHiDPIAware:(BOOL)HiDPIAware\n+               withIsSwPipe:(BOOL)isSwPipe;\n+\n+- (GlassOffscreen*)getPainterOffscreen;\n+- (GlassOffscreen*)getGlassOffscreen;\n+- (void)hostOffscreen:(GlassOffscreen*)offscreen;\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassLayerCGL.h","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"GlassMacros.h\"\n+#import \"GlassLayerCGL.h\"\n+#import \"GlassCGLOffscreen.h\"\n+\n+\/\/#define VERBOSE\n+#ifndef VERBOSE\n+    #define LOG(MSG, ...)\n+#else\n+    #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);\n+#endif\n+\n+@implementation GlassLayerCGL\n+\n+- (id)initWithSharedContext:(CGLContextObj)ctx\n+           andClientContext:(CGLContextObj)clCtx\n+             withHiDPIAware:(BOOL)HiDPIAware\n+               withIsSwPipe:(BOOL)isSwPipe\n+{\n+    LOG(\"GlassLayerCGL initWithSharedContext]\");\n+    self = [super init];\n+    if (self != nil)\n+    {\n+        self->_painterOffscreen = (GlassOffscreen*)[[GlassCGLOffscreen alloc] initWithContext:clCtx\n+                                                                                  andIsSwPipe:isSwPipe];\n+        self->_glassOffscreen = (GlassOffscreen*)[[GlassCGLOffscreen alloc] initWithContext:ctx\n+                                                                                andIsSwPipe:isSwPipe];\n+        [self->_glassOffscreen setLayer:self];\n+        LOG(\"   GlassLayerCGL context: %p\", ctx);\n+\n+        self->isHiDPIAware = HiDPIAware;\n+\n+        [self setAsynchronous:NO];\n+        [self setAutoresizingMask:(kCALayerWidthSizable | kCALayerHeightSizable)];\n+        [self setContentsGravity:kCAGravityTopLeft];\n+\n+        [self setMasksToBounds:YES];\n+        [self setNeedsDisplayOnBoundsChange:YES];\n+        [self setAnchorPoint:CGPointMake(0.0f, 0.0f)];\n+\n+        self.colorspace = CGColorSpaceCreateWithName(kCGColorSpaceSRGB);\n+    }\n+    return self;\n+}\n+\n+- (void)dealloc\n+{\n+    [self->_glassOffscreen release];\n+    self->_glassOffscreen = nil;\n+\n+    [self->_painterOffscreen release];\n+    self->_painterOffscreen = nil;\n+\n+    [super dealloc];\n+}\n+\n+- (BOOL)canDrawInCGLContext:(CGLContextObj)glContext\n+                pixelFormat:(CGLPixelFormatObj)pixelFormat\n+               forLayerTime:(CFTimeInterval)timeInterval\n+                displayTime:(const CVTimeStamp *)timeStamp\n+{\n+    return [self->_glassOffscreen isDirty];\n+}\n+\n+- (CGLContextObj)copyCGLContextForPixelFormat:(CGLPixelFormatObj)pixelFormat\n+{\n+    return CGLRetainContext([(GlassCGLOffscreen*)self->_glassOffscreen getContext]);\n+}\n+\n+- (CGLPixelFormatObj)copyCGLPixelFormatForDisplayMask:(uint32_t)mask\n+{\n+    return CGLRetainPixelFormat(CGLGetPixelFormat([(GlassCGLOffscreen*)self->_glassOffscreen getContext]));\n+}\n+\n+- (void)drawInCGLContext:(CGLContextObj)glContext\n+             pixelFormat:(CGLPixelFormatObj)pixelFormat\n+            forLayerTime:(CFTimeInterval)timeInterval\n+             displayTime:(const CVTimeStamp *)timeStamp\n+{\n+    \/\/ glContext is already set as current by now and locked by Quartz internaly\n+    LOG(\"GlassLayerCGL drawInCGLContext]\");\n+    LOG(\"   current context: %p\", CGLGetCurrentContext());\n+#ifdef VERBOSE\n+    {\n+        GLint fbo = 0; \/\/ default to screen\n+        glGetIntegerv(GL_FRAMEBUFFER_BINDING_EXT, (GLint*)&fbo);\n+        LOG(\"   fbo: %d\", fbo);\n+    }\n+#endif\n+    \/\/ the viewport is already set for us here, so just blit\n+\n+#if 0\n+    \/\/ this will stretch the offscreen to cover all the surface\n+    \/\/ ie., live resizing \"appears\" better, but the blit area is not at 1:1 scale\n+    [self->_glassOffscreen blit];\n+#else\n+    \/\/ we blit only in the area we rendered in\n+    GLint params[] = { 0, 0, 0, 0 };\n+    glGetIntegerv(GL_VIEWPORT, params);\n+    if ((params[2] > 0) && ((params[3] > 0)))\n+    {\n+        [self->_glassOffscreen blitForWidth:(GLuint)params[2] andHeight:(GLuint)params[3]];\n+    }\n+#endif\n+\n+    \/\/ the default implementation of the method flushes the context.\n+    [super drawInCGLContext:glContext\n+                pixelFormat:pixelFormat\n+               forLayerTime:timeInterval\n+                displayTime:timeStamp];\n+    LOG(\"\\n\");\n+}\n+\n+- (GlassOffscreen*)getPainterOffscreen\n+{\n+    return self->_painterOffscreen;\n+}\n+\n+- (GlassOffscreen*)getGlassOffscreen\n+{\n+    return self->_glassOffscreen;\n+}\n+\n+- (void)hostOffscreen:(GlassOffscreen*)offscreen\n+{\n+    [self->_glassOffscreen release];\n+    self->_glassOffscreen = [offscreen retain];\n+    [self->_glassOffscreen setLayer:self];\n+}\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassLayerCGL.m","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import <Metal\/Metal.h>\n+#import <QuartzCore\/CAMetalLayer.h>\n+#import \"GlassOffscreen.h\"\n+\n+\/\/ GlassLayerMTL is not subclass of GlassLayer, it is a subLayer\n+\/\/ and it handles CALayer's Metal specific drawing logic\n+@interface GlassLayerMTL : CAMetalLayer\n+{\n+    GlassOffscreen *_painterOffscreen;\n+\n+    BOOL isHiDPIAware;\n+    id<MTLCommandQueue> _blitCommandQueue;\n+}\n+\n+- (id) init:(long)mtlCommandQueuePtr\n+       withIsSwPipe:(BOOL)isSwPipe;\n+\n+- (void) blitToScreen;\n+\n+- (GlassOffscreen*)getPainterOffscreen;\n+- (void)display;\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassLayerMTL.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"GlassMacros.h\"\n+#import \"GlassScreen.h\"\n+#import \"GlassLayerMTL.h\"\n+#import \"GlassMTLOffscreen.h\"\n+\n+@implementation GlassLayerMTL\n+\n+- (id) init:(long)mtlCommandQueuePtr\n+       withIsSwPipe:(BOOL)isSwPipe\n+{\n+    self = [super init];\n+    isHiDPIAware = true; \/\/ TODO : pass in this from view\n+\n+    [self setAutoresizingMask:(kCALayerWidthSizable | kCALayerHeightSizable)];\n+    [self setContentsGravity:kCAGravityTopLeft];\n+\n+    [self setMasksToBounds:YES];\n+    [self setNeedsDisplayOnBoundsChange:YES];\n+    [self setAnchorPoint:CGPointMake(0.0f, 0.0f)];\n+\n+    self.device = MTLCreateSystemDefaultDevice();\n+\n+    self.pixelFormat = MTLPixelFormatBGRA8Unorm;\n+    self.framebufferOnly = NO;\n+    self.displaySyncEnabled = NO; \/\/ to support FPS faster than 60fps (-Djavafx.animation.fullspeed=true)\n+    self.opaque = NO; \/\/to support shaped window\n+\n+    if (!isSwPipe) {\n+        self->_blitCommandQueue = (id<MTLCommandQueue>)(jlong_to_ptr(mtlCommandQueuePtr));\n+    } else {\n+        self->_blitCommandQueue = [self.device newCommandQueue];\n+    }\n+    self->_painterOffscreen = (GlassOffscreen*)[[GlassMTLOffscreen alloc] initWithContext:self.device\n+                                                                             commandQueue:self->_blitCommandQueue\n+                                                                              andIsSwPipe:isSwPipe];\n+    [self->_painterOffscreen setLayer:self];\n+\n+    self.colorspace = CGColorSpaceCreateWithName(kCGColorSpaceSRGB);\n+\n+    return self;\n+}\n+\n+- (void)dealloc\n+{\n+    [self->_painterOffscreen release];\n+    self->_painterOffscreen = nil;\n+\n+    [super dealloc];\n+}\n+\n+- (GlassOffscreen*)getPainterOffscreen\n+{\n+    return self->_painterOffscreen;\n+}\n+\n+- (void)display {\n+\n+    [self blitToScreen];\n+\n+    [super display];\n+}\n+\n+static int nextDrawableCount = 0;\n+\n+- (void) blitToScreen\n+{\n+    id<MTLTexture> backBufferTex = [(GlassMTLOffscreen*)self->_painterOffscreen getMTLTexture];\n+\n+    if (backBufferTex == nil) {\n+        return;\n+    }\n+\n+    int width = [self->_painterOffscreen width];\n+    int height = [self->_painterOffscreen height];\n+\n+    if (width <= 0 || height <= 0) {\n+        \/\/ NSLog(@\"Layer --------- backing texture not ready yet--- skipping blit.\");\n+        return;\n+    }\n+\n+    if (nextDrawableCount > 2) {\n+        \/\/ NSLog(@\"Layer --------- previous drawing in progress.. skipping blit to screen.\");\n+        return;\n+    }\n+\n+    @autoreleasepool {\n+        id<MTLCommandBuffer> commandBuf = [self->_blitCommandQueue commandBuffer];\n+        if (commandBuf == nil) {\n+            return;\n+        }\n+        id<CAMetalDrawable> mtlDrawable = [self nextDrawable];\n+        if (mtlDrawable == nil) {\n+            return;\n+        }\n+\n+        nextDrawableCount++;\n+\n+        id <MTLBlitCommandEncoder> blitEncoder = [commandBuf blitCommandEncoder];\n+\n+        MTLRegion region = {{0, 0, 0}, {width, height, 1}};\n+\n+        if (backBufferTex.usage == MTLTextureUsageRenderTarget) {\n+            [blitEncoder synchronizeTexture:backBufferTex slice:0 level:0];\n+        }\n+        [blitEncoder copyFromTexture:backBufferTex\n+                         sourceSlice:0\n+                         sourceLevel:0\n+                        sourceOrigin:MTLOriginMake(0, 0, 0)\n+                          sourceSize:MTLSizeMake(width, height, 1)\n+                           toTexture:mtlDrawable.texture\n+                    destinationSlice:0\n+                    destinationLevel:0\n+                   destinationOrigin:MTLOriginMake(0, 0, 0)];\n+\n+        [blitEncoder endEncoding];\n+        [commandBuf presentDrawable:mtlDrawable];\n+        [commandBuf addCompletedHandler:^(id <MTLCommandBuffer> commandBuf) {\n+            nextDrawableCount--;\n+        }];\n+\n+        [commandBuf commit];\n+        \/\/ [commandBuf waitUntilCompleted];\n+    }\n+}\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassLayerMTL.m","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import <Metal\/Metal.h>\n+\n+@interface GlassMTLFrameBufferObject : NSObject\n+{\n+    unsigned int _width;\n+    unsigned int _height;\n+\n+    id<MTLTexture> _texture;\n+    BOOL   _isSwPipe;\n+}\n+\n+- (void)blitFromFBO:(GlassMTLFrameBufferObject*)other_fbo;\n+- (id<MTLTexture>)texture;\n+- (void)setIsSwPipe:(BOOL)isSwPipe;\n+- (unsigned int)width;\n+- (unsigned int)height;\n+- (void)bindForWidth:(unsigned int)width\n+           andHeight:(unsigned int)height;\n+- (void)blitForWidth:(unsigned int)width\n+           andHeight:(unsigned int)height;\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassMTLFrameBufferObject.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"GlassMTLFrameBufferObject.h\"\n+\n+\/\/#define VERBOSE\n+#ifndef VERBOSE\n+    #define LOG(MSG, ...)\n+#else\n+    #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);\n+#endif\n+\n+@implementation GlassMTLFrameBufferObject\n+\n+- (void)_destroyFbo\n+{\n+    if (self->_texture != nil)\n+    {\n+        LOG(\"GlassMTLFrameBufferObject releasing FBO :%lu\", self->_texture);\n+        [self->_texture release];\n+        self->_texture = nil;\n+    }\n+}\n+\n+- (void)_createFboIfNeededForWidth:(unsigned int)width\n+                         andHeight:(unsigned int)height\n+{\n+    if ((self->_width != width) || (self->_height != height))\n+    {\n+        \/\/ TODO optimization: is it possible to just resize an FBO's texture without destroying it first?\n+        [self _destroyFbo];\n+    }\n+\n+    if (self->_texture == nil) {\n+        @autoreleasepool {\n+            \/\/ Create a texture\n+            id<MTLDevice> device = MTLCreateSystemDefaultDevice();\n+\n+            MTLTextureDescriptor *texDescriptor =\n+                    [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm\n+                                                                       width:width\n+                                                                      height:height\n+                                                                   mipmapped:false];\n+            texDescriptor.storageMode = MTLStorageModeManaged;\n+            texDescriptor.usage = MTLTextureUsageRenderTarget;\n+\n+            self->_texture = [device newTextureWithDescriptor:texDescriptor];\n+        }\n+    }\n+\n+    self->_width = width;\n+    self->_height = height;\n+}\n+\n+- (id)init\n+{\n+    self = [super init];\n+    if (self != nil)\n+    {\n+        self->_width = 0;\n+        self->_height = 0;\n+        self->_texture = nil;\n+        self->_isSwPipe = NO;\n+    }\n+    return self;\n+}\n+\n+- (void)dealloc\n+{\n+    [self _destroyFbo];\n+    [super dealloc];\n+}\n+\n+- (unsigned int)width\n+{\n+    return self->_width;\n+}\n+\n+- (unsigned int)height\n+{\n+    return self->_height;\n+}\n+\n+- (void)bindForWidth:(unsigned int)width\n+           andHeight:(unsigned int)height\n+{\n+    LOG(\"           GlassMTLFrameBufferObject bindForWidth:%d andHeight:%d\", width, height);\n+    {\n+        if ((width > 0) && (height > 0))\n+        {\n+            if(self->_isSwPipe)\n+            {\n+                \/\/ self->_fboToRestore = 0; \/\/ default to screen\n+                \/\/ glGetIntegerv(GL_FRAMEBUFFER_BINDING_EXT, (GLint*)&self->_fboToRestore);\n+                \/\/ LOG(\"               will need to restore to FBO: %d\", self->_fboToRestore);\n+            }\n+\n+            [self _createFboIfNeededForWidth:width andHeight:height];\n+        }\n+    }\n+}\n+\n+- (void)blitForWidth:(unsigned int)width\n+           andHeight:(unsigned int)height\n+{\n+    \/\/ TODO: MTL: check if implementation required\n+}\n+\n+- (void)blitFromFBO:(GlassMTLFrameBufferObject*)other_fbo\n+{\n+    [self _createFboIfNeededForWidth:other_fbo->_width andHeight:other_fbo->_height];\n+}\n+\n+- (id<MTLTexture>)texture\n+{\n+    return self->_texture;\n+}\n+\n+- (void)setIsSwPipe:(BOOL)isSwPipe\n+{\n+    self->_isSwPipe = isSwPipe;\n+}\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassMTLFrameBufferObject.m","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import <Metal\/Metal.h>\n+#import <QuartzCore\/CAMetalLayer.h>\n+\n+#import \"GlassOffscreen.h\"\n+#import \"GlassMTLFrameBufferObject.h\"\n+\n+@interface GlassMTLOffscreen : GlassOffscreen\n+{\n+    GlassMTLFrameBufferObject* _fbo;\n+    id<MTLDevice> mtlDevice;\n+    id<MTLCommandQueue> offScreenCommandQueue;\n+}\n+\n+- (id)initWithContext:(id<MTLDevice>)device\n+         commandQueue:(id<MTLCommandQueue>)commandQueue\n+          andIsSwPipe:(BOOL)isSwPipe;\n+\n+- (id<MTLTexture>)getMTLTexture;\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassMTLOffscreen.h","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"GlassMTLOffscreen.h\"\n+\n+\/\/#define VERBOSE\n+#ifndef VERBOSE\n+    #define LOG(MSG, ...)\n+#else\n+    #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);\n+#endif\n+\n+@implementation GlassMTLOffscreen\n+\n+static NSArray *allModes = nil;\n+\n+- (id)initWithContext:(id<MTLDevice>)device\n+         commandQueue:(id<MTLCommandQueue>)commandQueue\n+          andIsSwPipe:(BOOL)isSwPipe\n+{\n+    self = [super init];\n+    if (self != nil)\n+    {\n+        self->_fbo = [[GlassMTLFrameBufferObject alloc] init];\n+        \/\/ if (self->_fbo == nil)\n+        \/\/ {\n+        \/\/     TODO: implement PBuffer if needed\n+        \/\/     self->_fbo = [[GlassPBuffer alloc] init];\n+        \/\/ }\n+        [(GlassMTLFrameBufferObject*)self->_fbo setIsSwPipe:(BOOL)isSwPipe];\n+        if (allModes == nil) {\n+            allModes = [[NSArray arrayWithObjects:NSDefaultRunLoopMode,\n+                                              NSEventTrackingRunLoopMode,\n+                                              NSModalPanelRunLoopMode, nil] retain];\n+        }\n+        self->offScreenCommandQueue = commandQueue;\n+        self->mtlDevice = device;\n+    }\n+    return self;\n+}\n+\n+- (void)dealloc\n+{\n+    if (self->_fbo != nil) {\n+        [(NSObject*)self->_fbo release];\n+        self->_fbo = nil;\n+        [super dealloc];\n+    }\n+}\n+\n+- (unsigned int)width\n+{\n+    return [self->_fbo width];\n+}\n+\n+- (unsigned int)height\n+{\n+    return [self->_fbo height];\n+}\n+\n+- (void)unbind\n+{\n+    \/\/ no-op in case of MTL\n+}\n+\n+- (jlong)fbo\n+{\n+    \/\/ NSLog(@\"Glass fbo = %@\", [self->_fbo texture]);\n+    return ptr_to_jlong((void *)[self->_fbo texture]);\n+}\n+\n+- (void)bindForWidth:(unsigned int)width\n+           andHeight:(unsigned int)height\n+{\n+    \/\/ NSLog(@\"GlassMTLOffscreen -------- w x h : %d x %d\", width, height);\n+    [self->_fbo bindForWidth:width\n+                   andHeight:height];\n+    CGSize s = {width, height};\n+    [(CAMetalLayer*)[self getLayer] setDrawableSize:s];\n+}\n+\n+- (id<MTLTexture>)getMTLTexture\n+{\n+    return [self->_fbo texture];\n+}\n+\n+- (void)blitForWidth:(unsigned int)width\n+           andHeight:(unsigned int)height\n+{\n+    [self->_fbo blitForWidth:width\n+                   andHeight:height];\n+}\n+\n+- (void)flush:(GlassOffscreen*)glassOffScreen\n+{\n+    if ([NSThread isMainThread]) {\n+        [[self getLayer] setNeedsDisplay];\n+    } else {\n+        [[self getLayer] performSelectorOnMainThread:@selector(setNeedsDisplay)\n+                                          withObject:nil\n+                                       waitUntilDone:NO\n+                                               modes:allModes];\n+    }\n+}\n+\n+- (void)pushPixels:(void*)pixels\n+         withWidth:(unsigned int)width\n+        withHeight:(unsigned int)height\n+        withScaleX:(float)scalex\n+        withScaleY:(float)scaley\n+            ofView:(NSView*)view\n+{\n+    id<MTLTexture> backBufferTex = [self->_fbo texture];\n+\n+    if ((backBufferTex.width != width) ||\n+        (backBufferTex.height != height)) {\n+        return;\n+    }\n+\n+    @autoreleasepool {\n+        id<MTLCommandBuffer> commandBuf = [self->offScreenCommandQueue commandBuffer];\n+        if (commandBuf == nil) {\n+            return;\n+        }\n+\n+        id <MTLBlitCommandEncoder> blitEncoder = [commandBuf blitCommandEncoder];\n+\n+        id<MTLBuffer> buff = [[self->mtlDevice newBufferWithBytes:pixels\n+                                                           length:(width * height * 4)\n+                                                          options:0] autorelease];\n+        [blitEncoder copyFromBuffer:buff\n+                       sourceOffset:(NSUInteger)0\n+                  sourceBytesPerRow:(NSUInteger)width * 4\n+                sourceBytesPerImage:(NSUInteger)width * height * 4\n+                         sourceSize:MTLSizeMake(width, height, 1)\n+                          toTexture:backBufferTex\n+                   destinationSlice:(NSUInteger)0\n+                   destinationLevel:(NSUInteger)0\n+                  destinationOrigin:MTLOriginMake(0, 0, 0)];\n+\n+        if (backBufferTex.usage == MTLTextureUsageRenderTarget) {\n+            [blitEncoder synchronizeTexture:backBufferTex slice:0 level:0];\n+        }\n+        [blitEncoder endEncoding];\n+        [commandBuf commit];\n+        [commandBuf waitUntilCompleted];\n+    }\n+}\n+\n+- (unsigned char)isDirty\n+{\n+    \/\/ no-op in case of MTL\n+    return 0;\n+}\n+\n+- (void)blit\n+{\n+    [self blitForWidth:[self->_fbo width]\n+             andHeight:[self->_fbo height]];\n+}\n+\n+\/\/ TODO: MTL: This just creates another texture and doesn't do any blit\n+- (void)blitFromOffscreen:(GlassMTLOffscreen*)other_offscreen\n+{\n+    [(GlassMTLFrameBufferObject*)self->_fbo blitFromFBO:(GlassMTLFrameBufferObject*)other_offscreen->_fbo];\n+}\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassMTLOffscreen.m","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#import \"common.h\"\n@@ -28,20 +29,1 @@\n-#import <OpenGL\/gl.h>\n-#import <OpenGL\/OpenGL.h>\n-\n-@protocol GlassOffscreenProtocol\n-\n-\/\/ as destination (to draw into)\n-- (void)bindForWidth:(GLuint)width andHeight:(GLuint)height;\n-- (void)unbind;\n-\n-\/\/ as source (to show)\n-- (GLuint)texture;\n-- (void)blitForWidth:(GLuint)width andHeight:(GLuint)height;\n-\n-- (GLuint)width;\n-- (GLuint)height;\n-- (GLuint)fbo;\n-\n-@end\n-\n-@interface GlassOffscreen : NSObject <GlassOffscreenProtocol>\n+@interface GlassOffscreen : NSObject\n@@ -49,13 +31,5 @@\n-    CGLContextObj               _ctx;\n-    CGLContextObj               _ctxToRestore;\n-\n-    id<GlassOffscreenProtocol>  _offscreen;\n-\n-    GLboolean                   _dirty;\n-\n-    GLfloat                     _backgroundR;\n-    GLfloat                     _backgroundG;\n-    GLfloat                     _backgroundB;\n-    GLfloat                     _backgroundA;\n-\n-    CAOpenGLLayer*              _layer;\n+    float    _backgroundR;\n+    float    _backgroundG;\n+    float    _backgroundB;\n+    float    _backgroundA;\n+    CALayer* _layer;\n@@ -64,4 +38,0 @@\n-- (id)initWithContext:(CGLContextObj)ctx\n-            andIsSwPipe:(BOOL)isSwPipe;\n-- (CGLContextObj)getContext;\n-\n@@ -69,1 +39,6 @@\n-\n+- (jlong)fbo;\n+- (unsigned int)width;\n+- (unsigned int)height;\n+- (void)bindForWidth:(unsigned int)width\n+           andHeight:(unsigned int)height;\n+- (void)unbind;\n@@ -71,9 +46,13 @@\n-- (GLuint)texture;\n-\n-- (CAOpenGLLayer*)getLayer;\n-- (void)setLayer:(CAOpenGLLayer*)new_layer;\n-\n-- (GLboolean)isDirty;\n-\n-- (void)blitFromOffscreen:(GlassOffscreen*) other_offscreen;\n-\n+- (void)blitForWidth:(unsigned int)width\n+           andHeight:(unsigned int)height;\n+- (unsigned char)isDirty;\n+- (void)blitFromOffscreen:(GlassOffscreen*)other_offscreen;\n+- (void)flush:(GlassOffscreen*)glassOffScreen;\n+- (void)pushPixels:(void*)pixels\n+         withWidth:(unsigned int)width\n+        withHeight:(unsigned int)height\n+        withScaleX:(float)scalex\n+        withScaleY:(float)scaley\n+            ofView:(NSView*)view;\n+- (CALayer*)getLayer;\n+- (void)setLayer:(CALayer*)new_layer;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassOffscreen.h","additions":27,"deletions":48,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-#import \"GlassFrameBufferObject.h\"\n-\/\/#import \"GlassPBuffer.h\"\n-\n@@ -38,5 +35,0 @@\n-@interface GlassOffscreen ()\n-- (void)setContext;\n-- (void)unsetContext;\n-@end\n-\n@@ -45,2 +37,1 @@\n-- (id)initWithContext:(CGLContextObj)ctx\n-            andIsSwPipe:(BOOL)isSwPipe;\n+- (id)init\n@@ -51,2 +42,0 @@\n-        self->_ctx = CGLRetainContext(ctx);\n-\n@@ -57,12 +46,0 @@\n-\n-        [self setContext];\n-        {\n-            self->_offscreen = [[GlassFrameBufferObject alloc] init];\n-            if (self->_offscreen == nil)\n-            {\n-                \/\/ TODO: implement PBuffer if needed\n-                \/\/self->_offscreen = [[GlassPBuffer alloc] init];\n-            }\n-            [(GlassFrameBufferObject*)self->_offscreen setIsSwPipe:(BOOL)isSwPipe];\n-        }\n-        [self unsetContext];\n@@ -73,5 +50,0 @@\n-- (CGLContextObj)getContext;\n-{\n-    return self->_ctx;\n-}\n-\n@@ -80,10 +52,0 @@\n-    [self setContext];\n-    {\n-        [(NSObject*)self->_offscreen release];\n-        self->_offscreen = NULL;\n-    }\n-    [self unsetContext];\n-\n-    CGLReleaseContext(self->_ctx);\n-    self->_ctx = NULL;\n-\n@@ -95,4 +57,4 @@\n-    self->_backgroundR = (GLfloat)[color redComponent];\n-    self->_backgroundG = (GLfloat)[color greenComponent];\n-    self->_backgroundB = (GLfloat)[color blueComponent];\n-    self->_backgroundA = (GLfloat)[color alphaComponent];\n+    self->_backgroundR = (float)[color redComponent];\n+    self->_backgroundG = (float)[color greenComponent];\n+    self->_backgroundB = (float)[color blueComponent];\n+    self->_backgroundA = (float)[color alphaComponent];\n@@ -101,1 +63,1 @@\n-- (GLuint)width\n+- (unsigned int)width\n@@ -103,1 +65,1 @@\n-    return [self->_offscreen width];\n+    return 0;\n@@ -106,1 +68,1 @@\n-- (GLuint)height\n+- (unsigned int)height\n@@ -108,1 +70,1 @@\n-    return [self->_offscreen height];\n+    return 0;\n@@ -111,1 +73,1 @@\n-- (GLuint)fbo\n+- (jlong)fbo\n@@ -113,6 +75,1 @@\n-    return [self->_offscreen fbo];\n-}\n-\n-- (CAOpenGLLayer*)getLayer\n-{\n-    return _layer;\n+    return 0;\n@@ -121,1 +78,2 @@\n-- (void)setLayer:(CAOpenGLLayer*)new_layer\n+- (void)bindForWidth:(unsigned int)width\n+           andHeight:(unsigned int)height\n@@ -123,2 +81,0 @@\n-    \/\/Set a weak reference as layer owns offscreen\n-    self->_layer = new_layer;\n@@ -127,1 +83,1 @@\n-- (void)setContext\n+- (void)unbind\n@@ -129,3 +85,0 @@\n-    self->_ctxToRestore = CGLGetCurrentContext();\n-    CGLLockContext(self->_ctx);\n-    CGLSetCurrentContext(self->_ctx);\n@@ -134,1 +87,1 @@\n-- (void)unsetContext\n+- (void)flush:(GlassOffscreen*)glassOffScreen\n@@ -136,2 +89,0 @@\n-    CGLSetCurrentContext(self->_ctxToRestore);\n-    CGLUnlockContext(self->_ctx);\n@@ -140,1 +91,6 @@\n-- (void)bindForWidth:(GLuint)width andHeight:(GLuint)height\n+- (void)pushPixels:(void*)pixels\n+         withWidth:(unsigned int)width\n+        withHeight:(unsigned int)height\n+        withScaleX:(float)scalex\n+        withScaleY:(float)scaley\n+            ofView:(NSView*)view\n@@ -142,2 +98,0 @@\n-    [self setContext];\n-    [self->_offscreen bindForWidth:width andHeight:height];\n@@ -146,1 +100,1 @@\n-- (void)unbind\n+- (void)blit\n@@ -148,2 +102,0 @@\n-    [self->_offscreen unbind];\n-    [self unsetContext];\n@@ -152,1 +104,2 @@\n-- (void)blit\n+- (void)blitForWidth:(unsigned int)width\n+           andHeight:(unsigned int)height\n@@ -154,1 +107,0 @@\n-    [self blitForWidth:[self->_offscreen width] andHeight:[self->_offscreen height]];\n@@ -157,1 +109,1 @@\n-- (GLuint)texture\n+- (unsigned char)isDirty\n@@ -159,1 +111,1 @@\n-    return [self->_offscreen texture];\n+    return 0;\n@@ -162,1 +114,1 @@\n-- (void)blitForWidth:(GLuint)width andHeight:(GLuint)height\n+- (void)blitFromOffscreen:(GlassOffscreen*)other_offscreen\n@@ -164,31 +116,0 @@\n-    {\n-#if 1\n-        glClearColor(self->_backgroundR, self->_backgroundG, self->_backgroundB, self->_backgroundA);\n-        glClear(GL_COLOR_BUFFER_BIT);\n-#else\n-        \/\/ for debugging, change clear color every 0.5 seconds\n-        static int counterFps = 0;\n-        static int counterColor = 0;\n-        counterFps++;\n-        if ((counterFps%(60\/2)) == 0)\n-        {\n-            counterColor++;\n-        }\n-        switch (counterColor%3)\n-        {\n-            case 0:\n-                glClearColor(1.0f, 0.0f, 0.0f, 1.0f);\n-                break;\n-            case 1:\n-                glClearColor(0.0f, 1.0f, 0.0f, 1.0f);\n-                break;\n-            case 2:\n-                glClearColor(0.0f, 0.0f, 1.0f, 1.0f);\n-                break;\n-        }\n-        glClear(GL_COLOR_BUFFER_BIT);\n-#endif\n-        [self->_offscreen blitForWidth:width andHeight:height];\n-\n-        self->_dirty = GL_FALSE;\n-    }\n@@ -197,1 +118,1 @@\n-- (GLboolean)isDirty\n+- (CALayer*)getLayer\n@@ -199,1 +120,1 @@\n-    return self->_dirty;\n+    return _layer;\n@@ -202,1 +123,1 @@\n-- (void)blitFromOffscreen:(GlassOffscreen*) other_offscreen\n+- (void)setLayer:(CALayer*)new_layer\n@@ -204,6 +125,2 @@\n-    [self setContext];\n-    {\n-        [(GlassFrameBufferObject*)self->_offscreen blitFromFBO:(GlassFrameBufferObject*)other_offscreen->_offscreen];\n-        self->_dirty = GL_TRUE;\n-    }\n-    [self unsetContext];\n+    \/\/Set a weak reference as layer owns offscreen\n+    self->_layer = new_layer;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassOffscreen.m","additions":33,"deletions":116,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-#import \"GlassLayer3D.h\"\n@@ -46,1 +45,1 @@\n-static inline NSView<GlassView>* getGlassView(JNIEnv *env, jlong jPtr)\n+static inline GlassView3D<GlassView>* getGlassView(JNIEnv *env, jlong jPtr)\n@@ -50,1 +49,1 @@\n-    return (NSView<GlassView>*)jlong_to_ptr(jPtr);\n+    return (GlassView3D<GlassView>*)jlong_to_ptr(jPtr);\n@@ -297,0 +296,2 @@\n+        \/\/NSLog(@\"--- hostView bounds = (%f, %f) - (%f, %f)\", [hostView bounds].origin.x, [hostView bounds].origin.y, [hostView bounds].size.width, [hostView bounds].size.height);\n+\n@@ -325,1 +326,1 @@\n-JNIEXPORT jint JNICALL Java_com_sun_glass_ui_mac_MacView__1getNativeFrameBuffer\n+JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_mac_MacView__1getNativeFrameBuffer\n@@ -332,1 +333,1 @@\n-    jint fb = 0;\n+    jlong fb = 0;\n@@ -337,3 +338,3 @@\n-        NSView<GlassView> *view = getGlassView(env, jPtr);\n-        GlassLayer3D *layer = (GlassLayer3D*)[view layer];\n-        fb = (jint) [[layer getPainterOffscreen] fbo];\n+        GlassView3D<GlassView> *view = getGlassView(env, jPtr);\n+        GlassLayer *layer = (GlassLayer*)[view getLayer];\n+        fb = (jlong) [[layer getPainterOffscreen] fbo];\n@@ -347,26 +348,0 @@\n-\/*\n- * Class:     com_sun_glass_ui_mac_MacView\n- * Method:    _getNativeLayer\n- * Signature: (J)J\n- *\/\n-JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_mac_MacView__1getNativeLayer\n-(JNIEnv *env, jobject jView, jlong jPtr)\n-{\n-    LOG(\"Java_com_sun_glass_ui_mac_MacView__1_getNativeLayer\");\n-    LOG(\"   view: %p\", jPtr);\n-    if (!jPtr) return 0L;\n-\n-    jlong ptr = 0L;\n-\n-    GLASS_ASSERT_MAIN_JAVA_THREAD(env);\n-    GLASS_POOL_ENTER;\n-    {\n-        NSView<GlassView> *view = getGlassView(env, jPtr);\n-        ptr = ptr_to_jlong([view layer]);\n-    }\n-    GLASS_POOL_EXIT;\n-    GLASS_CHECK_EXCEPTION(env);\n-\n-    return ptr;\n-}\n-\n@@ -609,1 +584,1 @@\n-        [view pushPixels:pixels withWidth:(GLuint)jWidth withHeight:(GLuint)jHeight withScaleX:(GLfloat)jScaleX withScaleY:(GLfloat)jScaleY withEnv:env];\n+        [view pushPixels:pixels withWidth:(unsigned int)jWidth withHeight:(unsigned int)jHeight withScaleX:(float)jScaleX withScaleY:(float)jScaleY withEnv:env];\n@@ -647,1 +622,1 @@\n-        [view pushPixels:pixels withWidth:(GLuint)jWidth withHeight:(GLuint)jHeight withScaleX:(GLfloat)jScaleX withScaleY:(GLfloat)jScaleY withEnv:env];\n+        [view pushPixels:pixels withWidth:(unsigned int)jWidth withHeight:(unsigned int)jHeight withScaleX:(float)jScaleX withScaleY:(float)jScaleY withEnv:env];\n@@ -686,1 +661,1 @@\n-        [view pushPixels:pixels withWidth:(GLuint)jWidth withHeight:(GLuint)jHeight withScaleX:(GLfloat)jScaleX withScaleY:(GLfloat)jScaleY withEnv:env];\n+        [view pushPixels:pixels withWidth:(unsigned int)jWidth withHeight:(unsigned int)jHeight withScaleX:(float)jScaleX withScaleY:(float)jScaleY withEnv:env];\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassView.m","additions":13,"deletions":38,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -26,4 +26,0 @@\n-#import <Cocoa\/Cocoa.h>\n-#import <OpenGL\/gl.h>\n-#import <OpenGL\/OpenGL.h>\n-\n@@ -31,1 +27,1 @@\n-#import \"GlassOffscreen.h\"\n+#import \"GlassLayer.h\"\n@@ -33,2 +29,3 @@\n-\/\/ 3D version of Glass providing OpenGL context through CAOpenGLLayer\n-@interface GlassView3D : NSOpenGLView <GlassView, NSTextInputClient>\n+\/\/ GlassView3D is subView of GlassHostView and it performs event\n+\/\/ handling tasks related to both OpenGL and Metal pipeline\n+@interface GlassView3D : NSView <GlassView, NSTextInputClient>\n@@ -37,3 +34,0 @@\n-\n-    NSUInteger          _drawCounter; \/\/ draw counter, so that we only bind\/unbind offscreen once\n-\n@@ -41,0 +35,1 @@\n+    GlassLayer *layer;\n@@ -42,8 +37,1 @@\n-    GLuint              _texture;\n-    GLuint              _textureWidth;\n-    GLuint              _textureHeight;\n-\n-    CGFloat             _backgroundR;\n-    CGFloat             _backgroundG;\n-    CGFloat             _backgroundB;\n-    CGFloat             _backgroundA;\n+    NSView *subView;\n@@ -55,0 +43,1 @@\n+\n@@ -64,0 +53,1 @@\n+- (GlassViewDelegate*)delegate;\n@@ -66,0 +56,1 @@\n+- (CALayer*)getLayer;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassView3D.h","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-#import \"GlassLayer3D.h\"\n+#import \"GlassViewCGL.h\"\n+#import \"GlassViewMTL.h\"\n@@ -81,34 +82,1 @@\n-- (CGLPixelFormatObj)_createPixelFormatWithDepth:(CGLPixelFormatAttribute)depth\n-{\n-    CGLPixelFormatObj pix = NULL;\n-    {\n-        const CGLPixelFormatAttribute attributes[] =\n-        {\n-            kCGLPFAAccelerated,\n-            kCGLPFAColorSize, 32,\n-            kCGLPFAAlphaSize, 8,\n-            kCGLPFADepthSize, depth,\n-            kCGLPFAAllowOfflineRenderers, \/\/ lets OpenGL know this context is offline renderer aware\n-            (CGLPixelFormatAttribute)0\n-        };\n-        GLint npix = 0;\n-        CGLError err = CGLChoosePixelFormat(attributes, &pix, &npix);\n-        if (pix == NULL)\n-        {\n-            NSLog(@\"CGLChoosePixelFormat: No matching pixel format exists for the requested attributes, trying again with limited capabilities\");\n-            const CGLPixelFormatAttribute attributes2[] =\n-            {\n-                kCGLPFAAllowOfflineRenderers,\n-                (CGLPixelFormatAttribute)0\n-            };\n-            err = CGLChoosePixelFormat(attributes2, &pix, &npix);\n-        }\n-        if (err != kCGLNoError)\n-        {\n-            NSLog(@\"CGLChoosePixelFormat error: %d\", err);\n-        }\n-    }\n-    return pix;\n-}\n-\n-- (CGLContextObj)_createContextWithShared:(CGLContextObj)share withFormat:(CGLPixelFormatObj)format\n+- (id)initWithFrame:(NSRect)frame withJview:(jobject)jView withJproperties:(jobject)jproperties\n@@ -116,10 +84,1 @@\n-    CGLContextObj ctx = NULL;\n-    {\n-        CGLError err = CGLCreateContext(format, share, &ctx);\n-        if (err != kCGLNoError)\n-        {\n-            NSLog(@\"CGLCreateContext error: %d\", err);\n-        }\n-    }\n-    return ctx;\n-}\n+    LOG(\"GlassView3D initWithFrame:withJview:withJproperties\");\n@@ -127,2 +86,0 @@\n-- (void)_initialize3dWithJproperties:(jobject)jproperties\n-{\n@@ -130,2 +87,1 @@\n-\n-    int depthBits = 0;\n+    long mtlCommandQueuePtr = 0l;\n@@ -134,1 +90,4 @@\n-        jobject k3dDepthKey = (*env)->NewObject(env, jIntegerClass, jIntegerInitMethod, com_sun_glass_ui_View_Capability_k3dDepthKeyValue);\n+        jobject mtlCommandQueueKey = (*env)->NewStringUTF(env, \"mtlCommandQueue\");\n+        jobject mtlCommandQueueValue = (*env)->CallObjectMethod(env, jproperties, jMapGetMethod, mtlCommandQueueKey);\n+        \/\/ NSLog(@\"---- mtlCommandQueueKey = %p\", mtlCommandQueueKey);\n+        \/\/ NSLog(@\"---- mtlCommandQueueValue = %p\", mtlCommandQueueValue);\n@@ -136,3 +95,1 @@\n-        jobject k3dDepthKeyValue = (*env)->CallObjectMethod(env, jproperties, jMapGetMethod, k3dDepthKey);\n-        GLASS_CHECK_EXCEPTION(env);\n-        if (k3dDepthKeyValue != NULL)\n+        if (mtlCommandQueueValue != NULL)\n@@ -140,1 +97,1 @@\n-            depthBits = (*env)->CallIntMethod(env, k3dDepthKeyValue, jIntegerValueMethod);\n+            jlong jmtlQueuePtr = (*env)->CallLongMethod(env, mtlCommandQueueValue, jLongValueMethod);\n@@ -142,14 +99,1 @@\n-        }\n-    }\n-\n-    CGLContextObj sharedCGL = NULL;\n-    if (jproperties != NULL)\n-    {\n-        jobject sharedContextPtrKey = (*env)->NewStringUTF(env, \"shareContextPtr\");\n-        jobject sharedContextPtrValue = (*env)->CallObjectMethod(env, jproperties, jMapGetMethod, sharedContextPtrKey);\n-        GLASS_CHECK_EXCEPTION(env);\n-        if (sharedContextPtrValue != NULL)\n-        {\n-            jlong jsharedContextPtr = (*env)->CallLongMethod(env, sharedContextPtrValue, jLongValueMethod);\n-            GLASS_CHECK_EXCEPTION(env);\n-            if (jsharedContextPtr != 0)\n+            if (jmtlQueuePtr != 0)\n@@ -157,5 +101,1 @@\n-                NSOpenGLContext *sharedContextNS = (NSOpenGLContext*)jlong_to_ptr(jsharedContextPtr);\n-                sharedCGL = [sharedContextNS CGLContextObj];\n-            }\n-        }\n-    }\n+                \/\/ NSLog(@\"--- GLASS metal command queue ptr = %ld\", jmtlQueuePtr);\n@@ -163,16 +103,3 @@\n-    CGLContextObj clientCGL = NULL;\n-    BOOL isSwPipe = NO;\n-\n-    if (jproperties != NULL)\n-    {\n-        jobject contextPtrKey = (*env)->NewStringUTF(env, \"contextPtr\");\n-        jobject contextPtrValue = (*env)->CallObjectMethod(env, jproperties, jMapGetMethod, contextPtrKey);\n-        GLASS_CHECK_EXCEPTION(env);\n-        if (contextPtrValue != NULL)\n-        {\n-            jlong jcontextPtr = (*env)->CallLongMethod(env, contextPtrValue, jLongValueMethod);\n-            GLASS_CHECK_EXCEPTION(env);\n-            if (jcontextPtr != 0)\n-            {\n-                NSOpenGLContext *clientContextNS = (NSOpenGLContext*)jlong_to_ptr(jcontextPtr);\n-                clientCGL = [clientContextNS CGLContextObj];\n+                \/\/ This enables sharing of MTLCommandQueue between PRISM and GLASS, if needed.\n+                \/\/ Note : Currently, PRISM and GLASS create their own dedicated MTLCommandQueue\n+                mtlCommandQueuePtr = jmtlQueuePtr;\n@@ -182,11 +109,0 @@\n-    if (clientCGL == NULL)\n-    {\n-        CGLPixelFormatObj clientPixelFormat = [self _createPixelFormatWithDepth:(CGLPixelFormatAttribute)depthBits];\n-        clientCGL = [self _createContextWithShared:sharedCGL withFormat:clientPixelFormat];\n-    }\n-    if (sharedCGL == NULL)\n-    {\n-        \/\/ this can happen in Rain or clients other than Prism (ie. device details do not have the shared context set)\n-        sharedCGL = clientCGL;\n-        isSwPipe = YES;\n-    }\n@@ -194,0 +110,2 @@\n+    \/\/ TODO : We again fetch isHiDPIAware in GlassViewCGL\n+    \/\/ Try to merge it\n@@ -208,30 +126,14 @@\n-    GlassLayer3D *layer = [[GlassLayer3D alloc] initWithSharedContext:sharedCGL andClientContext:clientCGL withHiDPIAware:self->isHiDPIAware withIsSwPipe:isSwPipe];\n-\n-    \/\/ https:\/\/developer.apple.com\/library\/mac\/documentation\/Cocoa\/Reference\/ApplicationKit\/Classes\/nsview_Class\/Reference\/NSView.html#\/\/apple_ref\/occ\/instm\/NSView\/setWantsLayer:\n-    \/\/ the order of the following 2 calls is important: here we indicate we want a layer-hosting view\n-    {\n-        [self setLayer:layer];\n-        [self setWantsLayer:YES];\n-    }\n-}\n-\n-- (id)initWithFrame:(NSRect)frame withJview:(jobject)jView withJproperties:(jobject)jproperties\n-{\n-    LOG(\"GlassView3D initWithFrame:withJview:withJproperties\");\n-\n-    NSOpenGLPixelFormatAttribute pixelFormatAttributes[] =\n-    {\n-        NSOpenGLPFAAllowOfflineRenderers, \/\/ Lets OpenGL know this context is offline renderer aware\n-        (NSOpenGLPixelFormatAttribute)0\n-    };\n-    NSOpenGLPixelFormat *pFormat = [[[NSOpenGLPixelFormat alloc] initWithAttributes:pixelFormatAttributes] autorelease];\n-    if (!pFormat)\n-    {\n-        pFormat = [NSOpenGLView defaultPixelFormat];\n-        LOG(\"GlassView3D initWithFrame: initWithAttributes failed! Set pixel format to default pixel format\");\n-    }\n-    self = [super initWithFrame:frame pixelFormat:pFormat];\n-    if (self != nil)\n-    {\n-        [self _initialize3dWithJproperties:jproperties];\n-\n+    self = [super initWithFrame:frame];\n+    if (self != nil) {\n+        if (mtlCommandQueuePtr != 0l) {\n+            GlassViewMTL* mtlSubView;\n+            subView = mtlSubView = [[GlassViewMTL alloc] initWithFrame:frame withJview:jView withJproperties:jproperties];\n+            self->layer = [mtlSubView getLayer];\n+            self->isHiDPIAware = YES;\n+        } else {\n+            GlassViewCGL* cglSubView;\n+            subView = cglSubView = [[GlassViewCGL alloc] initWithFrame:frame withJview:jView withJproperties:jproperties];\n+            self->layer = [cglSubView getLayer];\n+        }\n+        [subView setAutoresizingMask:(NSViewWidthSizable|NSViewHeightSizable)];\n+        [self addSubview:subView];\n@@ -239,3 +141,0 @@\n-        self->_drawCounter = 0;\n-        self->_texture = 0;\n-\n@@ -250,1 +149,0 @@\n-\n@@ -257,0 +155,1 @@\n+    \/\/self->_delegate = [[GlassViewDelegate alloc] initWithView:view withJview:jView];\n@@ -262,14 +161,0 @@\n-    if (self->_texture != 0)\n-    {\n-        GlassLayer3D *layer = (GlassLayer3D*)[self layer];\n-        [[layer getPainterOffscreen] bindForWidth:(GLuint)[self bounds].size.width andHeight:(GLuint)[self bounds].size.height];\n-        {\n-            glDeleteTextures(1, &self->_texture);\n-        }\n-        [[layer getPainterOffscreen] unbind];\n-    }\n-\n-    [[self layer] release];\n-    [self->_delegate release];\n-    self->_delegate = nil;\n-\n@@ -279,1 +164,2 @@\n-\n+    [self->_delegate release];\n+    self->_delegate = nil;\n@@ -282,1 +168,0 @@\n-\n@@ -285,1 +170,0 @@\n-\n@@ -337,6 +221,1 @@\n-    if ([self window] != nil)\n-    {\n-        GlassLayer3D *layer = (GlassLayer3D*)[self layer];\n-        [[layer getPainterOffscreen] setBackgroundColor:[[[self window] backgroundColor] colorUsingColorSpace:NSColorSpace.sRGBColorSpace]];\n-    }\n-\n+    [subView viewDidMoveToWindow];\n@@ -633,0 +512,5 @@\n+- (void)drawRect:(NSRect)dirtyRect\n+{\n+    [self->_delegate drawRect:dirtyRect];\n+}\n+\n@@ -648,10 +532,3 @@\n-    assert(self->_drawCounter >= 0);\n-\n-    if (self->_drawCounter == 0)\n-    {\n-        GlassLayer3D *layer = (GlassLayer3D*)[self layer];\n-        NSRect bounds = (self->isHiDPIAware && [self respondsToSelector:@selector(convertRectToBacking:)]) ?\n-            [self convertRectToBacking:[self bounds]] : [self bounds];\n-        [[layer getPainterOffscreen] bindForWidth:(GLuint)bounds.size.width andHeight:(GLuint)bounds.size.height];\n-    }\n-    self->_drawCounter++;\n+    NSRect bounds = (self->isHiDPIAware && [subView respondsToSelector:@selector(convertRectToBacking:)]) ?\n+            [subView convertRectToBacking:[subView bounds]] : [subView bounds];\n+    [self->layer bindForWidth:bounds.size.width andHeight:bounds.size.height];\n@@ -662,10 +539,1 @@\n-    assert(self->_drawCounter > 0);\n-\n-    self->_drawCounter--;\n-    if (self->_drawCounter == 0)\n-    {\n-        GlassLayer3D *layer = (GlassLayer3D*)[self layer];\n-        [[layer getPainterOffscreen] unbind];\n-        [layer flush];\n-    }\n-    LOG(\"end\");\n+    [self->layer end];\n@@ -674,1 +542,1 @@\n-- (void)drawRect:(NSRect)dirtyRect\n+- (void)pushPixels:(void*)pixels withWidth:(unsigned int)width withHeight:(unsigned int)height withScaleX:(float)scalex withScaleY:(float)scaley withEnv:(JNIEnv *)env\n@@ -676,86 +544,1 @@\n-    [self->_delegate drawRect:dirtyRect];\n-}\n-\n-- (void)pushPixels:(void*)pixels withWidth:(GLuint)width withHeight:(GLuint)height withScaleX:(GLfloat)scalex withScaleY:(GLfloat)scaley withEnv:(JNIEnv *)env\n-{\n-    assert(self->_drawCounter > 0);\n-\n-    if (self->_texture == 0)\n-    {\n-        glGenTextures(1, &self->_texture);\n-    }\n-\n-    BOOL uploaded = NO;\n-    if ((self->_textureWidth != width) || (self->_textureHeight != height))\n-    {\n-        uploaded = YES;\n-\n-        self->_textureWidth = width;\n-        self->_textureHeight = height;\n-\n-        \/\/ GL_EXT_texture_rectangle is defined in OS X 10.6 GL headers, so we can depend on GL_TEXTURE_RECTANGLE_EXT being available\n-        glBindTexture(GL_TEXTURE_RECTANGLE_EXT, self->_texture);\n-        glTexParameteri(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n-        glTexParameteri(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n-        glTexParameteri(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_WRAP_S, GL_CLAMP);\n-        glTexParameteri(GL_TEXTURE_RECTANGLE_EXT, GL_TEXTURE_WRAP_T, GL_CLAMP);\n-        glTexImage2D(GL_TEXTURE_RECTANGLE_EXT, 0, GL_RGBA8, (GLsizei)self->_textureWidth, (GLsizei)self->_textureHeight, 0, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, pixels);\n-    }\n-\n-    glEnable(GL_TEXTURE_RECTANGLE_EXT);\n-    glBindTexture(GL_TEXTURE_RECTANGLE_EXT, self->_texture);\n-    {\n-        if (uploaded == NO)\n-        {\n-            glTexSubImage2D(GL_TEXTURE_RECTANGLE_EXT, 0, 0, 0, (GLsizei)self->_textureWidth, (GLsizei)self->_textureHeight, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, pixels);\n-        }\n-\n-        GLfloat w = self->_textureWidth;\n-        GLfloat h = self->_textureHeight;\n-\n-        NSSize size = [self bounds].size;\n-        size.width *= scalex;\n-        size.height *= scaley;\n-        if ((size.width != w) || (size.height != h))\n-        {\n-            \/\/ This could happen on live resize, clear the FBO to avoid rendering garbage\n-            glClear(GL_COLOR_BUFFER_BIT);\n-        }\n-\n-        glMatrixMode(GL_PROJECTION);\n-        glPushMatrix();\n-        glLoadIdentity();\n-        glOrtho(0.0f, size.width, size.height, 0.0f, -1.0f, 1.0f);\n-        {\n-            glMatrixMode(GL_MODELVIEW);\n-            glPushMatrix();\n-            glLoadIdentity();\n-            {\n-                glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE); \/\/ copy\n-\n-                glBegin(GL_QUADS);\n-                {\n-                    glTexCoord2f(0.0f, 0.0f); glVertex2f(0.0f, 0.0f);\n-                    glTexCoord2f(   w, 0.0f); glVertex2f(   w, 0.0f);\n-                    glTexCoord2f(   w,    h); glVertex2f(   w,    h);\n-                    glTexCoord2f(0.0f,    h); glVertex2f(0.0f,    h);\n-                }\n-                glEnd();\n-            }\n-            glMatrixMode(GL_MODELVIEW);\n-            glPopMatrix();\n-        }\n-        glMatrixMode(GL_PROJECTION);\n-        glPopMatrix();\n-    }\n-    glBindTexture(GL_TEXTURE_RECTANGLE_EXT, 0);\n-    glDisable(GL_TEXTURE_RECTANGLE_EXT);\n-\n-    glFinish();\n-\n-    \/\/ The layer will be notified about redraw in _end()\n-}\n-\n-- (GlassViewDelegate*)delegate\n-{\n-    return self->_delegate;\n+    [self->layer pushPixels:pixels withWidth:width withHeight:height withScaleX:scalex withScaleY:scaley ofView:self];\n@@ -790,0 +573,5 @@\n+- (void)notifyScaleFactorChanged:(CGFloat)scale\n+{\n+    [self->layer notifyScaleFactorChanged:scale];\n+}\n+\n@@ -927,6 +715,0 @@\n-- (void)notifyScaleFactorChanged:(CGFloat)scale\n-{\n-    GlassLayer3D *layer = (GlassLayer3D*)[self layer];\n-    [layer notifyScaleFactorChanged:scale];\n-}\n-\n@@ -997,0 +779,9 @@\n+- (GlassLayer*)getLayer\n+{\n+    return self->layer;\n+}\n+\n+- (GlassViewDelegate*)delegate\n+{\n+    return self->_delegate;\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassView3D.m","additions":61,"deletions":270,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import <Cocoa\/Cocoa.h>\n+#import <OpenGL\/gl.h>\n+#import <OpenGL\/OpenGL.h>\n+\n+#import \"GlassView.h\"\n+#import \"GlassLayer.h\"\n+\n+\/\/ GlassViewCGL is not subclass of GlassView3D, it is a subView\n+\/\/ and it handles NSView's OpenGL specific drawing logic\n+@interface GlassViewCGL : NSOpenGLView\n+{\n+    GlassLayer* layer;\n+\n+    CGFloat _backgroundR;\n+    CGFloat _backgroundG;\n+    CGFloat _backgroundB;\n+    CGFloat _backgroundA;\n+}\n+\n+- (GlassLayer*)getLayer;\n+\n+- (id)initWithFrame:(NSRect)frame\n+          withJview:(jobject)jView\n+    withJproperties:(jobject)jproperties;\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassViewCGL.h","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"common.h\"\n+#import \"com_sun_glass_ui_View_Capability.h\"\n+#import \"GlassMacros.h\"\n+#import \"GlassViewCGL.h\"\n+\n+\/\/#define VERBOSE\n+#ifndef VERBOSE\n+    #define LOG(MSG, ...)\n+#else\n+    #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);\n+#endif\n+\n+\/\/ http:\/\/developer.apple.com\/library\/mac\/#technotes\/tn2085\/_index.html\n+\/\/ #define ENABLE_MULTITHREADED_GL\n+\n+@implementation GlassViewCGL\n+\n+- (CGLPixelFormatObj)_createPixelFormatWithDepth:(CGLPixelFormatAttribute)depth\n+{\n+    CGLPixelFormatObj pix = NULL;\n+    {\n+        const CGLPixelFormatAttribute attributes[] =\n+        {\n+            kCGLPFAAccelerated,\n+            kCGLPFAColorSize, 32,\n+            kCGLPFAAlphaSize, 8,\n+            kCGLPFADepthSize, depth,\n+            kCGLPFAAllowOfflineRenderers, \/\/ lets OpenGL know this context is offline renderer aware\n+            (CGLPixelFormatAttribute)0\n+        };\n+        GLint npix = 0;\n+        CGLError err = CGLChoosePixelFormat(attributes, &pix, &npix);\n+        if (pix == NULL)\n+        {\n+            NSLog(@\"CGLChoosePixelFormat: No matching pixel format exists for the requested attributes, trying again with limited capabilities\");\n+            const CGLPixelFormatAttribute attributes2[] =\n+            {\n+                kCGLPFAAllowOfflineRenderers,\n+                (CGLPixelFormatAttribute)0\n+            };\n+            err = CGLChoosePixelFormat(attributes2, &pix, &npix);\n+        }\n+        if (err != kCGLNoError)\n+        {\n+            NSLog(@\"CGLChoosePixelFormat error: %d\", err);\n+        }\n+    }\n+    return pix;\n+}\n+\n+- (CGLContextObj)_createContextWithShared:(CGLContextObj)share\n+                               withFormat:(CGLPixelFormatObj)format\n+{\n+    CGLContextObj ctx = NULL;\n+    {\n+        CGLError err = CGLCreateContext(format, share, &ctx);\n+        if (err != kCGLNoError)\n+        {\n+            NSLog(@\"CGLCreateContext error: %d\", err);\n+        }\n+    }\n+    return ctx;\n+}\n+\n+- (void)_initialize3dWithJproperties:(jobject)jproperties\n+{\n+    GET_MAIN_JENV;\n+\n+    int depthBits = 0;\n+    if (jproperties != NULL)\n+    {\n+        jobject k3dDepthKey = (*env)->NewObject(env, jIntegerClass, jIntegerInitMethod, com_sun_glass_ui_View_Capability_k3dDepthKeyValue);\n+        GLASS_CHECK_EXCEPTION(env);\n+        jobject k3dDepthKeyValue = (*env)->CallObjectMethod(env, jproperties, jMapGetMethod, k3dDepthKey);\n+        GLASS_CHECK_EXCEPTION(env);\n+        if (k3dDepthKeyValue != NULL)\n+        {\n+            depthBits = (*env)->CallIntMethod(env, k3dDepthKeyValue, jIntegerValueMethod);\n+            GLASS_CHECK_EXCEPTION(env);\n+        }\n+    }\n+\n+    CGLContextObj sharedCGL = NULL;\n+    if (jproperties != NULL)\n+    {\n+        jobject sharedContextPtrKey = (*env)->NewStringUTF(env, \"shareContextPtr\");\n+        jobject sharedContextPtrValue = (*env)->CallObjectMethod(env, jproperties, jMapGetMethod, sharedContextPtrKey);\n+        GLASS_CHECK_EXCEPTION(env);\n+        if (sharedContextPtrValue != NULL)\n+        {\n+            jlong jsharedContextPtr = (*env)->CallLongMethod(env, sharedContextPtrValue, jLongValueMethod);\n+            GLASS_CHECK_EXCEPTION(env);\n+            if (jsharedContextPtr != 0)\n+            {\n+                NSOpenGLContext *sharedContextNS = (NSOpenGLContext*)jlong_to_ptr(jsharedContextPtr);\n+                sharedCGL = [sharedContextNS CGLContextObj];\n+            }\n+        }\n+    }\n+\n+    CGLContextObj clientCGL = NULL;\n+    BOOL isSwPipe = NO;\n+\n+    if (jproperties != NULL)\n+    {\n+        jobject contextPtrKey = (*env)->NewStringUTF(env, \"contextPtr\");\n+        jobject contextPtrValue = (*env)->CallObjectMethod(env, jproperties, jMapGetMethod, contextPtrKey);\n+        GLASS_CHECK_EXCEPTION(env);\n+        if (contextPtrValue != NULL)\n+        {\n+            jlong jcontextPtr = (*env)->CallLongMethod(env, contextPtrValue, jLongValueMethod);\n+            GLASS_CHECK_EXCEPTION(env);\n+            if (jcontextPtr != 0)\n+            {\n+                NSOpenGLContext *clientContextNS = (NSOpenGLContext*)jlong_to_ptr(jcontextPtr);\n+                clientCGL = [clientContextNS CGLContextObj];\n+            }\n+        }\n+    }\n+    if (clientCGL == NULL)\n+    {\n+        CGLPixelFormatObj clientPixelFormat = [self _createPixelFormatWithDepth:(CGLPixelFormatAttribute)depthBits];\n+        clientCGL = [self _createContextWithShared:sharedCGL\n+                                        withFormat:clientPixelFormat];\n+    }\n+    if (sharedCGL == NULL)\n+    {\n+        \/\/ this can happen in Rain or clients other than Prism (ie. device details do not have the shared context set)\n+        sharedCGL = clientCGL;\n+        isSwPipe = YES;\n+    }\n+\n+    BOOL isHiDPIAware = NO;\n+    if (jproperties != NULL)\n+    {\n+        jobject kHiDPIAwareKey = (*env)->NewObject(env, jIntegerClass, jIntegerInitMethod, com_sun_glass_ui_View_Capability_kHiDPIAwareKeyValue);\n+        GLASS_CHECK_EXCEPTION(env);\n+        jobject kHiDPIAwareValue = (*env)->CallObjectMethod(env, jproperties, jMapGetMethod, kHiDPIAwareKey);\n+        GLASS_CHECK_EXCEPTION(env);\n+        if (kHiDPIAwareValue != NULL)\n+        {\n+            isHiDPIAware = (*env)->CallBooleanMethod(env, kHiDPIAwareValue, jBooleanValueMethod) ? YES : NO;\n+            GLASS_CHECK_EXCEPTION(env);\n+        }\n+    }\n+\n+    self->layer = [[GlassLayer alloc] initGlassLayer:(NSObject*)sharedCGL\n+                                    andClientContext:(NSObject*)clientCGL\n+                                         mtlQueuePtr:0l\n+                                      withHiDPIAware:isHiDPIAware\n+                                        withIsSwPipe:isSwPipe];\n+    \/\/ https:\/\/developer.apple.com\/library\/mac\/documentation\/Cocoa\/Reference\/ApplicationKit\/Classes\/nsview_Class\/Reference\/NSView.html#\/\/apple_ref\/occ\/instm\/NSView\/setWantsLayer:\n+    \/\/ the order of the following 2 calls is important: here we indicate we want a layer-hosting view\n+    [self setLayer:self->layer];\n+    [self setWantsLayer:YES];\n+}\n+\n+- (id)initWithFrame:(NSRect)frame\n+          withJview:(jobject)jView\n+    withJproperties:(jobject)jproperties\n+{\n+    LOG(\"GlassViewCGL initWithFrame:withJview:withJproperties\");\n+\n+    NSOpenGLPixelFormatAttribute pixelFormatAttributes[] =\n+    {\n+        NSOpenGLPFAAllowOfflineRenderers, \/\/ Lets OpenGL know this context is offline renderer aware\n+        (NSOpenGLPixelFormatAttribute)0\n+    };\n+    NSOpenGLPixelFormat *pFormat = [[[NSOpenGLPixelFormat alloc] initWithAttributes:pixelFormatAttributes] autorelease];\n+    if (!pFormat)\n+    {\n+        pFormat = [NSOpenGLView defaultPixelFormat];\n+        LOG(\"GlassViewCGL initWithFrame: initWithAttributes failed! Set pixel format to default pixel format\");\n+    }\n+    self = [super initWithFrame:frame pixelFormat:pFormat];\n+    if (self != nil)\n+    {\n+        [self _initialize3dWithJproperties:jproperties];\n+    }\n+    return self;\n+}\n+\n+- (void)dealloc\n+{\n+    [self->layer release];\n+    [super dealloc];\n+}\n+\n+\/\/ also called when closing window, when [self window] == nil\n+- (void)viewDidMoveToWindow\n+{\n+    if ([self window] != nil)\n+    {\n+        [[self->layer getPainterOffscreen] setBackgroundColor:[[[self window] backgroundColor] colorUsingColorSpace:NSColorSpace.sRGBColorSpace]];\n+    }\n+}\n+\n+- (GlassLayer*)getLayer\n+{\n+    return self->layer;\n+}\n+\n+- (BOOL)acceptsFirstMouse:(NSEvent *)theEvent\n+{\n+    return YES;\n+}\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassViewCGL.m","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -26,1 +26,0 @@\n-#import <Cocoa\/Cocoa.h>\n@@ -30,1 +29,0 @@\n-#import \"GlassDragSource.h\"\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassViewDelegate.h","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"GlassDraggingSource.h\"\n@@ -39,1 +38,0 @@\n-#import \"GlassScreen.h\"\n@@ -42,2 +40,0 @@\n-#import \"GlassLayer3D.h\"\n-#import \"GlassPasteboard.h\"\n@@ -45,1 +41,0 @@\n-#import \"GlassStatics.h\"\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassViewDelegate.m","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"GlassLayer.h\"\n+\n+\/\/ GlassViewMTL is not subclass of GlassView3D, it is a subView\n+\/\/ and it handles NSView's Metal specific drawing logic\n+@interface GlassViewMTL : NSView\n+{\n+    GlassLayer* layer;\n+}\n+\n+- (GlassLayer*)getLayer;\n+- (id)initWithFrame:(NSRect)frame\n+          withJview:(jobject)jView\n+    withJproperties:(jobject)jproperties;\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassViewMTL.h","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"com_sun_glass_ui_View_Capability.h\"\n+#import \"GlassMacros.h\"\n+#import \"GlassViewMTL.h\"\n+\n+\/\/#define VERBOSE\n+#ifndef VERBOSE\n+    #define LOG(MSG, ...)\n+#else\n+    #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);\n+#endif\n+\n+@implementation GlassViewMTL\n+\n+- (void)_initialize3dWithJproperties:(jobject)jproperties\n+{\n+    GET_MAIN_JENV;\n+    long mtlCommandQueuePtr = 0l;\n+\n+    int depthBits = 0;\n+    if (jproperties != NULL)\n+    {\n+        jobject k3dDepthKey = (*env)->NewObject(env, jIntegerClass, jIntegerInitMethod, com_sun_glass_ui_View_Capability_k3dDepthKeyValue);\n+        GLASS_CHECK_EXCEPTION(env);\n+        jobject k3dDepthKeyValue = (*env)->CallObjectMethod(env, jproperties, jMapGetMethod, k3dDepthKey);\n+        GLASS_CHECK_EXCEPTION(env);\n+        if (k3dDepthKeyValue != NULL)\n+        {\n+            depthBits = (*env)->CallIntMethod(env, k3dDepthKeyValue, jIntegerValueMethod);\n+            GLASS_CHECK_EXCEPTION(env);\n+        }\n+    }\n+\n+    BOOL isSwPipe = NO;\n+\n+    if (jproperties != NULL)\n+    {\n+        jobject mtlCommandQueueKey = (*env)->NewStringUTF(env, \"mtlCommandQueue\");\n+        jobject mtlCommandQueueValue = (*env)->CallObjectMethod(env, jproperties, jMapGetMethod, mtlCommandQueueKey);\n+        \/\/NSLog(@\"---- mtlCommandQueueKey = %p\", mtlCommandQueueKey);\n+        \/\/NSLog(@\"---- mtlCommandQueueValue = %p\", mtlCommandQueueValue);\n+        GLASS_CHECK_EXCEPTION(env);\n+        if (mtlCommandQueueValue != NULL)\n+        {\n+            jlong jmtlQueuePtr = (*env)->CallLongMethod(env, mtlCommandQueueValue, jLongValueMethod);\n+            GLASS_CHECK_EXCEPTION(env);\n+            if (jmtlQueuePtr != 0)\n+            {\n+                \/\/NSLog(@\"--- GLASS metal command queue ptr = %ld\", jmtlQueuePtr);\n+\n+                \/\/TODO: MTL: This enables sharing of MTLCommandQueue between PRISM and GLASS, if needed.\n+                \/\/Note : Currently, PRISM and GLASS create their own dedicated MTLCommandQueue\n+                mtlCommandQueuePtr = jmtlQueuePtr;\n+            }\n+        }\n+    }\n+\n+    if (mtlCommandQueuePtr == 0l) {\n+        LOG(\"GlassViewMTL _initialize3dWithJproperties : using software pipeline\");\n+        isSwPipe = YES;\n+    }\n+\n+    self->layer = [[GlassLayer alloc] initGlassLayer:nil\n+        andClientContext:nil mtlQueuePtr:mtlCommandQueuePtr\n+        withHiDPIAware:YES withIsSwPipe:isSwPipe];\n+\n+    \/\/ https:\/\/developer.apple.com\/library\/mac\/documentation\/Cocoa\/Reference\/ApplicationKit\/Classes\/nsview_Class\/Reference\/NSView.html#\/\/apple_ref\/occ\/instm\/NSView\/setWantsLayer:\n+    \/\/ the order of the following 2 calls is important: here we indicate we want a layer-hosting view\n+    {\n+        [self setLayerContentsRedrawPolicy: NSViewLayerContentsRedrawOnSetNeedsDisplay];\n+        [self setLayer:self->layer];\n+        [self setWantsLayer:YES];\n+        \/\/[self setWantsUpdateLayer:YES];\n+    }\n+}\n+\n+- (BOOL) wantsUpdateLayer {\n+    return TRUE;\n+}\n+\n+- (id)initWithFrame:(NSRect)frame withJview:(jobject)jView withJproperties:(jobject)jproperties\n+{\n+    LOG(\"GlassViewMTL initWithFrame:withJview:withJproperties\");\n+\n+    self = [super initWithFrame: frame];\n+    if (self != nil)\n+    {\n+        [self _initialize3dWithJproperties:jproperties];\n+    }\n+    return self;\n+}\n+\n+- (void)dealloc\n+{\n+    [self->layer release];\n+\n+    [super dealloc];\n+}\n+\n+\/\/ also called when closing window, when [self window] == nil\n+- (void)viewDidMoveToWindow\n+{\n+    \/\/[self->_delegate viewDidMoveToWindow];\n+}\n+\n+- (GlassLayer*)getLayer\n+{\n+    return self->layer;\n+}\n+\n+- (BOOL)acceptsFirstMouse:(NSEvent *)theEvent\n+{\n+    return YES;\n+}\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassViewMTL.m","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+#import \"GlassView3D.h\"\n@@ -42,1 +43,1 @@\n-    NSView<GlassView>   *view;\n+    GlassView3D<GlassView>   *view;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#import \"GlassLayer3D.h\"\n@@ -96,1 +95,1 @@\n-static inline NSView<GlassView> *getMacView(JNIEnv *env, jobject jview)\n+static inline GlassView3D<GlassView> *getMacView(JNIEnv *env, jobject jview)\n@@ -102,1 +101,1 @@\n-        return (NSView<GlassView>*)jlong_to_ptr((*env)->GetLongField(env, jview, jfID));\n+        return (GlassView3D<GlassView>*)jlong_to_ptr((*env)->GetLongField(env, jview, jfID));\n@@ -839,2 +838,4 @@\n-            CALayer *layer = [window->view layer];\n-            if (([layer isKindOfClass:[CAOpenGLLayer class]] == YES) &&\n+            CALayer *layer = [window->view getLayer];\n+            LOG(\"   layer: %p\", layer);\n+            \/\/ TODO : Move below logic to CGL specific View\/Layer class\n+            if (([layer.sublayers[0] isKindOfClass:[CAOpenGLLayer class]] == YES) &&\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow.m","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef METAL_COMMON_H\n+#define METAL_COMMON_H\n+\n+#import <jni.h>\n+#import <simd\/simd.h>\n+#import <Metal\/Metal.h>\n+#import <Foundation\/Foundation.h>\n+\n+#define jlong_to_ptr(value) (intptr_t)value\n+#define ptr_to_jlong(value) (jlong)((intptr_t)value)\n+\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalCommon.h","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef METAL_CONTEXT_H\n+#define METAL_CONTEXT_H\n+\n+#import \"MetalCommon.h\"\n+#import \"MetalRingBuffer.h\"\n+\n+@class MetalRTTexture;\n+@class MetalPipelineManager;\n+@class MetalShader;\n+@class MetalMeshView;\n+\n+#define BUFFER_SIZE 1\n+#define ARGS_BUFFER_SIZE (8  * 1024 * 1024)\n+#define DATA_BUFFER_SIZE (20 * 1024 * 1024)\n+\n+#define MAX_NUM_QUADS   (4096) \/\/ refer MTLContext.NUM_QUADS\n+#define INDICES_PER_IB  (MAX_NUM_QUADS * 6) \/\/ (4096 * 6 * 2 ) = 48 kb IndexBuffer\n+#define VERTICES_PER_IB (MAX_NUM_QUADS * 4)\n+\n+typedef struct PrismSourceVertex {\n+    float x, y, z;\n+    float tu1, tv1;\n+    float tu2, tv2;\n+} PrismSourceVertex;\n+\n+typedef struct CLEAR_VS_INPUT {\n+    packed_float2 position;\n+} CLEAR_VS_INPUT;\n+\n+typedef enum VertexInputIndex {\n+    VertexInputIndexVertices = 0,\n+    VertexInputMatrixMVP     = 1,\n+    VertexInputClearColor    = 2,\n+    VertexInputColors        = 2\n+} VertexInputIndex;\n+\n+@interface MetalContext : NSObject\n+{\n+    simd_float4x4 mvpMatrix;\n+    simd_float4x4 worldMatrix;\n+\n+    \/\/ clear rtt\n+    CLEAR_VS_INPUT clearScissorRectVertices[4];\n+    id<MTLBuffer> clearEntireRttVerticesBuf;\n+    id<MTLBuffer> indexBuffer;\n+\n+    id<MTLDevice> device;\n+    id<MTLCommandQueue> commandQueue;\n+    id<MTLCommandBuffer> currentCommandBuffer;\n+    id<MTLRenderCommandEncoder> currentRenderEncoder;\n+    id<MTLRenderCommandEncoder> phongEncoder;\n+    id<MTLRenderCommandEncoder> lastPhongEncoder;\n+    MetalShader* currentShader;\n+    NSMutableDictionary* linearSamplerDict;\n+    NSMutableDictionary* nonLinearSamplerDict;\n+\n+    bool commitOnDraw;\n+    NSLock *ringBufferLock;\n+    volatile bool isWaitingForBuffer;\n+    dispatch_semaphore_t ringBufferSemaphore;\n+    unsigned int currentRingBufferIndex;\n+    MetalRingBuffer* argsRingBuffer;\n+    MetalRingBuffer* dataRingBuffer;\n+    NSMutableArray*  transientBuffersForCB;\n+    NSMutableSet*    shadersUsedInCB;\n+    NSUInteger meshIndexCount;\n+\n+    MTLScissorRect scissorRect;\n+    bool isScissorEnabled;\n+    MetalRTTexture* rtt;\n+    bool clearDepthTexture;\n+    float clearColor[4];\n+    MTLRenderPassDescriptor* rttPassDesc;\n+\n+    MetalPipelineManager* pipelineManager;\n+    MTLRenderPassDescriptor* phongRPD;\n+    vector_float4 cPos;\n+    bool depthEnabled;\n+    NSUInteger currentBufferIndex;\n+\n+    int compositeMode;\n+    int cullMode;\n+\n+    id<MTLBuffer> pixelBuffer;\n+}\n+\n+- (void) setCompositeMode:(int)mode;\n+- (int) getCompositeMode;\n+- (MetalPipelineManager*) getPipelineManager;\n+- (MetalShader*) getCurrentShader;\n+- (void) setCurrentShader:(MetalShader*)shader;\n+\n+- (MetalRingBuffer*) getArgsRingBuffer;\n+- (MetalRingBuffer*) getDataRingBuffer;\n+\n+- (void) commitCurrentCommandBuffer;\n+- (void) commitCurrentCommandBufferAndWait;\n+- (void) commitCurrentCommandBuffer:(bool)waitUntilCompleted;\n+\n+- (id<MTLDevice>) getDevice;\n+- (id<MTLCommandBuffer>) getCurrentCommandBuffer;\n+- (id<MTLRenderCommandEncoder>) getCurrentRenderEncoder;\n+- (void) endCurrentRenderEncoder;\n+\n+- (id<MTLRenderPipelineState>) getPhongPipelineStateWithNumLights:(int)numLights;\n+- (NSUInteger) getCurrentBufferIndex;\n+\n+- (void) updateDepthDetails:(bool)depthTest;\n+- (void) verifyDepthTexture;\n+\n+- (int) setRTT:(MetalRTTexture*)rttPtr;\n+- (MetalRTTexture*) getRTT;\n+- (void) clearRTT:(float)red\n+            green:(float)green\n+             blue:(float)blue\n+            alpha:(float)alpha\n+       clearDepth:(bool)clearDepth;\n+\n+- (void) setClipRect:(int)x y:(int)y width:(int)width height:(int)height;\n+- (void) resetClipRect;\n+\n+- (NSInteger) drawIndexedQuads:(PrismSourceVertex const *)pSrcXYZUVs\n+                      ofColors:(char const *)pSrcColors\n+                   vertexCount:(NSUInteger)numVertices;\n+\n+- (void) renderMeshView:(MetalMeshView*)meshView;\n+- (void) resetProjViewMatrix;\n+- (void) setProjViewMatrix:(bool)isOrtho\n+        m00:(float)m00 m01:(float)m01 m02:(float)m02 m03:(float)m03\n+        m10:(float)m10 m11:(float)m11 m12:(float)m12 m13:(float)m13\n+        m20:(float)m20 m21:(float)m21 m22:(float)m22 m23:(float)m23\n+        m30:(float)m30 m31:(float)m31 m32:(float)m32 m33:(float)m33;\n+\n+- (void) setProjViewMatrix:(float)m00\n+        m01:(float)m01 m02:(float)m02 m03:(float)m03\n+        m10:(float)m10 m11:(float)m11 m12:(float)m12 m13:(float)m13\n+        m20:(float)m20 m21:(float)m21 m22:(float)m22 m23:(float)m23\n+        m30:(float)m30 m31:(float)m31 m32:(float)m32 m33:(float)m33;\n+\n+- (void) setWorldTransformMatrix:(float)m00\n+        m01:(float)m01 m02:(float)m02 m03:(float)m03\n+        m10:(float)m10 m11:(float)m11 m12:(float)m12 m13:(float)m13\n+        m20:(float)m20 m21:(float)m21 m22:(float)m22 m23:(float)m23\n+        m30:(float)m30 m31:(float)m31 m32:(float)m32 m33:(float)m33;\n+\n+- (void) setWorldTransformIdentityMatrix;\n+\n+- (MTLRenderPassDescriptor*) getPhongRPD;\n+- (simd_float4x4) getMVPMatrix;\n+- (simd_float4x4) getWorldMatrix;\n+- (void) setCameraPosition:(float)x y:(float)y z:(float)z;\n+- (vector_float4) getCameraPosition;\n+- (MTLScissorRect) getScissorRect;\n+- (bool) clearDepth;\n+- (bool) isDepthEnabled;\n+- (bool) isScissorEnabled;\n+- (bool) isCurrentRTT:(MetalRTTexture*)rttPtr;\n+- (void) dealloc;\n+- (id<MTLSamplerState>) getSampler:(bool)isLinear wrapMode:(int)wrapMode;\n+- (id<MTLSamplerState>) createSampler:(bool)isLinear wrapMode:(int)wrapMode;\n+- (id<MTLCommandQueue>) getCommandQueue;\n+\n+- (void) validatePixelBuffer:(NSUInteger)length;\n+- (id<MTLBuffer>) getPixelBuffer;\n+- (id<MTLBuffer>) getTransientBufferWithLength:(NSUInteger)length;\n+- (id<MTLBuffer>) getTransientBufferWithBytes:(const void *)pointer length:(NSUInteger)length;\n+\n+- (void) blit:(id<MTLTexture>)src srcX0:(int)srcX0 srcY0:(int)srcY0 srcX1:(int)srcX1 srcY1:(int)srcY1\n+       dstTex:(id<MTLTexture>)dst dstX0:(int)dstX0 dstY0:(int)dstY0 dstX1:(int)dstX1 dstY1:(int)dstY1;\n+\n+@end\n+\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalContext.h","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -0,0 +1,1555 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import <jni.h>\n+#import <dlfcn.h>\n+#import <stdlib.h>\n+#import <assert.h>\n+#import <stdio.h>\n+#import <string.h>\n+#import <math.h>\n+\n+#import \"MetalContext.h\"\n+#import \"MetalRTTexture.h\"\n+#import \"MetalPipelineManager.h\"\n+#import \"MetalShader.h\"\n+#import \"MetalMesh.h\"\n+#import \"MetalMeshView.h\"\n+#import \"MetalPhongMaterial.h\"\n+#import \"com_sun_prism_mtl_MTLContext.h\"\n+\n+@implementation MetalContext\n+\n+- (id) createContext:(dispatch_data_t)shaderLibData\n+{\n+    self = [super init];\n+    if (self) {\n+        device = MTLCreateSystemDefaultDevice();\n+\n+        currentRingBufferIndex = 0;\n+        ringBufferSemaphore = dispatch_semaphore_create(0);\n+        ringBufferLock = [[NSLock alloc] init];\n+        isWaitingForBuffer = false;\n+\n+        argsRingBuffer = [[MetalRingBuffer alloc] init:self\n+                                                ofSize:ARGS_BUFFER_SIZE];\n+        dataRingBuffer = [[MetalRingBuffer alloc] init:self\n+                                                ofSize:DATA_BUFFER_SIZE];\n+        transientBuffersForCB = [[NSMutableArray alloc] init];\n+        shadersUsedInCB = [[NSMutableSet alloc] init];\n+        isScissorEnabled = false;\n+        commitOnDraw = false;\n+        currentRenderEncoder = nil;\n+        meshIndexCount = 0;\n+        linearSamplerDict = [[NSMutableDictionary alloc] init];\n+        nonLinearSamplerDict = [[NSMutableDictionary alloc] init];\n+        compositeMode = com_sun_prism_mtl_MTLContext_MTL_COMPMODE_SRCOVER; \/\/default\n+\n+        currentBufferIndex = 0;\n+        commandQueue = [device newCommandQueue];\n+        commandQueue.label = @\"The only MTLCommandQueue\";\n+        pipelineManager = [MetalPipelineManager alloc];\n+        [pipelineManager init:self libData:shaderLibData];\n+\n+        rttPassDesc = [MTLRenderPassDescriptor new];\n+        rttPassDesc.colorAttachments[0].clearColor  = MTLClearColorMake(1, 1, 1, 1); \/\/ make this programmable\n+        rttPassDesc.colorAttachments[0].storeAction = MTLStoreActionStore;\n+        rttPassDesc.colorAttachments[0].loadAction  = MTLLoadActionLoad;\n+\n+        pixelBuffer = [device newBufferWithLength:4 options:MTLResourceStorageModeShared];\n+\n+        \/\/ clearing rtt related initialization\n+        clearEntireRttVerticesBuf = [device newBufferWithLength:sizeof(CLEAR_VS_INPUT) * 4\n+                                                        options:MTLResourceStorageModePrivate];\n+        id<MTLBuffer> tclearVertBuf = [self getTransientBufferWithLength:sizeof(CLEAR_VS_INPUT) * 4];\n+        CLEAR_VS_INPUT* clearEntireRttVertices = (CLEAR_VS_INPUT*)tclearVertBuf.contents;\n+\n+        clearEntireRttVertices[0].position.x = -1; clearEntireRttVertices[0].position.y = -1;\n+        clearEntireRttVertices[1].position.x = -1; clearEntireRttVertices[1].position.y =  1;\n+        clearEntireRttVertices[2].position.x =  1; clearEntireRttVertices[2].position.y = -1;\n+        clearEntireRttVertices[3].position.x =  1; clearEntireRttVertices[3].position.y =  1;\n+\n+        \/\/ Create Index Buffer\n+        indexBuffer = [device newBufferWithLength:(INDICES_PER_IB * sizeof(unsigned short))\n+                                          options:MTLResourceStorageModePrivate];\n+        id<MTLBuffer> tIndexBuffer = [self getTransientBufferWithLength:\n+                                               (INDICES_PER_IB * sizeof(unsigned short))];\n+        unsigned short* indices = (unsigned short*)tIndexBuffer.contents;\n+        for (unsigned short i = 0, j = 0; i < INDICES_PER_IB; j += 4, i += 6) {\n+            indices[i + 0] = 0 + j; \/\/ 0, 4,  8, 12\n+            indices[i + 1] = 1 + j; \/\/ 1, 5,  9, 13\n+            indices[i + 2] = 2 + j; \/\/ 2, 6, 10, 14\n+\n+            indices[i + 3] = 1 + j; \/\/ 1, 5,  9, 13\n+            indices[i + 4] = 2 + j; \/\/ 2, 6, 10, 14\n+            indices[i + 5] = 3 + j; \/\/ 3, 7, 11, 15\n+        }\n+\n+        id<MTLCommandBuffer> commandBuffer = [self getCurrentCommandBuffer];\n+        @autoreleasepool {\n+            id<MTLBlitCommandEncoder> blitEncoder = [commandBuffer blitCommandEncoder];\n+            [blitEncoder copyFromBuffer:tIndexBuffer\n+                           sourceOffset:(NSUInteger)0\n+                               toBuffer:indexBuffer\n+                      destinationOffset:(NSUInteger)0\n+                                   size:tIndexBuffer.length];\n+\n+            [blitEncoder copyFromBuffer:tclearVertBuf\n+                           sourceOffset:(NSUInteger)0\n+                               toBuffer:clearEntireRttVerticesBuf\n+                      destinationOffset:(NSUInteger)0\n+                                   size:tclearVertBuf.length];\n+\n+            [blitEncoder endEncoding];\n+        }\n+        [self commitCurrentCommandBuffer:false];\n+    }\n+    return self;\n+}\n+\n+- (int) setRTT:(MetalRTTexture*)rttPtr\n+{\n+    if (rtt != rttPtr) {\n+        [self endCurrentRenderEncoder];\n+    }\n+    \/\/ The method can possibly be optmized(with no significant gain in FPS)\n+    \/\/ to avoid updating RenderPassDescriptor if the render target\n+    \/\/ is not being changed, implement or change in future if necessary.\n+    rtt = rttPtr;\n+    id<MTLTexture> mtlTex = [rtt getTexture];\n+    [self validatePixelBuffer:(mtlTex.width * mtlTex.height * 4)];\n+    if ([rttPtr isMSAAEnabled]) {\n+        rttPassDesc.colorAttachments[0].storeAction = MTLStoreActionStoreAndMultisampleResolve;\n+        rttPassDesc.colorAttachments[0].texture = [rtt getMSAATexture];\n+        rttPassDesc.colorAttachments[0].resolveTexture = [rtt getTexture];\n+    } else {\n+        rttPassDesc.colorAttachments[0].storeAction = MTLStoreActionStore;\n+        rttPassDesc.colorAttachments[0].texture = [rtt getTexture];\n+        rttPassDesc.colorAttachments[0].resolveTexture = nil;\n+    }\n+    [self resetClipRect];\n+    return 1;\n+}\n+\n+- (MetalRTTexture*) getRTT\n+{\n+    return rtt;\n+}\n+\n+- (void) validatePixelBuffer:(NSUInteger)length\n+{\n+    if ([pixelBuffer length] < length) {\n+        [transientBuffersForCB addObject:pixelBuffer];\n+        pixelBuffer = [device newBufferWithLength:length options:MTLResourceStorageModeShared];\n+    }\n+}\n+\n+- (id<MTLBuffer>) getPixelBuffer\n+{\n+    return pixelBuffer;\n+}\n+\n+- (MetalRingBuffer*) getArgsRingBuffer\n+{\n+    return argsRingBuffer;\n+}\n+\n+- (MetalRingBuffer*) getDataRingBuffer\n+{\n+    return dataRingBuffer;\n+}\n+\n+- (id<MTLBuffer>) getTransientBufferWithBytes:(const void *)pointer length:(NSUInteger)length\n+{\n+    id<MTLBuffer> transientBuf = [device newBufferWithBytes:pointer\n+                                                     length:length\n+                                                    options:MTLResourceStorageModeShared];\n+    [transientBuffersForCB addObject:transientBuf];\n+    commitOnDraw = true;\n+    return transientBuf;\n+}\n+\n+- (id<MTLBuffer>) getTransientBufferWithLength:(NSUInteger)length\n+{\n+    id<MTLBuffer> transientBuf = [device newBufferWithLength:length\n+                                                     options:MTLResourceStorageModeShared];\n+    [transientBuffersForCB addObject:transientBuf];\n+    commitOnDraw = true;\n+    return transientBuf;\n+}\n+\n+- (id<MTLSamplerState>) getSampler:(bool)isLinear\n+                          wrapMode:(int)wrapMode\n+{\n+    NSMutableDictionary* samplerDict;\n+    if (isLinear) {\n+        samplerDict = linearSamplerDict;\n+    } else {\n+        samplerDict = nonLinearSamplerDict;\n+    }\n+    NSNumber *keyWrapMode = [NSNumber numberWithInt:wrapMode];\n+    id<MTLSamplerState> sampler = samplerDict[keyWrapMode];\n+    if (sampler == nil) {\n+        sampler = [self createSampler:isLinear wrapMode:wrapMode];\n+        [samplerDict setObject:sampler forKey:keyWrapMode];\n+    }\n+    return sampler;\n+}\n+\n+- (id<MTLSamplerState>) createSampler:(bool)isLinear\n+                             wrapMode:(int)wrapMode\n+{\n+    MTLSamplerDescriptor *samplerDescriptor = [MTLSamplerDescriptor new];\n+    if (isLinear) {\n+        samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;\n+        samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;\n+    }\n+    if (wrapMode != -1) {\n+        samplerDescriptor.sAddressMode = wrapMode;\n+        samplerDescriptor.tAddressMode = wrapMode;\n+    }\n+    id<MTLSamplerState> sampler = [[self getDevice] newSamplerStateWithDescriptor:samplerDescriptor];\n+    [samplerDescriptor release];\n+    return sampler;\n+}\n+\n+- (id<MTLDevice>) getDevice\n+{\n+    return device;\n+}\n+\n+- (void) commitCurrentCommandBuffer\n+{\n+    [self commitCurrentCommandBuffer:false];\n+}\n+\n+- (void) commitCurrentCommandBufferAndWait\n+{\n+    [self commitCurrentCommandBuffer:true];\n+}\n+\n+- (void) commitCurrentCommandBuffer:(bool)waitUntilCompleted\n+{\n+    if (currentCommandBuffer == nil) {\n+        return;\n+    }\n+    [self endCurrentRenderEncoder];\n+\n+    NSMutableArray* bufsForCB = transientBuffersForCB;\n+    transientBuffersForCB = [[NSMutableArray alloc] init];\n+\n+    for (MetalShader* shader in shadersUsedInCB) {\n+        [shader setArgsUpdated:true];\n+    }\n+    [shadersUsedInCB removeAllObjects];\n+\n+    int rbid = currentRingBufferIndex;\n+    if ([argsRingBuffer getNumReservedBytes] == 0 &&\n+            [dataRingBuffer getNumReservedBytes] == 0) {\n+        [MetalRingBuffer resetBuffer:rbid];\n+        rbid = -1;\n+    }\n+\n+    [currentCommandBuffer addCompletedHandler:^(id<MTLCommandBuffer> cb) {\n+        \/\/ The CompletedHandler is invoked on different background threads.\n+        \/\/ CommandBuffer are executed sequentially. A CommandBuffer is\n+        \/\/ considered to be completed only when all its CompletedHandler are\n+        \/\/ executed. So two completed handlers would never execute concurrently.\n+\n+        if (rbid > -1) {\n+            [MetalRingBuffer resetBuffer:rbid];\n+            if (isWaitingForBuffer) {\n+                [ringBufferLock lock];\n+                if (isWaitingForBuffer) {\n+                    isWaitingForBuffer = false;\n+                    dispatch_semaphore_signal(ringBufferSemaphore);\n+                }\n+                [ringBufferLock unlock];\n+            }\n+        }\n+        for (id buffer in bufsForCB) {\n+            [buffer release];\n+        }\n+        [bufsForCB removeAllObjects];\n+        [bufsForCB release];\n+    }];\n+    commitOnDraw = false;\n+    [currentCommandBuffer commit];\n+\n+    if (waitUntilCompleted) {\n+        [currentCommandBuffer waitUntilCompleted];\n+    } else {\n+        if (![MetalRingBuffer isBufferAvailable]) {\n+            [ringBufferLock lock];\n+            isWaitingForBuffer = true;\n+            [ringBufferLock unlock];\n+            dispatch_semaphore_wait(ringBufferSemaphore, DISPATCH_TIME_FOREVER);\n+        }\n+    }\n+\n+    currentRingBufferIndex = [MetalRingBuffer updateBufferInUse];\n+    [argsRingBuffer resetOffsets];\n+    [dataRingBuffer resetOffsets];\n+    [currentCommandBuffer release];\n+    currentCommandBuffer = nil;\n+}\n+\n+- (id<MTLCommandBuffer>) getCurrentCommandBuffer\n+{\n+    if (currentCommandBuffer == nil\n+                || currentCommandBuffer.status != MTLCommandBufferStatusNotEnqueued) {\n+\n+        @autoreleasepool {\n+            \/\/ The commandBuffer creation using commandQueue returns\n+            \/\/ an autoreleased object. We need this object at a class level as it\n+            \/\/ gets used in other class methods.\n+            \/\/ Take up the ownership of this commandBuffer object using retain.\n+            currentCommandBuffer = [[commandQueue commandBuffer] retain];\n+        }\n+        currentCommandBuffer.label = @\"JFX Command Buffer\";\n+    }\n+    return currentCommandBuffer;\n+}\n+\n+- (id<MTLRenderCommandEncoder>) getCurrentRenderEncoder\n+{\n+    if (currentRenderEncoder == nil) {\n+        id<MTLCommandBuffer> cb = [self getCurrentCommandBuffer];\n+\n+        @autoreleasepool {\n+            \/\/ The RenderEncoder creation using command buffer returns\n+            \/\/ an autoreleased object. We need this object at a class level as it\n+            \/\/ gets used in other class methods.\n+            \/\/ Take up the ownership of this RenderEncoder object using retain.\n+            currentRenderEncoder = [[cb renderCommandEncoderWithDescriptor:rttPassDesc] retain];\n+        }\n+    }\n+    return currentRenderEncoder;\n+}\n+\n+- (void) endCurrentRenderEncoder\n+{\n+    if (currentRenderEncoder != nil) {\n+        meshIndexCount = 0;\n+        [currentRenderEncoder endEncoding];\n+        [currentRenderEncoder release];\n+        currentRenderEncoder = nil;\n+    }\n+}\n+\n+- (NSUInteger) getCurrentBufferIndex\n+{\n+    return currentBufferIndex;\n+}\n+\n+- (id<MTLRenderPipelineState>) getPhongPipelineStateWithNumLights:(int)numLights\n+{\n+    return [[self getPipelineManager] getPhongPipeStateWithNumLights:numLights\n+                compositeMode:[self getCompositeMode]];\n+}\n+\n+- (NSInteger) drawIndexedQuads:(PrismSourceVertex const *)pSrcXYZUVs\n+                      ofColors:(char const *)pSrcColors\n+                   vertexCount:(NSUInteger)numVertices\n+{\n+    int vbLength   = numVertices * sizeof(PrismSourceVertex);\n+    int cbLength   = numVertices * 4;\n+    int numQuads   = numVertices \/ 4;\n+    int numIndices = numQuads * 6;\n+\n+    id<MTLBuffer> vertexBuffer = [dataRingBuffer getBuffer];\n+    int vertexOffset = [dataRingBuffer reserveBytes:vbLength];\n+    if (vertexOffset < 0) {\n+        vertexBuffer = [self getTransientBufferWithLength:vbLength];\n+        vertexOffset = 0;\n+    }\n+    memcpy(vertexBuffer.contents + vertexOffset, pSrcXYZUVs, vbLength);\n+\n+    id<MTLBuffer> colorBuffer = [dataRingBuffer getBuffer];\n+    int colorOffset = [dataRingBuffer reserveBytes:cbLength];\n+    if (colorOffset < 0) {\n+        colorBuffer = [self getTransientBufferWithLength:cbLength];\n+        colorOffset = 0;\n+    }\n+    memcpy(colorBuffer.contents + colorOffset, pSrcColors, cbLength);\n+\n+    id<MTLRenderCommandEncoder> renderEncoder = [self getCurrentRenderEncoder];\n+\n+    [renderEncoder setFrontFacingWinding:MTLWindingClockwise];\n+    [renderEncoder setCullMode:MTLCullModeNone];\n+    [renderEncoder setTriangleFillMode:MTLTriangleFillModeFill];\n+\n+    [renderEncoder setVertexBytes:&mvpMatrix\n+                           length:sizeof(mvpMatrix)\n+                          atIndex:VertexInputMatrixMVP];\n+\n+    MetalShader* shader = [self getCurrentShader];\n+    [shadersUsedInCB addObject:shader];\n+\n+    [renderEncoder setRenderPipelineState:[shader getPipelineState:[rtt isMSAAEnabled]\n+                                                     compositeMode:compositeMode]];\n+    if (depthEnabled) {\n+        id<MTLDepthStencilState> depthStencilState =\n+            [[self getPipelineManager] getDepthStencilState];\n+        [renderEncoder setDepthStencilState:depthStencilState];\n+    }\n+\n+    if ([shader getArgumentBufferLength] != 0) {\n+        [shader copyArgBufferToRingBuffer];\n+        [renderEncoder setFragmentBuffer:[shader getRingBuffer]\n+                                  offset:[shader getRingBufferOffset]\n+                                 atIndex:0];\n+\n+        NSMutableDictionary* texturesDict = [shader getTexutresDict];\n+        if ([texturesDict count] > 0) {\n+            for (NSString *key in texturesDict) {\n+                id<MTLTexture> tex = texturesDict[key];\n+                [renderEncoder useResource:tex usage:MTLResourceUsageRead];\n+            }\n+\n+            NSMutableDictionary* samplersDict = [shader getSamplersDict];\n+            for (NSNumber *key in samplersDict) {\n+                id<MTLSamplerState> sampler = samplersDict[key];\n+                [renderEncoder setFragmentSamplerState:sampler atIndex:[key integerValue]];\n+            }\n+        }\n+    }\n+\n+    [renderEncoder setScissorRect:[self getScissorRect]];\n+\n+    for (int i = 0; numIndices > 0; i++) {\n+        [renderEncoder setVertexBuffer:vertexBuffer\n+                                offset:(vertexOffset + (i * VERTICES_PER_IB * sizeof(PrismSourceVertex)))\n+                               atIndex:VertexInputIndexVertices];\n+\n+        [renderEncoder setVertexBuffer:colorBuffer\n+                                offset:(colorOffset + (i * VERTICES_PER_IB * 4))\n+                               atIndex:VertexInputColors];\n+\n+        [renderEncoder drawIndexedPrimitives:MTLPrimitiveTypeTriangle\n+                                  indexCount:((numIndices > INDICES_PER_IB) ? INDICES_PER_IB : numIndices)\n+                                   indexType:MTLIndexTypeUInt16\n+                                 indexBuffer:indexBuffer\n+                           indexBufferOffset:0];\n+        numIndices -= INDICES_PER_IB;\n+    }\n+\n+    if (commitOnDraw) {\n+        [self commitCurrentCommandBuffer];\n+    }\n+    return 1;\n+}\n+\n+- (void) setProjViewMatrix:(bool)depthTest\n+        m00:(float)m00 m01:(float)m01 m02:(float)m02 m03:(float)m03\n+        m10:(float)m10 m11:(float)m11 m12:(float)m12 m13:(float)m13\n+        m20:(float)m20 m21:(float)m21 m22:(float)m22 m23:(float)m23\n+        m30:(float)m30 m31:(float)m31 m32:(float)m32 m33:(float)m33\n+{\n+    mvpMatrix = simd_matrix(\n+        (simd_float4){ m00, m01, m02, m03 },\n+        (simd_float4){ m10, m11, m12, m13 },\n+        (simd_float4){ m20, m21, m22, m23 },\n+        (simd_float4){ m30, m31, m32, m33 }\n+    );\n+    if (depthTest &&\n+        ([rtt getDepthTexture] != nil)) {\n+        depthEnabled = true;\n+    } else {\n+        depthEnabled = false;\n+    }\n+    [self updateDepthDetails:depthTest];\n+}\n+\n+- (void) setProjViewMatrix:(float)m00\n+        m01:(float)m01 m02:(float)m02 m03:(float)m03\n+        m10:(float)m10 m11:(float)m11 m12:(float)m12 m13:(float)m13\n+        m20:(float)m20 m21:(float)m21 m22:(float)m22 m23:(float)m23\n+        m30:(float)m30 m31:(float)m31 m32:(float)m32 m33:(float)m33\n+{\n+    mvpMatrix = simd_matrix(\n+        (simd_float4){ m00, m01, m02, m03 },\n+        (simd_float4){ m10, m11, m12, m13 },\n+        (simd_float4){ m20, m21, m22, m23 },\n+        (simd_float4){ m30, m31, m32, m33 }\n+    );\n+}\n+\n+- (void) setWorldTransformMatrix:(float)m00\n+        m01:(float)m01 m02:(float)m02 m03:(float)m03\n+        m10:(float)m10 m11:(float)m11 m12:(float)m12 m13:(float)m13\n+        m20:(float)m20 m21:(float)m21 m22:(float)m22 m23:(float)m23\n+        m30:(float)m30 m31:(float)m31 m32:(float)m32 m33:(float)m33\n+{\n+    worldMatrix = simd_matrix(\n+        (simd_float4){ m00, m01, m02, m03 },\n+        (simd_float4){ m10, m11, m12, m13 },\n+        (simd_float4){ m20, m21, m22, m23 },\n+        (simd_float4){ m30, m31, m32, m33 }\n+    );\n+}\n+\n+- (void) setWorldTransformIdentityMatrix\n+{\n+    worldMatrix = matrix_identity_float4x4;\n+}\n+\n+- (void) clearRTT:(float)red\n+            green:(float)green\n+             blue:(float)blue\n+            alpha:(float)alpha\n+       clearDepth:(bool)clearDepth\n+{\n+    clearDepthTexture = false;\n+    if (clearDepth &&\n+        [rtt getDepthTexture] != nil) {\n+        clearDepthTexture = true;\n+        rttPassDesc.depthAttachment.clearDepth = 1.0;\n+        rttPassDesc.depthAttachment.loadAction = MTLLoadActionClear;\n+        if ([[self getRTT] isMSAAEnabled]) {\n+            rttPassDesc.depthAttachment.storeAction = MTLStoreActionStoreAndMultisampleResolve;\n+            rttPassDesc.depthAttachment.texture = [rtt getDepthMSAATexture];\n+            rttPassDesc.depthAttachment.resolveTexture = [rtt getDepthTexture];\n+        } else {\n+            rttPassDesc.depthAttachment.storeAction = MTLStoreActionStore;\n+            rttPassDesc.depthAttachment.texture = [[self getRTT] getDepthTexture];\n+            rttPassDesc.depthAttachment.resolveTexture = nil;\n+        }\n+    } else {\n+        rttPassDesc.depthAttachment = nil;\n+    }\n+    clearColor[0] = red;\n+    clearColor[1] = green;\n+    clearColor[2] = blue;\n+    clearColor[3] = alpha;\n+\n+    id<MTLRenderCommandEncoder> renderEncoder = [self getCurrentRenderEncoder];\n+\n+    [renderEncoder setRenderPipelineState:[pipelineManager getClearRttPipeState]];\n+    if (clearDepthTexture) {\n+        id<MTLDepthStencilState> depthStencilState =\n+            [[self getPipelineManager] getDepthStencilState];\n+        [renderEncoder setDepthStencilState:depthStencilState];\n+    }\n+    [renderEncoder setFrontFacingWinding:MTLWindingClockwise];\n+    [renderEncoder setCullMode:MTLCullModeNone];\n+    [renderEncoder setTriangleFillMode:MTLTriangleFillModeFill];\n+\n+    [renderEncoder setScissorRect:[self getScissorRect]];\n+\n+    if (isScissorEnabled) {\n+        [renderEncoder setVertexBytes:clearScissorRectVertices\n+                               length:sizeof(clearScissorRectVertices)\n+                              atIndex:VertexInputIndexVertices];\n+    } else {\n+        [renderEncoder setVertexBuffer:clearEntireRttVerticesBuf\n+                                offset:0\n+                               atIndex:VertexInputIndexVertices];\n+    }\n+\n+    [renderEncoder setFragmentBytes:clearColor\n+                             length:sizeof(clearColor)\n+                            atIndex:VertexInputClearColor];\n+\n+    [renderEncoder drawIndexedPrimitives:MTLPrimitiveTypeTriangle\n+                              indexCount:6\n+                               indexType:MTLIndexTypeUInt16\n+                             indexBuffer:indexBuffer\n+                       indexBufferOffset:0];\n+\n+    if (clearDepth && !depthEnabled) {\n+        [self endCurrentRenderEncoder];\n+    }\n+}\n+\n+- (void) renderMeshView:(MetalMeshView*)meshView\n+{\n+    MetalMesh* mesh = [meshView getMesh];\n+    NSUInteger indexCount = [mesh getNumIndices];\n+    meshIndexCount += indexCount;\n+    if (meshIndexCount >= MESH_INDEX_LIMIT) {\n+        [self endCurrentRenderEncoder];\n+    }\n+    [meshView render];\n+}\n+\n+- (void) setClipRect:(int)x y:(int)y width:(int)width height:(int)height\n+{\n+    id<MTLTexture> currRtt = [rtt getTexture];\n+    int x1 = x + width;\n+    int y1 = y + height;\n+    if (x <= 0 && y <= 0 && x1 >= currRtt.width && y1 >= currRtt.height) {\n+        [self resetClipRect];\n+    } else {\n+        if (x < 0)                    x = 0;\n+        if (y < 0)                    y = 0;\n+        if (x1 > currRtt.width)  width  = currRtt.width - x;\n+        if (y1 > currRtt.height) height = currRtt.height - y;\n+        if (x > x1)              width  = x = 0;\n+        if (y > y1)              height = y = 0;\n+        scissorRect.x = x;\n+        scissorRect.y = y;\n+        scissorRect.width  = width;\n+        scissorRect.height = height;\n+        isScissorEnabled = true;\n+\n+        \/\/ Create device space (-1, 1) coordinates of scissor rect.\n+        float halfWidth  = (float)currRtt.width  \/ 2.0f;\n+        float halfHeight = (float)currRtt.height \/ 2.0f;\n+        float x1 =   (scissorRect.x - halfWidth)  \/ halfWidth;\n+        float y1 = - (scissorRect.y - halfHeight) \/ halfHeight;\n+        float x2 =   ((scissorRect.x + scissorRect.width)  - halfWidth)  \/ halfWidth;\n+        float y2 = - ((scissorRect.y + scissorRect.height) - halfHeight) \/ halfHeight;\n+\n+        clearScissorRectVertices[0].position.x = x1;\n+        clearScissorRectVertices[0].position.y = y1;\n+        clearScissorRectVertices[1].position.x = x1;\n+        clearScissorRectVertices[1].position.y = y2;\n+        clearScissorRectVertices[2].position.x = x2;\n+        clearScissorRectVertices[2].position.y = y1;\n+        clearScissorRectVertices[3].position.x = x2;\n+        clearScissorRectVertices[3].position.y = y2;\n+    }\n+}\n+\n+- (void) resetClipRect\n+{\n+    isScissorEnabled = false;\n+    scissorRect.x = 0;\n+    scissorRect.y = 0;\n+    scissorRect.width  = 0;\n+    scissorRect.height = 0;\n+}\n+\n+- (void) resetProjViewMatrix\n+{\n+    mvpMatrix = matrix_identity_float4x4;\n+}\n+\n+- (MetalPipelineManager*) getPipelineManager\n+{\n+    return pipelineManager;\n+}\n+\n+- (MetalShader*) getCurrentShader\n+{\n+    return currentShader;\n+}\n+\n+- (void) setCurrentShader:(MetalShader*)shader\n+{\n+    currentShader = shader;\n+}\n+\n+- (void) updateDepthDetails:(bool)depthTest\n+{\n+    if (depthTest) {\n+        if ([[self getRTT] isMSAAEnabled]) {\n+            rttPassDesc.depthAttachment.storeAction = MTLStoreActionStoreAndMultisampleResolve;\n+            rttPassDesc.depthAttachment.texture = [rtt getDepthMSAATexture];\n+            rttPassDesc.depthAttachment.resolveTexture = [rtt getDepthTexture];\n+        } else {\n+            rttPassDesc.depthAttachment.storeAction = MTLStoreActionStore;\n+            rttPassDesc.depthAttachment.texture = [[self getRTT] getDepthTexture];\n+            rttPassDesc.depthAttachment.resolveTexture = nil;\n+        }\n+    } else {\n+        rttPassDesc.depthAttachment = nil;\n+    }\n+}\n+\n+- (void) verifyDepthTexture\n+{\n+    id<MTLTexture> depthTexture = [rtt getDepthTexture];\n+    if (depthTexture == nil) {\n+        [rtt createDepthTexture];\n+        rttPassDesc.depthAttachment.clearDepth = 1.0;\n+        rttPassDesc.depthAttachment.loadAction = MTLLoadActionClear;\n+    } else {\n+        rttPassDesc.depthAttachment.loadAction = MTLLoadActionLoad;\n+    }\n+}\n+\n+- (void) setCompositeMode:(int)mode\n+{\n+    compositeMode = mode;\n+}\n+\n+- (int) getCompositeMode\n+{\n+    return compositeMode;\n+}\n+\n+- (void) setCameraPosition:(float)x y:(float)y z:(float)z\n+{\n+    cPos.x = x;\n+    cPos.y = y;\n+    cPos.z = z;\n+    cPos.w = 0;\n+}\n+\n+- (MTLRenderPassDescriptor*) getPhongRPD\n+{\n+    return phongRPD;\n+}\n+\n+- (simd_float4x4) getMVPMatrix\n+{\n+    return mvpMatrix;\n+}\n+\n+- (simd_float4x4) getWorldMatrix\n+{\n+    return worldMatrix;\n+}\n+\n+- (vector_float4) getCameraPosition\n+{\n+    return cPos;\n+}\n+\n+- (MTLScissorRect) getScissorRect\n+{\n+    if (!isScissorEnabled) {\n+        scissorRect.x = 0;\n+        scissorRect.y = 0;\n+        id<MTLTexture> currRtt = rttPassDesc.colorAttachments[0].texture;\n+        scissorRect.width  = currRtt.width;\n+        scissorRect.height = currRtt.height;\n+    }\n+    return scissorRect;\n+}\n+\n+- (bool) clearDepth\n+{\n+    return clearDepthTexture;\n+}\n+\n+- (bool) isDepthEnabled\n+{\n+    return depthEnabled;\n+}\n+\n+- (bool) isScissorEnabled\n+{\n+    return isScissorEnabled;\n+}\n+\n+- (bool) isCurrentRTT:(MetalRTTexture*)rttPtr\n+{\n+    if (rttPtr == rtt) {\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+- (void) dealloc\n+{\n+    if (currentCommandBuffer == nil) {\n+        [self getCurrentCommandBuffer];\n+    }\n+    [self commitCurrentCommandBuffer:true];\n+\n+    if (commandQueue != nil) {\n+        [commandQueue release];\n+        commandQueue = nil;\n+    }\n+\n+    if (pipelineManager != nil) {\n+        [pipelineManager release];\n+        pipelineManager = nil;\n+    }\n+\n+    if (rttPassDesc != nil) {\n+        [rttPassDesc release];\n+        rttPassDesc = nil;\n+    }\n+\n+    if (phongRPD != nil) {\n+        [phongRPD release];\n+        phongRPD = nil;\n+    }\n+\n+    if (argsRingBuffer != nil) {\n+        [argsRingBuffer dealloc];\n+        argsRingBuffer = nil;\n+    }\n+\n+    if (dataRingBuffer != nil) {\n+        [dataRingBuffer dealloc];\n+        dataRingBuffer = nil;\n+    }\n+\n+    for (NSNumber *keyWrapMode in linearSamplerDict) {\n+        [linearSamplerDict[keyWrapMode] release];\n+    }\n+    for (NSNumber *keyWrapMode in nonLinearSamplerDict) {\n+        [nonLinearSamplerDict[keyWrapMode] release];\n+    }\n+    [linearSamplerDict release];\n+    [nonLinearSamplerDict release];\n+\n+    if (transientBuffersForCB != nil) {\n+        for (id buffer in transientBuffersForCB) {\n+            [buffer release];\n+        }\n+        [transientBuffersForCB removeAllObjects];\n+        [transientBuffersForCB release];\n+        transientBuffersForCB = nil;\n+    }\n+\n+    if (shadersUsedInCB != nil) {\n+        [shadersUsedInCB removeAllObjects];\n+        [shadersUsedInCB release];\n+        shadersUsedInCB = nil;\n+    }\n+\n+    if (clearEntireRttVerticesBuf != nil) {\n+        [clearEntireRttVerticesBuf release];\n+        clearEntireRttVerticesBuf = nil;\n+    }\n+\n+    if (pixelBuffer != nil) {\n+        [pixelBuffer release];\n+        pixelBuffer = nil;\n+    }\n+\n+    device = nil;\n+\n+    [super dealloc];\n+}\n+\n+- (id<MTLCommandQueue>) getCommandQueue\n+{\n+    return commandQueue;\n+}\n+\n+- (void) blit:(id<MTLTexture>)src srcX0:(int)srcX0 srcY0:(int)srcY0 srcX1:(int)srcX1 srcY1:(int)srcY1\n+       dstTex:(id<MTLTexture>)dst dstX0:(int)dstX0 dstY0:(int)dstY0 dstX1:(int)dstX1 dstY1:(int)dstY1\n+{\n+    [self endCurrentRenderEncoder];\n+\n+    id<MTLCommandBuffer> commandBuffer = [self getCurrentCommandBuffer];\n+    @autoreleasepool {\n+        id<MTLBlitCommandEncoder> blitEncoder = [commandBuffer blitCommandEncoder];\n+        if (src.usage == MTLTextureUsageRenderTarget) {\n+            [blitEncoder synchronizeTexture:src slice:0 level:0];\n+        }\n+        if (dst.usage == MTLTextureUsageRenderTarget) {\n+            [blitEncoder synchronizeTexture:dst slice:0 level:0];\n+        }\n+        [blitEncoder copyFromTexture:src\n+                         sourceSlice:(NSUInteger)0\n+                         sourceLevel:(NSUInteger)0\n+                        sourceOrigin:MTLOriginMake(0, 0, 0)\n+                          sourceSize:MTLSizeMake(src.width, src.height, src.depth)\n+                           toTexture:dst\n+                    destinationSlice:(NSUInteger)0\n+                    destinationLevel:(NSUInteger)0\n+                   destinationOrigin:MTLOriginMake(0, 0, 0)];\n+        [blitEncoder endEncoding];\n+    }\n+}\n+\n+@end \/\/ MetalContext\n+\n+\n+\/\/ ** JNI METHODS **\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nInitialize\n+ * Signature: (Ljava\/nio\/ByteBuffer;)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_prism_mtl_MTLContext_nInitialize\n+    (JNIEnv *env, jclass jClass, jobject shaderLibBuffer)\n+{\n+    jlong jContextPtr = 0L;\n+\n+    \/\/ Create data object from direct byte buffer\n+    const void* dataPtr = (*env)->GetDirectBufferAddress(env, shaderLibBuffer);\n+    if (dataPtr == NULL) {\n+        NSLog(@\"MTLContext_nInitialize: shaderLibBuffer addr = NULL\");\n+        return 0L;\n+    }\n+\n+    const jlong numBytes = (*env)->GetDirectBufferCapacity(env, shaderLibBuffer);\n+    if (numBytes <= 0) {\n+        NSLog(@\"MTLContext_nInitialize: shaderLibBuffer invalid capacity\");\n+        return 0L;\n+    }\n+\n+\n+    \/\/ We use a no-op destructor because the direct ByteBuffer is managed on the\n+    \/\/ Java side. We must not free it here.\n+    dispatch_data_t shaderLibData = dispatch_data_create(dataPtr, numBytes,\n+            DISPATCH_QUEUE_SERIAL,\n+            ^(void) {});\n+\n+    if (shaderLibData == nil) {\n+        NSLog(@\"MTLContext_nInitialize: Unable to create a dispatch_data object\");\n+        return 0L;\n+    }\n+\n+    jContextPtr = ptr_to_jlong([[MetalContext alloc] createContext:shaderLibData]);\n+    return jContextPtr;\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nDisposeShader\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nDisposeShader\n+    (JNIEnv *env, jclass jClass, jlong shaderRef)\n+{\n+    MetalShader *shaderPtr = (MetalShader *)jlong_to_ptr(shaderRef);\n+    if (shaderPtr != nil) {\n+        [shaderPtr release];\n+        shaderPtr = nil;\n+    }\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nRelease\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nRelease\n+    (JNIEnv *env, jclass jClass, jlong context)\n+{\n+    MetalContext *contextPtr = (MetalContext *)jlong_to_ptr(context);\n+\n+    if (contextPtr != nil) {\n+        [contextPtr dealloc];\n+    }\n+    contextPtr = nil;\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nCommitCurrentCommandBuffer\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nCommitCurrentCommandBuffer\n+    (JNIEnv *env, jclass jClass, jlong context)\n+{\n+    MetalContext *mtlContext = (MetalContext *)jlong_to_ptr(context);\n+    [mtlContext commitCurrentCommandBuffer];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nDrawIndexedQuads\n+ * Signature: (J[F[BI)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nDrawIndexedQuads\n+    (JNIEnv *env, jclass jClass, jlong context, jfloatArray vertices, jbyteArray colors, jint numVertices)\n+{\n+    MetalContext *mtlContext = (MetalContext *)jlong_to_ptr(context);\n+\n+    PrismSourceVertex *pVertices =\n+                    (PrismSourceVertex *) (*env)->GetPrimitiveArrayCritical(env, vertices, 0);\n+    char *pColors = (char *) (*env)->GetPrimitiveArrayCritical(env, colors, 0);\n+\n+    [mtlContext drawIndexedQuads:pVertices ofColors:pColors vertexCount:numVertices];\n+\n+    if (pColors) (*env)->ReleasePrimitiveArrayCritical(env, colors, pColors, 0);\n+    if (pVertices) (*env)->ReleasePrimitiveArrayCritical(env, vertices, pVertices, 0);\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nUpdateRenderTarget\n+ * Signature: (JJZ)V\n+ *\/\n+JNIEXPORT int JNICALL Java_com_sun_prism_mtl_MTLContext_nUpdateRenderTarget\n+    (JNIEnv *env, jclass jClass, jlong context, jlong texPtr, jboolean depthTest)\n+{\n+    MetalContext *mtlContext = (MetalContext *)jlong_to_ptr(context);\n+    MetalRTTexture *rtt = (MetalRTTexture *)jlong_to_ptr(texPtr);\n+    int ret = [mtlContext setRTT:rtt];\n+    \/\/ If we create depth texture while creating RTT\n+    \/\/ then also current implementation works fine. So in future\n+    \/\/ if we see any performance\/state impact we should move\n+    \/\/ depthTexture creation along with RTT creation,\n+    \/\/ implement or change in future if necessary.\n+    if (depthTest) {\n+        [mtlContext verifyDepthTexture];\n+    }\n+    return ret;\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetClipRect\n+ * Signature: (JJIIII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetClipRect\n+    (JNIEnv *env, jclass jClass, jlong ctx,\n+    jint x, jint y, jint width, jint height)\n+{\n+    MetalContext *pCtx = (MetalContext*)jlong_to_ptr(ctx);\n+    [pCtx setClipRect:x y:y width:width height:height];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nResetClipRect\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nResetClipRect\n+    (JNIEnv *env, jclass jClass, jlong ctx)\n+{\n+    MetalContext *pCtx = (MetalContext*)jlong_to_ptr(ctx);\n+    [pCtx resetClipRect];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetProjViewMatrix\n+ * Signature: (JZDDDDDDDDDDDDDDDD)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetProjViewMatrix\n+    (JNIEnv *env, jclass jClass,\n+    jlong context, jboolean isOrtho,\n+    jdouble m00, jdouble m01, jdouble m02, jdouble m03,\n+    jdouble m10, jdouble m11, jdouble m12, jdouble m13,\n+    jdouble m20, jdouble m21, jdouble m22, jdouble m23,\n+    jdouble m30, jdouble m31, jdouble m32, jdouble m33)\n+{\n+    MetalContext *mtlContext = (MetalContext *)jlong_to_ptr(context);\n+    [mtlContext setProjViewMatrix:isOrtho\n+        m00:m00 m01:m01 m02:m02 m03:m03\n+        m10:m10 m11:m11 m12:m12 m13:m13\n+        m20:m20 m21:m21 m22:m22 m23:m23\n+        m30:m30 m31:m31 m32:m32 m33:m33];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetTransform\n+ * Signature: (JDDDDDDDDDDDDDDDD)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetTransform\n+    (JNIEnv *env, jclass jClass,\n+    jlong context,\n+    jdouble m00, jdouble m01, jdouble m02, jdouble m03,\n+    jdouble m10, jdouble m11, jdouble m12, jdouble m13,\n+    jdouble m20, jdouble m21, jdouble m22, jdouble m23,\n+    jdouble m30, jdouble m31, jdouble m32, jdouble m33)\n+{\n+    MetalContext *mtlContext = (MetalContext *)jlong_to_ptr(context);\n+\n+    \/\/ Added separate nSetTransform because previously\n+    \/\/ we used to use nSetProjViewMatrix only and enabled depth test\n+    \/\/ by default. Also check whether we need to do anything else\n+    \/\/ apart from just updating projection view matrix,\n+    \/\/ implement or change in future if necessary.\n+\n+    [mtlContext setProjViewMatrix:m00\n+        m01:m01 m02:m02 m03:m03\n+        m10:m10 m11:m11 m12:m12 m13:m13\n+        m20:m20 m21:m21 m22:m22 m23:m23\n+        m30:m30 m31:m31 m32:m32 m33:m33];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetWorldTransform\n+ * Signature: (JDDDDDDDDDDDDDDDD)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetWorldTransform\n+    (JNIEnv *env, jclass jClass,\n+    jlong context,\n+    jdouble m00, jdouble m01, jdouble m02, jdouble m03,\n+    jdouble m10, jdouble m11, jdouble m12, jdouble m13,\n+    jdouble m20, jdouble m21, jdouble m22, jdouble m23,\n+    jdouble m30, jdouble m31, jdouble m32, jdouble m33)\n+{\n+    MetalContext *mtlContext = (MetalContext *)jlong_to_ptr(context);\n+    [mtlContext setWorldTransformMatrix:m00 m01:m01 m02:m02 m03:m03\n+        m10:m10 m11:m11 m12:m12 m13:m13\n+        m20:m20 m21:m21 m22:m22 m23:m23\n+        m30:m30 m31:m31 m32:m32 m33:m33];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetWorldTransformToIdentity\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetWorldTransformToIdentity\n+    (JNIEnv *env, jclass jClass, jlong context)\n+{\n+    MetalContext *mtlContext = (MetalContext *)jlong_to_ptr(context);\n+    [mtlContext setWorldTransformIdentityMatrix];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nCreateMTLMesh\n+ * Signature: (J)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_prism_mtl_MTLContext_nCreateMTLMesh\n+    (JNIEnv *env, jclass jClass, jlong ctx)\n+{\n+    MetalContext *pCtx = (MetalContext*) jlong_to_ptr(ctx);\n+\n+    MetalMesh* mesh = ([[MetalMesh alloc] createMesh:pCtx]);\n+    return ptr_to_jlong(mesh);\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nReleaseMTLMesh\n+ * Signature: (JJ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nReleaseMTLMesh\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativeMesh)\n+{\n+    MetalMesh *mesh = (MetalMesh *) jlong_to_ptr(nativeMesh);\n+    if (mesh != nil) {\n+        [mesh release];\n+        mesh = nil;\n+    }\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nBuildNativeGeometryShort\n+ * Signature: (JJ[FI[SI)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_prism_mtl_MTLContext_nBuildNativeGeometryShort\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativeMesh,\n+    jfloatArray vb, jint vbSize, jshortArray ib, jint ibSize)\n+{\n+    MetalMesh *mesh = (MetalMesh *) jlong_to_ptr(nativeMesh);\n+\n+    if (vbSize < 0 || ibSize < 0) {\n+        return JNI_FALSE;\n+    }\n+\n+    unsigned int uvbSize = (unsigned int) vbSize;\n+    unsigned int uibSize = (unsigned int) ibSize;\n+    unsigned int vertexBufferSize = (*env)->GetArrayLength(env, vb);\n+    unsigned int indexBufferSize = (*env)->GetArrayLength(env, ib);\n+\n+    if (uvbSize > vertexBufferSize || uibSize > indexBufferSize) {\n+        return JNI_FALSE;\n+    }\n+\n+    float *vertexBuffer = (float *) ((*env)->GetPrimitiveArrayCritical(env, vb, 0));\n+    if (vertexBuffer == NULL) {\n+        return JNI_FALSE;\n+    }\n+\n+    unsigned short *indexBuffer = (unsigned short *) ((*env)->GetPrimitiveArrayCritical(env, ib, 0));\n+    if (indexBuffer == NULL) {\n+        (*env)->ReleasePrimitiveArrayCritical(env, vb, vertexBuffer, 0);\n+        return JNI_FALSE;\n+    }\n+\n+    bool result = [mesh buildBuffersShort:vertexBuffer\n+                                    vSize:uvbSize\n+                                  iBuffer:indexBuffer\n+                                    iSize:uibSize];\n+    (*env)->ReleasePrimitiveArrayCritical(env, ib, indexBuffer, 0);\n+    (*env)->ReleasePrimitiveArrayCritical(env, vb, vertexBuffer, 0);\n+\n+    return result;\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nBuildNativeGeometryInt\n+ * Signature: (JJ[FI[II)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_prism_mtl_MTLContext_nBuildNativeGeometryInt\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativeMesh,\n+    jfloatArray vb, jint vbSize, jintArray ib, jint ibSize)\n+{\n+    MetalMesh *mesh = (MetalMesh *) jlong_to_ptr(nativeMesh);\n+\n+    if (vbSize < 0 || ibSize < 0) {\n+        return JNI_FALSE;\n+    }\n+\n+    unsigned int uvbSize = (unsigned int) vbSize;\n+    unsigned int uibSize = (unsigned int) ibSize;\n+    unsigned int vertexBufferSize = (*env)->GetArrayLength(env, vb);\n+    unsigned int indexBufferSize = (*env)->GetArrayLength(env, ib);\n+\n+    if (uvbSize > vertexBufferSize || uibSize > indexBufferSize) {\n+        return JNI_FALSE;\n+    }\n+\n+    float *vertexBuffer = (float *) ((*env)->GetPrimitiveArrayCritical(env, vb, 0));\n+    if (vertexBuffer == NULL) {\n+        return JNI_FALSE;\n+    }\n+\n+    unsigned int *indexBuffer = (unsigned int *) ((*env)->GetPrimitiveArrayCritical(env, ib, 0));\n+    if (indexBuffer == NULL) {\n+        (*env)->ReleasePrimitiveArrayCritical(env, vb, vertexBuffer, 0);\n+        return JNI_FALSE;\n+    }\n+\n+    bool result = [mesh buildBuffersInt:vertexBuffer\n+                                  vSize:uvbSize\n+                                iBuffer:indexBuffer\n+                                  iSize:uibSize];\n+    (*env)->ReleasePrimitiveArrayCritical(env, ib, indexBuffer, 0);\n+    (*env)->ReleasePrimitiveArrayCritical(env, vb, vertexBuffer, 0);\n+\n+    return result;\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nCreateMTLPhongMaterial\n+ * Signature: (J)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_prism_mtl_MTLContext_nCreateMTLPhongMaterial\n+    (JNIEnv *env, jclass jClass, jlong ctx)\n+{\n+    MetalContext *pCtx = (MetalContext*) jlong_to_ptr(ctx);\n+    MetalPhongMaterial *phongMaterial = ([[MetalPhongMaterial alloc] createPhongMaterial:pCtx]);\n+    return ptr_to_jlong(phongMaterial);\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nReleaseMTLPhongMaterial\n+ * Signature: (JJ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nReleaseMTLPhongMaterial\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativePhongMaterial)\n+{\n+    MetalPhongMaterial *phongMaterial = (MetalPhongMaterial *) jlong_to_ptr(nativePhongMaterial);\n+    if (phongMaterial != nil) {\n+        [phongMaterial release];\n+        phongMaterial = nil;\n+    }\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetDiffuseColor\n+ * Signature: (JJFFFF)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetDiffuseColor\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativePhongMaterial,\n+    jfloat r, jfloat g, jfloat b, jfloat a)\n+{\n+    MetalPhongMaterial *phongMaterial = (MetalPhongMaterial *) jlong_to_ptr(nativePhongMaterial);\n+    [phongMaterial setDiffuseColor:r g:g b:b a:a];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetSpecularColor\n+ * Signature: (JJZFFFF)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetSpecularColor\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativePhongMaterial,\n+    jboolean set, jfloat r, jfloat g, jfloat b, jfloat a)\n+{\n+    MetalPhongMaterial *phongMaterial = (MetalPhongMaterial *) jlong_to_ptr(nativePhongMaterial);\n+    bool specularSet = set ? true : false;\n+    [phongMaterial setSpecularColor:specularSet r:r g:g b:b a:a];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetMap\n+ * Signature: (JJIJ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetMap\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativePhongMaterial,\n+    jint mapType, jlong nativeTexture)\n+{\n+    MetalPhongMaterial *phongMaterial = (MetalPhongMaterial *) jlong_to_ptr(nativePhongMaterial);\n+    MetalTexture *texMap = (MetalTexture *)  jlong_to_ptr(nativeTexture);\n+\n+    [phongMaterial setMap:mapType map:[texMap getTexture]];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nCreateMTLMeshView\n+ * Signature: (JJ)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_prism_mtl_MTLContext_nCreateMTLMeshView\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativeMesh)\n+{\n+    MetalContext *pCtx = (MetalContext*) jlong_to_ptr(ctx);\n+\n+    MetalMesh *pMesh = (MetalMesh *) jlong_to_ptr(nativeMesh);\n+\n+    MetalMeshView* meshView = ([[MetalMeshView alloc] createMeshView:pCtx\n+                                                                mesh:pMesh]);\n+    return ptr_to_jlong(meshView);\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nReleaseMTLMeshView\n+ * Signature: (JJ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nReleaseMTLMeshView\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativeMeshView)\n+{\n+    MetalMeshView *meshView = (MetalMeshView *) jlong_to_ptr(nativeMeshView);\n+    if (meshView != nil) {\n+        [meshView release];\n+        meshView = nil;\n+    }\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetCullingMode\n+ * Signature: (JJI)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetCullingMode\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativeMeshView, jint cullMode)\n+{\n+    MetalMeshView *meshView = (MetalMeshView *) jlong_to_ptr(nativeMeshView);\n+\n+    switch (cullMode) {\n+        case com_sun_prism_mtl_MTLContext_CULL_BACK:\n+            cullMode = MTLCullModeBack;\n+            break;\n+        case com_sun_prism_mtl_MTLContext_CULL_FRONT:\n+            cullMode = MTLCullModeFront;\n+            break;\n+        case com_sun_prism_mtl_MTLContext_CULL_NONE:\n+            cullMode = MTLCullModeNone;\n+            break;\n+    }\n+    [meshView setCullingMode:cullMode];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetMaterial\n+ * Signature: (JJJ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetMaterial\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativeMeshView, jlong nativePhongMaterial)\n+{\n+    MetalMeshView *meshView = (MetalMeshView *) jlong_to_ptr(nativeMeshView);\n+\n+    MetalPhongMaterial *phongMaterial = (MetalPhongMaterial *) jlong_to_ptr(nativePhongMaterial);\n+    [meshView setMaterial:phongMaterial];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetWireframe\n+ * Signature: (JJZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetWireframe\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativeMeshView, jboolean wireframe)\n+{\n+    MetalMeshView *meshView = (MetalMeshView *) jlong_to_ptr(nativeMeshView);\n+    bool isWireFrame = wireframe ? true : false;\n+    [meshView setWireframe:isWireFrame];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetAmbientLight\n+ * Signature: (JJFFF)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetAmbientLight\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativeMeshView,\n+    jfloat r, jfloat g, jfloat b)\n+{\n+    MetalMeshView *meshView = (MetalMeshView *) jlong_to_ptr(nativeMeshView);\n+    [meshView setAmbientLight:r g:g b:b];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetLight\n+ * Signature: (JJIFFFFFFFFFFFFFFFFFF)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetLight\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativeMeshView, jint index,\n+    jfloat x, jfloat y, jfloat z, jfloat r, jfloat g, jfloat b, jfloat w,\n+    jfloat ca, jfloat la, jfloat qa, jfloat isAttenuated, jfloat range,\n+    jfloat dirX, jfloat dirY, jfloat dirZ, jfloat innerAngle, jfloat outerAngle, jfloat falloff)\n+{\n+    MetalMeshView *meshView = (MetalMeshView *) jlong_to_ptr(nativeMeshView);\n+    [meshView setLight:index\n+        x:x y:y z:z\n+        r:r g:g b:b w:w\n+        ca:ca la:la qa:qa\n+        isA:isAttenuated range:range\n+        dirX:dirX dirY:dirY dirZ:dirZ\n+        inA:innerAngle outA:outerAngle\n+        falloff:falloff];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nRenderMeshView\n+ * Signature: (JJ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nRenderMeshView\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong nativeMeshView)\n+{\n+    MetalContext *pCtx = (MetalContext*) jlong_to_ptr(ctx);\n+    MetalMeshView *meshView = (MetalMeshView *) jlong_to_ptr(nativeMeshView);\n+    [pCtx renderMeshView:meshView];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nIsCurrentRTT\n+ * Signature: (JJ[[)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_prism_mtl_MTLContext_nIsCurrentRTT\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong texPtr)\n+{\n+    MetalContext *pCtx = (MetalContext*)jlong_to_ptr(ctx);\n+    MetalRTTexture *rttPtr = (MetalRTTexture *)jlong_to_ptr(texPtr);\n+    return [pCtx isCurrentRTT:rttPtr];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nBlit\n+ * Signature: (JJJIIIIIIII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nBlit\n+    (JNIEnv *env, jclass jclass, jlong ctx, jlong nSrcRTT, jlong nDstRTT,\n+    jint srcX0, jint srcY0, jint srcX1, jint srcY1,\n+    jint dstX0, jint dstY0, jint dstX1, jint dstY1)\n+{\n+    MetalContext *pCtx = (MetalContext*)jlong_to_ptr(ctx);\n+    MetalRTTexture *srcRTT = (MetalRTTexture *)jlong_to_ptr(nSrcRTT);\n+    MetalRTTexture *dstRTT = (MetalRTTexture *)jlong_to_ptr(nDstRTT);\n+\n+    id<MTLTexture> src = [srcRTT getTexture];\n+    id<MTLTexture> dst = [dstRTT getTexture];\n+\n+    [pCtx blit:src srcX0:srcX0 srcY0:srcY0 srcX1:srcX1 srcY1:srcY1\n+        dstTex:dst dstX0:dstX0 dstY0:dstY0 dstX1:dstX1 dstY1:dstY1];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetCameraPosition\n+ * Signature: (JDDD)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetCameraPosition\n+    (JNIEnv *env, jclass jClass, jlong ctx,\n+    jdouble x, jdouble y, jdouble z)\n+{\n+    MetalContext *pCtx = (MetalContext*)jlong_to_ptr(ctx);\n+    [pCtx setCameraPosition:x y:y z:z];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nSetCompositeMode\n+ * Signature: (JI)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLContext_nSetCompositeMode(\n+    JNIEnv *env, jclass jClass, jlong context, jint mode)\n+{\n+    MetalContext* pCtx = (MetalContext*)jlong_to_ptr(context);\n+    [pCtx setCompositeMode:mode];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLContext\n+ * Method:    nGetCommandQueue\n+ * Signature: (J)J\n+ *\/\n+\/\/ This enables sharing of MTLCommandQueue between PRISM and GLASS, if needed.\n+JNIEXPORT jlong JNICALL Java_com_sun_prism_mtl_MTLContext_nGetCommandQueue\n+    (JNIEnv *env, jclass jClass, jlong context)\n+{\n+    MetalContext *contextPtr = (MetalContext *)jlong_to_ptr(context);\n+    jlong jPtr = ptr_to_jlong((void *)[contextPtr getCommandQueue]);\n+    return jPtr;\n+}\n+\n+\/\/ MTLGraphics methods\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLGraphics\n+ * Method:    nClear\n+ * Signature: (JFFFFZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLGraphics_nClear\n+    (JNIEnv *env, jclass jClass, jlong ctx,\n+    jfloat red, jfloat green, jfloat blue, jfloat alpha, jboolean clearDepth)\n+{\n+    MetalContext* context = (MetalContext*)jlong_to_ptr(ctx);\n+    [context clearRTT:red\n+                green:green\n+                 blue:blue\n+                alpha:alpha\n+           clearDepth:clearDepth];\n+}\n+\n+\n+\/\/ MTLResourceFactory methods\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLResourceFactory\n+ * Method:    nCreateTexture\n+ * Signature: (JIIZIIIZ)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_prism_mtl_MTLResourceFactory_nCreateTexture\n+    (JNIEnv *env, jclass class, jlong pContext, jint format, jint hint,\n+    jboolean isRTT, jint width, jint height, jint samples, jboolean useMipmap)\n+{\n+    MetalContext* context = (MetalContext*)jlong_to_ptr(pContext);\n+    jlong rtt = ptr_to_jlong([[MetalTexture alloc] createTexture:context\n+                                                         ofWidth:width\n+                                                        ofHeight:height\n+                                                     pixelFormat:format\n+                                                       useMipMap:useMipmap]);\n+    return rtt;\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLResourceFactory\n+ * Method:    nReleaseTexture\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLResourceFactory_nReleaseTexture\n+    (JNIEnv *env, jclass class, jlong pTexture)\n+{\n+    MetalTexture* pTex = (MetalTexture*)jlong_to_ptr(pTexture);\n+    [pTex release];\n+    pTex = nil;\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalContext.m","additions":1555,"deletions":0,"binary":false,"changes":1555,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef METAL_LIGHT_H\n+#define METAL_LIGHT_H\n+\n+#import <Foundation\/Foundation.h>\n+\n+@interface MetalLight : NSObject\n+{\n+    @public\n+    float position[3];\n+    float color[3];\n+    float lightOn;\n+    float attenuation[4]; \/\/ ca, la, qa, isAttenuated\n+    float maxRange;\n+    float direction[3];\n+    float inAngle;\n+    float outAngle;\n+    float falloff;\n+}\n+\n+- (MetalLight*) createLight:(float)x y:(float)y z:(float)z\n+            r:(float)r g:(float)g b:(float)b w:(float)w\n+            ca:(float)ca la:(float)la qa:(float)qa\n+            isA:(float)isAttenuated range:(float)range\n+            dirX:(float)dirX dirY:(float)dirY dirZ:(float)dirZ\n+            inA:(float)innerAngle outA:(float)outerAngle\n+            falloff:(float)fall_off;\n+\n+- (bool) isPointLight;\n+- (bool) isDirectionalLight;\n+\n+@end\n+\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalLight.h","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MetalLight.h\"\n+\n+@implementation MetalLight\n+\n+- (MetalLight*) createLight:(float)x y:(float)y z:(float)z\n+            r:(float)r g:(float)g b:(float)b w:(float)w\n+            ca:(float)ca la:(float)la qa:(float)qa\n+            isA:(float)isAttenuated range:(float)range\n+            dirX:(float)dirX dirY:(float)dirY dirZ:(float)dirZ\n+            inA:(float)innerAngle outA:(float)outerAngle\n+            falloff:(float)fall_off\n+{\n+    self = [super init];\n+    if (self) {\n+        position[0] = x;\n+        position[1] = y;\n+        position[2] = z;\n+        color[0] = r;\n+        color[1] = g;\n+        color[2] = b;\n+        lightOn  = w;\n+        attenuation[0] = ca;\n+        attenuation[1] = la;\n+        attenuation[2] = qa;\n+        attenuation[3] = isAttenuated;\n+        maxRange = range;\n+        direction[0] = dirX;\n+        direction[1] = dirY;\n+        direction[2] = dirZ;\n+        inAngle  = innerAngle;\n+        outAngle = outerAngle;\n+        falloff  = fall_off;\n+    }\n+    return self;\n+}\n+\n+- (bool) isPointLight\n+{\n+    return falloff == 0.0f && outAngle == 180.0f && attenuation[3] > 0.5f;\n+}\n+\n+- (bool) isDirectionalLight\n+{\n+    \/\/ Testing if attenuation.w is 0 or 1 using < 0.5f,\n+    \/\/ since equality check for floating points might not work well\n+    return attenuation[3] < 0.5f;\n+}\n+\n+@end \/\/ MetalLight\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalLight.m","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef METAL_MESH_H\n+#define METAL_MESH_H\n+\n+#import \"MetalContext.h\"\n+\n+#define NUM_OF_FLOATS_PER_VERTEX 9\n+#define MESH_INDEX_LIMIT 9000000\n+\n+@interface MetalMesh : NSObject\n+{\n+    MetalContext *context;\n+    id<MTLBuffer> indexBuffer[3];\n+    id<MTLBuffer> vertexBuffer[3];\n+    NSUInteger numVertices;\n+    NSUInteger numIndices;\n+    NSUInteger indexType;\n+}\n+\n+- (id) createMesh:(MetalContext*)ctx;\n+- (bool) buildBuffersShort:(float*)vb\n+                     vSize:(unsigned int)vbSize\n+                   iBuffer:(unsigned short*)ib\n+                     iSize:(unsigned int)ibSize;\n+- (bool) buildBuffersInt:(float*)vb\n+                   vSize:(unsigned int)vbSize\n+                 iBuffer:(unsigned int*)ib\n+                   iSize:(unsigned int)ibSize;\n+- (void) release;\n+- (void) createVertexBuffer:(unsigned int)size;\n+- (void) releaseVertexBuffer;\n+- (void) createIndexBuffer:(unsigned int)size;\n+- (void) releaseIndexBuffer;\n+- (id<MTLBuffer>) getVertexBuffer;\n+- (id<MTLBuffer>) getIndexBuffer;\n+- (NSUInteger) getNumVertices;\n+- (NSUInteger) getNumIndices;\n+- (NSUInteger) getIndexType;\n+@end\n+\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalMesh.h","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MetalMesh.h\"\n+\n+typedef struct\n+{\n+    vector_float4 position;\n+    vector_float4 color;\n+} MBEVertex;\n+\n+@implementation MetalMesh\n+\n+- (id) createMesh:(MetalContext*)ctx\n+{\n+    self = [super init];\n+    if (self) {\n+        context = ctx;\n+        numVertices = 0;\n+        numIndices = 0;\n+        indexType = MTLIndexTypeUInt16;\n+    }\n+    return self;\n+}\n+\n+- (bool) buildBuffersShort:(float*)vb\n+                     vSize:(unsigned int)vbSize\n+                   iBuffer:(unsigned short*)ib\n+                     iSize:(unsigned int)ibSize\n+{\n+    id<MTLDevice> device = [context getDevice];\n+    unsigned int size = vbSize * sizeof (float);\n+    unsigned int vbCount = vbSize \/ NUM_OF_FLOATS_PER_VERTEX;\n+\n+    if (numVertices != vbCount) {\n+        [self releaseVertexBuffer];\n+        [self createVertexBuffer:size];\n+        numVertices = vbCount;\n+    }\n+\n+    NSUInteger currentIndex = [context getCurrentBufferIndex];\n+    if (vertexBuffer[currentIndex] != nil) {\n+        memcpy(vertexBuffer[currentIndex].contents, vb, size);\n+    }\n+\n+    size = ibSize * sizeof (unsigned short);\n+    if (numIndices != ibSize) {\n+        [self releaseIndexBuffer];\n+        [self createIndexBuffer:size];\n+        numIndices = ibSize;\n+    }\n+\n+    if (indexBuffer[currentIndex] != nil) {\n+        memcpy(indexBuffer[currentIndex].contents, ib, size);\n+    }\n+    indexType = MTLIndexTypeUInt16;\n+    return true;\n+}\n+\n+- (bool) buildBuffersInt:(float*)vb\n+                   vSize:(unsigned int)vbSize\n+                 iBuffer:(unsigned int*)ib\n+                   iSize:(unsigned int)ibSize\n+{\n+    id<MTLDevice> device = [context getDevice];\n+    unsigned int size = vbSize * sizeof (float);\n+    unsigned int vbCount = vbSize \/ NUM_OF_FLOATS_PER_VERTEX;\n+\n+    if (numVertices != vbCount) {\n+        [self releaseVertexBuffer];\n+        [self createVertexBuffer:size];\n+        numVertices = vbCount;\n+    }\n+\n+    NSUInteger currentIndex = [context getCurrentBufferIndex];\n+    if (vertexBuffer[currentIndex] != nil) {\n+        memcpy(vertexBuffer[currentIndex].contents, vb, size);\n+    }\n+\n+    size = ibSize * sizeof (unsigned int);\n+    if (numIndices != ibSize) {\n+        [self releaseIndexBuffer];\n+        [self createIndexBuffer:size];\n+        numIndices = ibSize;\n+    }\n+\n+    if (indexBuffer[currentIndex] != nil) {\n+        memcpy(indexBuffer[currentIndex].contents, ib, size);\n+    }\n+\n+    indexType = MTLIndexTypeUInt32;\n+    return true;\n+}\n+\n+- (void) release\n+{\n+    [self releaseVertexBuffer];\n+    [self releaseIndexBuffer];\n+    context = nil;\n+}\n+\n+- (void) createVertexBuffer:(unsigned int)size;\n+{\n+    id<MTLDevice> device = [context getDevice];\n+    for (int i = 0; i < BUFFER_SIZE; i++) {\n+        vertexBuffer[i] = [device newBufferWithLength:size\n+            options:MTLResourceStorageModeShared];\n+    }\n+}\n+\n+- (void) releaseVertexBuffer\n+{\n+    for (int i = 0; i < BUFFER_SIZE; i++) {\n+        vertexBuffer[i] = nil;\n+    }\n+    numVertices = 0;\n+}\n+\n+- (void) createIndexBuffer:(unsigned int)size;\n+{\n+    id<MTLDevice> device = [context getDevice];\n+    for (int i = 0; i < BUFFER_SIZE; i++) {\n+        indexBuffer[i] = [device newBufferWithLength:size\n+            options:MTLResourceStorageModeShared];\n+    }\n+}\n+\n+- (void) releaseIndexBuffer\n+{\n+    for (int i = 0; i < BUFFER_SIZE; i++) {\n+        indexBuffer[i] = nil;\n+    }\n+    numIndices = 0;\n+}\n+\n+- (id<MTLBuffer>) getVertexBuffer\n+{\n+    return vertexBuffer[[context getCurrentBufferIndex]];\n+}\n+\n+- (id<MTLBuffer>) getIndexBuffer\n+{\n+    return indexBuffer[[context getCurrentBufferIndex]];\n+}\n+\n+- (NSUInteger) getNumVertices\n+{\n+    return numVertices;\n+}\n+\n+- (NSUInteger) getNumIndices\n+{\n+    return numIndices;\n+}\n+\n+- (NSUInteger) getIndexType\n+{\n+    return indexType;\n+}\n+@end \/\/ MetalMesh\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalMesh.m","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef METAL_MESHVIEW_H\n+#define METAL_MESHVIEW_H\n+\n+#import \"MetalContext.h\"\n+#import \"MetalMesh.h\"\n+#import \"MetalLight.h\"\n+#import \"MetalPhongMaterial.h\"\n+\n+#define MAX_NUM_LIGHTS 3\n+\n+typedef struct VS_PHONG_UNIFORMS {\n+    simd_float4x4 mvp_matrix;\n+    simd_float4x4 world_matrix;\n+    packed_float4 cameraPos;\n+    float lightsPosition[MAX_NUM_LIGHTS * 3];\n+    float lightsNormDirection[MAX_NUM_LIGHTS * 3];\n+    float numLights;\n+} VS_PHONG_UNIFORMS;\n+\n+typedef struct PS_PHONG_UNIFORMS {\n+    packed_float4 diffuseColor;\n+    packed_float4 ambientLightColor;\n+    packed_float4 specColor;\n+    float lightsColor[MAX_NUM_LIGHTS * 4];\n+    float lightsAttenuation[MAX_NUM_LIGHTS * 4];\n+    float lightsRange[MAX_NUM_LIGHTS * 4];\n+    float spotLightsFactors[MAX_NUM_LIGHTS * 4];\n+    int numLights;\n+    int specType;\n+    bool isBumpMap;\n+    bool isIlluminated;\n+} PS_PHONG_UNIFORMS;\n+\n+@interface MetalMeshView : NSObject\n+{\n+    MetalContext* context;\n+    MetalMesh* mesh;\n+    MetalPhongMaterial *material;\n+    MetalLight* lights[MAX_NUM_LIGHTS];\n+    vector_float4 ambientLightColor;\n+    int numLights;\n+    bool lightsDirty;\n+    int cullMode;\n+    bool wireframe;\n+\n+    VS_PHONG_UNIFORMS vsUniforms;\n+    PS_PHONG_UNIFORMS psUniforms;\n+}\n+\n+- (MetalMeshView*) createMeshView:(MetalContext*)ctx\n+                             mesh:(MetalMesh*)mtlMesh;\n+- (void) setMaterial:(MetalPhongMaterial*)pMaterial;\n+- (void) setCullingMode:(int)cMode;\n+- (void) setWireframe:(bool)isWireFrame;\n+- (void) setAmbientLight:(float)r\n+                       g:(float)g\n+                       b:(float)b;\n+- (void) computeNumLights;\n+- (void) setLight:(int)index\n+        x:(float)x y:(float)y z:(float)z\n+        r:(float)r g:(float)g b:(float)b w:(float)w\n+        ca:(float)ca la:(float)la qa:(float)qa\n+        isA:(float)isAttenuated range:(float)range\n+        dirX:(float)dirX dirY:(float)dirY dirZ:(float)dirZ\n+        inA:(float)innerAngle outA:(float)outerAngle\n+        falloff:(float)fall_off;\n+\n+- (MetalMesh*) getMesh;\n+- (int) getCullingMode;\n+- (void) render;\n+- (void) release;\n+@end\n+\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalMeshView.h","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MetalMeshView.h\"\n+#import \"MetalPipelineManager.h\"\n+\n+@implementation MetalMeshView\n+\n+- (MetalMeshView*) createMeshView:(MetalContext*)ctx\n+                             mesh:(MetalMesh*)mtlMesh\n+{\n+    self = [super init];\n+    if (self) {\n+        context = ctx;\n+        mesh = mtlMesh;\n+        material = nil;\n+        ambientLightColor.x = 0;\n+        ambientLightColor.y = 0;\n+        ambientLightColor.z = 0;\n+        ambientLightColor.w = 0;\n+        numLights = 0;\n+        lightsDirty = TRUE;\n+        cullMode = MTLCullModeBack;\n+        wireframe = FALSE;\n+    }\n+    return self;\n+}\n+\n+- (void) setMaterial:(MetalPhongMaterial*)pMaterial\n+{\n+    material = pMaterial;\n+}\n+\n+- (void) setCullingMode:(int)cMode\n+{\n+    cullMode = cMode;\n+}\n+\n+- (void) setWireframe:(bool)isWireFrame\n+{\n+    wireframe = isWireFrame;\n+}\n+\n+- (void) setAmbientLight:(float)r\n+                       g:(float)g\n+                       b:(float)b\n+{\n+    ambientLightColor.x = r;\n+    ambientLightColor.y = g;\n+    ambientLightColor.z = b;\n+    ambientLightColor.w = 1;\n+}\n+\n+- (void) computeNumLights\n+{\n+    if (!lightsDirty)\n+        return;\n+    lightsDirty = false;\n+\n+    int n = 0;\n+    for (int i = 0; i != MAX_NUM_LIGHTS; ++i) {\n+        n += lights[i]->lightOn ? 1 : 0;\n+    }\n+\n+    numLights = n;\n+}\n+\n+- (void) setLight:(int)index\n+        x:(float)x y:(float)y z:(float)z\n+        r:(float)r g:(float)g b:(float)b w:(float)w\n+        ca:(float)ca la:(float)la qa:(float)qa\n+        isA:(float)isAttenuated range:(float)range\n+        dirX:(float)dirX dirY:(float)dirY dirZ:(float)dirZ\n+        inA:(float)innerAngle outA:(float)outerAngle\n+        falloff:(float)fall_off\n+{\n+    \/\/ NOTE: We only support up to 3 point lights at the present\n+    if (index >= 0 && index <= MAX_NUM_LIGHTS - 1) {\n+        if (lights[index] == nil) {\n+            MetalLight* light = ([[MetalLight alloc] createLight:x y:y z:z\n+            r:r g:g b:b w:w\n+            ca:ca la:la qa:qa\n+            isA:isAttenuated range:range\n+            dirX:dirX dirY:dirY dirZ:dirZ\n+            inA:innerAngle outA:outerAngle\n+            falloff:fall_off]);\n+            lights[index] = light;\n+        } else {\n+            lights[index]->position[0] = x;\n+            lights[index]->position[1] = y;\n+            lights[index]->position[2] = z;\n+            lights[index]->color[0] = r;\n+            lights[index]->color[1] = g;\n+            lights[index]->color[2] = b;\n+            lights[index]->lightOn = w;\n+            lights[index]->attenuation[0] = ca;\n+            lights[index]->attenuation[1] = la;\n+            lights[index]->attenuation[2] = qa;\n+            lights[index]->attenuation[3] = isAttenuated;\n+            lights[index]->maxRange = range;\n+            lights[index]->direction[0] = dirX;\n+            lights[index]->direction[1] = dirY;\n+            lights[index]->direction[2] = dirZ;\n+            lights[index]->inAngle = innerAngle;\n+            lights[index]->outAngle = outerAngle;\n+            lights[index]->falloff = fall_off;\n+        }\n+        lightsDirty = TRUE;\n+    }\n+}\n+\n+- (MetalMesh*) getMesh\n+{\n+    return mesh;\n+}\n+\n+- (int) getCullingMode\n+{\n+    return cullMode;\n+}\n+\n+- (void) render\n+{\n+    [self computeNumLights];\n+\n+    for (int i = 0, d = 0, p = 0, c = 0, a = 0, r = 0, s = 0; i < numLights; i++) {\n+        MetalLight* light = lights[i];\n+\n+        vsUniforms.lightsPosition[p++] = light->position[0];\n+        vsUniforms.lightsPosition[p++] = light->position[1];\n+        vsUniforms.lightsPosition[p++] = light->position[2];\n+\n+        vsUniforms.lightsNormDirection[d++] = light->direction[0];\n+        vsUniforms.lightsNormDirection[d++] = light->direction[1];\n+        vsUniforms.lightsNormDirection[d++] = light->direction[2];\n+\n+        psUniforms.lightsColor[c++] = light->color[0];\n+        psUniforms.lightsColor[c++] = light->color[1];\n+        psUniforms.lightsColor[c++] = light->color[2];\n+        psUniforms.lightsColor[c++] = 1;\n+\n+        psUniforms.lightsAttenuation[a++] = light->attenuation[0];\n+        psUniforms.lightsAttenuation[a++] = light->attenuation[1];\n+        psUniforms.lightsAttenuation[a++] = light->attenuation[2];\n+        psUniforms.lightsAttenuation[a++] = light->attenuation[3];\n+\n+        psUniforms.lightsRange[r++] = light->maxRange;\n+        psUniforms.lightsRange[r++] = 0;\n+        psUniforms.lightsRange[r++] = 0;\n+        psUniforms.lightsRange[r++] = 0;\n+\n+        if ([light isPointLight] || [light isDirectionalLight]) {\n+            psUniforms.spotLightsFactors[s++] = -1; \/\/ cos(180)\n+            psUniforms.spotLightsFactors[s++] = 2;  \/\/ cos(0) - cos(180)\n+            psUniforms.spotLightsFactors[s++] = 0;\n+            psUniforms.spotLightsFactors[s++] = 0;\n+        } else {\n+            \/\/ preparing for: I = pow((cosAngle - cosOuter) \/ (cosInner - cosOuter), falloff)\n+            float cosInner = cos(light->inAngle * M_PI \/ 180);\n+            float cosOuter = cos(light->outAngle * M_PI \/ 180);\n+            psUniforms.spotLightsFactors[s++] = cosOuter;\n+            psUniforms.spotLightsFactors[s++] = cosInner - cosOuter;\n+            psUniforms.spotLightsFactors[s++] = light->falloff;\n+            psUniforms.spotLightsFactors[s++] = 0;\n+        }\n+    }\n+\n+    id<MTLRenderCommandEncoder> phongEncoder = [context getCurrentRenderEncoder];\n+    [phongEncoder setRenderPipelineState:[context getPhongPipelineStateWithNumLights:numLights]];\n+    id<MTLDepthStencilState> depthStencilState =\n+        [[context getPipelineManager] getDepthStencilState];\n+    [phongEncoder setDepthStencilState:depthStencilState];\n+    \/\/ In Metal default winding order is Clockwise but the vertex data that\n+    \/\/ we are getting is in CounterClockWise order, so we need to set\n+    \/\/ MTLWindingCounterClockwise explicitly\n+    [phongEncoder setFrontFacingWinding:MTLWindingCounterClockwise];\n+    [phongEncoder setCullMode:cullMode];\n+    if (wireframe) {\n+        [phongEncoder setTriangleFillMode:MTLTriangleFillModeLines];\n+    } else {\n+        [phongEncoder setTriangleFillMode:MTLTriangleFillModeFill];\n+    }\n+    [phongEncoder setScissorRect:[context getScissorRect]];\n+    vsUniforms.mvp_matrix = [context getMVPMatrix];\n+    vsUniforms.world_matrix = [context getWorldMatrix];\n+    vsUniforms.cameraPos = [context getCameraPosition];\n+    vsUniforms.numLights = numLights;\n+    id<MTLBuffer> vBuffer = [mesh getVertexBuffer];\n+    [phongEncoder setVertexBuffer:vBuffer\n+                           offset:0\n+                            atIndex:0];\n+    [phongEncoder setVertexBytes:&vsUniforms\n+                               length:sizeof(vsUniforms)\n+                              atIndex:1];\n+    psUniforms.diffuseColor = [material getDiffuseColor];\n+    psUniforms.ambientLightColor = ambientLightColor;\n+    psUniforms.specColor = [material getSpecularColor];\n+\n+    psUniforms.numLights = numLights;\n+    psUniforms.specType = [material getSpecType];\n+    psUniforms.isBumpMap = [material isBumpMap] ? true : false;\n+    psUniforms.isIlluminated = [material isSelfIllumMap] ? true : false;\n+\n+    [phongEncoder setFragmentBytes:&psUniforms\n+                                length:sizeof(psUniforms)\n+                                atIndex:0];\n+    [phongEncoder setFragmentTexture:[material getMap:DIFFUSE]\n+                             atIndex:0];\n+    [phongEncoder setFragmentTexture:[material getMap:SPECULAR]\n+                             atIndex:1];\n+    [phongEncoder setFragmentTexture:[material getMap:BUMP]\n+                             atIndex:2];\n+    [phongEncoder setFragmentTexture:[material getMap:SELFILLUMINATION]\n+                             atIndex:3];\n+\n+    [phongEncoder drawIndexedPrimitives:MTLPrimitiveTypeTriangle\n+        indexCount:[mesh getNumIndices]\n+        indexType:[mesh getIndexType]\n+        indexBuffer:[mesh getIndexBuffer]\n+        indexBufferOffset:0];\n+}\n+\n+- (void) release\n+{\n+    for (int i = 0; i < MAX_NUM_LIGHTS; i++) {\n+        if (lights[i] != nil) {\n+            [lights[i] release];\n+            lights[i] = nil;\n+        }\n+    }\n+}\n+\n+@end \/\/ MetalMeshView\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalMeshView.m","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef METAL_PHONGMATERIAL_H\n+#define METAL_PHONGMATERIAL_H\n+\n+#import \"MetalContext.h\"\n+\n+#define DIFFUSE 0\n+#define SPECULAR 1\n+#define BUMP 2\n+#define SELFILLUMINATION 3\n+\n+#define SPEC_NONE 0\n+#define SPEC_TEX 1\n+#define SPEC_CLR 2\n+#define SPEC_MIX 3\n+\n+@interface MetalPhongMaterial : NSObject\n+{\n+    MetalContext* context;\n+    vector_float4 diffuseColor;\n+    vector_float4 specularColor;\n+    bool specularColorSet;\n+    id<MTLTexture> map[4];\n+}\n+\n+- (MetalPhongMaterial*) createPhongMaterial:(MetalContext*)ctx;\n+- (void) setDiffuseColor:(float)r\n+                       g:(float)g\n+                       b:(float)b\n+                       a:(float)a;\n+- (void) setSpecularColor:(bool)set\n+                        r:(float)r\n+                        g:(float)g\n+                        b:(float)b\n+                        a:(float)a;\n+\n+- (vector_float4) getDiffuseColor;\n+- (vector_float4) getSpecularColor;\n+- (bool) isSpecularMap;\n+- (bool) isSpecularColor;\n+- (bool) isBumpMap;\n+- (int)  getSpecType;\n+- (bool) isSelfIllumMap;\n+- (void) setMap:(int)mapID\n+            map:(id<MTLTexture>)texMap;\n+- (id<MTLTexture>) getMap:(int)mapID;\n+@end\n+\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalPhongMaterial.h","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MetalPhongMaterial.h\"\n+\n+@implementation MetalPhongMaterial\n+\n+- (MetalPhongMaterial*) createPhongMaterial:(MetalContext*)ctx\n+{\n+    self = [super init];\n+    if (self) {\n+        context = ctx;\n+        diffuseColor.x = 0;\n+        diffuseColor.y = 0;\n+        diffuseColor.z = 0;\n+        diffuseColor.w = 0;\n+        specularColorSet = false;\n+        specularColor.x = 1;\n+        specularColor.y = 1;\n+        specularColor.z = 1;\n+        specularColor.w = 32;\n+        map[DIFFUSE] = nil;\n+        map[SPECULAR] = nil;\n+        map[BUMP] = nil;\n+        map[SELFILLUMINATION] = nil;\n+    }\n+    return self;\n+}\n+\n+- (void) setDiffuseColor:(float)r\n+                       g:(float)g\n+                       b:(float)b\n+                       a:(float)a\n+{\n+    diffuseColor.x = r;\n+    diffuseColor.y = g;\n+    diffuseColor.z = b;\n+    diffuseColor.w = a;\n+}\n+\n+- (void) setSpecularColor:(bool)set\n+                        r:(float)r\n+                        g:(float)g\n+                        b:(float)b\n+                        a:(float)a\n+{\n+    specularColorSet = set;\n+    specularColor.x = r;\n+    specularColor.y = g;\n+    specularColor.z = b;\n+    specularColor.w = a;\n+}\n+\n+- (vector_float4) getDiffuseColor\n+{\n+    return diffuseColor;\n+}\n+\n+- (vector_float4) getSpecularColor\n+{\n+    return specularColor;\n+}\n+\n+- (bool) isSpecularMap\n+{\n+    return map[SPECULAR] ? true : false;\n+}\n+\n+- (bool) isSpecularColor\n+{\n+    return specularColorSet;\n+}\n+\n+- (int) getSpecType\n+{\n+    if ([self isSpecularMap]) {\n+        return [self isSpecularColor] ? SPEC_MIX : SPEC_TEX;\n+    }\n+    return [self isSpecularColor] ? SPEC_CLR : SPEC_NONE;\n+}\n+\n+- (bool) isBumpMap\n+{\n+    return map[BUMP] ? true : false;\n+}\n+\n+- (bool) isSelfIllumMap\n+{\n+    return map[SELFILLUMINATION] ? true : false;\n+}\n+\n+- (void) setMap:(int)mapID\n+            map:(id<MTLTexture>)texMap\n+{\n+    \/\/ Within the range of DIFFUSE, SPECULAR, BUMP, SELFILLUMINATION\n+    if (mapID >= 0 && mapID <= 3) {\n+        map[mapID] = texMap;\n+    } else {\n+        NSLog(@\"MetalPhongMaterial.setMap(): mapID is out of range\");\n+    }\n+}\n+\n+- (id<MTLTexture>) getMap:(int)mapID\n+{\n+    \/\/ Within the range of DIFFUSE, SPECULAR, BUMP, SELFILLUMINATION\n+    if (mapID >= 0 && mapID <= 3) {\n+        return map[mapID];\n+    }\n+    NSLog(@\"MetalPhongMaterial.getMap(): mapID is out of range\");\n+    return nil;\n+}\n+@end \/\/ MetalPhongMaterial\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalPhongMaterial.m","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef METAL_PIPELINE_MANAGER_H\n+#define METAL_PIPELINE_MANAGER_H\n+\n+#import \"MetalContext.h\"\n+\n+\/**\n+ * native interface for the Java class MTLPipelineManager\n+ *\/\n+@interface MetalPipelineManager : NSObject\n+{\n+    id<MTLLibrary> shaderLib;\n+    id<MTLFunction> vertexFunction;\n+    MetalContext *context;\n+    NSMutableDictionary *clearRttPipeStateNoDepthDict;\n+    NSMutableDictionary *clearRttPipeStateDepthDict;\n+    NSMutableDictionary *phongPipelineStateNonMSAANoDepthDict;\n+    NSMutableDictionary *phongPipelineStateNonMSAADepthDict;\n+    NSMutableDictionary *phongPipelineStateMSAANoDepthDict;\n+    NSMutableDictionary *phongPipelineStateMSAADepthDict;\n+    id<MTLDepthStencilState> depthStencilState[2]; \/\/ [0] - disabled, [1] - enabled\n+    id<MTLComputePipelineState> uyvy422ToRGBAState;\n+}\n+\n+- (void) init:(MetalContext*)ctx\n+      libData:(dispatch_data_t)libData;\n+- (id<MTLFunction>) getFunction:(NSString*)funcName;\n+- (id<MTLRenderPipelineState>) getClearRttPipeState;\n+- (id<MTLRenderPipelineState>) getPipeStateWithFragFunc:(id<MTLFunction>)fragFunc\n+                                          compositeMode:(int)compositeMode;\n+- (id<MTLRenderPipelineState>) getPhongPipeStateWithNumLights:(int)numLights\n+                                                compositeMode:(int)compositeMode;\n+- (id<MTLComputePipelineState>) getComputePipelineStateWithFunc:(NSString*)funcName;\n+- (id<MTLDepthStencilState>) getDepthStencilState;\n+- (void) setPipelineCompositeBlendMode:(MTLRenderPipelineDescriptor*)pipeDesc\n+                         compositeMode:(int)compositeMode;\n+- (void) dealloc;\n+@end\n+\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalPipelineManager.h","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,366 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MetalPipelineManager.h\"\n+#import \"MetalRTTexture.h\"\n+#include \"com_sun_prism_mtl_MTLContext.h\"\n+\n+\/\/ ---------------------------- Debug helper for Developers -------------------------\n+\/\/\n+\/\/ This implementation is to utilize \"Metal Debuger\" present in Xcode.\n+\/\/ See - https:\/\/developer.apple.com\/documentation\/xcode\/capturing-a-metal-workload-programmatically\n+\/\/\n+\/\/ Limitation - Attaching to a java process and debugging frame by frame is not possible.\n+\/\/\n+\/\/ Currently, this debug helper can capture each frame related data to a file.\n+\/\/ It is configured to capture frame data from MTLDevice for entire lifetime of the application.\n+\/\/ This creates a trace file which is in GBs. So, please use this debug helper judiciously\n+\/\/ (i.e. with applications running for a short time and with less animation.)\n+\/\/ The generated trace file can be opened in Xcode and replayed.\n+\/\/\n+\/\/ If needed, this can be changed in future to capture only \"scope of interest\" as explained at -\n+\/\/ https:\/\/developer.apple.com\/documentation\/xcode\/creating-and-using-custom-capture-scopes\n+\/\/\n+\/\/ Prerequisites:\n+\/\/ 1. MacOS 14 (Sonoma)\n+\/\/ 2. On terminal, set environment variable MTL_CAPTURE_ENABLED=1.\n+\/\/\n+\/\/ Uncomment below line to capture Metal GPU Debug Trace to file GPUTraceFilename specified below.\n+\/\/#define JFX_MTL_DEBUG_CAPTURE\n+#ifdef JFX_MTL_DEBUG_CAPTURE\n+NSString *GPUTraceFilename = @\"file:\/\/\/tmp\/fx_metal.gputrace\";\n+#endif\n+\/\/ ---------------------------- Debug helper for Developers -------------------------\n+\n+@implementation MetalPipelineManager\n+\n+- (void) init:(MetalContext*)ctx\n+      libData:(dispatch_data_t)libData\n+{\n+    context = ctx;\n+    NSError *error = nil;\n+    shaderLib = [[context getDevice] newLibraryWithData:libData error:&error];\n+\n+    if (shaderLib != nil) {\n+        vertexFunction = [self getFunction:@\"passThrough\"];\n+    } else {\n+        NSLog(@\"MetalPipelineManager.init: Failed to create shader library\");\n+    }\n+\n+    clearRttPipeStateNoDepthDict = [[NSMutableDictionary alloc] init];\n+    clearRttPipeStateDepthDict = [[NSMutableDictionary alloc] init];\n+    phongPipelineStateNonMSAANoDepthDict = [[NSMutableDictionary alloc] init];\n+    phongPipelineStateNonMSAADepthDict = [[NSMutableDictionary alloc] init];\n+    phongPipelineStateMSAANoDepthDict = [[NSMutableDictionary alloc] init];\n+    phongPipelineStateMSAADepthDict = [[NSMutableDictionary alloc] init];\n+    uyvy422ToRGBAState = nil;\n+\n+    \/\/ Create and cache 2 possible depthStencilStates\n+    @autoreleasepool {\n+        MTLDepthStencilDescriptor *depthStencilDescriptor = [[MTLDepthStencilDescriptor new] autorelease];\n+        depthStencilDescriptor.depthCompareFunction = MTLCompareFunctionAlways;\n+        depthStencilDescriptor.depthWriteEnabled = NO;\n+        depthStencilState[0] = [[context getDevice] newDepthStencilStateWithDescriptor:depthStencilDescriptor];\n+\n+        depthStencilDescriptor.depthCompareFunction = MTLCompareFunctionLessEqual;\n+        depthStencilDescriptor.depthWriteEnabled = YES;\n+        depthStencilState[1] = [[context getDevice] newDepthStencilStateWithDescriptor:depthStencilDescriptor];\n+    }\n+#ifdef JFX_MTL_DEBUG_CAPTURE\n+\n+    if (@available(macOS 14, *)) {\n+        @autoreleasepool {\n+            NSLog(@\"JFX_MTL_DEBUG_CAPTURE is enabled\");\n+\n+            MTLCaptureManager* captureManager = [MTLCaptureManager sharedCaptureManager];\n+            if (![captureManager supportsDestination:MTLCaptureDestinationGPUTraceDocument]) {\n+                NSLog(@\"MTLCaptureDestinationGPUTraceDocument destination is not supported.\");\n+            } else {\n+                NSLog(@\"MTLCaptureDestinationGPUTraceDocument destination is supported.\");\n+                MTLCaptureDescriptor* captureDescriptor = [MTLCaptureDescriptor new];\n+                [captureDescriptor setCaptureObject: [context getDevice]];\n+                [captureDescriptor setDestination:MTLCaptureDestinationGPUTraceDocument];\n+\n+                NSURL* url = [NSURL URLWithString:GPUTraceFilename];\n+                [captureDescriptor setOutputURL:url];\n+                [captureManager startCaptureWithDescriptor:captureDescriptor error:nil];\n+            }\n+        }\n+    } else {\n+        NSLog(@\"MTL_CAPTURE_ENABLED is available only in macOS 14 and later versions\");\n+    }\n+#endif\n+}\n+\n+- (id<MTLFunction>) getFunction:(NSString*)funcName\n+{\n+    return [shaderLib newFunctionWithName:funcName];\n+}\n+\n+- (id<MTLRenderPipelineState>) getClearRttPipeState\n+{\n+    int sampleCount = 1;\n+    if ([[context getRTT] isMSAAEnabled]) {\n+        sampleCount = 4;\n+    }\n+    NSNumber *keySampleCount = [NSNumber numberWithInt:sampleCount];\n+    id<MTLRenderPipelineState> clearRttPipeState;\n+    if ([context clearDepth]) {\n+        clearRttPipeState = clearRttPipeStateDepthDict[keySampleCount];\n+    } else {\n+        clearRttPipeState = clearRttPipeStateNoDepthDict[keySampleCount];\n+    }\n+    if (clearRttPipeState == nil) {\n+        MTLRenderPipelineDescriptor* pipeDesc = [[MTLRenderPipelineDescriptor alloc] init];\n+        pipeDesc.vertexFunction   = [self getFunction:@\"clearVF\"];\n+        pipeDesc.fragmentFunction = [self getFunction:@\"clearFF\"];\n+        pipeDesc.colorAttachments[0].pixelFormat = [[context getRTT] getPixelFormat];\n+        pipeDesc.sampleCount = sampleCount;\n+        if ([context clearDepth]) {\n+            pipeDesc.depthAttachmentPixelFormat = MTLPixelFormatDepth32Float;\n+        } else {\n+            pipeDesc.depthAttachmentPixelFormat = MTLPixelFormatInvalid;\n+        }\n+\n+        NSError* error;\n+        clearRttPipeState = [[context getDevice] newRenderPipelineStateWithDescriptor:pipeDesc error:&error];\n+        [pipeDesc release];\n+        pipeDesc = nil;\n+        NSAssert(clearRttPipeState, @\"Failed to create clear pipeline state: %@\", error);\n+        if ([context clearDepth]) {\n+            [clearRttPipeStateDepthDict setObject:clearRttPipeState forKey:keySampleCount];\n+        } else {\n+            [clearRttPipeStateNoDepthDict setObject:clearRttPipeState forKey:keySampleCount];\n+        }\n+    }\n+    return clearRttPipeState;\n+}\n+\n+- (id<MTLRenderPipelineState>) getPipeStateWithFragFunc:(id<MTLFunction>)func\n+                                          compositeMode:(int)compositeMode\n+{\n+    NSError* error;\n+    MTLRenderPipelineDescriptor* pipeDesc = [[MTLRenderPipelineDescriptor alloc] init];\n+    pipeDesc.vertexFunction = vertexFunction;\n+    pipeDesc.fragmentFunction = func;\n+    pipeDesc.colorAttachments[0].pixelFormat = [[context getRTT] getPixelFormat];\n+\n+    if ([context isDepthEnabled]) {\n+        pipeDesc.depthAttachmentPixelFormat = MTLPixelFormatDepth32Float;\n+    } else {\n+        pipeDesc.depthAttachmentPixelFormat = MTLPixelFormatInvalid;\n+    }\n+\n+    if ([[context getRTT] isMSAAEnabled]) {\n+        pipeDesc.sampleCount = 4;\n+    } else {\n+        pipeDesc.sampleCount = 1;\n+    }\n+\n+    [self setPipelineCompositeBlendMode:pipeDesc\n+                          compositeMode:compositeMode];\n+\n+    id<MTLRenderPipelineState> pipeState = [[context getDevice] newRenderPipelineStateWithDescriptor:pipeDesc error:&error];\n+    [pipeDesc release];\n+    pipeDesc = nil;\n+    NSAssert(pipeState, @\"Failed to create pipeline state to render to texture: %@\", error);\n+\n+    return pipeState;\n+}\n+\n+- (id<MTLComputePipelineState>) getComputePipelineStateWithFunc:(NSString*)funcName\n+{\n+    if (uyvy422ToRGBAState == nil) {\n+        NSError* error;\n+        id<MTLFunction> kernelFunction = [self getFunction:funcName];\n+        uyvy422ToRGBAState = [[context getDevice] newComputePipelineStateWithFunction:kernelFunction\n+                                                                       error:&error];\n+        NSAssert(uyvy422ToRGBAState, @\"Failed to create compute pipeline state: %@\", error);\n+    }\n+\n+    return uyvy422ToRGBAState;\n+}\n+\n+- (id<MTLRenderPipelineState>) getPhongPipeStateWithNumLights:(int)numLights\n+                                                compositeMode:(int)compositeMode;\n+{\n+    NSError* error;\n+    NSMutableDictionary *psDict;\n+    if ([[context getRTT] isMSAAEnabled]) {\n+        if ([context isDepthEnabled]) {\n+            psDict = phongPipelineStateMSAADepthDict;\n+        } else {\n+            psDict = phongPipelineStateMSAANoDepthDict;\n+        }\n+    } else {\n+        if ([context isDepthEnabled]) {\n+            psDict = phongPipelineStateNonMSAADepthDict;\n+        } else {\n+            psDict = phongPipelineStateNonMSAANoDepthDict;\n+        }\n+    }\n+\n+    NSNumber *keyCompMode = [NSNumber numberWithInt:(compositeMode << 8) | numLights];\n+    id<MTLRenderPipelineState> pipeState = psDict[keyCompMode];\n+    if (pipeState == nil) {\n+\n+        NSString *vertFuncName = [[NSString alloc] initWithFormat:@\"PhongVS%d\", numLights];\n+        NSString *fragFuncName = [[NSString alloc] initWithFormat:@\"PhongPS%d\", numLights];\n+\n+        MTLRenderPipelineDescriptor* pipeDesc = [[MTLRenderPipelineDescriptor alloc] init];\n+        pipeDesc.vertexFunction = [self getFunction:vertFuncName];\n+        pipeDesc.fragmentFunction = [self getFunction:fragFuncName];\n+        pipeDesc.colorAttachments[0].pixelFormat = [[context getRTT] getPixelFormat];\n+        if ([context isDepthEnabled]) {\n+            pipeDesc.depthAttachmentPixelFormat = MTLPixelFormatDepth32Float;\n+        } else {\n+            pipeDesc.depthAttachmentPixelFormat = MTLPixelFormatInvalid;\n+        }\n+\n+        if ([[context getRTT] isMSAAEnabled]) {\n+            pipeDesc.sampleCount = 4;\n+        } else {\n+            pipeDesc.sampleCount = 1;\n+        }\n+        [self setPipelineCompositeBlendMode:pipeDesc\n+                compositeMode:compositeMode];\n+        pipeState = [[context getDevice]\n+                newRenderPipelineStateWithDescriptor:pipeDesc error:&error];\n+        [pipeDesc release];\n+        pipeDesc = nil;\n+        [psDict setObject:pipeState forKey:keyCompMode];\n+        [vertFuncName release];\n+        [fragFuncName release];\n+        NSAssert(pipeState, @\"Failed to create phong pipeline state: %@\", error);\n+    }\n+    return pipeState;\n+}\n+\n+- (id<MTLDepthStencilState>) getDepthStencilState\n+{\n+    if ([context isDepthEnabled]) {\n+        return depthStencilState[1];\n+    } else {\n+        return depthStencilState[0];\n+    }\n+}\n+\n+- (void) setPipelineCompositeBlendMode:(MTLRenderPipelineDescriptor*)pipeDesc\n+                         compositeMode:(int)compositeMode\n+{\n+    MTLBlendFactor srcFactor;\n+    MTLBlendFactor dstFactor;\n+\n+    switch(compositeMode) {\n+        case com_sun_prism_mtl_MTLContext_MTL_COMPMODE_CLEAR:\n+            srcFactor = MTLBlendFactorZero;\n+            dstFactor = MTLBlendFactorZero;\n+            break;\n+\n+        case com_sun_prism_mtl_MTLContext_MTL_COMPMODE_SRC:\n+            srcFactor = MTLBlendFactorOne;\n+            dstFactor = MTLBlendFactorZero;\n+            break;\n+\n+        case com_sun_prism_mtl_MTLContext_MTL_COMPMODE_SRCOVER:\n+            srcFactor = MTLBlendFactorOne;\n+            dstFactor = MTLBlendFactorOneMinusSourceAlpha;\n+            break;\n+\n+        case com_sun_prism_mtl_MTLContext_MTL_COMPMODE_DSTOUT:\n+            srcFactor = MTLBlendFactorZero;\n+            dstFactor = MTLBlendFactorOneMinusSourceAlpha;\n+            break;\n+\n+        case com_sun_prism_mtl_MTLContext_MTL_COMPMODE_ADD:\n+            srcFactor = MTLBlendFactorOne;\n+            dstFactor = MTLBlendFactorOne;\n+            break;\n+\n+        default:\n+            srcFactor = MTLBlendFactorOne;\n+            dstFactor = MTLBlendFactorOneMinusSourceAlpha;\n+            break;\n+    }\n+\n+    pipeDesc.colorAttachments[0].blendingEnabled = YES;\n+    pipeDesc.colorAttachments[0].rgbBlendOperation = MTLBlendOperationAdd;\n+    pipeDesc.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;\n+\n+    pipeDesc.colorAttachments[0].sourceAlphaBlendFactor = srcFactor;\n+    pipeDesc.colorAttachments[0].sourceRGBBlendFactor = srcFactor;\n+    pipeDesc.colorAttachments[0].destinationAlphaBlendFactor = dstFactor;\n+    pipeDesc.colorAttachments[0].destinationRGBBlendFactor = dstFactor;\n+}\n+\n+- (void) dealloc\n+{\n+#ifdef JFX_MTL_DEBUG_CAPTURE\n+    if (@available(macOS 14, *)) {\n+        NSLog(@\"stopping capture...\");\n+        MTLCaptureManager* captureManager = [MTLCaptureManager sharedCaptureManager];\n+        [captureManager stopCapture];\n+    }\n+#endif\n+\n+    if (shaderLib != nil) {\n+        [shaderLib release];\n+        shaderLib = nil;\n+    }\n+\n+    if (uyvy422ToRGBAState != nil) {\n+        [uyvy422ToRGBAState release];\n+        uyvy422ToRGBAState = nil;\n+    }\n+\n+    for (NSNumber *keyPipeState in clearRttPipeStateNoDepthDict) {\n+        [clearRttPipeStateNoDepthDict[keyPipeState] release];\n+    }\n+    for (NSNumber *keyPipeState in clearRttPipeStateDepthDict) {\n+        [clearRttPipeStateDepthDict[keyPipeState] release];\n+    }\n+    for (NSNumber *keyPipeState in phongPipelineStateNonMSAANoDepthDict) {\n+        [phongPipelineStateNonMSAANoDepthDict[keyPipeState] release];\n+    }\n+    for (NSNumber *keyPipeState in phongPipelineStateNonMSAADepthDict) {\n+        [phongPipelineStateNonMSAADepthDict[keyPipeState] release];\n+    }\n+    for (NSNumber *keyPipeState in phongPipelineStateMSAANoDepthDict) {\n+        [phongPipelineStateMSAANoDepthDict[keyPipeState] release];\n+    }\n+    for (NSNumber *keyPipeState in phongPipelineStateMSAADepthDict) {\n+        [phongPipelineStateMSAADepthDict[keyPipeState] release];\n+    }\n+\n+    [clearRttPipeStateNoDepthDict release];\n+    [clearRttPipeStateDepthDict release];\n+    [phongPipelineStateNonMSAANoDepthDict release];\n+    [phongPipelineStateNonMSAADepthDict release];\n+    [phongPipelineStateMSAANoDepthDict release];\n+    [phongPipelineStateMSAADepthDict release];\n+    [super dealloc];\n+}\n+\n+@end \/\/ MetalPipelineManager\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalPipelineManager.m","additions":366,"deletions":0,"binary":false,"changes":366,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef METAL_RTTEXTURE_H\n+#define METAL_RTTEXTURE_H\n+\n+#import \"MetalContext.h\"\n+#import \"MetalTexture.h\"\n+\n+@interface MetalRTTexture : MetalTexture\n+{\n+    NSUInteger contentWidth;\n+    NSUInteger contentHeight;\n+    NSUInteger physicalWidth;\n+    NSUInteger physicalHeight;\n+\n+    id<MTLTexture> depthTexture;\n+    id<MTLTexture> depthMSAATexture;\n+    id<MTLTexture> msaaTexture;\n+    BOOL isMSAA;\n+    BOOL lastDepthMSAA;\n+}\n+\n+- (id<MTLTexture>) getTexture;\n+- (id<MTLTexture>) getDepthTexture;\n+- (id<MTLTexture>) getDepthMSAATexture;\n+- (id<MTLTexture>) getMSAATexture;\n+- (BOOL) isMSAAEnabled;\n+\n+- (MetalRTTexture*) createTexture:(MetalContext*)ctx\n+                  ofPhysicalWidth:(NSUInteger)pw\n+                 ofPhysicalHeight:(NSUInteger)ph\n+                   ofContentWidth:(NSUInteger)cw\n+                  ofContentHeight:(NSUInteger)ch\n+                           isMsaa:(BOOL)isMsaa;\n+\n+- (MetalRTTexture*) createTexture:(MetalContext*)ctx\n+                  ofPhysicalWidth:(NSUInteger)pw\n+                 ofPhysicalHeight:(NSUInteger)ph\n+                           mtlTex:(long)pTex;\n+\n+- (void) initRTT:(int*)arr;\n+- (void) readPixels:(int*)pDst;\n+- (void) readPixelsFromRTT:(int*)pDst;\n+\n+- (void) createDepthTexture;\n+- (void) dealloc;\n+\n+@end\n+\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalRTTexture.h","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MetalRTTexture.h\"\n+#import \"com_sun_prism_mtl_MTLRTTexture.h\"\n+\n+@implementation MetalRTTexture\n+\n+- (MetalRTTexture*) createTexture:(MetalContext*)ctx\n+                  ofPhysicalWidth:(NSUInteger)pw\n+                 ofPhysicalHeight:(NSUInteger)ph\n+                   ofContentWidth:(NSUInteger)cw\n+                  ofContentHeight:(NSUInteger)ch\n+                           isMsaa:(BOOL)isMsaa\n+{\n+    self = [super init];\n+    if (self) {\n+        physicalWidth  = pw;\n+        physicalHeight = ph;\n+        contentWidth   = cw;\n+        contentHeight  = ch;\n+\n+        width   = pw;\n+        height  = ph;\n+        context = ctx;\n+        isMSAA  = isMsaa;\n+\n+        pixelFormat = MTLPixelFormatBGRA8Unorm;\n+        mipmapped = NO;\n+\n+        @autoreleasepool {\n+            MTLTextureDescriptor *texDescriptor = [MTLTextureDescriptor new];\n+            texDescriptor.storageMode = MTLStorageModeManaged;\n+            texDescriptor.usage  = MTLTextureUsageRenderTarget;\n+            texDescriptor.width  = width;\n+            texDescriptor.height = height;\n+            texDescriptor.textureType = MTLTextureType2D;\n+            texDescriptor.pixelFormat = pixelFormat;\n+            texDescriptor.sampleCount = 1;\n+            texDescriptor.hazardTrackingMode = MTLHazardTrackingModeTracked;\n+\n+            id<MTLDevice> device = [context getDevice];\n+\n+            texture = [device newTextureWithDescriptor:texDescriptor];\n+\n+            if (isMSAA) {\n+                MTLTextureDescriptor *msaaTexDescriptor = [MTLTextureDescriptor new];\n+                msaaTexDescriptor.storageMode = MTLStorageModePrivate;\n+                msaaTexDescriptor.usage = MTLTextureUsageRenderTarget | MTLTextureUsageShaderRead | MTLTextureUsageShaderWrite;\n+                msaaTexDescriptor.width  = width;\n+                msaaTexDescriptor.height = height;\n+                msaaTexDescriptor.textureType = MTLTextureType2DMultisample;\n+                msaaTexDescriptor.pixelFormat = pixelFormat;\n+                \/\/By default all SoC's on macOS support 4 sample count\n+                msaaTexDescriptor.sampleCount = 4;\n+                msaaTexture = [device newTextureWithDescriptor:msaaTexDescriptor];\n+            } else {\n+                msaaTexture = nil;\n+            }\n+\n+            depthTexture = nil;\n+            depthMSAATexture = nil;\n+        }\n+    }\n+    return self;\n+}\n+\n+- (MetalRTTexture*) createTexture:(MetalContext*)ctx\n+                  ofPhysicalWidth:(NSUInteger)pw\n+                 ofPhysicalHeight:(NSUInteger)ph\n+                           mtlTex:(long)pTex\n+{\n+    self = [super init];\n+    if (self) {\n+        width = physicalWidth = pw;\n+        height = physicalHeight = ph;\n+        context = ctx;\n+        pixelFormat = MTLPixelFormatBGRA8Unorm;\n+        mipmapped = NO;\n+        id <MTLTexture> tex = (__bridge id<MTLTexture>)(jlong_to_ptr(pTex));\n+        texture = tex;\n+    }\n+    return self;\n+}\n+\n+- (void) createDepthTexture\n+{\n+    id<MTLDevice> device = [context getDevice];\n+    if (depthTexture.width != width ||\n+        depthTexture.height != height ||\n+        lastDepthMSAA != isMSAA) {\n+        lastDepthMSAA = isMSAA;\n+        @autoreleasepool {\n+            MTLTextureDescriptor *depthDesc = [MTLTextureDescriptor new];\n+            depthDesc.width  = width;\n+            depthDesc.height = height;\n+            depthDesc.pixelFormat = MTLPixelFormatDepth32Float;\n+            depthDesc.textureType = MTLTextureType2D;\n+            depthDesc.sampleCount = 1;\n+            depthDesc.usage = MTLTextureUsageRenderTarget;\n+            depthDesc.storageMode = MTLStorageModePrivate;\n+            depthTexture = [device newTextureWithDescriptor:depthDesc];\n+            if (isMSAA) {\n+                depthDesc.usage = MTLTextureUsageRenderTarget | MTLTextureUsageShaderRead | MTLTextureUsageShaderWrite;\n+                depthDesc.textureType = MTLTextureType2DMultisample;\n+                \/\/ By default all SoC's on macOS support 4 sample count\n+                depthDesc.sampleCount = 4;\n+                depthMSAATexture = [device newTextureWithDescriptor:depthDesc];\n+            }\n+        }\n+    }\n+}\n+\n+- (void) initRTT:(int*)arr\n+{\n+    id<MTLTexture> tex = [self getTexture];\n+    MTLRegion region = {{0, 0, 0}, {tex.width, tex.height, 1}};\n+    [tex replaceRegion:region\n+           mipmapLevel:0\n+             withBytes:arr\n+           bytesPerRow:tex.width * 4];\n+}\n+\n+- (void) readPixels:(int*)pDst\n+{\n+    int* texContent = (int*)[[self getPixelBuffer] contents];\n+    for (NSUInteger i = 0; i < contentHeight; i++) {\n+        for (NSUInteger j = 0; j < contentWidth; j++) {\n+            pDst[i * contentWidth + j] = texContent[i * physicalWidth + j];\n+        }\n+    }\n+}\n+\n+- (void) readPixelsFromRTT:(int*)pDst\n+{\n+    int *texContent = (int*)[[self getPixelBuffer] contents];\n+    memcpy(pDst, texContent, contentWidth * contentHeight * 4);\n+}\n+\n+- (id<MTLTexture>) getTexture { return [super getTexture]; }\n+- (id<MTLTexture>) getDepthTexture { return depthTexture; }\n+- (BOOL) isMSAAEnabled { return isMSAA; }\n+- (id<MTLTexture>) getMSAATexture { return msaaTexture; }\n+- (id<MTLTexture>) getDepthMSAATexture { return depthMSAATexture; }\n+\n+- (void) dealloc {\n+    if (depthTexture != nil) {\n+        [depthTexture release];\n+        depthTexture = nil;\n+    }\n+    if (depthMSAATexture != nil) {\n+        [depthMSAATexture release];\n+        depthMSAATexture = nil;\n+    }\n+    if (msaaTexture != nil) {\n+        [msaaTexture release];\n+        msaaTexture = nil;\n+    }\n+    [super dealloc];\n+}\n+@end \/\/ MetalRTTexture\n+\n+\n+\/\/ ** JNI METHODS **\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLRTTexture\n+ * Method:    nCreateRT\n+ * Signature: (JIIIILcom\/sun\/prism\/Texture\/WrapMode;Z)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_prism_mtl_MTLRTTexture_nCreateRT\n+    (JNIEnv *env, jclass jClass, jlong ctx, jint pw, jint ph, jint cw,\n+    jint ch, jobject wrapMode, jboolean isMsaa)\n+{\n+    MetalContext* context = (MetalContext*)jlong_to_ptr(ctx);\n+    MetalRTTexture* rtt = [[MetalRTTexture alloc] createTexture:context\n+                                                ofPhysicalWidth:pw\n+                                               ofPhysicalHeight:ph\n+                                                 ofContentWidth:cw\n+                                                ofContentHeight:ch\n+                                                         isMsaa:isMsaa];\n+    return ptr_to_jlong(rtt);\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLRTTexture\n+ * Method:    nCreateRT2\n+ * Signature: (JJII)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_prism_mtl_MTLRTTexture_nCreateRT2\n+    (JNIEnv *env, jclass jClass, jlong ctx, jlong pTex, jint pw, jint ph)\n+{\n+    MetalContext* context = (MetalContext*)jlong_to_ptr(ctx);\n+    MetalRTTexture* rtt = [[MetalRTTexture alloc] createTexture:context\n+                                                ofPhysicalWidth:pw\n+                                               ofPhysicalHeight:ph\n+                                                         mtlTex:pTex];\n+    return ptr_to_jlong(rtt);\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLRTTexture\n+ * Method:    nInitRTT\n+ * Signature: (J[I)V\n+ *\/\n+\/\/ This method initializes underlying native MTLTexture with passed in pixData\n+\/\/ This texure replaceRegion is executed on CPU\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLRTTexture_nInitRTT\n+    (JNIEnv *env, jclass class, jlong jTexPtr, jintArray pixData)\n+{\n+    MetalRTTexture* rtt = (MetalRTTexture*) jlong_to_ptr(jTexPtr);\n+    int* arr = (*env)->GetIntArrayElements(env, pixData, NULL);\n+\n+    [rtt initRTT:arr];\n+\n+    (*env)->ReleaseIntArrayElements(env, pixData, arr, 0);\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLRTTexture\n+ * Method:    nReadPixelsFromRTT\n+ * Signature: (JLjava\/nio\/IntBuffer;)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLRTTexture_nReadPixelsFromRTT\n+    (JNIEnv *env, jclass class, jlong jTexPtr, jobject pixData)\n+{\n+    MetalRTTexture* rtt = (MetalRTTexture*) jlong_to_ptr(jTexPtr);\n+    int* pDst = (int*) (*env)->GetDirectBufferAddress(env, pixData);\n+    [rtt readPixelsFromRTT:pDst];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLRTTexture\n+ * Method:    nReadPixels\n+ * Signature: (J[I)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLRTTexture_nReadPixels\n+    (JNIEnv *env, jclass class, jlong jTexPtr, jintArray pixData)\n+{\n+    MetalRTTexture* rtt = (MetalRTTexture*) jlong_to_ptr(jTexPtr);\n+    int* pDst = (*env)->GetIntArrayElements(env, pixData, nil);\n+\n+    [rtt readPixels:pDst];\n+\n+    (*env)->ReleaseIntArrayElements(env, pixData, pDst, 0);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalRTTexture.m","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef METAL_RING_BUFFER_H\n+#define METAL_RING_BUFFER_H\n+\n+#define NUM_BUFFERS (3)\n+\n+\/\/ The alignment varies for different platforms.\n+\/\/ The alignment value can\/should be retrived from device capabilities and updated accordingly.\n+\/\/\n+\/\/ 1. For fragment function buffer uniforms the offset must be:\n+\/\/    - multiple of 8 on intel mac,\n+\/\/    - multiple of 4 for Apple GPU family 2 to 9,\n+\/\/    - multiple of 32 for Mac2\n+\/\/ 2. BlitEncoder offset: needs to be a multiple of the destination textureâ€™s pixel size.\n+\/\/\n+\/\/ For more details see metal feature set table and doc of BlitEncoder.copyFromBuffer\n+\/\/ #define BUFFER_OFFSET_ALIGNMENT (32)\n+\n+@class MetalContext;\n+\n+#import \"MetalCommon.h\"\n+\n+@interface MetalRingBuffer : NSObject\n+{\n+    id<MTLBuffer> buffer[NUM_BUFFERS];\n+    unsigned int currentOffset;\n+    unsigned int numReservedBytes;\n+    unsigned int bufferSize;\n+    unsigned int bufferOffsetAlignment;\n+}\n+\n+- (MetalRingBuffer*) init:(MetalContext*)ctx\n+                   ofSize:(unsigned int)size;\n+- (void) resetOffsets;\n+- (id<MTLBuffer>) getBuffer;\n+- (id<MTLBuffer>) getCurrentBuffer;\n+- (int)  reserveBytes:(unsigned int)length;\n+- (unsigned int) getNumReservedBytes;\n+- (void) dealloc;\n+\n++ (unsigned int)  getCurrentBufferIndex;\n++ (void) resetBuffer :(unsigned int)index;\n++ (bool) isBufferAvailable;\n++ (unsigned int) updateBufferInUse;\n+\n+@end\n+\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalRingBuffer.h","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MetalRingBuffer.h\"\n+#import \"MetalContext.h\"\n+\n+@implementation MetalRingBuffer\n+\n+static bool isBufferInUse[NUM_BUFFERS];\n+static unsigned int currentBufferIndex;\n+\n+- (MetalRingBuffer*) init:(MetalContext*)ctx\n+                   ofSize:(unsigned int)size {\n+\n+    self = [super init];\n+    if (self) {\n+        bufferSize = size;\n+        currentOffset = 0;\n+        numReservedBytes = 0;\n+        currentBufferIndex = 0;\n+        if (@available(macOS 13, *)) {\n+            bufferOffsetAlignment = 32;\n+        } else {\n+            \/\/ MacOS 12 requires the offset aligment to be 256 bytes for the method\n+            \/\/ MTLRenderCommandEncoder.setVertexBuffer.\n+            bufferOffsetAlignment = 256;\n+        }\n+\n+        for (int i = 0; i < NUM_BUFFERS; i++) {\n+            isBufferInUse[i] = false;\n+            buffer[i] = [[ctx getDevice] newBufferWithLength:bufferSize\n+                                                     options:MTLResourceStorageModeShared];\n+            buffer[i].label = [NSString stringWithFormat:@\"JFX Ring Buffer\"];\n+        }\n+    }\n+    return self;\n+}\n+\n++ (bool) isBufferAvailable {\n+    for (int i = 0; i < NUM_BUFFERS; i++) {\n+        if (!isBufferInUse[i]) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+\/\/ This method assumes that caller has made sure that a buffer is available\n+\/\/ by calling the method isBufferAvailable().\n+\/\/ If there is no buffer available then the behavior is undefined and\n+\/\/ should cause visual artefacts or Metal validation may fail or crash.\n+\n++ (unsigned int) updateBufferInUse {\n+    unsigned int prevBufferIndex = currentBufferIndex;\n+    for (int i = currentBufferIndex + 1; i < NUM_BUFFERS; i++) {\n+        if (!isBufferInUse[i]) {\n+            currentBufferIndex = i;\n+        }\n+    }\n+    if (prevBufferIndex == currentBufferIndex) {\n+        for (int i = 0; i < currentBufferIndex; i++) {\n+            if (!isBufferInUse[i]) {\n+                currentBufferIndex = i;\n+            }\n+        }\n+    }\n+    isBufferInUse[currentBufferIndex] = true;\n+    return currentBufferIndex;\n+}\n+\n++ (unsigned int) getCurrentBufferIndex {\n+    return currentBufferIndex;\n+}\n+\n++ (void) resetBuffer:(unsigned int)index {\n+    isBufferInUse[index] = false;\n+}\n+\n+- (void) resetOffsets\n+{\n+    currentOffset = 0;\n+    numReservedBytes = 0;\n+}\n+\n+- (id<MTLBuffer>) getBuffer {\n+    return [self getCurrentBuffer];\n+}\n+\n+- (id<MTLBuffer>) getCurrentBuffer {\n+    return buffer[currentBufferIndex];\n+}\n+\n+- (int) reserveBytes:(unsigned int)length {\n+    int prevOffset = currentOffset;\n+    currentOffset = numReservedBytes;\n+    unsigned int remainder = currentOffset % bufferOffsetAlignment;\n+    if (remainder != 0) {\n+        currentOffset = currentOffset + bufferOffsetAlignment - remainder;\n+    }\n+\n+    if (currentOffset > bufferSize || length > (bufferSize - currentOffset)) {\n+        \/\/ RingBuffer overflows with requested length.\n+        currentOffset = prevOffset;\n+        return -1;\n+    }\n+    numReservedBytes = currentOffset + length;\n+    return currentOffset;\n+}\n+\n+- (unsigned int) getNumReservedBytes {\n+    return numReservedBytes;\n+}\n+\n+- (void) dealloc {\n+    for (int i = 0; i < NUM_BUFFERS; i++) {\n+        [buffer[i] release];\n+        buffer[i] = nil;\n+    }\n+    [super dealloc];\n+}\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalRingBuffer.m","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef METAL_SHADER_H\n+#define METAL_SHADER_H\n+\n+#import \"MetalContext.h\"\n+#import \"MetalTexture.h\"\n+#import \"MetalPipelineManager.h\"\n+\n+@interface MetalShader : NSObject\n+{\n+    bool argsUpdated;\n+    MetalContext *context;\n+    NSString* fragFuncName;\n+    id<MTLFunction> fragmentFunction;\n+\n+    NSMutableDictionary *pipeStateNonMSAANoDepthDict;\n+    NSMutableDictionary *pipeStateNonMSAADepthDict;\n+    NSMutableDictionary *pipeStateMSAANoDepthDict;\n+    NSMutableDictionary *pipeStateMSAADepthDict;\n+\n+    NSDictionary* fragArgIndicesDict;\n+    NSMutableDictionary* fragTexArgsDict;\n+    NSMutableDictionary* fragTexSamplerDict;\n+\n+    id<MTLArgumentEncoder> argumentEncoder;\n+    id<MTLBuffer> argumentBuffer;\n+    NSUInteger argumentBufferLength;\n+    int currentRingBufferOffset; \/\/ offset in the MetalRingBuffer\n+    id<MTLBuffer> argumentBufferForCB;\n+}\n+\n+- (void) setArgsUpdated:(bool)updated;\n+- (jobject) getUniformNameIdMap:(JNIEnv*)env;\n+- (id) initWithContext:(MetalContext*)ctx\n+          withFragFunc:(NSString*)fragName;\n+- (id<MTLRenderPipelineState>) getPipelineState:(bool)isMSAA\n+                                  compositeMode:(int)compositeMode;\n+\n+- (void) copyArgBufferToRingBuffer;\n+- (NSUInteger) getArgumentBufferLength;\n+- (int) getRingBufferOffset;\n+- (id<MTLBuffer>) getRingBuffer;\n+\n+- (NSMutableDictionary*) getTexutresDict;\n+- (NSMutableDictionary*) getSamplersDict;\n+\n+- (NSUInteger) getArgumentID:(NSString*)name;\n+- (void) enable;\n+- (void) disable;\n+\n+- (void) setTexture:(int)texID\n+          uniformID:(int)uniformID\n+            texture:(id<MTLTexture>)texture\n+           isLinear:(bool)isLinear\n+           wrapMode:(int)wrapMode;\n+\n+- (void) setInt:(int)uniformID i0:(int)i0;\n+\n+- (void) setFloat1:(int)uniformID f0:(float)f0;\n+- (void) setFloat2:(int)uniformID f0:(float)f0 f1:(float)f1;\n+- (void) setFloat3:(int)uniformID f0:(float)f0 f1:(float)f1 f2:(float)f2;\n+- (void) setFloat4:(int)uniformID f0:(float)f0 f1:(float)f1 f2:(float)f2  f3:(float)f3;\n+\n+- (void) setConstants:(int)uniformID values:(float[])values size:(int)size;\n+- (void) dealloc;\n+\n+@end\n+\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalShader.h","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,478 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"PrismShaderCommon.h\"\n+#import \"DecoraShaderCommon.h\"\n+#import \"MetalShader.h\"\n+#import \"com_sun_prism_mtl_MTLShader.h\"\n+\n+NSString* jStringToNSString(JNIEnv *env, jstring string)\n+{\n+    if (string == NULL) return NULL;\n+    jsize length = (*env)->GetStringLength(env, string);\n+    NSString *result = NULL;\n+    const jchar *chars =(*env)->GetStringCritical(env, string, 0);\n+    if (chars) {\n+        @try {\n+            result = [NSString stringWithCharacters: chars length: length];\n+        }\n+        @finally {\n+            (*env)->ReleaseStringCritical(env, string, chars);\n+        }\n+    }\n+    return result;\n+}\n+\n+@implementation MetalShader\n+\n+- (id) initWithContext:(MetalContext*)ctx\n+          withFragFunc:(NSString*)fragName\n+{\n+    self = [super init];\n+    if (self) {\n+        context = ctx;\n+        argsUpdated = false;\n+        @autoreleasepool {\n+            fragTexArgsDict    = [[[NSMutableDictionary alloc] init] retain];\n+            fragTexSamplerDict = [[[NSMutableDictionary alloc] init] retain];\n+            pipeStateNonMSAANoDepthDict = [[[NSMutableDictionary alloc] init] retain];\n+            pipeStateNonMSAADepthDict = [[[NSMutableDictionary alloc] init] retain];\n+            pipeStateMSAANoDepthDict = [[[NSMutableDictionary alloc] init] retain];\n+            pipeStateMSAADepthDict = [[[NSMutableDictionary alloc] init] retain];\n+            fragArgIndicesDict = [getPRISMDict(fragName) retain];\n+            if (fragArgIndicesDict == nil) {\n+                fragArgIndicesDict = [getDECORADict(fragName) retain];\n+            }\n+        }\n+        currentRingBufferOffset = -1;\n+        fragFuncName = fragName;\n+        fragmentFunction = [[context getPipelineManager] getFunction:fragFuncName];\n+        NSString* key = (NSString*)[[fragArgIndicesDict allKeys] objectAtIndex:0];\n+        if ([fragArgIndicesDict count] == 1 && [key isEqualToString:@\"UNUSED\"]) {\n+            argumentBufferLength = 0;\n+        } else {\n+            argumentEncoder = [fragmentFunction newArgumentEncoderWithBufferIndex:0];\n+            argumentBufferLength = argumentEncoder.encodedLength;\n+            argumentBuffer = [[context getDevice] newBufferWithLength:argumentBufferLength options:0];\n+            argumentBuffer.label = [NSString stringWithFormat:@\"JFX Argument Buffer for fragmentFunction %@\", fragFuncName];\n+            [argumentEncoder setArgumentBuffer:argumentBuffer offset:0];\n+        }\n+    }\n+    return self;\n+}\n+\n+- (void) setArgsUpdated:(bool)updated\n+{\n+    argsUpdated = updated;\n+}\n+\n+- (jobject) getUniformNameIdMap:(JNIEnv*)env\n+{\n+    jclass HashMapClass  = (*env)->FindClass(env, \"java\/util\/HashMap\");\n+    jclass IntegerClass  = (*env)->FindClass(env, \"java\/lang\/Integer\");\n+    if(HashMapClass == NULL || IntegerClass == NULL) {\n+        NSLog(@\"can't find the class\");\n+        return NULL;\n+    }\n+\n+    jmethodID HashMapClassInitMId  = (*env)->GetMethodID(env, HashMapClass, \"<init>\", \"()V\");\n+    jmethodID IntegerClassInitMId  = (*env)->GetMethodID(env, IntegerClass, \"<init>\", \"(I)V\");\n+    if (HashMapClassInitMId == NULL || IntegerClassInitMId == NULL) {\n+        NSLog(@\"can't find the constructor\");\n+        (*env)->DeleteLocalRef(env, HashMapClass);\n+        (*env)->DeleteLocalRef(env, IntegerClass);\n+        return NULL;\n+    }\n+\n+    jmethodID putMId = (*env)->GetMethodID(env, HashMapClass, \"put\",\n+                        \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n+    if (putMId == NULL) {\n+        NSLog(@\"can't find the put method\");\n+        (*env)->DeleteLocalRef(env, HashMapClass);\n+        (*env)->DeleteLocalRef(env, IntegerClass);\n+        return NULL;\n+    }\n+\n+    jobject nameIdMap = (*env)->NewObject(env, HashMapClass, HashMapClassInitMId);\n+    for (NSString *key in fragArgIndicesDict) {\n+        NSNumber *index = fragArgIndicesDict[key];\n+        jobject jKey = (*env)->NewStringUTF(env, [key UTF8String]);\n+        jint value = index.intValue;\n+        jobject jValue = (*env)->NewObject(env, IntegerClass, IntegerClassInitMId, value);\n+        (*env)->CallObjectMethod(env, nameIdMap, putMId, jKey, jValue);\n+    }\n+    jobject hashMapGobal = (jobject) (*env)->NewGlobalRef(env, nameIdMap);\n+\n+    (*env)->DeleteLocalRef(env, nameIdMap);\n+    (*env)->DeleteLocalRef(env, HashMapClass);\n+    (*env)->DeleteLocalRef(env, IntegerClass);\n+\n+    return hashMapGobal;\n+}\n+\n+- (void) enable\n+{\n+    [context setCurrentShader:self];\n+}\n+\n+- (void) disable\n+{\n+    [context setCurrentShader:nil];\n+}\n+\n+- (id<MTLRenderPipelineState>) getPipelineState:(bool)isMSAA\n+                                  compositeMode:(int)compositeMode;\n+{\n+    NSMutableDictionary *psDict;\n+    if (isMSAA) {\n+        if ([context isDepthEnabled]) {\n+            psDict = pipeStateMSAADepthDict;\n+        } else {\n+            psDict = pipeStateMSAANoDepthDict;\n+        }\n+    } else {\n+        if ([context isDepthEnabled]) {\n+            psDict = pipeStateNonMSAADepthDict;\n+        } else {\n+            psDict = pipeStateNonMSAANoDepthDict;\n+        }\n+    }\n+    NSNumber *keyCompMode = [NSNumber numberWithInt:compositeMode];\n+    id<MTLRenderPipelineState> pipeState = psDict[keyCompMode];\n+    if (pipeState == nil) {\n+        pipeState = [[context getPipelineManager] getPipeStateWithFragFunc:fragmentFunction\n+                                                             compositeMode:compositeMode];\n+        [psDict setObject:pipeState forKey:keyCompMode];\n+    }\n+    return pipeState;\n+}\n+\n+- (NSUInteger) getArgumentBufferLength\n+{\n+    return argumentBufferLength;\n+}\n+\n+- (int) getRingBufferOffset\n+{\n+    return currentRingBufferOffset;\n+}\n+\n+- (id<MTLBuffer>) getRingBuffer\n+{\n+    return argumentBufferForCB;\n+}\n+\n+- (void) copyArgBufferToRingBuffer\n+{\n+    if (argumentBufferLength != 0 && argsUpdated) {\n+        currentRingBufferOffset = [[context getArgsRingBuffer] reserveBytes:argumentBufferLength];\n+\n+        if (currentRingBufferOffset < 0) {\n+            currentRingBufferOffset = 0;\n+            argumentBufferForCB = [context getTransientBufferWithBytes:argumentBuffer.contents\n+                                                                length:argumentBufferLength];\n+        } else {\n+            argumentBufferForCB = [[context getArgsRingBuffer] getBuffer];\n+            memcpy(argumentBufferForCB.contents + currentRingBufferOffset,\n+                                argumentBuffer.contents, argumentBufferLength);\n+            argsUpdated = false;\n+        }\n+    }\n+}\n+\n+- (NSMutableDictionary*) getTexutresDict\n+{\n+    return fragTexArgsDict;\n+}\n+\n+- (NSMutableDictionary*) getSamplersDict\n+{\n+    return fragTexSamplerDict;\n+}\n+\n+- (NSUInteger) getArgumentID:(NSString*)name\n+{\n+    return 0;\n+}\n+\n+- (void) setInt:(int)uniformID i0:(int)i0\n+{\n+    argsUpdated = true;\n+    int *anIntPtr = [argumentEncoder constantDataAtIndex:uniformID];\n+    *anIntPtr = i0;\n+}\n+\n+\n+- (void) setTexture:(int)texID\n+          uniformID:(int)uniformID\n+            texture:(id<MTLTexture>)texture\n+           isLinear:(bool)isLinear\n+           wrapMode:(int)wrapMode\n+{\n+    argsUpdated = true;\n+    NSNumber *idNum = [NSNumber numberWithInt:uniformID];\n+    [fragTexArgsDict setObject:texture forKey:idNum];\n+\n+    [argumentEncoder setTexture:texture atIndex:uniformID];\n+\n+    id<MTLSamplerState> sampler = [context getSampler:isLinear wrapMode:wrapMode];\n+    [fragTexSamplerDict setObject:sampler forKey:[NSNumber numberWithInt:texID]];\n+}\n+\n+- (void) setFloat1:(int)uniformID f0:(float)f0\n+{\n+    argsUpdated = true;\n+    float *aFloatPtr = [argumentEncoder constantDataAtIndex:uniformID];\n+    *aFloatPtr = f0;\n+}\n+\n+- (void) setFloat2:(int)uniformID f0:(float)f0 f1:(float)f1\n+{\n+    argsUpdated = true;\n+    float *aFloatPtr = [argumentEncoder constantDataAtIndex:uniformID];\n+    *aFloatPtr++ = f0;\n+    *aFloatPtr = f1;\n+}\n+\n+- (void) setFloat3:(int)uniformID f0:(float)f0 f1:(float)f1 f2:(float)f2\n+{\n+    argsUpdated = true;\n+    float *aFloatPtr = [argumentEncoder constantDataAtIndex:uniformID];\n+    *aFloatPtr++ = f0;\n+    *aFloatPtr++ = f1;\n+    *aFloatPtr = f2;\n+}\n+\n+- (void) setFloat4:(int)uniformID f0:(float)f0 f1:(float)f1 f2:(float)f2  f3:(float)f3\n+{\n+    argsUpdated = true;\n+    float *aFloatPtr = [argumentEncoder constantDataAtIndex:uniformID];\n+    *aFloatPtr++ = f0;\n+    *aFloatPtr++ = f1;\n+    *aFloatPtr++ = f2;\n+    *aFloatPtr = f3;\n+}\n+\n+- (void) setConstants:(int)uniformID values:(float[])values size:(int)size\n+{\n+    argsUpdated = true;\n+    float *aFloatPtr = [argumentEncoder constantDataAtIndex:uniformID];\n+    memcpy(aFloatPtr, values, size * 4);\n+}\n+\n+- (void) dealloc\n+{\n+    for (NSNumber *keyPipeState in pipeStateNonMSAANoDepthDict) {\n+        [pipeStateNonMSAANoDepthDict[keyPipeState] release];\n+    }\n+    for (NSNumber *keyPipeState in pipeStateNonMSAADepthDict) {\n+        [pipeStateNonMSAADepthDict[keyPipeState] release];\n+    }\n+    for (NSNumber *keyPipeState in pipeStateMSAANoDepthDict) {\n+        [pipeStateMSAANoDepthDict[keyPipeState] release];\n+    }\n+    for (NSNumber *keyPipeState in pipeStateMSAADepthDict) {\n+        [pipeStateMSAADepthDict[keyPipeState] release];\n+    }\n+    for (NSNumber *keyTexArg in fragTexArgsDict) {\n+        [fragTexArgsDict[keyTexArg] release];\n+    }\n+    for (NSNumber *keyTexSampler in fragTexSamplerDict) {\n+        [fragTexSamplerDict[keyTexSampler] release];\n+    }\n+    for (NSNumber *keyArgIndex in fragArgIndicesDict) {\n+        [fragArgIndicesDict[keyArgIndex] release];\n+    }\n+    [pipeStateNonMSAANoDepthDict release];\n+    [pipeStateNonMSAADepthDict release];\n+    [pipeStateMSAANoDepthDict release];\n+    [pipeStateMSAADepthDict release];\n+    [fragTexArgsDict release];\n+    [fragTexSamplerDict release];\n+    [fragArgIndicesDict release];\n+    [super dealloc];\n+}\n+\n+@end \/\/ MetalShader\n+\n+\n+\/\/ ** JNI METHODS **\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLShader\n+ * Method:    nCreateMetalShader\n+ * Signature: (JLjava\/lang\/String;)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_prism_mtl_MTLShader_nCreateMetalShader\n+    (JNIEnv *env, jclass jClass, jlong ctx, jstring fragFuncName)\n+{\n+    MetalContext* context = (MetalContext*)jlong_to_ptr(ctx);\n+    NSString *nameString = jStringToNSString(env, fragFuncName);\n+    MetalShader* shader = [[MetalShader alloc] initWithContext:context withFragFunc:nameString];\n+    jlong shader_ptr = ptr_to_jlong(shader);\n+    return shader_ptr;\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLShader\n+ * Method:    nGetUniformNameIdMap\n+ * Signature: (J)Ljava\/util\/HashMap;\n+ *\/\n+JNIEXPORT jobject JNICALL Java_com_sun_prism_mtl_MTLShader_nGetUniformNameIdMap\n+    (JNIEnv *env, jclass jClass, jlong shader)\n+{\n+    MetalShader *mtlShader = (MetalShader*)jlong_to_ptr(shader);\n+    return [mtlShader getUniformNameIdMap:env];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLShader\n+ * Method:    nEnable\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLShader_nEnable\n+    (JNIEnv *env, jclass jClass, jlong shader)\n+{\n+    MetalShader *mtlShader = (MetalShader *)jlong_to_ptr(shader);\n+    [mtlShader enable];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLShader\n+ * Method:    nDisable\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLShader_nDisable\n+    (JNIEnv *env, jclass jClass, jlong shader)\n+{\n+    MetalShader *mtlShader = (MetalShader *)jlong_to_ptr(shader);\n+    [mtlShader disable];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLShader\n+ * Method:    nSetTexture\n+ * Signature: (JIIJZI)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLShader_nSetTexture\n+    (JNIEnv *env, jclass jClass, jlong shader, jint texID, jint uniformID,\n+    jlong nTexturePtr, jboolean isLinear, jint wrapMode)\n+{\n+    MetalShader* mtlShader = (MetalShader*)jlong_to_ptr(shader);\n+    MetalTexture* mtlTex   = (MetalTexture*)jlong_to_ptr(nTexturePtr);\n+    id<MTLTexture> tex     = [mtlTex getTexture];\n+    [mtlShader setTexture:texID uniformID:uniformID texture:tex isLinear:isLinear wrapMode:wrapMode];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLShader\n+ * Method:    nSetInt\n+ * Signature: (JII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLShader_nSetInt\n+    (JNIEnv *env, jclass jClass, jlong shader, jint uniformID, jint i0)\n+{\n+    MetalShader *mtlShader = (MetalShader *)jlong_to_ptr(shader);\n+    [mtlShader setInt:uniformID i0:i0];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLShader\n+ * Method:    nSetFloat1\n+ * Signature: (JIF)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLShader_nSetFloat1\n+    (JNIEnv *env, jclass jClass, jlong shader, jint uniformID, jfloat f0)\n+{\n+    MetalShader *mtlShader = (MetalShader *)jlong_to_ptr(shader);\n+    [mtlShader setFloat1:uniformID f0:f0];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLShader\n+ * Method:    nSetFloat2\n+ * Signature: (JIFF)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLShader_nSetFloat2\n+    (JNIEnv *env, jclass jClass, jlong shader, jint uniformID, jfloat f0, jfloat f1)\n+{\n+    MetalShader *mtlShader = (MetalShader *)jlong_to_ptr(shader);\n+    [mtlShader setFloat2:uniformID f0:f0 f1:f1];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLShader\n+ * Method:    nSetFloat3\n+ * Signature: (JIFFF)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLShader_nSetFloat3\n+    (JNIEnv *env, jclass jClass, jlong shader, jint uniformID,\n+    jfloat f0, jfloat f1, jfloat f2)\n+{\n+    MetalShader *mtlShader = (MetalShader *)jlong_to_ptr(shader);\n+    [mtlShader setFloat3:uniformID f0:f0 f1:f1 f2:f2];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLShader\n+ * Method:    nSetFloat4\n+ * Signature: (JIFFFF)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLShader_nSetFloat4\n+    (JNIEnv *env, jclass jClass, jlong shader, jint uniformID,\n+    jfloat f0, jfloat f1, jfloat f2, jfloat f3)\n+{\n+    MetalShader *mtlShader = (MetalShader *)jlong_to_ptr(shader);\n+    [mtlShader setFloat4:uniformID f0:f0 f1:f1 f2:f2 f3:f3];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLShader\n+ * Method:    nSetConstantsBuf\n+ * Signature: (JILjava\/nio\/FloatBuffer;II)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLShader_nSetConstantsBuf\n+    (JNIEnv *env, jclass class, jlong shader, jint uniformID,\n+    jobject values, jint valuesByteOffset, jint size)\n+{\n+    MetalShader *mtlShader = (MetalShader *)jlong_to_ptr(shader);\n+    float *valuesPtr = (float *) (((char *) (*env)->GetDirectBufferAddress(env, values)) + valuesByteOffset);\n+    [mtlShader setConstants:uniformID values:valuesPtr size:size];\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLShader\n+ * Method:    nSetConstants\n+ * Signature: (JI[FI)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_prism_mtl_MTLShader_nSetConstants\n+  (JNIEnv *env, jclass jClass, jlong shader, jint uniformID,\n+    jfloatArray valuesArray, jint size)\n+{\n+    MetalShader *mtlShader = (MetalShader *)jlong_to_ptr(shader);\n+    jfloat* values = (*env)->GetFloatArrayElements(env, valuesArray, 0);\n+    [mtlShader setConstants:uniformID values:values size:size];\n+    (*env)->ReleaseFloatArrayElements(env, valuesArray, values, 0);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalShader.m","additions":478,"deletions":0,"binary":false,"changes":478,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef METAL_TEXTURE_H\n+#define METAL_TEXTURE_H\n+\n+#import \"MetalContext.h\"\n+\n+enum PFormat {\n+    PFORMAT_INT_ARGB_PRE  = 0,\n+    PFORMAT_BYTE_RGBA_PRE = 1,\n+    PFORMAT_BYTE_BGRA_PRE = 8,\n+    PFORMAT_BYTE_RGB      = 2,\n+    PFORMAT_BYTE_GRAY     = 3,\n+    PFORMAT_BYTE_ALPHA    = 4,\n+    PFORMAT_MULTI_YV_12   = 5,\n+    PFORMAT_BYTE_APPL_422 = 6,\n+    PFORMAT_FLOAT_XYZW    = 7,\n+};\n+\n+@interface MetalTexture : NSObject\n+{\n+    MetalContext *context;\n+\n+    id<MTLTexture> texture;\n+    MTLPixelFormat pixelFormat;\n+\n+    NSUInteger width;\n+    NSUInteger height;\n+\n+    BOOL mipmapped;\n+}\n+- (BOOL) isMipmapped;\n+\n+- (MTLPixelFormat) getPixelFormat;\n+- (id<MTLBuffer>)  getPixelBuffer;\n+- (id<MTLTexture>) getTexture;\n+- (MetalTexture*) createTexture:(MetalContext*)ctx\n+                        ofWidth:(NSUInteger)w\n+                       ofHeight:(NSUInteger)h\n+                    pixelFormat:(NSUInteger)format\n+                      useMipMap:(BOOL)useMipMap;\n+\n+- (void) updateTexture:(void*)pixels\n+                  dstX:(int)dstX\n+                  dstY:(int)dstY\n+                  srcX:(int)srcX\n+                  srcY:(int)srcY\n+                 width:(int)w\n+                height:(int)h\n+            scanStride:(int)scanStride;\n+\n+- (void) updateTextureYUV422:(char*)pixels\n+                        dstX:(int)dstX\n+                        dstY:(int)dstY\n+                        srcX:(int)srcX\n+                        srcY:(int)srcY\n+                       width:(int)w\n+                      height:(int)h\n+                  scanStride:(int)scanStride;\n+\n+- (void) dealloc;\n+\n+@end\n+\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalTexture.h","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,433 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MetalTexture.h\"\n+#import \"MetalPipelineManager.h\"\n+\n+\/\/ ** HELPER METHODS **\n+\n+static unsigned int getPixelSize(enum MTLPixelFormat pixelFormat)\n+{\n+    switch (pixelFormat) {\n+        case MTLPixelFormatA8Unorm:\n+            return 1;\n+        case MTLPixelFormatBGRA8Unorm:\n+            return 4;\n+        case MTLPixelFormatRGBA32Float:\n+            return 16;\n+        default:\n+            return 0;\n+    }\n+}\n+\n+static NSMutableDictionary *getBufferAndOffset(MetalContext* context, unsigned int length)\n+{\n+    NSMutableDictionary<NSNumber *, id<MTLBuffer>> *bufferOffsetDict = [NSMutableDictionary dictionary];\n+    id<MTLBuffer> pixelMTLBuf = nil;\n+    int offset = [[context getDataRingBuffer] reserveBytes:length];\n+    if (offset < 0) {\n+        pixelMTLBuf = [context getTransientBufferWithLength:length];\n+        offset = 0;\n+    } else {\n+        pixelMTLBuf = [[context getDataRingBuffer] getBuffer];\n+    }\n+\n+    [bufferOffsetDict setObject:pixelMTLBuf forKey:@(offset)];\n+    return bufferOffsetDict;\n+}\n+\n+static NSMutableDictionary *copyPixelDataToRingBuffer(MetalContext* context, void* pixels,\n+    int srcx, int srcy, int w, int h, int scanStride, MTLPixelFormat pixelFormat)\n+{\n+    unsigned int pixelSize = getPixelSize(pixelFormat);\n+    unsigned int length = pixelSize * w * h;\n+    NSMutableDictionary<NSNumber *, id<MTLBuffer>> *bufferOffsetDict = getBufferAndOffset(context, length);\n+    NSNumber *offset = [[bufferOffsetDict allKeys] firstObject];\n+    id<MTLBuffer> dstBuf = [[bufferOffsetDict allValues] firstObject];\n+\n+    void *dstBufOffset = dstBuf.contents + [offset intValue];\n+    unsigned int rowLength = pixelSize * w;\n+    void *pixelsSrcOffset = pixels + srcy * scanStride + srcx * pixelSize;\n+\n+    for (int i = 0; i < h; i++) {\n+        memcpy(dstBufOffset + (rowLength * i), pixelsSrcOffset + (scanStride * i), rowLength);\n+    }\n+\n+    return bufferOffsetDict;\n+}\n+\n+@implementation MetalTexture\n+\n+\/\/ This method creates a native MTLTexture\n+- (MetalTexture*) createTexture:(MetalContext*)ctx\n+                        ofWidth:(NSUInteger)w\n+                       ofHeight:(NSUInteger)h\n+                    pixelFormat:(NSUInteger)format\n+                      useMipMap:(BOOL)useMipMap\n+{\n+    self = [super init];\n+    if (self) {\n+        width   = w;\n+        height  = h;\n+        context = ctx;\n+        pixelFormat = MTLPixelFormatBGRA8Unorm;\n+\n+        switch (format) {\n+            case PFORMAT_BYTE_BGRA_PRE:\n+            case PFORMAT_INT_ARGB_PRE:\n+            case PFORMAT_BYTE_RGB:         \/\/ Note: this is actually 3-byte RGB\n+            case PFORMAT_BYTE_GRAY:\n+                pixelFormat = MTLPixelFormatBGRA8Unorm;\n+                break;\n+            case PFORMAT_BYTE_ALPHA:\n+                pixelFormat = MTLPixelFormatA8Unorm;\n+                break;\n+            case PFORMAT_FLOAT_XYZW:\n+                pixelFormat = MTLPixelFormatRGBA32Float;\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        mipmapped = useMipMap;\n+        \/\/ We create 1x1 diffuse map when we have only diffuse\n+        \/\/ color for PhongMaterial, in such a case if generate mipmap\n+        \/\/ it causes assertion error at generateMipMap because\n+        \/\/ mipmapLevelCount will be 1, ignore generating mipmap for\n+        \/\/ texture 1x1\n+        if (useMipMap &&\n+            (width == 1 && height == 1)) {\n+            mipmapped = NO;\n+        }\n+        @autoreleasepool {\n+            MTLTextureDescriptor *texDescriptor =\n+                [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:pixelFormat\n+                                                                   width:width\n+                                                                  height:height\n+                                                               mipmapped:mipmapped];\n+            texDescriptor.storageMode = MTLStorageModePrivate;\n+            \/\/ texDescriptor.usage = MTLTextureUsageShaderWrite | MTLTextureUsageShaderRead;\n+            texDescriptor.usage = MTLTextureUsageUnknown;\n+\n+            texture = [[context getDevice] newTextureWithDescriptor:texDescriptor];\n+        }\n+    }\n+    return self;\n+}\n+\n+- (id<MTLBuffer>) getPixelBuffer\n+{\n+    [context endCurrentRenderEncoder];\n+\n+    id<MTLCommandBuffer> commandBuffer = [context getCurrentCommandBuffer];\n+    @autoreleasepool {\n+        id<MTLBlitCommandEncoder> blitEncoder = [commandBuffer blitCommandEncoder];\n+\n+        if (texture.usage == MTLTextureUsageRenderTarget) {\n+            [blitEncoder synchronizeTexture:texture slice:0 level:0];\n+        }\n+\n+        [blitEncoder copyFromTexture:texture\n+                         sourceSlice:(NSUInteger)0\n+                         sourceLevel:(NSUInteger)0\n+                        sourceOrigin:MTLOriginMake(0, 0, 0)\n+                          sourceSize:MTLSizeMake(texture.width, texture.height, texture.depth)\n+                            toBuffer:[context getPixelBuffer]\n+                   destinationOffset:(NSUInteger)0\n+              destinationBytesPerRow:(NSUInteger)texture.width * getPixelSize(pixelFormat)\n+            destinationBytesPerImage:(NSUInteger)texture.width * texture.height * getPixelSize(pixelFormat)];\n+\n+        [blitEncoder endEncoding];\n+    }\n+    [context commitCurrentCommandBufferAndWait];\n+\n+    return [context getPixelBuffer];\n+}\n+\n+- (void) updateTexture:(void*)pixels\n+                  dstX:(int)dstX\n+                  dstY:(int)dstY\n+                  srcX:(int)srcX\n+                  srcY:(int)srcY\n+                 width:(int)w\n+                height:(int)h\n+            scanStride:(int)scanStride\n+{\n+    NSMutableDictionary* bufferOffsetDict = copyPixelDataToRingBuffer(context, pixels, srcX, srcY,\n+                                                                    w, h, scanStride, pixelFormat);\n+    int offset = [[[bufferOffsetDict allKeys] firstObject] intValue];\n+    id<MTLBuffer> pixelMTLBuf = [[bufferOffsetDict allValues] firstObject];\n+\n+    [context endCurrentRenderEncoder];\n+    id<MTLCommandBuffer> commandBuffer = [context getCurrentCommandBuffer];\n+    @autoreleasepool {\n+        id<MTLBlitCommandEncoder> blitEncoder = [commandBuffer blitCommandEncoder];\n+\n+        [blitEncoder copyFromBuffer:pixelMTLBuf\n+                       sourceOffset:(NSUInteger)offset\n+                  sourceBytesPerRow:(NSUInteger)w * getPixelSize(pixelFormat)\n+                sourceBytesPerImage:(NSUInteger)0 \/\/ 0 for 2D image\n+                         sourceSize:MTLSizeMake(w, h, 1)\n+                          toTexture:texture\n+                   destinationSlice:(NSUInteger)0\n+                   destinationLevel:(NSUInteger)0\n+                  destinationOrigin:MTLOriginMake(dstX, dstY, 0)];\n+\n+        if (texture.usage == MTLTextureUsageRenderTarget) {\n+            [blitEncoder synchronizeTexture:texture slice:0 level:0];\n+        }\n+\n+        if ([self isMipmapped]) {\n+            [blitEncoder generateMipmapsForTexture:texture];\n+        }\n+\n+        [blitEncoder endEncoding];\n+    }\n+}\n+\n+- (void) updateTextureYUV422:(char*)pixels\n+                        dstX:(int)dstX\n+                        dstY:(int)dstY\n+                        srcX:(int)srcX\n+                        srcY:(int)srcY\n+                       width:(int)w\n+                      height:(int)h\n+                  scanStride:(int)scanStride\n+{\n+    id<MTLTexture> tex = [self getTexture];\n+    @autoreleasepool {\n+        id<MTLDevice> device = [context getDevice];\n+\n+        id<MTLBuffer> srcBuff = [[device newBufferWithLength:(w * h * 2)\n+                                                     options:MTLResourceStorageModeManaged] autorelease];\n+        for (int row = 0; row < h; row++) {\n+            \/\/ Copy each row in srcBuff\n+            memcpy(srcBuff.contents + (row * w * 2), pixels, w * 2);\n+            pixels += (w * 2);\n+            pixels += scanStride - (w * 2);\n+        }\n+\n+        [srcBuff didModifyRange:NSMakeRange(0, srcBuff.length)];\n+\n+        [context endCurrentRenderEncoder];\n+\n+        MTLSize threadgroupSize = MTLSizeMake(2, 1, 1);\n+\n+        MTLSize threadgroupCount;\n+        threadgroupCount.width  = w \/ threadgroupSize.width;\n+        threadgroupCount.height = h \/ threadgroupSize.height;\n+        threadgroupCount.depth  = 1;\n+\n+        id<MTLComputePipelineState> computePipelineState =\n+            [[context getPipelineManager] getComputePipelineStateWithFunc:@\"uyvy422_to_rgba\"];\n+\n+        id<MTLCommandBuffer> commandBuffer = [context getCurrentCommandBuffer];\n+\n+        id<MTLComputeCommandEncoder> computeEncoder = [commandBuffer computeCommandEncoder];\n+\n+        [computeEncoder setComputePipelineState:computePipelineState];\n+\n+        [computeEncoder setBuffer:srcBuff\n+                           offset:0\n+                          atIndex:0];\n+\n+        [computeEncoder setTexture:tex\n+                           atIndex:0];\n+\n+        [computeEncoder dispatchThreadgroups:threadgroupCount\n+                       threadsPerThreadgroup:threadgroupSize];\n+\n+        [computeEncoder endEncoding];\n+\n+        [context commitCurrentCommandBuffer];\n+    }\n+}\n+\n+- (id<MTLTexture>) getTexture\n+{\n+    return texture;\n+}\n+\n+- (MTLPixelFormat) getPixelFormat\n+{\n+    return pixelFormat;\n+}\n+\n+- (BOOL) isMipmapped\n+{\n+    return mipmapped;\n+}\n+\n+- (void) dealloc\n+{\n+    if (texture != nil) {\n+        [texture release];\n+        texture = nil;\n+    }\n+    [super dealloc];\n+}\n+\n+@end \/\/ MetalTexture\n+\n+\n+\/\/ ** JNI METHODS **\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLTexture\n+ * Method:    nUpdate\n+ * Signature: (JLjava\/nio\/ByteBuffer;[BIIIIIII)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_prism_mtl_MTLTexture_nUpdate\n+    (JNIEnv *env, jclass jClass, jlong nTexturePtr, jobject buf,\n+    jbyteArray pixData, jint dstx, jint dsty, jint srcx, jint srcy,\n+    jint width, jint height, jint scanStride)\n+{\n+    MetalTexture* mtlTex  = (MetalTexture*)jlong_to_ptr(nTexturePtr);\n+\n+    jint length = pixData?\n+        (*env)->GetArrayLength(env, pixData) :\n+        (jint)((*env)->GetDirectBufferCapacity(env, buf));\n+    length *= sizeof(jbyte);\n+\n+    jbyte* pixels = (jbyte*)((pixData != NULL) ?\n+        (*env)->GetPrimitiveArrayCritical(env, pixData, NULL) :\n+        (*env)->GetDirectBufferAddress(env, buf));\n+\n+    [mtlTex updateTexture:pixels\n+                     dstX:dstx\n+                     dstY:dsty\n+                     srcX:srcx\n+                     srcY:srcy\n+                    width:width\n+                   height:height\n+               scanStride:scanStride];\n+\n+    if (pixData != NULL) {\n+        (*env)->ReleasePrimitiveArrayCritical(env, pixData, pixels, 0);\n+    }\n+\n+    \/\/ TODO: MTL: add error detection and return appropriate jlong\n+    return 0;\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLTexture\n+ * Method:    nUpdateFloat\n+ * Signature: (JLjava\/nio\/FloatBuffer;[FIIIIIII)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_prism_mtl_MTLTexture_nUpdateFloat\n+    (JNIEnv *env, jclass jClass, jlong nTexturePtr, jobject buf,\n+    jfloatArray pixData, jint dstx, jint dsty, jint srcx, jint srcy,\n+    jint width, jint height, jint scanStride)\n+{\n+    MetalTexture* mtlTex  = (MetalTexture*)jlong_to_ptr(nTexturePtr);\n+\n+    jint length = pixData ?\n+        (*env)->GetArrayLength(env, pixData) :\n+        (jint)((*env)->GetDirectBufferCapacity(env, buf));\n+    length *= sizeof(jfloat);\n+\n+    jfloat *pixels = (jfloat*)((pixData != NULL) ?\n+        (*env)->GetPrimitiveArrayCritical(env, pixData, NULL) :\n+        (*env)->GetDirectBufferAddress(env, buf));\n+\n+    [mtlTex updateTexture:pixels\n+                     dstX:dstx\n+                     dstY:dsty\n+                     srcX:srcx\n+                     srcY:srcy\n+                    width:width\n+                   height:height\n+               scanStride:scanStride];\n+\n+    if (pixData != NULL) {\n+        (*env)->ReleasePrimitiveArrayCritical(env, pixData, pixels, 0);\n+    }\n+    \/\/ TODO: MTL: add error detection and return appropriate jlong\n+    return 0;\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLTexture\n+ * Method:    nUpdateInt\n+ * Signature: (JLjava\/nio\/IntBuffer;[IIIIIIII)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_prism_mtl_MTLTexture_nUpdateInt\n+    (JNIEnv *env, jclass jClass, jlong nTexturePtr, jobject buf,\n+    jintArray pixData, jint dstx, jint dsty, jint srcx, jint srcy,\n+    jint width, jint height, jint scanStride)\n+{\n+    MetalTexture* mtlTex  = (MetalTexture*)jlong_to_ptr(nTexturePtr);\n+\n+    jint length = pixData ?\n+        (*env)->GetArrayLength(env, pixData) :\n+        (jint)((*env)->GetDirectBufferCapacity(env, buf));\n+    length *= sizeof(jint);\n+\n+    jint *pixels = (jint*)((pixData != NULL) ?\n+        (*env)->GetPrimitiveArrayCritical(env, pixData, NULL) :\n+        (*env)->GetDirectBufferAddress(env, buf));\n+\n+    [mtlTex updateTexture:pixels\n+                     dstX:dstx\n+                     dstY:dsty\n+                     srcX:srcx\n+                     srcY:srcy\n+                    width:width\n+                   height:height\n+               scanStride:scanStride];\n+\n+    if (pixData != NULL) {\n+        (*env)->ReleasePrimitiveArrayCritical(env, pixData, pixels, 0);\n+    }\/\/ TODO: MTL: add error detection and return appropriate jlong\n+    return 0;\n+}\n+\n+\/*\n+ * Class:     com_sun_prism_mtl_MTLTexture\n+ * Method:    nUpdateInt\n+ * Signature: (J[BIIIIIII)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_prism_mtl_MTLTexture_nUpdateYUV422\n+    (JNIEnv *env, jclass jClass, jlong nTexturePtr, jbyteArray pixData,\n+    jint dstx, jint dsty, jint srcx, jint srcy, jint w, jint h, jint scanStride)\n+{\n+    MetalTexture* mtlTex  = (MetalTexture*)jlong_to_ptr(nTexturePtr);\n+    jbyte* pixels = (*env)->GetByteArrayElements(env, pixData, 0);\n+\n+    [mtlTex updateTextureYUV422:(char*)pixels\n+                           dstX:dstx\n+                           dstY:dsty\n+                           srcX:srcx\n+                           srcY:srcy\n+                          width:w\n+                         height:h\n+                     scanStride:scanStride];\n+\n+    (*env)->ReleaseByteArrayElements(env, pixData, pixels, 0);\n+\n+    \/\/ TODO: MTL: add error detection and return appropriate jlong\n+    return 0;\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/MetalTexture.m","additions":433,"deletions":0,"binary":false,"changes":433,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <metal_stdlib>\n+#include <simd\/simd.h>\n+using namespace metal;\n+\n+\/\/ Following two clearVF\/FF functions are used only for drawing a clear rectangle.\n+\/\/ These are specific to metal implementation and not present for D3D\/ES2.\n+\n+typedef struct CLEAR_VS_INPUT\n+{\n+    packed_float2 position;\n+} CLEAR_VS_INPUT;\n+\n+typedef struct CLEAR_VS_OUTPUT\n+{\n+    vector_float4 position [[position]];\n+} CLEAR_VS_OUTPUT;\n+\n+[[vertex]] CLEAR_VS_OUTPUT clearVF(const    uint            v_id [[ vertex_id ]],\n+                                   constant CLEAR_VS_INPUT* v_in [[ buffer(0) ]])\n+{\n+    CLEAR_VS_OUTPUT out;\n+    out.position = vector_float4(v_in[v_id].position.xy, 0.0, 1.0);\n+    return out;\n+}\n+\n+[[fragment]] float4 clearFF(constant float4& color [[ buffer(2) ]])\n+{\n+    return color;\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/msl\/ClearRttShaders.metal","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <metal_stdlib>\n+#include <simd\/simd.h>\n+\n+using namespace metal;\n+\n+[[kernel]]  void uyvy422_to_rgba(const device uchar4 *YUV422Buff [[buffer(0)]],\n+                            texture2d<half, access::write> outTex [[texture(0)]],\n+                            uint2 gid [[thread_position_in_grid]])\n+{\n+    uchar4 uyvy = YUV422Buff[(gid.y * outTex.get_width()\/2) + gid.x\/2];\n+\n+    half u = (uyvy.r\/255.0) - 0.5;\n+    half v = (uyvy.b\/255.0) - 0.5;\n+\n+    half compR = (half)(1.402 * v);\n+    half compG = (half)(0.34414 * u + 0.71414 * v);\n+    half compB = (half)(1.772 * u);\n+\n+    if (gid.x % 2 == 0) {\n+        \/\/ Pixel at even x position\n+\n+        half y1 = uyvy.g\/255.0;\n+\n+        compR = clamp((y1 + compR), (half)0.0f, (half)1.0f);\n+        compG = clamp((y1 - compG), (half)0.0f, (half)1.0f);\n+        compB = clamp((y1 + compB), (half)0.0f, (half)1.0f);\n+    } else {\n+        \/\/ Pixel at odd x position\n+\n+        half y2 = uyvy.a\/255.0;\n+\n+        compR = clamp((y2 + compR), (half)0.0f, (half)1.0f);\n+        compG = clamp((y2 - compG), (half)0.0f, (half)1.0f);\n+        compB = clamp((y2 + compB), (half)0.0f, (half)1.0f);\n+    }\n+\n+    outTex.write(half4(compR, compG, compB, 1.0), gid);\n+\n+\n+\/* \/\/ This is another way to write this shader -----\n+\n+    if (gid.x % 2 != 0) {\n+        \/\/ 2 RGBA pixels are generated from 4-bytes of YUV422 data\n+        \/\/ A pixel at even x position in outTex, also generates adjacent pixel at x+1 (odd) position\n+        \/\/ Hence, pixels at odd x positions in outTex need not be calculated again\n+        return;\n+    }\n+\n+    uchar4 uyvy = YUV422Buff[(gid.y * outTex.get_width()\/2) + gid.x\/2];\n+\n+    half u = (uyvy.r\/255.0) - 0.5;\n+    half y1 = uyvy.g\/255.0;\n+    half v = (uyvy.b\/255.0) - 0.5;\n+    half y2 = uyvy.a\/255.0;\n+\n+    half compR = (half)(1.402 * v);\n+    half compG = (half)(0.34414 * u + 0.71414 * v);\n+    half compB = (half)(1.772 * u);\n+\n+    \/\/ Compute the color of 1st pixel ---------------------------\n+\n+    half r = clamp((y1 + compR), (half)0.0f, (half)1.0f);\n+    half g = clamp((y1 - compG), (half)0.0f, (half)1.0f);\n+    half b = clamp((y1 + compB), (half)0.0f, (half)1.0f);\n+\n+    outTex.write(half4(r, g, b, 1.0), gid);\n+\n+    \/\/ Compute the color of 2nd pixel ---------------------------\n+\n+    r = clamp((y2 + compR), (half)0.0f, (half)1.0f);\n+    g = clamp((y2 - compG), (half)0.0f, (half)1.0f);\n+    b = clamp((y2 + compB), (half)0.0f, (half)1.0f);\n+\n+    outTex.write(half4(r, g, b, 1.0), uint2(gid.x+1, gid.y));\n+    *\/\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/msl\/ComputeKernels.metal","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <metal_stdlib>\n+#include <simd\/simd.h>\n+using namespace metal;\n+\n+typedef struct VS_INPUT {\n+    packed_float3 position;\n+    packed_float2 texCoord0;\n+    packed_float2 texCoord1;\n+} VS_INPUT;\n+\n+typedef struct VS_COLOR {\n+    uchar4 color;\n+} VS_COLOR;\n+\n+typedef struct VS_OUTPUT\n+{\n+    vector_float4 position [[position]];\n+    vector_float4 fragColor;\n+    vector_float2 texCoord0;\n+    vector_float2 texCoord1;\n+} VS_OUTPUT;\n+\n+[[vertex]] VS_OUTPUT passThrough(const uint v_id [[ vertex_id ]],\n+                      constant VS_INPUT * v_in [[ buffer(0) ]],\n+                      constant float4x4 & mvp_matrix [[ buffer(1) ]],\n+                      constant VS_COLOR * c_in [[ buffer(2) ]])\n+{\n+    VS_OUTPUT out;\n+    out.position    = vector_float4(v_in[v_id].position.xy, 0.0, 1.0) * mvp_matrix;\n+    out.fragColor.r = c_in[v_id].color.r \/ 255.0f;\n+    out.fragColor.g = c_in[v_id].color.g \/ 255.0f;\n+    out.fragColor.b = c_in[v_id].color.b \/ 255.0f;\n+    out.fragColor.a = c_in[v_id].color.a \/ 255.0f;\n+    out.texCoord0   = v_in[v_id].texCoord0;\n+    out.texCoord1   = v_in[v_id].texCoord1;\n+    return out;\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/msl\/PassThroughVS.metal","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <metal_stdlib>\n+#include <simd\/simd.h>\n+#include \"PhongPSDecl.h\"\n+#include \"PhongVS2PS.h\"\n+using namespace metal;\n+\n+#define SPEC_NONE 0\n+#define SPEC_TEX 1\n+#define SPEC_CLR 2\n+#define SPEC_MIX 3\n+\n+constexpr sampler mipmapSampler(filter::linear,\n+                            mip_filter::linear,\n+                               address::repeat);\n+\n+constexpr sampler nonMipmapSampler(filter::linear,\n+                                  address::repeat);\n+\n+float NTSC_Gray(float3 color) {\n+    return dot(color, float3(0.299f, 0.587f, 0.114f));\n+}\n+\n+float computeSpotlightFactor3(float3 l, float3 lightDir, float cosOuter, float denom, float falloff) {\n+    float cosAngle = dot(normalize(-lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0.0f) {\n+        return pow(saturate(cutoff \/ denom), falloff);\n+    }\n+    return cutoff >= 0.0f ? 1.0f : 0.0f;\n+}\n+\n+[[fragment]] float4 PhongPS0(VS_PHONG_INOUT0 vert [[stage_in]],\n+                        constant PS_PHONG_UNIFORMS & psUniforms [[ buffer(0) ]],\n+                        texture2d<float> mapDiffuse [[ texture(0) ]],\n+                        texture2d<float> mapSpecular [[ texture(1) ]],\n+                        texture2d<float> mapBump [[ texture(2) ]],\n+                        texture2d<float> mapSelfIllum [[ texture(3) ]])\n+{\n+    float2 texD = vert.texCoord;\n+\n+    float4 tDiff = mapDiffuse.sample(mipmapSampler, texD);\n+    if (tDiff.a == 0.0f) discard_fragment();\n+    tDiff = tDiff * psUniforms.diffuseColor;\n+\n+    float3 normal = float3(0.0f, 0.0f, 1.0f);\n+\n+    \/\/ bump\n+    if (psUniforms.isBumpMap) {\n+        float4 BumpSpec = mapBump.sample(nonMipmapSampler, texD);\n+        normal = normalize(BumpSpec.xyz * 2.0f - 1.0f);\n+    }\n+\n+    float3 rez = psUniforms.ambientLightColor.rgb * tDiff.rgb;\n+\n+    \/\/ self-illumination\n+    if (psUniforms.isIlluminated) {\n+        rez += mapSelfIllum.sample(mipmapSampler, texD).rgb;\n+    }\n+\n+    return float4(saturate(rez), tDiff.a);\n+}\n+\n+[[fragment]] float4 PhongPS1(VS_PHONG_INOUT1 vert [[stage_in]],\n+                        constant PS_PHONG_UNIFORMS & psUniforms [[ buffer(0) ]],\n+                        texture2d<float> mapDiffuse [[ texture(0) ]],\n+                        texture2d<float> mapSpecular [[ texture(1) ]],\n+                        texture2d<float> mapBump [[ texture(2) ]],\n+                        texture2d<float> mapSelfIllum [[ texture(3) ]])\n+{\n+    float2 texD = vert.texCoord;\n+\n+    float4 tDiff = mapDiffuse.sample(mipmapSampler, texD);\n+    if (tDiff.a == 0.0f) discard_fragment();\n+    tDiff = tDiff * psUniforms.diffuseColor;\n+\n+    float3 normal = float3(0.0f, 0.0f, 1.0f);\n+    \/\/ bump\n+    if (psUniforms.isBumpMap) {\n+        float4 BumpSpec = mapBump.sample(nonMipmapSampler, texD);\n+        normal = normalize(BumpSpec.xyz * 2.0f - 1.0f);\n+    }\n+    \/\/ specular\n+    float4 tSpec = 0.0f;\n+    float specPower = 32.0f;\n+    if (psUniforms.specType > 0) {\n+        specPower = psUniforms.specColor.a;\n+        if (psUniforms.specType != SPEC_CLR) { \/\/ Texture or Mix\n+            tSpec = mapSpecular.sample(nonMipmapSampler, texD);\n+            specPower *= NTSC_Gray(tSpec.rgb);\n+        } else { \/\/ Color\n+            tSpec.rgb = psUniforms.specColor.rgb;\n+        }\n+        if (psUniforms.specType == SPEC_MIX) {\n+            tSpec.rgb *= psUniforms.specColor.rgb;\n+        }\n+    }\n+\n+    \/\/ lighting\n+    float3 worldNormVecToEye = normalize(vert.worldVecToEye);\n+    float3 refl = reflect(worldNormVecToEye, normal);\n+    float3 diffLightColor = 0.0f;\n+    float3 specLightColor = 0.0f;\n+\n+    float3 lightColor = float3(psUniforms.lightsColor[0],\n+                               psUniforms.lightsColor[1],\n+                               psUniforms.lightsColor[2]);\n+    float4 lightAttenuation = float4(psUniforms.lightsAttenuation[0],\n+                                     psUniforms.lightsAttenuation[1],\n+                                     psUniforms.lightsAttenuation[2],\n+                                     psUniforms.lightsAttenuation[3]);\n+    float3 spotLightsFactor = float3(psUniforms.spotLightsFactors[0],\n+                                     psUniforms.spotLightsFactors[1],\n+                                     psUniforms.spotLightsFactors[2]);\n+\n+    \/\/ Testing if w is 0 or 1 using < 0.5 since equality check\n+    \/\/ for floating points might not work well\n+    if (lightAttenuation.w < 0.5f) {\n+        diffLightColor += saturate(dot(normal, -vert.worldNormLightDirs1)) * lightColor;\n+        specLightColor += pow(saturate(dot(-refl, -vert.worldNormLightDirs1)), specPower) * lightColor;\n+    } else {\n+        float dist = length(vert.worldVecsToLights1);\n+        if (dist <= psUniforms.lightsRange[0]) {\n+            float3 l = normalize(vert.worldVecsToLights1);\n+\n+            float cosOuter = spotLightsFactor.x;\n+            float denom = spotLightsFactor.y;\n+            float falloff = spotLightsFactor.z;\n+            float spotlightFactor = computeSpotlightFactor3(l, vert.worldNormLightDirs1, cosOuter, denom, falloff);\n+\n+            float ca = lightAttenuation.x;\n+            float la = lightAttenuation.y;\n+            float qa = lightAttenuation.z;\n+            float invAttnFactor = ca + la * dist + qa * dist * dist;\n+\n+            float3 attenuatedColor = lightColor * spotlightFactor \/ invAttnFactor;\n+            diffLightColor += saturate(dot(normal, l)) * attenuatedColor;\n+            specLightColor += pow(saturate(dot(-refl, l)), specPower) * attenuatedColor;\n+        }\n+    }\n+\n+    float3 ambLightColor = psUniforms.ambientLightColor.rgb;\n+\n+    float3 rez = (ambLightColor + diffLightColor) * tDiff.rgb + specLightColor * tSpec.rgb;\n+\n+    \/\/ self-illumination\n+    if (psUniforms.isIlluminated) {\n+        rez += mapSelfIllum.sample(mipmapSampler, texD).rgb;\n+    }\n+\n+    return float4(saturate(rez), tDiff.a);\n+}\n+\n+[[fragment]] float4 PhongPS2(VS_PHONG_INOUT2 vert [[stage_in]],\n+                        constant PS_PHONG_UNIFORMS & psUniforms [[ buffer(0) ]],\n+                        texture2d<float> mapDiffuse [[ texture(0) ]],\n+                        texture2d<float> mapSpecular [[ texture(1) ]],\n+                        texture2d<float> mapBump [[ texture(2) ]],\n+                        texture2d<float> mapSelfIllum [[ texture(3) ]])\n+{\n+   float2 texD = vert.texCoord;\n+\n+    float4 tDiff = mapDiffuse.sample(mipmapSampler, texD);\n+    if (tDiff.a == 0.0f) discard_fragment();\n+    tDiff = tDiff * psUniforms.diffuseColor;\n+\n+    float3 normal = float3(0.0f, 0.0f, 1.0f);\n+\n+    \/\/ bump\n+    if (psUniforms.isBumpMap) {\n+        float4 BumpSpec = mapBump.sample(nonMipmapSampler, texD);\n+        normal = normalize(BumpSpec.xyz * 2.0f - 1.0f);\n+    }\n+    \/\/ specular\n+    float4 tSpec = 0.0f;\n+    float specPower = 32.0f;\n+    if (psUniforms.specType > 0) {\n+        specPower = psUniforms.specColor.a;\n+        if (psUniforms.specType != SPEC_CLR) { \/\/ Texture or Mix\n+            tSpec = mapSpecular.sample(nonMipmapSampler, texD);\n+            specPower *= NTSC_Gray(tSpec.rgb);\n+        } else { \/\/ Color\n+            tSpec.rgb = psUniforms.specColor.rgb;\n+        }\n+        if (psUniforms.specType == SPEC_MIX) {\n+            tSpec.rgb *= psUniforms.specColor.rgb;\n+        }\n+    }\n+\n+    \/\/ lighting\n+    float3 worldNormVecToEye = normalize(vert.worldVecToEye);\n+    float3 refl = reflect(worldNormVecToEye, normal);\n+    float3 diffLightColor = 0.0f;\n+    float3 specLightColor = 0.0f;\n+\n+    for (int i = 0; i < psUniforms.numLights; i++) {\n+\n+        float3 light;\n+        float3 lightDir;\n+        switch (i) {\n+            case 0 :\n+                light = vert.worldVecsToLights1;\n+                lightDir = vert.worldNormLightDirs1;\n+                break;\n+            case 1 :\n+                light = vert.worldVecsToLights2;\n+                lightDir = vert.worldNormLightDirs2;\n+                break;\n+        }\n+        float3 lightColor = float3(psUniforms.lightsColor[(i * 4)],\n+                                   psUniforms.lightsColor[(i * 4) + 1],\n+                                   psUniforms.lightsColor[(i * 4) + 2]);\n+        float4 lightAttenuation = float4(psUniforms.lightsAttenuation[(i * 4)],\n+                                         psUniforms.lightsAttenuation[(i * 4) + 1],\n+                                         psUniforms.lightsAttenuation[(i * 4) + 2],\n+                                         psUniforms.lightsAttenuation[(i * 4) + 3]);\n+        float3 spotLightsFactor = float3(psUniforms.spotLightsFactors[(i * 4)],\n+                                         psUniforms.spotLightsFactors[(i * 4) + 1],\n+                                         psUniforms.spotLightsFactors[(i * 4) + 2]);\n+\n+        \/\/ Testing if w is 0 or 1 using < 0.5 since equality check\n+        \/\/ for floating points might not work well\n+        if (lightAttenuation.w < 0.5f) {\n+            diffLightColor += saturate(dot(normal, -lightDir)) * lightColor;\n+            specLightColor += pow(saturate(dot(-refl, -lightDir)), specPower) * lightColor;\n+        } else {\n+            float dist = length(light);\n+            if (dist <= psUniforms.lightsRange[(i * 4)]) {\n+                float3 l = normalize(light);\n+\n+                float cosOuter = spotLightsFactor.x;\n+                float denom = spotLightsFactor.y;\n+                float falloff = spotLightsFactor.z;\n+                float spotlightFactor = computeSpotlightFactor3(l, lightDir, cosOuter, denom, falloff);\n+\n+                float ca = lightAttenuation.x;\n+                float la = lightAttenuation.y;\n+                float qa = lightAttenuation.z;\n+                float invAttnFactor = ca + la * dist + qa * dist * dist;\n+\n+                float3 attenuatedColor = lightColor * spotlightFactor \/ invAttnFactor;\n+                diffLightColor += saturate(dot(normal, l)) * attenuatedColor;\n+                specLightColor += pow(saturate(dot(-refl, l)), specPower) * attenuatedColor;\n+            }\n+        }\n+    }\n+\n+    float3 ambLightColor = psUniforms.ambientLightColor.rgb;\n+\n+    float3 rez = (ambLightColor + diffLightColor) * tDiff.rgb + specLightColor * tSpec.rgb;\n+\n+    \/\/ self-illumination\n+    if (psUniforms.isIlluminated) {\n+        rez += mapSelfIllum.sample(mipmapSampler, texD).rgb;\n+    }\n+\n+    return float4(saturate(rez), tDiff.a);\n+}\n+\n+[[fragment]] float4 PhongPS3(VS_PHONG_INOUT3 vert [[stage_in]],\n+                        constant PS_PHONG_UNIFORMS & psUniforms [[ buffer(0) ]],\n+                        texture2d<float> mapDiffuse [[ texture(0) ]],\n+                        texture2d<float> mapSpecular [[ texture(1) ]],\n+                        texture2d<float> mapBump [[ texture(2) ]],\n+                        texture2d<float> mapSelfIllum [[ texture(3) ]])\n+{\n+    float2 texD = vert.texCoord;\n+\n+    float4 tDiff = mapDiffuse.sample(mipmapSampler, texD);\n+    if (tDiff.a == 0.0f) discard_fragment();\n+    tDiff = tDiff * psUniforms.diffuseColor;\n+\n+    float3 normal = float3(0.0f, 0.0f, 1.0f);\n+\n+    \/\/ bump\n+    if (psUniforms.isBumpMap) {\n+        float4 BumpSpec = mapBump.sample(nonMipmapSampler, texD);\n+        normal = normalize(BumpSpec.xyz * 2.0f - 1.0f);\n+    }\n+    \/\/ specular\n+    float4 tSpec = 0.0f;\n+    float specPower = 32.0f;\n+    if (psUniforms.specType > 0) {\n+        specPower = psUniforms.specColor.a;\n+        if (psUniforms.specType != SPEC_CLR) { \/\/ Texture or Mix\n+            tSpec = mapSpecular.sample(nonMipmapSampler, texD);\n+            specPower *= NTSC_Gray(tSpec.rgb);\n+        } else { \/\/ Color\n+            tSpec.rgb = psUniforms.specColor.rgb;\n+        }\n+        if (psUniforms.specType == SPEC_MIX) {\n+            tSpec.rgb *= psUniforms.specColor.rgb;\n+        }\n+    }\n+\n+    \/\/ lighting\n+    float3 worldNormVecToEye = normalize(vert.worldVecToEye);\n+    float3 refl = reflect(worldNormVecToEye, normal);\n+    float3 diffLightColor = 0.0f;\n+    float3 specLightColor = 0.0f;\n+\n+    for (int i = 0; i < psUniforms.numLights; i++) {\n+        float3 light;\n+        float3 lightDir;\n+        switch (i) {\n+            case 0 :\n+                light = vert.worldVecsToLights1;\n+                lightDir = vert.worldNormLightDirs1;\n+                break;\n+            case 1 :\n+                light = vert.worldVecsToLights2;\n+                lightDir = vert.worldNormLightDirs2;\n+                break;\n+            case 2 :\n+                light = vert.worldVecsToLights3;\n+                lightDir = vert.worldNormLightDirs3;\n+                break;\n+        }\n+        float3 lightColor = float3(psUniforms.lightsColor[(i * 4)],\n+                                   psUniforms.lightsColor[(i * 4) + 1],\n+                                   psUniforms.lightsColor[(i * 4) + 2]);\n+        float4 lightAttenuation = float4(psUniforms.lightsAttenuation[(i * 4)],\n+                                         psUniforms.lightsAttenuation[(i * 4) + 1],\n+                                         psUniforms.lightsAttenuation[(i * 4) + 2],\n+                                         psUniforms.lightsAttenuation[(i * 4) + 3]);\n+        float3 spotLightsFactor = float3(psUniforms.spotLightsFactors[(i * 4)],\n+                                         psUniforms.spotLightsFactors[(i * 4) + 1],\n+                                         psUniforms.spotLightsFactors[(i * 4) + 2]);\n+\n+        \/\/ Testing if w is 0 or 1 using < 0.5 since equality check\n+        \/\/ for floating points might not work well\n+        if (lightAttenuation.w < 0.5f) {\n+            diffLightColor += saturate(dot(normal, -lightDir)) * lightColor;\n+            specLightColor += pow(saturate(dot(-refl, -lightDir)), specPower) * lightColor;\n+        } else {\n+            float dist = length(light);\n+            if (dist <= psUniforms.lightsRange[(i * 4)]) {\n+                float3 l = normalize(light);\n+\n+                float cosOuter = spotLightsFactor.x;\n+                float denom = spotLightsFactor.y;\n+                float falloff = spotLightsFactor.z;\n+                float spotlightFactor = computeSpotlightFactor3(l, lightDir, cosOuter, denom, falloff);\n+\n+                float ca = lightAttenuation.x;\n+                float la = lightAttenuation.y;\n+                float qa = lightAttenuation.z;\n+                float invAttnFactor = ca + la * dist + qa * dist * dist;\n+\n+                float3 attenuatedColor = lightColor * spotlightFactor \/ invAttnFactor;\n+                diffLightColor += saturate(dot(normal, l)) * attenuatedColor;\n+                specLightColor += pow(saturate(dot(-refl, l)), specPower) * attenuatedColor;\n+            }\n+        }\n+    }\n+\n+    float3 ambLightColor = psUniforms.ambientLightColor.rgb;\n+\n+    float3 rez = (ambLightColor + diffLightColor) * tDiff.rgb + specLightColor * tSpec.rgb;\n+\n+    \/\/ self-illumination\n+    if (psUniforms.isIlluminated) {\n+        rez += mapSelfIllum.sample(mipmapSampler, texD).rgb;\n+    }\n+\n+    return float4(saturate(rez), tDiff.a);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/msl\/PhongPS.metal","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#define MAX_NUM_LIGHTS 3\n+\n+struct PS_PHONG_UNIFORMS {\n+    packed_float4 diffuseColor;\n+    packed_float4 ambientLightColor;\n+    packed_float4 specColor;\n+    float lightsColor[MAX_NUM_LIGHTS * 4];\n+    float lightsAttenuation[MAX_NUM_LIGHTS * 4];\n+    float lightsRange[MAX_NUM_LIGHTS * 4];\n+    float spotLightsFactors[MAX_NUM_LIGHTS * 4];\n+    int numLights;\n+    int specType;\n+    bool isBumpMap;\n+    bool isIlluminated;\n+};\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/msl\/PhongPSDecl.h","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <metal_stdlib>\n+#include <simd\/simd.h>\n+#include \"PhongVSDecl.h\"\n+#include \"PhongVS2PS.h\"\n+using namespace metal;\n+\n+void quatToMatrix(float4 q, float3 N[3]) {\n+    float3 t1 = q.xyz * q.yzx * 2;\n+    float3 t2 = q.zxy * q.www * 2;\n+    float3 t3 = q.xyz * q.xyz * 2;\n+    float3 t4 = 1 - (t3 + t3.yzx);\n+\n+    float3 r1 = t1 + t2;\n+    float3 r2 = t1 - t2;\n+\n+    N[0] = float3(t4.y, r1.x, r2.z);\n+    N[1] = float3(r2.x, t4.z, r1.y);\n+    N[2] = float3(r1.z, r2.y, t4.x);\n+\n+    N[2] *= (q.w >= 0) ? 1.0f : -1.0f;   \/\/ ATI normal map generator compatibility\n+}\n+\n+float3 getLocalVector(float3 global, float3 N[3]) {\n+    return float3(dot(global, N[1]), dot(global, N[2]), dot(global, N[0]));\n+}\n+\n+[[vertex]] VS_PHONG_INOUT0 PhongVS0(const uint v_id [[ vertex_id ]],\n+                      constant VS_PHONG_INPUT * v_in [[ buffer(0) ]],\n+                      constant VS_PHONG_UNIFORMS & vsUniforms [[ buffer(1) ]])\n+{\n+    VS_PHONG_INOUT0 out;\n+    out.texCoord = v_in[v_id].texCoord;\n+    float4 worldVertexPos = vsUniforms.world_matrix * (float4(v_in[v_id].position, 1.0));\n+\n+    out.position = vsUniforms.mvp_matrix * worldVertexPos;\n+\n+    float3 n[3];\n+    quatToMatrix(v_in[v_id].normal, n);\n+    float3x3 sWorldMatrix = float3x3(vsUniforms.world_matrix[0].xyz,\n+                                     vsUniforms.world_matrix[1].xyz,\n+                                     vsUniforms.world_matrix[2].xyz);\n+    for (int i = 0; i != 3; ++i) {\n+        n[i] = sWorldMatrix * n[i];\n+    }\n+\n+    float3 worldVecToEye = vsUniforms.cameraPos.xyz - worldVertexPos.xyz;\n+    out.worldVecToEye = getLocalVector(worldVecToEye, n);\n+\n+    return out;\n+}\n+\n+[[vertex]] VS_PHONG_INOUT1 PhongVS1(const uint v_id [[ vertex_id ]],\n+                      constant VS_PHONG_INPUT * v_in [[ buffer(0) ]],\n+                      constant VS_PHONG_UNIFORMS & vsUniforms [[ buffer(1) ]])\n+{\n+    VS_PHONG_INOUT1 out;\n+    out.texCoord = v_in[v_id].texCoord;\n+    float4 worldVertexPos = vsUniforms.world_matrix * (float4(v_in[v_id].position, 1.0));\n+\n+    out.position = vsUniforms.mvp_matrix * worldVertexPos;\n+\n+    float3 n[3];\n+    quatToMatrix(v_in[v_id].normal, n);\n+    float3x3 sWorldMatrix = float3x3(vsUniforms.world_matrix[0].xyz,\n+                                     vsUniforms.world_matrix[1].xyz,\n+                                     vsUniforms.world_matrix[2].xyz);\n+    for (int i = 0; i != 3; ++i) {\n+        n[i] = sWorldMatrix * n[i];\n+    }\n+\n+    float3 worldVecToEye = vsUniforms.cameraPos.xyz - worldVertexPos.xyz;\n+    out.worldVecToEye = getLocalVector(worldVecToEye, n);\n+\n+    float3 worldVecToLight = vsUniforms.lightsPosition[0] - worldVertexPos.xyz;\n+    out.worldVecsToLights1 = getLocalVector(worldVecToLight, n);\n+    out.worldNormLightDirs1 = getLocalVector(vsUniforms.lightsNormDirection[0], n);\n+\n+    return out;\n+}\n+\n+[[vertex]] VS_PHONG_INOUT2 PhongVS2(const uint v_id [[ vertex_id ]],\n+                      constant VS_PHONG_INPUT * v_in [[ buffer(0) ]],\n+                      constant VS_PHONG_UNIFORMS & vsUniforms [[ buffer(1) ]])\n+{\n+    VS_PHONG_INOUT2 out;\n+    out.texCoord = v_in[v_id].texCoord;\n+    float4 worldVertexPos = vsUniforms.world_matrix * (float4(v_in[v_id].position, 1.0));\n+\n+    out.position = vsUniforms.mvp_matrix * worldVertexPos;\n+\n+    float3 n[3];\n+    quatToMatrix(v_in[v_id].normal, n);\n+    float3x3 sWorldMatrix = float3x3(vsUniforms.world_matrix[0].xyz,\n+                                     vsUniforms.world_matrix[1].xyz,\n+                                     vsUniforms.world_matrix[2].xyz);\n+    for (int i = 0; i != 3; ++i) {\n+        n[i] = sWorldMatrix * n[i];\n+    }\n+\n+    float3 worldVecToEye = vsUniforms.cameraPos.xyz - worldVertexPos.xyz;\n+    out.worldVecToEye = getLocalVector(worldVecToEye, n);\n+\n+    float3 worldVecToLight = vsUniforms.lightsPosition[0] - worldVertexPos.xyz;\n+    out.worldVecsToLights1 = getLocalVector(worldVecToLight, n);\n+    out.worldNormLightDirs1 = getLocalVector(vsUniforms.lightsNormDirection[0], n);\n+\n+    worldVecToLight = vsUniforms.lightsPosition[1] - worldVertexPos.xyz;\n+    out.worldVecsToLights2 = getLocalVector(worldVecToLight, n);\n+    out.worldNormLightDirs2 = getLocalVector(vsUniforms.lightsNormDirection[1], n);\n+\n+    return out;\n+}\n+\n+[[vertex]] VS_PHONG_INOUT3 PhongVS3(const uint v_id [[ vertex_id ]],\n+                      constant VS_PHONG_INPUT * v_in [[ buffer(0) ]],\n+                      constant VS_PHONG_UNIFORMS & vsUniforms [[ buffer(1) ]])\n+{\n+    VS_PHONG_INOUT3 out;\n+    out.texCoord = v_in[v_id].texCoord;\n+    float4 worldVertexPos = vsUniforms.world_matrix * (float4(v_in[v_id].position, 1.0));\n+\n+    out.position = vsUniforms.mvp_matrix * worldVertexPos;\n+\n+    float3 n[3];\n+    quatToMatrix(v_in[v_id].normal, n);\n+    float3x3 sWorldMatrix = float3x3(vsUniforms.world_matrix[0].xyz,\n+                                     vsUniforms.world_matrix[1].xyz,\n+                                     vsUniforms.world_matrix[2].xyz);\n+    for (int i = 0; i != 3; ++i) {\n+        n[i] = sWorldMatrix * n[i];\n+    }\n+\n+    float3 worldVecToEye = vsUniforms.cameraPos.xyz - worldVertexPos.xyz;\n+    out.worldVecToEye = getLocalVector(worldVecToEye, n);\n+\n+    float3 worldVecToLight = vsUniforms.lightsPosition[0] - worldVertexPos.xyz;\n+    out.worldVecsToLights1 = getLocalVector(worldVecToLight, n);\n+    out.worldNormLightDirs1 = getLocalVector(vsUniforms.lightsNormDirection[0], n);\n+\n+    worldVecToLight = vsUniforms.lightsPosition[1] - worldVertexPos.xyz;\n+    out.worldVecsToLights2 = getLocalVector(worldVecToLight, n);\n+    out.worldNormLightDirs2 = getLocalVector(vsUniforms.lightsNormDirection[1], n);\n+\n+    worldVecToLight = vsUniforms.lightsPosition[2] - worldVertexPos.xyz;\n+    out.worldVecsToLights3 = getLocalVector(worldVecToLight, n);\n+    out.worldNormLightDirs3 = getLocalVector(vsUniforms.lightsNormDirection[2], n);\n+\n+    return out;\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/msl\/PhongVS.metal","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#define MAX_NUM_LIGHTS 3\n+\n+struct VS_PHONG_INOUT0 {\n+    float4 position [[position]];\n+    float2 texCoord;\n+    float3 worldVecToEye;\n+};\n+\n+struct VS_PHONG_INOUT1 {\n+    float4 position [[position]];\n+    float2 texCoord;\n+    float3 worldVecToEye;\n+    float3 worldVecsToLights1;\n+    float3 worldNormLightDirs1;\n+};\n+\n+struct VS_PHONG_INOUT2 {\n+    float4 position [[position]];\n+    float2 texCoord;\n+    float3 worldVecToEye;\n+    float3 worldVecsToLights1;\n+    float3 worldVecsToLights2;\n+    float3 worldNormLightDirs1;\n+    float3 worldNormLightDirs2;\n+};\n+\n+struct VS_PHONG_INOUT3 {\n+    float4 position [[position]];\n+    float2 texCoord;\n+    float3 worldVecToEye;\n+    float3 worldVecsToLights1;\n+    float3 worldVecsToLights2;\n+    float3 worldVecsToLights3;\n+    float3 worldNormLightDirs1;\n+    float3 worldNormLightDirs2;\n+    float3 worldNormLightDirs3;\n+};\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/msl\/PhongVS2PS.h","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#define MAX_NUM_LIGHTS 3\n+\n+struct VS_PHONG_INPUT {\n+    packed_float3 position;\n+    packed_float2 texCoord;\n+    packed_float4 normal;\n+};\n+\n+struct VS_PHONG_UNIFORMS {\n+    simd_float4x4 mvp_matrix;\n+    simd_float4x4 world_matrix;\n+    packed_float4 cameraPos;\n+    packed_float3 lightsPosition[MAX_NUM_LIGHTS];\n+    packed_float3 lightsNormDirection[MAX_NUM_LIGHTS];\n+    float numLights;\n+};\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-mtl\/msl\/PhongVSDecl.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"}]}