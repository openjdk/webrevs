{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## GStreamer v1.24.10\n+## GStreamer v1.26.5\n@@ -6,1 +6,1 @@\n-You are receiving a copy of GStreamer, Version: 1.24.10 in either source or\n+You are receiving a copy of GStreamer, Version: 1.26.5 in either source or\n@@ -8,1 +8,1 @@\n-Oracle license do NOT apply to the GStreamer, Version: 1.24.10; it is\n+Oracle license do NOT apply to the GStreamer, Version: 1.26.5; it is\n@@ -70,1 +70,1 @@\n-Copyright (C) 2006-2009 Jan Schmidt <thaytan@noraisin.net>\n+Copyright (C) 2007-2009 Jan Schmidt <thaytan@noraisin.net>\n@@ -104,0 +104,1 @@\n+Copyright (C) 2024 Sebastian Dröge <sebastian@centricular.com>\n@@ -110,0 +111,1 @@\n+Copyright (C) 2015 Tim-Philipp Müller <tim@centricular.com>\n@@ -114,1 +116,0 @@\n-Copyright (C) 2015 Tim-Philipp Müller <tim@centricular.com>\n","filename":"modules\/javafx.media\/src\/main\/legal\/gstreamer.md","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -18,535 +18,541 @@\n-g_ascii_strncasecmp\t@17\tNONAME\n-g_ascii_strtod\t@18\tNONAME\n-g_ascii_strtoll\t@19\tNONAME\n-g_ascii_strtoull\t@20\tNONAME\n-g_ascii_strup\t@21\tNONAME\n-g_ascii_table\t@22\tNONAME\n-g_ascii_tolower\t@23\tNONAME\n-g_ascii_toupper\t@24\tNONAME\n-g_assertion_message_cmpint\t@25\tNONAME\n-g_assertion_message_cmpnum\t@26\tNONAME\n-g_atomic_int_add\t@27\tNONAME\n-g_atomic_int_compare_and_exchange\t@28\tNONAME\n-g_atomic_int_dec_and_test\t@29\tNONAME\n-g_atomic_int_get\t@30\tNONAME\n-g_atomic_int_inc\t@31\tNONAME\n-g_atomic_int_set\t@32\tNONAME\n-g_atomic_pointer_compare_and_exchange\t@33\tNONAME\n-g_atomic_pointer_get\t@34\tNONAME\n-g_atomic_pointer_set\t@35\tNONAME\n-g_atomic_rc_box_acquire\t@36\tNONAME\n-g_atomic_rc_box_alloc\t@37\tNONAME\n-g_atomic_rc_box_release_full\t@38\tNONAME\n-g_base64_decode\t@39\tNONAME\n-g_base64_decode_inplace\t@40\tNONAME\n-g_base64_encode\t@41\tNONAME\n-g_boxed_type_register_static\t@42\tNONAME\n-g_build_filename\t@43\tNONAME\n-g_build_filenamev\t@44\tNONAME\n-g_byte_array_set_size\t@45\tNONAME\n-g_bytes_compare\t@46\tNONAME\n-g_bytes_get_data\t@47\tNONAME\n-g_bytes_get_type\t@48\tNONAME\n-g_bytes_new\t@49\tNONAME\n-g_bytes_new_take\t@50\tNONAME\n-g_bytes_ref\t@51\tNONAME\n-g_bytes_unref\t@52\tNONAME\n-g_cclosure_marshal_VOID__VOID\t@53\tNONAME\n-g_cclosure_marshal_generic\t@54\tNONAME\n-g_checksum_free\t@55\tNONAME\n-g_checksum_get_string\t@56\tNONAME\n-g_checksum_new\t@57\tNONAME\n-g_checksum_update\t@58\tNONAME\n-g_clear_error\t@59\tNONAME\n-g_cond_broadcast\t@60\tNONAME\n-g_cond_clear\t@61\tNONAME\n-g_cond_init\t@62\tNONAME\n-g_cond_signal\t@63\tNONAME\n-g_cond_wait\t@64\tNONAME\n-g_cond_wait_until\t@65\tNONAME\n-g_convert\t@66\tNONAME\n-g_datalist_id_get_data\t@67\tNONAME\n-g_datalist_id_set_data_full\t@68\tNONAME\n-g_datalist_init\t@69\tNONAME\n-g_date_free\t@70\tNONAME\n-g_date_get_day\t@71\tNONAME\n-g_date_get_julian\t@72\tNONAME\n-g_date_get_month\t@73\tNONAME\n-g_date_get_type\t@74\tNONAME\n-g_date_get_year\t@75\tNONAME\n-g_date_new_dmy\t@76\tNONAME\n-g_date_time_add\t@77\tNONAME\n-g_date_time_add_minutes\t@78\tNONAME\n-g_date_time_add_seconds\t@79\tNONAME\n-g_date_time_compare\t@80\tNONAME\n-g_date_time_get_day_of_month\t@81\tNONAME\n-g_date_time_get_hour\t@82\tNONAME\n-g_date_time_get_microsecond\t@83\tNONAME\n-g_date_time_get_minute\t@84\tNONAME\n-g_date_time_get_month\t@85\tNONAME\n-g_date_time_get_second\t@86\tNONAME\n-g_date_time_get_type\t@87\tNONAME\n-g_date_time_get_utc_offset\t@88\tNONAME\n-g_date_time_get_year\t@89\tNONAME\n-g_date_time_get_ymd\t@90\tNONAME\n-g_date_time_new\t@91\tNONAME\n-g_date_time_new_from_unix_local\t@92\tNONAME\n-g_date_time_new_from_unix_utc\t@93\tNONAME\n-g_date_time_new_local\t@94\tNONAME\n-g_date_time_new_now_local\t@95\tNONAME\n-g_date_time_new_now_utc\t@96\tNONAME\n-g_date_time_new_utc\t@97\tNONAME\n-g_date_time_to_local\t@98\tNONAME\n-g_date_time_to_unix\t@99\tNONAME\n-g_date_time_unref\t@100\tNONAME\n-g_date_valid\t@101\tNONAME\n-g_date_valid_dmy\t@102\tNONAME\n-g_dgettext\t@103\tNONAME\n-g_dir_close\t@104\tNONAME\n-g_dir_open\t@105\tNONAME\n-g_dir_read_name\t@106\tNONAME\n-g_enum_get_value\t@107\tNONAME\n-g_enum_get_value_by_name\t@108\tNONAME\n-g_enum_get_value_by_nick\t@109\tNONAME\n-g_enum_register_static\t@110\tNONAME\n-g_error_free\t@111\tNONAME\n-g_error_get_type\t@112\tNONAME\n-g_error_new\t@113\tNONAME\n-g_error_new_literal\t@114\tNONAME\n-g_file_set_contents\t@115\tNONAME\n-g_file_test\t@116\tNONAME\n-g_filename_to_uri\t@117\tNONAME\n-g_flags_get_first_value\t@118\tNONAME\n-g_flags_get_value_by_name\t@119\tNONAME\n-g_flags_get_value_by_nick\t@120\tNONAME\n-g_flags_register_static\t@121\tNONAME\n-g_free\t@122\tNONAME\n-g_get_charset\t@123\tNONAME\n-g_get_current_dir\t@124\tNONAME\n-g_get_current_time\t@125\tNONAME\n-g_get_monotonic_time\t@126\tNONAME\n-g_get_prgname\t@127\tNONAME\n-g_get_real_time\t@128\tNONAME\n-g_get_user_cache_dir\t@129\tNONAME\n-g_get_user_data_dir\t@130\tNONAME\n-g_getenv\t@131\tNONAME\n-g_gtype_get_type\t@132\tNONAME\n-g_hash_table_contains\t@133\tNONAME\n-g_hash_table_destroy\t@134\tNONAME\n-g_hash_table_foreach\t@135\tNONAME\n-g_hash_table_foreach_remove\t@136\tNONAME\n-g_hash_table_get_keys\t@137\tNONAME\n-g_hash_table_get_values\t@138\tNONAME\n-g_hash_table_insert\t@139\tNONAME\n-g_hash_table_iter_init\t@140\tNONAME\n-g_hash_table_iter_next\t@141\tNONAME\n-g_hash_table_lookup\t@142\tNONAME\n-g_hash_table_new\t@143\tNONAME\n-g_hash_table_new_full\t@144\tNONAME\n-g_hash_table_ref\t@145\tNONAME\n-g_hash_table_remove\t@146\tNONAME\n-g_hash_table_replace\t@147\tNONAME\n-g_hash_table_size\t@148\tNONAME\n-g_hash_table_unref\t@149\tNONAME\n-g_hook_alloc\t@150\tNONAME\n-g_hook_destroy_link\t@151\tNONAME\n-g_hook_get\t@152\tNONAME\n-g_hook_insert_before\t@153\tNONAME\n-g_hook_list_clear\t@154\tNONAME\n-g_hook_list_init\t@155\tNONAME\n-g_hook_list_marshal\t@156\tNONAME\n-g_hook_ref\t@157\tNONAME\n-g_hook_unref\t@158\tNONAME\n-g_initially_unowned_get_type\t@159\tNONAME\n-g_int_equal\t@160\tNONAME\n-g_int_hash\t@161\tNONAME\n-g_intern_static_string\t@162\tNONAME\n-g_intern_string\t@163\tNONAME\n-g_key_file_free\t@164\tNONAME\n-g_key_file_get_comment\t@165\tNONAME\n-g_key_file_get_groups\t@166\tNONAME\n-g_key_file_get_keys\t@167\tNONAME\n-g_key_file_get_value\t@168\tNONAME\n-g_key_file_has_group\t@169\tNONAME\n-g_key_file_load_from_file\t@170\tNONAME\n-g_key_file_new\t@171\tNONAME\n-g_key_file_remove_group\t@172\tNONAME\n-g_key_file_remove_key\t@173\tNONAME\n-g_key_file_set_comment\t@174\tNONAME\n-g_key_file_set_string\t@175\tNONAME\n-g_key_file_set_value\t@176\tNONAME\n-g_key_file_to_data\t@177\tNONAME\n-g_list_alloc\t@178\tNONAME\n-g_list_append\t@179\tNONAME\n-g_list_concat\t@180\tNONAME\n-g_list_copy\t@181\tNONAME\n-g_list_copy_deep\t@182\tNONAME\n-g_list_delete_link\t@183\tNONAME\n-g_list_find\t@184\tNONAME\n-g_list_find_custom\t@185\tNONAME\n-g_list_foreach\t@186\tNONAME\n-g_list_free\t@187\tNONAME\n-g_list_free_full\t@188\tNONAME\n-g_list_index\t@189\tNONAME\n-g_list_insert\t@190\tNONAME\n-g_list_insert_before\t@191\tNONAME\n-g_list_insert_sorted\t@192\tNONAME\n-g_list_last\t@193\tNONAME\n-g_list_length\t@194\tNONAME\n-g_list_nth_data\t@195\tNONAME\n-g_list_position\t@196\tNONAME\n-g_list_prepend\t@197\tNONAME\n-g_list_remove\t@198\tNONAME\n-g_list_remove_link\t@199\tNONAME\n-g_list_reverse\t@200\tNONAME\n-g_list_sort\t@201\tNONAME\n-g_locale_to_utf8\t@202\tNONAME\n-g_log\t@203\tNONAME\n-g_log_default_handler\t@204\tNONAME\n-g_log_set_default_handler\t@205\tNONAME\n-g_log_set_handler\t@206\tNONAME\n-g_main_context_get_thread_default\t@207\tNONAME\n-g_main_context_new\t@208\tNONAME\n-g_main_context_unref\t@209\tNONAME\n-g_main_loop_is_running\t@210\tNONAME\n-g_main_loop_new\t@211\tNONAME\n-g_main_loop_quit\t@212\tNONAME\n-g_main_loop_run\t@213\tNONAME\n-g_main_loop_unref\t@214\tNONAME\n-g_malloc\t@215\tNONAME\n-g_malloc0\t@216\tNONAME\n-g_malloc0_n\t@217\tNONAME\n-g_malloc_n\t@218\tNONAME\n-g_mapped_file_ref\t@219\tNONAME\n-g_mapped_file_unref\t@220\tNONAME\n-g_markup_parse_context_ref\t@221\tNONAME\n-g_markup_parse_context_unref\t@222\tNONAME\n-g_memdup\t@223\tNONAME\n-g_memdup2\t@224\tNONAME\n-g_mkdir_with_parents\t@225\tNONAME\n-g_module_close\t@226\tNONAME\n-g_module_error\t@227\tNONAME\n-g_module_make_resident\t@228\tNONAME\n-g_module_open\t@229\tNONAME\n-g_module_supported\t@230\tNONAME\n-g_module_symbol\t@231\tNONAME\n-g_mutex_clear\t@232\tNONAME\n-g_mutex_init\t@233\tNONAME\n-g_mutex_lock\t@234\tNONAME\n-g_mutex_unlock\t@235\tNONAME\n-g_node_children_foreach\t@236\tNONAME\n-g_node_destroy\t@237\tNONAME\n-g_node_insert_before\t@238\tNONAME\n-g_node_new\t@239\tNONAME\n-g_node_nth_child\t@240\tNONAME\n-g_object_add_weak_pointer\t@241\tNONAME\n-g_object_class_find_property\t@242\tNONAME\n-g_object_class_install_properties\t@243\tNONAME\n-g_object_class_install_property\t@244\tNONAME\n-g_object_class_list_properties\t@245\tNONAME\n-g_object_force_floating\t@246\tNONAME\n-g_object_freeze_notify\t@247\tNONAME\n-g_object_get\t@248\tNONAME\n-g_object_get_property\t@249\tNONAME\n-g_object_interface_install_property\t@250\tNONAME\n-g_object_is_floating\t@251\tNONAME\n-g_object_new\t@252\tNONAME\n-g_object_new_with_properties\t@253\tNONAME\n-g_object_notify\t@254\tNONAME\n-g_object_notify_by_pspec\t@255\tNONAME\n-g_object_ref\t@256\tNONAME\n-g_object_ref_sink\t@257\tNONAME\n-g_object_remove_weak_pointer\t@258\tNONAME\n-g_object_set\t@259\tNONAME\n-g_object_set_property\t@260\tNONAME\n-g_object_thaw_notify\t@261\tNONAME\n-g_object_unref\t@262\tNONAME\n-g_once_impl\t@263\tNONAME\n-g_once_init_enter\t@264\tNONAME\n-g_once_init_enter_pointer\t@265\tNONAME\n-g_once_init_leave\t@266\tNONAME\n-g_once_init_leave_pointer\t@267\tNONAME\n-g_option_group_ref\t@268\tNONAME\n-g_option_group_unref\t@269\tNONAME\n-g_param_spec_boolean\t@270\tNONAME\n-g_param_spec_boxed\t@271\tNONAME\n-g_param_spec_double\t@272\tNONAME\n-g_param_spec_enum\t@273\tNONAME\n-g_param_spec_flags\t@274\tNONAME\n-g_param_spec_float\t@275\tNONAME\n-g_param_spec_gtype\t@276\tNONAME\n-g_param_spec_int\t@277\tNONAME\n-g_param_spec_int64\t@278\tNONAME\n-g_param_spec_internal\t@279\tNONAME\n-g_param_spec_object\t@280\tNONAME\n-g_param_spec_ref\t@281\tNONAME\n-g_param_spec_sink\t@282\tNONAME\n-g_param_spec_string\t@283\tNONAME\n-g_param_spec_uint\t@284\tNONAME\n-g_param_spec_uint64\t@285\tNONAME\n-g_param_spec_unref\t@286\tNONAME\n-g_param_type_register_static\t@287\tNONAME\n-g_param_value_set_default\t@288\tNONAME\n-g_param_value_validate\t@289\tNONAME\n-g_param_values_cmp\t@290\tNONAME\n-g_path_get_basename\t@291\tNONAME\n-g_path_get_dirname\t@292\tNONAME\n-g_path_is_absolute\t@293\tNONAME\n-g_pointer_type_register_static\t@294\tNONAME\n-g_print\t@295\tNONAME\n-g_printerr\t@296\tNONAME\n-g_private_get\t@297\tNONAME\n-g_private_set\t@298\tNONAME\n-g_propagate_error\t@299\tNONAME\n-g_ptr_array_add\t@300\tNONAME\n-g_ptr_array_find_with_equal_func\t@301\tNONAME\n-g_ptr_array_foreach\t@302\tNONAME\n-g_ptr_array_free\t@303\tNONAME\n-g_ptr_array_new_full\t@304\tNONAME\n-g_ptr_array_new_with_free_func\t@305\tNONAME\n-g_ptr_array_remove_fast\t@306\tNONAME\n-g_ptr_array_remove_index\t@307\tNONAME\n-g_ptr_array_set_size\t@308\tNONAME\n-g_ptr_array_sized_new\t@309\tNONAME\n-g_ptr_array_sort\t@310\tNONAME\n-g_qsort_with_data\t@311\tNONAME\n-g_quark_from_static_string\t@312\tNONAME\n-g_quark_from_string\t@313\tNONAME\n-g_quark_to_string\t@314\tNONAME\n-g_quark_try_string\t@315\tNONAME\n-g_queue_clear\t@316\tNONAME\n-g_queue_clear_full\t@317\tNONAME\n-g_queue_delete_link\t@318\tNONAME\n-g_queue_find\t@319\tNONAME\n-g_queue_find_custom\t@320\tNONAME\n-g_queue_foreach\t@321\tNONAME\n-g_queue_free\t@322\tNONAME\n-g_queue_get_length\t@323\tNONAME\n-g_queue_init\t@324\tNONAME\n-g_queue_is_empty\t@325\tNONAME\n-g_queue_new\t@326\tNONAME\n-g_queue_peek_head\t@327\tNONAME\n-g_queue_peek_nth\t@328\tNONAME\n-g_queue_pop_head\t@329\tNONAME\n-g_queue_push_head\t@330\tNONAME\n-g_queue_push_tail\t@331\tNONAME\n-g_queue_remove\t@332\tNONAME\n-g_queue_sort\t@333\tNONAME\n-g_random_int\t@334\tNONAME\n-g_realloc\t@335\tNONAME\n-g_realloc_n\t@336\tNONAME\n-g_rec_mutex_clear\t@337\tNONAME\n-g_rec_mutex_init\t@338\tNONAME\n-g_rec_mutex_lock\t@339\tNONAME\n-g_rec_mutex_unlock\t@340\tNONAME\n-g_rename\t@341\tNONAME\n-g_rw_lock_init\t@342\tNONAME\n-g_rw_lock_reader_lock\t@343\tNONAME\n-g_rw_lock_reader_unlock\t@344\tNONAME\n-g_rw_lock_writer_lock\t@345\tNONAME\n-g_rw_lock_writer_unlock\t@346\tNONAME\n-g_set_error\t@347\tNONAME\n-g_set_error_literal\t@348\tNONAME\n-g_signal_connect_data\t@349\tNONAME\n-g_signal_emit\t@350\tNONAME\n-g_signal_handler_disconnect\t@351\tNONAME\n-g_signal_handlers_destroy\t@352\tNONAME\n-g_signal_handlers_disconnect_matched\t@353\tNONAME\n-g_signal_new\t@354\tNONAME\n-g_signal_new_class_handler\t@355\tNONAME\n-g_slice_alloc\t@356\tNONAME\n-g_slice_alloc0\t@357\tNONAME\n-g_slice_copy\t@358\tNONAME\n-g_slice_free1\t@359\tNONAME\n-g_slist_append\t@360\tNONAME\n-g_slist_concat\t@361\tNONAME\n-g_slist_delete_link\t@362\tNONAME\n-g_slist_foreach\t@363\tNONAME\n-g_slist_free\t@364\tNONAME\n-g_slist_insert_before\t@365\tNONAME\n-g_slist_prepend\t@366\tNONAME\n-g_slist_remove\t@367\tNONAME\n-g_slist_reverse\t@368\tNONAME\n-g_snprintf\t@369\tNONAME\n-g_source_add_poll\t@370\tNONAME\n-g_source_attach\t@371\tNONAME\n-g_source_destroy\t@372\tNONAME\n-g_source_new\t@373\tNONAME\n-g_source_ref\t@374\tNONAME\n-g_source_remove\t@375\tNONAME\n-g_source_set_callback\t@376\tNONAME\n-g_source_set_dispose_function\t@377\tNONAME\n-g_source_set_name\t@378\tNONAME\n-g_source_set_priority\t@379\tNONAME\n-g_source_unref\t@380\tNONAME\n-g_spawn_close_pid\t@381\tNONAME\n-g_stat\t@382\tNONAME\n-g_str_equal\t@383\tNONAME\n-g_str_has_prefix\t@384\tNONAME\n-g_str_has_suffix\t@385\tNONAME\n-g_str_hash\t@386\tNONAME\n-g_strchomp\t@387\tNONAME\n-g_strchug\t@388\tNONAME\n-g_strcmp0\t@389\tNONAME\n-g_strconcat\t@390\tNONAME\n-g_strdelimit\t@391\tNONAME\n-g_strdup\t@392\tNONAME\n-g_strdup_printf\t@393\tNONAME\n-g_strdup_value_contents\t@394\tNONAME\n-g_strdup_vprintf\t@395\tNONAME\n-g_strdupv\t@396\tNONAME\n-g_strerror\t@397\tNONAME\n-g_strfreev\t@398\tNONAME\n-g_string_append\t@399\tNONAME\n-g_string_append_len\t@400\tNONAME\n-g_string_append_printf\t@401\tNONAME\n-g_string_free\t@402\tNONAME\n-g_string_insert_c\t@403\tNONAME\n-g_string_insert_len\t@404\tNONAME\n-g_string_new\t@405\tNONAME\n-g_string_set_size\t@406\tNONAME\n-g_string_sized_new\t@407\tNONAME\n-g_string_truncate\t@408\tNONAME\n-g_strjoin\t@409\tNONAME\n-g_strlcat\t@410\tNONAME\n-g_strlcpy\t@411\tNONAME\n-g_strndup\t@412\tNONAME\n-g_strrstr\t@413\tNONAME\n-g_strsplit\t@414\tNONAME\n-g_strsplit_set\t@415\tNONAME\n-g_strstr_len\t@416\tNONAME\n-g_strtod\t@417\tNONAME\n-g_strv_get_type\t@418\tNONAME\n-g_strv_length\t@419\tNONAME\n-g_thread_get_type\t@420\tNONAME\n-g_thread_join\t@421\tNONAME\n-g_thread_new\t@422\tNONAME\n-g_thread_pool_free\t@423\tNONAME\n-g_thread_pool_new\t@424\tNONAME\n-g_thread_pool_push\t@425\tNONAME\n-g_thread_pool_set_max_threads\t@426\tNONAME\n-g_thread_pool_set_max_unused_threads\t@427\tNONAME\n-g_thread_self\t@428\tNONAME\n-g_thread_try_new\t@429\tNONAME\n-g_thread_yield\t@430\tNONAME\n-g_time_zone_new\t@431\tNONAME\n-g_time_zone_new_identifier\t@432\tNONAME\n-g_time_zone_unref\t@433\tNONAME\n-g_timeout_add_full\t@434\tNONAME\n-g_timer_destroy\t@435\tNONAME\n-g_timer_elapsed\t@436\tNONAME\n-g_timer_new\t@437\tNONAME\n-g_timer_start\t@438\tNONAME\n-g_tree_destroy\t@439\tNONAME\n-g_tree_insert\t@440\tNONAME\n-g_tree_new_with_data\t@441\tNONAME\n-g_tree_search\t@442\tNONAME\n-g_try_malloc\t@443\tNONAME\n-g_try_malloc0_n\t@444\tNONAME\n-g_try_malloc_n\t@445\tNONAME\n-g_try_realloc\t@446\tNONAME\n-g_try_realloc_n\t@447\tNONAME\n-g_type_add_class_private\t@448\tNONAME\n-g_type_add_instance_private\t@449\tNONAME\n-g_type_add_interface_static\t@450\tNONAME\n-g_type_check_class_cast\t@451\tNONAME\n-g_type_check_instance_cast\t@452\tNONAME\n-g_type_check_instance_is_a\t@453\tNONAME\n-g_type_check_instance_is_fundamentally_a\t@454\tNONAME\n-g_type_check_value\t@455\tNONAME\n-g_type_check_value_holds\t@456\tNONAME\n-g_type_class_add_private\t@457\tNONAME\n-g_type_class_adjust_private_offset\t@458\tNONAME\n-g_type_class_get_private\t@459\tNONAME\n-g_type_class_peek\t@460\tNONAME\n-g_type_class_peek_parent\t@461\tNONAME\n-g_type_class_ref\t@462\tNONAME\n-g_type_class_unref\t@463\tNONAME\n-g_type_from_name\t@464\tNONAME\n-g_type_fundamental\t@465\tNONAME\n-g_type_fundamental_next\t@466\tNONAME\n-g_type_get_qdata\t@467\tNONAME\n-g_type_init\t@468\tNONAME\n-g_type_instance_get_private\t@469\tNONAME\n-g_type_interface_add_prerequisite\t@470\tNONAME\n-g_type_interface_peek\t@471\tNONAME\n-g_type_interfaces\t@472\tNONAME\n-g_type_is_a\t@473\tNONAME\n-g_type_name\t@474\tNONAME\n-g_type_parent\t@475\tNONAME\n-g_type_qname\t@476\tNONAME\n-g_type_register_fundamental\t@477\tNONAME\n-g_type_register_static\t@478\tNONAME\n-g_type_register_static_simple\t@479\tNONAME\n-g_type_set_qdata\t@480\tNONAME\n-g_type_value_table_peek\t@481\tNONAME\n-g_unlink\t@482\tNONAME\n-g_uri_escape_string\t@483\tNONAME\n-g_uri_unescape_segment\t@484\tNONAME\n-g_uri_unescape_string\t@485\tNONAME\n-g_utf16_to_utf8\t@486\tNONAME\n-g_utf8_strchr\t@487\tNONAME\n-g_utf8_to_utf16\t@488\tNONAME\n-g_utf8_validate\t@489\tNONAME\n-g_value_array_append\t@490\tNONAME\n-g_value_array_get_nth\t@491\tNONAME\n-g_value_array_get_type\t@492\tNONAME\n-g_value_array_new\t@493\tNONAME\n-g_value_copy\t@494\tNONAME\n-g_value_dup_boxed\t@495\tNONAME\n-g_value_dup_object\t@496\tNONAME\n-g_value_dup_string\t@497\tNONAME\n-g_value_get_boolean\t@498\tNONAME\n-g_value_get_boxed\t@499\tNONAME\n-g_value_get_double\t@500\tNONAME\n-g_value_get_enum\t@501\tNONAME\n-g_value_get_flags\t@502\tNONAME\n-g_value_get_float\t@503\tNONAME\n-g_value_get_gtype\t@504\tNONAME\n-g_value_get_int\t@505\tNONAME\n-g_value_get_int64\t@506\tNONAME\n-g_value_get_long\t@507\tNONAME\n-g_value_get_object\t@508\tNONAME\n-g_value_get_pointer\t@509\tNONAME\n-g_value_get_string\t@510\tNONAME\n-g_value_get_uchar\t@511\tNONAME\n-g_value_get_uint\t@512\tNONAME\n-g_value_get_uint64\t@513\tNONAME\n-g_value_get_ulong\t@514\tNONAME\n-g_value_init\t@515\tNONAME\n-g_value_peek_pointer\t@516\tNONAME\n-g_value_register_transform_func\t@517\tNONAME\n-g_value_reset\t@518\tNONAME\n-g_value_set_boolean\t@519\tNONAME\n-g_value_set_boxed\t@520\tNONAME\n-g_value_set_double\t@521\tNONAME\n-g_value_set_enum\t@522\tNONAME\n-g_value_set_flags\t@523\tNONAME\n-g_value_set_float\t@524\tNONAME\n-g_value_set_gtype\t@525\tNONAME\n-g_value_set_int\t@526\tNONAME\n-g_value_set_int64\t@527\tNONAME\n-g_value_set_long\t@528\tNONAME\n-g_value_set_object\t@529\tNONAME\n-g_value_set_pointer\t@530\tNONAME\n-g_value_set_static_boxed\t@531\tNONAME\n-g_value_set_static_string\t@532\tNONAME\n-g_value_set_string\t@533\tNONAME\n-g_value_set_uchar\t@534\tNONAME\n-g_value_set_uint\t@535\tNONAME\n-g_value_set_uint64\t@536\tNONAME\n-g_value_set_ulong\t@537\tNONAME\n-g_value_take_boxed\t@538\tNONAME\n-g_value_take_object\t@539\tNONAME\n-g_value_take_string\t@540\tNONAME\n-g_value_transform\t@541\tNONAME\n-g_value_type_compatible\t@542\tNONAME\n-g_value_unset\t@543\tNONAME\n-g_vasprintf\t@544\tNONAME\n-g_warn_message\t@545\tNONAME\n-g_weak_ref_clear\t@546\tNONAME\n-g_weak_ref_get\t@547\tNONAME\n-g_weak_ref_init\t@548\tNONAME\n-g_weak_ref_set\t@549\tNONAME\n-g_win32_error_message\t@550\tNONAME\n-g_win32_get_package_installation_directory_of_module\t@551\tNONAME\n+g_ascii_string_to_unsigned\t@17\tNONAME\n+g_ascii_strncasecmp\t@18\tNONAME\n+g_ascii_strtod\t@19\tNONAME\n+g_ascii_strtoll\t@20\tNONAME\n+g_ascii_strtoull\t@21\tNONAME\n+g_ascii_strup\t@22\tNONAME\n+g_ascii_table\t@23\tNONAME\n+g_ascii_tolower\t@24\tNONAME\n+g_ascii_toupper\t@25\tNONAME\n+g_assertion_message_cmpint\t@26\tNONAME\n+g_assertion_message_cmpnum\t@27\tNONAME\n+g_atomic_int_add\t@28\tNONAME\n+g_atomic_int_compare_and_exchange\t@29\tNONAME\n+g_atomic_int_dec_and_test\t@30\tNONAME\n+g_atomic_int_get\t@31\tNONAME\n+g_atomic_int_inc\t@32\tNONAME\n+g_atomic_int_set\t@33\tNONAME\n+g_atomic_pointer_compare_and_exchange\t@34\tNONAME\n+g_atomic_pointer_get\t@35\tNONAME\n+g_atomic_pointer_set\t@36\tNONAME\n+g_atomic_rc_box_acquire\t@37\tNONAME\n+g_atomic_rc_box_alloc\t@38\tNONAME\n+g_atomic_rc_box_release_full\t@39\tNONAME\n+g_base64_decode\t@40\tNONAME\n+g_base64_decode_inplace\t@41\tNONAME\n+g_base64_encode\t@42\tNONAME\n+g_boxed_type_register_static\t@43\tNONAME\n+g_build_filename\t@44\tNONAME\n+g_build_filenamev\t@45\tNONAME\n+g_byte_array_set_size\t@46\tNONAME\n+g_bytes_compare\t@47\tNONAME\n+g_bytes_get_data\t@48\tNONAME\n+g_bytes_get_type\t@49\tNONAME\n+g_bytes_new\t@50\tNONAME\n+g_bytes_new_take\t@51\tNONAME\n+g_bytes_ref\t@52\tNONAME\n+g_bytes_unref\t@53\tNONAME\n+g_cclosure_marshal_VOID__VOID\t@54\tNONAME\n+g_cclosure_marshal_generic\t@55\tNONAME\n+g_checksum_free\t@56\tNONAME\n+g_checksum_get_string\t@57\tNONAME\n+g_checksum_new\t@58\tNONAME\n+g_checksum_update\t@59\tNONAME\n+g_clear_error\t@60\tNONAME\n+g_cond_broadcast\t@61\tNONAME\n+g_cond_clear\t@62\tNONAME\n+g_cond_init\t@63\tNONAME\n+g_cond_signal\t@64\tNONAME\n+g_cond_wait\t@65\tNONAME\n+g_cond_wait_until\t@66\tNONAME\n+g_convert\t@67\tNONAME\n+g_datalist_id_get_data\t@68\tNONAME\n+g_datalist_id_set_data_full\t@69\tNONAME\n+g_datalist_init\t@70\tNONAME\n+g_date_free\t@71\tNONAME\n+g_date_get_day\t@72\tNONAME\n+g_date_get_julian\t@73\tNONAME\n+g_date_get_month\t@74\tNONAME\n+g_date_get_type\t@75\tNONAME\n+g_date_get_year\t@76\tNONAME\n+g_date_new_dmy\t@77\tNONAME\n+g_date_time_add\t@78\tNONAME\n+g_date_time_add_hours\t@79\tNONAME\n+g_date_time_add_minutes\t@80\tNONAME\n+g_date_time_add_seconds\t@81\tNONAME\n+g_date_time_compare\t@82\tNONAME\n+g_date_time_get_day_of_month\t@83\tNONAME\n+g_date_time_get_hour\t@84\tNONAME\n+g_date_time_get_microsecond\t@85\tNONAME\n+g_date_time_get_minute\t@86\tNONAME\n+g_date_time_get_month\t@87\tNONAME\n+g_date_time_get_second\t@88\tNONAME\n+g_date_time_get_type\t@89\tNONAME\n+g_date_time_get_utc_offset\t@90\tNONAME\n+g_date_time_get_year\t@91\tNONAME\n+g_date_time_get_ymd\t@92\tNONAME\n+g_date_time_new\t@93\tNONAME\n+g_date_time_new_from_unix_local\t@94\tNONAME\n+g_date_time_new_from_unix_utc\t@95\tNONAME\n+g_date_time_new_local\t@96\tNONAME\n+g_date_time_new_now_local\t@97\tNONAME\n+g_date_time_new_now_utc\t@98\tNONAME\n+g_date_time_new_utc\t@99\tNONAME\n+g_date_time_ref\t@100\tNONAME\n+g_date_time_to_local\t@101\tNONAME\n+g_date_time_to_unix\t@102\tNONAME\n+g_date_time_unref\t@103\tNONAME\n+g_date_valid\t@104\tNONAME\n+g_date_valid_dmy\t@105\tNONAME\n+g_dgettext\t@106\tNONAME\n+g_dir_close\t@107\tNONAME\n+g_dir_open\t@108\tNONAME\n+g_dir_read_name\t@109\tNONAME\n+g_enum_get_value\t@110\tNONAME\n+g_enum_get_value_by_name\t@111\tNONAME\n+g_enum_get_value_by_nick\t@112\tNONAME\n+g_enum_register_static\t@113\tNONAME\n+g_error_free\t@114\tNONAME\n+g_error_get_type\t@115\tNONAME\n+g_error_new\t@116\tNONAME\n+g_error_new_literal\t@117\tNONAME\n+g_file_set_contents\t@118\tNONAME\n+g_file_test\t@119\tNONAME\n+g_filename_to_uri\t@120\tNONAME\n+g_flags_get_first_value\t@121\tNONAME\n+g_flags_get_value_by_name\t@122\tNONAME\n+g_flags_get_value_by_nick\t@123\tNONAME\n+g_flags_register_static\t@124\tNONAME\n+g_free\t@125\tNONAME\n+g_get_charset\t@126\tNONAME\n+g_get_current_dir\t@127\tNONAME\n+g_get_current_time\t@128\tNONAME\n+g_get_monotonic_time\t@129\tNONAME\n+g_get_prgname\t@130\tNONAME\n+g_get_real_time\t@131\tNONAME\n+g_get_user_cache_dir\t@132\tNONAME\n+g_get_user_data_dir\t@133\tNONAME\n+g_getenv\t@134\tNONAME\n+g_gtype_get_type\t@135\tNONAME\n+g_hash_table_contains\t@136\tNONAME\n+g_hash_table_destroy\t@137\tNONAME\n+g_hash_table_foreach\t@138\tNONAME\n+g_hash_table_foreach_remove\t@139\tNONAME\n+g_hash_table_get_keys\t@140\tNONAME\n+g_hash_table_get_values\t@141\tNONAME\n+g_hash_table_insert\t@142\tNONAME\n+g_hash_table_iter_init\t@143\tNONAME\n+g_hash_table_iter_next\t@144\tNONAME\n+g_hash_table_lookup\t@145\tNONAME\n+g_hash_table_new\t@146\tNONAME\n+g_hash_table_new_full\t@147\tNONAME\n+g_hash_table_ref\t@148\tNONAME\n+g_hash_table_remove\t@149\tNONAME\n+g_hash_table_replace\t@150\tNONAME\n+g_hash_table_size\t@151\tNONAME\n+g_hash_table_unref\t@152\tNONAME\n+g_hook_alloc\t@153\tNONAME\n+g_hook_destroy_link\t@154\tNONAME\n+g_hook_get\t@155\tNONAME\n+g_hook_insert_before\t@156\tNONAME\n+g_hook_list_clear\t@157\tNONAME\n+g_hook_list_init\t@158\tNONAME\n+g_hook_list_marshal\t@159\tNONAME\n+g_hook_ref\t@160\tNONAME\n+g_hook_unref\t@161\tNONAME\n+g_initially_unowned_get_type\t@162\tNONAME\n+g_int_equal\t@163\tNONAME\n+g_int_hash\t@164\tNONAME\n+g_intern_static_string\t@165\tNONAME\n+g_intern_string\t@166\tNONAME\n+g_key_file_free\t@167\tNONAME\n+g_key_file_get_comment\t@168\tNONAME\n+g_key_file_get_groups\t@169\tNONAME\n+g_key_file_get_keys\t@170\tNONAME\n+g_key_file_get_value\t@171\tNONAME\n+g_key_file_has_group\t@172\tNONAME\n+g_key_file_load_from_file\t@173\tNONAME\n+g_key_file_new\t@174\tNONAME\n+g_key_file_remove_group\t@175\tNONAME\n+g_key_file_remove_key\t@176\tNONAME\n+g_key_file_set_comment\t@177\tNONAME\n+g_key_file_set_string\t@178\tNONAME\n+g_key_file_set_value\t@179\tNONAME\n+g_key_file_to_data\t@180\tNONAME\n+g_list_alloc\t@181\tNONAME\n+g_list_append\t@182\tNONAME\n+g_list_concat\t@183\tNONAME\n+g_list_copy\t@184\tNONAME\n+g_list_copy_deep\t@185\tNONAME\n+g_list_delete_link\t@186\tNONAME\n+g_list_find\t@187\tNONAME\n+g_list_find_custom\t@188\tNONAME\n+g_list_foreach\t@189\tNONAME\n+g_list_free\t@190\tNONAME\n+g_list_free_full\t@191\tNONAME\n+g_list_index\t@192\tNONAME\n+g_list_insert\t@193\tNONAME\n+g_list_insert_before\t@194\tNONAME\n+g_list_insert_sorted\t@195\tNONAME\n+g_list_last\t@196\tNONAME\n+g_list_length\t@197\tNONAME\n+g_list_nth_data\t@198\tNONAME\n+g_list_position\t@199\tNONAME\n+g_list_prepend\t@200\tNONAME\n+g_list_remove\t@201\tNONAME\n+g_list_remove_link\t@202\tNONAME\n+g_list_reverse\t@203\tNONAME\n+g_list_sort\t@204\tNONAME\n+g_locale_to_utf8\t@205\tNONAME\n+g_log\t@206\tNONAME\n+g_log_default_handler\t@207\tNONAME\n+g_log_set_default_handler\t@208\tNONAME\n+g_log_set_handler\t@209\tNONAME\n+g_main_context_get_thread_default\t@210\tNONAME\n+g_main_context_new\t@211\tNONAME\n+g_main_context_unref\t@212\tNONAME\n+g_main_loop_is_running\t@213\tNONAME\n+g_main_loop_new\t@214\tNONAME\n+g_main_loop_quit\t@215\tNONAME\n+g_main_loop_run\t@216\tNONAME\n+g_main_loop_unref\t@217\tNONAME\n+g_malloc\t@218\tNONAME\n+g_malloc0\t@219\tNONAME\n+g_malloc0_n\t@220\tNONAME\n+g_malloc_n\t@221\tNONAME\n+g_mapped_file_ref\t@222\tNONAME\n+g_mapped_file_unref\t@223\tNONAME\n+g_markup_parse_context_ref\t@224\tNONAME\n+g_markup_parse_context_unref\t@225\tNONAME\n+g_memdup\t@226\tNONAME\n+g_memdup2\t@227\tNONAME\n+g_mkdir_with_parents\t@228\tNONAME\n+g_module_close\t@229\tNONAME\n+g_module_error\t@230\tNONAME\n+g_module_make_resident\t@231\tNONAME\n+g_module_open\t@232\tNONAME\n+g_module_supported\t@233\tNONAME\n+g_module_symbol\t@234\tNONAME\n+g_mutex_clear\t@235\tNONAME\n+g_mutex_init\t@236\tNONAME\n+g_mutex_lock\t@237\tNONAME\n+g_mutex_unlock\t@238\tNONAME\n+g_node_children_foreach\t@239\tNONAME\n+g_node_destroy\t@240\tNONAME\n+g_node_insert_before\t@241\tNONAME\n+g_node_new\t@242\tNONAME\n+g_node_nth_child\t@243\tNONAME\n+g_object_add_weak_pointer\t@244\tNONAME\n+g_object_class_find_property\t@245\tNONAME\n+g_object_class_install_properties\t@246\tNONAME\n+g_object_class_install_property\t@247\tNONAME\n+g_object_class_list_properties\t@248\tNONAME\n+g_object_force_floating\t@249\tNONAME\n+g_object_freeze_notify\t@250\tNONAME\n+g_object_get\t@251\tNONAME\n+g_object_get_property\t@252\tNONAME\n+g_object_interface_install_property\t@253\tNONAME\n+g_object_is_floating\t@254\tNONAME\n+g_object_new\t@255\tNONAME\n+g_object_new_with_properties\t@256\tNONAME\n+g_object_notify\t@257\tNONAME\n+g_object_notify_by_pspec\t@258\tNONAME\n+g_object_ref\t@259\tNONAME\n+g_object_ref_sink\t@260\tNONAME\n+g_object_remove_weak_pointer\t@261\tNONAME\n+g_object_set\t@262\tNONAME\n+g_object_set_property\t@263\tNONAME\n+g_object_thaw_notify\t@264\tNONAME\n+g_object_unref\t@265\tNONAME\n+g_once_impl\t@266\tNONAME\n+g_once_init_enter\t@267\tNONAME\n+g_once_init_enter_pointer\t@268\tNONAME\n+g_once_init_leave\t@269\tNONAME\n+g_once_init_leave_pointer\t@270\tNONAME\n+g_option_group_ref\t@271\tNONAME\n+g_option_group_unref\t@272\tNONAME\n+g_param_spec_boolean\t@273\tNONAME\n+g_param_spec_boxed\t@274\tNONAME\n+g_param_spec_double\t@275\tNONAME\n+g_param_spec_enum\t@276\tNONAME\n+g_param_spec_flags\t@277\tNONAME\n+g_param_spec_float\t@278\tNONAME\n+g_param_spec_get_blurb\t@279\tNONAME\n+g_param_spec_get_name\t@280\tNONAME\n+g_param_spec_gtype\t@281\tNONAME\n+g_param_spec_int\t@282\tNONAME\n+g_param_spec_int64\t@283\tNONAME\n+g_param_spec_internal\t@284\tNONAME\n+g_param_spec_object\t@285\tNONAME\n+g_param_spec_ref\t@286\tNONAME\n+g_param_spec_sink\t@287\tNONAME\n+g_param_spec_string\t@288\tNONAME\n+g_param_spec_uint\t@289\tNONAME\n+g_param_spec_uint64\t@290\tNONAME\n+g_param_spec_unref\t@291\tNONAME\n+g_param_type_register_static\t@292\tNONAME\n+g_param_value_set_default\t@293\tNONAME\n+g_param_value_validate\t@294\tNONAME\n+g_param_values_cmp\t@295\tNONAME\n+g_path_get_basename\t@296\tNONAME\n+g_path_get_dirname\t@297\tNONAME\n+g_path_is_absolute\t@298\tNONAME\n+g_pointer_type_register_static\t@299\tNONAME\n+g_print\t@300\tNONAME\n+g_printerr\t@301\tNONAME\n+g_private_get\t@302\tNONAME\n+g_private_set\t@303\tNONAME\n+g_propagate_error\t@304\tNONAME\n+g_ptr_array_add\t@305\tNONAME\n+g_ptr_array_find_with_equal_func\t@306\tNONAME\n+g_ptr_array_foreach\t@307\tNONAME\n+g_ptr_array_free\t@308\tNONAME\n+g_ptr_array_new_full\t@309\tNONAME\n+g_ptr_array_new_with_free_func\t@310\tNONAME\n+g_ptr_array_remove_fast\t@311\tNONAME\n+g_ptr_array_remove_index\t@312\tNONAME\n+g_ptr_array_set_size\t@313\tNONAME\n+g_ptr_array_sized_new\t@314\tNONAME\n+g_ptr_array_sort\t@315\tNONAME\n+g_qsort_with_data\t@316\tNONAME\n+g_quark_from_static_string\t@317\tNONAME\n+g_quark_from_string\t@318\tNONAME\n+g_quark_to_string\t@319\tNONAME\n+g_quark_try_string\t@320\tNONAME\n+g_queue_clear\t@321\tNONAME\n+g_queue_clear_full\t@322\tNONAME\n+g_queue_delete_link\t@323\tNONAME\n+g_queue_find\t@324\tNONAME\n+g_queue_find_custom\t@325\tNONAME\n+g_queue_foreach\t@326\tNONAME\n+g_queue_free\t@327\tNONAME\n+g_queue_get_length\t@328\tNONAME\n+g_queue_init\t@329\tNONAME\n+g_queue_is_empty\t@330\tNONAME\n+g_queue_new\t@331\tNONAME\n+g_queue_peek_head\t@332\tNONAME\n+g_queue_peek_nth\t@333\tNONAME\n+g_queue_pop_head\t@334\tNONAME\n+g_queue_push_head\t@335\tNONAME\n+g_queue_push_tail\t@336\tNONAME\n+g_queue_remove\t@337\tNONAME\n+g_queue_sort\t@338\tNONAME\n+g_random_int\t@339\tNONAME\n+g_realloc\t@340\tNONAME\n+g_realloc_n\t@341\tNONAME\n+g_rec_mutex_clear\t@342\tNONAME\n+g_rec_mutex_init\t@343\tNONAME\n+g_rec_mutex_lock\t@344\tNONAME\n+g_rec_mutex_unlock\t@345\tNONAME\n+g_rename\t@346\tNONAME\n+g_rw_lock_init\t@347\tNONAME\n+g_rw_lock_reader_lock\t@348\tNONAME\n+g_rw_lock_reader_unlock\t@349\tNONAME\n+g_rw_lock_writer_lock\t@350\tNONAME\n+g_rw_lock_writer_unlock\t@351\tNONAME\n+g_set_error\t@352\tNONAME\n+g_set_error_literal\t@353\tNONAME\n+g_signal_connect_data\t@354\tNONAME\n+g_signal_emit\t@355\tNONAME\n+g_signal_handler_disconnect\t@356\tNONAME\n+g_signal_handlers_destroy\t@357\tNONAME\n+g_signal_handlers_disconnect_matched\t@358\tNONAME\n+g_signal_new\t@359\tNONAME\n+g_signal_new_class_handler\t@360\tNONAME\n+g_slice_alloc\t@361\tNONAME\n+g_slice_alloc0\t@362\tNONAME\n+g_slice_copy\t@363\tNONAME\n+g_slice_free1\t@364\tNONAME\n+g_slist_append\t@365\tNONAME\n+g_slist_concat\t@366\tNONAME\n+g_slist_delete_link\t@367\tNONAME\n+g_slist_foreach\t@368\tNONAME\n+g_slist_free\t@369\tNONAME\n+g_slist_insert_before\t@370\tNONAME\n+g_slist_prepend\t@371\tNONAME\n+g_slist_remove\t@372\tNONAME\n+g_slist_reverse\t@373\tNONAME\n+g_snprintf\t@374\tNONAME\n+g_sort_array\t@375\tNONAME\n+g_source_add_poll\t@376\tNONAME\n+g_source_attach\t@377\tNONAME\n+g_source_destroy\t@378\tNONAME\n+g_source_new\t@379\tNONAME\n+g_source_ref\t@380\tNONAME\n+g_source_remove\t@381\tNONAME\n+g_source_set_callback\t@382\tNONAME\n+g_source_set_dispose_function\t@383\tNONAME\n+g_source_set_name\t@384\tNONAME\n+g_source_set_priority\t@385\tNONAME\n+g_source_unref\t@386\tNONAME\n+g_spawn_close_pid\t@387\tNONAME\n+g_stat\t@388\tNONAME\n+g_str_equal\t@389\tNONAME\n+g_str_has_prefix\t@390\tNONAME\n+g_str_has_suffix\t@391\tNONAME\n+g_str_hash\t@392\tNONAME\n+g_strchomp\t@393\tNONAME\n+g_strchug\t@394\tNONAME\n+g_strcmp0\t@395\tNONAME\n+g_strconcat\t@396\tNONAME\n+g_strdelimit\t@397\tNONAME\n+g_strdup\t@398\tNONAME\n+g_strdup_printf\t@399\tNONAME\n+g_strdup_value_contents\t@400\tNONAME\n+g_strdup_vprintf\t@401\tNONAME\n+g_strdupv\t@402\tNONAME\n+g_strerror\t@403\tNONAME\n+g_strfreev\t@404\tNONAME\n+g_string_append\t@405\tNONAME\n+g_string_append_len\t@406\tNONAME\n+g_string_append_printf\t@407\tNONAME\n+g_string_free\t@408\tNONAME\n+g_string_insert_c\t@409\tNONAME\n+g_string_insert_len\t@410\tNONAME\n+g_string_new\t@411\tNONAME\n+g_string_set_size\t@412\tNONAME\n+g_string_sized_new\t@413\tNONAME\n+g_string_truncate\t@414\tNONAME\n+g_strjoin\t@415\tNONAME\n+g_strlcat\t@416\tNONAME\n+g_strlcpy\t@417\tNONAME\n+g_strndup\t@418\tNONAME\n+g_strrstr\t@419\tNONAME\n+g_strsplit\t@420\tNONAME\n+g_strsplit_set\t@421\tNONAME\n+g_strstr_len\t@422\tNONAME\n+g_strtod\t@423\tNONAME\n+g_strv_get_type\t@424\tNONAME\n+g_strv_length\t@425\tNONAME\n+g_thread_get_type\t@426\tNONAME\n+g_thread_join\t@427\tNONAME\n+g_thread_new\t@428\tNONAME\n+g_thread_pool_free\t@429\tNONAME\n+g_thread_pool_new\t@430\tNONAME\n+g_thread_pool_push\t@431\tNONAME\n+g_thread_pool_set_max_threads\t@432\tNONAME\n+g_thread_pool_set_max_unused_threads\t@433\tNONAME\n+g_thread_self\t@434\tNONAME\n+g_thread_try_new\t@435\tNONAME\n+g_thread_yield\t@436\tNONAME\n+g_time_zone_new\t@437\tNONAME\n+g_time_zone_new_identifier\t@438\tNONAME\n+g_time_zone_unref\t@439\tNONAME\n+g_timeout_add_full\t@440\tNONAME\n+g_timer_destroy\t@441\tNONAME\n+g_timer_elapsed\t@442\tNONAME\n+g_timer_new\t@443\tNONAME\n+g_timer_start\t@444\tNONAME\n+g_tree_destroy\t@445\tNONAME\n+g_tree_insert\t@446\tNONAME\n+g_tree_new_with_data\t@447\tNONAME\n+g_tree_search\t@448\tNONAME\n+g_try_malloc\t@449\tNONAME\n+g_try_malloc0_n\t@450\tNONAME\n+g_try_malloc_n\t@451\tNONAME\n+g_try_realloc\t@452\tNONAME\n+g_try_realloc_n\t@453\tNONAME\n+g_type_add_class_private\t@454\tNONAME\n+g_type_add_instance_private\t@455\tNONAME\n+g_type_add_interface_static\t@456\tNONAME\n+g_type_check_class_cast\t@457\tNONAME\n+g_type_check_instance_cast\t@458\tNONAME\n+g_type_check_instance_is_a\t@459\tNONAME\n+g_type_check_instance_is_fundamentally_a\t@460\tNONAME\n+g_type_check_value\t@461\tNONAME\n+g_type_check_value_holds\t@462\tNONAME\n+g_type_class_add_private\t@463\tNONAME\n+g_type_class_adjust_private_offset\t@464\tNONAME\n+g_type_class_get_private\t@465\tNONAME\n+g_type_class_peek\t@466\tNONAME\n+g_type_class_peek_parent\t@467\tNONAME\n+g_type_class_ref\t@468\tNONAME\n+g_type_class_unref\t@469\tNONAME\n+g_type_from_name\t@470\tNONAME\n+g_type_fundamental\t@471\tNONAME\n+g_type_fundamental_next\t@472\tNONAME\n+g_type_get_qdata\t@473\tNONAME\n+g_type_init\t@474\tNONAME\n+g_type_instance_get_private\t@475\tNONAME\n+g_type_interface_add_prerequisite\t@476\tNONAME\n+g_type_interface_peek\t@477\tNONAME\n+g_type_interfaces\t@478\tNONAME\n+g_type_is_a\t@479\tNONAME\n+g_type_name\t@480\tNONAME\n+g_type_parent\t@481\tNONAME\n+g_type_qname\t@482\tNONAME\n+g_type_register_fundamental\t@483\tNONAME\n+g_type_register_static\t@484\tNONAME\n+g_type_register_static_simple\t@485\tNONAME\n+g_type_set_qdata\t@486\tNONAME\n+g_type_value_table_peek\t@487\tNONAME\n+g_unlink\t@488\tNONAME\n+g_uri_escape_string\t@489\tNONAME\n+g_uri_unescape_segment\t@490\tNONAME\n+g_uri_unescape_string\t@491\tNONAME\n+g_utf16_to_utf8\t@492\tNONAME\n+g_utf8_strchr\t@493\tNONAME\n+g_utf8_to_utf16\t@494\tNONAME\n+g_utf8_validate\t@495\tNONAME\n+g_value_array_append\t@496\tNONAME\n+g_value_array_get_nth\t@497\tNONAME\n+g_value_array_get_type\t@498\tNONAME\n+g_value_array_new\t@499\tNONAME\n+g_value_copy\t@500\tNONAME\n+g_value_dup_boxed\t@501\tNONAME\n+g_value_dup_object\t@502\tNONAME\n+g_value_dup_string\t@503\tNONAME\n+g_value_get_boolean\t@504\tNONAME\n+g_value_get_boxed\t@505\tNONAME\n+g_value_get_double\t@506\tNONAME\n+g_value_get_enum\t@507\tNONAME\n+g_value_get_flags\t@508\tNONAME\n+g_value_get_float\t@509\tNONAME\n+g_value_get_gtype\t@510\tNONAME\n+g_value_get_int\t@511\tNONAME\n+g_value_get_int64\t@512\tNONAME\n+g_value_get_long\t@513\tNONAME\n+g_value_get_object\t@514\tNONAME\n+g_value_get_pointer\t@515\tNONAME\n+g_value_get_string\t@516\tNONAME\n+g_value_get_uchar\t@517\tNONAME\n+g_value_get_uint\t@518\tNONAME\n+g_value_get_uint64\t@519\tNONAME\n+g_value_get_ulong\t@520\tNONAME\n+g_value_init\t@521\tNONAME\n+g_value_peek_pointer\t@522\tNONAME\n+g_value_register_transform_func\t@523\tNONAME\n+g_value_reset\t@524\tNONAME\n+g_value_set_boolean\t@525\tNONAME\n+g_value_set_boxed\t@526\tNONAME\n+g_value_set_double\t@527\tNONAME\n+g_value_set_enum\t@528\tNONAME\n+g_value_set_flags\t@529\tNONAME\n+g_value_set_float\t@530\tNONAME\n+g_value_set_gtype\t@531\tNONAME\n+g_value_set_int\t@532\tNONAME\n+g_value_set_int64\t@533\tNONAME\n+g_value_set_long\t@534\tNONAME\n+g_value_set_object\t@535\tNONAME\n+g_value_set_pointer\t@536\tNONAME\n+g_value_set_static_boxed\t@537\tNONAME\n+g_value_set_static_string\t@538\tNONAME\n+g_value_set_string\t@539\tNONAME\n+g_value_set_uchar\t@540\tNONAME\n+g_value_set_uint\t@541\tNONAME\n+g_value_set_uint64\t@542\tNONAME\n+g_value_set_ulong\t@543\tNONAME\n+g_value_take_boxed\t@544\tNONAME\n+g_value_take_object\t@545\tNONAME\n+g_value_take_string\t@546\tNONAME\n+g_value_transform\t@547\tNONAME\n+g_value_type_compatible\t@548\tNONAME\n+g_value_unset\t@549\tNONAME\n+g_vasprintf\t@550\tNONAME\n+g_warn_message\t@551\tNONAME\n+g_weak_ref_clear\t@552\tNONAME\n+g_weak_ref_get\t@553\tNONAME\n+g_weak_ref_init\t@554\tNONAME\n+g_weak_ref_set\t@555\tNONAME\n+g_win32_error_message\t@556\tNONAME\n+g_win32_get_package_installation_directory_of_module\t@557\tNONAME\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/build\/win32\/vs100\/glib-lite.def","additions":541,"deletions":535,"binary":false,"changes":1076,"status":"modified"},{"patch":"@@ -1575,2 +1575,3 @@\n-\n-      \/* otherwise fall-through *\/\n+#ifndef GSTREAMER_LITE\n+      G_GNUC_FALLTHROUGH;\n+#endif \/\/ GSTREAMER_LITE\n@@ -1588,1 +1589,1 @@\n-      \/* fall-through *\/\n+      \/* FALLTHROUGH *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-bad\/gst\/aiff\/aiffparse.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-      if (rate_to_test > max_rate) {\n+      if (rate_to_test <= 0 || rate_to_test > max_rate) {\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/ext\/alsa\/gstalsa.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,4 @@\n+#ifdef HAVE_VALGRIND\n+# include <valgrind\/valgrind.h>\n+#endif\n+\n@@ -147,0 +151,6 @@\n+#ifdef HAVE_VALGRIND\n+  if (RUNNING_ON_VALGRIND) {\n+    snd_config_update_free_global ();\n+  }\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/ext\/alsa\/gstalsasink.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  GstQueueArray *queue;\n+  GstVecDeque *queue;\n@@ -618,1 +618,1 @@\n-  priv->queue = gst_queue_array_new (16);\n+  priv->queue = gst_vec_deque_new (16);\n@@ -649,1 +649,1 @@\n-  while ((queue_obj = gst_queue_array_pop_head (priv->queue)))\n+  while ((queue_obj = gst_vec_deque_pop_head (priv->queue)))\n@@ -673,1 +673,1 @@\n-  gst_queue_array_free (priv->queue);\n+  gst_vec_deque_free (priv->queue);\n@@ -810,1 +810,1 @@\n-  while ((obj = gst_queue_array_pop_head (priv->queue))) {\n+  while ((obj = gst_vec_deque_pop_head (priv->queue))) {\n@@ -823,1 +823,1 @@\n-  while ((obj = gst_queue_array_pop_head (priv->queue)))\n+  while ((obj = gst_vec_deque_pop_head (priv->queue)))\n@@ -892,3 +892,0 @@\n-  gst_queue_array_push_tail (priv->queue, gst_event_new_caps (caps));\n-  gst_queue_status_info_push_event (&priv->queue_status_info);\n-\n@@ -1000,1 +997,1 @@\n-    gst_queue_array_push_tail (priv->queue, gst_event_ref (event));\n+    gst_vec_deque_push_tail (priv->queue, gst_event_ref (event));\n@@ -1078,1 +1075,1 @@\n-  obj = gst_queue_array_pop_head (priv->queue);\n+  obj = gst_vec_deque_pop_head (priv->queue);\n@@ -1203,1 +1200,1 @@\n-  gst_queue_array_push_tail (priv->queue, gst_mini_object_ref (data));\n+  gst_vec_deque_push_tail (priv->queue, gst_mini_object_ref (data));\n@@ -1863,1 +1860,1 @@\n- * gst_app_sink_pull_object: (skip)\n+ * gst_app_sink_pull_object:\n@@ -2064,1 +2061,1 @@\n- * gst_app_sink_try_pull_object: (skip)\n+ * gst_app_sink_try_pull_object:\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/app\/gstappsink.c","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -634,0 +634,69 @@\n+typedef enum\n+{\n+  GST_AUDIO_CHANNEL_MIXER_VIRTUAL_INPUT_NONE = 0,\n+  GST_AUDIO_CHANNEL_MIXER_VIRTUAL_INPUT_MONO,\n+  GST_AUDIO_CHANNEL_MIXER_VIRTUAL_INPUT_STEREO\n+} GstAudioChannelMixerVirtualInput;\n+\n+\/* Detects specific input channels configurations introduced in the\n+ * audioconvert element (since version 1.26) with the\n+ * `GstAudioConvertInputChannelsReorder` configurations.\n+ *\n+ * If all input channels are positioned to GST_AUDIO_CHANNEL_POSITION_MONO,\n+ * the automatic mixing matrix should be configured like if there was only one\n+ * virtual input mono channel. This virtual mono channel is the mix of all the\n+ * real mono channels.\n+ *\n+ * If all input channels with an even index are positioned to\n+ * GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT and all input channels with an odd\n+ * index are positioned to GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, then the\n+ * automatic mixing matrix should be configured like if there were only one\n+ * virtual input left channel and one virtual input right channel. This virtual\n+ * left or right channel is the mix of all the real left or right channels.\n+ *\/\n+static gboolean\n+gst_audio_channel_mixer_detect_virtual_input_channels (gint channels,\n+    GstAudioChannelPosition * position,\n+    GstAudioChannelMixerVirtualInput * virtual_input)\n+{\n+  g_return_val_if_fail (position != NULL, FALSE);\n+  g_return_val_if_fail (virtual_input != NULL, FALSE);\n+\n+  *virtual_input = GST_AUDIO_CHANNEL_MIXER_VIRTUAL_INPUT_NONE;\n+\n+  if (channels < 2)\n+    return FALSE;\n+\n+  static const GstAudioChannelPosition alternate_positions[2] =\n+      { GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+    GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT\n+  };\n+\n+  gboolean is_mono = TRUE;\n+  gboolean is_alternate = TRUE;\n+  for (gint i = 0; i < channels; ++i) {\n+    if (position[i] != GST_AUDIO_CHANNEL_POSITION_MONO)\n+      is_mono = FALSE;\n+\n+    if (position[i] != alternate_positions[i % 2])\n+      is_alternate = FALSE;\n+\n+    if (!is_mono && !is_alternate)\n+      return FALSE;\n+  }\n+\n+  if (is_mono) {\n+    g_assert (!is_alternate);\n+    *virtual_input = GST_AUDIO_CHANNEL_MIXER_VIRTUAL_INPUT_MONO;\n+    return TRUE;\n+  }\n+\n+  if (is_alternate && (channels > 2)) {\n+    g_assert (!is_mono);\n+    *virtual_input = GST_AUDIO_CHANNEL_MIXER_VIRTUAL_INPUT_STEREO;\n+    return TRUE;\n+  }\n+\n+  return FALSE;\n+}\n+\n@@ -644,1 +713,27 @@\n-  gst_audio_channel_mixer_fill_identical (matrix, in_channels, in_position,\n+  \/* If all input channels are positioned to mono, the mix matrix should be\n+   * configured like if there was only one virtual input mono channel. This\n+   * virtual mono channel is the mix of all the real input mono channels.\n+   *\n+   * If all input channels are positioned to left and right alternately, the mix\n+   * matrix should be configured like if there were only two virtual input\n+   * channels: one left and one right. This virtual left or right channel is the\n+   * mix of all the real input left or right channels.\n+   *\/\n+  gint in_size = in_channels;\n+  GstAudioChannelMixerVirtualInput virtual_input =\n+      GST_AUDIO_CHANNEL_MIXER_VIRTUAL_INPUT_NONE;\n+  if (gst_audio_channel_mixer_detect_virtual_input_channels (in_size,\n+          in_position, &virtual_input)) {\n+    switch (virtual_input) {\n+      case GST_AUDIO_CHANNEL_MIXER_VIRTUAL_INPUT_MONO:\n+        in_size = 1;\n+        break;\n+      case GST_AUDIO_CHANNEL_MIXER_VIRTUAL_INPUT_STEREO:\n+        in_size = 2;\n+        break;\n+      default:\n+        break;\n+    }\n+  }\n+\n+  gst_audio_channel_mixer_fill_identical (matrix, in_size, in_position,\n@@ -648,1 +743,1 @@\n-    gst_audio_channel_mixer_fill_compatible (matrix, in_channels, in_position,\n+    gst_audio_channel_mixer_fill_compatible (matrix, in_size, in_position,\n@@ -650,1 +745,1 @@\n-    gst_audio_channel_mixer_fill_others (matrix, in_channels, in_position,\n+    gst_audio_channel_mixer_fill_others (matrix, in_size, in_position,\n@@ -652,1 +747,31 @@\n-    gst_audio_channel_mixer_fill_normalize (matrix, in_channels, out_channels);\n+    gst_audio_channel_mixer_fill_normalize (matrix, in_size, out_channels);\n+  }\n+\n+  switch (virtual_input) {\n+    case GST_AUDIO_CHANNEL_MIXER_VIRTUAL_INPUT_MONO:{\n+      for (gint out = 0; out < out_channels; ++out)\n+        matrix[0][out] \/= in_channels;\n+\n+      for (gint in = 1; in < in_channels; ++in)\n+        memcpy (matrix[in], matrix[0], out_channels * sizeof (gfloat));\n+\n+      break;\n+    }\n+\n+    case GST_AUDIO_CHANNEL_MIXER_VIRTUAL_INPUT_STEREO:{\n+      gint right_channels = in_channels >> 1;\n+      gint left_channels = right_channels + (in_channels % 2);\n+\n+      for (gint out = 0; out < out_channels; ++out) {\n+        matrix[0][out] \/= left_channels;\n+        matrix[1][out] \/= right_channels;\n+      }\n+\n+      for (gint in = 2; in < in_channels; ++in)\n+        memcpy (matrix[in], matrix[in % 2], out_channels * sizeof (gfloat));\n+\n+      break;\n+    }\n+\n+    default:\n+      break;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-channel-mixer.c","additions":129,"deletions":4,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -185,0 +185,46 @@\n+\/**\n+ * gst_audio_reorder_channels_with_reorder_map:\n+ * @data: (array length=size) (element-type guint8): The pointer to\n+ *   the memory.\n+ * @size: The size of the memory.\n+ * @bps: The number of bytes per sample.\n+ * @channels: The number of channels.\n+ * @reorder_map: (array length=channels): The channel reorder map.\n+ *\n+ * Reorders @data with the given @reorder_map.\n+ *\n+ * The reorder map can be retrieved for example with\n+ * gst_audio_get_channel_reorder_map().\n+ *\n+ * Note: this function assumes the audio data is in interleaved layout\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_audio_reorder_channels_with_reorder_map (gpointer data, gsize size,\n+    gint bps, gint channels, const gint * reorder_map)\n+{\n+  gint bpf = bps * channels;\n+  guint8 *ptr = data;\n+  gsize n;\n+\n+  g_return_if_fail (data != NULL);\n+  g_return_if_fail (size % (bps * channels) == 0);\n+  g_return_if_fail (bps > 0);\n+  g_return_if_fail (bps <= 64);\n+  g_return_if_fail (channels > 0);\n+  g_return_if_fail (channels <= 64);\n+  g_return_if_fail (reorder_map != NULL);\n+\n+  n = size \/ bpf;\n+  for (gsize i = 0; i < n; i++) {\n+    guint8 tmp[64 * 8];\n+\n+    memcpy (tmp, ptr, bpf);\n+    for (gint j = 0; j < channels; j++)\n+      memcpy (ptr + reorder_map[j] * bps, tmp + j * bps, bps);\n+\n+    ptr += bpf;\n+  }\n+}\n+\n@@ -199,0 +245,6 @@\n+ * This function internally calls gst_audio_get_channel_reorder_map() and\n+ * gst_audio_reorder_channels_with_reorder_map(). It is more efficient to call\n+ * gst_audio_get_channel_reorder_map() once to retrieve the reorder map and\n+ * then call gst_audio_reorder_channels_with_reorder_map() with the same\n+ * reorder map until the channel positions change.\n+ *\n@@ -209,1 +261,0 @@\n-  gint i, j, n;\n@@ -211,3 +262,0 @@\n-  guint8 *ptr;\n-  gint bpf, bps;\n-  guint8 tmp[64 * 8];\n@@ -237,13 +285,2 @@\n-  bps = info->width \/ 8;\n-  bpf = bps * channels;\n-  ptr = data;\n-\n-  n = size \/ bpf;\n-  for (i = 0; i < n; i++) {\n-\n-    memcpy (tmp, ptr, bpf);\n-    for (j = 0; j < channels; j++)\n-      memcpy (ptr + reorder_map[j] * bps, tmp + j * bps, bps);\n-\n-    ptr += bpf;\n-  }\n+  gst_audio_reorder_channels_with_reorder_map (data, size, info->width \/ 8,\n+      channels, reorder_map);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-channels.c","additions":54,"deletions":17,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+ * @GST_AUDIO_CHANNEL_POSITION_TOP_SURROUND_LEFT: Top surround left (between rear left and side left)\n+ *     (Since: 1.26)\n+ * @GST_AUDIO_CHANNEL_POSITION_TOP_SURROUND_RIGHT: Top surround right (between rear right and side right)\n+ *     (Since: 1.26)\n@@ -129,1 +133,19 @@\n-  GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT\n+  GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT,\n+\n+  \/**\n+   * GST_AUDIO_CHANNEL_POSITION_TOP_SURROUND_LEFT:\n+   *\n+   * Top surround left (between rear left and side left).\n+   *\n+   * Since: 1.26\n+   *\/\n+  GST_AUDIO_CHANNEL_POSITION_TOP_SURROUND_LEFT,\n+\n+  \/**\n+   * GST_AUDIO_CHANNEL_POSITION_TOP_SURROUND_RIGHT:\n+   *\n+   * Top surround right (between rear right and side right).\n+   *\n+   * Since: 1.26\n+   *\/\n+  GST_AUDIO_CHANNEL_POSITION_TOP_SURROUND_RIGHT\n@@ -148,0 +170,6 @@\n+GST_AUDIO_API\n+void           gst_audio_reorder_channels_with_reorder_map (gpointer data, gsize size,\n+                                                            gint bps,\n+                                                            gint channels,\n+                                                            const gint *reorder_map);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-channels.h","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -314,1 +314,2 @@\n-copy_config (GQuark field_id, const GValue * value, gpointer user_data)\n+copy_config (const GstIdStr * fieldname, const GValue * value,\n+    gpointer user_data)\n@@ -318,1 +319,1 @@\n-  gst_structure_id_set_value (convert->config, field_id, value);\n+  gst_structure_id_str_set_value (convert->config, fieldname, value);\n@@ -369,1 +370,1 @@\n-    gst_structure_foreach (config, copy_config, convert);\n+    gst_structure_foreach_id_str (config, copy_config, convert);\n@@ -789,2 +790,7 @@\n-      if (!G_VALUE_HOLDS_FLOAT (itm)) {\n-        GST_ERROR (\"Invalid mix matrix element type, should be float\");\n+      if (!G_VALUE_HOLDS_FLOAT (itm) &&\n+          !G_VALUE_HOLDS_DOUBLE (itm) &&\n+          !G_VALUE_HOLDS_INT (itm) &&\n+          !G_VALUE_HOLDS_INT64 (itm) &&\n+          !G_VALUE_HOLDS_UINT (itm) && !G_VALUE_HOLDS_UINT64 (itm)) {\n+        GST_ERROR\n+            (\"Invalid mix matrix element type, should be float or double or integer\");\n@@ -820,1 +826,15 @@\n-      coefficient = g_value_get_float (itm);\n+      if (G_VALUE_HOLDS_FLOAT (itm))\n+        coefficient = g_value_get_float (itm);\n+      else if (G_VALUE_HOLDS_DOUBLE (itm))\n+        coefficient = g_value_get_double (itm);\n+      else if (G_VALUE_HOLDS_INT (itm))\n+        coefficient = g_value_get_int (itm);\n+      else if (G_VALUE_HOLDS_INT64 (itm))\n+        coefficient = g_value_get_int64 (itm);\n+      else if (G_VALUE_HOLDS_UINT (itm))\n+        coefficient = g_value_get_uint (itm);\n+      else if (G_VALUE_HOLDS_UINT64 (itm))\n+        coefficient = g_value_get_uint64 (itm);\n+      else\n+        g_assert_not_reached ();\n+\n@@ -1357,1 +1377,1 @@\n-  convert->config = gst_structure_new_empty (\"GstAudioConverter\");\n+  convert->config = gst_structure_new_static_str_empty (\"GstAudioConverter\");\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-converter.c","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -431,0 +431,11 @@\n+\/**\n+ * gst_audio_format_to_string:\n+ * @format: a #GstAudioFormat audio format\n+ *\n+ * Returns a string containing a descriptive name for the #GstAudioFormat.\n+ *\n+ * Since 1.26 this can also be used with %GST_AUDIO_FORMAT_UNKNOWN, previous\n+ * versions were printing a critical warning and returned %NULL.\n+ *\n+ * Returns: the name corresponding to @format\n+ *\/\n@@ -434,1 +445,1 @@\n-  g_return_val_if_fail (format != GST_AUDIO_FORMAT_UNKNOWN, NULL);\n+  g_return_val_if_fail ((gint) format < G_N_ELEMENTS (formats), NULL);\n@@ -436,0 +447,1 @@\n+  \/* In case glib checks are disabled *\/\n@@ -663,1 +675,1 @@\n-  s = gst_structure_new (\"audio\/x-raw\",\n+  s = gst_structure_new_static_str (\"audio\/x-raw\",\n@@ -668,1 +680,1 @@\n-  gst_structure_take_value (s, \"format\", &format);\n+  gst_structure_take_value_static_str (s, \"format\", &format);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-format.c","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -131,0 +131,3 @@\n+\n+  \/* Update GST_AUDIO_FORMAT_LAST below when adding more formats here *\/\n+\n@@ -148,0 +151,8 @@\n+\/**\n+ * GST_AUDIO_FORMAT_LAST:\n+ *\n+ * Number of audio formats in #GstAudioFormat.\n+ *\n+ * Since: 1.26\n+ *\/\n+#define GST_AUDIO_FORMAT_LAST (GST_AUDIO_FORMAT_F64BE + 1)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-format.h","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-  caps = gst_caps_new_simple (\"audio\/x-raw\",\n+  caps = gst_caps_new_static_str_simple (\"audio\/x-raw\",\n@@ -415,2 +415,2 @@\n-      gst_caps_set_simple (caps, \"channel-mask\", GST_TYPE_BITMASK, channel_mask,\n-          NULL);\n+      gst_caps_set_simple_static_str (caps, \"channel-mask\", GST_TYPE_BITMASK,\n+          channel_mask, NULL);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/audio-info.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1216,2 +1216,2 @@\n-  gint writeseg, segdone;\n-  gint diff;\n+  guint64 writeseg, segdone;\n+  gint64 diff;\n@@ -1232,2 +1232,2 @@\n-  segdone = g_atomic_int_get (&sink->ringbuffer->segdone)\n-      - sink->ringbuffer->segbase;\n+  segdone = gst_audio_ring_buffer_get_segdone (sink->ringbuffer)\n+      - gst_audio_ring_buffer_get_segbase (sink->ringbuffer);\n@@ -1279,1 +1279,1 @@\n-  GstClockTimeDiff requested_skew;\n+  GstClockTimeDiff requested_skew, drift;\n@@ -1317,1 +1317,10 @@\n-    cexternal = (cexternal > requested_skew) ? (cexternal - requested_skew) : 0;\n+    \/* Move the external time backward by the requested skew, but don't ever\n+     * go negative. Moving the requested skew by the same distance defines\n+     * the new clock skew window center point. This allows the clock to\n+     * drift equally into either direction after the correction. *\/\n+    if (G_LIKELY (cexternal > requested_skew))\n+      drift = requested_skew;\n+    else\n+      drift = cexternal;\n+\n+    cexternal -= drift;\n@@ -1319,2 +1328,1 @@\n-    driftsamples =\n-        (sink->ringbuffer->spec.info.rate * requested_skew) \/ GST_SECOND;\n+    driftsamples = (sink->ringbuffer->spec.info.rate * drift) \/ GST_SECOND;\n@@ -1335,1 +1343,2 @@\n-    cexternal += ABS (requested_skew);\n+    drift = -requested_skew;\n+    cexternal += drift;\n@@ -1337,2 +1346,1 @@\n-    driftsamples =\n-        (sink->ringbuffer->spec.info.rate * ABS (requested_skew)) \/ GST_SECOND;\n+    driftsamples = (sink->ringbuffer->spec.info.rate * drift) \/ GST_SECOND;\n@@ -1745,1 +1753,2 @@\n-  gint segdone = g_atomic_int_get (&ringbuf->segdone) - ringbuf->segbase;\n+  guint64 segdone = gst_audio_ring_buffer_get_segdone (sink->ringbuffer)\n+      - gst_audio_ring_buffer_get_segbase (sink->ringbuffer);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudiobasesink.c","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -703,2 +703,3 @@\n-  gint readseg, segdone, segtotal, sps;\n-  gint diff;\n+  guint64 readseg, segdone;\n+  gint segtotal, sps;\n+  gint64 diff;\n@@ -713,2 +714,2 @@\n-  segdone = g_atomic_int_get (&src->ringbuffer->segdone)\n-      - src->ringbuffer->segbase;\n+  segdone = gst_audio_ring_buffer_get_segdone (src->ringbuffer)\n+      - gst_audio_ring_buffer_get_segbase (src->ringbuffer);\n@@ -717,1 +718,2 @@\n-    GST_DEBUG_OBJECT (src, \"at segment %d and sample %\" G_GUINT64_FORMAT,\n+    GST_DEBUG_OBJECT (src,\n+        \"at segment %\" G_GUINT64_FORMAT \" and sample %\" G_GUINT64_FORMAT,\n@@ -728,1 +730,2 @@\n-      GST_DEBUG_OBJECT (src, \"dropped, align to segment %d\", segdone);\n+      GST_DEBUG_OBJECT (src, \"dropped, align to segment %\" G_GUINT64_FORMAT,\n+          segdone);\n@@ -734,2 +737,3 @@\n-    GST_DEBUG_OBJECT (src, \"first sample, align to current %d\", segdone);\n-    sample = ((guint64) (segdone)) * sps;\n+    GST_DEBUG_OBJECT (src, \"first sample, align to current %\" G_GUINT64_FORMAT,\n+        segdone);\n+    sample = segdone * sps;\n@@ -740,2 +744,2 @@\n-      \"reading from %d, we are at %d, sample %\" G_GUINT64_FORMAT, readseg,\n-      segdone, sample);\n+      \"reading from %\" G_GUINT64_FORMAT \", we are at %\" G_GUINT64_FORMAT\n+      \", sample %\" G_GUINT64_FORMAT, readseg, segdone, sample);\n@@ -879,3 +883,3 @@\n-        gint running_time_segment;\n-        gint last_read_segment;\n-        gint segment_skew;\n+        guint64 running_time_segment;\n+        guint64 last_read_segment;\n+        gint64 segment_skew;\n@@ -883,2 +887,2 @@\n-        gint segments_written;\n-        gint last_written_segment;\n+        guint64 segments_written;\n+        guint64 last_written_segment;\n@@ -887,1 +891,1 @@\n-        segments_written = g_atomic_int_get (&ringbuffer->segdone);\n+        segments_written = gst_audio_ring_buffer_get_segdone (src->ringbuffer);\n@@ -892,1 +896,3 @@\n-        last_written_segment = segments_written - ringbuffer->segbase - 1;\n+        last_written_segment =\n+            segments_written - gst_audio_ring_buffer_get_segbase (ringbuffer) -\n+            1;\n@@ -926,7 +932,10 @@\n-            \"\\n running_time_segment                                       = %d\"\n-            \"\\n last_written_segment                                       = %d\"\n-            \"\\n segment_skew (running time segment - last_written_segment) = %d\"\n-            \"\\n last_read_segment                                          = %d\",\n-            GST_TIME_ARGS (running_time), GST_TIME_ARGS (timestamp),\n-            running_time_segment, last_written_segment, segment_skew,\n-            last_read_segment);\n+            \"\\n running_time_segment                                       = %\"\n+            G_GUINT64_FORMAT\n+            \"\\n last_written_segment                                       = %\"\n+            G_GUINT64_FORMAT\n+            \"\\n segment_skew (running time segment - last_written_segment) = %\"\n+            G_GINT64_FORMAT\n+            \"\\n last_read_segment                                          = %\"\n+            G_GUINT64_FORMAT, GST_TIME_ARGS (running_time),\n+            GST_TIME_ARGS (timestamp), running_time_segment,\n+            last_written_segment, segment_skew, last_read_segment);\n@@ -946,2 +955,2 @@\n-          gint new_read_segment;\n-          gint segment_diff;\n+          guint64 new_read_segment;\n+          guint64 segment_diff;\n@@ -957,2 +966,2 @@\n-          new_read_segment =\n-              g_atomic_int_get (&ringbuffer->segdone) - ringbuffer->segbase;\n+          new_read_segment = gst_audio_ring_buffer_get_segdone (src->ringbuffer)\n+              - gst_audio_ring_buffer_get_segbase (src->ringbuffer);\n@@ -961,1 +970,1 @@\n-          new_sample = ((guint64) new_read_segment) * sps;\n+          new_sample = new_read_segment * sps;\n@@ -970,1 +979,1 @@\n-              \"Timeshifted the ringbuffer with %d segments: \"\n+              \"Timeshifted the ringbuffer with %\" G_GINT64_FORMAT \" segments: \"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudiobasesrc.c","additions":39,"deletions":30,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2552,2 +2552,0 @@\n-\n-      \/* fall through *\/\n@@ -2555,0 +2553,1 @@\n+      \/* FALLTHROUGH *\/\n@@ -2911,1 +2910,0 @@\n-      \/* fall-through *\/\n@@ -2913,0 +2911,1 @@\n+      \/* FALLTHROUGH *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudiodecoder.c","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1728,1 +1728,0 @@\n-      \/* fall through *\/\n@@ -1730,0 +1729,1 @@\n+      \/* FALLTHROUGH *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudioencoder.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,118 @@\n+\/* TODO: use GLib's once https:\/\/gitlab.gnome.org\/GNOME\/glib\/issues\/1076 lands, or\n+ * use C11 atomics once MS arrives in this century.\n+ *\n+ * We also assume that signed overflow just wraps around because unfortunately\n+ * there are no unsigned versions in MSVC. *\/\n+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_ATOMICS__)\n+#include <stdatomic.h>\n+\n+static inline guint64\n+gst_atomic_uint64_add (guint64 * atomic, guint64 n)\n+{\n+  return atomic_fetch_add ((_Atomic guint64 *) atomic, n);\n+}\n+\n+static inline void\n+gst_atomic_uint64_set (guint64 * atomic, guint64 n)\n+{\n+  atomic_store ((_Atomic guint64 *) atomic, n);\n+}\n+\n+static inline guint64\n+gst_atomic_uint64_get (guint64 * atomic)\n+{\n+  gint64 ret = atomic_load ((_Atomic guint64 *) atomic);\n+  return ret;\n+}\n+#elif defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8)\n+static inline guint64\n+gst_atomic_uint64_add (guint64 * atomic, guint64 n)\n+{\n+  return __sync_fetch_and_add (atomic, n);\n+}\n+\n+static inline void\n+gst_atomic_uint64_set (guint64 * atomic, guint64 n)\n+{\n+  __sync_synchronize ();\n+  __asm__ __volatile__ (\"\":::\"memory\");\n+  *atomic = n;\n+}\n+\n+static inline guint64\n+gst_atomic_uint64_get (guint64 * atomic)\n+{\n+  gint64 ret = *atomic;\n+  __sync_synchronize ();\n+  __asm__ __volatile__ (\"\":::\"memory\");\n+  return ret;\n+}\n+#elif defined (G_PLATFORM_WIN32)\n+#include <windows.h>\n+static inline guint64\n+gst_atomic_uint64_add (guint64 * atomic, guint64 n)\n+{\n+  return InterlockedExchangeAdd64 ((gint64 *) atomic, (gint64) n);\n+}\n+\n+static inline void\n+gst_atomic_uint64_set (guint64 * atomic, guint64 n)\n+{\n+  *atomic = n;\n+  MemoryBarrier ();\n+}\n+\n+static inline guint64\n+gst_atomic_uint64_get (guint64 * atomic)\n+{\n+  MemoryBarrier ();\n+  return *atomic;\n+}\n+#else\n+#define STR_TOKEN(s) #s\n+#define STR(s) STR_TOKEN(s)\n+#pragma message \"No 64-bit atomic int defined for this \" STR(TARGET_CPU) \" platform\/toolchain!\"\n+\n+#define NO_64BIT_ATOMIC_INT_FOR_PLATFORM\n+G_LOCK_DEFINE_STATIC (atomic_lock);\n+static inline guint64\n+gst_atomic_uint64_add (guint64 * atomic, guint64 n)\n+{\n+  guint64 ret;\n+\n+  G_LOCK (atomic_lock);\n+  *atomic += n;\n+  ret = *atomic;\n+  G_UNLOCK (atomic_lock);\n+\n+  return ret;\n+}\n+\n+static inline void\n+gst_atomic_uint64_set (guint64 * atomic, guint64 n)\n+{\n+  G_LOCK (atomic_lock);\n+  *atomic = n;\n+  G_UNLOCK (atomic_lock);\n+}\n+\n+static inline guint64\n+gst_atomic_uint64_get (gint64 * atomic)\n+{\n+  guint64 ret;\n+\n+  G_LOCK (atomic_lock);\n+  ret = *atomic;\n+  G_UNLOCK (atomic_lock);\n+\n+  return ret;\n+}\n+#endif\n+\n+struct _GstAudioRingBufferPrivate\n+{\n+  \/* ATOMIC *\/\n+  guint64 segdone;\n+  guint64 segbase;\n+};\n+\n@@ -60,1 +178,1 @@\n-G_DEFINE_ABSTRACT_TYPE (GstAudioRingBuffer, gst_audio_ring_buffer,\n+G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE (GstAudioRingBuffer, gst_audio_ring_buffer,\n@@ -85,0 +203,1 @@\n+  ringbuffer->priv = gst_audio_ring_buffer_get_instance_private (ringbuffer);\n@@ -94,0 +213,2 @@\n+  ringbuffer->priv->segbase = 0;\n+  ringbuffer->priv->segdone = 0;\n@@ -814,2 +935,4 @@\n-  GST_DEBUG_OBJECT (buf, \"signal waiter\");\n-  GST_AUDIO_RING_BUFFER_SIGNAL (buf);\n+  if (g_atomic_int_compare_and_exchange (&buf->waiting, 1, 0)) {\n+    GST_DEBUG_OBJECT (buf, \"signal waiter\");\n+    GST_AUDIO_RING_BUFFER_SIGNAL (buf);\n+  }\n@@ -820,0 +943,1 @@\n+  gst_atomic_uint64_set (&buf->priv->segdone, 0);\n@@ -821,0 +945,1 @@\n+  buf->priv->segbase = 0;\n@@ -1154,2 +1279,4 @@\n-  GST_DEBUG_OBJECT (buf, \"signal waiter\");\n-  GST_AUDIO_RING_BUFFER_SIGNAL (buf);\n+  if (g_atomic_int_compare_and_exchange (&buf->waiting, 1, 0)) {\n+    GST_DEBUG_OBJECT (buf, \"signal waiter\");\n+    GST_AUDIO_RING_BUFFER_SIGNAL (buf);\n+  }\n@@ -1271,2 +1398,4 @@\n-  GST_DEBUG_OBJECT (buf, \"signal waiter\");\n-  GST_AUDIO_RING_BUFFER_SIGNAL (buf);\n+  if (g_atomic_int_compare_and_exchange (&buf->waiting, 1, 0)) {\n+    GST_DEBUG_OBJECT (buf, \"signal waiter\");\n+    GST_AUDIO_RING_BUFFER_SIGNAL (buf);\n+  }\n@@ -1351,1 +1480,1 @@\n-  gint segdone;\n+  guint64 segdone;\n@@ -1357,1 +1486,1 @@\n-  segdone = g_atomic_int_get (&buf->segdone);\n+  segdone = gst_atomic_uint64_get (&buf->priv->segdone);\n@@ -1360,1 +1489,1 @@\n-  samples = ((guint64) segdone) * buf->samples_per_seg;\n+  samples = segdone * buf->samples_per_seg;\n@@ -1382,0 +1511,2 @@\n+  guint64 segdone;\n+\n@@ -1393,1 +1524,3 @@\n-  buf->segbase = buf->segdone - sample \/ buf->samples_per_seg;\n+  segdone = gst_atomic_uint64_get (&buf->priv->segdone);\n+  buf->priv->segbase = segdone - sample \/ buf->samples_per_seg;\n+  buf->segbase = buf->priv->segbase;\n@@ -1397,2 +1530,57 @@\n-  GST_DEBUG_OBJECT (buf, \"set sample to %\" G_GUINT64_FORMAT \", segbase %d\",\n-      sample, buf->segbase);\n+  GST_DEBUG_OBJECT (buf,\n+      \"set sample to %\" G_GUINT64_FORMAT \", segbase %\" G_GUINT64_FORMAT, sample,\n+      buf->priv->segbase);\n+}\n+\n+\/**\n+ * gst_audio_ring_buffer_set_segdone:\n+ * @buf: the #GstAudioRingBuffer to use\n+ * @segdone: the segment number to set\n+ *\n+ * Sets the current segment number of the ringbuffer.\n+ *\n+ * MT safe.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_audio_ring_buffer_set_segdone (GstAudioRingBuffer * buf, guint64 segdone)\n+{\n+  gst_atomic_uint64_set (&buf->priv->segdone, segdone);\n+  g_atomic_int_set (&buf->segdone, segdone);\n+}\n+\n+\/**\n+ * gst_audio_ring_buffer_get_segdone:\n+ * @buf: the #GstAudioRingBuffer to use\n+ *\n+ * Gets the current segment number of the ringbuffer.\n+ *\n+ * MT safe.\n+ *\n+ * Returns: Current segment number of the ringbuffer.\n+ *\n+ * Since: 1.26\n+ *\/\n+guint64\n+gst_audio_ring_buffer_get_segdone (GstAudioRingBuffer * buf)\n+{\n+  return gst_atomic_uint64_get (&buf->priv->segdone);\n+}\n+\n+\/**\n+ * gst_audio_ring_buffer_get_segbase:\n+ * @buf: the #GstAudioRingBuffer to use\n+ *\n+ * Gets the current segment base number of the ringbuffer.\n+ *\n+ * MT safe.\n+ *\n+ * Returns: Current segment base number of the ringbuffer.\n+ *\n+ * Since: 1.26\n+ *\/\n+guint64\n+gst_audio_ring_buffer_get_segbase (GstAudioRingBuffer * buf)\n+{\n+  return gst_atomic_uint64_get (&buf->priv->segbase);\n@@ -1448,1 +1636,1 @@\n-  gint segments;\n+  guint64 segments;\n@@ -1459,1 +1647,1 @@\n-    segments = g_atomic_int_get (&buf->segdone);\n+    segments = gst_atomic_uint64_get (&buf->priv->segdone);\n@@ -1464,1 +1652,1 @@\n-    if (G_LIKELY (g_atomic_int_get (&buf->segdone) != segments))\n+    if (G_LIKELY (gst_atomic_uint64_get (&buf->priv->segdone) != segments))\n@@ -1628,1 +1816,1 @@\n-  gint segdone;\n+  guint64 segdone;\n@@ -1631,1 +1819,1 @@\n-  gint writeseg, sampleoff;\n+  guint64 writeseg, sampleoff;\n@@ -1680,1 +1868,1 @@\n-      gint diff;\n+      gint64 diff;\n@@ -1683,1 +1871,2 @@\n-      segdone = g_atomic_int_get (&buf->segdone) - buf->segbase;\n+      segdone =\n+          gst_atomic_uint64_get (&buf->priv->segdone) - buf->priv->segbase;\n@@ -1689,2 +1878,4 @@\n-          \"pointer at %d, write to %d-%d, diff %d, segtotal %d, segsize %d, base %d\",\n-          segdone, writeseg, sampleoff, diff, segtotal, segsize, buf->segbase);\n+          \"pointer at %\" G_GUINT64_FORMAT \", write to %\" G_GUINT64_FORMAT \"-%\"\n+          G_GUINT64_FORMAT \", diff %\" G_GINT64_FORMAT\n+          \", segtotal %d, segsize %d, base %\" G_GUINT64_FORMAT, segdone,\n+          writeseg, sampleoff, diff, segtotal, segsize, buf->priv->segbase);\n@@ -1719,1 +1910,2 @@\n-    GST_DEBUG_OBJECT (buf, \"write @%p seg %d, sps %d, off %d, avail %d\",\n+    GST_DEBUG_OBJECT (buf,\n+        \"write @%p seg %d, sps %d, off %\" G_GUINT64_FORMAT \", avail %d\",\n@@ -1862,2 +2054,2 @@\n-  gint segdone;\n-  gint segsize, segtotal, channels, bps, bpf, sps, readseg = 0;\n+  guint64 segdone, readseg = 0;\n+  gint segsize, segtotal, channels, bps, bpf, sps;\n@@ -1893,1 +2085,1 @@\n-      gint diff;\n+      gint64 diff;\n@@ -1896,1 +2088,2 @@\n-      segdone = g_atomic_int_get (&buf->segdone) - buf->segbase;\n+      segdone =\n+          gst_atomic_uint64_get (&buf->priv->segdone) - buf->priv->segbase;\n@@ -1904,4 +2097,4 @@\n-          (buf, \"pointer at %d, sample %\" G_GUINT64_FORMAT\n-          \", read from %d-%d, to_read %d, diff %d, segtotal %d, segsize %d\",\n-          segdone, sample, readseg, sampleoff, to_read, diff, segtotal,\n-          segsize);\n+          (buf, \"pointer at %\" G_GUINT64_FORMAT \", sample %\" G_GUINT64_FORMAT\n+          \", read from %\" G_GUINT64_FORMAT \"-%d, to_read %d, diff %\"\n+          G_GINT64_FORMAT \", segtotal %d, segsize %d\", segdone, sample, readseg,\n+          sampleoff, to_read, diff, segtotal, segsize);\n@@ -1931,1 +2124,2 @@\n-    GST_DEBUG_OBJECT (buf, \"read @%p seg %d, off %d, sampleslen %d\",\n+    GST_DEBUG_OBJECT (buf,\n+        \"read @%p seg %\" G_GUINT64_FORMAT \", off %d, sampleslen %d\",\n@@ -1960,1 +2154,2 @@\n-        \" @ %d\", GST_TIME_ARGS (*timestamp), readseg % segtotal);\n+        \" @ %\" G_GUINT64_FORMAT, GST_TIME_ARGS (*timestamp),\n+        readseg % segtotal);\n@@ -1993,1 +2188,1 @@\n-  gint segdone;\n+  guint64 segdone;\n@@ -2011,1 +2206,1 @@\n-  segdone = g_atomic_int_get (&buf->segdone);\n+  segdone = gst_atomic_uint64_get (&buf->priv->segdone);\n@@ -2017,2 +2212,3 @@\n-  GST_LOG_OBJECT (buf, \"prepare read from segment %d (real %d) @%p\",\n-      *segment, segdone, *readptr);\n+  GST_LOG_OBJECT (buf,\n+      \"prepare read from segment %d (real %\" G_GUINT64_FORMAT \") @%p\", *segment,\n+      segdone, *readptr);\n@@ -2044,0 +2240,1 @@\n+  gst_atomic_uint64_add (&buf->priv->segdone, advance);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudioringbuffer.c","additions":234,"deletions":37,"binary":false,"changes":271,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+typedef struct _GstAudioRingBufferPrivate GstAudioRingBufferPrivate;\n@@ -250,1 +251,2 @@\n-  gpointer _gst_reserved[GST_PADDING - 1];\n+  GstAudioRingBufferPrivate   *priv;\n+  gpointer _gst_reserved[GST_PADDING - 2];\n@@ -444,0 +446,9 @@\n+GST_AUDIO_API\n+void            gst_audio_ring_buffer_set_segdone     (GstAudioRingBuffer *buf, guint64 segdone);\n+\n+GST_AUDIO_API\n+guint64         gst_audio_ring_buffer_get_segdone     (GstAudioRingBuffer *buf);\n+\n+GST_AUDIO_API\n+guint64         gst_audio_ring_buffer_get_segbase     (GstAudioRingBuffer *buf);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudioringbuffer.h","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-    GQuark q_name =\n-        gst_structure_get_name_id (gst_caps_get_structure (templ_caps, i));\n+    const GstIdStr *name =\n+        gst_structure_get_name_id_str (gst_caps_get_structure (templ_caps, i));\n@@ -55,1 +55,1 @@\n-      s = gst_structure_new_id_empty (q_name);\n+      s = gst_structure_new_id_str_empty (name);\n@@ -221,0 +221,3 @@\n+typedef HANDLE (WINAPI * AvSetMmThreadCharacteristicsPtr) (LPCSTR, LPDWORD);\n+typedef BOOL (WINAPI * AvRevertMmThreadCharacteristicsPtr) (HANDLE);\n+\n@@ -226,2 +229,2 @@\n-  FARPROC AvSetMmThreadCharacteristics;\n-  FARPROC AvRevertMmThreadCharacteristics;\n+  AvSetMmThreadCharacteristicsPtr AvSetMmThreadCharacteristics;\n+  AvRevertMmThreadCharacteristicsPtr AvRevertMmThreadCharacteristics;\n@@ -249,0 +252,1 @@\n+        (AvSetMmThreadCharacteristicsPtr)\n@@ -258,0 +262,1 @@\n+        (AvRevertMmThreadCharacteristicsPtr)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/audio\/gstaudioutilsprivate.c","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include <stdio.h>\n@@ -1546,0 +1547,434 @@\n+\/**\n+ * gst_codec_utils_h266_get_profile:\n+ * @ptl_record: (array length=len): Pointer to the VvcPTLRecord structure as defined in ISO\/IEC 14496-15.\n+ * @len: Length of the data available in @ptl_record\n+ *\n+ * Converts the profile indication (general_profile_idc) in the stream's\n+ * ptl_record structure into a string.\n+ *\n+ * Returns: (nullable): The profile as a const string, or %NULL if there is an error.\n+ *\n+ * Since: 1.26\n+ *\/\n+const gchar *\n+gst_codec_utils_h266_get_profile (const guint8 * ptl_record, guint len)\n+{\n+  gint profile_idc;\n+\n+  g_return_val_if_fail (ptl_record != NULL, NULL);\n+\n+  if (len < 2)\n+    return NULL;\n+\n+  GST_MEMDUMP (\"VvcPTLRecord\", ptl_record, len);\n+\n+  profile_idc = (ptl_record[1] & 0xFE) >> 1;\n+\n+  if (!profile_idc)\n+    return NULL;\n+\n+  switch (profile_idc) {\n+    case 1:\n+      return \"main-10\";\n+      break;\n+    case 2:\n+      return \"main-12\";\n+      break;\n+    case 10:\n+      return \"main-12-intra\";\n+      break;\n+    case 17:\n+      return \"multilayer-main-10\";\n+      break;\n+    case 33:\n+      return \"main-444-10\";\n+      break;\n+    case 34:\n+      return \"main-444-12\";\n+      break;\n+    case 35:\n+      return \"main-444-16\";\n+      break;\n+    case 42:\n+      return \"main-444-12-intra\";\n+      break;\n+    case 43:\n+      return \"main-444-16-intra\";\n+      break;\n+    case 49:\n+      return \"multilayer-main-444-10\";\n+      break;\n+    case 65:\n+      return \"main-10-still-picture\";\n+      break;\n+    case 66:\n+      return \"main-12-still-picture\";\n+      break;\n+    case 97:\n+      return \"main-444-10-still-picture\";\n+      break;\n+    case 98:\n+      return \"main-444-12-still-picture\";\n+      break;\n+    case 99:\n+      return \"main-444-16-still-picture\";\n+      break;\n+    default:\n+      return NULL;\n+  }\n+}\n+\n+\/**\n+ * gst_codec_utils_h266_get_tier:\n+ * @ptl_record: (array length=len): Pointer to the VvcPTLRecord structure as defined in ISO\/IEC 14496-15.\n+ * @len: Length of the data available in @ptl_record.\n+ *\n+ * Converts the tier indication (general_tier_flag) in the stream's\n+ * ptl_record structure into a string.\n+ *\n+ * Returns: (nullable): The tier as a const string, or %NULL if there is an error.\n+ *\n+ * Since: 1.26\n+ *\/\n+const gchar *\n+gst_codec_utils_h266_get_tier (const guint8 * ptl_record, guint len)\n+{\n+  const gchar *tier = NULL;\n+  gint tier_flag = 0;\n+\n+  g_return_val_if_fail (ptl_record != NULL, NULL);\n+\n+  if (len < 2)\n+    return NULL;\n+\n+  GST_MEMDUMP (\"VvcPTLRecord\", ptl_record, len);\n+\n+  tier_flag = ptl_record[1] & 0x01;\n+\n+  if (tier_flag)\n+    tier = \"high\";\n+  else\n+    tier = \"main\";\n+\n+  return tier;\n+}\n+\n+\/**\n+ * gst_codec_utils_h266_get_level:\n+ * @ptl_record: (array length=len): Pointer to the VvcPTLRecord structure as defined in ISO\/IEC 14496-15.\n+ * @len: Length of the data available in @ptl_record.\n+ *\n+ * Converts the level indication (general_level_idc) in the stream's\n+ * ptl_record structure into a string.\n+ *\n+ * Returns: (nullable): The level as a const string, or %NULL if there is an error.\n+ *\n+ * Since: 1.26\n+ *\/\n+const gchar *\n+gst_codec_utils_h266_get_level (const guint8 * ptl_record, guint len)\n+{\n+  guint8 level_idc;\n+\n+  g_return_val_if_fail (ptl_record != NULL, NULL);\n+\n+  if (len < 3)\n+    return NULL;\n+\n+  GST_MEMDUMP (\"VvcPTLRecord\", ptl_record, len);\n+\n+  level_idc = ptl_record[2];\n+\n+  if (!level_idc)\n+    return NULL;\n+\n+  switch (level_idc) {\n+    case 16:\n+      return \"1\";\n+      break;\n+    case 32:\n+      return \"2\";\n+      break;\n+    case 35:\n+      return \"2.1\";\n+      break;\n+    case 48:\n+      return \"3\";\n+      break;\n+    case 51:\n+      return \"3.1\";\n+      break;\n+    case 64:\n+      return \"4\";\n+      break;\n+    case 67:\n+      return \"4.1\";\n+      break;\n+    case 80:\n+      return \"5\";\n+      break;\n+    case 83:\n+      return \"5.1\";\n+      break;\n+    case 86:\n+      return \"5.2\";\n+      break;\n+    case 96:\n+      return \"6\";\n+      break;\n+    case 99:\n+      return \"6.1\";\n+      break;\n+    case 102:\n+      return \"6.2\";\n+      break;\n+    case 105:\n+      return \"6.3\";\n+      break;\n+    default:\n+      return NULL;\n+  }\n+}\n+\n+\/**\n+ * gst_codec_utils_h266_get_level_idc:\n+ * @level: A level string from caps\n+ *\n+ * Transform a level string from the caps into the level_idc\n+ *\n+ * Returns: the level_idc or 0 if the level is unknown\n+ *\n+ * Since: 1.26\n+ *\/\n+guint8\n+gst_codec_utils_h266_get_level_idc (const gchar * level)\n+{\n+  g_return_val_if_fail (level != NULL, 0);\n+\n+  if (!strcmp (level, \"1\"))\n+    return 16;\n+  else if (!strcmp (level, \"2\"))\n+    return 32;\n+  else if (!strcmp (level, \"2.1\"))\n+    return 35;\n+  else if (!strcmp (level, \"3\"))\n+    return 48;\n+  else if (!strcmp (level, \"3.1\"))\n+    return 51;\n+  else if (!strcmp (level, \"4\"))\n+    return 64;\n+  else if (!strcmp (level, \"4.1\"))\n+    return 67;\n+  else if (!strcmp (level, \"5\"))\n+    return 80;\n+  else if (!strcmp (level, \"5.1\"))\n+    return 83;\n+  else if (!strcmp (level, \"5.2\"))\n+    return 86;\n+  else if (!strcmp (level, \"6\"))\n+    return 96;\n+  else if (!strcmp (level, \"6.1\"))\n+    return 99;\n+  else if (!strcmp (level, \"6.2\"))\n+    return 102;\n+  else if (!strcmp (level, \"6.3\"))\n+    return 105;\n+\n+\n+  GST_WARNING (\"Invalid level %s\", level);\n+  return 0;\n+}\n+\n+\/**\n+ * gst_codec_utils_h266_caps_set_level_tier_and_profile:\n+ * @caps: the #GstCaps to which the level, tier and profile are to be added\n+ * @decoder_configuration: (array length=len): Pointer to the VvcDecoderConfigurationRecord struct as defined in ISO\/IEC 14496-15\n+ * @len: Length of the data available in @decoder_configuration.\n+ *\n+ * Sets the level, tier and profile in @caps if it can be determined from\n+ * @decoder_configuration. See gst_codec_utils_h266_get_level(),\n+ * gst_codec_utils_h266_get_tier() and gst_codec_utils_h266_get_profile()\n+ * for more details on the parameters.\n+ *\n+ * Returns: %TRUE if the level, tier, profile could be set, %FALSE otherwise.\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_codec_utils_h266_caps_set_level_tier_and_profile (GstCaps * caps,\n+    const guint8 * decoder_configuration, guint len)\n+{\n+  const gchar *level, *tier, *profile;\n+  gboolean ptl_present_flag;\n+  const guint8 *ptl_record;\n+\n+  g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);\n+  g_return_val_if_fail (GST_CAPS_IS_SIMPLE (caps), FALSE);\n+  g_return_val_if_fail (GST_SIMPLE_CAPS_HAS_NAME (caps, \"video\/x-h266\"), FALSE);\n+  g_return_val_if_fail (decoder_configuration != NULL, FALSE);\n+\n+  if (len < 5)\n+    return FALSE;\n+\n+  ptl_present_flag = decoder_configuration[0] & 0x01;\n+  if (!ptl_present_flag)\n+    return FALSE;\n+\n+  ptl_record = decoder_configuration + 4;\n+  len -= 4;\n+\n+  level = gst_codec_utils_h266_get_level (ptl_record, len);\n+  if (level != NULL)\n+    gst_caps_set_simple (caps, \"level\", G_TYPE_STRING, level, NULL);\n+\n+  tier = gst_codec_utils_h266_get_tier (ptl_record, len);\n+  if (tier != NULL)\n+    gst_caps_set_simple (caps, \"tier\", G_TYPE_STRING, tier, NULL);\n+\n+  profile = gst_codec_utils_h266_get_profile (ptl_record, len);\n+  if (profile != NULL)\n+    gst_caps_set_simple (caps, \"profile\", G_TYPE_STRING, profile, NULL);\n+\n+  GST_LOG (\"profile : %s\", (profile) ? profile : \"---\");\n+  GST_LOG (\"tier    : %s\", (tier) ? tier : \"---\");\n+  GST_LOG (\"level   : %s\", (level) ? level : \"---\");\n+\n+  return (level != NULL && tier != NULL && profile != NULL);\n+}\n+\n+\/**\n+ * gst_codec_utils_av1_get_seq_level_idx:\n+ * @level: A level string from caps\n+ *\n+ * Transform a level string from the caps into the seq_level_idx\n+ *\n+ * Returns: the seq_level_idx or 31 (max-level) if the level is unknown\n+ *\n+ * Since: 1.26\n+ *\/\n+guint8\n+gst_codec_utils_av1_get_seq_level_idx (const gchar * level)\n+{\n+  g_return_val_if_fail (level != NULL, 0);\n+\n+  if (!strcmp (level, \"2.0\"))\n+    return 0;\n+  else if (!strcmp (level, \"2.1\"))\n+    return 1;\n+  else if (!strcmp (level, \"2.2\"))\n+    return 2;\n+  else if (!strcmp (level, \"2.3\"))\n+    return 3;\n+  else if (!strcmp (level, \"3.0\"))\n+    return 4;\n+  else if (!strcmp (level, \"3.1\"))\n+    return 5;\n+  else if (!strcmp (level, \"3.2\"))\n+    return 6;\n+  else if (!strcmp (level, \"3.3\"))\n+    return 7;\n+  else if (!strcmp (level, \"4.0\"))\n+    return 8;\n+  else if (!strcmp (level, \"4.1\"))\n+    return 9;\n+  else if (!strcmp (level, \"4.2\"))\n+    return 10;\n+  else if (!strcmp (level, \"4.3\"))\n+    return 11;\n+  else if (!strcmp (level, \"5.0\"))\n+    return 12;\n+  else if (!strcmp (level, \"5.1\"))\n+    return 13;\n+  else if (!strcmp (level, \"5.2\"))\n+    return 14;\n+  else if (!strcmp (level, \"5.3\"))\n+    return 15;\n+  else if (!strcmp (level, \"6.0\"))\n+    return 16;\n+  else if (!strcmp (level, \"6.1\"))\n+    return 17;\n+  else if (!strcmp (level, \"6.2\"))\n+    return 18;\n+  else if (!strcmp (level, \"6.3\"))\n+    return 19;\n+  else if (!strcmp (level, \"7.0\"))\n+    return 20;\n+  else if (!strcmp (level, \"7.1\"))\n+    return 21;\n+  else if (!strcmp (level, \"7.2\"))\n+    return 22;\n+  else if (!strcmp (level, \"7.3\"))\n+    return 23;\n+\n+  GST_WARNING (\"Invalid level %s\", level);\n+  return 31;\n+}\n+\n+\/**\n+ * gst_codec_utils_av1_get_level:\n+ * @seq_level_idx: A seq_level_idx\n+ *\n+ * Transform a seq_level_idx into the level string\n+ *\n+ * Returns: (nullable): the level string or %NULL if the seq_level_idx is unknown\n+ *\n+ * Since: 1.26\n+ *\/\n+const gchar *\n+gst_codec_utils_av1_get_level (guint8 seq_level_idx)\n+{\n+  switch (seq_level_idx) {\n+    case 0:\n+      return \"2.0\";\n+    case 1:\n+      return \"2.1\";\n+    case 2:\n+      return \"2.2\";\n+    case 3:\n+      return \"2.3\";\n+    case 4:\n+      return \"3.0\";\n+    case 5:\n+      return \"3.1\";\n+    case 6:\n+      return \"3.2\";\n+    case 7:\n+      return \"3.3\";\n+    case 8:\n+      return \"4.0\";\n+    case 9:\n+      return \"4.1\";\n+    case 10:\n+      return \"4.2\";\n+    case 11:\n+      return \"4.3\";\n+    case 12:\n+      return \"5.0\";\n+    case 13:\n+      return \"5.1\";\n+    case 14:\n+      return \"5.2\";\n+    case 15:\n+      return \"5.3\";\n+    case 16:\n+      return \"6.0\";\n+    case 17:\n+      return \"6.1\";\n+    case 18:\n+      return \"6.2\";\n+    case 19:\n+      return \"6.3\";\n+    case 20:\n+      return \"7.0\";\n+    case 21:\n+      return \"7.1\";\n+    case 22:\n+      return \"7.2\";\n+    case 23:\n+      return \"7.3\";\n+    default:\n+      return NULL;\n+  }\n+}\n+\n+\n@@ -2284,0 +2719,226 @@\n+\/**\n+ * gst_codec_utils_av1_create_caps_from_av1c:\n+ * @av1c: (transfer none): a #GstBuffer containing a AV1CodecConfigurationRecord\n+ *\n+ * Parses the provided @av1c and returns the corresponding caps\n+ *\n+ * Since: 1.26\n+ *\n+ * Returns: (transfer full) (nullable): The parsed AV1 caps, or %NULL if there\n+ * is an error\n+ *\/\n+GstCaps *\n+gst_codec_utils_av1_create_caps_from_av1c (GstBuffer * av1c)\n+{\n+  GstMapInfo map;\n+  GstCaps *ret = NULL;\n+  const gchar *profile, *chroma_format;\n+  guint bit_depth_luma = 8;\n+  gint presentation_delay = -1;\n+\n+  g_return_val_if_fail (av1c, NULL);\n+\n+  if (!gst_buffer_map (av1c, &map, GST_MAP_READ))\n+    return NULL;\n+\n+  if (map.size < 4) {\n+    GST_WARNING (\"av1c too small\");\n+    goto done;\n+  }\n+\n+  \/*\n+   *  unsigned int (1) marker = 1;\n+   *  unsigned int (7) version = 1;\n+   *\/\n+  if (map.data[0] != 0x81) {\n+    GST_WARNING (\"Wrong av1c marker\/version: 0x%02x\", map.data[0]);\n+    goto done;\n+  }\n+\n+  \/*\n+   *  unsigned int (3) seq_profile;\n+   *  unsigned int (5) seq_level_idx_0;\n+   *\/\n+  switch (map.data[1] >> 5) {\n+    case 0:\n+      profile = \"main\";\n+      break;\n+    case 1:\n+      profile = \"high\";\n+      break;\n+    case 2:\n+      profile = \"professional\";\n+      break;\n+    default:\n+      GST_WARNING (\"Invalid seq_profile %d\", map.data[1] >> 5);\n+      goto done;\n+  }\n+\n+  \/* FIXME : Add level processing *\/\n+\n+  \/*\n+   *  unsigned int (1) seq_tier_0;\n+   *  unsigned int (1) high_bitdepth;\n+   *  unsigned int (1) twelve_bit;\n+   *  unsigned int (1) monochrome;\n+   *  unsigned int (1) chroma_subsampling_x;\n+   *  unsigned int (1) chroma_subsampling_y;\n+   *  unsigned int (2) chroma_sample_position;\n+   *\/\n+  if ((map.data[2] & 0x60) == 0x60) {\n+    bit_depth_luma = 12;\n+  } else if ((map.data[2] & 0x60) == 0x40) {\n+    bit_depth_luma = 10;\n+  }\n+\n+  switch (map.data[2] & 0x1c) {\n+    case 0x1c:\n+      chroma_format = \"4:0:0\";\n+      break;\n+    case 0x0c:\n+      chroma_format = \"4:2:0\";\n+      break;\n+    case 0x08:\n+      chroma_format = \"4:2:2\";\n+      break;\n+    case 0x00:\n+      chroma_format = \"4:4:4\";\n+      break;\n+    default:\n+      GST_WARNING (\"invalid chroma format values\");\n+      goto done;\n+  }\n+\n+  \/*\n+   *  unsigned int (3) reserved = 0;\n+   *\n+   *  unsigned int (1) initial_presentation_delay_present;\n+   *  if (initial_presentation_delay_present) {\n+   *    unsigned int (4) initial_presentation_delay_minus_one;\n+   *  } else {\n+   *    unsigned int (4) reserved = 0;\n+   *  }\n+   *\/\n+  if (map.data[3] & 0x10)\n+    presentation_delay = map.data[3] & 0xf;\n+\n+  ret = gst_caps_new_simple (\"video\/x-av1\", \"profile\", G_TYPE_STRING, profile,\n+      \"bit-depth-luma\", G_TYPE_UINT, bit_depth_luma,\n+      \"chroma-format\", G_TYPE_STRING, chroma_format, NULL);\n+\n+  if (presentation_delay != -1)\n+    gst_caps_set_simple (ret, \"presentation-delay\", G_TYPE_INT,\n+        presentation_delay, NULL);\n+\n+  \/* FIXME : Extract more information from optional configOBU *\/\n+\n+done:\n+  gst_buffer_unmap (av1c, &map);\n+\n+  return ret;\n+}\n+\n+\/**\n+ * gst_codec_utils_av1_create_av1c_from_caps:\n+ * @caps: a video\/x-av1 #GstCaps\n+ *\n+ * Creates the corresponding AV1 Codec Configuration Record\n+ *\n+ * Since: 1.26\n+ *\n+ * Returns: (transfer full) (nullable): The AV1 Codec Configuration Record, or\n+ * %NULL if there was an error.\n+ *\/\n+\n+GstBuffer *\n+gst_codec_utils_av1_create_av1c_from_caps (GstCaps * caps)\n+{\n+  gint presentation_delay = -1;\n+  GstBuffer *av1_codec_data = NULL;\n+  GstStructure *structure;\n+  GstMapInfo map;\n+  const gchar *tmp;\n+  guint tmp2;\n+\n+  g_return_val_if_fail (caps, NULL);\n+\n+  structure = gst_caps_get_structure (caps, 0);\n+  if (!structure || !gst_structure_has_name (structure, \"video\/x-av1\")) {\n+    GST_WARNING (\"Caps provided are not video\/x-av1\");\n+    return NULL;\n+  }\n+\n+  gst_structure_get_int (structure, \"presentation-delay\", &presentation_delay);\n+\n+  av1_codec_data = gst_buffer_new_allocate (NULL, 4, NULL);\n+  gst_buffer_map (av1_codec_data, &map, GST_MAP_WRITE);\n+\n+  \/*\n+   *  unsigned int (1) marker = 1;\n+   *  unsigned int (7) version = 1;\n+   *  unsigned int (3) seq_profile;\n+   *  unsigned int (5) seq_level_idx_0;\n+   *  unsigned int (1) seq_tier_0;\n+   *  unsigned int (1) high_bitdepth;\n+   *  unsigned int (1) twelve_bit;\n+   *  unsigned int (1) monochrome;\n+   *  unsigned int (1) chroma_subsampling_x;\n+   *  unsigned int (1) chroma_subsampling_y;\n+   *  unsigned int (2) chroma_sample_position;\n+   *  unsigned int (3) reserved = 0;\n+   *\n+   *  unsigned int (1) initial_presentation_delay_present;\n+   *  if (initial_presentation_delay_present) {\n+   *    unsigned int (4) initial_presentation_delay_minus_one;\n+   *  } else {\n+   *    unsigned int (4) reserved = 0;\n+   *  }\n+   *\/\n+\n+  map.data[0] = 0x81;\n+  map.data[1] = 0x00;\n+  if ((tmp = gst_structure_get_string (structure, \"profile\"))) {\n+    if (strcmp (tmp, \"main\") == 0)\n+      map.data[1] |= (0 << 5);\n+    if (strcmp (tmp, \"high\") == 0)\n+      map.data[1] |= (1 << 5);\n+    if (strcmp (tmp, \"professional\") == 0)\n+      map.data[1] |= (2 << 5);\n+  }\n+  \/* FIXME: level set to 1 *\/\n+  map.data[1] |= 0x01;\n+  \/* FIXME: tier set to 0 *\/\n+\n+  if (gst_structure_get_uint (structure, \"bit-depth-luma\", &tmp2)) {\n+    if (tmp2 == 10) {\n+      map.data[2] |= 0x40;\n+    } else if (tmp2 == 12) {\n+      map.data[2] |= 0x60;\n+    }\n+  }\n+\n+  \/* Assume 4:2:0 if nothing else is given *\/\n+  map.data[2] |= 0x0C;\n+  if ((tmp = gst_structure_get_string (structure, \"chroma-format\"))) {\n+    if (strcmp (tmp, \"4:0:0\") == 0)\n+      map.data[2] |= 0x1C;\n+    if (strcmp (tmp, \"4:2:0\") == 0)\n+      map.data[2] |= 0x0C;\n+    if (strcmp (tmp, \"4:2:2\") == 0)\n+      map.data[2] |= 0x08;\n+    if (strcmp (tmp, \"4:4:4\") == 0)\n+      map.data[2] |= 0x00;\n+  }\n+\n+  \/* FIXME: keep chroma-site unknown *\/\n+\n+  if (presentation_delay != -1) {\n+    map.data[3] = 0x10 | (MAX (0xF, presentation_delay) & 0xF);\n+  }\n+\n+  gst_buffer_unmap (av1_codec_data, &map);\n+\n+  return av1_codec_data;\n+}\n+\n+\n@@ -2559,0 +3220,250 @@\n+static GstCaps *\n+av1_caps_from_mime_codec (gchar ** subcodec)\n+{\n+  GstCaps *caps = NULL;\n+  gchar tier;\n+  guint seq_level_idx_0;\n+  guint bit_depth, seq_profile, chroma_sample_position,\n+      monochrome, chroma_subsampling_x, chroma_subsampling_y, primaries,\n+      transfer, matrix, full_range, chroma_sampling;\n+  const gchar *level_str;\n+  const gchar *tier_str;\n+  const gchar *profile_str;\n+  const gchar *chroma_format_str;\n+  gchar *colorimetry_str;\n+  GstVideoColorimetry cinfo = { 0, };\n+\n+  caps = gst_caps_new_empty_simple (\"video\/x-av1\");\n+\n+  if (!subcodec[1])\n+    goto done;\n+\n+  seq_profile = g_ascii_strtoull (subcodec[1], NULL, 10);\n+  if (seq_profile == 0) {\n+    profile_str = \"main\";\n+  } else if (seq_profile == 1) {\n+    profile_str = \"high\";\n+  } else if (seq_profile == 2) {\n+    profile_str = \"professional\";\n+  } else {\n+    GST_WARNING (\"Unknown AV1 profile %d\", seq_profile);\n+    goto done;\n+  }\n+  gst_caps_set_simple (caps, \"profile\", G_TYPE_STRING, profile_str, NULL);\n+\n+  if (subcodec[2]) {\n+    if (sscanf (subcodec[2], \"%02u%c\", &seq_level_idx_0, &tier) != 2) {\n+      GST_WARNING (\"Failed to parse level and tier from %s\", subcodec[2]);\n+      goto done;\n+    }\n+  } else {\n+    seq_level_idx_0 = 1;\n+    tier = 'M';\n+  }\n+\n+  if (tier == 'H') {\n+    tier_str = \"high\";\n+  } else if (tier == 'M') {\n+    tier_str = \"main\";\n+  } else {\n+    GST_WARNING (\"Unknown AV1 tier %c\", tier);\n+    goto done;\n+  }\n+  gst_caps_set_simple (caps, \"tier\", G_TYPE_STRING, tier_str, NULL);\n+\n+  level_str = gst_codec_utils_av1_get_level (seq_level_idx_0);\n+  if (level_str) {\n+    gst_caps_set_simple (caps, \"level\", G_TYPE_STRING, level_str, NULL);\n+  } else {\n+    GST_WARNING (\"Unknown AV1 level %d\", seq_level_idx_0);\n+    goto done;\n+  }\n+\n+  if (subcodec[3]) {\n+    bit_depth = g_ascii_strtoull (subcodec[3], NULL, 10);\n+    gst_caps_set_simple (caps, \"bit-depth-luma\", G_TYPE_UINT, bit_depth,\n+        \"bit-depth-chroma\", G_TYPE_UINT, bit_depth, NULL);\n+  } else {\n+    GST_WARNING (\"Failed to parse bit-depth from %s\", subcodec[3]);\n+    goto done;\n+  }\n+\n+  \/* Verify if all values necessary to continue are present in the subcodec *\/\n+  if (subcodec[4] && subcodec[5] && subcodec[6]\n+      && subcodec[7] && subcodec[8] && subcodec[9]) {\n+\n+    monochrome = g_ascii_strtoull (subcodec[4], NULL, 10);\n+    chroma_sampling = g_ascii_strtoull (subcodec[5], NULL, 10);\n+    chroma_subsampling_x = chroma_sampling \/ 100;\n+    chroma_subsampling_y = (chroma_sampling % 100) \/ 10;\n+    chroma_sample_position = chroma_sampling % 10;\n+    if (monochrome) {\n+      chroma_format_str = \"4:0:0\";\n+    } else if (chroma_subsampling_x == 1 && chroma_subsampling_y == 1) {\n+      chroma_format_str = \"4:2:0\";\n+    } else if (chroma_subsampling_x == 1 && chroma_subsampling_y == 0) {\n+      chroma_format_str = \"4:2:2\";\n+    } else if (chroma_subsampling_x == 0 && chroma_subsampling_y == 0) {\n+      chroma_format_str = \"4:4:4\";\n+    } else {\n+      GST_WARNING (\"Unknown chroma subsampling %d:%d:%d\", chroma_subsampling_x,\n+          chroma_subsampling_y, monochrome);\n+      goto done;\n+    }\n+\n+    primaries = g_ascii_strtoull (subcodec[6], NULL, 10);\n+    transfer = g_ascii_strtoull (subcodec[7], NULL, 10);\n+    matrix = g_ascii_strtoull (subcodec[8], NULL, 10);\n+    full_range = g_ascii_strtoull (subcodec[9], NULL, 10);\n+  } else {\n+    GST_DEBUG\n+        (\"Using default values for chroma_format, chroma_sample_position, \"\n+        \"primaries, transfer, matrix, and full_range\");\n+\n+    chroma_format_str = \"4:2:0\";\n+    chroma_sample_position = 0;\n+    primaries = 1;\n+    transfer = 1;\n+    matrix = 1;\n+    full_range = 0;\n+  }\n+\n+  gst_caps_set_simple (caps, \"chroma-format\", G_TYPE_STRING, chroma_format_str,\n+      NULL);\n+  if (chroma_sample_position == 1) {\n+    gst_caps_set_simple (caps, \"chroma-site\", G_TYPE_STRING, \"v-cosited\", NULL);\n+  } else if (chroma_sample_position == 2) {\n+    gst_caps_set_simple (caps, \"chroma-site\", G_TYPE_STRING,\n+        \"v-cosited+h-cosited\", NULL);\n+  }\n+\n+  cinfo.range =\n+      full_range ? GST_VIDEO_COLOR_RANGE_0_255 : GST_VIDEO_COLOR_RANGE_16_235;\n+  cinfo.primaries = gst_video_color_primaries_from_iso (primaries);\n+  cinfo.transfer = gst_video_transfer_function_from_iso (transfer);\n+  cinfo.matrix = gst_video_color_matrix_from_iso (matrix);\n+  colorimetry_str = gst_video_colorimetry_to_string (&cinfo);\n+  if (colorimetry_str) {\n+    gst_caps_set_simple (caps, \"colorimetry\", G_TYPE_STRING, colorimetry_str,\n+        NULL);\n+  } else {\n+    GST_WARNING (\"Failed to parse colorimetry from %u %u %u %u\", full_range,\n+        matrix, transfer, primaries);\n+  }\n+  g_free (colorimetry_str);\n+\n+done:\n+  return caps;\n+}\n+\n+\/* https:\/\/aomediacodec.github.io\/av1-isobmff\/#codecsparam *\/\n+static char *\n+av1_caps_get_mime_codec (GstCaps * caps)\n+{\n+  gchar tier_mime;\n+  guint8 seq_level_idx_0;\n+  guint bit_depth, seq_profile, chroma_sample_position,\n+      monochrome, chroma_subsampling_x, chroma_subsampling_y, primaries,\n+      transfer, matrix, full_range;\n+  GstStructure *caps_st;\n+  GString *codec_string;\n+  const gchar *level_str;\n+  const gchar *tier_str;\n+  const gchar *profile_str;\n+  const gchar *chroma_format_str;\n+  const gchar *chroma_site_str;\n+  const gchar *colorimetry_str;\n+  GstVideoColorimetry cinfo = { 0, };\n+\n+  caps_st = gst_caps_get_structure (caps, 0);\n+  codec_string = g_string_new (\"av01\");\n+\n+  tier_str = gst_structure_get_string (caps_st, \"tier\");\n+  if (g_strcmp0 (tier_str, \"main\") == 0) {\n+    tier_mime = 'M';\n+  } else if (g_strcmp0 (tier_str, \"high\") == 0) {\n+    tier_mime = 'H';\n+  } else {\n+    GST_WARNING (\"Unknown AV1 tier %s, using default 'M'\", tier_str);\n+    tier_mime = 'M';\n+  }\n+\n+  level_str = gst_structure_get_string (caps_st, \"level\");\n+  if (level_str) {\n+    seq_level_idx_0 = gst_codec_utils_av1_get_seq_level_idx (level_str);\n+  } else {\n+    seq_level_idx_0 = 1;\n+  }\n+\n+  profile_str = gst_structure_get_string (caps_st, \"profile\");\n+  if (g_strcmp0 (profile_str, \"main\") == 0) {\n+    seq_profile = 0;\n+  } else if (g_strcmp0 (profile_str, \"high\") == 0) {\n+    seq_profile = 1;\n+  } else if (g_strcmp0 (profile_str, \"professional\") == 0) {\n+    seq_profile = 2;\n+  } else {\n+    goto done;\n+  }\n+\n+  if (!gst_structure_get_uint (caps_st, \"bit-depth-luma\", &bit_depth))\n+    goto done;\n+\n+  \/* We have all information to compute a minimal mime *\/\n+  g_string_append_printf (codec_string, \".%d.%02u%c.%02u\",\n+      seq_profile, seq_level_idx_0, tier_mime, bit_depth);\n+\n+  chroma_format_str = gst_structure_get_string (caps_st, \"chroma-format\");\n+  if (g_strcmp0 (chroma_format_str, \"4:0:0\") == 0) {\n+    monochrome = 1;\n+    chroma_subsampling_x = 1;\n+    chroma_subsampling_y = 1;\n+  } else if (g_strcmp0 (chroma_format_str, \"4:2:0\") == 0) {\n+    monochrome = 0;\n+    chroma_subsampling_x = 1;\n+    chroma_subsampling_y = 1;\n+  } else if (g_strcmp0 (chroma_format_str, \"4:2:2\") == 0) {\n+    monochrome = 0;\n+    chroma_subsampling_x = 1;\n+    chroma_subsampling_y = 0;\n+  } else if (g_strcmp0 (chroma_format_str, \"4:4:4\") == 0) {\n+    monochrome = 0;\n+    chroma_subsampling_x = 0;\n+    chroma_subsampling_y = 0;\n+  } else {\n+    goto done;\n+  }\n+\n+  chroma_sample_position = 0;\n+  chroma_site_str = gst_structure_get_string (caps_st, \"chroma-site\");\n+  if (g_strcmp0 (chroma_site_str, \"v-cosited\") == 0) {\n+    chroma_sample_position = 1;\n+  } else if (g_strcmp0 (chroma_site_str, \"v-cosited+h-cosited\") == 0) {\n+    chroma_sample_position = 2;\n+  }\n+\n+  colorimetry_str = gst_structure_get_string (caps_st, \"colorimetry\");\n+  if (!colorimetry_str)\n+    goto done;\n+  if (!gst_video_colorimetry_from_string (&cinfo, colorimetry_str))\n+    goto done;\n+  full_range = cinfo.range == GST_VIDEO_COLOR_RANGE_0_255;\n+\n+  primaries = gst_video_color_primaries_to_iso (cinfo.primaries);\n+  transfer = gst_video_transfer_function_to_iso (cinfo.transfer);\n+  matrix = gst_video_color_matrix_to_iso (cinfo.matrix);\n+\n+  if (chroma_subsampling_x != 1 || chroma_subsampling_y != 1\n+      || chroma_sample_position != 0 || primaries != 1 || transfer != 1\n+      || matrix != 1 || full_range != 0) {\n+    g_string_append_printf (codec_string,\n+        \".%u.%u%u%u.%02u.%02u.%02u.%u\", monochrome, chroma_subsampling_x,\n+        chroma_subsampling_y, chroma_sample_position, primaries, transfer,\n+        matrix, full_range);\n+  }\n+\n+done:\n+  return g_string_free (codec_string, FALSE);\n+}\n+\n+\n@@ -2615,0 +3526,2 @@\n+  } else if (g_strcmp0 (media_type, \"video\/x-h266\") == 0) {\n+    mime_codec = g_strdup (\"vvc1\");\n@@ -2616,4 +3529,1 @@\n-    \/* TODO: Some browsers won't play the video unless more codec information is\n-     * available in the mime codec for av1. This is documented in\n-     * https:\/\/aomediacodec.github.io\/av1-isobmff\/#codecsparam *\/\n-    mime_codec = g_strdup (\"av01\");\n+    mime_codec = av1_caps_get_mime_codec (caps);\n@@ -2785,0 +3695,7 @@\n+    }\n+    case GST_MAKE_FOURCC ('v', 'v', 'c', '1'):\n+    case GST_MAKE_FOURCC ('v', 'v', 'i', '1'):\n+    {\n+      \/* H.266 *\/\n+      caps = gst_caps_new_empty_simple (\"video\/x-h266\");\n+      break;\n@@ -2795,0 +3712,1 @@\n+      \/* FALLTHROUGH *\/\n@@ -2816,0 +3734,1 @@\n+    {\n@@ -2817,1 +3736,1 @@\n-      caps = gst_caps_new_empty_simple (\"video\/x-av1\");\n+      caps = av1_caps_from_mime_codec (subcodec);\n@@ -2819,0 +3738,1 @@\n+    }\n@@ -2833,0 +3753,3 @@\n+    case GST_MAKE_FOURCC ('m', 'j', 'p', 'g'):\n+      caps = gst_caps_new_empty_simple (\"image\/jpeg\");\n+      break;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/codec-utils.c","additions":928,"deletions":5,"binary":false,"changes":933,"status":"modified"},{"patch":"@@ -99,0 +99,31 @@\n+\n+\/* H.266 *\/\n+\n+GST_PBUTILS_API\n+const gchar * gst_codec_utils_h266_get_profile                     (const guint8 * ptl_record,\n+                                                                    guint len);\n+\n+GST_PBUTILS_API\n+const gchar * gst_codec_utils_h266_get_tier                        (const guint8 * ptl_record,\n+                                                                    guint len);\n+\n+GST_PBUTILS_API\n+const gchar * gst_codec_utils_h266_get_level                       (const guint8 * ptl_record,\n+                                                                    guint len);\n+\n+GST_PBUTILS_API\n+guint8        gst_codec_utils_h266_get_level_idc                   (const gchar  * level);\n+\n+GST_PBUTILS_API\n+gboolean      gst_codec_utils_h266_caps_set_level_tier_and_profile (GstCaps      * caps,\n+                                                                    const guint8 * decoder_configuration,\n+                                                                    guint          len);\n+\n+\/* AV1 *\/\n+\n+GST_PBUTILS_API\n+guint8        gst_codec_utils_av1_get_seq_level_idx                (const gchar  * level);\n+\n+GST_PBUTILS_API\n+const gchar * gst_codec_utils_av1_get_level                        (guint8 seq_level_idx);\n+\n@@ -156,0 +187,7 @@\n+\/* AV1 *\/\n+GST_PBUTILS_API\n+GstCaps * gst_codec_utils_av1_create_caps_from_av1c (GstBuffer *av1c);\n+\n+GST_PBUTILS_API\n+GstBuffer * gst_codec_utils_av1_create_av1c_from_caps (GstCaps *caps);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/codec-utils.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -324,0 +324,1 @@\n+  {\"video\/x-h266\", NULL, FLAG_VIDEO, \"h266\"},\n@@ -466,0 +467,21 @@\n+static const gchar *\n+pbutils_desc_get_h266_profile_name_from_nick (const gchar * nick)\n+{\n+  static const gchar map[] =\n+      \"main-10\\000Main 10\\000\"\n+      \"multilayer-main-10\\000Multilayer Main 10\\000\"\n+      \"main-10-still-picture\\000Main 10 Still Picture\\000\"\n+      \"main-4:4:4-10\\000Main 4:4:4 10\\000\"\n+      \"multilayer-main-4:4:4-10\\000Multilayer Main 4:4:4 10\\000\"\n+      \"main-4:4:4-10-still-picture\\000Main 4:4:4 10 Still Picture\\000\"\n+      \"main-12\\000Main 12\\000\"\n+      \"main-12-intra\\000Main 12 Intra\\000\"\n+      \"main-12-still-picture\\000Main 12 Still Picture\\000\"\n+      \"main-4:4:4-12\\000Main 4:4:4 12\\000\"\n+      \"main-4:4:4-12-intra\\000Main 4:4:4 12 Intra\\000\"\n+      \"main-4:4:4-12-still-picture\\000Main 4:4:4 12 Still Picture\\000\"\n+      \"main-4:4:4-16\\000Main 4:4:4 16\\000\";\n+\n+  return pbutils_desc_get_profile_name_from_nick (map, sizeof (map), nick);\n+}\n+\n@@ -572,0 +594,2 @@\n+    gboolean lcevc = FALSE;\n+    const gchar *lcevc_str = \"\";\n@@ -590,0 +614,3 @@\n+    gst_structure_get_boolean (s, \"lcevc\", &lcevc);\n+    if (lcevc)\n+      lcevc_str = \" (LCEVC)\";\n@@ -591,2 +618,3 @@\n-      return g_strdup (ret);\n-    return g_strdup_printf (\"%s (%s Profile)\", ret, profile);\n+      return g_strdup_printf (\"%s%s\", ret, lcevc_str);\n+    else\n+      return g_strdup_printf (\"%s (%s Profile)%s\", ret, profile, lcevc_str);\n@@ -602,0 +630,9 @@\n+  } else if (strcmp (info->type, \"video\/x-h266\") == 0) {\n+    const gchar *profile = gst_structure_get_string (s, \"profile\");\n+\n+    if (profile != NULL)\n+      profile = pbutils_desc_get_h266_profile_name_from_nick (profile);\n+    if (profile != NULL)\n+      return g_strdup_printf (\"H.266 (%s Profile)\", profile);\n+\n+    return g_strdup (\"H.266\");\n@@ -891,0 +928,24 @@\n+  } else if (strcmp (info->type, \"video\/x-hap\") == 0) {\n+    const gchar *variant, *ret;\n+\n+    \/\/ https:\/\/github.com\/Vidvox\/hap\/blob\/master\/documentation\/HapVideoDRAFT.md\n+    variant = gst_structure_get_string (s, \"variant\");\n+    if (variant == NULL || strcmp (variant, \"Hap1\") == 0)\n+      ret = \"Hap\";\n+    else if (strcmp (variant, \"Hap5\") == 0)\n+      ret = \"Hap Alpha\";\n+    else if (strcmp (variant, \"HapY\") == 0)\n+      ret = \"Hap Q\";\n+    else if (strcmp (variant, \"HapM\") == 0)\n+      ret = \"Hap Q Alpha\";\n+    else if (strcmp (variant, \"HapA\") == 0)\n+      ret = \"Hap Alpha-Only\";\n+    else if (strcmp (variant, \"Hap7\") == 0)\n+      ret = \"Hap R\";\n+    else if (strcmp (variant, \"HapH\") == 0)\n+      ret = \"Hap HDR\";\n+    else {\n+      GST_WARNING (\"Unknown Hap video variant '%s'\", variant);\n+      ret = \"Hap\";\n+    }\n+    return g_strdup (ret);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/descriptions.c","additions":63,"deletions":2,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -521,0 +521,43 @@\n+\/**\n+ * gst_missing_plugin_message_set_stream_id:\n+ * @msg: A missing-plugin #GstMessage of type #GST_MESSAGE_ELEMENT\n+ * @stream_id: The stream id for which an element is missing\n+ *\n+ * Set the stream-id of the stream for which an element is missing.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_missing_plugin_message_set_stream_id (GstMessage * msg,\n+    const gchar * stream_id)\n+{\n+  const GstStructure *structure;\n+\n+  g_return_if_fail (gst_is_missing_plugin_message (msg));\n+\n+  structure = gst_message_get_structure (msg);\n+  gst_structure_set ((GstStructure *) structure, \"stream-id\", G_TYPE_STRING,\n+      stream_id, NULL);\n+}\n+\n+\/**\n+ * gst_missing_plugin_message_get_stream_id:\n+ * @msg: A missing-plugin #GstMessage of type #GST_MESSAGE_ELEMENT\n+ *\n+ * Get the stream-id of the stream for which an element is missing.\n+ *\n+ * Since: 1.26\n+ *\n+ * Returns: (nullable): The stream-id or %NULL if none is specified.\n+ *\/\n+const gchar *\n+gst_missing_plugin_message_get_stream_id (GstMessage * msg)\n+{\n+  const GstStructure *structure;\n+\n+  g_return_val_if_fail (gst_is_missing_plugin_message (msg), NULL);\n+\n+  structure = gst_message_get_structure (msg);\n+  return gst_structure_get_string (structure, \"stream-id\");\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/missing-plugins.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -52,0 +52,7 @@\n+GST_PBUTILS_API\n+void gst_missing_plugin_message_set_stream_id(GstMessage *msg,\n+                                              const gchar *stream_id);\n+\n+GST_PBUTILS_API\n+const gchar *gst_missing_plugin_message_get_stream_id (GstMessage *msg);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/missing-plugins.h","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -101,5 +101,0 @@\n-\n-  gint stream_count;\n-\n-  gchar *cachefile;\n-  gpointer from_cache;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/pbutils-private.h","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -972,0 +972,13 @@\n+    case GST_MAKE_FOURCC ('L', 'A', 'G', 'S'):\n+      caps = gst_caps_new_empty_simple (\"video\/x-lagarith\");\n+      if (codec_name)\n+        *codec_name = g_strdup (\"Lagarith lossless video codec\");\n+      break;\n+\n+    case GST_MAKE_FOURCC ('M', '1', '0', '1'):\n+    case GST_MAKE_FOURCC ('M', '1', '0', '2'):\n+      caps = gst_caps_new_empty_simple (\"video\/x-m101\");\n+      if (codec_name)\n+        *codec_name = g_strdup (\"Matrox uncompressed SD video codec\");\n+      break;\n+\n@@ -1222,0 +1235,1 @@\n+      \/* FALLTHROUGH *\/\n@@ -1224,0 +1238,1 @@\n+      \/* FALLTHROUGH *\/\n@@ -1227,0 +1242,1 @@\n+      \/* FALLTHROUGH *\/\n@@ -1230,0 +1246,1 @@\n+      \/* FALLTHROUGH *\/\n@@ -1232,0 +1249,1 @@\n+      \/* FALLTHROUGH *\/\n@@ -1234,0 +1252,1 @@\n+      \/* FALLTHROUGH *\/\n@@ -1326,2 +1345,3 @@\n-        if (strf->channels != 0 && strf->rate != 0 && strf->blockalign != 0) {\n-          int spb = ((strf->blockalign - strf->channels * 7) \/ 2) * 2;\n+        if (strf->channels != 0 && strf->rate != 0 && strf->blockalign != 0 &&\n+            (strf->blockalign \/ strf->channels) >= 7) {\n+          int spb = ((strf->blockalign \/ strf->channels) - 7) * 2 + 2;\n@@ -1448,2 +1468,3 @@\n-        if (strf->channels != 0 && strf->rate != 0 && strf->blockalign != 0) {\n-          int spb = ((strf->blockalign - strf->channels * 4) \/ 2) * 2;\n+        if (strf->channels != 0 && strf->rate != 0 && strf->blockalign != 0 &&\n+            (strf->blockalign \/ strf->channels) >= 4) {\n+          int spb = ((strf->blockalign \/ strf->channels) - 4) * 2 + 1;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/riff\/riff-media.c","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -642,1 +642,1 @@\n-      \/* Fall-through *\/\n+      \/* FALLTHROUGH *\/\n@@ -699,1 +699,0 @@\n-      \/* fall-through *\/\n@@ -701,0 +700,1 @@\n+      \/* FALLTHROUGH *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/tag\/gsttagdemux.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -283,0 +283,109 @@\n+gint\n+__exif_tag_capturing_light_source_to_exif_value (const gchar * str)\n+{\n+  if (str == NULL) {\n+    GST_WARNING (\"Invalid light source: NULL\");\n+    return -1;\n+  }\n+\n+  if (strcmp (str, \"unknown\") == 0)\n+    return 0;\n+  else if (strcmp (str, \"daylight\") == 0)\n+    return 1;\n+  else if (strcmp (str, \"flourescent\") == 0)\n+    return 2;\n+  else if (strcmp (str, \"tungsten\") == 0)\n+    return 3;\n+  else if (strcmp (str, \"flash\") == 0)\n+    return 4;\n+  else if (strcmp (str, \"fine-weather\") == 0)\n+    return 9;\n+  else if (strcmp (str, \"cloudy-weather\") == 0)\n+    return 10;\n+  else if (strcmp (str, \"shade\") == 0)\n+    return 11;\n+  else if (strcmp (str, \"daylight-fluorescent\") == 0)\n+    return 12;\n+  else if (strcmp (str, \"day-white-fluorescent\") == 0)\n+    return 13;\n+  else if (strcmp (str, \"cool-white-fluorescent\") == 0)\n+    return 14;\n+  else if (strcmp (str, \"white-fluorescent\") == 0)\n+    return 15;\n+  else if (strcmp (str, \"warm-white-fluorescent\") == 0)\n+    return 16;\n+  else if (strcmp (str, \"standard-light-A\") == 0)\n+    return 17;\n+  else if (strcmp (str, \"standard-light-B\") == 0)\n+    return 18;\n+  else if (strcmp (str, \"standard-light-C\") == 0)\n+    return 19;\n+  else if (strcmp (str, \"D55\") == 0)\n+    return 20;\n+  else if (strcmp (str, \"D65\") == 0)\n+    return 21;\n+  else if (strcmp (str, \"D75\") == 0)\n+    return 22;\n+  else if (strcmp (str, \"D50\") == 0)\n+    return 23;\n+  else if (strcmp (str, \"iso-studio-tungsten\") == 0)\n+    return 24;\n+  else if (strcmp (str, \"other\") == 0)\n+    return 255;\n+\n+  GST_WARNING (\"Invalid light source: %s\", str);\n+  return -1;\n+}\n+\n+const gchar *\n+__exif_tag_capturing_light_source_from_exif_value (gint value)\n+{\n+  switch (value) {\n+    case 0:\n+      return \"unknown\";\n+    case 1:\n+      return \"daylight\";\n+    case 2:\n+      return \"flourescent\";\n+    case 4:\n+      return \"flash\";\n+    case 9:\n+      return \"fine-weather\";\n+    case 10:\n+      return \"cloudy-weather\";\n+    case 11:\n+      return \"shade\";\n+    case 12:\n+      return \"daylight-fluorescent\";\n+    case 13:\n+      return \"day-white-fluorescent\";\n+    case 14:\n+      return \"cool-white-fluorescent\";\n+    case 15:\n+      return \"white-fluorescent\";\n+    case 16:\n+      return \"warm-white-fluorescent\";\n+    case 17:\n+      return \"standard-light-A\";\n+    case 18:\n+      return \"standard-light-B\";\n+    case 19:\n+      return \"standard-light-C\";\n+    case 20:\n+      return \"D55\";\n+    case 21:\n+      return \"D65\";\n+    case 22:\n+      return \"D75\";\n+    case 23:\n+      return \"D50\";\n+    case 24:\n+      return \"iso-studio-tungsten\";\n+    case 255:\n+      return \"other\";\n+    default:\n+      GST_WARNING (\"Invalid light source type: %d\", value);\n+      return NULL;\n+  }\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/tag\/gsttageditingprivate.c","additions":109,"deletions":0,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -56,0 +56,3 @@\n+int __exif_tag_capturing_light_source_to_exif_value (const gchar * str);\n+const gchar * __exif_tag_capturing_light_source_from_exif_value (gint value);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/tag\/gsttageditingprivate.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -528,0 +528,1 @@\n+        \/* FALLTHROUGH *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/tag\/id3v2.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -301,0 +301,33 @@\n+\/**\n+ * GST_TAG_CAPTURING_LIGHT_SOURCE:\n+ *\n+ * Light source used when capturing an image. (string)\n+ *\n+ * The allowed values are:\n+ *   \"unknown\"\n+ *   \"daylight\"\n+ *   \"fluorescent\"\n+ *   \"tungsten\"\n+ *   \"flash\"\n+ *   \"fine-weather\"\n+ *   \"cloudy-weather\"\n+ *   \"shade\"\n+ *   \"daylight-fluorescent\"\n+ *   \"day-white-fluorescent\"\n+ *   \"cool-white-fluorescent\"\n+ *   \"white-fluorescent\"\n+ *   \"warm-white-fluorescent\"\n+ *   \"standard-light-A\"\n+ *   \"standard-light-B\"\n+ *   \"standard-light-C\"\n+ *   \"D55\"\n+ *   \"D65\"\n+ *   \"D75\"\n+ *   \"D50\"\n+ *   \"iso-studio-tungsten\"\n+ *   \"other\"\n+ *\n+ * Since: 1.26\n+ *\/\n+#define GST_TAG_CAPTURING_LIGHT_SOURCE        \"capturing-light-source\"\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/tag\/tag.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -168,0 +168,5 @@\n+  gst_tag_register_static (GST_TAG_CAPTURING_LIGHT_SOURCE, GST_TAG_FLAG_META,\n+      G_TYPE_STRING, _(\"capturing light source\"),\n+      _(\"The light source indicates the kind of light when capturing an\"\n+          \"image\"), NULL);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/tag\/tags.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    GError ** err)\n+    gboolean is_d3d12, GError ** err)\n@@ -151,0 +151,7 @@\n+  const gchar *d3d_conv_name = \"d3d11convert\";\n+  const gchar *d3d_download_name = \"d3d11download\";\n+\n+  if (is_d3d12) {\n+    d3d_conv_name = \"d3d12convert\";\n+    d3d_download_name = \"d3d12download\";\n+  }\n@@ -153,2 +160,2 @@\n-      !create_element (\"d3d11convert\", &d3d11_convert, &error) ||\n-      !create_element (\"d3d11download\", &d3d11_download, &error) ||\n+      !create_element (d3d_conv_name, &d3d11_convert, &error) ||\n+      !create_element (d3d_download_name, &d3d11_download, &error) ||\n@@ -214,0 +221,19 @@\n+static GstPadProbeReturn\n+strip_video_crop_meta (GstPad * pad, GstPadProbeInfo * info, gpointer user_data)\n+{\n+  GstBuffer *buf = gst_pad_probe_info_get_buffer (info);\n+  GstVideoCropMeta *cmeta = gst_buffer_get_video_crop_meta (buf);\n+\n+  if (cmeta != NULL) {\n+    \/* Make the buffer writable before stripping the meta and\n+     * putting the possibly-replaced buffer back into\n+     * the pad probe data *\/\n+    GST_DEBUG (\"Removing video crop meta from input buffer\");\n+    buf = gst_buffer_make_writable (buf);\n+    gst_buffer_remove_meta (buf, GST_META_CAST (cmeta));\n+    GST_PAD_PROBE_INFO_DATA (info) = buf;\n+  }\n+\n+  return GST_PAD_PROBE_OK;\n+}\n+\n@@ -227,3 +253,10 @@\n-  if (features && gst_caps_features_contains (features, \"memory:D3D11Memory\")) {\n-    return build_convert_frame_pipeline_d3d11 (src_element, sink_element,\n-        from_caps, to_caps, err);\n+  if (features && !gst_caps_features_is_any (features)) {\n+    gboolean is_d3d11 =\n+        gst_caps_features_contains (features, \"memory:D3D11Memory\");\n+    gboolean is_d3d12 =\n+        gst_caps_features_contains (features, \"memory:D3D12Memory\");\n+\n+    if (is_d3d11 || is_d3d12) {\n+      return build_convert_frame_pipeline_d3d11 (src_element, sink_element,\n+          from_caps, to_caps, is_d3d12, err);\n+    }\n@@ -280,2 +313,2 @@\n-    g_object_set (vcrop, \"right\", GST_VIDEO_INFO_WIDTH (&info) - cmeta->width,\n-        NULL);\n+    g_object_set (vcrop, \"right\",\n+        GST_VIDEO_INFO_WIDTH (&info) - (cmeta->x + cmeta->width), NULL);\n@@ -283,1 +316,12 @@\n-        GST_VIDEO_INFO_HEIGHT (&info) - cmeta->height, NULL);\n+        GST_VIDEO_INFO_HEIGHT (&info) - (cmeta->y + cmeta->height), NULL);\n+\n+    \/* Because we are asking videocrop to apply the cropping explicitly,\n+     * we need to give it a buffer without crop meta, or the crop amounts end up\n+     * getting applied twice. Add a probe to strip the meta and use videocrop's\n+     * properties *\/\n+    GstPad *sink = gst_element_get_static_pad (vcrop, \"sink\");\n+    g_assert (sink != NULL);\n+    gst_pad_add_probe (sink, GST_PAD_PROBE_TYPE_BUFFER,\n+        strip_video_crop_meta, NULL, NULL);\n+    gst_object_unref (sink);\n+\n@@ -286,1 +330,0 @@\n-  }\n@@ -288,2 +331,1 @@\n-  \/* FIXME: linking is still way too expensive, profile this properly *\/\n-  if (vcrop) {\n+    \/* FIXME: linking is still way too expensive, profile this properly *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/convertframe.c","additions":54,"deletions":12,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -127,0 +127,62 @@\n+static gboolean\n+gst_video_meta_api_params_aggregator (GstStructure ** aggregated_params,\n+    const GstStructure * params0, const GstStructure * params1)\n+{\n+  GstVideoAlignment align0;\n+  GstVideoAlignment align1;\n+  GstVideoAlignment aggregated_align;\n+\n+  gst_video_alignment_reset (&align0);\n+  gst_video_alignment_reset (&align1);\n+  gst_video_alignment_reset (&aggregated_align);\n+\n+  if (params0 && (!gst_structure_has_name (params0, \"video-meta\") ||\n+          !gst_buffer_pool_config_get_video_alignment (params0, &align0))) {\n+    GST_WARNING (\"Invalid params\");\n+    params0 = NULL;\n+  }\n+\n+  if (params1 && (!gst_structure_has_name (params1, \"video-meta\") ||\n+          !gst_buffer_pool_config_get_video_alignment (params1, &align1))) {\n+    GST_WARNING (\"Invalid params\");\n+    params1 = NULL;\n+  }\n+\n+  if (!params0 && !params1) {\n+    *aggregated_params = NULL;\n+    return TRUE;\n+  }\n+\n+  if (params0 && !params1) {\n+    *aggregated_params = gst_structure_copy (params0);\n+    return TRUE;\n+  }\n+\n+  if (!params0 && params1) {\n+    *aggregated_params = gst_structure_copy (params1);\n+    return TRUE;\n+  }\n+\n+  aggregated_align.padding_top = MAX (align0.padding_top, align1.padding_top);\n+\n+  aggregated_align.padding_bottom =\n+      MAX (align0.padding_bottom, align1.padding_bottom);\n+\n+  aggregated_align.padding_left =\n+      MAX (align0.padding_left, align1.padding_left);\n+\n+  aggregated_align.padding_right =\n+      MAX (align0.padding_right, align1.padding_right);\n+\n+  for (int n = 0; n < GST_VIDEO_MAX_PLANES; ++n)\n+    aggregated_align.stride_align[n] =\n+        align0.stride_align[n] | align1.stride_align[n];\n+\n+  *aggregated_params = gst_structure_new_empty (\"video-meta\");\n+\n+  gst_buffer_pool_config_set_video_alignment (*aggregated_params,\n+      &aggregated_align);\n+\n+  return TRUE;\n+}\n+\n@@ -139,0 +201,3 @@\n+\n+    gst_meta_api_type_set_params_aggregator (_type,\n+        gst_video_meta_api_params_aggregator);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/gstvideometa.c","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -75,2 +75,6 @@\n- * The padding fields have the same semantic as #GstVideoMeta.alignment\n- * and so represent the paddings requested on produced video buffers.\n+ * - stride-align0 (uint): stride align requirements for plane 0\n+ * - stride-align1 (uint): stride align requirements for plane 1\n+ * - stride-align2 (uint): stride align requirements for plane 2\n+ * - stride-align3 (uint): stride align requirements for plane 3\n+ * The padding and stride-align fields have the same semantic as #GstVideoMeta.alignment\n+ * and so represent the paddings and stride-align requested on produced video buffers.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/gstvideometa.h","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-gst_buffer_pool_config_get_video_alignment (GstStructure * config,\n+gst_buffer_pool_config_get_video_alignment (const GstStructure * config,\n@@ -283,1 +283,1 @@\n-gst_video_buffer_pool_new ()\n+gst_video_buffer_pool_new (void)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/gstvideopool.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-gboolean         gst_buffer_pool_config_get_video_alignment  (GstStructure *config, GstVideoAlignment *align);\n+gboolean         gst_buffer_pool_config_get_video_alignment  (const GstStructure *config, GstVideoAlignment *align);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/gstvideopool.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,2 +101,1 @@\n-    if (tc->config.fps_n != 30000 && tc->config.fps_n != 60000 &&\n-        tc->config.fps_n != 24000 && tc->config.fps_n != 120000)\n+    if (tc->config.fps_n % 30000 != 0 && tc->config.fps_n != 24000)\n@@ -109,2 +108,2 @@\n-  \/* We support only 30000\/1001, 60000\/1001, and 120000\/1001 (see above) as\n-   * drop-frame framerates. 24000\/1001 is *not* a drop-frame framerate! *\/\n+  \/* We support only multiples of 30000\/1001 (see above) as drop-frame\n+   * framerates. 24000\/1001 is *not* a drop-frame framerate! *\/\n@@ -119,1 +118,1 @@\n-   * and the first eight timecodes for 120000\/1001. *\/\n+   * and the first eight timecodes for 120000\/1001, etc. *\/\n@@ -186,1 +185,3 @@\n-  gdouble add_us;\n+  guint64 nseconds;\n+  gdouble seconds;\n+  gint hours, minutes;\n@@ -201,2 +202,10 @@\n-  gst_util_fraction_to_double (tc->frames * tc->config.fps_d, tc->config.fps_n,\n-      &add_us);\n+  nseconds = gst_video_time_code_nsec_since_daily_jam (tc);\n+\n+  hours = nseconds \/ GST_SECOND \/ 60 \/ 60;\n+  nseconds -= hours * GST_SECOND * 60 * 60;\n+\n+  minutes = nseconds \/ GST_SECOND \/ 60;\n+  nseconds -= minutes * GST_SECOND * 60;\n+\n+  seconds = nseconds \/ 1000000000.0;\n+\n@@ -205,1 +214,1 @@\n-    gdouble sub_us;\n+    gdouble sub_s;\n@@ -208,2 +217,2 @@\n-        &sub_us);\n-    add_us -= sub_us;\n+        &sub_s);\n+    seconds -= sub_s;\n@@ -212,1 +221,1 @@\n-  ret2 = g_date_time_add_seconds (ret, add_us + tc->seconds);\n+  ret2 = g_date_time_add_seconds (ret, seconds);\n@@ -214,1 +223,1 @@\n-  ret = g_date_time_add_minutes (ret2, tc->minutes);\n+  ret = g_date_time_add_minutes (ret2, minutes);\n@@ -216,1 +225,1 @@\n-  ret2 = g_date_time_add_hours (ret, tc->hours);\n+  ret2 = g_date_time_add_hours (ret, hours);\n@@ -378,2 +387,1 @@\n-    \/* these need to be truncated to integer: side effect, code looks cleaner\n-     * *\/\n+    \/* these need to be truncated to integer: side effect, code looks cleaner *\/\n@@ -382,2 +390,2 @@\n-    \/* for 30000\/1001 we drop the first 2 frames per minute, for 60000\/1001 we\n-     * drop the first 4 : so we use this number *\/\n+    \/* for 30000\/1001 we drop the first 2 timecodes per minute, for 60000\/1001\n+     * the first 4, etc. except for every 10th minute *\/\n@@ -386,8 +394,3 @@\n-    if (tc->config.fps_n == 30000) {\n-      dropframe_multiplier = 2;\n-    } else if (tc->config.fps_n == 60000) {\n-      dropframe_multiplier = 4;\n-    } else {\n-      \/* already checked by gst_video_time_code_is_valid() *\/\n-      g_assert_not_reached ();\n-    }\n+    \/* already checked by gst_video_time_code_is_valid() *\/\n+    g_assert (tc->config.fps_n % 30000 == 0);\n+    dropframe_multiplier = 2 * (tc->config.fps_n \/ 30000);\n@@ -464,2 +467,2 @@\n-    \/* for 30000\/1001 we drop the first 2 frames per minute, for 60000\/1001 we\n-     * drop the first 4 : so we use this number *\/\n+    \/* for 30000\/1001 we drop the first 2 timecodes per minute, for 60000\/1001\n+     * the first 4, etc. except for every 10th minute *\/\n@@ -468,8 +471,3 @@\n-    if (tc->config.fps_n == 30000) {\n-      dropframe_multiplier = 2;\n-    } else if (tc->config.fps_n == 60000) {\n-      dropframe_multiplier = 4;\n-    } else {\n-      \/* already checked by gst_video_time_code_is_valid() *\/\n-      g_assert_not_reached ();\n-    }\n+    \/* already checked by gst_video_time_code_is_valid() *\/\n+    g_assert (tc->config.fps_n % 30000 == 0);\n+    dropframe_multiplier = 2 * (tc->config.fps_n \/ 30000);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/gstvideotimecode.c","additions":34,"deletions":36,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -96,1 +96,3 @@\n-  GstNavigationInterface *iface = GST_NAVIGATION_GET_INTERFACE (navigation);\n+  GstNavigationInterface *iface;\n+\n+  g_return_if_fail (GST_IS_NAVIGATION (navigation));\n@@ -98,0 +100,1 @@\n+  iface = GST_NAVIGATION_GET_INTERFACE (navigation);\n@@ -119,0 +122,1 @@\n+  g_return_if_fail (GST_IS_NAVIGATION (navigation));\n@@ -131,1 +135,1 @@\n- * \"mouse-button-press\", \"mouse-button-release\" and \"mouse-move\".\n+ * \"mouse-button-press\", \"mouse-button-release\", \"mouse-move\" and \"mouse-double-click\".\n@@ -147,0 +151,1 @@\n+  g_return_if_fail (GST_IS_NAVIGATION (navigation));\n@@ -149,1 +154,2 @@\n-      g_strcmp0 (event, \"mouse-move\") == 0);\n+      g_strcmp0 (event, \"mouse-move\") == 0 ||\n+      g_strcmp0 (event, \"mouse-double-click\") == 0);\n@@ -176,0 +182,2 @@\n+  g_return_if_fail (GST_IS_NAVIGATION (navigation));\n+\n@@ -196,0 +204,2 @@\n+  g_return_if_fail (GST_IS_NAVIGATION (navigation));\n+\n@@ -212,1 +222,1 @@\n-  GstNavigationInterface *iface = GST_NAVIGATION_GET_INTERFACE (navigation);\n+  GstNavigationInterface *iface;\n@@ -214,0 +224,1 @@\n+  g_return_if_fail (GST_IS_NAVIGATION (navigation));\n@@ -216,0 +227,1 @@\n+  iface = GST_NAVIGATION_GET_INTERFACE (navigation);\n@@ -799,0 +811,2 @@\n+  else if (g_str_equal (e_type, \"mouse-double-click\"))\n+    return GST_NAVIGATION_EVENT_MOUSE_DOUBLE_CLICK;\n@@ -870,0 +884,25 @@\n+\/**\n+ * gst_navigation_event_new_mouse_double_click:\n+ * @button: The number of the pressed mouse button.\n+ * @x: The x coordinate of the mouse cursor.\n+ * @y: The y coordinate of the mouse cursor.\n+ * @state: a bit-mask representing the state of the modifier keys (e.g. Control,\n+ * Shift and Alt).\n+ *\n+ * Create a new navigation event for the given key mouse double click.\n+ *\n+ * Returns: (transfer full): a new #GstEvent\n+ *\n+ * Since: 1.26\n+ *\/\n+GstEvent *\n+gst_navigation_event_new_mouse_double_click (gint button, gdouble x, gdouble y,\n+    GstNavigationModifierType state)\n+{\n+  return gst_event_new_navigation (gst_structure_new (GST_NAVIGATION_EVENT_NAME,\n+          \"event\", G_TYPE_STRING, \"mouse-double-click\",\n+          \"button\", G_TYPE_INT, button, \"pointer_x\", G_TYPE_DOUBLE, x,\n+          \"pointer_y\", G_TYPE_DOUBLE, y,\n+          \"state\", GST_TYPE_NAVIGATION_MODIFIER_TYPE, state, NULL));\n+}\n+\n@@ -1155,1 +1194,2 @@\n-      e_type == GST_NAVIGATION_EVENT_MOUSE_BUTTON_RELEASE, FALSE);\n+      e_type == GST_NAVIGATION_EVENT_MOUSE_BUTTON_RELEASE ||\n+      e_type == GST_NAVIGATION_EVENT_MOUSE_DOUBLE_CLICK, FALSE);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/navigation.c","additions":45,"deletions":5,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -374,0 +374,3 @@\n+ * @GST_NAVIGATION_EVENT_MOUSE_DOUBLE_CLICK: A mouse button double click event. Use\n+ * gst_navigation_event_parse_mouse_button_event() to extract the details from the\n+ * event. (Since: 1.26)\n@@ -450,0 +453,11 @@\n+\n+  \/**\n+   * GST_NAVIGATION_EVENT_MOUSE_DOUBLE_CLICK:\n+   *\n+   * A mouse button double click event.\n+   * Use gst_navigation_event_parse_mouse_button_event() to extract the details\n+   * from the event.\n+   *\n+   * Since: 1.26\n+   *\/\n+  GST_NAVIGATION_EVENT_MOUSE_DOUBLE_CLICK         = 13,\n@@ -468,0 +482,5 @@\n+GST_VIDEO_API\n+GstEvent*       gst_navigation_event_new_mouse_double_click   (gint button, gdouble x,\n+                                                               gdouble y,\n+                                                               GstNavigationModifierType state) G_GNUC_MALLOC;\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/navigation.h","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @GST_VIDEO_CHROMA_SITE_ALT_LINE: choma samples are sited on alternate lines\n+ * @GST_VIDEO_CHROMA_SITE_ALT_LINE: chroma samples are sited on alternate lines\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-chroma.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,2 +139,2 @@\n-  GstQueueArray *tasks;\n-  GstQueueArray *work_items;\n+  GstVecDeque *tasks;\n+  GstVecDeque *work_items;\n@@ -154,1 +154,1 @@\n-  work_item = gst_queue_array_pop_head (runner->work_items);\n+  work_item = gst_vec_deque_pop_head (runner->work_items);\n@@ -173,2 +173,2 @@\n-    if (!(joined = gst_queue_array_is_empty (self->tasks))) {\n-      gpointer task = gst_queue_array_pop_head (self->tasks);\n+    if (!(joined = gst_vec_deque_is_empty (self->tasks))) {\n+      gpointer task = gst_vec_deque_pop_head (self->tasks);\n@@ -188,2 +188,2 @@\n-  gst_queue_array_free (self->work_items);\n-  gst_queue_array_free (self->tasks);\n+  gst_vec_deque_free (self->work_items);\n+  gst_vec_deque_free (self->tasks);\n@@ -226,2 +226,2 @@\n-  self->tasks = gst_queue_array_new (n_threads);\n-  self->work_items = gst_queue_array_new (n_threads);\n+  self->tasks = gst_vec_deque_new (n_threads);\n+  self->work_items = gst_vec_deque_new (n_threads);\n@@ -270,1 +270,1 @@\n-      gst_queue_array_push_tail (self->work_items, work_item);\n+      gst_vec_deque_push_tail (self->work_items, work_item);\n@@ -278,1 +278,1 @@\n-      gst_queue_array_push_tail (self->tasks, task);\n+      gst_vec_deque_push_tail (self->tasks, task);\n@@ -2305,20 +2305,2 @@\n-\/**\n- * gst_video_converter_new_with_pool: (skip)\n- * @in_info: a #GstVideoInfo\n- * @out_info: a #GstVideoInfo\n- * @config: (transfer full): a #GstStructure with configuration options\n- * @pool: (nullable): a #GstTaskPool to spawn threads from\n- *\n- * Create a new converter object to convert between @in_info and @out_info\n- * with @config.\n- *\n- * The optional @pool can be used to spawn threads, this is useful when\n- * creating new converters rapidly, for example when updating cropping.\n- *\n- * Returns (nullable): a #GstVideoConverter or %NULL if conversion is not possible.\n- *\n- * Since: 1.20\n- *\/\n-GstVideoConverter *\n-gst_video_converter_new_with_pool (const GstVideoInfo * in_info,\n-    const GstVideoInfo * out_info, GstStructure * config, GstTaskPool * pool)\n+static void\n+gst_video_converter_init_from_config (GstVideoConverter * convert)\n@@ -2326,2 +2308,0 @@\n-  GstVideoConverter *convert;\n-  GstLineCache *prev;\n@@ -2329,0 +2309,2 @@\n+  GstVideoInfo *in_info = &convert->in_info;\n+  GstVideoInfo *out_info = &convert->out_info;\n@@ -2330,13 +2312,0 @@\n-  gint n_threads, i;\n-  gboolean async_tasks;\n-\n-  g_return_val_if_fail (in_info != NULL, NULL);\n-  g_return_val_if_fail (out_info != NULL, NULL);\n-  \/* we won't ever do framerate conversion *\/\n-  g_return_val_if_fail (in_info->fps_n == out_info->fps_n, NULL);\n-  g_return_val_if_fail (in_info->fps_d == out_info->fps_d, NULL);\n-  \/* we won't ever do deinterlace *\/\n-  g_return_val_if_fail (in_info->interlace_mode == out_info->interlace_mode,\n-      NULL);\n-\n-  convert = g_new0 (GstVideoConverter, 1);\n@@ -2347,13 +2316,0 @@\n-  convert->in_info = *in_info;\n-  convert->out_info = *out_info;\n-\n-  \/* default config *\/\n-  convert->config = gst_structure_new_empty (\"GstVideoConverter\");\n-  if (config)\n-    gst_video_converter_set_config (convert, config);\n-\n-  convert->in_maxwidth = GST_VIDEO_INFO_WIDTH (in_info);\n-  convert->in_maxheight = GST_VIDEO_INFO_FIELD_HEIGHT (in_info);\n-  convert->out_maxwidth = GST_VIDEO_INFO_WIDTH (out_info);\n-  convert->out_maxheight = GST_VIDEO_INFO_FIELD_HEIGHT (out_info);\n-\n@@ -2451,0 +2407,52 @@\n+}\n+\n+\/**\n+ * gst_video_converter_new_with_pool: (skip)\n+ * @in_info: a #GstVideoInfo\n+ * @out_info: a #GstVideoInfo\n+ * @config: (transfer full): a #GstStructure with configuration options\n+ * @pool: (nullable): a #GstTaskPool to spawn threads from\n+ *\n+ * Create a new converter object to convert between @in_info and @out_info\n+ * with @config.\n+ *\n+ * The optional @pool can be used to spawn threads, this is useful when\n+ * creating new converters rapidly, for example when updating cropping.\n+ *\n+ * Returns (nullable): a #GstVideoConverter or %NULL if conversion is not possible.\n+ *\n+ * Since: 1.20\n+ *\/\n+GstVideoConverter *\n+gst_video_converter_new_with_pool (const GstVideoInfo * in_info,\n+    const GstVideoInfo * out_info, GstStructure * config, GstTaskPool * pool)\n+{\n+  GstVideoConverter *convert;\n+  GstLineCache *prev;\n+  gint n_threads, i;\n+  gboolean async_tasks;\n+\n+  g_return_val_if_fail (in_info != NULL, NULL);\n+  g_return_val_if_fail (out_info != NULL, NULL);\n+  \/* we won't ever do framerate conversion *\/\n+  g_return_val_if_fail (in_info->fps_n == out_info->fps_n, NULL);\n+  g_return_val_if_fail (in_info->fps_d == out_info->fps_d, NULL);\n+  \/* we won't ever do deinterlace *\/\n+  g_return_val_if_fail (in_info->interlace_mode == out_info->interlace_mode,\n+      NULL);\n+\n+  convert = g_new0 (GstVideoConverter, 1);\n+\n+  convert->in_info = *in_info;\n+  convert->out_info = *out_info;\n+\n+  convert->in_maxwidth = GST_VIDEO_INFO_WIDTH (in_info);\n+  convert->in_maxheight = GST_VIDEO_INFO_FIELD_HEIGHT (in_info);\n+  convert->out_maxwidth = GST_VIDEO_INFO_WIDTH (out_info);\n+  convert->out_maxheight = GST_VIDEO_INFO_FIELD_HEIGHT (out_info);\n+\n+  convert->config = gst_structure_new_static_str_empty (\"GstVideoConverter\");\n+  if (config)\n+    gst_video_converter_set_config (convert, config);\n+  else\n+    gst_video_converter_init_from_config (convert);\n@@ -2694,1 +2702,2 @@\n-copy_config (GQuark field_id, const GValue * value, gpointer user_data)\n+copy_config (const GstIdStr * fieldname, const GValue * value,\n+    gpointer user_data)\n@@ -2698,1 +2707,1 @@\n-  gst_structure_id_set_value (convert->config, field_id, value);\n+  gst_structure_id_str_set_value (convert->config, fieldname, value);\n@@ -2728,1 +2737,1 @@\n-  gst_structure_foreach (config, copy_config, convert);\n+  gst_structure_foreach_id_str (config, copy_config, convert);\n@@ -2731,0 +2740,2 @@\n+  gst_video_converter_init_from_config (convert);\n+\n@@ -3786,0 +3797,151 @@\n+static void\n+convert_I420_10_v210_task (FConvertTask * task)\n+{\n+  gint i, j;\n+  gint l1, l2;\n+  const guint16 *s_y1, *s_y2, *s_u, *s_v;\n+  guint8 *d1, *d2;\n+  guint32 a0, a1, a2, a3;\n+  guint16 y0_1, y1_1, y2_1, y3_1, y4_1, y5_1;\n+  guint16 u0_1, u2_1, u4_1;\n+  guint16 v0_1, v2_1, v4_1;\n+  guint16 y0_2, y1_2, y2_2, y3_2, y4_2, y5_2;\n+  guint16 u0_2, u2_2, u4_2;\n+  guint16 v0_2, v2_2, v4_2;\n+\n+  for (i = task->height_0; i < task->height_1; i += 2) {\n+    GET_LINE_OFFSETS (task->interlaced, i, l1, l2);\n+\n+    s_y1 = FRAME_GET_Y_LINE (task->src, l1);\n+    s_y2 = FRAME_GET_Y_LINE (task->src, l2);\n+    s_u = FRAME_GET_U_LINE (task->src, i >> 1);\n+    s_v = FRAME_GET_V_LINE (task->src, i >> 1);\n+\n+    d1 = FRAME_GET_LINE (task->dest, l1);\n+    d2 = FRAME_GET_LINE (task->dest, l2);\n+\n+    for (j = 0; j < task->width; j += 6) {\n+      y1_1 = y2_1 = y3_1 = y4_1 = y5_1 = 0;\n+      u2_1 = u4_1 = v2_1 = v4_1 = 0;\n+      y1_2 = y2_2 = y3_2 = y4_2 = y5_2 = 0;\n+      u2_2 = u4_2 = v2_2 = v4_2 = 0;\n+\n+      y0_1 = s_y1[j];\n+      y0_2 = s_y2[j];\n+\n+      u0_1 = u0_2 = s_u[j \/ 2];\n+      v0_1 = v0_2 = s_v[j \/ 2];\n+\n+      if (j < task->width - 1) {\n+        y1_1 = s_y1[j + 1];\n+        y1_2 = s_y2[j + 1];\n+      }\n+\n+      if (j < task->width - 2) {\n+        y2_1 = s_y1[j + 2];\n+        y2_2 = s_y2[j + 2];\n+\n+        u2_1 = u2_2 = s_u[j \/ 2 + 1];\n+        v2_1 = v2_2 = s_v[j \/ 2 + 1];\n+      }\n+\n+      if (j < task->width - 3) {\n+        y3_1 = s_y1[j + 3];\n+        y3_2 = s_y2[j + 3];\n+      }\n+\n+      if (j < task->width - 4) {\n+        y4_1 = s_y1[j + 4];\n+        y4_2 = s_y2[j + 4];\n+\n+        u4_1 = u4_2 = s_u[j \/ 2 + 2];\n+        v4_1 = v4_2 = s_v[j \/ 2 + 2];\n+      }\n+\n+      if (j < task->width - 5) {\n+        y5_1 = s_y1[j + 5];\n+        y5_2 = s_y2[j + 5];\n+      }\n+\n+      a0 = u0_1 | (y0_1 << 10) | (v0_1 << 20);\n+      a1 = y1_1 | (u2_1 << 10) | (y2_1 << 20);\n+      a2 = v2_1 | (y3_1 << 10) | (u4_1 << 20);\n+      a3 = y4_1 | (v4_1 << 10) | (y5_1 << 20);\n+\n+      GST_WRITE_UINT32_LE (d1 + (j \/ 6) * 16 + 0, a0);\n+      GST_WRITE_UINT32_LE (d1 + (j \/ 6) * 16 + 4, a1);\n+      GST_WRITE_UINT32_LE (d1 + (j \/ 6) * 16 + 8, a2);\n+      GST_WRITE_UINT32_LE (d1 + (j \/ 6) * 16 + 12, a3);\n+\n+      a0 = u0_2 | (y0_2 << 10) | (v0_2 << 20);\n+      a1 = y1_2 | (u2_2 << 10) | (y2_2 << 20);\n+      a2 = v2_2 | (y3_2 << 10) | (u4_2 << 20);\n+      a3 = y4_2 | (v4_2 << 10) | (y5_2 << 20);\n+\n+      GST_WRITE_UINT32_LE (d2 + (j \/ 6) * 16 + 0, a0);\n+      GST_WRITE_UINT32_LE (d2 + (j \/ 6) * 16 + 4, a1);\n+      GST_WRITE_UINT32_LE (d2 + (j \/ 6) * 16 + 8, a2);\n+      GST_WRITE_UINT32_LE (d2 + (j \/ 6) * 16 + 12, a3);\n+    }\n+  }\n+}\n+\n+static void\n+convert_I420_10_v210 (GstVideoConverter * convert, const GstVideoFrame * src,\n+    GstVideoFrame * dest)\n+{\n+  int i;\n+  gint width = convert->in_width;\n+  gint height = convert->in_height;\n+  gboolean interlaced = GST_VIDEO_FRAME_IS_INTERLACED (src)\n+      && (GST_VIDEO_INFO_INTERLACE_MODE (&src->info) !=\n+      GST_VIDEO_INTERLACE_MODE_ALTERNATE);\n+  gint h2;\n+  FConvertTask *tasks;\n+  FConvertTask **tasks_p;\n+  gint n_threads;\n+  gint lines_per_thread;\n+\n+  \/* I420 has half as many chroma lines, as such we have to\n+   * always merge two into one. For non-interlaced these are\n+   * the two next to each other, for interlaced one is skipped\n+   * in between. *\/\n+  if (interlaced)\n+    h2 = GST_ROUND_DOWN_4 (height);\n+  else\n+    h2 = GST_ROUND_DOWN_2 (height);\n+\n+  n_threads = convert->conversion_runner->n_threads;\n+  tasks = convert->tasks[0] =\n+      g_renew (FConvertTask, convert->tasks[0], n_threads);\n+  tasks_p = convert->tasks_p[0] =\n+      g_renew (FConvertTask *, convert->tasks_p[0], n_threads);\n+\n+  lines_per_thread = GST_ROUND_UP_2 ((h2 + n_threads - 1) \/ n_threads);\n+\n+  for (i = 0; i < n_threads; i++) {\n+    tasks[i].src = src;\n+    tasks[i].dest = dest;\n+\n+    tasks[i].interlaced = interlaced;\n+    tasks[i].width = width;\n+\n+    tasks[i].height_0 = i * lines_per_thread;\n+    tasks[i].height_1 = tasks[i].height_0 + lines_per_thread;\n+    tasks[i].height_1 = MIN (h2, tasks[i].height_1);\n+\n+    tasks_p[i] = &tasks[i];\n+  }\n+\n+  gst_parallelized_task_runner_run (convert->conversion_runner,\n+      (GstParallelizedTaskFunc) convert_I420_10_v210_task, (gpointer) tasks_p);\n+\n+  \/* now handle last lines. For interlaced these are up to 3 *\/\n+  if (h2 != height) {\n+    for (i = h2; i < height; i++) {\n+      UNPACK_FRAME (src, convert->tmpline[0], i, convert->in_x, width);\n+      PACK_FRAME (dest, convert->tmpline[0], i, width);\n+    }\n+  }\n+}\n+\n@@ -3854,4 +4016,174 @@\n-  \/* now handle last lines. For interlaced these are up to 3 *\/\n-  if (h2 != height) {\n-    for (i = h2; i < height; i++) {\n-      UNPACK_FRAME (src, convert->tmpline[0], i, convert->in_x, width);\n+  \/* now handle last lines. For interlaced these are up to 3 *\/\n+  if (h2 != height) {\n+    for (i = h2; i < height; i++) {\n+      UNPACK_FRAME (src, convert->tmpline[0], i, convert->in_x, width);\n+      PACK_FRAME (dest, convert->tmpline[0], i, width);\n+    }\n+  }\n+}\n+\n+static void\n+convert_v210_I420_task (FConvertTask * task)\n+{\n+  gint i, j;\n+  gint l1, l2;\n+  guint8 *d_y1, *d_y2, *d_u, *d_v;\n+  const guint8 *s1, *s2;\n+  guint32 a0, a1, a2, a3;\n+  guint16 y0_1, y1_1, y2_1, y3_1, y4_1, y5_1;\n+  guint16 u0_1, u2_1, u4_1;\n+  guint16 v0_1, v2_1, v4_1;\n+  guint16 y0_2, y1_2, y2_2, y3_2, y4_2, y5_2;\n+  guint16 u0_2, u2_2, u4_2;\n+  guint16 v0_2, v2_2, v4_2;\n+\n+  for (i = task->height_0; i < task->height_1; i += 2) {\n+    GET_LINE_OFFSETS (task->interlaced, i, l1, l2);\n+\n+    d_y1 = FRAME_GET_Y_LINE (task->dest, l1);\n+    d_y2 = FRAME_GET_Y_LINE (task->dest, l2);\n+    d_u = FRAME_GET_U_LINE (task->dest, i >> 1);\n+    d_v = FRAME_GET_V_LINE (task->dest, i >> 1);\n+\n+    s1 = FRAME_GET_LINE (task->src, l1);\n+    s2 = FRAME_GET_LINE (task->src, l2);\n+\n+    for (j = 0; j < task->width; j += 6) {\n+      a0 = GST_READ_UINT32_LE (s1 + (j \/ 6) * 16 + 0);\n+      a1 = GST_READ_UINT32_LE (s1 + (j \/ 6) * 16 + 4);\n+      a2 = GST_READ_UINT32_LE (s1 + (j \/ 6) * 16 + 8);\n+      a3 = GST_READ_UINT32_LE (s1 + (j \/ 6) * 16 + 12);\n+\n+      u0_1 = ((a0 >> 0) & 0x3ff) >> 2;\n+      y0_1 = ((a0 >> 10) & 0x3ff) >> 2;\n+      v0_1 = ((a0 >> 20) & 0x3ff) >> 2;\n+      y1_1 = ((a1 >> 0) & 0x3ff) >> 2;\n+\n+      u2_1 = ((a1 >> 10) & 0x3ff) >> 2;\n+      y2_1 = ((a1 >> 20) & 0x3ff) >> 2;\n+      v2_1 = ((a2 >> 0) & 0x3ff) >> 2;\n+      y3_1 = ((a2 >> 10) & 0x3ff) >> 2;\n+\n+      u4_1 = ((a2 >> 20) & 0x3ff) >> 2;\n+      y4_1 = ((a3 >> 0) & 0x3ff) >> 2;\n+      v4_1 = ((a3 >> 10) & 0x3ff) >> 2;\n+      y5_1 = ((a3 >> 20) & 0x3ff) >> 2;\n+\n+      a0 = GST_READ_UINT32_LE (s2 + (j \/ 6) * 16 + 0);\n+      a1 = GST_READ_UINT32_LE (s2 + (j \/ 6) * 16 + 4);\n+      a2 = GST_READ_UINT32_LE (s2 + (j \/ 6) * 16 + 8);\n+      a3 = GST_READ_UINT32_LE (s2 + (j \/ 6) * 16 + 12);\n+\n+      u0_2 = ((a0 >> 0) & 0x3ff) >> 2;\n+      y0_2 = ((a0 >> 10) & 0x3ff) >> 2;\n+      v0_2 = ((a0 >> 20) & 0x3ff) >> 2;\n+      y1_2 = ((a1 >> 0) & 0x3ff) >> 2;\n+\n+      u2_2 = ((a1 >> 10) & 0x3ff) >> 2;\n+      y2_2 = ((a1 >> 20) & 0x3ff) >> 2;\n+      v2_2 = ((a2 >> 0) & 0x3ff) >> 2;\n+      y3_2 = ((a2 >> 10) & 0x3ff) >> 2;\n+\n+      u4_2 = ((a2 >> 20) & 0x3ff) >> 2;\n+      y4_2 = ((a3 >> 0) & 0x3ff) >> 2;\n+      v4_2 = ((a3 >> 10) & 0x3ff) >> 2;\n+      y5_2 = ((a3 >> 20) & 0x3ff) >> 2;\n+\n+      d_y1[j] = y0_1;\n+      d_y2[j] = y0_2;\n+      d_u[j \/ 2] = (u0_1 + u0_2) \/ 2;\n+      d_v[j \/ 2] = (v0_1 + v0_2) \/ 2;\n+\n+      if (j < task->width - 1) {\n+        d_y1[j + 1] = y1_1;\n+        d_y2[j + 1] = y1_2;\n+      }\n+\n+      if (j < task->width - 2) {\n+        d_y1[j + 2] = y2_1;\n+        d_y2[j + 2] = y2_2;\n+        d_u[j \/ 2 + 1] = (u2_1 + u2_2) \/ 2;\n+        d_v[j \/ 2 + 1] = (v2_1 + v2_2) \/ 2;\n+      }\n+\n+      if (j < task->width - 3) {\n+        d_y1[j + 3] = y3_1;\n+        d_y2[j + 3] = y3_2;\n+      }\n+\n+      if (j < task->width - 4) {\n+        d_y1[j + 4] = y4_1;\n+        d_y2[j + 4] = y4_2;\n+        d_u[j \/ 2 + 2] = (u4_1 + u4_2) \/ 2;\n+        d_v[j \/ 2 + 2] = (v4_1 + v4_2) \/ 2;\n+      }\n+\n+      if (j < task->width - 5) {\n+        d_y1[j + 5] = y5_1;\n+        d_y2[j + 5] = y5_2;\n+      }\n+    }\n+  }\n+}\n+\n+static void\n+convert_v210_I420 (GstVideoConverter * convert, const GstVideoFrame * src,\n+    GstVideoFrame * dest)\n+{\n+  int i;\n+  gint width = convert->in_width;\n+  gint height = convert->in_height;\n+  gboolean interlaced = GST_VIDEO_FRAME_IS_INTERLACED (src)\n+      && (GST_VIDEO_INFO_INTERLACE_MODE (&src->info) !=\n+      GST_VIDEO_INTERLACE_MODE_ALTERNATE);\n+  gint h2;\n+  FConvertTask *tasks;\n+  FConvertTask **tasks_p;\n+  gint n_threads;\n+  gint lines_per_thread;\n+  guint8 *tmpline_8;\n+\n+  \/* I420 has half as many chroma lines, as such we have to\n+   * always merge two into one. For non-interlaced these are\n+   * the two next to each other, for interlaced one is skipped\n+   * in between. *\/\n+  if (interlaced)\n+    h2 = GST_ROUND_DOWN_4 (height);\n+  else\n+    h2 = GST_ROUND_DOWN_2 (height);\n+\n+  n_threads = convert->conversion_runner->n_threads;\n+  tasks = convert->tasks[0] =\n+      g_renew (FConvertTask, convert->tasks[0], n_threads);\n+  tasks_p = convert->tasks_p[0] =\n+      g_renew (FConvertTask *, convert->tasks_p[0], n_threads);\n+\n+  lines_per_thread = GST_ROUND_UP_2 ((h2 + n_threads - 1) \/ n_threads);\n+\n+  for (i = 0; i < n_threads; i++) {\n+    tasks[i].src = src;\n+    tasks[i].dest = dest;\n+\n+    tasks[i].interlaced = interlaced;\n+    tasks[i].width = width;\n+\n+    tasks[i].height_0 = i * lines_per_thread;\n+    tasks[i].height_1 = tasks[i].height_0 + lines_per_thread;\n+    tasks[i].height_1 = MIN (h2, tasks[i].height_1);\n+\n+    tasks_p[i] = &tasks[i];\n+  }\n+\n+  gst_parallelized_task_runner_run (convert->conversion_runner,\n+      (GstParallelizedTaskFunc) convert_v210_I420_task, (gpointer) tasks_p);\n+\n+  \/* now handle last lines. For interlaced these are up to 3 *\/\n+  if (h2 != height) {\n+    for (i = h2; i < height; i++) {\n+      UNPACK_FRAME (src, convert->tmpline[0], i, convert->in_x, width);\n+\n+      tmpline_8 = (guint8 *) convert->tmpline[0];\n+      for (int j = 0; j < width * 4; j++) {\n+        tmpline_8[j] = convert->tmpline[0][j] >> 8;\n+      }\n+\n@@ -3864,1 +4196,1 @@\n-convert_v210_I420_task (FConvertTask * task)\n+convert_v210_I420_10_task (FConvertTask * task)\n@@ -3868,1 +4200,1 @@\n-  guint8 *d_y1, *d_y2, *d_u, *d_v;\n+  guint16 *d_y1, *d_y2, *d_u, *d_v;\n@@ -3895,4 +4227,4 @@\n-      u0_1 = ((a0 >> 0) & 0x3ff) >> 2;\n-      y0_1 = ((a0 >> 10) & 0x3ff) >> 2;\n-      v0_1 = ((a0 >> 20) & 0x3ff) >> 2;\n-      y1_1 = ((a1 >> 0) & 0x3ff) >> 2;\n+      u0_1 = ((a0 >> 0) & 0x3ff);\n+      y0_1 = ((a0 >> 10) & 0x3ff);\n+      v0_1 = ((a0 >> 20) & 0x3ff);\n+      y1_1 = ((a1 >> 0) & 0x3ff);\n@@ -3900,4 +4232,4 @@\n-      u2_1 = ((a1 >> 10) & 0x3ff) >> 2;\n-      y2_1 = ((a1 >> 20) & 0x3ff) >> 2;\n-      v2_1 = ((a2 >> 0) & 0x3ff) >> 2;\n-      y3_1 = ((a2 >> 10) & 0x3ff) >> 2;\n+      u2_1 = ((a1 >> 10) & 0x3ff);\n+      y2_1 = ((a1 >> 20) & 0x3ff);\n+      v2_1 = ((a2 >> 0) & 0x3ff);\n+      y3_1 = ((a2 >> 10) & 0x3ff);\n@@ -3905,4 +4237,4 @@\n-      u4_1 = ((a2 >> 20) & 0x3ff) >> 2;\n-      y4_1 = ((a3 >> 0) & 0x3ff) >> 2;\n-      v4_1 = ((a3 >> 10) & 0x3ff) >> 2;\n-      y5_1 = ((a3 >> 20) & 0x3ff) >> 2;\n+      u4_1 = ((a2 >> 20) & 0x3ff);\n+      y4_1 = ((a3 >> 0) & 0x3ff);\n+      v4_1 = ((a3 >> 10) & 0x3ff);\n+      y5_1 = ((a3 >> 20) & 0x3ff);\n@@ -3915,4 +4247,4 @@\n-      u0_2 = ((a0 >> 0) & 0x3ff) >> 2;\n-      y0_2 = ((a0 >> 10) & 0x3ff) >> 2;\n-      v0_2 = ((a0 >> 20) & 0x3ff) >> 2;\n-      y1_2 = ((a1 >> 0) & 0x3ff) >> 2;\n+      u0_2 = ((a0 >> 0) & 0x3ff);\n+      y0_2 = ((a0 >> 10) & 0x3ff);\n+      v0_2 = ((a0 >> 20) & 0x3ff);\n+      y1_2 = ((a1 >> 0) & 0x3ff);\n@@ -3920,4 +4252,4 @@\n-      u2_2 = ((a1 >> 10) & 0x3ff) >> 2;\n-      y2_2 = ((a1 >> 20) & 0x3ff) >> 2;\n-      v2_2 = ((a2 >> 0) & 0x3ff) >> 2;\n-      y3_2 = ((a2 >> 10) & 0x3ff) >> 2;\n+      u2_2 = ((a1 >> 10) & 0x3ff);\n+      y2_2 = ((a1 >> 20) & 0x3ff);\n+      v2_2 = ((a2 >> 0) & 0x3ff);\n+      y3_2 = ((a2 >> 10) & 0x3ff);\n@@ -3925,4 +4257,4 @@\n-      u4_2 = ((a2 >> 20) & 0x3ff) >> 2;\n-      y4_2 = ((a3 >> 0) & 0x3ff) >> 2;\n-      v4_2 = ((a3 >> 10) & 0x3ff) >> 2;\n-      y5_2 = ((a3 >> 20) & 0x3ff) >> 2;\n+      u4_2 = ((a2 >> 20) & 0x3ff);\n+      y4_2 = ((a3 >> 0) & 0x3ff);\n+      v4_2 = ((a3 >> 10) & 0x3ff);\n+      y5_2 = ((a3 >> 20) & 0x3ff);\n@@ -3968,1 +4300,1 @@\n-convert_v210_I420 (GstVideoConverter * convert, const GstVideoFrame * src,\n+convert_v210_I420_10 (GstVideoConverter * convert, const GstVideoFrame * src,\n@@ -3982,1 +4314,0 @@\n-  guint8 *tmpline_8;\n@@ -4016,1 +4347,1 @@\n-      (GstParallelizedTaskFunc) convert_v210_I420_task, (gpointer) tasks_p);\n+      (GstParallelizedTaskFunc) convert_v210_I420_10_task, (gpointer) tasks_p);\n@@ -4022,6 +4353,0 @@\n-\n-      tmpline_8 = (guint8 *) convert->tmpline[0];\n-      for (int j = 0; j < width * 4; j++) {\n-        tmpline_8[j] = convert->tmpline[0][j] >> 8;\n-      }\n-\n@@ -4033,0 +4358,1 @@\n+\n@@ -4457,0 +4783,124 @@\n+static void\n+convert_v210_I422_10_task (FConvertPlaneTask * task)\n+{\n+  gint i, j;\n+  guint16 *d_y, *d_u, *d_v;\n+  const guint8 *s;\n+  guint32 a0, a1, a2, a3;\n+  guint16 y0, y1, y2, y3, y4, y5;\n+  guint16 u0, u2, u4;\n+  guint16 v0, v2, v4;\n+\n+  for (i = 0; i < task->height; i++) {\n+    d_y = (guint16 *) (task->d + i * task->dstride);\n+    d_u = (guint16 *) (task->du + i * task->dustride);\n+    d_v = (guint16 *) (task->dv + i * task->dvstride);\n+    s = task->s + i * task->sstride;\n+\n+    for (j = 0; j < task->width; j += 6) {\n+      a0 = GST_READ_UINT32_LE (s + (j \/ 6) * 16 + 0);\n+      a1 = GST_READ_UINT32_LE (s + (j \/ 6) * 16 + 4);\n+      a2 = GST_READ_UINT32_LE (s + (j \/ 6) * 16 + 8);\n+      a3 = GST_READ_UINT32_LE (s + (j \/ 6) * 16 + 12);\n+\n+      u0 = ((a0 >> 0) & 0x3ff);\n+      y0 = ((a0 >> 10) & 0x3ff);\n+      v0 = ((a0 >> 20) & 0x3ff);\n+      y1 = ((a1 >> 0) & 0x3ff);\n+\n+      u2 = ((a1 >> 10) & 0x3ff);\n+      y2 = ((a1 >> 20) & 0x3ff);\n+      v2 = ((a2 >> 0) & 0x3ff);\n+      y3 = ((a2 >> 10) & 0x3ff);\n+\n+      u4 = ((a2 >> 20) & 0x3ff);\n+      y4 = ((a3 >> 0) & 0x3ff);\n+      v4 = ((a3 >> 10) & 0x3ff);\n+      y5 = ((a3 >> 20) & 0x3ff);\n+\n+      d_y[j] = y0;\n+      d_u[j \/ 2] = u0;\n+      d_v[j \/ 2] = v0;\n+\n+      if (j < task->width - 1) {\n+        d_y[j + 1] = y1;\n+      }\n+\n+      if (j < task->width - 2) {\n+        d_y[j + 2] = y2;\n+        d_u[j \/ 2 + 1] = u2;\n+        d_v[j \/ 2 + 1] = v2;\n+      }\n+\n+      if (j < task->width - 3) {\n+        d_y[j + 3] = y3;\n+      }\n+\n+      if (j < task->width - 4) {\n+        d_y[j + 4] = y4;\n+        d_u[j \/ 2 + 2] = u4;\n+        d_v[j \/ 2 + 2] = v4;\n+      }\n+\n+      if (j < task->width - 5) {\n+        d_y[j + 5] = y5;\n+      }\n+    }\n+  }\n+}\n+\n+static void\n+convert_v210_I422_10 (GstVideoConverter * convert, const GstVideoFrame * src,\n+    GstVideoFrame * dest)\n+{\n+  gint width = convert->in_width;\n+  gint height = convert->in_height;\n+  guint8 *s, *dy, *du, *dv;\n+  FConvertPlaneTask *tasks;\n+  FConvertPlaneTask **tasks_p;\n+  gint n_threads;\n+  gint lines_per_thread;\n+  gint i;\n+\n+  s = FRAME_GET_LINE (src, convert->in_y);\n+  s += (GST_ROUND_UP_2 (convert->in_x) * 2);\n+\n+  dy = FRAME_GET_Y_LINE (dest, convert->out_y);\n+  dy += convert->out_x;\n+  du = FRAME_GET_U_LINE (dest, convert->out_y);\n+  du += convert->out_x >> 1;\n+  dv = FRAME_GET_V_LINE (dest, convert->out_y);\n+  dv += convert->out_x >> 1;\n+\n+  n_threads = convert->conversion_runner->n_threads;\n+  tasks = convert->tasks[0] =\n+      g_renew (FConvertPlaneTask, convert->tasks[0], n_threads);\n+  tasks_p = convert->tasks_p[0] =\n+      g_renew (FConvertPlaneTask *, convert->tasks_p[0], n_threads);\n+\n+  lines_per_thread = (height + n_threads - 1) \/ n_threads;\n+\n+  for (i = 0; i < n_threads; i++) {\n+    tasks[i].dstride = FRAME_GET_Y_STRIDE (dest);\n+    tasks[i].dustride = FRAME_GET_U_STRIDE (dest);\n+    tasks[i].dvstride = FRAME_GET_V_STRIDE (dest);\n+    tasks[i].sstride = FRAME_GET_STRIDE (src);\n+    tasks[i].d = dy + i * lines_per_thread * tasks[i].dstride;\n+    tasks[i].du = du + i * lines_per_thread * tasks[i].dustride;\n+    tasks[i].dv = dv + i * lines_per_thread * tasks[i].dvstride;\n+    tasks[i].s = s + i * lines_per_thread * tasks[i].sstride;\n+\n+    tasks[i].width = width;\n+    tasks[i].height = (i + 1) * lines_per_thread;\n+    tasks[i].height = MIN (tasks[i].height, height);\n+    tasks[i].height -= i * lines_per_thread;\n+\n+    tasks_p[i] = &tasks[i];\n+  }\n+\n+  gst_parallelized_task_runner_run (convert->conversion_runner,\n+      (GstParallelizedTaskFunc) convert_v210_I422_10_task, (gpointer) tasks_p);\n+\n+  convert_fill_border (convert, dest);\n+}\n+\n@@ -5776,0 +6226,117 @@\n+static void\n+convert_I422_10_v210_task (FConvertPlaneTask * task)\n+{\n+  gint i, j;\n+  guint8 *d;\n+  const guint16 *s_y, *s_u, *s_v;\n+  guint32 a0, a1, a2, a3;\n+  guint16 y0, y1, y2, y3, y4, y5;\n+  guint16 u0, u2, u4;\n+  guint16 v0, v2, v4;\n+\n+  for (i = 0; i < task->height; i++) {\n+    d = task->d + i * task->dstride;\n+    s_y = (const guint16 *) (task->s + i * task->sstride);\n+    s_u = (const guint16 *) (task->su + i * task->sustride);\n+    s_v = (const guint16 *) (task->sv + i * task->svstride);\n+\n+    for (j = 0; j < task->width; j += 6) {\n+      y1 = y2 = y3 = y4 = y5 = 0;\n+      u2 = u4 = v2 = v4 = 0;\n+\n+      y0 = s_y[j];\n+      u0 = s_u[j \/ 2];\n+      v0 = s_v[j \/ 2];\n+\n+      if (j < task->width - 1) {\n+        y1 = s_y[j + 1];\n+      }\n+\n+      if (j < task->width - 2) {\n+        y2 = s_y[j + 2];\n+        u2 = s_u[j \/ 2 + 1];\n+        v2 = s_v[j \/ 2 + 1];\n+      }\n+\n+      if (j < task->width - 3) {\n+        y3 = s_y[j + 3];\n+      }\n+\n+      if (j < task->width - 4) {\n+        y4 = s_y[j + 4];\n+        u4 = s_u[j \/ 2 + 2];\n+        v4 = s_v[j \/ 2 + 2];\n+      }\n+\n+      if (j < task->width - 5) {\n+        y5 = s_y[j + 5];\n+      }\n+\n+      a0 = u0 | (y0 << 10) | (v0 << 20);\n+      a1 = y1 | (u2 << 10) | (y2 << 20);\n+      a2 = v2 | (y3 << 10) | (u4 << 20);\n+      a3 = y4 | (v4 << 10) | (y5 << 20);\n+\n+      GST_WRITE_UINT32_LE (d + (j \/ 6) * 16 + 0, a0);\n+      GST_WRITE_UINT32_LE (d + (j \/ 6) * 16 + 4, a1);\n+      GST_WRITE_UINT32_LE (d + (j \/ 6) * 16 + 8, a2);\n+      GST_WRITE_UINT32_LE (d + (j \/ 6) * 16 + 12, a3);\n+    }\n+  }\n+}\n+\n+static void\n+convert_I422_10_v210 (GstVideoConverter * convert, const GstVideoFrame * src,\n+    GstVideoFrame * dest)\n+{\n+  gint width = convert->in_width;\n+  gint height = convert->in_height;\n+  guint8 *d, *sy, *su, *sv;\n+  FConvertPlaneTask *tasks;\n+  FConvertPlaneTask **tasks_p;\n+  gint n_threads;\n+  gint lines_per_thread;\n+  gint i;\n+\n+  d = FRAME_GET_LINE (dest, convert->out_y);\n+  d += (GST_ROUND_UP_2 (convert->out_x) * 2);\n+\n+  sy = FRAME_GET_Y_LINE (src, convert->in_y);\n+  sy += convert->in_x;\n+  su = FRAME_GET_U_LINE (src, convert->in_y);\n+  su += convert->in_x >> 1;\n+  sv = FRAME_GET_V_LINE (src, convert->in_y);\n+  sv += convert->in_x >> 1;\n+\n+  n_threads = convert->conversion_runner->n_threads;\n+  tasks = convert->tasks[0] =\n+      g_renew (FConvertPlaneTask, convert->tasks[0], n_threads);\n+  tasks_p = convert->tasks_p[0] =\n+      g_renew (FConvertPlaneTask *, convert->tasks_p[0], n_threads);\n+\n+  lines_per_thread = (height + n_threads - 1) \/ n_threads;\n+\n+  for (i = 0; i < n_threads; i++) {\n+    tasks[i].dstride = FRAME_GET_STRIDE (dest);\n+    tasks[i].sstride = FRAME_GET_Y_STRIDE (src);\n+    tasks[i].sustride = FRAME_GET_U_STRIDE (src);\n+    tasks[i].svstride = FRAME_GET_V_STRIDE (src);\n+    tasks[i].d = d + i * lines_per_thread * tasks[i].dstride;\n+    tasks[i].s = sy + i * lines_per_thread * tasks[i].sstride;\n+    tasks[i].su = su + i * lines_per_thread * tasks[i].sustride;\n+    tasks[i].sv = sv + i * lines_per_thread * tasks[i].svstride;\n+\n+    tasks[i].width = width;\n+    tasks[i].height = (i + 1) * lines_per_thread;\n+    tasks[i].height = MIN (tasks[i].height, height);\n+    tasks[i].height -= i * lines_per_thread;\n+\n+    tasks_p[i] = &tasks[i];\n+  }\n+\n+  gst_parallelized_task_runner_run (convert->conversion_runner,\n+      (GstParallelizedTaskFunc) convert_I422_10_v210_task, (gpointer) tasks_p);\n+\n+  convert_fill_border (convert, dest);\n+}\n+\n@@ -7366,0 +7933,1 @@\n+    case GST_VIDEO_FORMAT_GRAY10_LE16:\n@@ -7380,0 +7948,2 @@\n+    case GST_VIDEO_FORMAT_Y216_BE:\n+    case GST_VIDEO_FORMAT_Y216_LE:\n@@ -7382,0 +7952,2 @@\n+    case GST_VIDEO_FORMAT_Y416_BE:\n+    case GST_VIDEO_FORMAT_Y416_LE:\n@@ -7827,0 +8399,20 @@\n+#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n+  {GST_VIDEO_FORMAT_v210, GST_VIDEO_FORMAT_I420_10LE, TRUE, FALSE, TRUE, FALSE,\n+      FALSE, FALSE, FALSE, FALSE, 0, 0, convert_v210_I420_10},\n+  {GST_VIDEO_FORMAT_v210, GST_VIDEO_FORMAT_I422_10LE, TRUE, FALSE, TRUE, FALSE,\n+      FALSE, FALSE, FALSE, FALSE, 0, 0, convert_v210_I422_10},\n+  {GST_VIDEO_FORMAT_I420_10LE, GST_VIDEO_FORMAT_v210, TRUE, FALSE, TRUE, FALSE,\n+      FALSE, FALSE, FALSE, FALSE, 0, 0, convert_I420_10_v210},\n+  {GST_VIDEO_FORMAT_I422_10LE, GST_VIDEO_FORMAT_v210, TRUE, FALSE, TRUE, TRUE,\n+      TRUE, FALSE, FALSE, FALSE, 0, 0, convert_I422_10_v210},\n+#else\n+  {GST_VIDEO_FORMAT_v210, GST_VIDEO_FORMAT_I420_10BE, TRUE, FALSE, TRUE, FALSE,\n+      FALSE, FALSE, FALSE, FALSE, 0, 0, convert_v210_I420_10},\n+  {GST_VIDEO_FORMAT_v210, GST_VIDEO_FORMAT_I422_10BE, TRUE, FALSE, TRUE, FALSE,\n+      FALSE, FALSE, FALSE, FALSE, 0, 0, convert_v210_I422_10},\n+  {GST_VIDEO_FORMAT_I420_10BE, GST_VIDEO_FORMAT_v210, TRUE, FALSE, TRUE, FALSE,\n+      FALSE, FALSE, FALSE, FALSE, 0, 0, convert_I420_10_v210},\n+  {GST_VIDEO_FORMAT_I422_10BE, GST_VIDEO_FORMAT_v210, TRUE, FALSE, TRUE, TRUE,\n+      TRUE, FALSE, FALSE, FALSE, 0, 0, convert_I422_10_v210},\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-converter.c","additions":693,"deletions":101,"binary":false,"changes":794,"status":"modified"},{"patch":"@@ -5227,0 +5227,38 @@\n+#define PACK_GRAY10_LE16 GST_VIDEO_FORMAT_AYUV64, unpack_GRAY10_LE16, 1, pack_GRAY10_LE16\n+static void\n+unpack_GRAY10_LE16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)\n+{\n+  int i;\n+  const guint16 *restrict s = GET_LINE (y);\n+  guint16 *restrict d = dest;\n+\n+  s += x;\n+\n+  for (i = 0; i < width; i++) {\n+    guint16 Y = GST_READ_UINT16_LE (s + i);\n+    d[i * 4 + 0] = 0xffff;\n+    d[i * 4 + 1] = (Y << 6);\n+    if (!(flags & GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE))\n+      d[i * 4 + 1] |= ((Y & 0X03FF) >> 4);\n+    d[i * 4 + 2] = 0x8000;\n+    d[i * 4 + 3] = 0x8000;\n+  }\n+}\n+\n+static void\n+pack_GRAY10_LE16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,\n+    gint y, gint width)\n+{\n+  int i;\n+  guint16 *restrict d = GET_LINE (y);\n+  const guint16 *restrict s = src;\n+\n+  for (i = 0; i < width; i++) {\n+    GST_WRITE_UINT16_LE (d + i, s[i * 4 + 1] >> 6);\n+  }\n+}\n+\n@@ -6677,0 +6715,170 @@\n+#define PACK_Y216_BE GST_VIDEO_FORMAT_AYUV64, unpack_Y216_BE, 1, pack_Y216_BE\n+static void\n+unpack_Y216_BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)\n+{\n+  int i;\n+  const guint8 *restrict s = GET_LINE (y);\n+  guint16 *restrict d = dest;\n+  guint Y0, Y1, U, V;\n+\n+  s += GST_ROUND_DOWN_2 (x) * 4;\n+\n+  if (x & 1) {\n+    Y1 = GST_READ_UINT16_BE (s + 4);\n+    U = GST_READ_UINT16_BE (s + 2);\n+    V = GST_READ_UINT16_BE (s + 6);\n+\n+    d[0] = 0xffff;\n+    d[1] = Y1;\n+    d[2] = U;\n+    d[3] = V;\n+    s += 8;\n+    d += 4;\n+    width--;\n+  }\n+\n+  for (i = 0; i < width \/ 2; i++) {\n+    Y0 = GST_READ_UINT16_BE (s + i * 8 + 0);\n+    U = GST_READ_UINT16_BE (s + i * 8 + 2);\n+    V = GST_READ_UINT16_BE (s + i * 8 + 6);\n+    Y1 = GST_READ_UINT16_BE (s + i * 8 + 4);\n+\n+    d[i * 8 + 0] = 0xffff;\n+    d[i * 8 + 1] = Y0;\n+    d[i * 8 + 2] = U;\n+    d[i * 8 + 3] = V;\n+\n+    d[i * 8 + 4] = 0xffff;\n+    d[i * 8 + 5] = Y1;\n+    d[i * 8 + 6] = U;\n+    d[i * 8 + 7] = V;\n+  }\n+\n+  if (width & 1) {\n+    i = width - 1;\n+\n+    Y0 = GST_READ_UINT16_BE (s + i * 4 + 0);\n+    U = GST_READ_UINT16_BE (s + i * 4 + 2);\n+    V = GST_READ_UINT16_BE (s + i * 4 + 6);\n+\n+    d[i * 4 + 0] = 0xffff;\n+    d[i * 4 + 1] = Y0;\n+    d[i * 4 + 2] = U;\n+    d[i * 4 + 3] = V;\n+  }\n+}\n+\n+static void\n+pack_Y216_BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,\n+    gint y, gint width)\n+{\n+  int i;\n+  guint16 Y0, Y1, U, V;\n+  guint8 *restrict d = GET_LINE (y);\n+  const guint16 *restrict s = src;\n+\n+  for (i = 0; i < width; i += 2) {\n+    Y0 = s[i * 4 + 1];\n+    U = s[i * 4 + 2];\n+    V = s[i * 4 + 3];\n+    if (i == width - 1)\n+      Y1 = s[i * 4 + 1];\n+    else\n+      Y1 = s[(i + 1) * 4 + 1];\n+\n+    GST_WRITE_UINT16_BE (d + i * 4 + 0, Y0);\n+    GST_WRITE_UINT16_BE (d + i * 4 + 2, U);\n+    GST_WRITE_UINT16_BE (d + i * 4 + 4, Y1);\n+    GST_WRITE_UINT16_BE (d + i * 4 + 6, V);\n+  }\n+}\n+\n+#define PACK_Y216_LE GST_VIDEO_FORMAT_AYUV64, unpack_Y216_LE, 1, pack_Y216_LE\n+static void\n+unpack_Y216_LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)\n+{\n+  int i;\n+  const guint8 *restrict s = GET_LINE (y);\n+  guint16 *restrict d = dest;\n+  guint Y0, Y1, U, V;\n+\n+  s += GST_ROUND_DOWN_2 (x) * 4;\n+\n+  if (x & 1) {\n+    Y1 = GST_READ_UINT16_LE (s + 4);\n+    U = GST_READ_UINT16_LE (s + 2);\n+    V = GST_READ_UINT16_LE (s + 6);\n+\n+    d[0] = 0xffff;\n+    d[1] = Y1;\n+    d[2] = U;\n+    d[3] = V;\n+    s += 8;\n+    d += 4;\n+    width--;\n+  }\n+\n+  for (i = 0; i < width \/ 2; i++) {\n+    Y0 = GST_READ_UINT16_LE (s + i * 8 + 0);\n+    U = GST_READ_UINT16_LE (s + i * 8 + 2);\n+    V = GST_READ_UINT16_LE (s + i * 8 + 6);\n+    Y1 = GST_READ_UINT16_LE (s + i * 8 + 4);\n+\n+    d[i * 8 + 0] = 0xffff;\n+    d[i * 8 + 1] = Y0;\n+    d[i * 8 + 2] = U;\n+    d[i * 8 + 3] = V;\n+\n+    d[i * 8 + 4] = 0xffff;\n+    d[i * 8 + 5] = Y1;\n+    d[i * 8 + 6] = U;\n+    d[i * 8 + 7] = V;\n+  }\n+\n+  if (width & 1) {\n+    i = width - 1;\n+\n+    Y0 = GST_READ_UINT16_LE (s + i * 4 + 0);\n+    U = GST_READ_UINT16_LE (s + i * 4 + 2);\n+    V = GST_READ_UINT16_LE (s + i * 4 + 6);\n+\n+    d[i * 4 + 0] = 0xffff;\n+    d[i * 4 + 1] = Y0;\n+    d[i * 4 + 2] = U;\n+    d[i * 4 + 3] = V;\n+  }\n+}\n+\n+static void\n+pack_Y216_LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,\n+    gint y, gint width)\n+{\n+  int i;\n+  guint16 Y0, Y1, U, V;\n+  guint8 *restrict d = GET_LINE (y);\n+  const guint16 *restrict s = src;\n+\n+  for (i = 0; i < width; i += 2) {\n+    Y0 = s[i * 4 + 1];\n+    U = s[i * 4 + 2];\n+    V = s[i * 4 + 3];\n+    if (i == width - 1)\n+      Y1 = s[i * 4 + 1];\n+    else\n+      Y1 = s[(i + 1) * 4 + 1];\n+\n+    GST_WRITE_UINT16_LE (d + i * 4 + 0, Y0);\n+    GST_WRITE_UINT16_LE (d + i * 4 + 2, U);\n+    GST_WRITE_UINT16_LE (d + i * 4 + 4, Y1);\n+    GST_WRITE_UINT16_LE (d + i * 4 + 6, V);\n+  }\n+}\n+\n@@ -6791,0 +6999,100 @@\n+#define PACK_Y416_BE GST_VIDEO_FORMAT_AYUV64, unpack_Y416_BE, 1, pack_Y416_BE\n+static void\n+unpack_Y416_BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)\n+{\n+  int i;\n+  const guint16 *restrict s = GET_LINE (y);\n+  guint16 *restrict d = dest;\n+  guint16 A, Y, U, V;\n+\n+  s += x * 4;\n+\n+  for (i = 0; i < width; i++) {\n+    U = GST_READ_UINT16_BE (s + 4 * i + 0);\n+    Y = GST_READ_UINT16_BE (s + 4 * i + 1);\n+    V = GST_READ_UINT16_BE (s + 4 * i + 2);\n+    A = GST_READ_UINT16_BE (s + 4 * i + 3);\n+\n+    d[4 * i + 0] = A;\n+    d[4 * i + 1] = Y;\n+    d[4 * i + 2] = U;\n+    d[4 * i + 3] = V;\n+  }\n+}\n+\n+static void\n+pack_Y416_BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,\n+    gint y, gint width)\n+{\n+  int i;\n+  guint16 *restrict d = GET_LINE (y);\n+  const guint16 *restrict s = src;\n+  guint16 A, Y, U, V;\n+\n+  for (i = 0; i < width; i++) {\n+    A = s[4 * i + 0];\n+    Y = s[4 * i + 1];\n+    U = s[4 * i + 2];\n+    V = s[4 * i + 3];\n+\n+    GST_WRITE_UINT16_BE (d + 4 * i + 0, U);\n+    GST_WRITE_UINT16_BE (d + 4 * i + 1, Y);\n+    GST_WRITE_UINT16_BE (d + 4 * i + 2, V);\n+    GST_WRITE_UINT16_BE (d + 4 * i + 3, A);\n+  }\n+}\n+\n+#define PACK_Y416_LE GST_VIDEO_FORMAT_AYUV64, unpack_Y416_LE, 1, pack_Y416_LE\n+static void\n+unpack_Y416_LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)\n+{\n+  int i;\n+  const guint16 *restrict s = GET_LINE (y);\n+  guint16 *restrict d = dest;\n+  guint16 A, Y, U, V;\n+\n+  s += x * 4;\n+\n+  for (i = 0; i < width; i++) {\n+    U = GST_READ_UINT16_LE (s + 4 * i + 0);\n+    Y = GST_READ_UINT16_LE (s + 4 * i + 1);\n+    V = GST_READ_UINT16_LE (s + 4 * i + 2);\n+    A = GST_READ_UINT16_LE (s + 4 * i + 3);\n+\n+    d[4 * i + 0] = A;\n+    d[4 * i + 1] = Y;\n+    d[4 * i + 2] = U;\n+    d[4 * i + 3] = V;\n+  }\n+}\n+\n+static void\n+pack_Y416_LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,\n+    const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],\n+    const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,\n+    gint y, gint width)\n+{\n+  int i;\n+  guint16 *restrict d = GET_LINE (y);\n+  const guint16 *restrict s = src;\n+  guint16 A, Y, U, V;\n+\n+  for (i = 0; i < width; i++) {\n+    A = s[4 * i + 0];\n+    Y = s[4 * i + 1];\n+    U = s[4 * i + 2];\n+    V = s[4 * i + 3];\n+\n+    GST_WRITE_UINT16_LE (d + 4 * i + 0, U);\n+    GST_WRITE_UINT16_LE (d + 4 * i + 1, Y);\n+    GST_WRITE_UINT16_LE (d + 4 * i + 2, V);\n+    GST_WRITE_UINT16_LE (d + 4 * i + 3, A);\n+  }\n+}\n+\n@@ -7725,1 +8033,1 @@\n-  MAKE_YUV_FORMAT (AV12, \"raw video\", GST_MAKE_FOURCC ('A', 'V', '1', '2'),\n+  MAKE_YUVA_FORMAT (AV12, \"raw video\", GST_MAKE_FOURCC ('A', 'V', '1', '2'),\n@@ -7797,0 +8105,10 @@\n+  MAKE_YUV_LE_FORMAT (Y216_LE, \"raw video\", 0x00000000, DPTH16_16_16,\n+      PSTR488, PLANE0, OFFS0, SUB422, PACK_Y216_LE),\n+  MAKE_YUV_FORMAT (Y216_BE, \"raw video\", 0x00000000, DPTH16_16_16,\n+      PSTR488, PLANE0, OFFS0, SUB422, PACK_Y216_BE),\n+  MAKE_YUV_LE_FORMAT (Y416_LE, \"raw video\", 0x00000000, DPTH16_16_16_16,\n+      PSTR8888, PLANE0, OFFS0, SUB4444, PACK_Y416_LE),\n+  MAKE_YUV_FORMAT (Y416_BE, \"raw video\", 0x00000000, DPTH16_16_16_16,\n+      PSTR8888, PLANE0, OFFS0, SUB4444, PACK_Y416_BE),\n+  MAKE_GRAY_LE_FORMAT (GRAY10_LE16, \"raw video\", DPTH10, PSTR2, PLANE0, OFFS0,\n+      SUB4, PACK_GRAY10_LE16),\n@@ -8113,2 +8431,4 @@\n- * Returns a string containing a descriptive name for\n- * the #GstVideoFormat if there is one, or NULL otherwise.\n+ * Returns a string containing a descriptive name for the #GstVideoFormat.\n+ *\n+ * Since 1.26 this can also be used with %GST_VIDEO_FORMAT_UNKNOWN, previous\n+ * versions were printing a critical warning and returned %NULL.\n@@ -8121,1 +8441,1 @@\n-  g_return_val_if_fail (format != GST_VIDEO_FORMAT_UNKNOWN, NULL);\n+  g_return_val_if_fail ((gint) format < G_N_ELEMENTS (formats), NULL);\n@@ -8123,0 +8443,1 @@\n+  \/* In case glib checks are disabled *\/\n@@ -8412,1 +8733,1 @@\n-  s = gst_structure_new (\"video\/x-raw\",\n+  s = gst_structure_new_static_str (\"video\/x-raw\",\n@@ -8417,1 +8738,1 @@\n-  gst_structure_take_value (s, \"format\", &format);\n+  gst_structure_take_value_static_str (s, \"format\", &format);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-format.c","additions":327,"deletions":6,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -172,0 +172,5 @@\n+ * @GST_VIDEO_FORMAT_Y216_LE: packed 4:2:2 YUV, 16 bits per channel (Y-U-Y-V) (Since: 1.26)\n+ * @GST_VIDEO_FORMAT_Y216_BE: packed 4:2:2 YUV, 16 bits per channel (Y-U-Y-V) (Since: 1.26)\n+ * @GST_VIDEO_FORMAT_Y416_LE: packed 4:4:4:4 YUV, 16 bits per channel(U-Y-V-A) (Since: 1.26)\n+ * @GST_VIDEO_FORMAT_Y416_BE: packed 4:4:4:4 YUV, 16 bits per channel(U-Y-V-A) (Since: 1.26)\n+ * @GST_VIDEO_FORMAT_GRAY10_LE16: 10-bit grayscale, packed into 16bit words (6 bits padding) (Since: 1.26)\n@@ -622,0 +627,47 @@\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_Y216_LE:\n+   *\n+   * packed 4:2:2 YUV, 16 bits per channel (Y-U-Y-V)\n+   *\n+   * Since: 1.26\n+   *\/\n+  GST_VIDEO_FORMAT_Y216_LE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_Y216_BE:\n+   *\n+   * packed 4:2:2 YUV, 16 bits per channel (Y-U-Y-V)\n+   *\n+   * Since: 1.26\n+   *\/\n+  GST_VIDEO_FORMAT_Y216_BE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_Y416_LE:\n+   *\n+   * packed 4:4:4:4 YUV, 16 bits per channel(U-Y-V-A)\n+   *\n+   * Since: 1.26\n+   *\/\n+  GST_VIDEO_FORMAT_Y416_LE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_Y416_BE:\n+   *\n+   * packed 4:4:4:4 YUV, 16 bits per channel(U-Y-V-A)\n+   *\n+   * Since: 1.26\n+   *\/\n+  GST_VIDEO_FORMAT_Y416_BE,\n+\n+  \/**\n+   * GST_VIDEO_FORMAT_GRAY10_LE16:\n+   *\n+   * 10-bit grayscale, packed into 16bit words (6 bits left padding)\n+   *\n+   * Since: 1.26\n+   *\/\n+  GST_VIDEO_FORMAT_GRAY10_LE16,\n+\n+  \/* Update GST_VIDEO_FORMAT_LAST below when adding more formats here *\/\n@@ -624,0 +676,9 @@\n+\/**\n+ * GST_VIDEO_FORMAT_LAST:\n+ *\n+ * Number of video formats in #GstVideoFormat.\n+ *\n+ * Since: 1.26\n+ *\/\n+#define GST_VIDEO_FORMAT_LAST (GST_VIDEO_FORMAT_GRAY10_LE16 + 1)\n+\n@@ -1091,17 +1152,17 @@\n-    \"RGBA64_BE, ARGB64_BE, BGRA64_BE, ABGR64_BE, RGBA64_LE, ARGB64_LE, \" \\\n-    \"BGRA64_LE, ABGR64_LE, A422_16BE, A422_16LE, A420_16BE, A420_16LE, \" \\\n-    \"A444_12BE, GBRA_12BE, A444_12LE, GBRA_12LE, Y412_BE, Y412_LE, A422_12BE, \" \\\n-    \"A422_12LE, A420_12BE, A420_12LE, A444_10BE, GBRA_10BE, A444_10LE, \" \\\n-    \"GBRA_10LE, A422_10BE, A422_10LE, A420_10BE, A420_10LE, Y410, BGR10A2_LE, \" \\\n-    \"RGB10A2_LE, A444, GBRA, AYUV, VUYA, RGBA, RBGA, ARGB, BGRA, ABGR, A422, \" \\\n-    \"A420, AV12, Y444_16BE, GBR_16BE, Y444_16LE, GBR_16LE, v216, P016_BE, \" \\\n-    \"P016_LE, Y444_12BE, GBR_12BE, Y444_12LE, GBR_12LE, I422_12BE, I422_12LE, \" \\\n-    \"Y212_BE, Y212_LE, I420_12BE, I420_12LE, P012_BE, P012_LE, Y444_10BE, \" \\\n-    \"GBR_10BE, Y444_10LE, GBR_10LE, r210, I422_10BE, I422_10LE, NV16_10LE32, \" \\\n-    \"Y210, UYVP, v210, I420_10BE, I420_10LE, P010_10BE, MT2110R, MT2110T, \" \\\n-    \"NV12_10BE_8L128, NV12_10LE40_4L4, P010_10LE, NV12_10LE40, NV12_10LE32, \" \\\n-    \"Y444, BGRP, GBR, RGBP, NV24, v308, IYU2, RGBx, xRGB, BGRx, xBGR, RGB, \" \\\n-    \"BGR, Y42B, NV16, NV61, YUY2, YVYU, UYVY, VYUY, I420, YV12, NV12, NV21, \" \\\n-    \"NV12_16L32S, NV12_32L32, NV12_4L4, NV12_64Z32, NV12_8L128, Y41B, IYU1, \" \\\n-    \"YUV9, YVU9, BGR16, RGB16, BGR15, RGB15, RGB8P, GRAY16_BE, GRAY16_LE, \" \\\n-    \"GRAY10_LE32, GRAY8\"\n+    \"Y416_BE, RGBA64_BE, ARGB64_BE, BGRA64_BE, ABGR64_BE, Y416_LE, RGBA64_LE, \" \\\n+    \"ARGB64_LE, BGRA64_LE, ABGR64_LE, A422_16BE, A422_16LE, A420_16BE, \" \\\n+    \"A420_16LE, A444_12BE, GBRA_12BE, A444_12LE, GBRA_12LE, Y412_BE, Y412_LE, \" \\\n+    \"A422_12BE, A422_12LE, A420_12BE, A420_12LE, A444_10BE, GBRA_10BE, \" \\\n+    \"A444_10LE, GBRA_10LE, A422_10BE, A422_10LE, A420_10BE, A420_10LE, Y410, \" \\\n+    \"BGR10A2_LE, RGB10A2_LE, A444, GBRA, AYUV, VUYA, RGBA, RBGA, ARGB, BGRA, \" \\\n+    \"ABGR, A422, A420, AV12, Y444_16BE, GBR_16BE, Y444_16LE, GBR_16LE, \" \\\n+    \"Y216_BE, v216, Y216_LE, P016_BE, P016_LE, Y444_12BE, GBR_12BE, Y444_12LE, \" \\\n+    \"GBR_12LE, I422_12BE, I422_12LE, Y212_BE, Y212_LE, I420_12BE, I420_12LE, \" \\\n+    \"P012_BE, P012_LE, Y444_10BE, GBR_10BE, Y444_10LE, GBR_10LE, r210, \" \\\n+    \"I422_10BE, I422_10LE, NV16_10LE32, Y210, UYVP, v210, I420_10BE, \" \\\n+    \"I420_10LE, P010_10BE, MT2110R, MT2110T, NV12_10BE_8L128, NV12_10LE40_4L4, \" \\\n+    \"P010_10LE, NV12_10LE40, NV12_10LE32, Y444, BGRP, GBR, RGBP, NV24, v308, \" \\\n+    \"IYU2, RGBx, xRGB, BGRx, xBGR, RGB, BGR, Y42B, NV16, NV61, YUY2, YVYU, \" \\\n+    \"UYVY, VYUY, I420, YV12, NV12, NV21, NV12_16L32S, NV12_32L32, NV12_4L4, \" \\\n+    \"NV12_64Z32, NV12_8L128, Y41B, IYU1, YUV9, YVU9, BGR16, RGB16, BGR15, \" \\\n+    \"RGB15, RGB8P, GRAY16_BE, GRAY16_LE, GRAY10_LE16, GRAY10_LE32, GRAY8\"\n@@ -1109,18 +1170,18 @@\n-#define GST_VIDEO_FORMATS_ALL_STR \"A444_16LE, A444_16BE, AYUV64, RGBA64_LE, \" \\\n-    \"ARGB64, ARGB64_LE, BGRA64_LE, ABGR64_LE, RGBA64_BE, ARGB64_BE, BGRA64_BE, \" \\\n-    \"ABGR64_BE, A422_16LE, A422_16BE, A420_16LE, A420_16BE, A444_12LE, \" \\\n-    \"GBRA_12LE, A444_12BE, GBRA_12BE, Y412_LE, Y412_BE, A422_12LE, A422_12BE, \" \\\n-    \"A420_12LE, A420_12BE, A444_10LE, GBRA_10LE, A444_10BE, GBRA_10BE, \" \\\n-    \"A422_10LE, A422_10BE, A420_10LE, A420_10BE, BGR10A2_LE, RGB10A2_LE, Y410, \" \\\n-    \"A444, GBRA, AYUV, VUYA, RGBA, RBGA, ARGB, BGRA, ABGR, A422, A420, AV12, \" \\\n-    \"Y444_16LE, GBR_16LE, Y444_16BE, GBR_16BE, v216, P016_LE, P016_BE, \" \\\n-    \"Y444_12LE, GBR_12LE, Y444_12BE, GBR_12BE, I422_12LE, I422_12BE, Y212_LE, \" \\\n-    \"Y212_BE, I420_12LE, I420_12BE, P012_LE, P012_BE, Y444_10LE, GBR_10LE, \" \\\n-    \"Y444_10BE, GBR_10BE, r210, I422_10LE, I422_10BE, NV16_10LE32, Y210, UYVP, \" \\\n-    \"v210, I420_10LE, I420_10BE, P010_10LE, NV12_10LE40, NV12_10LE32, \" \\\n-    \"P010_10BE, MT2110R, MT2110T, NV12_10BE_8L128, NV12_10LE40_4L4, Y444, \" \\\n-    \"BGRP, GBR, RGBP, NV24, v308, IYU2, RGBx, xRGB, BGRx, xBGR, RGB, BGR, \" \\\n-    \"Y42B, NV16, NV61, YUY2, YVYU, UYVY, VYUY, I420, YV12, NV12, NV21, \" \\\n-    \"NV12_16L32S, NV12_32L32, NV12_4L4, NV12_64Z32, NV12_8L128, Y41B, IYU1, \" \\\n-    \"YUV9, YVU9, BGR16, RGB16, BGR15, RGB15, RGB8P, GRAY16_LE, GRAY16_BE, \" \\\n-    \"GRAY10_LE32, GRAY8\"\n+#define GST_VIDEO_FORMATS_ALL_STR \"A444_16LE, A444_16BE, Y416_LE, AYUV64, \" \\\n+    \"RGBA64_LE, ARGB64, ARGB64_LE, BGRA64_LE, ABGR64_LE, Y416_BE, RGBA64_BE, \" \\\n+    \"ARGB64_BE, BGRA64_BE, ABGR64_BE, A422_16LE, A422_16BE, A420_16LE, \" \\\n+    \"A420_16BE, A444_12LE, GBRA_12LE, A444_12BE, GBRA_12BE, Y412_LE, Y412_BE, \" \\\n+    \"A422_12LE, A422_12BE, A420_12LE, A420_12BE, A444_10LE, GBRA_10LE, \" \\\n+    \"A444_10BE, GBRA_10BE, A422_10LE, A422_10BE, A420_10LE, A420_10BE, \" \\\n+    \"BGR10A2_LE, RGB10A2_LE, Y410, A444, GBRA, AYUV, VUYA, RGBA, RBGA, ARGB, \" \\\n+    \"BGRA, ABGR, A422, A420, AV12, Y444_16LE, GBR_16LE, Y444_16BE, GBR_16BE, \" \\\n+    \"Y216_LE, Y216_BE, v216, P016_LE, P016_BE, Y444_12LE, GBR_12LE, Y444_12BE, \" \\\n+    \"GBR_12BE, I422_12LE, I422_12BE, Y212_LE, Y212_BE, I420_12LE, I420_12BE, \" \\\n+    \"P012_LE, P012_BE, Y444_10LE, GBR_10LE, Y444_10BE, GBR_10BE, r210, \" \\\n+    \"I422_10LE, I422_10BE, NV16_10LE32, Y210, UYVP, v210, I420_10LE, \" \\\n+    \"I420_10BE, P010_10LE, NV12_10LE40, NV12_10LE32, P010_10BE, MT2110R, \" \\\n+    \"MT2110T, NV12_10BE_8L128, NV12_10LE40_4L4, Y444, BGRP, GBR, RGBP, NV24, \" \\\n+    \"v308, IYU2, RGBx, xRGB, BGRx, xBGR, RGB, BGR, Y42B, NV16, NV61, YUY2, \" \\\n+    \"YVYU, UYVY, VYUY, I420, YV12, NV12, NV21, NV12_16L32S, NV12_32L32, \" \\\n+    \"NV12_4L4, NV12_64Z32, NV12_8L128, Y41B, IYU1, YUV9, YVU9, BGR16, RGB16, \" \\\n+    \"BGR15, RGB15, RGB8P, GRAY16_LE, GRAY16_BE, GRAY10_LE16, GRAY10_LE32, GRAY8\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-format.h","additions":96,"deletions":35,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -386,4 +386,9 @@\n-    for (j = 0; j < h; j++) {\n-      memcpy (dp, sp, w);\n-      dp += ds;\n-      sp += ss;\n+    if (GST_VIDEO_INFO_PLANE_STRIDE (dinfo,\n+            plane) == GST_VIDEO_INFO_PLANE_STRIDE (sinfo, plane)) {\n+      memcpy (dp, sp, GST_VIDEO_INFO_PLANE_STRIDE (dinfo, plane) * h);\n+    } else {\n+      for (j = 0; j < h; j++) {\n+        memcpy (dp, sp, w);\n+        dp += ds;\n+        sp += ss;\n+      }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-frame.c","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -135,0 +136,1 @@\n+#endif \/\/ GSTREAMER_LITE\n@@ -192,0 +194,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -221,0 +224,1 @@\n+#endif \/\/ GSTREAMER_LITE\n@@ -269,0 +273,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -316,0 +321,1 @@\n+#endif \/\/ GSTREAMER_LITE\n@@ -360,0 +366,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -388,0 +395,1 @@\n+#endif \/\/ GSTREAMER_LITE\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-hdr.c","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -82,0 +83,1 @@\n+#endif \/\/ GSTREAMER_LITE\n@@ -90,0 +92,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -93,0 +96,1 @@\n+#endif \/\/ GSTREAMER_LITE\n@@ -121,0 +125,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -124,0 +129,1 @@\n+#endif \/\/ GSTREAMER_LITE\n@@ -132,0 +138,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -135,0 +142,1 @@\n+#endif \/\/ GSTREAMER_LITE\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-hdr.h","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -173,1 +173,0 @@\n-      info->chroma_site = GST_VIDEO_CHROMA_SITE_H_COSITED;\n@@ -176,1 +175,0 @@\n-      info->chroma_site = GST_VIDEO_CHROMA_SITE_NONE;\n@@ -189,1 +187,1 @@\n-validate_colorimetry (GstVideoInfo * info)\n+validate_colorimetry (const GstVideoInfo * info)\n@@ -212,0 +210,42 @@\n+static void\n+set_default_chroma_site (GstVideoInfo * info)\n+{\n+  const GstVideoFormatInfo *finfo = info->finfo;\n+\n+  if (GST_VIDEO_FORMAT_INFO_IS_YUV (finfo)) {\n+    if (info->height > 576) {\n+      info->chroma_site = GST_VIDEO_CHROMA_SITE_H_COSITED;\n+    } else {\n+      info->chroma_site = GST_VIDEO_CHROMA_SITE_NONE;\n+    }\n+  } else {\n+    info->chroma_site = GST_VIDEO_CHROMA_SITE_UNKNOWN;\n+  }\n+}\n+\n+static gboolean\n+validate_chroma_site (const GstVideoInfo * info)\n+{\n+  const GstVideoFormatInfo *finfo = info->finfo;\n+\n+  if (GST_VIDEO_FORMAT_INFO_IS_YUV (finfo)) {\n+    \/\/ FIXME: Might also want to check here for subsampling?\n+    \/\/ - chroma-site only makes sense with subsampled formats?\n+    \/\/ - ALT_LINE only makes sense for formats with vertical subsampling, and if\n+    \/\/   also V_COSITED?\n+    if ((info->chroma_site & GST_VIDEO_CHROMA_SITE_NONE) &&\n+        (info->chroma_site & (GST_VIDEO_CHROMA_SITE_H_COSITED |\n+                GST_VIDEO_CHROMA_SITE_V_COSITED))) {\n+      GST_WARNING\n+          (\"No chroma siting together with horizontal or vertical cositing is invalid\");\n+      return FALSE;\n+    }\n+  } else if (info->chroma_site != GST_VIDEO_CHROMA_SITE_UNKNOWN) {\n+    GST_WARNING (\"chroma-site only makes sense for YUV formats, %s is none\",\n+        finfo->name);\n+    return FALSE;\n+  }\n+\n+  return TRUE;\n+}\n+\n@@ -510,1 +550,1 @@\n-  if ((s = gst_structure_get_string (structure, \"chroma-site\")))\n+  if ((s = gst_structure_get_string (structure, \"chroma-site\"))) {\n@@ -512,2 +552,11 @@\n-  else\n-    info->chroma_site = GST_VIDEO_CHROMA_SITE_UNKNOWN;\n+    if (!validate_chroma_site (info)) {\n+      GST_WARNING (\"invalid chroma-site, using default\");\n+      set_default_chroma_site (info);\n+    } else if (GST_VIDEO_FORMAT_INFO_IS_YUV (info->finfo)\n+        && info->chroma_site == GST_VIDEO_CHROMA_SITE_UNKNOWN) {\n+      \/* force a default chroma-site for YUV formats *\/\n+      set_default_chroma_site (info);\n+    }\n+  } else {\n+    set_default_chroma_site (info);\n+  }\n@@ -685,1 +734,1 @@\n-  caps = gst_caps_new_simple (\"video\/x-raw\",\n+  caps = gst_caps_new_static_str_simple (\"video\/x-raw\",\n@@ -693,1 +742,1 @@\n-  gst_caps_set_simple (caps, \"interlace-mode\", G_TYPE_STRING,\n+  gst_caps_set_simple_static_str (caps, \"interlace-mode\", G_TYPE_STRING,\n@@ -697,0 +746,1 @@\n+          info->interlace_mode == GST_VIDEO_INTERLACE_MODE_FIELDS ||\n@@ -699,1 +749,1 @@\n-    gst_caps_set_simple (caps, \"field-order\", G_TYPE_STRING,\n+    gst_caps_set_simple_static_str (caps, \"field-order\", G_TYPE_STRING,\n@@ -709,1 +759,3 @@\n-    features = gst_caps_features_new (GST_CAPS_FEATURE_FORMAT_INTERLACED, NULL);\n+    features =\n+        gst_caps_features_new_static_str (GST_CAPS_FEATURE_FORMAT_INTERLACED,\n+        NULL);\n@@ -743,1 +795,1 @@\n-      gst_caps_set_simple (caps, \"multiview-mode\", G_TYPE_STRING,\n+      gst_caps_set_simple_static_str (caps, \"multiview-mode\", G_TYPE_STRING,\n@@ -749,1 +801,1 @@\n-  gst_caps_set_simple (caps, \"pixel-aspect-ratio\",\n+  gst_caps_set_simple_static_str (caps, \"pixel-aspect-ratio\",\n@@ -759,1 +811,1 @@\n-      gst_caps_set_simple (caps,\n+      gst_caps_set_simple_static_str (caps,\n@@ -774,1 +826,2 @@\n-    gst_caps_set_simple (caps, \"colorimetry\", G_TYPE_STRING, color, NULL);\n+    gst_caps_set_simple_static_str (caps, \"colorimetry\", G_TYPE_STRING, color,\n+        NULL);\n@@ -779,1 +832,2 @@\n-    gst_caps_set_simple (caps, \"views\", G_TYPE_INT, info->views, NULL);\n+    gst_caps_set_simple_static_str (caps, \"views\", G_TYPE_INT, info->views,\n+        NULL);\n@@ -783,1 +837,1 @@\n-    gst_caps_set_simple (caps, \"framerate\", GST_TYPE_FRACTION, 0, 1,\n+    gst_caps_set_simple_static_str (caps, \"framerate\", GST_TYPE_FRACTION, 0, 1,\n@@ -787,1 +841,1 @@\n-    gst_caps_set_simple (caps, \"framerate\", GST_TYPE_FRACTION,\n+    gst_caps_set_simple_static_str (caps, \"framerate\", GST_TYPE_FRACTION,\n@@ -866,0 +920,2 @@\n+    case GST_VIDEO_FORMAT_Y216_BE:\n+    case GST_VIDEO_FORMAT_Y216_LE:\n@@ -911,0 +967,2 @@\n+    case GST_VIDEO_FORMAT_Y416_BE:\n+    case GST_VIDEO_FORMAT_Y416_LE:\n@@ -1240,0 +1298,5 @@\n+    case GST_VIDEO_FORMAT_GRAY10_LE16:\n+      info->stride[0] = GST_ROUND_UP_4 (width * 2);\n+      info->offset[0] = 0;\n+      info->size = info->stride[0] * height;\n+      break;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-info.c","additions":80,"deletions":17,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -215,13 +215,55 @@\n-    GstMetaTransformCopy *copy = data;\n-\n-    if (!copy->region) {\n-      GST_DEBUG (\"copy video overlay composition metadata\");\n-\n-      \/* only copy if the complete data is copied as well *\/\n-      dmeta =\n-          (GstVideoOverlayCompositionMeta *) gst_buffer_add_meta (dest,\n-          GST_VIDEO_OVERLAY_COMPOSITION_META_INFO, NULL);\n-      if (!dmeta)\n-        return FALSE;\n-\n-      dmeta->overlay = gst_video_overlay_composition_ref (smeta->overlay);\n+    GST_DEBUG (\"copy video overlay composition metadata\");\n+\n+    dmeta =\n+        (GstVideoOverlayCompositionMeta *) gst_buffer_add_meta (dest,\n+        GST_VIDEO_OVERLAY_COMPOSITION_META_INFO, NULL);\n+    if (!dmeta)\n+      return FALSE;\n+\n+    dmeta->overlay = gst_video_overlay_composition_ref (smeta->overlay);\n+  } else if (GST_VIDEO_META_TRANSFORM_IS_SCALE (type)) {\n+    GstVideoMetaTransform *trans = data;\n+    GstVideoOverlayComposition *new_comp;\n+    gint ow, oh, nw, nh;\n+    guint n_rectangles;\n+\n+    ow = GST_VIDEO_INFO_WIDTH (trans->in_info);\n+    nw = GST_VIDEO_INFO_WIDTH (trans->out_info);\n+    oh = GST_VIDEO_INFO_HEIGHT (trans->in_info);\n+    nh = GST_VIDEO_INFO_HEIGHT (trans->out_info);\n+\n+    GST_DEBUG (\"scaling video overlay composition metadata %dx%d -> %dx%d\", ow,\n+        oh, nw, nh);\n+\n+    smeta = (GstVideoOverlayCompositionMeta *) meta;\n+\n+    new_comp = gst_video_overlay_composition_new (NULL);\n+    n_rectangles = gst_video_overlay_composition_n_rectangles (smeta->overlay);\n+    for (guint i = 0; i < n_rectangles; i++) {\n+      GstVideoOverlayRectangle *rect =\n+          gst_video_overlay_composition_get_rectangle (smeta->overlay, i);\n+      GstVideoOverlayRectangle *new_rect =\n+          gst_video_overlay_rectangle_copy (rect);\n+      gint render_x = 0, render_y = 0;\n+      gint new_render_x, new_render_y;\n+      guint render_width = 0, render_height = 0;\n+      guint new_render_width, new_render_height;\n+\n+      gst_video_overlay_rectangle_get_render_rectangle (rect, &render_x,\n+          &render_y, &render_width, &render_height);\n+\n+      new_render_x = (render_x * nw) \/ ow;\n+      new_render_y = (render_y * nh) \/ oh;\n+      new_render_width = (render_width * nw) \/ ow;\n+      new_render_height = (render_height * nh) \/ oh;\n+\n+      GST_DEBUG\n+          (\"overlay rectangle %u (seqnum: %d) (%dx%d)x(%ux%u) -> (%dx%d)->(%ux%u)\",\n+          i, gst_video_overlay_rectangle_get_seqnum (rect), render_x, render_y,\n+          render_width, render_height, new_render_x, new_render_y,\n+          new_render_width, new_render_height);\n+\n+      gst_video_overlay_rectangle_set_render_rectangle (new_rect,\n+          new_render_x, new_render_y, new_render_width, new_render_height);\n+      gst_video_overlay_composition_add_rectangle (new_comp, new_rect);\n+      gst_video_overlay_rectangle_unref (new_rect);\n@@ -229,0 +271,5 @@\n+\n+    dmeta = gst_buffer_add_video_overlay_composition_meta (dest, new_comp);\n+    gst_video_overlay_composition_unref (new_comp);\n+    if (!dmeta)\n+      return FALSE;\n@@ -240,1 +287,4 @@\n-  static const gchar *tags[] = { NULL };\n+  static const gchar *tags[] =\n+      { GST_META_TAG_VIDEO_STR, GST_META_TAG_VIDEO_ORIENTATION_STR,\n+    GST_META_TAG_VIDEO_SIZE_STR, NULL\n+  };\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video-overlay-composition.c","additions":64,"deletions":14,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-\n+#endif \/\/ GSTREAMER_LITE\n@@ -255,0 +255,1 @@\n+#ifndef GSTREAMER_LITE\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,2 +75,2 @@\n- * @GST_VIDEO_ORIENTATION_UL_LR: Flip across upper left\/lower right diagonal\n- * @GST_VIDEO_ORIENTATION_UR_LL: Flip across upper right\/lower left diagonal\n+ * @GST_VIDEO_ORIENTATION_UL_LR: Rotate counter-clockwise 90 degrees and flip vertically\n+ * @GST_VIDEO_ORIENTATION_UR_LL: Rotate clockwise 90 degrees and flip vertically\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/video.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,10 @@\n+ * The mix matrix can also be passed through a custom upstream event:\n+ *\n+ * |[\n+ * GstStructure *s = gst_structure_new(\"GstRequestAudioMixMatrix\", \"matrix\", GST_TYPE_ARRAY, &v, NULL);\n+ * GstEvent *event = gst_event_new_custom (GST_EVENT_CUSTOM_UPSTREAM, s);\n+ * GstPad *srcpad = gst_element_get_static_pad(audioconvert, \"src\");\n+ * gst_pad_send_event (srcpad, event);\n+ * gst_object_unref (pad);\n+ * ]|\n+ *\n@@ -93,0 +103,25 @@\n+ *\n+ * If input channels are unpositioned but follow a standard layout, they can be\n+ * automatically positioned according to their index using one of the reorder\n+ * configurations.\n+ *\n+ * ## Example with unpositioned input channels reordering\n+ * |[\n+ * gst-launch-1.0 -v audiotestsrc ! audio\/x-raw,channels=6,channel-mask=\\(bitmask\\)0x0000000000000000 ! audioconvert input-channels-reorder-mode=unpositioned input-channels-reorder=smpte ! fakesink\n+ * ]|\n+ *  In this case the input channels will be automatically positioned to the\n+ * SMPTE order (left, right, center, lfe, rear-left and rear-right).\n+ *\n+ * The input channels reorder configurations can also be used to force the\n+ * repositioning of the input channels when needed, for example when channels'\n+ * positions are not correctly identified in an encoded file.\n+ *\n+ * ## Example with the forced reordering of input channels wrongly positioned\n+ * |[\n+ * gst-launch-1.0 -v audiotestsrc ! audio\/x-raw,channels=3,channel-mask=\\(bitmask\\)0x0000000000000034 ! audioconvert input-channels-reorder-mode=force input-channels-reorder=aac ! fakesink\n+ * ]|\n+ *  In this case the input channels are positioned upstream as center,\n+ * rear-left and rear-right in this order. Using the \"force\" reorder mode and\n+ * the \"aac\" order, the input channels are going to be repositioned to left,\n+ * right and lfe, ignoring the actual value of the `channel-mask` in the input\n+ * caps.\n@@ -161,1 +196,3 @@\n-  PROP_DITHERING_THRESHOLD\n+  PROP_DITHERING_THRESHOLD,\n+  PROP_INPUT_CHANNELS_REORDER,\n+  PROP_INPUT_CHANNELS_REORDER_MODE\n@@ -195,0 +232,107 @@\n+\n+#define GST_TYPE_AUDIO_CONVERT_INPUT_CHANNELS_REORDER (gst_audio_convert_input_channels_reorder_get_type ())\n+\n+static GType\n+gst_audio_convert_input_channels_reorder_get_type (void)\n+{\n+  static GType reorder_type = 0;\n+\n+  if (g_once_init_enter (&reorder_type)) {\n+    static GEnumValue reorder_types[] = {\n+      {GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_GST,\n+            \"Reorder the input channels using the default GStreamer order\",\n+          \"gst\"},\n+      {GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_SMPTE,\n+            \"Reorder the input channels using the SMPTE order\",\n+          \"smpte\"},\n+      {GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_CINE,\n+            \"Reorder the input channels using the CINE order\",\n+          \"cine\"},\n+      {GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_AC3,\n+            \"Reorder the input channels using the AC3 order\",\n+          \"ac3\"},\n+      {GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_AAC,\n+            \"Reorder the input channels using the AAC order\",\n+          \"aac\"},\n+      {GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MONO,\n+            \"Reorder and mix all input channels to a single mono channel\",\n+          \"mono\"},\n+      {GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_ALTERNATE,\n+            \"Reorder and mix all input channels to a single left and a single right stereo channels alternately\",\n+          \"alternate\"},\n+      {0, NULL, NULL},\n+    };\n+\n+    GType type = g_enum_register_static (\"GstAudioConvertInputChannelsReorder\",\n+        reorder_types);\n+\n+    g_once_init_leave (&reorder_type, type);\n+  }\n+\n+  return reorder_type;\n+}\n+\n+#define GST_TYPE_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE (gst_audio_convert_input_channels_reorder_mode_get_type ())\n+\n+static GType\n+gst_audio_convert_input_channels_reorder_mode_get_type (void)\n+{\n+  static GType reorder_mode_type = 0;\n+\n+  if (g_once_init_enter (&reorder_mode_type)) {\n+    static GEnumValue reorder_mode_types[] = {\n+      {GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_NONE,\n+            \"Never reorder the input channels\",\n+          \"none\"},\n+      {GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_UNPOSITIONED,\n+            \"Reorder the input channels only if they are unpositioned\",\n+          \"unpositioned\"},\n+      {GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_FORCE,\n+            \"Always reorder the input channels according to the selected configuration\",\n+          \"force\"},\n+      {0, NULL, NULL},\n+    };\n+\n+    GType type =\n+        g_enum_register_static (\"GstAudioConvertInputChannelsReorderMode\",\n+        reorder_mode_types);\n+\n+    g_once_init_leave (&reorder_mode_type, type);\n+  }\n+\n+  return reorder_mode_type;\n+}\n+\n+static void\n+gst_audio_convert_set_mix_matrix (GstAudioConvert * this, const GValue * value);\n+\n+static gboolean\n+gst_audio_convert_src_event (GstBaseTransform * trans, GstEvent * event)\n+{\n+  gboolean ret = TRUE;\n+\n+  switch (GST_EVENT_TYPE (event)) {\n+    case GST_EVENT_CUSTOM_UPSTREAM:\n+    {\n+      const GstStructure *s = gst_event_get_structure (event);\n+\n+      if (s && gst_structure_has_name (s, \"GstRequestAudioMixMatrix\")) {\n+        const GValue *matrix = gst_structure_get_value (s, \"matrix\");\n+\n+        if (matrix) {\n+          gst_audio_convert_set_mix_matrix (GST_AUDIO_CONVERT (trans), matrix);\n+          g_object_notify (G_OBJECT (trans), \"mix-matrix\");\n+        }\n+        goto done;\n+      }\n+      break;\n+    }\n+    default:\n+      break;\n+  }\n+  ret = GST_BASE_TRANSFORM_CLASS (parent_class)->src_event (trans, event);\n+\n+done:\n+  return ret;\n+}\n+\n@@ -249,0 +393,47 @@\n+  \/**\n+   * GstAudioConvert:input-channels-reorder:\n+   *\n+   * The positions configuration to use to reorder the input channels\n+   * consecutively according to their index. If a `mix-matrix` is specified,\n+   * this configuration is ignored.\n+   *\n+   * When the input channels reordering is activated (because the\n+   * `input-channels-reorder-mode` property is\n+   * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_FORCE or the input channels\n+   * are unpositioned and the reorder mode is\n+   * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_UNPOSITIONED), input\n+   * channels will be reordered consecutively according to their index\n+   * independently of the `channel-mask` value in the sink pad audio caps.\n+   *\n+   * Since: 1.26\n+   *\/\n+  g_object_class_install_property (gobject_class,\n+      PROP_INPUT_CHANNELS_REORDER,\n+      g_param_spec_enum (\"input-channels-reorder\",\n+          \"Input Channels Reorder\",\n+          \"The positions configuration to use to reorder the input channels consecutively according to their index.\",\n+          GST_TYPE_AUDIO_CONVERT_INPUT_CHANNELS_REORDER,\n+          GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_GST,\n+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));\n+  gst_type_mark_as_plugin_api (GST_TYPE_AUDIO_CONVERT_INPUT_CHANNELS_REORDER,\n+      0);\n+\n+  \/**\n+   * GstAudioConvert:input-channels-reorder-mode:\n+   *\n+   * The input channels reordering mode used to apply the selected positions\n+   * configuration.\n+   *\n+   * Since: 1.26\n+   *\/\n+  g_object_class_install_property (gobject_class,\n+      PROP_INPUT_CHANNELS_REORDER_MODE,\n+      g_param_spec_enum (\"input-channels-reorder-mode\",\n+          \"Input Channels Reorder Mode\",\n+          \"The input channels reordering mode used to apply the selected positions configuration.\",\n+          GST_TYPE_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE,\n+          GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_NONE,\n+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));\n+  gst_type_mark_as_plugin_api\n+      (GST_TYPE_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE, 0);\n+\n@@ -275,0 +466,2 @@\n+  basetransform_class->src_event =\n+      GST_DEBUG_FUNCPTR (gst_audio_convert_src_event);\n@@ -307,0 +500,568 @@\n+\/*** INPUT CHANNELS REORDER FUNCTIONS *****************************************\/\n+\n+typedef struct\n+{\n+  gboolean has_stereo;\n+  gboolean lfe_as_last_channel;\n+} GstAudioConvertInputChannelsReorderConfig;\n+\n+static const GstAudioConvertInputChannelsReorderConfig\n+    input_channels_reorder_config[] = {\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_GST\n+  {TRUE, FALSE},\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_SMPTE\n+  {TRUE, FALSE},\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_CINE\n+  {TRUE, TRUE},\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_AC3\n+  {TRUE, TRUE},\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_AAC\n+  {TRUE, TRUE},\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MONO\n+  {FALSE, FALSE},\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_ALTERNATE\n+  {TRUE, FALSE}\n+};\n+\n+#define GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_NB G_N_ELEMENTS (input_channels_reorder_config)\n+\n+static const GstAudioChannelPosition\n+    channel_position_per_reorder_config\n+    [GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_NB][64] = {\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_GST\n+  {\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+        GST_AUDIO_CHANNEL_POSITION_LFE1,\n+        GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+        GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+        GST_AUDIO_CHANNEL_POSITION_LFE2,\n+        GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER,\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_CENTER,\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_WIDE_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_WIDE_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+      },\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_SMPTE (see: https:\/\/www.sis.se\/api\/document\/preview\/919377\/)\n+  {\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ Left front (L)\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ Right front (R)\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,        \/\/ Center front (C)\n+        GST_AUDIO_CHANNEL_POSITION_LFE1,        \/\/ Low frequency enhancement (LFE)\n+        GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,   \/\/ Left surround (Ls)\n+        GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,  \/\/ Right surround (Rs)\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,        \/\/ Left front center (Lc)\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,       \/\/ Right front center (Rc)\n+        GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT,       \/\/ Rear surround left (Lsr)\n+        GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT,      \/\/ Rear surround right (Rsr)\n+        GST_AUDIO_CHANNEL_POSITION_REAR_CENTER, \/\/ Rear center (Cs)\n+        GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,   \/\/ Left side surround (Lss)\n+        GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,  \/\/ Right side surround (Rss)\n+        GST_AUDIO_CHANNEL_POSITION_WIDE_LEFT,   \/\/ Left wide front (Lw)\n+        GST_AUDIO_CHANNEL_POSITION_WIDE_RIGHT,  \/\/ Right wide front (Rw)\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT,      \/\/ Left front vertical height (Lv)\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,     \/\/ Right front vertical height (Rv)\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,    \/\/ Center front vertical height (Cv)\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT,       \/\/ Left surround vertical height rear (Lvr)\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT,      \/\/ Right surround vertical height rear (Rvr)\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER,     \/\/ Center vertical height rear (Cvr)\n+        GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_LEFT,       \/\/ Left vertical height side surround (Lvss)\n+        GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_RIGHT,      \/\/ Right vertical height side surround (Rvss)\n+        GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,  \/\/ Top center surround (Ts)\n+        GST_AUDIO_CHANNEL_POSITION_LFE2,        \/\/ Low frequency enhancement 2 (LFE2)\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_LEFT,   \/\/ Left front vertical bottom (Lb)\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_RIGHT,  \/\/ Right front vertical bottom (Rb)\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_CENTER, \/\/ Center front vertical bottom (Cb)\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,     \/\/ Left vertical height surround (Lvs)\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,     \/\/ Right vertical height surround (Rvs)\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,     \/\/ Reserved\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,     \/\/ Reserved\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,     \/\/ Reserved\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,     \/\/ Reserved\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,     \/\/ Low frequency enhancement 3 (LFE3)\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,     \/\/ Left edge of screen (Leos)\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,     \/\/ Right edge of screen (Reos)\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,     \/\/ Half-way between center of screen and left edge of screen (Hwbcal)\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,     \/\/ Half-way between center of screen and right edge of screen (Hwbcar)\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,     \/\/ Left back surround (Lbs)\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,     \/\/ Right back surround (Rbs)\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+      },\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_CINE\n+  {\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,        \/\/ C\n+        GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,   \/\/ Ls\n+        GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,  \/\/ Rs\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,        \/\/ Lc\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,       \/\/ Rc\n+        GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT,       \/\/ Lsr\n+        GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT,      \/\/ Rsr\n+        GST_AUDIO_CHANNEL_POSITION_REAR_CENTER, \/\/ Cs\n+        GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,  \/\/ Ts\n+        GST_AUDIO_CHANNEL_POSITION_WIDE_LEFT,   \/\/ Lw\n+        GST_AUDIO_CHANNEL_POSITION_WIDE_RIGHT,  \/\/ Rw\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT,      \/\/ Lv\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,     \/\/ Rv\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,    \/\/ Cv\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT,       \/\/ Lvr\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT,      \/\/ Rvr\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER,     \/\/ Cvr\n+        GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,   \/\/ Lss\n+        GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,  \/\/ Rss\n+        GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_LEFT,       \/\/ Lvss\n+        GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_RIGHT,      \/\/ Rvss\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_LEFT,   \/\/ Lb\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_RIGHT,  \/\/ Rb\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_CENTER, \/\/ Cb\n+        GST_AUDIO_CHANNEL_POSITION_LFE2,        \/\/ LFE2\n+        GST_AUDIO_CHANNEL_POSITION_LFE1,        \/\/ LFE1\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+      },\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_AC3\n+  {\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,        \/\/ C\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,   \/\/ Ls\n+        GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,  \/\/ Rs\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,        \/\/ Lc\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,       \/\/ Rc\n+        GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT,       \/\/ Lsr\n+        GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT,      \/\/ Rsr\n+        GST_AUDIO_CHANNEL_POSITION_REAR_CENTER, \/\/ Cs\n+        GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,  \/\/ Ts\n+        GST_AUDIO_CHANNEL_POSITION_WIDE_LEFT,   \/\/ Lw\n+        GST_AUDIO_CHANNEL_POSITION_WIDE_RIGHT,  \/\/ Rw\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT,      \/\/ Lv\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,     \/\/ Rv\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,    \/\/ Cv\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT,       \/\/ Lvr\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT,      \/\/ Rvr\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER,     \/\/ Cvr\n+        GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,   \/\/ Lss\n+        GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,  \/\/ Rss\n+        GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_LEFT,       \/\/ Lvss\n+        GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_RIGHT,      \/\/ Rvss\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_LEFT,   \/\/ Lb\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_RIGHT,  \/\/ Rb\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_CENTER, \/\/ Cb\n+        GST_AUDIO_CHANNEL_POSITION_LFE2,        \/\/ LFE2\n+        GST_AUDIO_CHANNEL_POSITION_LFE1,        \/\/ LFE1\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+      },\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_AAC\n+  {\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,        \/\/ C\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,   \/\/ Ls\n+        GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,  \/\/ Rs\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,        \/\/ Lc\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,       \/\/ Rc\n+        GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT,       \/\/ Lsr\n+        GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT,      \/\/ Rsr\n+        GST_AUDIO_CHANNEL_POSITION_REAR_CENTER, \/\/ Cs\n+        GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,  \/\/ Ts\n+        GST_AUDIO_CHANNEL_POSITION_WIDE_LEFT,   \/\/ Lw\n+        GST_AUDIO_CHANNEL_POSITION_WIDE_RIGHT,  \/\/ Rw\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT,      \/\/ Lv\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,     \/\/ Rv\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,    \/\/ Cv\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT,       \/\/ Lvr\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT,      \/\/ Rvr\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER,     \/\/ Cvr\n+        GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,   \/\/ Lss\n+        GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,  \/\/ Rss\n+        GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_LEFT,       \/\/ Lvss\n+        GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_RIGHT,      \/\/ Rvss\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_LEFT,   \/\/ Lb\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_RIGHT,  \/\/ Rb\n+        GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_CENTER, \/\/ Cb\n+        GST_AUDIO_CHANNEL_POSITION_LFE2,        \/\/ LFE2\n+        GST_AUDIO_CHANNEL_POSITION_LFE1,        \/\/ LFE1\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+        GST_AUDIO_CHANNEL_POSITION_INVALID,\n+      },\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MONO\n+  {\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+        GST_AUDIO_CHANNEL_POSITION_MONO,\n+      },\n+  \/\/ GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_ALTERNATE\n+  {\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,  \/\/ L\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, \/\/ R\n+      }\n+};\n+\n+static const gchar *gst_audio_convert_input_channels_reorder_to_string\n+    (GstAudioConvertInputChannelsReorder reorder)\n+{\n+  switch (reorder) {\n+    case GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_GST:\n+      return \"GST\";\n+    case GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_SMPTE:\n+      return \"SMPTE\";\n+    case GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_CINE:\n+      return \"CINE\";\n+    case GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_AC3:\n+      return \"AC3\";\n+    case GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_AAC:\n+      return \"AAC\";\n+    case GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MONO:\n+      return \"MONO\";\n+    case GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_ALTERNATE:\n+      return \"ALTERNATE\";\n+    default:\n+      return \"UNKNOWN\";\n+  }\n+}\n+\n+static gboolean\n+gst_audio_convert_position_channels_from_reorder_configuration (gint channels,\n+    GstAudioConvertInputChannelsReorder reorder,\n+    GstAudioChannelPosition * position)\n+{\n+  g_return_val_if_fail (channels > 0, FALSE);\n+  g_return_val_if_fail (reorder >= 0\n+      && reorder < GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_NB, FALSE);\n+  g_return_val_if_fail (position != NULL, FALSE);\n+\n+  GST_DEBUG (\"ordering %d audio channel(s) according to the %s configuration\",\n+      channels, gst_audio_convert_input_channels_reorder_to_string (reorder));\n+\n+  if (channels == 1) {\n+    position[0] = GST_AUDIO_CHANNEL_POSITION_MONO;\n+    return TRUE;\n+  }\n+\n+  if (channels == 2 && input_channels_reorder_config[reorder].has_stereo) {\n+    position[0] = GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT;\n+    position[1] = GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT;\n+    return TRUE;\n+  }\n+\n+  for (gint i = 0; i < channels; ++i) {\n+    if (i < G_N_ELEMENTS (channel_position_per_reorder_config[reorder]))\n+      position[i] = channel_position_per_reorder_config[reorder][i];\n+    else\n+      position[i] = GST_AUDIO_CHANNEL_POSITION_INVALID;\n+  }\n+\n+  if (channels > 2\n+      && input_channels_reorder_config[reorder].lfe_as_last_channel) {\n+    position[channels - 1] = GST_AUDIO_CHANNEL_POSITION_LFE1;\n+    if (channels == 3 && input_channels_reorder_config[reorder].has_stereo) {\n+      position[0] = GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT;\n+      position[1] = GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT;\n+    }\n+  }\n+\n+  return TRUE;\n+}\n+\n@@ -355,1 +1116,1 @@\n-  GstAudioConvert *this = GST_AUDIO_CONVERT (user_data);\n+  gboolean force_removing = *(gboolean *) user_data;\n@@ -357,2 +1118,4 @@\n-  \/* Only remove the channels and channel-mask if a (empty) mix matrix was manually specified,\n-   * if no channel-mask is specified, for non-NONE channel layouts or for a single channel layout\n+  \/* Only remove the channels and channel-mask if a mix matrix was manually\n+   * specified or an input channels reordering is applied, or if no\n+   * channel-mask is specified, for non-NONE channel layouts or for a single\n+   * channel layout.\n@@ -360,1 +1123,1 @@\n-  if (this->mix_matrix_is_set ||\n+  if (force_removing ||\n@@ -376,1 +1139,2 @@\n-  gst_structure_set (s, \"channels\", G_TYPE_INT, other_channels, NULL);\n+  gst_structure_set_static_str (s, \"channels\", G_TYPE_INT, other_channels,\n+      NULL);\n@@ -396,1 +1160,0 @@\n-  gst_caps_map_in_place (tmp, remove_channels_from_structure, btrans);\n@@ -399,0 +1162,5 @@\n+  gboolean force_removing = this->mix_matrix_is_set\n+      || (direction == GST_PAD_SINK\n+      && this->input_channels_reorder_mode !=\n+      GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_NONE);\n+  gst_caps_map_in_place (tmp, remove_channels_from_structure, &force_removing);\n@@ -570,1 +1338,1 @@\n-    gst_structure_set (outs, \"format\", G_TYPE_STRING,\n+    gst_structure_set_static_str (outs, \"format\", G_TYPE_STRING,\n@@ -578,0 +1346,1 @@\n+  GstAudioConvert *this = GST_AUDIO_CONVERT (base);\n@@ -612,2 +1381,2 @@\n-      gst_structure_set (outs, \"channel-mask\", GST_TYPE_BITMASK, out_mask,\n-          NULL);\n+      gst_structure_set_static_str (outs, \"channel-mask\", GST_TYPE_BITMASK,\n+          out_mask, NULL);\n@@ -629,2 +1398,1 @@\n-      g_warning (\"%s: Upstream caps contain no channel mask\",\n-          GST_ELEMENT_NAME (base));\n+      GST_WARNING_OBJECT (base, \"Upstream caps contain no channel mask\");\n@@ -641,1 +1409,2 @@\n-      gst_structure_set (outs, \"channel-mask\", GST_TYPE_BITMASK, in_mask, NULL);\n+      gst_structure_set_static_str (outs, \"channel-mask\", GST_TYPE_BITMASK,\n+          in_mask, NULL);\n@@ -655,2 +1424,2 @@\n-      g_warning (\"%s: Invalid downstream channel-mask with too few bits set\",\n-          GST_ELEMENT_NAME (base));\n+      GST_WARNING_OBJECT (base,\n+          \"Invalid downstream channel-mask with too few bits set\");\n@@ -664,2 +1433,2 @@\n-        gst_structure_set (outs, \"channel-mask\", GST_TYPE_BITMASK, in_mask,\n-            NULL);\n+        gst_structure_set_static_str (outs, \"channel-mask\", GST_TYPE_BITMASK,\n+            in_mask, NULL);\n@@ -673,2 +1442,2 @@\n-        gst_structure_set (outs, \"channel-mask\", GST_TYPE_BITMASK, intersection,\n-            NULL);\n+        gst_structure_set_static_str (outs, \"channel-mask\", GST_TYPE_BITMASK,\n+            intersection, NULL);\n@@ -690,1 +1459,5 @@\n-    if (n_bits_set (out_mask) >= out_chans) {\n+    if (has_out_mask && out_mask == 0) {\n+      gst_structure_set_static_str (outs, \"channel-mask\", GST_TYPE_BITMASK,\n+          out_mask, NULL);\n+      return;\n+    } else if (n_bits_set (out_mask) >= out_chans) {\n@@ -692,2 +1465,2 @@\n-      gst_structure_set (outs, \"channel-mask\", GST_TYPE_BITMASK, intersection,\n-          NULL);\n+      gst_structure_set_static_str (outs, \"channel-mask\", GST_TYPE_BITMASK,\n+          intersection, NULL);\n@@ -695,0 +1468,6 @@\n+    } else if (this->mix_matrix_is_set) {\n+      \/* Assume the matrix matches the number of in\/out channels. This will be\n+       * validated when creating the converter. *\/\n+    } else {\n+      \/* what now?! Just ignore what we're given and use default positions *\/\n+      GST_WARNING_OBJECT (base, \"invalid or unexpected channel-positions\");\n@@ -696,3 +1475,0 @@\n-\n-    \/* what now?! Just ignore what we're given and use default positions *\/\n-    GST_WARNING_OBJECT (base, \"invalid or unexpected channel-positions\");\n@@ -709,1 +1485,2 @@\n-    gst_structure_set (outs, \"channel-mask\", GST_TYPE_BITMASK, out_mask, NULL);\n+    gst_structure_set_static_str (outs, \"channel-mask\", GST_TYPE_BITMASK,\n+        out_mask, NULL);\n@@ -713,1 +1490,1 @@\n-    gst_structure_set (outs, \"channel-mask\", GST_TYPE_BITMASK,\n+    gst_structure_set_static_str (outs, \"channel-mask\", GST_TYPE_BITMASK,\n@@ -792,1 +1569,1 @@\n-  config = gst_structure_new (\"GstAudioConverterConfig\",\n+  config = gst_structure_new_static_str (\"GstAudioConverterConfig\",\n@@ -801,2 +1578,24 @@\n-    gst_structure_set_value (config, GST_AUDIO_CONVERTER_OPT_MIX_MATRIX,\n-        &this->mix_matrix);\n+    gst_structure_set_value_static_str (config,\n+        GST_AUDIO_CONVERTER_OPT_MIX_MATRIX, &this->mix_matrix);\n+\n+    this->convert = gst_audio_converter_new (0, in_info, out_info, config);\n+  } else if (this->input_channels_reorder_mode !=\n+      GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_NONE) {\n+    GstAudioFlags in_flags;\n+    GstAudioChannelPosition in_position[64];\n+    gboolean restore_in = FALSE;\n+\n+    if (this->input_channels_reorder_mode ==\n+        GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_FORCE\n+        || GST_AUDIO_INFO_IS_UNPOSITIONED (in_info)) {\n+      in_flags = GST_AUDIO_INFO_FLAGS (in_info);\n+      memcpy (in_position, in_info->position,\n+          GST_AUDIO_INFO_CHANNELS (in_info) * sizeof (GstAudioChannelPosition));\n+\n+      if (gst_audio_convert_position_channels_from_reorder_configuration\n+          (GST_AUDIO_INFO_CHANNELS (in_info), this->input_channels_reorder,\n+              in_info->position)) {\n+        GST_AUDIO_INFO_FLAGS (in_info) &= ~GST_AUDIO_FLAG_UNPOSITIONED;\n+        restore_in = TRUE;\n+      }\n+    }\n@@ -805,0 +1604,7 @@\n+\n+    if (restore_in) {\n+      GST_AUDIO_INFO_FLAGS (in_info) = in_flags;\n+      memcpy (in_info->position, in_position,\n+          GST_AUDIO_INFO_CHANNELS (in_info) * sizeof (GstAudioChannelPosition));\n+    }\n+\n@@ -1053,7 +1859,0 @@\n-  gboolean mix_matrix_was_set;\n-  GstAudioConverter *old_converter;\n-  GValue old_mix_matrix = G_VALUE_INIT;\n-  gboolean restore = FALSE;\n-\n-  g_value_init (&old_mix_matrix, GST_TYPE_ARRAY);\n-\n@@ -1062,9 +1861,1 @@\n-  mix_matrix_was_set = this->mix_matrix_is_set;\n-  old_converter = this->convert;\n-  if (mix_matrix_was_set) {\n-    g_value_copy (&this->mix_matrix, &old_mix_matrix);\n-  }\n-\n-  if (this->convert) {\n-    this->convert = NULL;\n-  }\n+  g_clear_pointer (&this->convert, gst_audio_converter_free);\n@@ -1082,3 +1873,2 @@\n-      g_warning (\"Empty mix matrix's first row.\");\n-      restore = TRUE;\n-      goto done;\n+      GST_WARNING_OBJECT (this, \"Empty mix matrix's first row.\");\n+      this->mix_matrix_is_set = FALSE;\n@@ -1090,26 +1880,7 @@\n-  \/* We need to call this here already because gst_audio_convert_transform\n-   * might never get called otherwise if the element was set to passthrough.\n-   *\n-   * In any case if this succeeds we still want to reconfigure the sink to give\n-   * upstream a chance to renegotiate channels.\n-   *\/\n-  if (gst_audio_convert_ensure_converter (GST_BASE_TRANSFORM (this),\n-          &this->in_info, &this->out_info)) {\n-    gst_base_transform_reconfigure_sink (GST_BASE_TRANSFORM (this));\n-  } else {\n-    g_warning (\"Cannot build converter with this mix matrix\");\n-    restore = TRUE;\n-    goto done;\n-  }\n-\n-done:\n-  if (restore) {\n-    this->mix_matrix_is_set = mix_matrix_was_set;\n-    if (mix_matrix_was_set) {\n-      g_value_copy (&old_mix_matrix, &this->mix_matrix);\n-    }\n-    this->convert = old_converter;\n-  } else if (old_converter) {\n-    gst_audio_converter_free (old_converter);\n-  }\n-  g_value_unset (&old_mix_matrix);\n+  \/* We can't create the converter here because the application could be setting\n+   * a new mix-matrix for caps we haven't received yet (e.g. number of input\n+   * channels changed). Assume for now we can't be passthrough and in-place,\n+   * that will be revised once new caps or next buffer arrives. *\/\n+  gst_base_transform_set_in_place (GST_BASE_TRANSFORM_CAST (this), FALSE);\n+  gst_base_transform_set_passthrough (GST_BASE_TRANSFORM_CAST (this), FALSE);\n+  gst_base_transform_reconfigure_sink (GST_BASE_TRANSFORM_CAST (this));\n@@ -1137,0 +1908,6 @@\n+    case PROP_INPUT_CHANNELS_REORDER:\n+      this->input_channels_reorder = g_value_get_enum (value);\n+      break;\n+    case PROP_INPUT_CHANNELS_REORDER_MODE:\n+      this->input_channels_reorder_mode = g_value_get_enum (value);\n+      break;\n@@ -1165,0 +1942,6 @@\n+    case PROP_INPUT_CHANNELS_REORDER:\n+      g_value_set_enum (value, this->input_channels_reorder);\n+      break;\n+    case PROP_INPUT_CHANNELS_REORDER_MODE:\n+      g_value_set_enum (value, this->input_channels_reorder_mode);\n+      break;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/audioconvert\/gstaudioconvert.c","additions":858,"deletions":75,"binary":false,"changes":933,"status":"modified"},{"patch":"@@ -29,0 +29,144 @@\n+\/**\n+ * GstAudioConvertInputChannelsReorder:\n+ * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_GST: reorder input channels\n+ *     according to the default ordering in GStreamer: FRONT_LEFT, FRONT_RIGHT,\n+ *     FRONT_CENTER, LFE1 and then the other channels. If there is only one\n+ *     input channel available, it will be positioned to MONO.\n+ * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_SMPTE: reorder input channels\n+ *     according to the SMPTE standard: FRONT_LEFT, FRONT_RIGHT, FRONT_CENTER,\n+ *     LFE1 and then the other channels (the ordering is slightly different from\n+ *     the default GStreamer order). This audio channels ordering is the only\n+ *     one that is officially standardized and used by default in many audio\n+ *     softwares (see: https:\/\/www.sis.se\/api\/document\/preview\/919377\/). If\n+ *     there is only one input channel available, it will be positioned to MONO.\n+ * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_CINE: reorder input channels as it\n+ *     is commonly used in the cinema industry: FRONT_LEFT, FRONT_RIGHT,\n+ *     FRONT_CENTER, the other channels and then LFE1. This configuration is not\n+ *     standardized but usually appears in the literature related to the cinema\n+ *     industry and as an alternate ordering in different audio softwares. On\n+ *     some web sites, this configuration and the\n+ *     @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_AC3 ordering are switched. If\n+ *     there is only one input channel available, it will be positioned to\n+ *     MONO. If the number of available input channels is > 2, the last channel\n+ *     will always be positioned to LFE1.\n+ * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_AC3: reorder input channels in the\n+ *     same order as the default order of the AC3 format: FRONT_LEFT,\n+ *     FRONT_CENTER, FRONT_RIGHT, the other channels (same order as in the\n+ *     @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_CINE policy) and then LFE1.\n+ *     This configuration is also commonly used in the cinema industry and in\n+ *     professional audio softwares (like ProTools under the name \"FILM\"\n+ *     ordering). The only difference with the\n+ *     @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_CINE configuration is the\n+ *     order of the first 3 channels. If there is only one input channel\n+ *     available, it will be positioned to MONO. If the number of available\n+ *     input channels is > 2, the last channel will always be positioned to\n+ *     LFE1. If the number of available input channels is 2 or 3, the first two\n+ *     channels will be positioned to FRONT_LEFT and FRONT_RIGHT.\n+ * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_AAC: reorder input channels in the\n+ *     same order as the default order of the AAC format: FRONT_CENTER,\n+ *     FRONT_LEFT, FRONT_RIGHT, the other channels (same order as in the\n+ *     @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_CINE configuration) and then\n+ *     LFE1. The only difference with the\n+ *     @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_CINE configuration is the\n+ *     order of the first 3 channels. If there is only one input channel\n+ *     available, it will be positioned to MONO. If the number of available\n+ *     input channels is > 2, the last channel will always be positioned to\n+ *     LFE1. If the number of available input channels is 2 or 3, the first two\n+ *     channels will be positioned to FRONT_LEFT and FRONT_RIGHT.\n+ * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MONO: reorder all input channels\n+ *     to MONO. All input channels are mixed together at the same level to a\n+ *     virtual single mono channel. For `n` input channels, the virtual output\n+ *     sample value is computed as:\n+ *     `output_sample[MONO] = (1\/n) x ∑ input_sample_for_channel(i)` with\n+ *     `0 <= i < n`. A concrete usage for this configuration is, for example,\n+ *     when importing audio from an array of multiple mono microphones and you\n+ *     want to use them as a unique mono channel.\n+ * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_ALTERNATE: reorder all input\n+ *     channels to FRONT_LEFT and FRONT_RIGHT channels alternately (or MONO if\n+ *     there is only one input channel available). All left input channels are\n+ *     mixed together, at the same level, to a single FRONT_LEFT virtual\n+ *     channel and all right input channels are mixed together to a single\n+ *     FRONT_RIGHT virtual channel. For `2n` input channels the FRONT_LEFT and\n+ *     FRONT_RIGHT virtual output samples are computed as:\n+ *     `output_sample[FRONT_LEFT] = (1\/n) x ∑ input_sample_for_channel(2i)` and\n+ *     `output_sample[FRONT_RIGHT] = (1\/n) x ∑ input_sample_for_channel(2i+1)`\n+ *     with `0 <= i < n` (in case of an odd number of input channels the\n+ *     principle is the same but with an extra input left channel). A concrete\n+ *     usage for this configuration is, for example, when importing audio from\n+ *     an array of multiple stereo microphones and you want to use them as a\n+ *     simple pair of stereo channels.\n+ *\n+ * Input audio channels reordering configurations.\n+ *\n+ * It defines different ways of reordering input audio channels when they are\n+ * not positioned by GStreamer. As a general matter, channels are always ordered\n+ * in the @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_GST order and the\n+ * `channel-mask` field in the audio caps allows specifying which channels are\n+ * active.\n+ *\n+ * Depending on the selected mode (see:\n+ * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_UNPOSITIONED), input channels\n+ * can be automatically positioned when the `channel-mask` is not specified or\n+ * equals 0. In this case, all input channels will be positioned according to\n+ * the selected reordering configuration and the index of each input channel.\n+ * This can be useful when importing audio from an array of independent\n+ * microphones for example.\n+ *\n+ * The reordering configuration can also be forced (see:\n+ * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_FORCE) to reposition all\n+ * input channels according to each channel index. In this case the\n+ * `channel-mask` will be totally ignored and input channels will be reordered\n+ * just like if they were unpositioned. This can be useful when importing\n+ * multi-channels audio with errors in the channels positioning.\n+ *\n+ * For any of the former configurations, when the reordering is applied\n+ * (input channels are unpositioned or the \"force\" mode is active):\n+ * - When there is only one input channel available, it is positioned to MONO\n+ *   always, independently of the selected configuration.\n+ * - When there are 2 input channels available, they are positioned to\n+ *   FRONT_LEFT and FRONT_RIGHT (except for the\n+ *   @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MONO configuration where all\n+ *   input channels are positioned to MONO).\n+ *\n+ * Since: 1.26\n+ *\/\n+typedef enum {\n+  GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_GST = 0,\n+  GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_SMPTE,\n+  GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_CINE,\n+  GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_AC3,\n+  GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_AAC,\n+  GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MONO,\n+  GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_ALTERNATE\n+} GstAudioConvertInputChannelsReorder;\n+\n+\/**\n+ * GstAudioConvertInputChannelsReorderMode:\n+ * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_NONE: never reorder the input\n+ *     channels. If input channels are unpositioned and there are, at least, 3\n+ *     input channels, an error will be generated.\n+ * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_UNPOSITIONED: automatically\n+ *     reorder the input channels according to the selected\n+ *     #GstAudioConvertInputChannelsReorder configuration when, and only when,\n+ *     they are unpositioned (the `channel-mask` equals 0 or is not specified\n+ *     in the input caps).\n+ * @GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_FORCE: always reorder the\n+ *     input channels according to the selected\n+ *     #GstAudioConvertInputChannelsReorder configuration. The `channel-mask`\n+ *     value in the input caps is completely ignored. Input channels are always\n+ *     reordered as if they were unpositioned independently of the input caps.\n+ *\n+ * The different usage modes of the input channels reordering configuration.\n+ *\n+ * Independently of the selected mode, the explicit definition of a mix matrix\n+ * takes precedence over the reorder configuration. In this case, the provided\n+ * mix matrix will override the reorder configuration.\n+ *\n+ * Since: 1.26\n+ *\/\n+typedef enum {\n+  GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_NONE = 0,\n+  GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_UNPOSITIONED,\n+  GST_AUDIO_CONVERT_INPUT_CHANNELS_REORDER_MODE_FORCE\n+} GstAudioConvertInputChannelsReorderMode;\n+\n@@ -48,0 +192,2 @@\n+  GstAudioConvertInputChannelsReorder input_channels_reorder;\n+  GstAudioConvertInputChannelsReorderMode input_channels_reorder_mode;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/audioconvert\/gstaudioconvert.h","additions":146,"deletions":0,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2861,1 +2861,1 @@\n-      nut = c.data[3] & 0x9f;   \/* forbiden_zero_bit | nal_unit_type *\/\n+      nut = c.data[3] & 0x9f;   \/* forbidden_zero_bit | nal_unit_type *\/\n@@ -2963,1 +2963,1 @@\n-      \/* forbiden_zero_bit | nal_unit_type *\/\n+      \/* forbidden_zero_bit | nal_unit_type *\/\n@@ -3031,0 +3031,94 @@\n+\/*** video\/x-h266 H266 elementary video stream ***\/\n+\n+static GstStaticCaps h266_video_caps =\n+GST_STATIC_CAPS (\"video\/x-h266,stream-format=byte-stream\");\n+\n+#define H266_VIDEO_CAPS gst_static_caps_get(&h266_video_caps)\n+\n+#define H266_MAX_PROBE_LENGTH (128 * 1024)      \/* 128kB for HD should be enough. *\/\n+\n+static void\n+h266_video_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  DataScanCtx c = { 0, NULL, 0 };\n+\n+  \/* Stream consists of: a series of sync codes (00 00 00 01) followed\n+   * by NALs\n+   *\/\n+  gboolean seen_irap = FALSE;\n+  gboolean seen_vps = FALSE;\n+  gboolean seen_sps = FALSE;\n+  gboolean seen_pps = FALSE;\n+  int nuh, nut;\n+  int good = 0;\n+  int bad = 0;\n+\n+  while (c.offset < H266_MAX_PROBE_LENGTH) {\n+    if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &c, 5)))\n+      break;\n+\n+    if (IS_MPEG_HEADER (c.data)) {\n+      \/* forbidden_zero_bit(1) | nuh_reserved_zero_bit(1) | nuh_layer_id(6) *\/\n+      nuh = c.data[3] & 0xc0;\n+      \/* nal_unit_type(5) | nuh_temporal_id_plus1(3) *\/\n+      nut = c.data[4] & 0xf8;\n+\n+      \/* if forbidden bit and nuh_reserved_zero_bit are different to 0 won't be h266 *\/\n+      if (nuh) {\n+        bad++;\n+        break;\n+      }\n+      nut = nut >> 3;\n+\n+      \/* if nuh_temporal_id_plus1 is zero then it won't be h266 *\/\n+      if (!(c.data[4] & 0x07)) {\n+        bad++;\n+        break;\n+      }\n+\n+      \/* collect statistics about the NAL types *\/\n+      if ((nut >= 0 && nut <= 27)) {\n+        if (nut == 14)\n+          seen_vps = TRUE;\n+        else if (nut == 15)\n+          seen_sps = TRUE;\n+        else if (nut == 16)\n+          seen_pps = TRUE;\n+        else if (nut >= 7 && nut <= 9) {\n+          \/* BLA, IDR and CRA pictures are belongs to be IRAP picture *\/\n+          \/* we are not counting the reserved IRAP pictures (22 and 23) to good *\/\n+          seen_irap = TRUE;\n+        }\n+\n+        good++;\n+      } else if (nut >= 27) {\n+        \/* reserved values are counting as bad *\/\n+        bad++;\n+      }\n+\n+      GST_LOG (\"good:%d, bad:%d, pps:%d, sps:%d, vps:%d, irap:%d\", good, bad,\n+          seen_pps, seen_sps, seen_vps, seen_irap);\n+\n+      if (seen_sps && seen_pps && seen_irap && good >= 10 && bad < 4) {\n+        gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, H266_VIDEO_CAPS);\n+        return;\n+      }\n+\n+      data_scan_ctx_advance (tf, &c, 5);\n+    }\n+    data_scan_ctx_advance (tf, &c, 1);\n+  }\n+\n+  GST_LOG (\"good:%d, bad:%d, pps:%d, sps:%d, vps:%d, irap:%d\", good, bad,\n+      seen_pps, seen_sps, seen_vps, seen_irap);\n+\n+  if (good >= 2 && bad == 0) {\n+    GstTypeFindProbability probability = GST_TYPE_FIND_POSSIBLE;\n+\n+    if (seen_pps && seen_sps && seen_vps)\n+      probability = GST_TYPE_FIND_LIKELY;\n+\n+    gst_type_find_suggest (tf, probability, H266_VIDEO_CAPS);\n+  }\n+}\n+\n@@ -6686,0 +6780,148 @@\n+\/*** video\/x-av1 ***\/\n+\n+static GstStaticCaps av1_caps =\n+    GST_STATIC_CAPS\n+    (\"video\/x-av1,stream-format={obu-stream, annexb},alignment=none\");\n+\n+#define AV1_CAPS gst_static_caps_get(&av1_caps)\n+\n+static gboolean\n+av1_is_valid_obu_type (guint obu_type)\n+{\n+  if ((obu_type > 0 && obu_type < 9) || obu_type == 15)\n+    return TRUE;\n+\n+  return FALSE;\n+}\n+\n+static gboolean\n+av1_leb128 (const guint8 * data, guint32 * retval, gint * read_bytes)\n+{\n+  guint8 leb128_byte = 0;\n+  guint64 value = 0;\n+  gint i;\n+\n+  *retval = 0;\n+  *read_bytes = 0;\n+\n+  for (i = 0; i < 8; i++) {\n+    leb128_byte = data[i];\n+    value |= (((gint) leb128_byte & 0x7f) << (i * 7));\n+    if (!(leb128_byte & 0x80))\n+      break;\n+\n+    if (i == 7 && leb128_byte & 0x80)\n+      return FALSE;\n+  }\n+\n+  if (i == 8)\n+    return FALSE;\n+\n+  \/* check for bitstream conformance see chapter 4.10.5 *\/\n+  if (value < G_MAXUINT32) {\n+    *retval = (guint32) value;\n+    *read_bytes = i + 1;\n+    return TRUE;\n+  }\n+\n+  return FALSE;\n+}\n+\n+static gboolean\n+av1_is_valid_obu (const guint8 * data, guint * obu_type, gint * read_bytes)\n+{\n+  gboolean obu_forbidden_bit;\n+  gboolean obu_extension_flag;\n+  gboolean obu_has_size_field;\n+  gboolean obu_reserved_1bit;\n+  int offset = 1;\n+\n+  *obu_type = 0;\n+  *read_bytes = 0;\n+\n+  \/* Detect OBU header *\/\n+  obu_forbidden_bit = !!(data[0] & 0x80);\n+  if (obu_forbidden_bit)\n+    return FALSE;\n+\n+  *obu_type = (data[0] & 0x78) >> 3;\n+  obu_extension_flag = !!(data[0] & 0x4);\n+  obu_has_size_field = !!(data[0] & 0x2);\n+  obu_reserved_1bit = !!(data[0] & 0x1);\n+\n+  \/* if obu_extension_flag is set temporal_id (3 bits)\n+   * spatial_id (2 bits) and extension_header_reserved_3bits (3 bits)\n+   * field are coded in the header so OBU size field is\n+   * 1 byte after *\/\n+  if (obu_extension_flag)\n+    offset++;\n+\n+  *read_bytes += offset;\n+\n+  if (av1_is_valid_obu_type (*obu_type) && !obu_reserved_1bit) {\n+    if (obu_has_size_field) {\n+      guint32 obu_size;\n+      gint bytes;\n+\n+      if (!av1_leb128 (data + offset, &obu_size, &bytes))\n+        return FALSE;\n+      *read_bytes += bytes;\n+    }\n+\n+    return TRUE;\n+  }\n+\n+  return FALSE;\n+}\n+\n+static void\n+av1_type_find (GstTypeFind * tf, gpointer unused)\n+{\n+  guint32 temporal_unit_size;\n+  guint32 frame_unit_size;\n+  guint32 obu_length;\n+  const guint8 *data;\n+  guint obu_type;\n+  gint read_bytes;\n+  gint offset = 0;\n+\n+  data = gst_type_find_peek (tf, 0, 25);\n+  if (!data)\n+    return;\n+\n+  if (av1_is_valid_obu (data, &obu_type, &read_bytes)) {\n+    gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MINIMUM, \"video\/x-av1\",\n+        \"stream-format\", G_TYPE_STRING, \"obu-stream\",\n+        \"alignment\", G_TYPE_STRING, \"none\", NULL);\n+    return;\n+  }\n+\n+  if (!av1_leb128 (data, &temporal_unit_size, &read_bytes))\n+    return;\n+  offset += read_bytes;\n+\n+  if (!av1_leb128 (data + offset, &frame_unit_size, &read_bytes))\n+    return;\n+  offset += read_bytes;\n+\n+  if (frame_unit_size > temporal_unit_size)\n+    return;\n+\n+  if (!av1_leb128 (data + offset, &obu_length, &read_bytes))\n+    return;\n+  offset += read_bytes;\n+\n+  if (obu_length > frame_unit_size)\n+    return;\n+\n+  if (!av1_is_valid_obu (data + offset, &obu_type, &read_bytes))\n+    return;\n+  offset += read_bytes;\n+\n+  \/* The first OBU must be a temporal delimiter *\/\n+  if (obu_type == 2)\n+    gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MINIMUM, \"video\/x-av1\",\n+        \"stream-format\", G_TYPE_STRING, \"annexb\",\n+        \"alignment\", G_TYPE_STRING, \"none\", NULL);\n+}\n+\n@@ -6746,0 +6988,2 @@\n+GST_TYPE_FIND_REGISTER_DEFINE (h266_video, \"video\/x-h266\", GST_RANK_PRIMARY,\n+    h266_video_type_find, \"h266,266\", H266_VIDEO_CAPS, NULL, NULL);\n@@ -6950,0 +7194,2 @@\n+GST_TYPE_FIND_REGISTER_DEFINE (av1, \"video\/x-av1\", GST_RANK_MARGINAL,\n+    av1_type_find, \"av1\", AV1_CAPS, NULL, NULL);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/typefind\/gsttypefindfunctions.c","additions":248,"deletions":2,"binary":false,"changes":250,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+  GST_TYPE_FIND_REGISTER (h266_video, plugin);\n@@ -222,0 +223,1 @@\n+  GST_TYPE_FIND_REGISTER (av1, plugin);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/typefind\/gsttypefindfunctionsplugin.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+GST_TYPE_FIND_REGISTER_DECLARE (h266_video);\n@@ -222,0 +223,1 @@\n+GST_TYPE_FIND_REGISTER_DECLARE (av1);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/typefind\/gsttypefindfunctionsplugin.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n@@ -109,1 +108,2 @@\n-    GST_AUDIO_CAPS_MAKE (\"{ F32LE, F64LE, S8, S16LE, S24LE, S32LE }\") \\\n+    GST_AUDIO_CAPS_MAKE (\"{ \" GST_AUDIO_NE (F32) \", \" GST_AUDIO_NE (F64) \", S8, \" \\\n+    GST_AUDIO_NE (S16) \", \" GST_AUDIO_NE (S24) \", \" GST_AUDIO_NE (S32) \" }\") \\\n@@ -111,5 +111,0 @@\n-#else\n-#define ALLOWED_CAPS \\\n-    GST_AUDIO_CAPS_MAKE (\"{ F32BE, F64BE, S8, S16BE, S24BE, S32BE }\") \\\n-    \", layout = (string) { interleaved, non-interleaved }\"\n-#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/volume\/gstvolume.c","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -558,0 +558,6 @@\n+  guint8 program_config_skipping_data;\n+  guint8 mixdown_present_skipflag;\n+  guint8 is_cpe;\n+  guint8 total_num_channel_elements;\n+  guint8 total_num_channel;\n+  guint8 channel_element_tag;\n@@ -571,1 +577,1 @@\n-  if (!gst_bit_reader_get_bits_uint8 (br, &num_lfe_channel_elements, 4))\n+  if (!gst_bit_reader_get_bits_uint8 (br, &num_lfe_channel_elements, 2))\n@@ -573,5 +579,47 @@\n-  GST_LOG_OBJECT (aacparse, \"channels front %d side %d back %d lfe %d \",\n-      num_front_channel_elements, num_side_channel_elements,\n-      num_back_channel_elements, num_lfe_channel_elements);\n-  *channels = num_front_channel_elements + num_side_channel_elements +\n-      num_back_channel_elements + num_lfe_channel_elements;\n+\n+  \/\/ skip num_assoc_data_elements + num_valid_cc_elements\n+  if (!gst_bit_reader_get_bits_uint8 (br, &program_config_skipping_data, 7))\n+    return FALSE;\n+\n+  if (!gst_bit_reader_get_bits_uint8 (br, &mixdown_present_skipflag, 1))\n+    return FALSE;\n+\n+  \/\/ skip mono_mixdown_element_number\n+  if (mixdown_present_skipflag)\n+    if (!gst_bit_reader_get_bits_uint8 (br, &program_config_skipping_data, 4))\n+      return FALSE;\n+\n+  if (!gst_bit_reader_get_bits_uint8 (br, &mixdown_present_skipflag, 1))\n+    return FALSE;\n+\n+  \/\/ skip stereo_mixdown_element_number\n+  if (mixdown_present_skipflag)\n+    if (!gst_bit_reader_get_bits_uint8 (br, &program_config_skipping_data, 4))\n+      return FALSE;\n+\n+  if (!gst_bit_reader_get_bits_uint8 (br, &mixdown_present_skipflag, 1))\n+    return FALSE;\n+\n+  \/\/ skip matrix_mixdown_idx + pseudo_surround_enable\n+  if (mixdown_present_skipflag) {\n+    if (!gst_bit_reader_get_bits_uint8 (br, &program_config_skipping_data, 3))\n+      return FALSE;\n+  }\n+\n+  total_num_channel_elements =\n+      num_front_channel_elements + num_side_channel_elements +\n+      num_back_channel_elements;\n+\n+  total_num_channel = total_num_channel_elements + num_lfe_channel_elements;\n+  \/\/ If cpe (coupled), then each single channel element represents two channels\n+  for (guint8 i = 0; i < total_num_channel_elements; i++) {\n+    if (!gst_bit_reader_get_bits_uint8 (br, &is_cpe, 1))\n+      return FALSE;\n+    if (is_cpe)\n+      total_num_channel += 1;\n+    if (!gst_bit_reader_get_bits_uint8 (br, &channel_element_tag, 4))\n+      return FALSE;\n+  }\n+\n+  *channels = total_num_channel;\n+  GST_LOG_OBJECT (aacparse, \"total channels : %d\", *channels);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/audioparsers\/gstaacparse.c","additions":54,"deletions":6,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+#define FOURCC_H266     GST_MAKE_FOURCC('H','2','6','6')\n+#define FOURCC_LAGS     GST_MAKE_FOURCC('L','A','G','S')\n@@ -62,0 +64,1 @@\n+#define FOURCC_QDMC     GST_MAKE_FOURCC('Q','D','M','C')\n@@ -118,0 +121,1 @@\n+#define FOURCC_cmpd     GST_MAKE_FOURCC('c','m','p','d')\n@@ -213,0 +217,2 @@\n+#define FOURCC_clli     GST_MAKE_FOURCC('c','l','l','i')\n+#define FOURCC_mdcv     GST_MAKE_FOURCC('m','d','c','v')\n@@ -282,0 +288,2 @@\n+#define FOURCC_uncC     GST_MAKE_FOURCC('u','n','c','C')\n+#define FOURCC_uncv     GST_MAKE_FOURCC('u','n','c','v')\n@@ -295,0 +303,3 @@\n+#define FOURCC_vvc1     GST_MAKE_FOURCC('v','v','c','1')\n+#define FOURCC_vvcC     GST_MAKE_FOURCC('v','v','c','C')\n+#define FOURCC_vvi1     GST_MAKE_FOURCC('v','v','i','1')\n@@ -301,0 +312,5 @@\n+#define FOURCC_ipcm     GST_MAKE_FOURCC('i','p','c','m')\n+#define FOURCC_fpcm     GST_MAKE_FOURCC('f','p','c','m')\n+#define FOURCC_pcmC     GST_MAKE_FOURCC('p','c','m','C')\n+#define FOURCC_chnl     GST_MAKE_FOURCC('c','h','n','l')\n+#define FOURCC_chan     GST_MAKE_FOURCC('c','h','a','n')\n@@ -451,0 +467,9 @@\n+\/* Hap video codec *\/\n+#define FOURCC_Hap1     GST_MAKE_FOURCC('H','a','p','1')\n+#define FOURCC_Hap5     GST_MAKE_FOURCC('H','a','p','5')\n+#define FOURCC_HapY     GST_MAKE_FOURCC('H','a','p','Y')\n+#define FOURCC_HapM     GST_MAKE_FOURCC('H','a','p','M')\n+#define FOURCC_HapA     GST_MAKE_FOURCC('H','a','p','A')\n+#define FOURCC_Hap7     GST_MAKE_FOURCC('H','a','p','7')\n+#define FOURCC_HapH     GST_MAKE_FOURCC('H','a','p','H')\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/fourcc.h","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-\n+      \/* FALLTHROUGH *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/gstisoff.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-    const guint8 * stsd_entry_data, gchar ** codec_name);\n+    GNode * stsd_entry, gchar ** codec_name);\n@@ -376,1 +376,2 @@\n-    const guint8 * data, int len, gchar ** codec_name);\n+    guint8 stsd_version, guint32 version, GNode * stsd_entry,\n+    gchar ** codec_name);\n@@ -378,1 +379,1 @@\n-    QtDemuxStreamStsdEntry * entry, guint32 fourcc, const guint8 * data,\n+    QtDemuxStreamStsdEntry * entry, guint32 fourcc, GNode * stsd_entry,\n@@ -381,1 +382,1 @@\n-    QtDemuxStreamStsdEntry * entry, guint32 fourcc, const guint8 * data,\n+    QtDemuxStreamStsdEntry * entry, guint32 fourcc, GNode * stsd_entry,\n@@ -385,1 +386,1 @@\n-    const guint8 * stsd_entry_data, gchar ** codec_name);\n+    GNode * stsd_entry, gchar ** codec_name);\n@@ -1935,0 +1936,1 @@\n+  stream->needs_row_alignment = FALSE;\n@@ -1938,0 +1940,2 @@\n+  gst_video_info_init (&stream->info);\n+  gst_video_info_init (&stream->pre_info);\n@@ -3681,1 +3685,1 @@\n-  GST_DEBUG_OBJECT (qtdemux, \"Using clsg_shift %\" G_GUINT64_FORMAT,\n+  GST_DEBUG_OBJECT (qtdemux, \"Using cslg_shift %\" G_GUINT64_FORMAT,\n@@ -4562,1 +4566,1 @@\n-              FOURCC_sgpd, &sbgp_data);\n+              FOURCC_sbgp, &sbgp_data);\n@@ -6187,0 +6191,30 @@\n+static GstBuffer *\n+gst_qtdemux_reorder_audio_channels (GstQTDemux * demux,\n+    QtDemuxStream * stream, GstBuffer * buffer)\n+{\n+  buffer = gst_buffer_make_writable (buffer);\n+\n+  GstMapInfo map;\n+\n+  if (!gst_buffer_map (buffer, &map, GST_MAP_READWRITE))\n+    return buffer;\n+\n+  if (map.size % (CUR_STREAM (stream)->bytes_per_sample *\n+          CUR_STREAM (stream)->n_channels) != 0) {\n+    GST_WARNING_OBJECT (demux,\n+        \"Odd number of frames in raw audio buffer of length %\" G_GSIZE_FORMAT\n+        \" with %u bps and %u channels\", map.size,\n+        CUR_STREAM (stream)->bytes_per_sample, CUR_STREAM (stream)->n_channels);\n+    goto out;\n+  }\n+\n+  gst_audio_reorder_channels_with_reorder_map (map.data, map.size,\n+      CUR_STREAM (stream)->bytes_per_sample, CUR_STREAM (stream)->n_channels,\n+      CUR_STREAM (stream)->reorder_map);\n+\n+out:\n+  gst_buffer_unmap (buffer, &map);\n+\n+  return buffer;\n+}\n+\n@@ -6225,0 +6259,65 @@\n+\/* Adds padding to the end of each row to achieve byte-alignment\n+ *\n+ * Returns NULL if failed\n+ *\/\n+static GstBuffer *\n+gst_qtdemux_row_align_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,\n+    GstBuffer * pre_buffer)\n+{\n+  GstVideoFrame pre_frame;\n+  GstVideoFrame new_frame;\n+  GstVideoInfo pre_info = stream->pre_info;\n+  GstVideoInfo new_info = stream->info;\n+  GstBuffer *new_buffer = NULL;\n+  gboolean pre_frame_mapped = FALSE;\n+  gboolean new_frame_mapped = FALSE;\n+\n+  \/* Map Buffer to Frame *\/\n+  pre_frame_mapped =\n+      gst_video_frame_map (&pre_frame, &pre_info, pre_buffer, GST_MAP_READ);\n+  if (!pre_frame_mapped) {\n+    GST_ERROR_OBJECT (qtdemux, \"Failed to map video frame.\");\n+    goto error;\n+  }\n+\n+  \/* Allocate New Buffer *\/\n+  GstAllocationParams params = { 0, stream->alignment - 1, 0, 0, };\n+  new_buffer = gst_buffer_new_allocate (NULL, new_info.size, &params);\n+  if (!new_buffer) {\n+    GST_ERROR_OBJECT (qtdemux, \"Failed to allocate new buffer.\");\n+    goto error;\n+  }\n+\n+  \/* Map New Frame *\/\n+  new_frame_mapped =\n+      gst_video_frame_map (&new_frame, &new_info, new_buffer, GST_MAP_WRITE);\n+  if (!new_frame_mapped) {\n+    GST_ERROR_OBJECT (qtdemux, \"Failed to map new video frame.\");\n+    goto error;\n+  }\n+\n+  \/* Copying the frame will automatically row-align the buffer *\/\n+  if (!gst_video_frame_copy (&new_frame, &pre_frame)) {\n+    GST_ERROR_OBJECT (qtdemux, \"Failed to copy video frame.\");\n+    goto error;\n+  }\n+\n+  \/* Cleanup before returning *\/\n+  gst_video_frame_unmap (&pre_frame);\n+  gst_video_frame_unmap (&new_frame);\n+  gst_buffer_unref (pre_buffer);\n+  return new_buffer;\n+\n+error:\n+  if (new_frame_mapped) {\n+    gst_video_frame_unmap (&new_frame);\n+  }\n+  if (pre_frame_mapped) {\n+    gst_video_frame_unmap (&pre_frame);\n+  }\n+  if (new_buffer) {\n+    gst_buffer_unref (new_buffer);\n+  }\n+  return NULL;\n+}\n+\n@@ -6677,1 +6776,8 @@\n-  if (stream->alignment > 1)\n+  \/* Copy buffer to ensure alignment *\/\n+  if (stream->needs_row_alignment) {\n+    buf = gst_qtdemux_row_align_buffer (qtdemux, stream, buf);\n+    if (buf == NULL) {\n+      ret = GST_FLOW_ERROR;\n+      goto exit;\n+    }\n+  } else if (stream->alignment > 1) {\n@@ -6679,0 +6785,4 @@\n+  }\n+\n+  if (CUR_STREAM (stream)->needs_reorder)\n+    buf = gst_qtdemux_reorder_audio_channels (qtdemux, stream, buf);\n@@ -6879,0 +6989,3 @@\n+    if (CUR_STREAM (stream)->needs_reorder)\n+      buffer = gst_qtdemux_reorder_audio_channels (qtdemux, stream, buffer);\n+\n@@ -7480,0 +7593,15 @@\n+          \/* segment.position will still be at the last timestamp and won't always\n+           * include the duration of the last packet. Expand that to the segment\n+           * duration so that segment.base is increased correctly to include the\n+           * length of the last packet when doing segment seeks. We need to do\n+           * this before the segment-done event goes out so everything's ready\n+           * for the next seek request coming in. *\/\n+          if (GST_CLOCK_TIME_IS_VALID (stop)) {\n+            GST_DEBUG_OBJECT (qtdemux,\n+                \"End of segment, updating segment.position from %\"\n+                GST_TIME_FORMAT \" to stop %\" GST_TIME_FORMAT,\n+                GST_TIME_ARGS (qtdemux->segment.position),\n+                GST_TIME_ARGS (stop));\n+            qtdemux->segment.position = stop;\n+          }\n+\n@@ -8588,0 +8716,7 @@\n+          } else if ((demux->segment.flags &\n+                  GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS) != 0 &&\n+              stream->subtype == FOURCC_vide && !keyframe) {\n+            GST_LOG_OBJECT (demux, \"Skipping non-keyframe on track-id %u\",\n+                stream->track_id);\n+            gst_adapter_flush (demux->adapter, demux->neededbytes);\n+            ret = GST_FLOW_OK;\n@@ -8922,61 +9057,0 @@\n-static gboolean\n-qtdemux_parse_theora_extension (GstQTDemux * qtdemux, QtDemuxStream * stream,\n-    GNode * xdxt)\n-{\n-  int len = QT_UINT32 (xdxt->data);\n-  guint8 *buf = xdxt->data;\n-  guint8 *end = buf + len;\n-  GstBuffer *buffer;\n-\n-  \/* skip size and type *\/\n-  buf += 8;\n-  end -= 8;\n-\n-  while (buf < end) {\n-    guint32 size;\n-    guint32 type;\n-\n-    size = QT_UINT32 (buf);\n-    type = QT_FOURCC (buf + 4);\n-\n-    GST_LOG_OBJECT (qtdemux, \"%p %p\", buf, end);\n-\n-    if (end - buf < size || size < 8)\n-      break;\n-\n-    buf += 8;\n-    size -= 8;\n-\n-    GST_WARNING_OBJECT (qtdemux, \"have cookie %\" GST_FOURCC_FORMAT,\n-        GST_FOURCC_ARGS (type));\n-\n-    switch (type) {\n-      case FOURCC_tCtH:\n-        buffer = gst_buffer_new_and_alloc (size);\n-        gst_buffer_fill (buffer, 0, buf, size);\n-        stream->buffers = g_slist_append (stream->buffers, buffer);\n-        GST_LOG_OBJECT (qtdemux, \"parsing theora header\");\n-        break;\n-      case FOURCC_tCt_:\n-        buffer = gst_buffer_new_and_alloc (size);\n-        gst_buffer_fill (buffer, 0, buf, size);\n-        stream->buffers = g_slist_append (stream->buffers, buffer);\n-        GST_LOG_OBJECT (qtdemux, \"parsing theora comment\");\n-        break;\n-      case FOURCC_tCtC:\n-        buffer = gst_buffer_new_and_alloc (size);\n-        gst_buffer_fill (buffer, 0, buf, size);\n-        stream->buffers = g_slist_append (stream->buffers, buffer);\n-        GST_LOG_OBJECT (qtdemux, \"parsing theora codebook\");\n-        break;\n-      default:\n-        GST_WARNING_OBJECT (qtdemux,\n-            \"unknown theora cookie %\" GST_FOURCC_FORMAT,\n-            GST_FOURCC_ARGS (type));\n-        break;\n-    }\n-    buf += size;\n-  }\n-  return TRUE;\n-}\n-\n@@ -9036,0 +9110,45 @@\n+      case FOURCC_lpcm:\n+      case FOURCC_wma_:\n+      case FOURCC_owma:\n+      case FOURCC_sowt:\n+      case FOURCC_twos:\n+      case FOURCC_in24:\n+      case FOURCC_in32:\n+      case FOURCC_fl32:\n+      case FOURCC_fl64:\n+      case FOURCC_s16l:\n+      case FOURCC_ipcm:\n+      case FOURCC_fpcm:\n+      case FOURCC_samr:\n+      case FOURCC_sawb:\n+      case FOURCC_QDM2:\n+      case FOURCC_QDMC:\n+      case FOURCC_MAC6:\n+      case FOURCC_MAC3:\n+      case FOURCC_ima4:\n+      case FOURCC_ulaw:\n+      case FOURCC_alaw:\n+      case FOURCC_agsm:\n+      case 0x20736d:\n+      case GST_MAKE_FOURCC ('e', 'c', '-', '3'):\n+      case GST_MAKE_FOURCC ('s', 'a', 'c', '3'):       \/\/ Nero Recode\n+      case FOURCC_ac_3:\n+      case 0x0200736d:\n+      case 0x6d730002:\n+      case 0x1100736d:\n+      case 0x6d730011:\n+      case 0x1700736d:\n+      case 0x6d730017:\n+      case 0x5500736d:\n+      case 0x6d730055:\n+      case FOURCC__mp3:\n+      case FOURCC_mp3_:\n+      case GST_MAKE_FOURCC ('.', 'm', 'p', '2'):\n+      case GST_MAKE_FOURCC ('d', 't', 's', 'c'):\n+      case GST_MAKE_FOURCC ('D', 'T', 'S', ' '):\n+      case GST_MAKE_FOURCC ('O', 'g', 'g', 'V'):\n+      case GST_MAKE_FOURCC ('d', 'v', 'c', 'a'):\n+      case GST_MAKE_FOURCC ('Q', 'c', 'l', 'p'):\n+      case GST_MAKE_FOURCC ('a', 'c', '-', '4'):\n+      case FOURCC_enca:\n+        \/* FIXME FOURCC_raw_ but that is used for video too *\/\n@@ -9037,0 +9156,1 @@\n+        guint8 stsd_version;\n@@ -9065,2 +9185,1 @@\n-           in Movies.h) *\/\n-        version = QT_UINT16 (buffer + 16);\n+           in Movies.h).\n@@ -9068,2 +9187,6 @@\n-        GST_DEBUG_OBJECT (qtdemux, \"%\" GST_FOURCC_FORMAT \" version 0x%08x\",\n-            GST_FOURCC_ARGS (fourcc), version);\n+           For ISOBMFF there's only version 0 and 1, and both have the same size.\n+           The distinction between the two version 1 can be made via the stsd (parent)\n+           node version.\n+         *\/\n+        stsd_version = QT_UINT8 ((const guint8 *) node->data + 8);\n+        version = QT_UINT16 (buffer + 16);\n@@ -9071,17 +9194,40 @@\n-        \/* parse any esds descriptors *\/\n-        switch (version) {\n-          case 0:\n-            offset = 0x24;\n-            break;\n-          case 1:\n-            offset = 0x34;\n-            break;\n-          case 2:\n-            offset = 0x48;\n-            break;\n-          default:\n-            GST_WARNING_OBJECT (qtdemux,\n-                \"unhandled %\" GST_FOURCC_FORMAT \" version 0x%08x\",\n-                GST_FOURCC_ARGS (fourcc), version);\n-            offset = 0;\n-            break;\n+        GST_DEBUG_OBJECT (qtdemux,\n+            \"%\" GST_FOURCC_FORMAT \" stsd version %u version %u\",\n+            GST_FOURCC_ARGS (fourcc), stsd_version, version);\n+\n+        if (stsd_version == 0) {\n+          \/* parse any esds descriptors and other optional boxes *\/\n+          switch (version) {\n+            case 0:\n+              offset = 36;\n+              break;\n+            case 1:\n+              offset = 52;\n+              break;\n+            case 2:\n+              offset = 72;\n+              break;\n+            default:\n+              GST_WARNING_OBJECT (qtdemux,\n+                  \"unhandled %\" GST_FOURCC_FORMAT \" version %u\",\n+                  GST_FOURCC_ARGS (fourcc), version);\n+              offset = 0;\n+              break;\n+          }\n+        } else if (stsd_version == 1) {\n+          switch (version) {\n+            case 0:\n+            case 1:\n+              offset = 36;\n+              break;\n+            default:\n+              GST_WARNING_OBJECT (qtdemux,\n+                  \"unhandled %\" GST_FOURCC_FORMAT \" version %u\",\n+                  GST_FOURCC_ARGS (fourcc), version);\n+              offset = 0;\n+              break;\n+          }\n+        } else {\n+          GST_WARNING_OBJECT (qtdemux,\n+              \"unhandled stsd version %u\", stsd_version);\n+          offset = 0;\n@@ -9089,0 +9235,1 @@\n+\n@@ -9102,0 +9249,1 @@\n+      case FOURCC_ap4x:\n@@ -9106,0 +9254,1 @@\n+      case FOURCC_dva1:\n@@ -9107,0 +9256,13 @@\n+      case FOURCC_dvav:\n+      case FOURCC_ai12:\n+      case FOURCC_ai13:\n+      case FOURCC_ai15:\n+      case FOURCC_ai16:\n+      case FOURCC_ai1p:\n+      case FOURCC_ai1q:\n+      case FOURCC_ai52:\n+      case FOURCC_ai53:\n+      case FOURCC_ai55:\n+      case FOURCC_ai56:\n+      case FOURCC_ai5p:\n+      case FOURCC_ai5q:\n@@ -9114,0 +9276,143 @@\n+      case FOURCC_H266:\n+      case FOURCC_vvc1:\n+      case FOURCC_vvi1:\n+      case FOURCC_av01:\n+      case FOURCC_uncv:\n+      case FOURCC_SVQ3:\n+      case FOURCC_VP31:\n+      case FOURCC_jpeg:\n+      case FOURCC_rle_:\n+      case FOURCC_WRLE:\n+      case FOURCC_ovc1:\n+      case FOURCC_vc_1:\n+      case FOURCC_VP80:\n+      case FOURCC_vp08:\n+      case FOURCC_vp09:\n+      case FOURCC_png:\n+      case GST_MAKE_FOURCC ('m', 'j', 'p', 'a'):\n+      case GST_MAKE_FOURCC ('A', 'V', 'D', 'J'):\n+      case GST_MAKE_FOURCC ('M', 'J', 'P', 'G'):\n+      case GST_MAKE_FOURCC ('d', 'm', 'b', '1'):\n+      case GST_MAKE_FOURCC ('m', 'j', 'p', 'b'):\n+      case GST_MAKE_FOURCC ('s', 'v', 'q', 'i'):\n+      case GST_MAKE_FOURCC ('S', 'V', 'Q', '1'):\n+      case GST_MAKE_FOURCC ('W', 'R', 'A', 'W'):\n+      case GST_MAKE_FOURCC ('y', 'v', '1', '2'):\n+      case GST_MAKE_FOURCC ('y', 'u', 'v', '2'):\n+      case GST_MAKE_FOURCC ('Y', 'u', 'v', '2'):\n+      case GST_MAKE_FOURCC ('2', 'V', 'u', 'y'):\n+      case GST_MAKE_FOURCC ('v', '3', '0', '8'):\n+      case GST_MAKE_FOURCC ('v', '2', '1', '6'):\n+      case FOURCC_v210:\n+      case GST_MAKE_FOURCC ('r', '2', '1', '0'):\n+      case GST_MAKE_FOURCC ('m', 'p', 'e', 'g'):\n+      case GST_MAKE_FOURCC ('m', 'p', 'g', '1'):\n+      case GST_MAKE_FOURCC ('m', '1', 'v', ' '):\n+      case GST_MAKE_FOURCC ('h', 'd', 'v', '1'):\n+      case GST_MAKE_FOURCC ('h', 'd', 'v', '2'):\n+      case GST_MAKE_FOURCC ('h', 'd', 'v', '3'):\n+      case GST_MAKE_FOURCC ('h', 'd', 'v', '4'):\n+      case GST_MAKE_FOURCC ('h', 'd', 'v', '5'):\n+      case GST_MAKE_FOURCC ('h', 'd', 'v', '6'):\n+      case GST_MAKE_FOURCC ('h', 'd', 'v', '7'):\n+      case GST_MAKE_FOURCC ('h', 'd', 'v', '8'):\n+      case GST_MAKE_FOURCC ('h', 'd', 'v', '9'):\n+      case GST_MAKE_FOURCC ('h', 'd', 'v', 'a'):\n+      case GST_MAKE_FOURCC ('m', 'x', '5', 'n'):\n+      case GST_MAKE_FOURCC ('m', 'x', '5', 'p'):\n+      case GST_MAKE_FOURCC ('m', 'x', '4', 'n'):\n+      case GST_MAKE_FOURCC ('m', 'x', '4', 'p'):\n+      case GST_MAKE_FOURCC ('m', 'x', '3', 'n'):\n+      case GST_MAKE_FOURCC ('m', 'x', '3', 'p'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', '1'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', '2'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', '3'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', '4'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', '5'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', '6'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', '7'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', '8'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', '9'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', 'a'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', 'b'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', 'c'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', 'd'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', 'e'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'v', 'f'):\n+      case GST_MAKE_FOURCC ('x', 'd', '5', '1'):\n+      case GST_MAKE_FOURCC ('x', 'd', '5', '4'):\n+      case GST_MAKE_FOURCC ('x', 'd', '5', '5'):\n+      case GST_MAKE_FOURCC ('x', 'd', '5', '9'):\n+      case GST_MAKE_FOURCC ('x', 'd', '5', 'a'):\n+      case GST_MAKE_FOURCC ('x', 'd', '5', 'b'):\n+      case GST_MAKE_FOURCC ('x', 'd', '5', 'c'):\n+      case GST_MAKE_FOURCC ('x', 'd', '5', 'd'):\n+      case GST_MAKE_FOURCC ('x', 'd', '5', 'e'):\n+      case GST_MAKE_FOURCC ('x', 'd', '5', 'f'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'h', 'd'):\n+      case GST_MAKE_FOURCC ('x', 'd', 'h', '2'):\n+      case GST_MAKE_FOURCC ('A', 'V', 'm', 'p'):\n+      case GST_MAKE_FOURCC ('m', 'p', 'g', '2'):\n+      case GST_MAKE_FOURCC ('m', 'p', '2', 'v'):\n+      case GST_MAKE_FOURCC ('m', '2', 'v', '1'):\n+      case GST_MAKE_FOURCC ('g', 'i', 'f', ' '):\n+      case FOURCC_h263:\n+      case GST_MAKE_FOURCC ('H', '2', '6', '3'):\n+      case FOURCC_s263:\n+      case GST_MAKE_FOURCC ('U', '2', '6', '3'):\n+      case GST_MAKE_FOURCC ('3', 'i', 'v', 'd'):\n+      case GST_MAKE_FOURCC ('3', 'I', 'V', 'D'):\n+      case GST_MAKE_FOURCC ('D', 'I', 'V', '3'):\n+      case GST_MAKE_FOURCC ('D', 'I', 'V', 'X'):\n+      case GST_MAKE_FOURCC ('d', 'i', 'v', 'x'):\n+      case GST_MAKE_FOURCC ('D', 'X', '5', '0'):\n+      case GST_MAKE_FOURCC ('F', 'F', 'V', '1'):\n+      case GST_MAKE_FOURCC ('3', 'I', 'V', '1'):\n+      case GST_MAKE_FOURCC ('3', 'I', 'V', '2'):\n+      case GST_MAKE_FOURCC ('U', 'M', 'P', '4'):\n+      case GST_MAKE_FOURCC ('c', 'v', 'i', 'd'):\n+      case GST_MAKE_FOURCC ('q', 'd', 'r', 'w'):\n+      case GST_MAKE_FOURCC ('r', 'p', 'z', 'a'):\n+      case GST_MAKE_FOURCC ('I', 'V', '3', '2'):\n+      case GST_MAKE_FOURCC ('i', 'v', '3', '2'):\n+      case GST_MAKE_FOURCC ('I', 'V', '4', '1'):\n+      case GST_MAKE_FOURCC ('i', 'v', '4', '1'):\n+      case FOURCC_dvcp:\n+      case FOURCC_dvc_:\n+      case GST_MAKE_FOURCC ('d', 'v', 's', 'd'):\n+      case GST_MAKE_FOURCC ('D', 'V', 'S', 'D'):\n+      case GST_MAKE_FOURCC ('d', 'v', 'c', 's'):\n+      case GST_MAKE_FOURCC ('D', 'V', 'C', 'S'):\n+      case GST_MAKE_FOURCC ('d', 'v', '2', '5'):\n+      case GST_MAKE_FOURCC ('d', 'v', 'p', 'p'):\n+      case FOURCC_dv5n:\n+      case FOURCC_dv5p:\n+      case GST_MAKE_FOURCC ('d', 'v', 'h', '5'):\n+      case GST_MAKE_FOURCC ('d', 'v', 'h', '6'):\n+      case GST_MAKE_FOURCC ('s', 'm', 'c', ' '):\n+      case GST_MAKE_FOURCC ('V', 'P', '6', 'F'):\n+      case FOURCC_drac:\n+      case GST_MAKE_FOURCC ('t', 'i', 'f', 'f'):\n+      case GST_MAKE_FOURCC ('i', 'c', 'o', 'd'):\n+      case GST_MAKE_FOURCC ('A', 'V', 'd', 'n'):\n+      case GST_MAKE_FOURCC ('A', 'V', 'd', 'h'):\n+      case FOURCC_cfhd:\n+      case FOURCC_SHQ0:\n+      case FOURCC_SHQ1:\n+      case FOURCC_SHQ2:\n+      case FOURCC_SHQ3:\n+      case FOURCC_SHQ4:\n+      case FOURCC_SHQ5:\n+      case FOURCC_SHQ6:\n+      case FOURCC_SHQ7:\n+      case FOURCC_SHQ8:\n+      case FOURCC_SHQ9:\n+      case FOURCC_LAGS:\n+      case FOURCC_Hap1:\n+      case FOURCC_Hap5:\n+      case FOURCC_HapY:\n+      case FOURCC_HapM:\n+      case FOURCC_HapA:\n+      case FOURCC_Hap7:\n+      case FOURCC_HapH:\n+        \/* FIXME FOURCC_raw_ but that is used for audio too *\/\n@@ -9223,5 +9528,0 @@\n-      case FOURCC_in24:\n-      {\n-        qtdemux_parse_container (qtdemux, node, buffer + 0x34, end);\n-        break;\n-      }\n@@ -9233,5 +9533,0 @@\n-      case FOURCC_enca:\n-      {\n-        qtdemux_parse_container (qtdemux, node, buffer + 36, end);\n-        break;\n-      }\n@@ -9675,0 +9970,10 @@\n+      if (CUR_STREAM (stream)->content_light_level_set) {\n+        gst_video_content_light_level_add_to_caps (&CUR_STREAM\n+            (stream)->content_light_level, CUR_STREAM (stream)->caps);\n+      }\n+\n+      if (CUR_STREAM (stream)->mastering_display_info_set) {\n+        gst_video_mastering_display_info_add_to_caps (&CUR_STREAM\n+            (stream)->mastering_display_info, CUR_STREAM (stream)->caps);\n+      }\n+\n@@ -10191,2 +10496,1 @@\n-      stream->n_samples_per_chunk * 3 * 4 +\n-      (stream->n_samples_per_chunk - 1) * 4) {\n+      stream->n_samples_per_chunk * 3 * 4) {\n@@ -10558,1 +10862,1 @@\n-  GST_DEBUG_OBJECT (qtdemux, \"Using clsg_shift %\" G_GUINT64_FORMAT,\n+  GST_DEBUG_OBJECT (qtdemux, \"Using cslg_shift %\" G_GUINT64_FORMAT,\n@@ -11241,97 +11545,0 @@\n-\/*\n- * Parses the stsd atom of a svq3 trak looking for\n- * the SMI and gama atoms.\n- *\/\n-static void\n-qtdemux_parse_svq3_stsd_data (GstQTDemux * qtdemux,\n-    const guint8 * stsd_entry_data, const guint8 ** gamma, GstBuffer ** seqh)\n-{\n-  const guint8 *_gamma = NULL;\n-  GstBuffer *_seqh = NULL;\n-  const guint8 *stsd_data = stsd_entry_data;\n-  guint32 length = QT_UINT32 (stsd_data);\n-  guint16 version;\n-\n-  if (length < 32) {\n-    GST_WARNING_OBJECT (qtdemux, \"stsd too short\");\n-    goto end;\n-  }\n-\n-  stsd_data += 16;\n-  length -= 16;\n-  version = QT_UINT16 (stsd_data);\n-  if (version == 3) {\n-    if (length >= 70) {\n-      length -= 70;\n-      stsd_data += 70;\n-      while (length > 8) {\n-        guint32 fourcc, size;\n-        const guint8 *data;\n-        size = QT_UINT32 (stsd_data);\n-        fourcc = QT_FOURCC (stsd_data + 4);\n-        data = stsd_data + 8;\n-\n-        if (size == 0) {\n-          GST_WARNING_OBJECT (qtdemux, \"Atom of size 0 found, aborting \"\n-              \"svq3 atom parsing\");\n-          goto end;\n-        }\n-\n-        switch (fourcc) {\n-          case FOURCC_gama:{\n-            if (size == 12) {\n-              _gamma = data;\n-            } else {\n-              GST_WARNING_OBJECT (qtdemux, \"Unexpected size %\" G_GUINT32_FORMAT\n-                  \" for gama atom, expected 12\", size);\n-            }\n-            break;\n-          }\n-          case FOURCC_SMI_:{\n-            if (size > 16 && QT_FOURCC (data) == FOURCC_SEQH) {\n-              guint32 seqh_size;\n-              if (_seqh != NULL) {\n-                GST_WARNING_OBJECT (qtdemux, \"Unexpected second SEQH SMI atom \"\n-                    \" found, ignoring\");\n-              } else {\n-                \/* Note: The size does *not* include the fourcc and the size field itself *\/\n-                seqh_size = QT_UINT32 (data + 4);\n-                if (seqh_size > 0 && seqh_size <= size - 8) {\n-                  _seqh = gst_buffer_new_and_alloc (seqh_size);\n-                  gst_buffer_fill (_seqh, 0, data + 8, seqh_size);\n-                }\n-              }\n-            }\n-            break;\n-          }\n-          default:{\n-            GST_WARNING_OBJECT (qtdemux, \"Unhandled atom %\" GST_FOURCC_FORMAT\n-                \" in SVQ3 entry in stsd atom\", GST_FOURCC_ARGS (fourcc));\n-          }\n-        }\n-\n-        if (size <= length) {\n-          length -= size;\n-          stsd_data += size;\n-        }\n-      }\n-    } else {\n-      GST_WARNING_OBJECT (qtdemux, \"SVQ3 entry too short in stsd atom\");\n-    }\n-  } else {\n-    GST_WARNING_OBJECT (qtdemux, \"Unexpected version for SVQ3 entry %\"\n-        G_GUINT16_FORMAT, version);\n-    goto end;\n-  }\n-\n-end:\n-  if (gamma) {\n-    *gamma = _gamma;\n-  }\n-  if (seqh) {\n-    *seqh = _seqh;\n-  } else if (_seqh) {\n-    gst_buffer_unref (_seqh);\n-  }\n-}\n-\n@@ -11433,1 +11640,1 @@\n-qtdemux_parse_amr_bitrate (GstBuffer * buf, gboolean wb)\n+qtdemux_parse_amr_bitrate (const guint8 * data, guint32 len, gboolean wb)\n@@ -11452,1 +11659,0 @@\n-  GstMapInfo map;\n@@ -11456,4 +11662,2 @@\n-  gst_buffer_map (buf, &map, GST_MAP_READ);\n-\n-  if (map.size != 0x11) {\n-    GST_DEBUG (\"Atom should have size 0x11, not %\" G_GSIZE_FORMAT, map.size);\n+  if (len != 0x11) {\n+    GST_DEBUG (\"Atom should have size 0x11, not %u\", len);\n@@ -11463,1 +11667,1 @@\n-  if (QT_FOURCC (map.data + 4) != FOURCC_damr) {\n+  if (QT_FOURCC (data + 4) != FOURCC_damr) {\n@@ -11465,1 +11669,1 @@\n-        GST_FOURCC_ARGS (QT_UINT32 (map.data + 4)));\n+        GST_FOURCC_ARGS (QT_UINT32 (data + 4)));\n@@ -11469,1 +11673,1 @@\n-  mode_set = QT_UINT16 (map.data + 13);\n+  mode_set = QT_UINT16 (data + 13);\n@@ -11483,1 +11687,0 @@\n-  gst_buffer_unmap (buf, &map);\n@@ -11487,1 +11690,0 @@\n-  gst_buffer_unmap (buf, &map);\n@@ -11515,0 +11717,1 @@\n+  \/* The 2.30 value conversion does not work for negative values *\/\n@@ -11516,9 +11719,45 @@\n-  GST_DEBUG_OBJECT (qtdemux, \"%u.%u %u.%u %u.%u\", matrix[0] >> 16,\n-      matrix[0] & 0xFFFF, matrix[1] >> 16, matrix[1] & 0xFF, matrix[2] >> 16,\n-      matrix[2] & 0xFF);\n-  GST_DEBUG_OBJECT (qtdemux, \"%u.%u %u.%u %u.%u\", matrix[3] >> 16,\n-      matrix[3] & 0xFFFF, matrix[4] >> 16, matrix[4] & 0xFF, matrix[5] >> 16,\n-      matrix[5] & 0xFF);\n-  GST_DEBUG_OBJECT (qtdemux, \"%u.%u %u.%u %u.%u\", matrix[6] >> 16,\n-      matrix[6] & 0xFFFF, matrix[7] >> 16, matrix[7] & 0xFF, matrix[8] >> 16,\n-      matrix[8] & 0xFF);\n+  GST_DEBUG_OBJECT (qtdemux, \"%i.%u %i.%u %u.%u\", (gint16) (matrix[0] >> 16),\n+      matrix[0] & 0xFFFF, (gint16) (matrix[1] >> 16), matrix[1] & 0xFFFF,\n+      matrix[2] >> 30, matrix[2] & 0x3FFFFFFF);\n+  GST_DEBUG_OBJECT (qtdemux, \"%i.%u %i.%u %u.%u\", (gint16) (matrix[3] >> 16),\n+      matrix[3] & 0xFFFF, (gint16) (matrix[4] >> 16), matrix[4] & 0xFFFF,\n+      matrix[5] >> 30, matrix[5] & 0x3FFFFFFF);\n+  GST_DEBUG_OBJECT (qtdemux, \"%i.%u %i.%u %u.%u\", (gint16) (matrix[6] >> 16),\n+      matrix[6] & 0xFFFF, (gint16) (matrix[7] >> 16), matrix[7] & 0xFFFF,\n+      matrix[8] >> 30, matrix[8] & 0x3FFFFFFF);\n+\n+  return TRUE;\n+}\n+\n+\/* Check if all matrix elements are either 0, 1 or -1 *\/\n+static gboolean\n+qtdemux_transformation_matrix_is_simple (GstQTDemux * qtdemux, guint32 * m)\n+{\n+  int i;\n+\n+  for (i = 0; i < 9; i++) {\n+    switch (i) {\n+      case 2:\n+      case 5:\n+        \/* 2.30 *\/\n+        if (m[i] != 0U)\n+          GST_INFO_OBJECT (qtdemux, \"Matrix non-zero UV values ignored\");\n+        break;\n+      case 6:\n+      case 7:\n+        \/* 16.16 *\/\n+        if (m[i] != 0U)\n+          GST_INFO_OBJECT (qtdemux, \"Matrix non-zero XY values ignored\");\n+        break;\n+      case 8:\n+        \/* 2.30 *\/\n+        if (m[i] != 0U && m[i] != (1U << 30) && m[i] != (3U << 30))\n+          return FALSE;\n+        break;\n+      default:\n+        \/* 16.16 *\/\n+        if (m[i] != 0U && m[i] != (1U << 16) && m[i] != (G_MAXUINT16 << 16))\n+          return FALSE;\n+        break;\n+    }\n+  }\n@@ -11529,0 +11768,30 @@\n+static void\n+qtdemux_mul_transformation_matrix (GstQTDemux * qtdemux,\n+    guint32 * a, guint32 * b, guint32 * c)\n+{\n+#define QTMUL_MATRIX(_a,_b) (((_a) == 0 || (_b) == 0) ? 0 : \\\n+      ((_a) == (_b) ? 1 : -1))\n+#define QTADD_MATRIX(_a,_b) ((_a) + (_b) > 0 ? (1U << 16) : \\\n+      ((_a) + (_b) < 0) ? (G_MAXUINT16 << 16) : 0u)\n+\n+  if (!qtdemux_transformation_matrix_is_simple (qtdemux, a) ||\n+      !qtdemux_transformation_matrix_is_simple (qtdemux, b)) {\n+    GST_WARNING_OBJECT (qtdemux,\n+        \"Cannot handle transform matrix with element values other than 0, 1 or -1\");\n+    \/* Pretend to have an identity matrix in this case *\/\n+    c[1] = c[2] = c[3] = c[5] = c[6] = c[7] = 0;\n+    c[0] = c[4] = (1U << 16);\n+    c[8] = (1 << 30);\n+  } else {\n+    c[2] = c[5] = c[6] = c[7] = 0;\n+    c[0] = QTADD_MATRIX (QTMUL_MATRIX (a[0], b[0]), QTMUL_MATRIX (a[1], b[3]));\n+    c[1] = QTADD_MATRIX (QTMUL_MATRIX (a[0], b[1]), QTMUL_MATRIX (a[1], b[4]));\n+    c[3] = QTADD_MATRIX (QTMUL_MATRIX (a[3], b[0]), QTMUL_MATRIX (a[4], b[3]));\n+    c[4] = QTADD_MATRIX (QTMUL_MATRIX (a[3], b[1]), QTMUL_MATRIX (a[4], b[4]));\n+    c[8] = a[8];\n+  }\n+\n+#undef QTMUL_MATRIX\n+#undef QTADD_MATRIX\n+}\n+\n@@ -11538,1 +11807,1 @@\n- * This macro will only compare value abdegh, it expects cfi to have already\n+ * This macro will only compare value abde, it expects cfi to have already\n@@ -11553,2 +11822,1 @@\n-    } else if (QTCHECK_MATRIX (matrix, G_MAXUINT16, 0, 0, G_MAXUINT16) ||\n-        QTCHECK_MATRIX (matrix, G_MAXUINT16, 0, 0, 1)) {\n+    } else if (QTCHECK_MATRIX (matrix, G_MAXUINT16, 0, 0, G_MAXUINT16)) {\n@@ -11558,0 +11826,8 @@\n+    } else if (QTCHECK_MATRIX (matrix, G_MAXUINT16, 0, 0, 1)) {\n+      rotation_tag = \"flip-rotate-0\";\n+    } else if (QTCHECK_MATRIX (matrix, 0, G_MAXUINT16, G_MAXUINT16, 0)) {\n+      rotation_tag = \"flip-rotate-90\";\n+    } else if (QTCHECK_MATRIX (matrix, 1, 0, 0, G_MAXUINT16)) {\n+      rotation_tag = \"flip-rotate-180\";\n+    } else if (QTCHECK_MATRIX (matrix, 0, 1, 1, 0)) {\n+      rotation_tag = \"flip-rotate-270\";\n@@ -11838,7 +12114,1 @@\n-\/* parse the traks.\n- * With each track we associate a new QtDemuxStream that contains all the info\n- * about the trak.\n- * traks that do not decode to something (like strm traks) will not have a pad.\n- *\/\n-static gboolean\n-qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)\n+typedef enum\n@@ -11846,28 +12116,49 @@\n-  GstByteReader tkhd;\n-  int offset;\n-  GNode *mdia;\n-  GNode *mdhd;\n-  GNode *hdlr;\n-  GNode *minf;\n-  GNode *stbl;\n-  GNode *stsd;\n-  GNode *mp4a;\n-  GNode *mp4v;\n-  GNode *esds;\n-  GNode *tref;\n-  GNode *udta;\n-\n-  QtDemuxStream *stream = NULL;\n-  const guint8 *stsd_data;\n-  const guint8 *stsd_entry_data;\n-  guint remaining_stsd_len;\n-  guint stsd_entry_count;\n-  guint stsd_index;\n-  guint16 lang_code;            \/* quicktime lang code or packed iso code *\/\n-  guint32 version;\n-  guint32 tkhd_flags = 0;\n-  guint8 tkhd_version = 0;\n-  guint32 w = 0, h = 0;\n-  guint value_size, stsd_len, len;\n-  guint32 track_id;\n-  guint32 dummy;\n+  \/\/ ISO\/IEC 23001-17 Table 1 - Component Types\n+  COMPONENT_MONOCHROME = 0,     \/\/ Gray\n+  COMPONENT_Y = 1,              \/\/ Luma: Y\n+  COMPONENT_U = 2,              \/\/ Chroma: Cb or U\n+  COMPONENT_V = 3,              \/\/ Chroma: Cr or V\n+  COMPONENT_RED = 4,            \/\/ R\n+  COMPONENT_GREEN = 5,          \/\/ G\n+  COMPONENT_BLUE = 6,           \/\/ B\n+  COMPONENT_ALPHA = 7,          \/\/ A\n+  COMPONENT_DEPTH = 8,          \/\/\n+  COMPONENT_DISPARITY = 9,      \/\/\n+  COMPONENT_PALETTE = 10,       \/\/ The component_format value for this component shall be 0.\n+  COMPONENT_FILTER_ARRAY = 11,  \/\/ Bayer, RGBW, etc.\n+  COMPONENT_PADDING = 12,       \/\/ unused bit\/bytes\n+  COMPONENT_CYAN = 13,          \/\/\n+  COMPONENT_MAGENTA = 14,       \/\/\n+  COMPONENT_YELLOW = 15,        \/\/\n+  COMPONENT_KEY = 16,           \/\/ Black\n+  \/\/ Values 17 to 0x7FFF are reserved\n+  \/\/ Values 0x8000 to 0xFFFF are user-defined\n+} ComponentType;\n+\n+typedef enum\n+{\n+  \/\/ ISO\/IEC 23001-17 Table 4 - Interleave Types\n+  INTERLEAVE_COMPONENT = 0,     \/\/ Planar: RRR... GGG... BBB...\n+  INTERLEAVE_PIXEL = 1,         \/\/ Packed: RGB RGB RGB ...\n+  INTERLEAVE_MIXED = 2,         \/\/ All Y components followed by interleaved U and V components.\n+  INTERLEAVE_ROW = 3,           \/\/ Interleaved by rows\n+  INTERLEAVE_TILE = 4,          \/\/ Interleaved by tiles\n+  INTERLEAVE_MULTI_Y = 5,       \/\/ Multiple Y components with a single UV pair\n+} InterleaveType;\n+\n+typedef enum\n+{\n+  \/\/ ISO\/IEC 23001-17 Table 3 - Sampling Types\n+  SAMPLING_444 = 0,             \/\/ 4:4:4 (no subsampling)\n+  SAMPLING_422 = 1,             \/\/ 4:2:2\n+  SAMPLING_420 = 2,             \/\/ 4:2:0\n+  SAMPLING_411 = 3,             \/\/ 4:1:1\n+} SamplingType;\n+\n+typedef struct ComponentDefinitionBox\n+{\n+  \/\/ ComponentDefinitionBox\n+  guint32 component_count;      \/\/ Should match the uncC component_count\n+  ComponentType *types;         \/\/ The type of component (R,G,B,A,Y,U,V, etc.)\n+  const gchar **type_uris;      \/\/ Describes a user-defined component type\n+} ComponentDefinitionBox;\n@@ -11875,1 +12166,7 @@\n-  GST_DEBUG_OBJECT (qtdemux, \"parse_trak\");\n+typedef struct UncompressedFrameConfigComponent\n+{\n+  guint16 index;                \/\/ Index associated with the cmpd box\n+  guint8 bit_depth;             \/\/ The number of bits to store a component value.\n+  guint8 format;                \/\/ 0: int, 1: float, 2: complex\n+  guint8 align_size;            \/\/ The number of bytes used to store a component value. If 0, refer to bit_depth.\n+} UncompressedFrameConfigComponent;\n@@ -11877,4 +12174,21 @@\n-  if (!qtdemux_tree_get_child_by_type_full (trak, FOURCC_tkhd, &tkhd)\n-      || !gst_byte_reader_get_uint8 (&tkhd, &tkhd_version)\n-      || !gst_byte_reader_get_uint24_be (&tkhd, &tkhd_flags))\n-    goto corrupt_file;\n+typedef struct UncompressedFrameConfigBox\n+{\n+  guint8 version;\n+  guint32 flags;\n+  guint32 profile;              \/\/ indicates a predefined configuration\n+  guint32 component_count;      \/\/ Should match the cmpd component_count\n+  UncompressedFrameConfigComponent *components; \/\/ Array of Components\n+  guint8 sampling_type;         \/\/ 0=4:4:4, 1=4:2:2, 2=4:2:0, 3=4:1:1\n+  guint8 interleave_type;       \/\/ Planar, interleaved, etc.\n+  guint8 block_size;            \/\/ Stores data in fixed-sized blocks\n+  gboolean components_little_endian;    \/\/ indicates that components are stored as little endian\n+  gboolean block_pad_lsb;       \/\/ Padding bits location\n+  gboolean block_little_endian; \/\/ Block Endianness\n+  gboolean block_reversed;      \/\/ Indicates if component order is reversed within the block\n+  gboolean pad_unknown;         \/\/ the value of padded bits is unknown\n+  guint32 pixel_size;           \/\/ number of bytes used to store all components for a single pixel\n+  guint32 row_align_size;       \/\/ Padding between rows\n+  guint32 tile_align_size;      \/\/ Padding between tiles\n+  guint32 num_tile_cols;        \/\/ Number of horizontal tiles\n+  guint32 num_tile_rows;        \/\/ Number of vertical tiles\n+} UncompressedFrameConfigBox;\n@@ -11882,5 +12196,5 @@\n-  \/* pick between 64 or 32 bits *\/\n-  value_size = tkhd_version == 1 ? 8 : 4;\n-  if (!gst_byte_reader_skip (&tkhd, value_size * 2) ||\n-      !gst_byte_reader_get_uint32_be (&tkhd, &track_id))\n-    goto corrupt_file;\n+static void\n+qtdemux_clear_uncC (UncompressedFrameConfigBox * uncC)\n+{\n+  if (!uncC)\n+    return;\n@@ -11888,3 +12202,2 @@\n-  \/* Check if current moov has duplicated track_id *\/\n-  if (qtdemux_find_stream (qtdemux, track_id))\n-    goto existing_stream;\n+  g_free (uncC->components);\n+}\n@@ -11892,2 +12205,5 @@\n-  stream = _create_stream (qtdemux, track_id);\n-  stream->stream_tags = gst_tag_list_make_writable (stream->stream_tags);\n+static void\n+qtdemux_clear_cmpd (ComponentDefinitionBox * cmpd)\n+{\n+  if (!cmpd)\n+    return;\n@@ -11895,2 +12211,3 @@\n-  \/* need defaults for fragments *\/\n-  qtdemux_parse_trex (qtdemux, stream, &dummy, &dummy, &dummy);\n+  g_free (cmpd->types);\n+  g_free (cmpd->type_uris);\n+}\n@@ -11898,2 +12215,9 @@\n-  if ((tkhd_flags & 1) == 0)\n-    stream->disabled = TRUE;\n+static gboolean\n+qtdemux_parse_cmpd (GstQTDemux * qtdemux, GstByteReader * reader,\n+    ComponentDefinitionBox * cmpd)\n+{\n+  \/* There should be enough to parse the component_count (4) *\/\n+  if (gst_byte_reader_get_remaining (reader) < 4) {\n+    GST_ERROR_OBJECT (qtdemux, \"cmpd is too short\");\n+    goto error;\n+  }\n@@ -11901,4 +12225,1 @@\n-#ifdef GSTREAMER_LITE\n-  \/\/ set track_enabled based on bit 0 of flags\n-  stream->track_enabled = (gboolean)(tkhd_flags & 0x000001);\n-#endif \/\/ GSTREAMER_LITE\n+  cmpd->component_count = gst_byte_reader_get_uint32_be_unchecked (reader);\n@@ -11906,2 +12227,5 @@\n-  GST_LOG_OBJECT (qtdemux, \"track[tkhd] version\/flags\/id: 0x%02x\/%06x\/%u\",\n-      tkhd_version, tkhd_flags, stream->track_id);\n+  guint32 minimum_size = cmpd->component_count * 2 + 4; \/\/ assuming type_uris are not used\n+  if (gst_byte_reader_get_size (reader) < minimum_size) {\n+    GST_ERROR_OBJECT (qtdemux, \"cmpd size is too short\");\n+    goto error;\n+  }\n@@ -11909,2 +12233,2 @@\n-  if (!(mdia = qtdemux_tree_get_child_by_type (trak, FOURCC_mdia)))\n-    goto corrupt_file;\n+  cmpd->types = g_new0 (ComponentType, cmpd->component_count);\n+  cmpd->type_uris = g_new0 (const gchar *, cmpd->component_count);\n@@ -11912,1 +12236,2478 @@\n-  if (!(mdhd = qtdemux_tree_get_child_by_type (mdia, FOURCC_mdhd))) {\n+  guint16 type = 0;\n+  for (guint32 i = 0; i < cmpd->component_count; i++) {\n+    if (!gst_byte_reader_get_uint16_be (reader, &type)) {\n+      GST_ERROR_OBJECT (qtdemux, \"Failed to read component type\");\n+      goto error;\n+    }\n+    if (type >= 0x8000) {\n+      if (!gst_byte_reader_get_string (reader, &cmpd->type_uris[i])) {\n+        GST_ERROR_OBJECT (qtdemux, \"Failed to read component type URI\");\n+        goto error;\n+      }\n+    }\n+    cmpd->types[i] = (ComponentType) type;\n+  }\n+\n+  \/* Success *\/\n+  return TRUE;\n+\n+error:\n+  return FALSE;\n+}\n+\n+static gboolean\n+qtdemux_parse_uncC (GstQTDemux * qtdemux, GstByteReader * reader,\n+    UncompressedFrameConfigBox * uncC)\n+{\n+  \/* There should be enough to parse the version\/flags (4) & profile (4) *\/\n+  if (gst_byte_reader_get_remaining (reader) < 8) {\n+    GST_ERROR_OBJECT (qtdemux, \"uncC is too short\");\n+    goto error;\n+  }\n+\n+  uncC->version = gst_byte_reader_get_uint8_unchecked (reader);\n+  uncC->flags = gst_byte_reader_get_uint24_be_unchecked (reader);\n+\n+  uncC->profile = gst_byte_reader_get_uint32_le_unchecked (reader);\n+  if (uncC->version == 1) {\n+    \/* Use the profile for predetermined settings *\/\n+    goto success;\n+  } else if (uncC->version != 0) {\n+    GST_ERROR_OBJECT (qtdemux, \"Unsupported uncC version\");\n+    goto error;\n+  }\n+\n+  if (!gst_byte_reader_get_uint32_be (reader, &uncC->component_count)) {\n+    GST_ERROR_OBJECT (qtdemux, \"Failed to read component count\");\n+    goto error;\n+  }\n+\n+  guint32 expected_size = uncC->component_count * 5 + 36;\n+  if (gst_byte_reader_get_size (reader) != expected_size) {\n+    GST_ERROR_OBJECT (qtdemux, \"uncC size is incorrect\");\n+    goto error;\n+  }\n+\n+  guint32 expected_remaining = uncC->component_count * 5 + 24;\n+  if (gst_byte_reader_get_remaining (reader) < expected_remaining) {\n+    GST_ERROR_OBJECT (qtdemux, \"uncC is too short\");\n+    goto error;\n+  }\n+\n+  uncC->components =\n+      g_new0 (UncompressedFrameConfigComponent, uncC->component_count);\n+\n+  for (guint32 i = 0; i < uncC->component_count; i++) {\n+    UncompressedFrameConfigComponent *component = &uncC->components[i];\n+    component->index = gst_byte_reader_get_uint16_be_unchecked (reader);\n+    component->bit_depth = gst_byte_reader_get_uint8_unchecked (reader) + 1;\n+    component->format = gst_byte_reader_get_uint8_unchecked (reader);\n+    component->align_size = gst_byte_reader_get_uint8_unchecked (reader);\n+  }\n+\n+  uncC->sampling_type = gst_byte_reader_get_uint8_unchecked (reader);\n+  uncC->interleave_type = gst_byte_reader_get_uint8_unchecked (reader);\n+  uncC->block_size = gst_byte_reader_get_uint8_unchecked (reader);\n+\n+  guint8 block_flags = gst_byte_reader_get_uint8_unchecked (reader);\n+  uncC->components_little_endian = (block_flags >> 7) & 0x01;\n+  uncC->block_pad_lsb = (block_flags >> 6) & 0x01;\n+  uncC->block_little_endian = (block_flags >> 5) & 0x01;\n+  uncC->block_reversed = (block_flags >> 4) & 0x01;\n+  uncC->pad_unknown = (block_flags >> 3) & 0x01;\n+\n+  uncC->pixel_size = gst_byte_reader_get_uint32_be_unchecked (reader);\n+  uncC->row_align_size = gst_byte_reader_get_uint32_be_unchecked (reader);\n+  uncC->tile_align_size = gst_byte_reader_get_uint32_be_unchecked (reader);\n+  uncC->num_tile_cols = gst_byte_reader_get_uint32_be_unchecked (reader) + 1;\n+  uncC->num_tile_rows = gst_byte_reader_get_uint32_be_unchecked (reader) + 1;\n+\n+success:\n+  return TRUE;\n+\n+error:\n+  return FALSE;\n+}\n+\n+typedef struct ComponentFormatMapping\n+{\n+  GstVideoFormat format;\n+  UncompressedFrameConfigBox uncC;\n+  UncompressedFrameConfigComponent component_config;    \/\/ All components are assumed to have the same config\n+  guint16 component_types[4];   \/\/ From cmpd\n+} ComponentFormatMapping;\n+\n+static const ComponentFormatMapping component_lookup[] = {\n+  {\n+        GST_VIDEO_FORMAT_GRAY8,\n+        {.component_count = 1,.interleave_type =\n+              INTERLEAVE_PIXEL,.sampling_type = SAMPLING_444,.pixel_size = 1},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+      {COMPONENT_MONOCHROME}},\n+  {\n+        GST_VIDEO_FORMAT_GRAY8,\n+        {.component_count = 1,.interleave_type =\n+              INTERLEAVE_COMPONENT,.sampling_type = SAMPLING_444,.pixel_size =\n+              1},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+      {COMPONENT_MONOCHROME}},\n+  {\n+        GST_VIDEO_FORMAT_GRAY16_BE,\n+        {.component_count = 1,.interleave_type =\n+              INTERLEAVE_COMPONENT,.sampling_type = SAMPLING_444,.pixel_size =\n+              2,.components_little_endian = FALSE},\n+        {.bit_depth = 16,.format = 0,.align_size = 2},\n+      {COMPONENT_MONOCHROME}},\n+  {\n+        GST_VIDEO_FORMAT_RGB,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_PIXEL,.sampling_type = SAMPLING_444,.pixel_size = 3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+      {COMPONENT_RED, COMPONENT_GREEN, COMPONENT_BLUE}},\n+  {\n+        GST_VIDEO_FORMAT_RGBP,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_COMPONENT,.sampling_type = SAMPLING_444,.pixel_size =\n+              3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+      {COMPONENT_RED, COMPONENT_GREEN, COMPONENT_BLUE}},\n+  {\n+        GST_VIDEO_FORMAT_BGRP,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_COMPONENT,.sampling_type = SAMPLING_444,.pixel_size =\n+              3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+      {COMPONENT_BLUE, COMPONENT_GREEN, COMPONENT_RED}},\n+  {\n+        GST_VIDEO_FORMAT_RGBx,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_PIXEL,.sampling_type = SAMPLING_444,.pixel_size = 4},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_RED, COMPONENT_GREEN, COMPONENT_BLUE}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_GBR,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_COMPONENT,.sampling_type = SAMPLING_444,.pixel_size =\n+              3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_GREEN, COMPONENT_BLUE, COMPONENT_RED}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_BGR,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_PIXEL,.sampling_type = SAMPLING_444,.pixel_size = 3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_BLUE, COMPONENT_GREEN, COMPONENT_RED}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_BGRx,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_PIXEL,.sampling_type = SAMPLING_444,.pixel_size = 4},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_BLUE, COMPONENT_GREEN, COMPONENT_RED}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_r210,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_PIXEL,.sampling_type = SAMPLING_444,.pixel_size =\n+              4,.block_size = 4},\n+        {.bit_depth = 10,.format = 0,.align_size = 0},\n+        {COMPONENT_RED, COMPONENT_GREEN, COMPONENT_BLUE}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_Y444,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_COMPONENT,.sampling_type = SAMPLING_444,.pixel_size =\n+              3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_Y, COMPONENT_U, COMPONENT_V}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_v308,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_PIXEL,.sampling_type = SAMPLING_444,.pixel_size = 3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_Y, COMPONENT_U, COMPONENT_V}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_Y42B,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_COMPONENT,.sampling_type = SAMPLING_422,.pixel_size =\n+              3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_Y, COMPONENT_U, COMPONENT_V}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_I420,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_COMPONENT,.sampling_type = SAMPLING_420,.pixel_size =\n+              3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_Y, COMPONENT_U, COMPONENT_V}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_YV12,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_COMPONENT,.sampling_type = SAMPLING_420,.pixel_size =\n+              3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_Y, COMPONENT_V, COMPONENT_U}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_IYU2,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_PIXEL,.sampling_type = SAMPLING_444,.pixel_size = 3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_U, COMPONENT_Y, COMPONENT_V}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_NV12,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_MIXED,.sampling_type = SAMPLING_420,.pixel_size = 3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_Y, COMPONENT_U, COMPONENT_V}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_NV21,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_MIXED,.sampling_type = SAMPLING_420,.pixel_size = 3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_Y, COMPONENT_V, COMPONENT_U}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_NV16,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_MIXED,.sampling_type = SAMPLING_422,.pixel_size = 3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_Y, COMPONENT_U, COMPONENT_V}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_Y41B,\n+        {.component_count = 3,.interleave_type =\n+              INTERLEAVE_COMPONENT,.sampling_type = SAMPLING_411,.pixel_size =\n+              3},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_Y, COMPONENT_U, COMPONENT_V}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_AYUV,\n+        {.component_count = 4,.interleave_type =\n+              INTERLEAVE_PIXEL,.sampling_type = SAMPLING_444,.pixel_size = 4},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_ALPHA, COMPONENT_Y, COMPONENT_U, COMPONENT_V}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_ARGB,\n+        {.component_count = 4,.interleave_type =\n+              INTERLEAVE_PIXEL,.sampling_type = SAMPLING_444,.pixel_size = 4},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_ALPHA, COMPONENT_RED, COMPONENT_GREEN, COMPONENT_BLUE}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_BGRA,\n+        {.component_count = 4,.interleave_type =\n+              INTERLEAVE_PIXEL,.sampling_type = SAMPLING_444,.pixel_size = 4},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_BLUE, COMPONENT_GREEN, COMPONENT_RED, COMPONENT_ALPHA}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_RGBA,\n+        {.component_count = 4,.interleave_type =\n+              INTERLEAVE_PIXEL,.sampling_type = SAMPLING_444,.pixel_size = 4},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_RED, COMPONENT_GREEN, COMPONENT_BLUE, COMPONENT_ALPHA}\n+      },\n+  {\n+        GST_VIDEO_FORMAT_RGBx,\n+        {.component_count = 4,.interleave_type =\n+              INTERLEAVE_PIXEL,.sampling_type = SAMPLING_444,.pixel_size = 4},\n+        {.bit_depth = 8,.format = 0,.align_size = 1},\n+        {COMPONENT_RED, COMPONENT_GREEN, COMPONENT_BLUE, COMPONENT_PADDING}\n+      },\n+};\n+\n+\n+static GstVideoFormat\n+qtdemux_get_format_from_uncv (GstQTDemux * qtdemux,\n+    UncompressedFrameConfigBox * uncC, ComponentDefinitionBox * cmpd)\n+{\n+  guint32 num_components = uncC->component_count;\n+  guint16 component_types[4];\n+\n+\n+  if (uncC->version == 1) {\n+    \/\/ Determine format with profile\n+    \/\/ The only permitted profiles for version 1 are `rgb3`, `rgba`, and `abgr`\n+    switch (uncC->profile) {\n+      case GST_MAKE_FOURCC ('r', 'g', 'b', '3'):       \/\/ RGB 24 bits packed\n+        return GST_VIDEO_FORMAT_RGB;\n+        break;\n+\n+      case GST_MAKE_FOURCC ('r', 'g', 'b', 'a'):       \/\/ RGBA 32 bits packed\n+        return GST_VIDEO_FORMAT_RGBA;\n+        break;\n+\n+      case GST_MAKE_FOURCC ('a', 'b', 'g', 'r'):       \/\/ RGBA 32 bits packed\n+        return GST_VIDEO_FORMAT_ABGR;\n+        break;\n+\n+      default:\n+        goto unsupported_feature;\n+    }\n+\n+  } else if (uncC->version == 0) {\n+    \/\/ Determine format with uncC & cmpd boxes\n+  } else {\n+    GST_WARNING_OBJECT (qtdemux, \"Unsupported uncv version: %u\", uncC->version);\n+    goto unsupported_feature;\n+  }\n+\n+\n+  \/* Assert that components are similar *\/\n+  UncompressedFrameConfigComponent *first_comp = &uncC->components[0];\n+  guint8 align_size = first_comp->align_size;\n+  for (guint32 i = 0; i < num_components; i++) {\n+    \/\/ For now, assert that each component has the same bit depth\n+    UncompressedFrameConfigComponent *comp = &uncC->components[i];\n+    if (comp->bit_depth != first_comp->bit_depth) {\n+      GST_WARNING_OBJECT (qtdemux,\n+          \"Unsupported bit_depth combination for uncompressed track: %u != %u\",\n+          comp->bit_depth, first_comp->bit_depth);\n+      goto unsupported_feature;\n+    }\n+    \/\/ For now, assert that each component has the same align size\n+    if (comp->align_size != first_comp->align_size) {\n+      GST_WARNING_OBJECT (qtdemux,\n+          \"Unsupported component_align_size for uncompressed track: %u != %u\",\n+          comp->align_size, first_comp->align_size);\n+      goto unsupported_feature;\n+    }\n+  }\n+\n+\n+  \/* Unsupported Features *\/\n+  if (align_size) {\n+    \/\/ If component_align_size is 0, the component value\n+    \/\/ is coded on component_bit_depth bits exactly\n+    GST_WARNING_OBJECT (qtdemux,\n+        \"Unsupported align_size for uncompressed track: %u\", align_size);\n+    goto unsupported_feature;\n+  } else if (uncC->tile_align_size) {\n+    \/\/ tile_align_size indicates the padding between tiles\n+    GST_WARNING_OBJECT (qtdemux,\n+        \"Unsupported tile_align_size for uncompressed track: %u\",\n+        uncC->tile_align_size);\n+    goto unsupported_feature;\n+  }\n+\n+  \/\/ Get Component Types\n+  for (guint32 i = 0; i < num_components; i++) {\n+    guint16 component_index = uncC->components[i].index;\n+    component_types[i] = cmpd->types[component_index];\n+  }\n+\n+  \/\/ Lookup Format\n+  const ComponentFormatMapping *lut = component_lookup;\n+  for (guint i = 0; i < G_N_ELEMENTS (component_lookup); i++) {\n+    \/\/ Component Count\n+    if (num_components != lut[i].uncC.component_count) {\n+      continue;\n+    }\n+\n+    \/\/ Component Bit Depth\n+    if (first_comp->bit_depth != lut[i].component_config.bit_depth) {\n+      continue;\n+    }\n+\n+    \/\/ Component Align Size\n+    if (align_size && align_size != lut[i].component_config.align_size) {\n+      continue;                 \/\/ If set, the align size must match\n+    }\n+\n+    \/\/ Interleave Types\n+    if (uncC->interleave_type != lut[i].uncC.interleave_type) {\n+      continue;\n+    }\n+\n+    \/\/ Sampling Types\n+    if (uncC->sampling_type != lut[i].uncC.sampling_type) {\n+      continue;\n+    }\n+\n+    \/\/ Pixel Size\n+    if (uncC->pixel_size && uncC->pixel_size != lut[i].uncC.pixel_size) {\n+      continue;                 \/\/ If set, the pixel size must match\n+    }\n+\n+    \/\/ Block Size\n+    if (uncC->block_size && uncC->block_size != lut[i].uncC.block_size) {\n+      continue;                 \/\/ If set, the block size must match\n+    }\n+\n+    \/\/ Endian\n+    if (uncC->components_little_endian != lut[i].uncC.components_little_endian) {\n+      continue;\n+    }\n+\n+    if (memcmp (component_types, lut[i].component_types,\n+            num_components * sizeof (guint16))) {\n+      continue;\n+    }\n+\n+    \/* success *\/\n+    return lut[i].format;\n+  }\n+\n+unsupported_feature:\n+  GST_WARNING_OBJECT (qtdemux, \"Unsupported uncv format\");\n+  return GST_VIDEO_FORMAT_UNKNOWN;\n+}\n+\n+static void\n+qtdemux_set_info_from_uncv (GstQTDemux * qtdemux,\n+    QtDemuxStreamStsdEntry * entry, UncompressedFrameConfigBox * uncC,\n+    GstVideoInfo * info)\n+{\n+  guint32 num_components = uncC->component_count;\n+  guint32 row_align_size = uncC->row_align_size;\n+  gint height = entry->height;\n+\n+  if (uncC->version == 1) {\n+    switch (uncC->profile) {\n+      case GST_MAKE_FOURCC ('r', 'g', 'b', '3'):\n+        num_components = 3;\n+        break;\n+      case GST_MAKE_FOURCC ('r', 'g', 'b', 'a'):\n+      case GST_MAKE_FOURCC ('a', 'b', 'g', 'r'):\n+        num_components = 4;\n+        break;\n+      default:\n+        GST_WARNING_OBJECT (qtdemux, \"Unsupported uncv profile: %u\",\n+            uncC->profile);\n+        return;\n+    }\n+    info->stride[0] = entry->width * num_components;\n+    info->size = info->stride[0] * height;\n+    return;\n+  }\n+\n+  gint default_stride = 0;\n+  if (row_align_size) {\n+    default_stride = row_align_size;\n+  } else {\n+    default_stride = entry->width;\n+  }\n+\n+  switch (uncC->sampling_type) {\n+    case SAMPLING_444:\n+      if (uncC->interleave_type == INTERLEAVE_PIXEL) {\n+        if (row_align_size) {\n+          info->stride[0] = row_align_size;\n+        } else {\n+          info->stride[0] = entry->width * num_components;\n+        }\n+        info->size = info->stride[0] * height;\n+      } else {\n+        for (gint i = 0; i < num_components; i++) {\n+          info->stride[i] = default_stride;\n+        }\n+        info->size = info->stride[0] * height * num_components;\n+      }\n+      break;\n+\n+    case SAMPLING_422:\n+      info->stride[0] = default_stride;\n+      switch (uncC->interleave_type) {\n+        case INTERLEAVE_COMPONENT:\n+          info->stride[1] = info->stride[0] \/ 2;\n+          info->stride[2] = info->stride[1];\n+          break;\n+        case INTERLEAVE_MIXED:\n+          info->stride[1] = info->stride[0];\n+          break;\n+        case INTERLEAVE_MULTI_Y:\n+          \/\/ TODO\n+          break;\n+        default:\n+          break;                \/\/ Error\n+      }\n+      info->size = info->stride[0] * height * 2;\n+      break;\n+\n+    case SAMPLING_420:\n+      info->stride[0] = default_stride;\n+      switch (uncC->interleave_type) {\n+        case INTERLEAVE_COMPONENT:\n+          info->stride[1] = info->stride[0] \/ 2;\n+          info->stride[2] = info->stride[1];\n+          break;\n+        case INTERLEAVE_MIXED:\n+          info->stride[1] = info->stride[0];\n+          break;\n+        default:\n+          break;                \/\/ Error\n+      }\n+      info->size = info->stride[0] * height * 3 \/ 2;\n+      break;\n+\n+    case SAMPLING_411:\n+      info->stride[0] = default_stride;\n+      switch (uncC->interleave_type) {\n+        case INTERLEAVE_COMPONENT:\n+          info->stride[1] = info->stride[0] \/ 4;\n+          info->stride[2] = info->stride[1];\n+          break;\n+        case INTERLEAVE_MIXED:\n+          info->stride[1] = info->stride[0];\n+          break;\n+        case INTERLEAVE_MULTI_Y:\n+          \/\/ TODO\n+        default:\n+          break;                \/\/ Error\n+      }\n+      info->size = info->stride[0] * height * 3 \/ 2;\n+      break;\n+    default:\n+      break;\n+  }\n+\n+}\n+\n+\/* *INDENT-OFF* *\/\n+\n+\/\/ ISO\/IEC 23091-3\n+static const GstAudioChannelPosition chnl_positions[] = {\n+  \/\/ 0\n+  GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+  GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+  GST_AUDIO_CHANNEL_POSITION_LFE1,\n+  GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+  GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+  GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+  GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+  \/\/ 10\n+  GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+  GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT,\n+  GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+  GST_AUDIO_CHANNEL_POSITION_WIDE_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_WIDE_RIGHT,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,\n+  \/\/ 20\n+  GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_RIGHT,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,\n+  GST_AUDIO_CHANNEL_POSITION_LFE2,\n+  GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_RIGHT,\n+  GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_CENTER,\n+  \/\/ 30\n+  GST_AUDIO_CHANNEL_POSITION_TOP_SURROUND_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_SURROUND_RIGHT,\n+  GST_AUDIO_CHANNEL_POSITION_INVALID, \/\/ reserved\n+  GST_AUDIO_CHANNEL_POSITION_INVALID, \/\/ reserved\n+  GST_AUDIO_CHANNEL_POSITION_INVALID, \/\/ reserved\n+  GST_AUDIO_CHANNEL_POSITION_INVALID, \/\/ reserved\n+  GST_AUDIO_CHANNEL_POSITION_INVALID, \/\/ low frequency enhancement 3\n+  GST_AUDIO_CHANNEL_POSITION_INVALID, \/\/ left edge of screen\n+  GST_AUDIO_CHANNEL_POSITION_INVALID, \/\/ right edge of screen\n+  GST_AUDIO_CHANNEL_POSITION_INVALID, \/\/ half-way between centre of screen and\n+                                      \/\/ left edge of screen\n+  \/\/ 40\n+  GST_AUDIO_CHANNEL_POSITION_INVALID, \/\/ half-way between centre of screen and\n+                                      \/\/ right edge of screen\n+  GST_AUDIO_CHANNEL_POSITION_INVALID, \/\/ left back surround\n+  GST_AUDIO_CHANNEL_POSITION_INVALID, \/\/ right back surround\n+  \/\/ 43-125 reserved\n+  \/\/ 126 explicit position\n+  \/\/ 127 unknown \/ undefined\n+};\n+\n+\/\/ Pre-defined channel layouts\n+\/\/\n+\/\/ Each layout is terminated by INVALID to allow counting the number of\n+\/\/ channels in the layout.\n+static const GstAudioChannelPosition chnl_layouts[][25] = {\n+ \/\/ 0\n+ { GST_AUDIO_CHANNEL_POSITION_INVALID, },\n+ \/\/ 1\n+ { GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER, GST_AUDIO_CHANNEL_POSITION_INVALID, },\n+ \/\/ 2\n+ { GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT, GST_AUDIO_CHANNEL_POSITION_INVALID, },\n+ \/\/ 3\n+ {\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_INVALID,\n+ },\n+ \/\/ 4\n+ {\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_INVALID,\n+ },\n+ \/\/ 5\n+ {\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT, GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_INVALID,\n+ },\n+ \/\/ 6\n+ {\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT, GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_LFE1,\n+   GST_AUDIO_CHANNEL_POSITION_INVALID,\n+ },\n+ \/\/ 7\n+ {\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT, GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_LFE1,\n+   GST_AUDIO_CHANNEL_POSITION_INVALID,\n+ },\n+ \/\/ 8\n+ { GST_AUDIO_CHANNEL_POSITION_INVALID, },\n+ \/\/ 9\n+ {\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_INVALID,\n+ },\n+ \/\/ 10\n+ {\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT, GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_INVALID,\n+ },\n+ \/\/ 11\n+ {\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT, GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_LFE1,\n+   GST_AUDIO_CHANNEL_POSITION_INVALID,\n+ },\n+ \/\/ 12\n+ {\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT, GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_REAR_LEFT, GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_LFE1,\n+   GST_AUDIO_CHANNEL_POSITION_INVALID,\n+ },\n+ \/\/ 13\n+ {\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT, GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_REAR_LEFT, GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_LFE1, GST_AUDIO_CHANNEL_POSITION_LFE2,\n+   GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_LEFT, GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT, GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_INVALID,\n+ },\n+ \/\/ 14\n+ {\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+   GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT, GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_LFE1,\n+   GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT, GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,\n+   GST_AUDIO_CHANNEL_POSITION_INVALID,\n+ },\n+\n+};\n+\/* *INDENT-ON* *\/\n+\n+static void\n+qtdemux_parse_chnl (GstQTDemux * qtdemux, GstByteReader * br,\n+    QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry)\n+{\n+  GstAudioChannelPosition positions[64];\n+  guint n_channels = 0;\n+\n+  guint8 version = gst_byte_reader_get_uint8_unchecked (br);\n+  guint32 flags = gst_byte_reader_get_uint24_be_unchecked (br);\n+\n+  if (version == 0 && flags == 0) {\n+    guint8 stream_structure;\n+    if (!gst_byte_reader_get_uint8 (br, &stream_structure)) {\n+      GST_WARNING_OBJECT (qtdemux, \"Too short chnl box\");\n+      goto error;\n+    }\n+\n+    \/\/ stream carries channels\n+    if (stream_structure & 1) {\n+      guint8 defined_layout;\n+\n+      if (!gst_byte_reader_get_uint8 (br, &defined_layout)) {\n+        GST_WARNING_OBJECT (qtdemux, \"Too short chnl box\");\n+        goto error;\n+      }\n+\n+      n_channels = entry->n_channels;\n+\n+      if (defined_layout == 0) {\n+        for (unsigned int i = 0; i < n_channels; i++) {\n+          guint8 speaker_position;\n+\n+          if (!gst_byte_reader_get_uint8 (br, &speaker_position)) {\n+            GST_WARNING_OBJECT (qtdemux, \"Too short chnl box\");\n+            goto error;\n+          }\n+\n+          \/\/ explicit position\n+          if (speaker_position == 126) {\n+            GST_WARNING_OBJECT (qtdemux,\n+                \"Explicit speaker position not supported\");\n+            goto error;\n+          }\n+\n+          if (speaker_position >= G_N_ELEMENTS (chnl_positions) ||\n+              chnl_positions[speaker_position] ==\n+              GST_AUDIO_CHANNEL_POSITION_INVALID) {\n+            GST_WARNING_OBJECT (qtdemux,\n+                \"Unsupported speaker channel %u position %u\", i,\n+                speaker_position);\n+            goto error;\n+          }\n+\n+          positions[i] = chnl_positions[speaker_position];\n+        }\n+      } else {\n+        guint64 omitted_channels_map;\n+\n+        if (!gst_byte_reader_get_uint64_be (br, &omitted_channels_map)) {\n+          GST_WARNING_OBJECT (qtdemux, \"Too short chnl box\");\n+          goto error;\n+        }\n+\n+        if (defined_layout >= G_N_ELEMENTS (chnl_layouts) ||\n+            chnl_layouts[defined_layout][0] ==\n+            GST_AUDIO_CHANNEL_POSITION_INVALID) {\n+          GST_WARNING_OBJECT (qtdemux, \"Unsupported defined layout %u\",\n+              defined_layout);\n+          goto error;\n+        }\n+\n+        const GstAudioChannelPosition *layout = chnl_layouts[defined_layout];\n+\n+        \/\/ The omitted channel map defines which of the channels of the\n+        \/\/ pre-defined layout are *not* included.\n+        for (unsigned int c = 0; c < n_channels; c++) {\n+          \/\/ Find c-th channel in layout that is not omitted\n+          unsigned int l_c = 0;\n+          for (unsigned int i = 0; i < 64; i++) {\n+            \/\/ If there are not enough non-omitted channels in the layout we end\n+            \/\/ up here and return\n+            if (layout[i] == GST_AUDIO_CHANNEL_POSITION_INVALID) {\n+              GST_WARNING_OBJECT (qtdemux,\n+                  \"Invalid defined layout %u with %u channels and omitted channels map %016\"\n+                  G_GINT64_MODIFIER \"x\", defined_layout, n_channels,\n+                  omitted_channels_map);\n+              goto error;\n+            }\n+\n+            \/\/ The i-th channel of the layout is included\n+            if (((omitted_channels_map >> i) & 1) == 0) {\n+              \/\/ The channel we're looking for\n+              if (l_c == c) {\n+                positions[c] = layout[l_c];\n+                break;\n+              }\n+              l_c += 1;\n+            }\n+          }\n+\n+          \/\/ If there are not enough non-omitted channels in the omitted\n+          \/\/ channels map then return here\n+          if (positions[c] == GST_AUDIO_CHANNEL_POSITION_INVALID) {\n+            GST_WARNING_OBJECT (qtdemux,\n+                \"Invalid defined layout %u with %u channels and omitted channels map %016\"\n+                G_GINT64_MODIFIER \"x\", defined_layout, n_channels,\n+                omitted_channels_map);\n+            goto error;\n+          }\n+        }\n+      }\n+    }\n+\n+    \/\/ stream carries objects\n+    if (stream_structure & 2) {\n+      guint8 object_count;\n+\n+      if (!gst_byte_reader_get_uint8 (br, &object_count)) {\n+        GST_WARNING_OBJECT (qtdemux, \"Too short chnl box\");\n+        goto error;\n+      }\n+\n+      GST_WARNING_OBJECT (qtdemux, \"Stream carries %u objects\", object_count);\n+      goto error;\n+    }\n+  } else if (version == 1 && flags == 0) {\n+    guint8 b;\n+\n+    if (!gst_byte_reader_get_uint8 (br, &b)) {\n+      GST_WARNING_OBJECT (qtdemux, \"Too short chnl box\");\n+      goto error;\n+    }\n+\n+    guint8 stream_structure = b >> 4;\n+    \/\/ guint8 format_ordering = b & 0x0f;\n+\n+    guint8 base_channel_count;\n+    if (!gst_byte_reader_get_uint8 (br, &base_channel_count)) {\n+      GST_WARNING_OBJECT (qtdemux, \"Too short chnl box\");\n+      goto error;\n+    }\n+\n+    \/\/ stream carries channels\n+    if (stream_structure & 1) {\n+      guint8 defined_layout;\n+\n+      if (!gst_byte_reader_get_uint8 (br, &defined_layout)) {\n+        GST_WARNING_OBJECT (qtdemux, \"Too short chnl box\");\n+        goto error;\n+      }\n+\n+      if (defined_layout == 0) {\n+        guint8 layout_channel_count;\n+\n+        if (!gst_byte_reader_get_uint8 (br, &layout_channel_count)) {\n+          GST_WARNING_OBJECT (qtdemux, \"Too short chnl box\");\n+          goto error;\n+        }\n+\n+        if (layout_channel_count == 0) {\n+          \/\/ Not present so configure a default based on the sample entry\n+          goto error;\n+        }\n+\n+        n_channels = layout_channel_count;\n+        for (unsigned int i = 0; i < layout_channel_count; i++) {\n+          guint8 speaker_position;\n+\n+          if (!gst_byte_reader_get_uint8 (br, &speaker_position)) {\n+            GST_WARNING_OBJECT (qtdemux, \"Too short chnl box\");\n+            goto error;\n+          }\n+\n+          \/\/ explicit position\n+          if (speaker_position == 126) {\n+            GST_WARNING_OBJECT (qtdemux,\n+                \"Explicit speaker position not supported\");\n+            goto error;\n+          }\n+\n+          if (speaker_position >= G_N_ELEMENTS (chnl_positions) ||\n+              chnl_positions[speaker_position] ==\n+              GST_AUDIO_CHANNEL_POSITION_INVALID) {\n+            GST_WARNING_OBJECT (qtdemux,\n+                \"Unsupported speaker channel %u position %u\", i,\n+                speaker_position);\n+            goto error;\n+          }\n+\n+          positions[i] = chnl_positions[speaker_position];\n+        }\n+      } else {\n+        if (!gst_byte_reader_get_uint8 (br, &b)) {\n+          GST_WARNING_OBJECT (qtdemux, \"Too short chnl box\");\n+          goto error;\n+        }\n+\n+        guint8 channel_order_definition = (b >> 1) & 0x07;\n+        guint8 omitted_channels_present = b & 0x01;\n+\n+        if (channel_order_definition != 0) {\n+          GST_WARNING_OBJECT (qtdemux,\n+              \"Channel order definition %u not supported\",\n+              channel_order_definition);\n+          goto error;\n+        }\n+\n+        guint64 omitted_channels_map = 0;\n+        if (omitted_channels_present) {\n+          if (!gst_byte_reader_get_uint64_be (br, &omitted_channels_map)) {\n+            GST_WARNING_OBJECT (qtdemux, \"Too short chnl box\");\n+            goto error;\n+          }\n+        }\n+\n+        const GstAudioChannelPosition *layout = chnl_layouts[defined_layout];\n+\n+        \/\/ Calculate number of channels: number of channels in the layout\n+        \/\/ minus number of omitted channels\n+        n_channels = 0;\n+        for (unsigned int i = 0; i < G_N_ELEMENTS (chnl_layouts[0]); i++) {\n+          if (layout[i] == GST_AUDIO_CHANNEL_POSITION_INVALID)\n+            break;\n+\n+          n_channels += 1;\n+        }\n+        for (unsigned int i = 0; i < 64; i++) {\n+          if ((omitted_channels_map >> i) == 1) {\n+            n_channels -= 1;\n+          }\n+          \/\/ No channels present\n+          if (n_channels == 0) {\n+            goto error;\n+          }\n+        }\n+\n+        \/\/ The omitted channel map defines which of the channels of the\n+        \/\/ pre-defined layout are *not* included.\n+        for (unsigned int c = 0; c < n_channels; c++) {\n+          \/\/ Find c-th channel in layout that is not omitted\n+          unsigned int l_c = 0;\n+          for (unsigned int i = 0; i < 64; i++) {\n+            \/\/ If there are not enough non-omitted channels in the layout we end\n+            \/\/ up here and return\n+            if (layout[i] == GST_AUDIO_CHANNEL_POSITION_INVALID) {\n+              GST_WARNING_OBJECT (qtdemux,\n+                  \"Invalid defined layout %u with %u channels and omitted channels map %016\"\n+                  G_GINT64_MODIFIER \"x\", defined_layout, n_channels,\n+                  omitted_channels_map);\n+              goto error;\n+            }\n+\n+            \/\/ The i-th channel of the layout is included\n+            if (((omitted_channels_map >> i) & 1) == 0) {\n+              \/\/ The channel we're looking for\n+              if (l_c == c) {\n+                positions[c] = layout[l_c];\n+                break;\n+              }\n+              l_c += 1;\n+            }\n+          }\n+\n+          \/\/ If there are not enough non-omitted channels in the omitted\n+          \/\/ channels map then return here\n+          if (positions[c] == GST_AUDIO_CHANNEL_POSITION_INVALID) {\n+            GST_WARNING_OBJECT (qtdemux,\n+                \"Invalid defined layout %u with %u channels and omitted channels map %016\"\n+                G_GINT64_MODIFIER \"x\", defined_layout, n_channels,\n+                omitted_channels_map);\n+            goto error;\n+          }\n+        }\n+      }\n+    }\n+\n+    \/\/ stream carries objects\n+    if (stream_structure & 2) {\n+      guint8 object_count = base_channel_count - n_channels;\n+      GST_WARNING_OBJECT (qtdemux, \"Stream carries %u objects\", object_count);\n+      goto error;\n+    }\n+  } else {\n+    GST_WARNING_OBJECT (qtdemux,\n+        \"Unsupported chnl version %u flags %06x\", version, flags);\n+\n+    goto error;\n+  }\n+\n+#ifndef GST_DISABLE_GST_DEBUG\n+  {\n+    gchar *s = gst_audio_channel_positions_to_string (positions, n_channels);\n+\n+    GST_DEBUG_OBJECT (qtdemux, \"Retrieved channel positions %s\", s);\n+\n+    g_free (s);\n+  }\n+#endif\n+\n+  guint64 channel_mask;\n+  GstAudioChannelPosition valid_positions[64];\n+\n+  if (!gst_audio_channel_positions_to_mask (positions, n_channels, FALSE,\n+          &channel_mask)) {\n+    GST_WARNING_OBJECT (qtdemux, \"Can't convert channel positions to mask\");\n+    goto error;\n+  }\n+\n+  memcpy (valid_positions, positions, sizeof (positions[0]) * n_channels);\n+  if (!gst_audio_channel_positions_to_valid_order (valid_positions, n_channels)) {\n+    GST_WARNING_OBJECT (qtdemux,\n+        \"Can't convert channel positions to GStreamer channel order\");\n+    goto error;\n+  }\n+\n+  if (n_channels > 1) {\n+    if (!gst_audio_get_channel_reorder_map (n_channels, positions,\n+            valid_positions, entry->reorder_map)) {\n+      GST_WARNING_OBJECT (qtdemux, \"Can't calculate channel reorder map\");\n+      goto error;\n+    }\n+    entry->needs_reorder =\n+        memcmp (positions, valid_positions,\n+        sizeof (positions[0]) * n_channels) != 0;\n+  }\n+\n+  gst_caps_set_simple (entry->caps, \"channel-mask\", GST_TYPE_BITMASK,\n+      channel_mask, NULL);\n+\n+  \/\/ Update based on the actual channel count from this box\n+  entry->samples_per_frame = n_channels;\n+  entry->bytes_per_frame = n_channels * entry->bytes_per_sample;\n+  entry->samples_per_packet = entry->samples_per_frame;\n+  entry->bytes_per_packet = entry->bytes_per_sample;\n+\n+  stream->min_buffer_size = 1024 * entry->bytes_per_frame;\n+  stream->max_buffer_size = entry->rate * entry->bytes_per_frame;\n+  GST_DEBUG (\"setting min\/max buffer sizes to %d\/%d\", stream->min_buffer_size,\n+      stream->max_buffer_size);\n+\n+  return;\n+\n+error:\n+  {\n+    GST_WARNING_OBJECT (qtdemux,\n+        \"Configuring default channel mask for %u channels\", entry->n_channels);\n+\n+    if (entry->n_channels > 1) {\n+      \/\/ Set a default channel mask on errors\n+      guint64 default_mask =\n+          gst_audio_channel_get_fallback_mask (entry->n_channels);\n+\n+      gst_caps_set_simple (entry->caps, \"channel-mask\", GST_TYPE_BITMASK,\n+          default_mask, NULL);\n+    }\n+  }\n+}\n+\n+\/\/ See CoreAudioTypes.h and ffmpeg's mov_chan.h\n+typedef enum\n+{\n+  AUDIO_CHANNEL_LAYOUT_TAG_USECHANNELDESCRIPTIONS = (0 << 16) | 0,\n+  AUDIO_CHANNEL_LAYOUT_TAG_USECHANNELBITMAP = (1 << 16) | 0,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_MONO = (100 << 16) | 1,\n+  AUDIO_CHANNEL_LAYOUT_TAG_STEREO = (101 << 16) | 2,\n+  AUDIO_CHANNEL_LAYOUT_TAG_STEREOHEADPHONES = (102 << 16) | 2,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MATRIXSTEREO = (103 << 16) | 2,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MIDSIDE = (104 << 16) | 2,\n+  AUDIO_CHANNEL_LAYOUT_TAG_XY = (105 << 16) | 2,\n+  AUDIO_CHANNEL_LAYOUT_TAG_BINAURAL = (106 << 16) | 2,\n+  AUDIO_CHANNEL_LAYOUT_TAG_AMBISONIC_B_FORMAT = (107 << 16) | 4,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_QUADRAPHONIC = (108 << 16) | 4,\n+  AUDIO_CHANNEL_LAYOUT_TAG_PENTAGONAL = (109 << 16) | 5,\n+  AUDIO_CHANNEL_LAYOUT_TAG_HEXAGONAL = (110 << 16) | 6,\n+  AUDIO_CHANNEL_LAYOUT_TAG_OCTAGONAL = (111 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_CUBE = (112 << 16) | 8,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_3_0_A = (113 << 16) | 3,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_3_0_B = (114 << 16) | 3,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_4_0_A = (115 << 16) | 4,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_4_0_B = (116 << 16) | 4,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_0_A = (117 << 16) | 5,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_0_B = (118 << 16) | 5,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_0_C = (119 << 16) | 5,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_0_D = (120 << 16) | 5,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_1_A = (121 << 16) | 6,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_1_B = (122 << 16) | 6,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_1_C = (123 << 16) | 6,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_1_D = (124 << 16) | 6,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_6_1_A = (125 << 16) | 7,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_7_1_A = (126 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_7_1_B = (127 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_MPEG_7_1_C = (128 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_EMAGIC_DEFAULT_7_1 = (129 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_SMPTE_DTV = (130 << 16) | 8,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_ITU_2_1 = (131 << 16) | 3,\n+  AUDIO_CHANNEL_LAYOUT_TAG_ITU_2_2 = (132 << 16) | 4,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_DVD_4 = (133 << 16) | 3,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DVD_5 = (134 << 16) | 4,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DVD_6 = (135 << 16) | 5,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DVD_10 = (136 << 16) | 4,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DVD_11 = (137 << 16) | 5,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DVD_18 = (138 << 16) | 5,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_AUDIOUNIT_6_0 = (139 << 16) | 6,\n+  AUDIO_CHANNEL_LAYOUT_TAG_AUDIOUNIT_7_0 = (140 << 16) | 7,\n+  AUDIO_CHANNEL_LAYOUT_TAG_AUDIOUNIT_7_0_FRONT = (148 << 16) | 7,\n+  AUDIO_CHANNEL_LAYOUT_TAG_AAC_6_0 = (141 << 16) | 6,\n+  AUDIO_CHANNEL_LAYOUT_TAG_AAC_6_1 = (142 << 16) | 7,\n+  AUDIO_CHANNEL_LAYOUT_TAG_AAC_7_0 = (143 << 16) | 7,\n+  AUDIO_CHANNEL_LAYOUT_TAG_AAC_7_1_B = (183 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_AAC_OCTAGONAL = (144 << 16) | 8,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_TMH_10_2_STD = (145 << 16) | 16,\n+  AUDIO_CHANNEL_LAYOUT_TAG_TMH_10_2_FULL = (146 << 16) | 21,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_AC3_1_0_1 = (149 << 16) | 2,\n+  AUDIO_CHANNEL_LAYOUT_TAG_AC3_3_0 = (150 << 16) | 3,\n+  AUDIO_CHANNEL_LAYOUT_TAG_AC3_3_1 = (151 << 16) | 4,\n+  AUDIO_CHANNEL_LAYOUT_TAG_AC3_3_0_1 = (152 << 16) | 4,\n+  AUDIO_CHANNEL_LAYOUT_TAG_AC3_2_1_1 = (153 << 16) | 4,\n+  AUDIO_CHANNEL_LAYOUT_TAG_AC3_3_1_1 = (154 << 16) | 5,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_EAC_6_0_A = (155 << 16) | 6,\n+  AUDIO_CHANNEL_LAYOUT_TAG_EAC_7_0_A = (156 << 16) | 7,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_EAC3_6_1_A = (157 << 16) | 7,\n+  AUDIO_CHANNEL_LAYOUT_TAG_EAC3_6_1_B = (158 << 16) | 7,\n+  AUDIO_CHANNEL_LAYOUT_TAG_EAC3_6_1_C = (159 << 16) | 7,\n+  AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_A = (160 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_B = (161 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_C = (162 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_D = (163 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_E = (164 << 16) | 8,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_F = (165 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_G = (166 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_H = (167 << 16) | 8,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_3_1 = (168 << 16) | 4,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_4_1 = (169 << 16) | 5,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_0_A = (170 << 16) | 6,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_0_B = (171 << 16) | 6,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_0_C = (172 << 16) | 6,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_1_A = (173 << 16) | 7,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_1_B = (174 << 16) | 7,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_1_C = (175 << 16) | 7,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_7_0 = (176 << 16) | 7,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_7_1 = (177 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_8_0_A = (178 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_8_0_B = (179 << 16) | 8,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_8_1_A = (180 << 16) | 9,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_8_1_B = (181 << 16) | 9,\n+  AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_1_D = (182 << 16) | 7,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_HOA_ACN_SN3D = (190U << 16) | 0,\n+  AUDIO_CHANNEL_LAYOUT_TAG_HOA_ACN_N3D = (191U << 16) | 0,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_ATMOS_7_1_4 = (192U << 16) | 12,\n+  AUDIO_CHANNEL_LAYOUT_TAG_ATMOS_9_1_6 = (193U << 16) | 16,\n+  AUDIO_CHANNEL_LAYOUT_TAG_ATMOS_5_1_2 = (194U << 16) | 8,\n+\n+  AUDIO_CHANNEL_LAYOUT_TAG_DISCRETEINORDER = (147 << 16) | 0,\n+  AUDIO_CHANNEL_LAYOUT_TAG_UNKNOWN = 0xFFFF0000\n+} AudioChannelLayoutTag;\n+\n+static const struct\n+{\n+  AudioChannelLayoutTag tag;\n+  const GstAudioChannelPosition *positions;\n+} chan_layout_map[] = {\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MONO,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_MONO,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_STEREO,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_STEREOHEADPHONES,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MATRIXSTEREO,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MIDSIDE,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_XY,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_BINAURAL,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+            },\n+      },\n+  \/\/ TODO: AUDIO_CHANNEL_LAYOUT_TAG_AMBISONIC_B_FORMAT\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_QUADRAPHONIC,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_PENTAGONAL,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_HEXAGONAL,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_OCTAGONAL,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_CUBE,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_3_0_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_3_0_B,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_4_0_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_4_0_B,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_0_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_0_B,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_0_C,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_0_D,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_1_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_1_B,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_1_C,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_5_1_D,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_6_1_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_7_1_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_7_1_B,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_MPEG_7_1_C,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_EMAGIC_DEFAULT_7_1,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+            },\n+      },\n+  \/\/ TODO: AUDIO_CHANNEL_LAYOUT_TAG_SMPTE_DTV\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_ITU_2_1,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_ITU_2_2,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DVD_4,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DVD_5,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DVD_6,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DVD_10,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DVD_11,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DVD_18,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AUDIOUNIT_6_0,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AUDIOUNIT_7_0,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AUDIOUNIT_7_0_FRONT,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AAC_6_0,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AAC_6_1,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AAC_7_0,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AAC_7_1_B,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AAC_OCTAGONAL,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+\n+\/\/ TODO: AUDIO_CHANNEL_LAYOUT_TAG_TMH_10_2_STD\n+\/\/ TODO: AUDIO_CHANNEL_LAYOUT_TAG_TMH_10_2_FULL\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AC3_1_0_1,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AC3_3_0,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AC3_3_1,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AC3_3_0_1,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AC3_2_1_1,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_AC3_3_1_1,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_EAC_6_0_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_EAC_7_0_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+            },\n+      },\n+\n+\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_EAC3_6_1_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+\/\/ TODO: AUDIO_CHANNEL_LAYOUT_TAG_EAC3_6_1_B,\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_EAC3_6_1_C,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_B,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_C,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_D,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_WIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_WIDE_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_E,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_F,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_G,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_EAC3_7_1_H,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_3_1,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_4_1,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_0_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_0_B,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_0_C,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_1_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_1_B,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_1_C,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_7_0,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_7_1,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_8_0_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_8_0_B,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+            },\n+      },\n+\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_8_1_A,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_8_1_B,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+            },\n+      },\n+\n+  {\n+        AUDIO_CHANNEL_LAYOUT_TAG_DTS_6_1_D,\n+        (const GstAudioChannelPosition[]) {\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+              GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+              GST_AUDIO_CHANNEL_POSITION_LFE1,\n+              GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+            },\n+      },\n+\n+  \/\/ TODO: AUDIO_CHANNEL_LAYOUT_TAG_HOA_ACN_SN3D\n+  \/\/ TODO: AUDIO_CHANNEL_LAYOUT_TAG_HOA_ACN_N3D\n+  \/\/ TODO: AUDIO_CHANNEL_LAYOUT_TAG_ATMOS_7_1_4\n+  \/\/ TODO: AUDIO_CHANNEL_LAYOUT_TAG_ATMOS_9_1_6\n+  \/\/ TODO: AUDIO_CHANNEL_LAYOUT_TAG_ATMOS_5_1_2\n+};\n+\n+\/\/ Mapping bit N to GstAudioChannelPosition\n+static const GstAudioChannelPosition audio_channel_bitmap_mapping[32] = {\n+  GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,        \/\/ 0\n+  GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+  GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+  GST_AUDIO_CHANNEL_POSITION_LFE1,\n+  GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+  GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+  GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,\n+  GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+  GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT,    \/\/ 10\n+  GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER,\n+  GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT,    \/\/ 17\n+  GST_AUDIO_CHANNEL_POSITION_INVALID,\n+  GST_AUDIO_CHANNEL_POSITION_INVALID,\n+  GST_AUDIO_CHANNEL_POSITION_INVALID,   \/\/ 20\n+  GST_AUDIO_CHANNEL_POSITION_INVALID,   \/\/ LeftTopMiddle\n+  GST_AUDIO_CHANNEL_POSITION_INVALID,\n+  GST_AUDIO_CHANNEL_POSITION_INVALID,   \/\/ RightTopMiddle\n+  GST_AUDIO_CHANNEL_POSITION_INVALID,   \/\/ LeftTopRear\n+  GST_AUDIO_CHANNEL_POSITION_INVALID,   \/\/ CenterTopRear\n+  GST_AUDIO_CHANNEL_POSITION_INVALID,   \/\/ RightTopRear\n+};\n+\n+typedef enum\n+{\n+  AUDIO_CHANNEL_LABEL_UNKNOWN = 0xFFFFFFFF,\n+  AUDIO_CHANNEL_LABEL_UNUSED = 0,\n+  AUDIO_CHANNEL_LABEL_USE_COORDINATES = 100,\n+\n+  AUDIO_CHANNEL_LABEL_LEFT = 1,\n+  AUDIO_CHANNEL_LABEL_RIGHT = 2,\n+  AUDIO_CHANNEL_LABEL_CENTER = 3,\n+  AUDIO_CHANNEL_LABEL_LFE_SCREEN = 4,\n+  AUDIO_CHANNEL_LABEL_LEFT_SURROUND = 5,\n+  AUDIO_CHANNEL_LABEL_RIGHT_SURROUND = 6,\n+  AUDIO_CHANNEL_LABEL_LEFT_CENTER = 7,\n+  AUDIO_CHANNEL_LABEL_RIGHT_CENTER = 8,\n+  AUDIO_CHANNEL_LABEL_CENTER_SURROUND = 9,\n+  AUDIO_CHANNEL_LABEL_LEFT_SURROUND_DIRECT = 10,\n+  AUDIO_CHANNEL_LABEL_RIGHT_SURROUND_DIRECT = 11,\n+  AUDIO_CHANNEL_LABEL_TOP_CENTER_SURROUND = 12,\n+  AUDIO_CHANNEL_LABEL_VERTICAL_HEIGHT_LEFT = 13,\n+  AUDIO_CHANNEL_LABEL_VERTICAL_HEIGHT_CENTER = 14,\n+  AUDIO_CHANNEL_LABEL_VERTICAL_HEIGHT_RIGHT = 15,\n+\n+  AUDIO_CHANNEL_LABEL_TOP_BACK_LEFT = 16,\n+  AUDIO_CHANNEL_LABEL_TOP_BACK_CENTER = 17,\n+  AUDIO_CHANNEL_LABEL_TOP_BACK_RIGHT = 18,\n+\n+  AUDIO_CHANNEL_LABEL_REAR_SURROUND_LEFT = 33,\n+  AUDIO_CHANNEL_LABEL_REAR_SURROUND_RIGHT = 34,\n+  AUDIO_CHANNEL_LABEL_LEFT_WIDE = 35,\n+  AUDIO_CHANNEL_LABEL_RIGHT_WIDE = 36,\n+  AUDIO_CHANNEL_LABEL_LFE2 = 37,\n+  AUDIO_CHANNEL_LABEL_LEFT_TOTAL = 38,\n+  AUDIO_CHANNEL_LABEL_RIGHT_TOTAL = 39,\n+  AUDIO_CHANNEL_LABEL_HEARING_IMPAIRED = 40,\n+  AUDIO_CHANNEL_LABEL_NARRATION = 41,\n+  AUDIO_CHANNEL_LABEL_MONO = 42,\n+  AUDIO_CHANNEL_LABEL_DIALOG_CENTRIC_MIX = 43,\n+\n+  AUDIO_CHANNEL_LABEL_CENTER_SURROUND_DIRECT = 44,\n+\n+  AUDIO_CHANNEL_LABEL_HAPTIC = 45,\n+\n+  AUDIO_CHANNEL_LABEL_LEFT_TOP_MIDDLE = 49,\n+  AUDIO_CHANNEL_LABEL_RIGHT_TOP_MIDDLE = 51,\n+  AUDIO_CHANNEL_LABEL_LEFT_TOP_REAR = 52,\n+  AUDIO_CHANNEL_LABEL_CENTER_TOP_REAR = 53,\n+  AUDIO_CHANNEL_LABEL_RIGHT_TOP_REAR = 54,\n+\n+  AUDIO_CHANNEL_LABEL_AMBISONIC_W = 200,\n+  AUDIO_CHANNEL_LABEL_AMBISONIC_X = 201,\n+  AUDIO_CHANNEL_LABEL_AMBISONIC_Y = 202,\n+  AUDIO_CHANNEL_LABEL_AMBISONIC_Z = 203,\n+\n+  AUDIO_CHANNEL_LABEL_MS_MID = 204,\n+  AUDIO_CHANNEL_LABEL_MS_SIDE = 205,\n+\n+  AUDIO_CHANNEL_LABEL_XY_X = 206,\n+  AUDIO_CHANNEL_LABEL_XY_Y = 207,\n+\n+  AUDIO_CHANNEL_LABEL_BINAURAL_LEFT = 208,\n+  AUDIO_CHANNEL_LABEL_BINAURAL_RIGHT = 209,\n+\n+  AUDIO_CHANNEL_LABEL_HEADPHONES_LEFT = 301,\n+  AUDIO_CHANNEL_LABEL_HEADPHONES_RIGHT = 302,\n+  AUDIO_CHANNEL_LABEL_CLICK_TRACK = 304,\n+  AUDIO_CHANNEL_LABEL_FOREIGN_LANGUAGE = 305,\n+} AudioChannelLabel;\n+\n+static const struct\n+{\n+  AudioChannelLabel label;\n+  GstAudioChannelPosition position;\n+} audio_channel_label_mapping[] = {\n+  {\n+        AUDIO_CHANNEL_LABEL_MONO,\n+      GST_AUDIO_CHANNEL_POSITION_MONO},\n+  {\n+        AUDIO_CHANNEL_LABEL_LEFT,\n+      GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT},\n+  {\n+        AUDIO_CHANNEL_LABEL_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_CENTER,\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_LFE_SCREEN,\n+        GST_AUDIO_CHANNEL_POSITION_LFE1,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_LEFT_SURROUND,\n+        GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_RIGHT_SURROUND,\n+        GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_LEFT_CENTER,\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_RIGHT_CENTER,\n+      GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER},\n+  {\n+        AUDIO_CHANNEL_LABEL_CENTER_SURROUND,\n+        GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_LEFT_SURROUND_DIRECT,\n+        GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_RIGHT_SURROUND_DIRECT,\n+        GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_TOP_CENTER_SURROUND,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_VERTICAL_HEIGHT_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_VERTICAL_HEIGHT_CENTER,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_VERTICAL_HEIGHT_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_TOP_BACK_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_TOP_BACK_CENTER,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_TOP_BACK_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_REAR_SURROUND_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_REAR_SURROUND_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_LEFT_WIDE,\n+        GST_AUDIO_CHANNEL_POSITION_WIDE_LEFT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_RIGHT_WIDE,\n+        GST_AUDIO_CHANNEL_POSITION_WIDE_RIGHT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_LFE2,\n+        GST_AUDIO_CHANNEL_POSITION_LFE2,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_BINAURAL_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_BINAURAL_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_HEADPHONES_LEFT,\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,\n+      },\n+  {\n+        AUDIO_CHANNEL_LABEL_HEADPHONES_RIGHT,\n+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,\n+      }\n+};\n+\n+static void\n+qtdemux_parse_chan (GstQTDemux * qtdemux, GstByteReader * br,\n+    QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry)\n+{\n+  GstAudioChannelPosition positions[64];\n+  guint n_channels = 0;\n+\n+  \/\/ Skip over version and flags\n+  gst_byte_reader_skip_unchecked (br, 4);\n+\n+  if (gst_byte_reader_get_remaining (br) < 12)\n+    return;\n+\n+  guint32 layout_tag = gst_byte_reader_get_uint32_be_unchecked (br);\n+  guint32 bitmap = gst_byte_reader_get_uint32_be_unchecked (br);\n+  guint32 num_channel_descs = gst_byte_reader_get_uint32_be_unchecked (br);\n+\n+  if (gst_byte_reader_get_remaining (br) < num_channel_descs * 5 * 4)\n+    return;\n+\n+  if (layout_tag == AUDIO_CHANNEL_LAYOUT_TAG_USECHANNELBITMAP) {\n+    \/\/ Invalid\/unsupported positions are mapped to defaults later\n+    for (gsize i = 0; i < G_N_ELEMENTS (audio_channel_bitmap_mapping); i++) {\n+      if (bitmap & (1 << i)) {\n+        positions[n_channels] = audio_channel_bitmap_mapping[i];\n+        n_channels += 1;\n+      }\n+    }\n+  } else if (layout_tag == AUDIO_CHANNEL_LAYOUT_TAG_USECHANNELDESCRIPTIONS) {\n+    if (num_channel_descs < 64) {\n+      n_channels = num_channel_descs;\n+\n+      for (guint32 i = 0; i < num_channel_descs; i++) {\n+        positions[i] = GST_AUDIO_CHANNEL_POSITION_INVALID;\n+\n+        guint32 label = gst_byte_reader_get_uint32_be_unchecked (br);\n+\n+        \/\/ Discrete channel\n+        if (label == 400 || (label >> 16) == 1) {\n+          positions[i] = GST_AUDIO_CHANNEL_POSITION_NONE;\n+        } else {\n+          \/\/ If a label is not found the channel stays invalid and is\n+          \/\/ handled as an error later with mapping to the defaults\n+          for (gsize j = 0; j < G_N_ELEMENTS (audio_channel_label_mapping); j++) {\n+            if (audio_channel_label_mapping[j].label == label) {\n+              positions[i] = audio_channel_label_mapping[j].position;\n+              break;\n+            }\n+          }\n+        }\n+\n+        \/\/ Skip coordinates and flags\n+        gst_byte_reader_skip_unchecked (br, 4 * 4);\n+      }\n+    }\n+  } else if (layout_tag == AUDIO_CHANNEL_LAYOUT_TAG_DISCRETEINORDER) {\n+    \/\/ Unordered\n+    n_channels = entry->n_channels;\n+    for (gsize i = 0; i < n_channels; i++) {\n+      positions[i] = GST_AUDIO_CHANNEL_POSITION_NONE;\n+    }\n+  } else if (layout_tag & 0xffff) {\n+    for (gsize i = 0; i < G_N_ELEMENTS (chan_layout_map); i++) {\n+      if (chan_layout_map[i].tag == layout_tag) {\n+        n_channels = layout_tag & 0xffff;\n+        memcpy (positions, chan_layout_map[i].positions,\n+            n_channels * sizeof (GstAudioChannelPosition));\n+        break;\n+      }\n+    }\n+  }\n+\n+  if (n_channels == 0) {\n+    GST_WARNING_OBJECT (qtdemux, \"Unsupported channel layout tag 0x%08x\",\n+        layout_tag);\n+    return;\n+  }\n+\n+#ifndef GST_DISABLE_GST_DEBUG\n+  {\n+    gchar *s = gst_audio_channel_positions_to_string (positions, n_channels);\n+\n+    GST_DEBUG_OBJECT (qtdemux, \"Retrieved channel positions %s\", s);\n+\n+    g_free (s);\n+  }\n+#endif\n+\n+  guint64 channel_mask;\n+  GstAudioChannelPosition valid_positions[64];\n+\n+  if (!gst_audio_channel_positions_to_mask (positions, n_channels, FALSE,\n+          &channel_mask)) {\n+    GST_WARNING_OBJECT (qtdemux, \"Can't convert channel positions to mask\");\n+    goto error;\n+  }\n+\n+  memcpy (valid_positions, positions, sizeof (positions[0]) * n_channels);\n+  if (!gst_audio_channel_positions_to_valid_order (valid_positions, n_channels)) {\n+    GST_WARNING_OBJECT (qtdemux,\n+        \"Can't convert channel positions to GStreamer channel order\");\n+    goto error;\n+  }\n+\n+  if (n_channels > 1) {\n+    if (!gst_audio_get_channel_reorder_map (n_channels, positions,\n+            valid_positions, entry->reorder_map)) {\n+      GST_WARNING_OBJECT (qtdemux, \"Can't calculate channel reorder map\");\n+      goto error;\n+    }\n+    entry->needs_reorder =\n+        memcmp (positions, valid_positions,\n+        sizeof (positions[0]) * n_channels) != 0;\n+  }\n+\n+  gst_caps_set_simple (entry->caps, \"channel-mask\", GST_TYPE_BITMASK,\n+      channel_mask, NULL);\n+\n+  \/\/ Update based on the actual channel count from this box\n+  entry->samples_per_frame = n_channels;\n+  entry->bytes_per_frame = n_channels * entry->bytes_per_sample;\n+  entry->samples_per_packet = entry->samples_per_frame;\n+  entry->bytes_per_packet = entry->bytes_per_sample;\n+\n+  stream->min_buffer_size = 1024 * entry->bytes_per_frame;\n+  stream->max_buffer_size = entry->rate * entry->bytes_per_frame;\n+  GST_DEBUG (\"setting min\/max buffer sizes to %d\/%d\", stream->min_buffer_size,\n+      stream->max_buffer_size);\n+\n+  return;\n+\n+error:\n+  {\n+    GST_WARNING_OBJECT (qtdemux,\n+        \"Configuring default channel mask for %u channels\", entry->n_channels);\n+\n+    if (entry->n_channels > 1) {\n+      \/\/ Set a default channel mask on errors\n+      guint64 default_mask =\n+          gst_audio_channel_get_fallback_mask (entry->n_channels);\n+\n+      gst_caps_set_simple (entry->caps, \"channel-mask\", GST_TYPE_BITMASK,\n+          default_mask, NULL);\n+    }\n+  }\n+}\n+\n+\/* parse the traks.\n+ * With each track we associate a new QtDemuxStream that contains all the info\n+ * about the trak.\n+ * traks that do not decode to something (like strm traks) will not have a pad.\n+ *\/\n+static gboolean\n+qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak, guint32 * mvhd_matrix)\n+{\n+  GstByteReader tkhd;\n+  int offset;\n+  GNode *mdia;\n+  GNode *mdhd;\n+  GNode *hdlr;\n+  GNode *minf;\n+  GNode *stbl;\n+  GNode *stsd;\n+  GNode *esds;\n+  GNode *tref;\n+  GNode *udta;\n+\n+  QtDemuxStream *stream = NULL;\n+  const guint8 *stsd_data;\n+  guint8 stsd_version;\n+  guint stsd_entry_count;\n+  guint stsd_index;\n+  guint16 lang_code;            \/* quicktime lang code or packed iso code *\/\n+  guint32 version;\n+  guint32 tkhd_flags = 0;\n+  guint8 tkhd_version = 0;\n+  guint32 w = 0, h = 0;\n+  guint value_size, stsd_len, len;\n+  guint32 track_id;\n+  guint32 dummy;\n+\n+  GST_DEBUG_OBJECT (qtdemux, \"parse_trak\");\n+\n+  if (!qtdemux_tree_get_child_by_type_full (trak, FOURCC_tkhd, &tkhd)\n+      || !gst_byte_reader_get_uint8 (&tkhd, &tkhd_version)\n+      || !gst_byte_reader_get_uint24_be (&tkhd, &tkhd_flags))\n+    goto corrupt_file;\n+\n+  \/* pick between 64 or 32 bits *\/\n+  value_size = tkhd_version == 1 ? 8 : 4;\n+  if (!gst_byte_reader_skip (&tkhd, value_size * 2) ||\n+      !gst_byte_reader_get_uint32_be (&tkhd, &track_id))\n+    goto corrupt_file;\n+\n+  \/* Check if current moov has duplicated track_id *\/\n+  if (qtdemux_find_stream (qtdemux, track_id))\n+    goto existing_stream;\n+\n+  stream = _create_stream (qtdemux, track_id);\n+  stream->stream_tags = gst_tag_list_make_writable (stream->stream_tags);\n+\n+  \/* need defaults for fragments *\/\n+  qtdemux_parse_trex (qtdemux, stream, &dummy, &dummy, &dummy);\n+\n+  if ((tkhd_flags & 1) == 0)\n+    stream->disabled = TRUE;\n+\n+#ifdef GSTREAMER_LITE\n+  \/\/ set track_enabled based on bit 0 of flags\n+  stream->track_enabled = (gboolean)(tkhd_flags & 0x000001);\n+#endif \/\/ GSTREAMER_LITE\n+\n+  GST_LOG_OBJECT (qtdemux, \"track[tkhd] version\/flags\/id: 0x%02x\/%06x\/%u\",\n+      tkhd_version, tkhd_flags, stream->track_id);\n+\n+  if (!(mdia = qtdemux_tree_get_child_by_type (trak, FOURCC_mdia)))\n+    goto corrupt_file;\n+\n+  if (!(mdhd = qtdemux_tree_get_child_by_type (mdia, FOURCC_mdhd))) {\n@@ -12021,0 +14822,1 @@\n+    guint32 tkhd_matrix[9];\n@@ -12027,1 +14829,2 @@\n-    if (!qtdemux_parse_transformation_matrix (qtdemux, &tkhd, matrix, \"tkhd\"))\n+    if (!qtdemux_parse_transformation_matrix (qtdemux, &tkhd, tkhd_matrix,\n+            \"tkhd\"))\n@@ -12030,0 +14833,4 @@\n+    \/* calculate the final matrix from the mvhd_matrix and the tkhd matrix *\/\n+    qtdemux_mul_transformation_matrix (qtdemux, mvhd_matrix, tkhd_matrix,\n+        matrix);\n+\n@@ -12055,0 +14862,1 @@\n+  stsd_version = QT_UINT8 (stsd_data + 8);\n@@ -12074,2 +14882,0 @@\n-  stsd_entry_data = stsd_data + 16;\n-  remaining_stsd_len = stsd_len - 16;\n@@ -12077,0 +14883,2 @@\n+    GNode *stsd_entry;\n+    const guint8 *stsd_entry_data;\n@@ -12081,3 +14889,2 @@\n-    \/* and that entry should fit within stsd *\/\n-    len = QT_UINT32 (stsd_entry_data);\n-    if (len > remaining_stsd_len)\n+    stsd_entry = qtdemux_tree_get_child_by_index (stsd, stsd_index);\n+    if (!stsd_entry)\n@@ -12086,0 +14893,4 @@\n+    stsd_entry_data = stsd_entry->data;\n+\n+    len = QT_UINT32 (stsd_entry_data);\n+\n@@ -12111,3 +14922,0 @@\n-      \/* FIXME this looks wrong, there might be multiple children\n-       * with the same type *\/\n-      GNode *enc = qtdemux_tree_get_child_by_type (stsd, fourcc);\n@@ -12115,1 +14923,2 @@\n-      if (!qtdemux_parse_protection_scheme_info (qtdemux, stream, enc, &fourcc)) {\n+      if (!qtdemux_parse_protection_scheme_info (qtdemux, stream, stsd_entry,\n+              &fourcc)) {\n@@ -12125,0 +14934,4 @@\n+      GNode *btrt;\n+      GNode *clli;\n+      GNode *mdcv;\n+      guint32 version;\n@@ -12135,1 +14948,2 @@\n-      if (len < 86)             \/* TODO verify *\/\n+      \/* sample description entry (16) + visual sample description (70) *\/\n+      if (len < 86)\n@@ -12138,0 +14952,1 @@\n+      version = QT_UINT32 (stsd_entry_data + offset);\n@@ -12245,1 +15060,1 @@\n-          qtdemux_video_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,\n+          qtdemux_video_caps (qtdemux, stream, entry, fourcc, stsd_entry,\n@@ -12291,25 +15106,7 @@\n-      esds = NULL;\n-      pasp = NULL;\n-      colr = NULL;\n-      fiel = NULL;\n-      \/* pick 'the' stsd child *\/\n-      mp4v = qtdemux_tree_get_child_by_index (stsd, stsd_index);\n-      \/\/ We should skip parsing the stsd for non-protected streams if\n-      \/\/ the entry doesn't match the fourcc, since they don't change\n-      \/\/ format. However, for protected streams we can have partial\n-      \/\/ encryption, where parts of the stream are encrypted and parts\n-      \/\/ not. For both parts of such streams, we should ensure the\n-      \/\/ esds overrides are parsed for both from the stsd.\n-      if (QTDEMUX_TREE_NODE_FOURCC (mp4v) != fourcc) {\n-        if (stream->protected && QTDEMUX_TREE_NODE_FOURCC (mp4v) != FOURCC_encv)\n-          mp4v = NULL;\n-        else if (!stream->protected)\n-          mp4v = NULL;\n-      }\n-\n-      if (mp4v) {\n-        esds = qtdemux_tree_get_child_by_type (mp4v, FOURCC_esds);\n-        pasp = qtdemux_tree_get_child_by_type (mp4v, FOURCC_pasp);\n-        colr = qtdemux_tree_get_child_by_type (mp4v, FOURCC_colr);\n-        fiel = qtdemux_tree_get_child_by_type (mp4v, FOURCC_fiel);\n-      }\n+      esds = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_esds);\n+      pasp = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_pasp);\n+      colr = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_colr);\n+      fiel = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_fiel);\n+      btrt = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_btrt);\n+      clli = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_clli);\n+      mdcv = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_mdcv);\n@@ -12373,0 +15170,72 @@\n+      if (clli) {\n+        const guint8 *clli_data = clli->data;\n+        guint32 len = QT_UINT32 (clli_data);\n+\n+        if (len >= 8 + 2 * 2) {\n+          CUR_STREAM (stream)->content_light_level_set = TRUE;\n+          CUR_STREAM (stream)->content_light_level.max_content_light_level =\n+              QT_UINT16 (clli_data + 8);\n+          CUR_STREAM (stream)->\n+              content_light_level.max_frame_average_light_level =\n+              QT_UINT16 (clli_data + 10);\n+        }\n+      }\n+\n+      if (mdcv) {\n+        const guint8 *mdcv_data = mdcv->data;\n+        guint32 len = QT_UINT32 (mdcv_data);\n+\n+        if (len >= 8 + 3 * 2 * 2 + 2 * 2 + 2 * 4) {\n+          CUR_STREAM (stream)->mastering_display_info_set = TRUE;\n+          for (gsize c = 0; c < 3; c++) {\n+            CUR_STREAM (stream)->mastering_display_info.display_primaries[c].x =\n+                QT_UINT16 (mdcv_data + 8 + c * 2 * 2);\n+            CUR_STREAM (stream)->mastering_display_info.display_primaries[c].y =\n+                QT_UINT16 (mdcv_data + 8 + c * 2 * 2 + 2);\n+          }\n+          CUR_STREAM (stream)->mastering_display_info.white_point.x =\n+              QT_UINT16 (mdcv_data + 8 + 3 * 2 * 2);\n+          CUR_STREAM (stream)->mastering_display_info.white_point.y =\n+              QT_UINT16 (mdcv_data + 8 + 3 * 2 * 2 + 2);\n+          CUR_STREAM (stream)->\n+              mastering_display_info.max_display_mastering_luminance =\n+              QT_UINT16 (mdcv_data + 8 + 3 * 2 * 2 + 2 * 2);\n+          CUR_STREAM (stream)->\n+              mastering_display_info.min_display_mastering_luminance =\n+              QT_UINT16 (mdcv_data + 8 + 3 * 2 * 2 + 2 * 2 + 4);\n+        }\n+      }\n+\n+      if (btrt) {\n+        const guint8 *data;\n+        guint32 size;\n+\n+        data = btrt->data;\n+        size = QT_UINT32 (data);\n+\n+        \/* bufferSizeDB, maxBitrate and avgBitrate - 4 bytes each *\/\n+        if (size >= 8 + 12) {\n+\n+          guint32 max_bitrate = QT_UINT32 (data + 8 + 4);\n+          guint32 avg_bitrate = QT_UINT32 (data + 8 + 8);\n+\n+          \/* Some muxers seem to swap the average and maximum bitrates\n+           * (I'm looking at you, YouTube), so we swap for sanity. *\/\n+          if (max_bitrate > 0 && max_bitrate < avg_bitrate) {\n+            guint temp = avg_bitrate;\n+\n+            avg_bitrate = max_bitrate;\n+            max_bitrate = temp;\n+          }\n+          if (max_bitrate > 0 && max_bitrate < G_MAXUINT32) {\n+            gst_tag_list_add (stream->stream_tags,\n+                GST_TAG_MERGE_REPLACE, GST_TAG_MAXIMUM_BITRATE,\n+                max_bitrate, NULL);\n+          }\n+          if (avg_bitrate > 0 && avg_bitrate < G_MAXUINT32) {\n+            gst_tag_list_add (stream->stream_tags,\n+                GST_TAG_MERGE_REPLACE, GST_TAG_BITRATE, avg_bitrate, NULL);\n+          }\n+        }\n+      }\n+\n@@ -12388,66 +15257,30 @@\n-            guint32 len = QT_UINT32 (stsd_entry_data);\n-            len = len <= 0x56 ? 0 : len - 0x56;\n-            const guint8 *avc_data = stsd_entry_data + 0x56;\n-\n-            \/* find avcC *\/\n-            while (len >= 8) {\n-              guint32 size = QT_UINT32 (avc_data);\n-\n-              if (size < 8 || size > len)\n-                break;\n-\n-              switch (QT_FOURCC (avc_data + 4)) {\n-                case FOURCC_avcC:\n-                {\n-                  \/* parse, if found *\/\n-                  GstBuffer *buf;\n-\n-                  if (size < 8 + 1)\n-                    break;\n-\n-                  GST_DEBUG_OBJECT (qtdemux, \"found avcC codec_data in stsd\");\n-\n-                  \/* First 4 bytes are the length of the atom, the next 4 bytes\n-                   * are the fourcc, the next 1 byte is the version, and the\n-                   * subsequent bytes are profile_tier_level structure like data. *\/\n-                  gst_codec_utils_h264_caps_set_level_and_profile (entry->caps,\n-                      avc_data + 8 + 1, size - 8 - 1);\n-                  buf = gst_buffer_new_and_alloc (size - 8);\n-                  gst_buffer_fill (buf, 0, avc_data + 8, size - 8);\n-                  gst_caps_set_simple (entry->caps,\n-                      \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n-                  gst_buffer_unref (buf);\n-\n-                  break;\n-                }\n-                case FOURCC_strf:\n-                {\n-                  GstBuffer *buf;\n-\n-                  if (size < 8 + 40 + 1)\n-                    break;\n-\n-                  GST_DEBUG_OBJECT (qtdemux, \"found strf codec_data in stsd\");\n-\n-                  \/* First 4 bytes are the length of the atom, the next 4 bytes\n-                   * are the fourcc, next 40 bytes are BITMAPINFOHEADER,\n-                   * next 1 byte is the version, and the\n-                   * subsequent bytes are sequence parameter set like data. *\/\n-\n-                  gst_codec_utils_h264_caps_set_level_and_profile\n-                      (entry->caps, avc_data + 8 + 40 + 1, size - 8 - 40 - 1);\n-\n-                  buf = gst_buffer_new_and_alloc (size - 8 - 40);\n-                  gst_buffer_fill (buf, 0, avc_data + 8 + 40, size - 8 - 40);\n-                  gst_caps_set_simple (entry->caps,\n-                      \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n-                  gst_buffer_unref (buf);\n-                  break;\n-                }\n-                case FOURCC_btrt:\n-                {\n-                  guint avg_bitrate, max_bitrate;\n-\n-                  \/* bufferSizeDB, maxBitrate and avgBitrate - 4 bytes each *\/\n-                  if (size < 8 + 12)\n-                    break;\n+            GNode *avcC =\n+                qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_avcC);\n+            GNode *strf =\n+                qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_strf);\n+\n+            if (avcC) {\n+              const guint8 *data;\n+              guint32 size;\n+\n+              data = avcC->data;\n+              size = QT_UINT32 (data);\n+              if (size >= 8 + 1) {\n+                GstBuffer *buf;\n+\n+                GST_DEBUG_OBJECT (qtdemux, \"found avcC codec_data in stsd\");\n+\n+                \/* First 4 bytes are the length of the atom, the next 4 bytes\n+                 * are the fourcc, the next 1 byte is the version, and the\n+                 * subsequent bytes are profile_tier_level structure like data. *\/\n+                gst_codec_utils_h264_caps_set_level_and_profile (entry->caps,\n+                    data + 8 + 1, size - 8 - 1);\n+                buf = gst_buffer_new_and_alloc (size - 8);\n+                gst_buffer_fill (buf, 0, data + 8, size - 8);\n+                gst_caps_set_simple (entry->caps,\n+                    \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n+                gst_buffer_unref (buf);\n+              }\n+            } else if (strf) {\n+              const guint8 *data;\n+              guint32 size;\n@@ -12455,2 +15288,2 @@\n-                  max_bitrate = QT_UINT32 (avc_data + 8 + 4);\n-                  avg_bitrate = QT_UINT32 (avc_data + 8 + 8);\n+              data = strf->data;\n+              size = QT_UINT32 (data);\n@@ -12458,2 +15291,2 @@\n-                  if (!max_bitrate && !avg_bitrate)\n-                    break;\n+              if (size >= 8 + 40 + 1) {\n+                GstBuffer *buf;\n@@ -12461,4 +15294,0 @@\n-                  \/* Some muxers seem to swap the average and maximum bitrates\n-                   * (I'm looking at you, YouTube), so we swap for sanity. *\/\n-                  if (max_bitrate > 0 && max_bitrate < avg_bitrate) {\n-                    guint temp = avg_bitrate;\n@@ -12466,3 +15295,1 @@\n-                    avg_bitrate = max_bitrate;\n-                    max_bitrate = temp;\n-                  }\n+                GST_DEBUG_OBJECT (qtdemux, \"found strf codec_data in stsd\");\n@@ -12470,10 +15297,4 @@\n-                  if (max_bitrate > 0 && max_bitrate < G_MAXUINT32) {\n-                    gst_tag_list_add (stream->stream_tags,\n-                        GST_TAG_MERGE_REPLACE, GST_TAG_MAXIMUM_BITRATE,\n-                        max_bitrate, NULL);\n-                  }\n-                  if (avg_bitrate > 0 && avg_bitrate < G_MAXUINT32) {\n-                    gst_tag_list_add (stream->stream_tags,\n-                        GST_TAG_MERGE_REPLACE, GST_TAG_BITRATE, avg_bitrate,\n-                        NULL);\n-                  }\n+                \/* First 4 bytes are the length of the atom, the next 4 bytes\n+                 * are the fourcc, next 40 bytes are BITMAPINFOHEADER,\n+                 * next 1 byte is the version, and the\n+                 * subsequent bytes are sequence parameter set like data. *\/\n@@ -12481,2 +15302,2 @@\n-                  break;\n-                }\n+                gst_codec_utils_h264_caps_set_level_and_profile\n+                    (entry->caps, data + 8 + 40 + 1, size - 8 - 40 - 1);\n@@ -12484,2 +15305,5 @@\n-                default:\n-                  break;\n+                buf = gst_buffer_new_and_alloc (size - 8 - 40);\n+                gst_buffer_fill (buf, 0, data + 8 + 40, size - 8 - 40);\n+                gst_caps_set_simple (entry->caps,\n+                    \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n+                gst_buffer_unref (buf);\n@@ -12487,3 +15311,0 @@\n-\n-              len -= size;\n-              avc_data += size;\n@@ -12500,3 +15321,2 @@\n-            guint32 len = QT_UINT32 (stsd_entry_data);\n-            len = len <= 0x56 ? 0 : len - 0x56;\n-            const guint8 *hevc_data = stsd_entry_data + 0x56;\n+            GNode *hvcC =\n+                qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_hvcC);\n@@ -12504,3 +15324,3 @@\n-            \/* find hevc *\/\n-            while (len >= 8) {\n-              guint32 size = QT_UINT32 (hevc_data);\n+            if (hvcC) {\n+              const guint8 *data;\n+              guint32 size;\n@@ -12508,2 +15328,2 @@\n-              if (size < 8 || size > len)\n-                break;\n+              data = hvcC->data;\n+              size = QT_UINT32 (data);\n@@ -12511,5 +15331,2 @@\n-              switch (QT_FOURCC (hevc_data + 4)) {\n-                case FOURCC_hvcC:\n-                {\n-                  \/* parse, if found *\/\n-                  GstBuffer *buf;\n+              if (size >= 8 + 1) {\n+                GstBuffer *buf;\n@@ -12517,2 +15334,1 @@\n-                  if (size < 8 + 1)\n-                    break;\n+                GST_DEBUG_OBJECT (qtdemux, \"found hvcC codec_data in stsd\");\n@@ -12520,1 +15336,5 @@\n-                  GST_DEBUG_OBJECT (qtdemux, \"found hvcC codec_data in stsd\");\n+                \/* First 4 bytes are the length of the atom, the next 4 bytes\n+                 * are the fourcc, the next 1 byte is the version, and the\n+                 * subsequent bytes are sequence parameter set like data. *\/\n+                gst_codec_utils_h265_caps_set_level_tier_and_profile\n+                    (entry->caps, data + 8 + 1, size - 8 - 1);\n@@ -12522,5 +15342,15 @@\n-                  \/* First 4 bytes are the length of the atom, the next 4 bytes\n-                   * are the fourcc, the next 1 byte is the version, and the\n-                   * subsequent bytes are sequence parameter set like data. *\/\n-                  gst_codec_utils_h265_caps_set_level_tier_and_profile\n-                      (entry->caps, hevc_data + 8 + 1, size - 8 - 1);\n+                buf = gst_buffer_new_and_alloc (size - 8);\n+                gst_buffer_fill (buf, 0, data + 8, size - 8);\n+                gst_caps_set_simple (entry->caps,\n+                    \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n+                gst_buffer_unref (buf);\n+              }\n+            }\n+            break;\n+          }\n+          case FOURCC_H266:\n+          case FOURCC_vvc1:\n+          case FOURCC_vvi1:\n+          {\n+            GNode *vvcC =\n+                qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_vvcC);\n@@ -12528,5 +15358,22 @@\n-                  buf = gst_buffer_new_and_alloc (size - 8);\n-                  gst_buffer_fill (buf, 0, hevc_data + 8, size - 8);\n-                  gst_caps_set_simple (entry->caps,\n-                      \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n-                  gst_buffer_unref (buf);\n+            if (vvcC) {\n+              const guint8 *data;\n+              guint32 size;\n+\n+              data = vvcC->data;\n+              size = QT_UINT32 (data);\n+\n+\n+              if (size >= 12 + 1) {\n+                GstBuffer *buf;\n+                guint8 version;\n+\n+                GST_DEBUG_OBJECT (qtdemux, \"found vvcC codec_data in stsd\");\n+\n+                \/* First 4 bytes are the length of the atom, the next 4 bytes\n+                 * are the fourcc, the next 1 byte is the version, the next 3 bytes are flags and the\n+                 * subsequent bytes are the decoder configuration record. *\/\n+                version = data[8];\n+                if (version != 0) {\n+                  GST_ERROR_OBJECT (qtdemux,\n+                      \"Unsupported vvcC version %u. Only version 0 is supported\",\n+                      version);\n@@ -12535,2 +15382,9 @@\n-                default:\n-                  break;\n+\n+                gst_codec_utils_h266_caps_set_level_tier_and_profile\n+                    (entry->caps, data + 12, size - 12);\n+\n+                buf = gst_buffer_new_and_alloc (size - 12);\n+                gst_buffer_fill (buf, 0, data + 12, size - 12);\n+                gst_caps_set_simple (entry->caps,\n+                    \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n+                gst_buffer_unref (buf);\n@@ -12538,2 +15392,0 @@\n-              len -= size;\n-              hevc_data += size;\n@@ -12556,2 +15408,1 @@\n-            glbl = mp4v ?\n-                qtdemux_tree_get_child_by_type (mp4v, FOURCC_glbl) : NULL;\n+            glbl = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_glbl);\n@@ -12580,1 +15431,1 @@\n-            GNode *jp2h, *ihdr, *colr, *mjp2, *field, *prefix, *cmap, *cdef;\n+            GNode *jp2h, *ihdr, *colr, *prefix, *cmap, *cdef;\n@@ -12584,0 +15435,1 @@\n+            guint32 colr_len;\n@@ -12591,4 +15443,1 @@\n-            mjp2 = qtdemux_tree_get_child_by_index (stsd, stsd_index);\n-            if (!mjp2)\n-              break;\n-            jp2h = qtdemux_tree_get_child_by_type (mjp2, FOURCC_jp2h);\n+            jp2h = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_jp2h);\n@@ -12608,0 +15457,3 @@\n+            colr_len = QT_UINT32 (colr->data);\n+            if (colr_len < 15)\n+              break;\n@@ -12731,4 +15583,0 @@\n-            \/* some optional atoms *\/\n-            field = qtdemux_tree_get_child_by_type (mjp2, FOURCC_fiel);\n-            prefix = qtdemux_tree_get_child_by_type (mjp2, FOURCC_jp2x);\n-\n@@ -12736,5 +15584,3 @@\n-            if (field) {\n-              data = (guint8 *) field->data + 8;\n-              if (*data != 1)\n-                gst_caps_set_simple (entry->caps, \"fields\", G_TYPE_INT,\n-                    (gint) * data, NULL);\n+            if (CUR_STREAM (stream)->interlace_mode != 1) {\n+              gst_caps_set_simple (entry->caps, \"fields\", G_TYPE_INT,\n+                  CUR_STREAM (stream)->interlace_mode, NULL);\n@@ -12742,0 +15588,4 @@\n+\n+            \/* some optional atoms *\/\n+            prefix = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_jp2x);\n+\n@@ -12764,32 +15614,2 @@\n-            GstBuffer *buf;\n-            GstBuffer *seqh = NULL;\n-            const guint8 *gamma_data = NULL;\n-            guint len = QT_UINT32 (stsd_data);  \/* FIXME review - why put the whole stsd in codec data? *\/\n-\n-            qtdemux_parse_svq3_stsd_data (qtdemux, stsd_entry_data, &gamma_data,\n-                &seqh);\n-            if (gamma_data) {\n-              gst_caps_set_simple (entry->caps, \"applied-gamma\", G_TYPE_DOUBLE,\n-                  QT_FP32 (gamma_data), NULL);\n-            }\n-            if (seqh) {\n-              \/* sorry for the bad name, but we don't know what this is, other\n-               * than its own fourcc *\/\n-              gst_caps_set_simple (entry->caps, \"seqh\", GST_TYPE_BUFFER, seqh,\n-                  NULL);\n-              gst_buffer_unref (seqh);\n-            }\n-\n-            GST_DEBUG_OBJECT (qtdemux, \"found codec_data in stsd\");\n-            buf = gst_buffer_new_and_alloc (len);\n-            gst_buffer_fill (buf, 0, stsd_data, len);\n-            gst_caps_set_simple (entry->caps,\n-                \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n-            gst_buffer_unref (buf);\n-            break;\n-          }\n-          case FOURCC_jpeg:\n-          {\n-            \/* https:\/\/developer.apple.com\/standards\/qtff-2001.pdf,\n-             * page 92, \"Video Sample Description\", under table 3.1 *\/\n-            GstByteReader br;\n+            if (version >> 16 == 3) {\n+              GNode *gama, *smi;\n@@ -12797,7 +15617,3 @@\n-            const gint compressor_offset =\n-                16 + 4 + 4 * 3 + 2 * 2 + 2 * 4 + 4 + 2;\n-            const gint min_size = compressor_offset + 32 + 2 + 2;\n-            GNode *jpeg;\n-            guint32 len;\n-            guint16 color_table_id = 0;\n-            gboolean ok;\n+              gama = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_gama);\n+              if (gama) {\n+                guint32 size = QT_UINT32 (gama->data);\n@@ -12805,6 +15621,6 @@\n-            GST_DEBUG_OBJECT (qtdemux, \"found jpeg\");\n-\n-            \/* recover information on interlaced\/progressive *\/\n-            jpeg = qtdemux_tree_get_child_by_type (stsd, FOURCC_jpeg);\n-            if (!jpeg)\n-              break;\n+                if (size == 12) {\n+                  gdouble gamma = QT_FP32 ((const guint8 *) gama->data + 8);\n+                  gst_caps_set_simple (entry->caps, \"applied-gamma\",\n+                      G_TYPE_DOUBLE, gamma, NULL);\n+                }\n+              }\n@@ -12812,40 +15628,17 @@\n-            len = QT_UINT32 (jpeg->data);\n-            GST_DEBUG_OBJECT (qtdemux, \"Found jpeg: len %u, need %d\", len,\n-                min_size);\n-            if (len >= min_size) {\n-              gst_byte_reader_init (&br, jpeg->data, len);\n-\n-              gst_byte_reader_skip (&br, compressor_offset + 32 + 2);\n-              gst_byte_reader_get_uint16_le (&br, &color_table_id);\n-              if (color_table_id != 0) {\n-                \/* the spec says there can be concatenated chunks in the data, and we want\n-                 * to find one called field. Walk through them. *\/\n-                gint offset = min_size;\n-                while (offset + 8 < len) {\n-                  guint32 size = 0, tag;\n-                  ok = gst_byte_reader_get_uint32_le (&br, &size);\n-                  ok &= gst_byte_reader_get_uint32_le (&br, &tag);\n-                  if (!ok || size < 8) {\n-                    GST_WARNING_OBJECT (qtdemux,\n-                        \"Failed to walk optional chunk list\");\n-                    break;\n-                  }\n-                  GST_DEBUG_OBJECT (qtdemux,\n-                      \"Found optional %4.4s chunk, size %u\",\n-                      (const char *) &tag, size);\n-                  if (tag == FOURCC_fiel) {\n-                    guint8 n_fields = 0, ordering = 0;\n-                    gst_byte_reader_get_uint8 (&br, &n_fields);\n-                    gst_byte_reader_get_uint8 (&br, &ordering);\n-                    if (n_fields == 1 || n_fields == 2) {\n-                      GST_DEBUG_OBJECT (qtdemux,\n-                          \"Found fiel tag with %u fields, ordering %u\",\n-                          n_fields, ordering);\n-                      if (n_fields == 2)\n-                        gst_caps_set_simple (CUR_STREAM (stream)->caps,\n-                            \"interlace-mode\", G_TYPE_STRING, \"interleaved\",\n-                            NULL);\n-                    } else {\n-                      GST_WARNING_OBJECT (qtdemux,\n-                          \"Found fiel tag with invalid fields (%u)\", n_fields);\n-                    }\n+              smi = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_SMI_);\n+              if (smi) {\n+                const guint8 *data = smi->data;\n+                guint32 size = QT_UINT32 (data);\n+\n+                \/\/ This has first a fourcc and then the size\n+                if (size > 16 && QT_FOURCC (data + 8) == FOURCC_SEQH) {\n+                  guint32 seqh_size = QT_UINT32 (data + 8 + 4);\n+                  if (seqh_size > 0 && seqh_size <= size - 8 - 8) {\n+                    GstBuffer *seqh = gst_buffer_new_and_alloc (seqh_size);\n+                    gst_buffer_fill (seqh, 0, data + 8 + 8, seqh_size);\n+\n+                    \/* sorry for the bad name, but we don't know what this is, other\n+                     * than its own fourcc *\/\n+                    gst_caps_set_simple (entry->caps, \"seqh\", GST_TYPE_BUFFER,\n+                        seqh, NULL);\n+                    gst_buffer_unref (seqh);\n@@ -12853,1 +15646,0 @@\n-                  offset += size;\n@@ -12855,3 +15647,0 @@\n-              } else {\n-                GST_DEBUG_OBJECT (qtdemux,\n-                    \"Color table ID is 0, not trying to get interlacedness\");\n@@ -12859,3 +15648,0 @@\n-            } else {\n-              GST_WARNING_OBJECT (qtdemux,\n-                  \"Length of jpeg chunk is too small, not trying to get interlacedness\");\n@@ -12870,2 +15656,1 @@\n-                \"depth\", G_TYPE_INT, QT_UINT16 (stsd_entry_data + offset + 66),\n-                NULL);\n+                \"depth\", G_TYPE_INT, entry->bits_per_sample, NULL);\n@@ -12876,1 +15661,1 @@\n-            GNode *xith, *xdxt;\n+            GNode *xdxt;\n@@ -12879,3 +15664,0 @@\n-            xith = qtdemux_tree_get_child_by_index (stsd, stsd_index);\n-            if (!xith)\n-              break;\n@@ -12883,3 +15665,5 @@\n-            xdxt = qtdemux_tree_get_child_by_type (xith, FOURCC_XdxT);\n-            if (!xdxt)\n-              break;\n+            xdxt = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_XdxT);\n+            if (xdxt) {\n+              GNode *tcth, *tct, *tctc;\n+\n+              GST_DEBUG_OBJECT (qtdemux, \"found XdxT node\");\n@@ -12887,4 +15671,36 @@\n-            GST_DEBUG_OBJECT (qtdemux, \"found XdxT node\");\n-            \/* collect the headers and store them in a stream list so that we can\n-             * send them out first *\/\n-            qtdemux_parse_theora_extension (qtdemux, stream, xdxt);\n+              \/* collect the headers and store them in a stream list so that we can\n+               * send them out first *\/\n+\n+              tcth = qtdemux_tree_get_child_by_type (xdxt, FOURCC_tCtH);\n+              if (tcth) {\n+                guint32 size = QT_UINT32 (tcth->data);\n+                GstBuffer *buffer;\n+\n+                buffer = gst_buffer_new_and_alloc (size);\n+                gst_buffer_fill (buffer, 0, tcth->data, size);\n+                stream->buffers = g_slist_append (stream->buffers, buffer);\n+                GST_LOG_OBJECT (qtdemux, \"parsing theora header\");\n+              }\n+\n+              tct = qtdemux_tree_get_child_by_type (xdxt, FOURCC_tCt_);\n+              if (tct) {\n+                guint32 size = QT_UINT32 (tct->data);\n+                GstBuffer *buffer;\n+\n+                buffer = gst_buffer_new_and_alloc (size);\n+                gst_buffer_fill (buffer, 0, tct->data, size);\n+                stream->buffers = g_slist_append (stream->buffers, buffer);\n+                GST_LOG_OBJECT (qtdemux, \"parsing theora comment\");\n+              }\n+\n+              tctc = qtdemux_tree_get_child_by_type (xdxt, FOURCC_tCtC);\n+              if (tctc) {\n+                guint32 size = QT_UINT32 (tctc->data);\n+                GstBuffer *buffer;\n+\n+                buffer = gst_buffer_new_and_alloc (size);\n+                gst_buffer_fill (buffer, 0, tctc->data, size);\n+                stream->buffers = g_slist_append (stream->buffers, buffer);\n+                GST_LOG_OBJECT (qtdemux, \"parsing theora codebook\");\n+              }\n+            }\n@@ -12895,1 +15711,0 @@\n-            GNode *ovc1;\n@@ -12901,4 +15716,1 @@\n-            ovc1 = qtdemux_tree_get_child_by_index (stsd, stsd_index);\n-            if (!ovc1)\n-              break;\n-            ovc1_data = ovc1->data;\n+            ovc1_data = stsd_entry->data;\n@@ -12919,3 +15731,32 @@\n-            guint32 len = QT_UINT32 (stsd_entry_data);\n-            len = len <= 0x56 ? 0 : len - 0x56;\n-            const guint8 *vc1_data = stsd_entry_data + 0x56;\n+            GNode *dvc1;\n+\n+            dvc1 =\n+                qtdemux_tree_get_child_by_type (stsd_entry,\n+                GST_MAKE_FOURCC ('d', 'v', 'c', '1'));\n+            if (dvc1) {\n+              guint32 size = QT_UINT32 (dvc1->data);\n+\n+              if (size >= 8) {\n+                GstBuffer *buf;\n+\n+                GST_DEBUG_OBJECT (qtdemux, \"found dvc1 codec_data in stsd\");\n+                buf = gst_buffer_new_and_alloc (size - 8);\n+                gst_buffer_fill (buf, 0, (const guint8 *) dvc1->data + 8,\n+                    size - 8);\n+                gst_caps_set_simple (entry->caps, \"codec_data\", GST_TYPE_BUFFER,\n+                    buf, NULL);\n+                gst_buffer_unref (buf);\n+              }\n+            }\n+            break;\n+          }\n+          case FOURCC_av01:\n+          {\n+            GNode *av1C;\n+\n+            av1C = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_av1C);\n+            if (av1C) {\n+              const guint8 *data = av1C->data;\n+              guint32 size = QT_UINT32 (data);\n+\n+              GstBuffer *buf;\n@@ -12923,3 +15764,2 @@\n-            \/* find dvc1 *\/\n-            while (len >= 8) {\n-              guint32 size = QT_UINT32 (vc1_data);\n+              GST_DEBUG_OBJECT (qtdemux,\n+                  \"found av1C codec_data in stsd of size %d\", size);\n@@ -12927,1 +15767,2 @@\n-              if (size < 8 || size > len)\n+              \/* not enough data, just ignore and hope for the best *\/\n+              if (size < 8 + 4)\n@@ -12930,4 +15771,45 @@\n-              switch (QT_FOURCC (vc1_data + 4)) {\n-                case GST_MAKE_FOURCC ('d', 'v', 'c', '1'):\n-                {\n-                  GstBuffer *buf;\n+              \/* Content is:\n+               * 4 bytes: atom length\n+               * 4 bytes: fourcc\n+               *\n+               * version 1 (marker=1):\n+               *\n+               *  unsigned int (1) marker = 1;\n+               *  unsigned int (7) version = 1;\n+               *  unsigned int (3) seq_profile;\n+               *  unsigned int (5) seq_level_idx_0;\n+               *  unsigned int (1) seq_tier_0;\n+               *  unsigned int (1) high_bitdepth;\n+               *  unsigned int (1) twelve_bit;\n+               *  unsigned int (1) monochrome;\n+               *  unsigned int (1) chroma_subsampling_x;\n+               *  unsigned int (1) chroma_subsampling_y;\n+               *  unsigned int (2) chroma_sample_position;\n+               *  unsigned int (3) reserved = 0;\n+               *\n+               *  unsigned int (1) initial_presentation_delay_present;\n+               *  if (initial_presentation_delay_present) {\n+               *    unsigned int (4) initial_presentation_delay_minus_one;\n+               *  } else {\n+               *    unsigned int (4) reserved = 0;\n+               *  }\n+               *\n+               *  unsigned int (8) configOBUs[];\n+               *\n+               * rest: OBUs.\n+               *\/\n+\n+              switch (data[8]) {\n+                case 0x81:{\n+                  guint8 pres_delay_field;\n+\n+                  \/* We let profile and the other parts be figured out by\n+                   * av1parse and only include the presentation delay here\n+                   * if present *\/\n+                  \/* We skip initial_presentation_delay* for now *\/\n+                  pres_delay_field = *(data + 11);\n+                  if (pres_delay_field & (1 << 5)) {\n+                    gst_caps_set_simple (entry->caps,\n+                        \"presentation-delay\", G_TYPE_INT,\n+                        (gint) (pres_delay_field & 0x0F) + 1, NULL);\n+                  }\n@@ -12935,1 +15817,0 @@\n-                  GST_DEBUG_OBJECT (qtdemux, \"found dvc1 codec_data in stsd\");\n@@ -12937,1 +15818,2 @@\n-                  gst_buffer_fill (buf, 0, vc1_data + 8, size - 8);\n+                  GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_HEADER);\n+                  gst_buffer_fill (buf, 0, data + 8, size - 8);\n@@ -12944,0 +15826,1 @@\n+                  GST_WARNING (\"Unknown version 0x%02x of av1C box\", data[8]);\n@@ -12946,2 +15829,0 @@\n-              len -= size;\n-              vc1_data += size;\n@@ -12949,0 +15830,1 @@\n+\n@@ -12951,5 +15833,0 @@\n-          case FOURCC_av01:\n-          {\n-            guint32 len = QT_UINT32 (stsd_entry_data);\n-            len = len <= 0x56 ? 0 : len - 0x56;\n-            const guint8 *av1_data = stsd_entry_data + 0x56;\n@@ -12957,3 +15834,24 @@\n-            \/* find av1C *\/\n-            while (len >= 8) {\n-              guint32 size = QT_UINT32 (av1_data);\n+          case FOURCC_vp08:\n+          case FOURCC_vp09:\n+          {\n+            GNode *vpcC;\n+\n+            vpcC = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_vpcC);\n+            if (vpcC) {\n+              const guint8 *data = vpcC->data;\n+              guint32 size = QT_UINT32 (data);\n+              const gchar *profile_str = NULL;\n+              const gchar *chroma_format_str = NULL;\n+              guint8 profile;\n+              guint8 bitdepth;\n+              guint8 chroma_format;\n+              GstVideoColorimetry cinfo;\n+\n+              \/* parse, if found *\/\n+              GST_DEBUG_OBJECT (qtdemux,\n+                  \"found vp codec_data in stsd of size %d\", size);\n+\n+              \/* the meaning of \"size\" is length of the atom body, excluding\n+               * atom length and fourcc fields *\/\n+              if (size < 8 + 12)\n+                break;\n@@ -12961,1 +15859,20 @@\n-              if (size < 8 || size > len)\n+              \/* Content is:\n+               * 4 bytes: atom length\n+               * 4 bytes: fourcc\n+               * 1 byte: version\n+               * 3 bytes: flags\n+               * 1 byte: profile\n+               * 1 byte: level\n+               * 4 bits: bitDepth\n+               * 3 bits: chromaSubsampling\n+               * 1 bit: videoFullRangeFlag\n+               * 1 byte: colourPrimaries\n+               * 1 byte: transferCharacteristics\n+               * 1 byte: matrixCoefficients\n+               * 2 bytes: codecIntializationDataSize (should be zero for vp8 and vp9)\n+               * rest: codecIntializationData (not used for vp8 and vp9)\n+               *\/\n+\n+              if (data[8] != 1) {\n+                GST_WARNING_OBJECT (qtdemux,\n+                    \"unknown vpcC version %d\", data[8]);\n@@ -12963,0 +15880,19 @@\n+              }\n+\n+              profile = data[12];\n+              switch (profile) {\n+                case 0:\n+                  profile_str = \"0\";\n+                  break;\n+                case 1:\n+                  profile_str = \"1\";\n+                  break;\n+                case 2:\n+                  profile_str = \"2\";\n+                  break;\n+                case 3:\n+                  profile_str = \"3\";\n+                  break;\n+                default:\n+                  break;\n+              }\n@@ -12964,5 +15900,4 @@\n-              switch (QT_FOURCC (av1_data + 4)) {\n-                case FOURCC_av1C:\n-                {\n-                  \/* parse, if found *\/\n-                  GstBuffer *buf;\n+              if (profile_str) {\n+                gst_caps_set_simple (entry->caps,\n+                    \"profile\", G_TYPE_STRING, profile_str, NULL);\n+              }\n@@ -12970,52 +15905,3 @@\n-                  GST_DEBUG_OBJECT (qtdemux,\n-                      \"found av1C codec_data in stsd of size %d\", size);\n-\n-                  \/* not enough data, just ignore and hope for the best *\/\n-                  if (size < 8 + 4)\n-                    break;\n-\n-                  \/* Content is:\n-                   * 4 bytes: atom length\n-                   * 4 bytes: fourcc\n-                   *\n-                   * version 1 (marker=1):\n-                   *\n-                   *  unsigned int (1) marker = 1;\n-                   *  unsigned int (7) version = 1;\n-                   *  unsigned int (3) seq_profile;\n-                   *  unsigned int (5) seq_level_idx_0;\n-                   *  unsigned int (1) seq_tier_0;\n-                   *  unsigned int (1) high_bitdepth;\n-                   *  unsigned int (1) twelve_bit;\n-                   *  unsigned int (1) monochrome;\n-                   *  unsigned int (1) chroma_subsampling_x;\n-                   *  unsigned int (1) chroma_subsampling_y;\n-                   *  unsigned int (2) chroma_sample_position;\n-                   *  unsigned int (3) reserved = 0;\n-                   *\n-                   *  unsigned int (1) initial_presentation_delay_present;\n-                   *  if (initial_presentation_delay_present) {\n-                   *    unsigned int (4) initial_presentation_delay_minus_one;\n-                   *  } else {\n-                   *    unsigned int (4) reserved = 0;\n-                   *  }\n-                   *\n-                   *  unsigned int (8) configOBUs[];\n-                   *\n-                   * rest: OBUs.\n-                   *\/\n-\n-                  switch (av1_data[8]) {\n-                    case 0x81:{\n-                      guint8 pres_delay_field;\n-\n-                      \/* We let profile and the other parts be figured out by\n-                       * av1parse and only include the presentation delay here\n-                       * if present *\/\n-                      \/* We skip initial_presentation_delay* for now *\/\n-                      pres_delay_field = *(av1_data + 11);\n-                      if (pres_delay_field & (1 << 5)) {\n-                        gst_caps_set_simple (entry->caps,\n-                            \"presentation-delay\", G_TYPE_INT,\n-                            (gint) (pres_delay_field & 0x0F) + 1, NULL);\n-                      }\n+              \/* skip level, the VP9 spec v0.6 defines only one level atm,\n+               * but webm spec define various ones. Add level to caps\n+               * if we really need it then *\/\n@@ -13023,13 +15909,6 @@\n-                      buf = gst_buffer_new_and_alloc (size - 8);\n-                      GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_HEADER);\n-                      gst_buffer_fill (buf, 0, av1_data + 8, size - 8);\n-                      gst_caps_set_simple (entry->caps,\n-                          \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n-                      gst_buffer_unref (buf);\n-                      break;\n-                    }\n-                    default:\n-                      GST_WARNING (\"Unknown version 0x%02x of av1C box\",\n-                          av1_data[8]);\n-                      break;\n-                  }\n+              bitdepth = (data[14] & 0xf0) >> 4;\n+              if (bitdepth == 8 || bitdepth == 10 || bitdepth == 12) {\n+                gst_caps_set_simple (entry->caps,\n+                    \"bit-depth-luma\", G_TYPE_UINT, bitdepth,\n+                    \"bit-depth-chroma\", G_TYPE_UINT, bitdepth, NULL);\n+              }\n@@ -13037,0 +15916,11 @@\n+              chroma_format = (data[14] & 0xe) >> 1;\n+              switch (chroma_format) {\n+                case 0:\n+                case 1:\n+                  chroma_format_str = \"4:2:0\";\n+                  break;\n+                case 2:\n+                  chroma_format_str = \"4:2:2\";\n+                  break;\n+                case 3:\n+                  chroma_format_str = \"4:4:4\";\n@@ -13038,1 +15928,0 @@\n-                }\n@@ -13043,3 +15932,4 @@\n-              len -= size;\n-              av1_data += size;\n-            }\n+              if (chroma_format_str) {\n+                gst_caps_set_simple (entry->caps,\n+                    \"chroma-format\", G_TYPE_STRING, chroma_format_str, NULL);\n+              }\n@@ -13047,0 +15937,16 @@\n+              if ((data[14] & 0x1) != 0)\n+                cinfo.range = GST_VIDEO_COLOR_RANGE_0_255;\n+              else\n+                cinfo.range = GST_VIDEO_COLOR_RANGE_16_235;\n+              cinfo.primaries = gst_video_color_primaries_from_iso (data[15]);\n+              cinfo.transfer = gst_video_transfer_function_from_iso (data[16]);\n+              cinfo.matrix = gst_video_color_matrix_from_iso (data[17]);\n+\n+              if (cinfo.primaries != GST_VIDEO_COLOR_PRIMARIES_UNKNOWN &&\n+                  cinfo.transfer != GST_VIDEO_TRANSFER_UNKNOWN &&\n+                  cinfo.matrix != GST_VIDEO_COLOR_MATRIX_UNKNOWN) {\n+                \/* set this only if all values are known, otherwise this\n+                 * might overwrite valid ones parsed from other color box *\/\n+                CUR_STREAM (stream)->colorimetry = cinfo;\n+              }\n+            }\n@@ -13049,0 +15955,2 @@\n+          case GST_MAKE_FOURCC ('A', 'V', 'd', 'h'):{\n+            GNode *adhr;\n@@ -13050,12 +15958,6 @@\n-            \/* TODO: Need to parse vpcC for VP8 codec too.\n-             * Note that VPCodecConfigurationBox (vpcC) is defined for\n-             * vp08, vp09, and vp10 fourcc. *\/\n-          case FOURCC_vp09:\n-          {\n-            guint32 len = QT_UINT32 (stsd_entry_data);\n-            len = len <= 0x56 ? 0 : len - 0x56;\n-            const guint8 *vpcc_data = stsd_entry_data + 0x56;\n-\n-            \/* find vpcC *\/\n-            while (len >= 8) {\n-              guint32 size = QT_UINT32 (vpcc_data);\n+            adhr =\n+                qtdemux_tree_get_child_by_type (stsd_entry,\n+                GST_MAKE_FOURCC ('A', 'D', 'H', 'R'));\n+            if (adhr) {\n+              const guint8 *data = adhr->data;\n+              guint32 size = QT_UINT32 (data);\n@@ -13063,2 +15965,2 @@\n-              if (size < 8 || size > len)\n-                break;\n+              if (size >= 8 + 4 + 4) {\n+                guint32 version = QT_FOURCC (data + 8);\n@@ -13066,41 +15968,4 @@\n-              switch (QT_FOURCC (vpcc_data + 4)) {\n-                case FOURCC_vpcC:\n-                {\n-                  const gchar *profile_str = NULL;\n-                  const gchar *chroma_format_str = NULL;\n-                  guint8 profile;\n-                  guint8 bitdepth;\n-                  guint8 chroma_format;\n-                  GstVideoColorimetry cinfo;\n-\n-                  \/* parse, if found *\/\n-                  GST_DEBUG_OBJECT (qtdemux,\n-                      \"found vp codec_data in stsd of size %d\", size);\n-\n-                  \/* the meaning of \"size\" is length of the atom body, excluding\n-                   * atom length and fourcc fields *\/\n-                  if (size < 8 + 12)\n-                    break;\n-\n-                  \/* Content is:\n-                   * 4 bytes: atom length\n-                   * 4 bytes: fourcc\n-                   * 1 byte: version\n-                   * 3 bytes: flags\n-                   * 1 byte: profile\n-                   * 1 byte: level\n-                   * 4 bits: bitDepth\n-                   * 3 bits: chromaSubsampling\n-                   * 1 bit: videoFullRangeFlag\n-                   * 1 byte: colourPrimaries\n-                   * 1 byte: transferCharacteristics\n-                   * 1 byte: matrixCoefficients\n-                   * 2 bytes: codecIntializationDataSize (should be zero for vp8 and vp9)\n-                   * rest: codecIntializationData (not used for vp8 and vp9)\n-                   *\/\n-\n-                  if (vpcc_data[8] != 1) {\n-                    GST_WARNING_OBJECT (qtdemux,\n-                        \"unknown vpcC version %d\", vpcc_data[8]);\n-                    break;\n-                  }\n+                if (version == GST_MAKE_FOURCC ('0', '0', '0', '1') ||\n+                    version == GST_MAKE_FOURCC ('0', '0', '0', '2')) {\n+                  guint32 profile = QT_UINT32 (data + 12);\n+                  const gchar *profile_s = \"dnxhr\";\n@@ -13108,1 +15973,0 @@\n-                  profile = vpcc_data[12];\n@@ -13110,11 +15974,2 @@\n-                    case 0:\n-                      profile_str = \"0\";\n-                      break;\n-                    case 1:\n-                      profile_str = \"1\";\n-                      break;\n-                    case 2:\n-                      profile_str = \"2\";\n-                      break;\n-                    case 3:\n-                      profile_str = \"3\";\n+                    case 0x4f6:\n+                      profile_s = \"dnxhr-444\";\n@@ -13122,1 +15977,2 @@\n-                    default:\n+                    case 0x4f7:\n+                      profile_s = \"dnxhr-hqx\";\n@@ -13124,23 +15980,2 @@\n-                  }\n-\n-                  if (profile_str) {\n-                    gst_caps_set_simple (entry->caps,\n-                        \"profile\", G_TYPE_STRING, profile_str, NULL);\n-                  }\n-\n-                  \/* skip level, the VP9 spec v0.6 defines only one level atm,\n-                   * but webm spec define various ones. Add level to caps\n-                   * if we really need it then *\/\n-\n-                  bitdepth = (vpcc_data[14] & 0xf0) >> 4;\n-                  if (bitdepth == 8 || bitdepth == 10 || bitdepth == 12) {\n-                    gst_caps_set_simple (entry->caps,\n-                        \"bit-depth-luma\", G_TYPE_UINT, bitdepth,\n-                        \"bit-depth-chroma\", G_TYPE_UINT, bitdepth, NULL);\n-                  }\n-\n-                  chroma_format = (vpcc_data[14] & 0xe) >> 1;\n-                  switch (chroma_format) {\n-                    case 0:\n-                    case 1:\n-                      chroma_format_str = \"4:2:0\";\n+                    case 0x4f8:\n+                      profile_s = \"dnxhr-hq\";\n@@ -13148,2 +15983,2 @@\n-                    case 2:\n-                      chroma_format_str = \"4:2:2\";\n+                    case 0x4f9:\n+                      profile_s = \"dnxhr-sq\";\n@@ -13151,2 +15986,2 @@\n-                    case 3:\n-                      chroma_format_str = \"4:4:4\";\n+                    case 0x4fa:\n+                      profile_s = \"dnxhr-lb\";\n@@ -13155,0 +15990,2 @@\n+                      GST_WARNING_OBJECT (qtdemux, \"Unknown DNxHR profile %08x\",\n+                          profile);\n@@ -13158,25 +15995,2 @@\n-                  if (chroma_format_str) {\n-                    gst_caps_set_simple (entry->caps,\n-                        \"chroma-format\", G_TYPE_STRING, chroma_format_str,\n-                        NULL);\n-                  }\n-\n-                  if ((vpcc_data[14] & 0x1) != 0)\n-                    cinfo.range = GST_VIDEO_COLOR_RANGE_0_255;\n-                  else\n-                    cinfo.range = GST_VIDEO_COLOR_RANGE_16_235;\n-                  cinfo.primaries =\n-                      gst_video_color_primaries_from_iso (vpcc_data[15]);\n-                  cinfo.transfer =\n-                      gst_video_transfer_function_from_iso (vpcc_data[16]);\n-                  cinfo.matrix =\n-                      gst_video_color_matrix_from_iso (vpcc_data[17]);\n-\n-                  if (cinfo.primaries != GST_VIDEO_COLOR_PRIMARIES_UNKNOWN &&\n-                      cinfo.transfer != GST_VIDEO_TRANSFER_UNKNOWN &&\n-                      cinfo.matrix != GST_VIDEO_COLOR_MATRIX_UNKNOWN) {\n-                    \/* set this only if all values are known, otherwise this\n-                     * might overwrite valid ones parsed from other color box *\/\n-                    CUR_STREAM (stream)->colorimetry = cinfo;\n-                  }\n-                  break;\n+                  gst_caps_set_simple (entry->caps, \"profile\", G_TYPE_STRING,\n+                      profile_s, NULL);\n@@ -13184,2 +15998,0 @@\n-                default:\n-                  break;\n@@ -13187,3 +15999,0 @@\n-\n-              len -= size;\n-              vpcc_data += size;\n@@ -13191,1 +16000,0 @@\n-\n@@ -13204,1 +16012,1 @@\n-      GNode *wave;\n+      GNode *wave, *btrt;\n@@ -13242,1 +16050,8 @@\n-      if (version == 0x00010000) {\n+      \/* This is only valid in MOV files. To distinguish this from the\n+       * AudioSampleEntryV1 from ISOBMFF (which does not have the additional\n+       * fields but instead the exact same layout as AudioSampleEntry), the\n+       * latter requires a stsd of version 1 to be used.\n+       * The same goes for version 2 below, for which no equivalent in ISOBMFF\n+       * exists yet, fortunately\n+       *\/\n+      if (version == 0x00010000 && stsd_version == 0) {\n@@ -13269,1 +16084,1 @@\n-      } else if (version == 0x00020000) {\n+      } else if (version == 0x00020000 && stsd_version == 0) {\n@@ -13352,0 +16167,2 @@\n+        case FOURCC_ipcm:\n+        case FOURCC_fpcm:\n@@ -13422,1 +16239,1 @@\n-          stsd_entry_data + 32, len - 16, &codec);\n+          stsd_version, version, stsd_entry, &codec);\n@@ -13431,1 +16248,0 @@\n-          GNode *fmt;\n@@ -13433,3 +16249,1 @@\n-          fmt = qtdemux_tree_get_child_by_type (stsd, fourcc);\n-\n-          enda = qtdemux_tree_get_child_by_type (fmt, FOURCC_enda);\n+          enda = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_enda);\n@@ -13437,1 +16251,1 @@\n-            wave = qtdemux_tree_get_child_by_type (fmt, FOURCC_wave);\n+            wave = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_wave);\n@@ -13442,1 +16256,0 @@\n-            int enda_value = QT_UINT16 ((guint8 *) enda->data + 8);\n@@ -13444,0 +16257,1 @@\n+            guint32 enda_len = QT_UINT32 (enda->data);\n@@ -13445,16 +16259,22 @@\n-            switch (fourcc) {\n-              case FOURCC_in24:\n-                format_str = (enda_value) ? \"S24LE\" : \"S24BE\";\n-                break;\n-              case FOURCC_in32:\n-                format_str = (enda_value) ? \"S32LE\" : \"S32BE\";\n-                break;\n-              case FOURCC_fl32:\n-                format_str = (enda_value) ? \"F32LE\" : \"F32BE\";\n-                break;\n-              case FOURCC_fl64:\n-                format_str = (enda_value) ? \"F64LE\" : \"F64BE\";\n-                break;\n-              default:\n-                g_assert_not_reached ();\n-                break;\n+            if (enda_len >= 9) {\n+              guint16 enda_value = QT_UINT16 ((guint8 *) enda->data + 8);\n+\n+              switch (fourcc) {\n+                case FOURCC_in24:\n+                  format_str = (enda_value) ? \"S24LE\" : \"S24BE\";\n+                  break;\n+                case FOURCC_in32:\n+                  format_str = (enda_value) ? \"S32LE\" : \"S32BE\";\n+                  break;\n+                case FOURCC_fl32:\n+                  format_str = (enda_value) ? \"F32LE\" : \"F32BE\";\n+                  break;\n+                case FOURCC_fl64:\n+                  format_str = (enda_value) ? \"F64LE\" : \"F64BE\";\n+                  break;\n+                default:\n+                  g_assert_not_reached ();\n+                  break;\n+              }\n+              gst_caps_set_simple (entry->caps,\n+                  \"format\", G_TYPE_STRING, format_str, NULL);\n@@ -13462,2 +16282,0 @@\n-            gst_caps_set_simple (entry->caps,\n-                \"format\", G_TYPE_STRING, format_str, NULL);\n@@ -13487,1 +16305,1 @@\n-          WAVEFORMATEX *wfex;\n+          WAVEFORMATEX wfex;\n@@ -13496,1 +16314,7 @@\n-          wfex = (WAVEFORMATEX *) (owma_data + 36);\n+          wfex.wFormatTag = GST_READ_UINT16_LE (owma_data + 36 + 0);\n+          wfex.nChannels = GST_READ_UINT16_LE (owma_data + 36 + 2);\n+          wfex.nSamplesPerSec = GST_READ_UINT32_LE (owma_data + 36 + 4);\n+          wfex.nAvgBytesPerSec = GST_READ_UINT32_LE (owma_data + 36 + 8);\n+          wfex.nBlockAlign = GST_READ_UINT16_LE (owma_data + 36 + 12);\n+          wfex.wBitsPerSample = GST_READ_UINT16_LE (owma_data + 36 + 14);\n+          wfex.cbSize = GST_READ_UINT16_LE (owma_data + 36 + 16);\n@@ -13499,1 +16323,1 @@\n-          if (wfex->wFormatTag == 0x0161) {\n+          if (wfex.wFormatTag == 0x0161) {\n@@ -13502,1 +16326,1 @@\n-          } else if (wfex->wFormatTag == 0x0162) {\n+          } else if (wfex.wFormatTag == 0x0162) {\n@@ -13505,1 +16329,1 @@\n-          } else if (wfex->wFormatTag == 0x0163) {\n+          } else if (wfex.wFormatTag == 0x0163) {\n@@ -13516,4 +16340,4 @@\n-              GST_READ_UINT16_LE (&wfex->nBlockAlign), \"bitrate\", G_TYPE_INT,\n-              GST_READ_UINT32_LE (&wfex->nAvgBytesPerSec), \"width\", G_TYPE_INT,\n-              GST_READ_UINT16_LE (&wfex->wBitsPerSample), \"depth\", G_TYPE_INT,\n-              GST_READ_UINT16_LE (&wfex->wBitsPerSample), NULL);\n+              wfex.nBlockAlign, \"bitrate\", G_TYPE_INT,\n+              wfex.nAvgBytesPerSec, \"width\", G_TYPE_INT,\n+              wfex.wBitsPerSample, \"depth\", G_TYPE_INT,\n+              wfex.wBitsPerSample, NULL);\n@@ -13530,3 +16354,0 @@\n-          guint32 len = QT_UINT32 (stsd_entry_data);\n-          len = len <= offset ? 0 : len - offset;\n-          const guint8 *wfex_data = stsd_entry_data + offset;\n@@ -13549,0 +16370,1 @@\n+          GNode *wfex_node;\n@@ -13553,3 +16375,7 @@\n-          \/* find wfex *\/\n-          while (len >= 8) {\n-            guint32 size = QT_UINT32 (wfex_data);\n+          wfex_node =\n+              qtdemux_tree_get_child_by_type (stsd_entry, GST_MAKE_FOURCC ('w',\n+                  'f', 'e', 'x'));\n+\n+          if (wfex_node) {\n+            const guint8 *wfex_data = wfex_node->data;\n+            guint32 wfex_size = QT_UINT32 (wfex_data);\n@@ -13557,1 +16383,3 @@\n-            if (size < 8 || size > len)\n+            GST_DEBUG_OBJECT (qtdemux, \"found wfex in stsd\");\n+\n+            if (wfex_size < 8 + 18)\n@@ -13560,4 +16388,27 @@\n-            switch (QT_FOURCC (wfex_data + 4)) {\n-              case GST_MAKE_FOURCC ('w', 'f', 'e', 'x'):\n-              {\n-                GST_DEBUG_OBJECT (qtdemux, \"found wfex in stsd\");\n+            wfex.wFormatTag = GST_READ_UINT16_LE (wfex_data + 8 + 0);\n+            wfex.nChannels = GST_READ_UINT16_LE (wfex_data + 8 + 2);\n+            wfex.nSamplesPerSec = GST_READ_UINT32_LE (wfex_data + 8 + 4);\n+            wfex.nAvgBytesPerSec = GST_READ_UINT32_LE (wfex_data + 8 + 8);\n+            wfex.nBlockAlign = GST_READ_UINT16_LE (wfex_data + 8 + 12);\n+            wfex.wBitsPerSample = GST_READ_UINT16_LE (wfex_data + 8 + 14);\n+            wfex.cbSize = GST_READ_UINT16_LE (wfex_data + 8 + 16);\n+\n+            GST_LOG_OBJECT (qtdemux, \"Found wfex box in stsd:\");\n+            GST_LOG_OBJECT (qtdemux, \"FormatTag = 0x%04x, Channels = %u, \"\n+                \"SamplesPerSec = %u, AvgBytesPerSec = %u, BlockAlign = %u, \"\n+                \"BitsPerSample = %u, Size = %u\", wfex.wFormatTag,\n+                wfex.nChannels, wfex.nSamplesPerSec, wfex.nAvgBytesPerSec,\n+                wfex.nBlockAlign, wfex.wBitsPerSample, wfex.cbSize);\n+\n+            if (wfex.wFormatTag == 0x0161) {\n+              codec_name = \"Windows Media Audio\";\n+              version = 2;\n+            } else if (wfex.wFormatTag == 0x0162) {\n+              codec_name = \"Windows Media Audio 9 Pro\";\n+              version = 3;\n+            } else if (wfex.wFormatTag == 0x0163) {\n+              codec_name = \"Windows Media Audio 9 Lossless\";\n+              \/* is that correct? gstffmpegcodecmap.c is missing it, but\n+               * fluendo codec seems to support it *\/\n+              version = 4;\n+            }\n@@ -13565,2 +16416,6 @@\n-                if (size < 8 + 18)\n-                  break;\n+            gst_caps_set_simple (entry->caps,\n+                \"wmaversion\", G_TYPE_INT, version,\n+                \"block_align\", G_TYPE_INT, wfex.nBlockAlign,\n+                \"bitrate\", G_TYPE_INT, wfex.nAvgBytesPerSec,\n+                \"width\", G_TYPE_INT, wfex.wBitsPerSample,\n+                \"depth\", G_TYPE_INT, wfex.wBitsPerSample, NULL);\n@@ -13568,27 +16423,2 @@\n-                wfex.wFormatTag = GST_READ_UINT16_LE (wfex_data + 8 + 0);\n-                wfex.nChannels = GST_READ_UINT16_LE (wfex_data + 8 + 2);\n-                wfex.nSamplesPerSec = GST_READ_UINT32_LE (wfex_data + 8 + 4);\n-                wfex.nAvgBytesPerSec = GST_READ_UINT32_LE (wfex_data + 8 + 8);\n-                wfex.nBlockAlign = GST_READ_UINT16_LE (wfex_data + 8 + 12);\n-                wfex.wBitsPerSample = GST_READ_UINT16_LE (wfex_data + 8 + 14);\n-                wfex.cbSize = GST_READ_UINT16_LE (wfex_data + 8 + 16);\n-\n-                GST_LOG_OBJECT (qtdemux, \"Found wfex box in stsd:\");\n-                GST_LOG_OBJECT (qtdemux, \"FormatTag = 0x%04x, Channels = %u, \"\n-                    \"SamplesPerSec = %u, AvgBytesPerSec = %u, BlockAlign = %u, \"\n-                    \"BitsPerSample = %u, Size = %u\", wfex.wFormatTag,\n-                    wfex.nChannels, wfex.nSamplesPerSec, wfex.nAvgBytesPerSec,\n-                    wfex.nBlockAlign, wfex.wBitsPerSample, wfex.cbSize);\n-\n-                if (wfex.wFormatTag == 0x0161) {\n-                  codec_name = \"Windows Media Audio\";\n-                  version = 2;\n-                } else if (wfex.wFormatTag == 0x0162) {\n-                  codec_name = \"Windows Media Audio 9 Pro\";\n-                  version = 3;\n-                } else if (wfex.wFormatTag == 0x0163) {\n-                  codec_name = \"Windows Media Audio 9 Lossless\";\n-                  \/* is that correct? gstffmpegcodecmap.c is missing it, but\n-                   * fluendo codec seems to support it *\/\n-                  version = 4;\n-                }\n+            if (wfex_size > 8 + wfex.cbSize) {\n+              GstBuffer *buf;\n@@ -13596,19 +16426,9 @@\n-                gst_caps_set_simple (entry->caps,\n-                    \"wmaversion\", G_TYPE_INT, version,\n-                    \"block_align\", G_TYPE_INT, wfex.nBlockAlign,\n-                    \"bitrate\", G_TYPE_INT, wfex.nAvgBytesPerSec,\n-                    \"width\", G_TYPE_INT, wfex.wBitsPerSample,\n-                    \"depth\", G_TYPE_INT, wfex.wBitsPerSample, NULL);\n-\n-                if (size > 8 + wfex.cbSize) {\n-                  GstBuffer *buf;\n-\n-                  buf = gst_buffer_new_and_alloc (size - 8 - wfex.cbSize);\n-                  gst_buffer_fill (buf, 0, wfex_data + 8 + wfex.cbSize,\n-                      size - 8 - wfex.cbSize);\n-                  gst_caps_set_simple (entry->caps,\n-                      \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n-                  gst_buffer_unref (buf);\n-                } else {\n-                  GST_WARNING_OBJECT (qtdemux, \"no codec data\");\n-                }\n+              buf = gst_buffer_new_and_alloc (wfex_size - 8 - wfex.cbSize);\n+              gst_buffer_fill (buf, 0, wfex_data + 8 + wfex.cbSize,\n+                  wfex_size - 8 - wfex.cbSize);\n+              gst_caps_set_simple (entry->caps,\n+                  \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n+              gst_buffer_unref (buf);\n+            } else {\n+              GST_WARNING_OBJECT (qtdemux, \"no codec data\");\n+            }\n@@ -13616,8 +16436,3 @@\n-                if (codec_name) {\n-                  g_free (codec);\n-                  codec = g_strdup (codec_name);\n-                }\n-                break;\n-              }\n-              default:\n-                break;\n+            if (codec_name) {\n+              g_free (codec);\n+              codec = g_strdup (codec_name);\n@@ -13625,2 +16440,1 @@\n-            len -= size;\n-            wfex_data += size;\n+            break;\n@@ -13641,1 +16455,0 @@\n-          GNode *opus;\n@@ -13644,7 +16457,1 @@\n-          opus = qtdemux_tree_get_child_by_type (stsd, FOURCC_opus);\n-          if (opus == NULL) {\n-            GST_WARNING_OBJECT (qtdemux, \"Opus Sample Entry not found\");\n-            goto corrupt_file;\n-          }\n-\n-          dops = qtdemux_tree_get_child_by_type (opus, FOURCC_dops);\n+          dops = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_dops);\n@@ -13721,0 +16528,1 @@\n+          gst_caps_unref (entry->caps);\n@@ -13728,0 +16536,80 @@\n+          break;\n+        }\n+        case FOURCC_ipcm:\n+        case FOURCC_fpcm:\n+        {\n+          GNode *pcmC;\n+\n+          pcmC = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_pcmC);\n+          if (pcmC) {\n+            const guint8 *data = pcmC->data;\n+            gsize len = QT_UINT32 (data);\n+            if (len >= 8 + 6) {\n+              GstByteReader br = GST_BYTE_READER_INIT (data, len);\n+\n+              gst_byte_reader_skip_unchecked (&br, 4 + 4);\n+\n+              guint32 version_flags =\n+                  gst_byte_reader_get_uint32_be_unchecked (&br);\n+              \/\/ Version 0, no flags\n+              if (version_flags == 0) {\n+                guint8 format_flags = gst_byte_reader_get_uint8_unchecked (&br);\n+                guint8 pcm_sample_size =\n+                    gst_byte_reader_get_uint8_unchecked (&br);\n+                GstAudioFormat audio_format = GST_AUDIO_FORMAT_UNKNOWN;\n+\n+                if (fourcc == FOURCC_ipcm) {\n+                  audio_format =\n+                      gst_audio_format_build_integer (TRUE,\n+                      (format_flags & 0x01) ? G_LITTLE_ENDIAN : G_BIG_ENDIAN,\n+                      pcm_sample_size, pcm_sample_size);\n+                } else {\n+                  switch (pcm_sample_size) {\n+                    case 32:\n+                      audio_format =\n+                          (format_flags & 0x01) ? GST_AUDIO_FORMAT_F32LE :\n+                          GST_AUDIO_FORMAT_F32BE;\n+                      break;\n+                    case 64:\n+                      audio_format =\n+                          (format_flags & 0x01) ? GST_AUDIO_FORMAT_F64LE :\n+                          GST_AUDIO_FORMAT_F64BE;\n+                      break;\n+                    default:\n+                      GST_WARNING_OBJECT (qtdemux,\n+                          \"Unsupported floating point PCM sample size %u\",\n+                          pcm_sample_size);\n+                      break;\n+                  }\n+                }\n+                gst_caps_set_simple (entry->caps,\n+                    \"format\", G_TYPE_STRING,\n+                    audio_format !=\n+                    GST_AUDIO_FORMAT_UNKNOWN ?\n+                    gst_audio_format_to_string (audio_format) : \"UNKNOWN\",\n+                    NULL);\n+\n+                entry->bytes_per_sample = pcm_sample_size \/ 8;\n+                entry->samples_per_frame = entry->n_channels;\n+                entry->bytes_per_frame =\n+                    entry->n_channels * entry->bytes_per_sample;\n+                entry->samples_per_packet = entry->samples_per_frame;\n+                entry->bytes_per_packet = entry->bytes_per_sample;\n+\n+                stream->min_buffer_size = 1024 * entry->bytes_per_frame;\n+                stream->max_buffer_size = entry->rate * entry->bytes_per_frame;\n+                GST_DEBUG (\"setting min\/max buffer sizes to %d\/%d\",\n+                    stream->min_buffer_size, stream->max_buffer_size);\n+\n+                stream->alignment = pcm_sample_size \/ 8;\n+              } else {\n+                GST_WARNING_OBJECT (qtdemux,\n+                    \"Unsupported pcmC version\/flags %08x\", version_flags);\n+              }\n+            }\n+          } else {\n+            GST_WARNING_OBJECT (qtdemux,\n+                \"%\" GST_FOURCC_FORMAT \" without pcmC box\",\n+                GST_FOURCC_ARGS (fourcc));\n+          }\n+\n@@ -13753,5 +16641,28 @@\n-      mp4a = qtdemux_tree_get_child_by_index (stsd, stsd_index);\n-      if (QTDEMUX_TREE_NODE_FOURCC (mp4a) != fourcc) {\n-        if (stream->protected) {\n-          if (QTDEMUX_TREE_NODE_FOURCC (mp4a) == FOURCC_aavd) {\n-            esds = qtdemux_tree_get_child_by_type (mp4a, FOURCC_esds);\n+      wave = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_wave);\n+      if (wave)\n+        esds = qtdemux_tree_get_child_by_type (wave, FOURCC_esds);\n+      if (!esds)\n+        esds = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_esds);\n+\n+      btrt = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_btrt);\n+\n+      if (btrt) {\n+        const guint8 *data;\n+        guint32 size;\n+\n+        data = btrt->data;\n+        size = QT_UINT32 (data);\n+\n+        \/* bufferSizeDB, maxBitrate and avgBitrate - 4 bytes each *\/\n+        if (size >= 8 + 12) {\n+\n+          guint32 max_bitrate = QT_UINT32 (data + 8 + 4);\n+          guint32 avg_bitrate = QT_UINT32 (data + 8 + 8);\n+\n+          \/* Some muxers seem to swap the average and maximum bitrates\n+           * (I'm looking at you, YouTube), so we swap for sanity. *\/\n+          if (max_bitrate > 0 && max_bitrate < avg_bitrate) {\n+            guint temp = avg_bitrate;\n+\n+            avg_bitrate = max_bitrate;\n+            max_bitrate = temp;\n@@ -13759,2 +16670,8 @@\n-          if (QTDEMUX_TREE_NODE_FOURCC (mp4a) != FOURCC_enca) {\n-            mp4a = NULL;\n+          if (max_bitrate > 0 && max_bitrate < G_MAXUINT32) {\n+            gst_tag_list_add (stream->stream_tags,\n+                GST_TAG_MERGE_REPLACE, GST_TAG_MAXIMUM_BITRATE,\n+                max_bitrate, NULL);\n+          }\n+          if (avg_bitrate > 0 && avg_bitrate < G_MAXUINT32) {\n+            gst_tag_list_add (stream->stream_tags,\n+                GST_TAG_MERGE_REPLACE, GST_TAG_BITRATE, avg_bitrate, NULL);\n@@ -13762,2 +16679,0 @@\n-        } else {\n-          mp4a = NULL;\n@@ -13767,10 +16682,0 @@\n-      wave = NULL;\n-      if (mp4a) {\n-        wave = qtdemux_tree_get_child_by_type (mp4a, FOURCC_wave);\n-        if (wave)\n-          esds = qtdemux_tree_get_child_by_type (wave, FOURCC_esds);\n-        if (!esds)\n-          esds = qtdemux_tree_get_child_by_type (mp4a, FOURCC_esds);\n-      }\n-\n-\n@@ -13849,10 +16754,0 @@\n-#if 0\n-            \/* FIXME: what is in the chunk? *\/\n-          case FOURCC_QDMC:\n-          {\n-            gint len = QT_UINT32 (stsd_data);\n-\n-            \/* seems to be always = 116 = 0x74 *\/\n-            break;\n-          }\n-#endif\n@@ -13860,0 +16755,1 @@\n+          case FOURCC_QDMC:\n@@ -13861,1 +16757,2 @@\n-            gint len = QT_UINT32 (stsd_entry_data);\n+            if (wave) {\n+              guint32 len = QT_UINT32 (wave->data);\n@@ -13863,2 +16760,2 @@\n-            if (len > 0x3C) {\n-              GstBuffer *buf = gst_buffer_new_and_alloc (len - 0x3C);\n+              if (len > 8) {\n+                GstBuffer *buf = gst_buffer_new_and_alloc (len - 8);\n@@ -13866,4 +16763,6 @@\n-              gst_buffer_fill (buf, 0, stsd_entry_data + 0x3C, len - 0x3C);\n-              gst_caps_set_simple (entry->caps,\n-                  \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n-              gst_buffer_unref (buf);\n+                gst_buffer_fill (buf, 0, (const guint8 *) wave->data + 8,\n+                    len - 8);\n+                gst_caps_set_simple (entry->caps, \"codec_data\", GST_TYPE_BUFFER,\n+                    buf, NULL);\n+                gst_buffer_unref (buf);\n+              }\n@@ -13871,0 +16770,1 @@\n+\n@@ -13877,1 +16777,1 @@\n-            GNode *alac, *wave = NULL;\n+            GNode *alac;\n@@ -13881,9 +16781,5 @@\n-            alac = qtdemux_tree_get_child_by_type (stsd, FOURCC_alac);\n-            if (alac) {\n-              \/* alac now refers to stsd entry atom *\/\n-              wave = qtdemux_tree_get_child_by_type (alac, FOURCC_wave);\n-              if (wave)\n-                alac = qtdemux_tree_get_child_by_type (wave, FOURCC_alac);\n-              else\n-                alac = qtdemux_tree_get_child_by_type (alac, FOURCC_alac);\n-            }\n+            \/* alac now refers to stsd entry atom *\/\n+            if (wave)\n+              alac = qtdemux_tree_get_child_by_type (wave, FOURCC_alac);\n+            else\n+              alac = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_alac);\n@@ -13920,7 +16816,4 @@\n-            GNode *flac = qtdemux_tree_get_child_by_type (stsd, FOURCC_fLaC);\n-\n-            if (flac) {\n-              \/* The 'dfLa' box is added to the sample entry to convey\n-                 initializing information for the decoder. *\/\n-              const GNode *dfla =\n-                  qtdemux_tree_get_child_by_type (flac, FOURCC_dfLa);\n+            \/* The 'dfLa' box is added to the sample entry to convey\n+               initializing information for the decoder. *\/\n+            const GNode *dfla =\n+                qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_dfLa);\n@@ -14014,1 +16907,0 @@\n-                }\n@@ -14020,1 +16912,0 @@\n-            \/* Fallthrough! *\/\n@@ -14022,0 +16913,1 @@\n+            \/* FALLTHROUGH *\/\n@@ -14024,4 +16916,5 @@\n-            gint len = QT_UINT32 (stsd_entry_data);\n-\n-            if (len > 0x24) {\n-              GstBuffer *buf = gst_buffer_new_and_alloc (len - 0x24);\n+            const GNode *damr =\n+                qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_damr);\n+            if (damr) {\n+              guint32 len = QT_UINT32 (damr->data);\n+              GstBuffer *buf = gst_buffer_new_and_alloc (len);\n@@ -14030,1 +16923,5 @@\n-              gst_buffer_fill (buf, 0, stsd_entry_data + 0x24, len - 0x24);\n+              gst_buffer_fill (buf, 0, damr->data, len);\n+\n+              gst_caps_set_simple (entry->caps,\n+                  \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n+              gst_buffer_unref (buf);\n@@ -14034,2 +16931,3 @@\n-              if ((len - 0x34) > 8 &&\n-                  (bitrate = qtdemux_parse_amr_bitrate (buf, amrwb))) {\n+              if (len > 8 &&\n+                  (bitrate =\n+                      qtdemux_parse_amr_bitrate (damr->data, len, amrwb))) {\n@@ -14039,4 +16937,0 @@\n-\n-              gst_caps_set_simple (entry->caps,\n-                  \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n-              gst_buffer_unref (buf);\n@@ -14049,2 +16943,0 @@\n-            gint len = QT_UINT32 (stsd_entry_data);\n-            guint16 sound_version = 0;\n@@ -14052,1 +16944,1 @@\n-             * anything in mp4a atom that specifis compression *\/\n+             * anything in mp4a atom that specifies compression *\/\n@@ -14055,1 +16947,1 @@\n-            guint32 time_scale = (guint32) entry->rate;\n+            guint32 sample_rate = (guint32) entry->rate;\n@@ -14058,15 +16950,0 @@\n-            if (len >= 34) {\n-              sound_version = QT_UINT16 (stsd_entry_data + 16);\n-\n-              if (sound_version == 1) {\n-                channels = QT_UINT16 (stsd_entry_data + 24);\n-                time_scale = QT_UINT32 (stsd_entry_data + 30);\n-              } else {\n-                GST_FIXME_OBJECT (qtdemux, \"Unhandled mp4a atom version %d\",\n-                    sound_version);\n-              }\n-            } else {\n-              GST_DEBUG_OBJECT (qtdemux, \"Too small stsd entry data len %d\",\n-                  len);\n-            }\n-\n@@ -14074,1 +16951,1 @@\n-                gst_codec_utils_aac_get_index_from_sample_rate (time_scale);\n+                gst_codec_utils_aac_get_index_from_sample_rate (sample_rate);\n@@ -14093,1 +16970,7 @@\n-          case FOURCC_opus:\n+          case FOURCC_opus:{\n+            \/* Fully handled elsewhere *\/\n+            break;\n+          }\n+          case FOURCC_raw_:\n+          case FOURCC_sowt:\n+          case FOURCC_twos:\n@@ -14095,0 +16978,2 @@\n+          case FOURCC_ipcm:\n+          case FOURCC_fpcm:\n@@ -14099,2 +16984,39 @@\n-          case FOURCC_s16l:\n-            \/* Fully handled elsewhere *\/\n+          case FOURCC_s16l:{\n+            GNode *chnl, *chan;\n+\n+            \/\/ Parse channel layout information for raw PCM\n+            chnl = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_chnl);\n+            chan = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_chan);\n+\n+            if (chnl) {\n+              const guint8 *data = chnl->data;\n+              gsize len = QT_UINT32 (data);\n+              if (len >= 8 + 4) {\n+                GstByteReader br = GST_BYTE_READER_INIT (data, len);\n+                \/\/ Skip over fourcc and length\n+                gst_byte_reader_skip_unchecked (&br, 4 + 4);\n+                qtdemux_parse_chnl (qtdemux, &br, stream, entry);\n+              }\n+            } else if (chan) {\n+              const guint8 *data = chan->data;\n+              gsize len = QT_UINT32 (data);\n+              if (len >= 8 + 4) {\n+                GstByteReader br = GST_BYTE_READER_INIT (data, len);\n+                \/\/ Skip over fourcc and length\n+                gst_byte_reader_skip_unchecked (&br, 4 + 4);\n+                qtdemux_parse_chan (qtdemux, &br, stream, entry);\n+              }\n+            } else {\n+              GST_DEBUG_OBJECT (qtdemux,\n+                  \"Configuring default channel mask for %u channels\",\n+                  entry->n_channels);\n+\n+              if (entry->n_channels > 1) {\n+                \/\/ Set a default channel mask if all is unknown\n+                guint64 default_mask =\n+                    gst_audio_channel_get_fallback_mask (entry->n_channels);\n+\n+                gst_caps_set_simple (entry->caps, \"channel-mask\",\n+                    GST_TYPE_BITMASK, default_mask, NULL);\n+              }\n+            }\n@@ -14102,0 +17024,1 @@\n+          }\n@@ -14129,2 +17052,1 @@\n-          qtdemux_sub_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,\n-          &codec);\n+          qtdemux_sub_caps (qtdemux, stream, entry, fourcc, stsd_entry, &codec);\n@@ -14142,1 +17064,0 @@\n-          GNode *mp4s = NULL;\n@@ -14146,3 +17067,1 @@\n-          mp4s = qtdemux_tree_get_child_by_type (stsd, FOURCC_mp4s);\n-          if (mp4s)\n-            esds = qtdemux_tree_get_child_by_type (mp4s, FOURCC_esds);\n+          esds = qtdemux_tree_get_child_by_type (stsd_entry, FOURCC_esds);\n@@ -14172,1 +17091,1 @@\n-          qtdemux_meta_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,\n+          qtdemux_meta_caps (qtdemux, stream, entry, fourcc, stsd_entry,\n@@ -14189,1 +17108,1 @@\n-          qtdemux_generic_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,\n+          qtdemux_generic_caps (qtdemux, stream, entry, fourcc, stsd_entry,\n@@ -14217,4 +17136,0 @@\n-\n-\n-    stsd_entry_data += len;\n-    remaining_stsd_len -= len;\n@@ -14964,1 +17879,3 @@\n-  gint version;\n+  guint8 version;\n+  GstByteReader mvhd_reader;\n+  guint32 matrix[9];\n@@ -14969,1 +17886,2 @@\n-  mvhd = qtdemux_tree_get_child_by_type (qtdemux->moov_node, FOURCC_mvhd);\n+  mvhd = qtdemux_tree_get_child_by_type_full (qtdemux->moov_node,\n+      FOURCC_mvhd, &mvhd_reader);\n@@ -14975,1 +17893,5 @@\n-  version = QT_UINT8 ((guint8 *) mvhd->data + 8);\n+  if (!gst_byte_reader_get_uint8 (&mvhd_reader, &version))\n+    return FALSE;\n+  \/* flags *\/\n+  if (!gst_byte_reader_skip (&mvhd_reader, 3))\n+    return FALSE;\n@@ -14977,3 +17899,9 @@\n-    creation_time = QT_UINT64 ((guint8 *) mvhd->data + 12);\n-    qtdemux->timescale = QT_UINT32 ((guint8 *) mvhd->data + 28);\n-    qtdemux->duration = QT_UINT64 ((guint8 *) mvhd->data + 32);\n+    if (!gst_byte_reader_get_uint64_be (&mvhd_reader, &creation_time))\n+      return FALSE;\n+    \/* modification time *\/\n+    if (!gst_byte_reader_skip (&mvhd_reader, 8))\n+      return FALSE;\n+    if (!gst_byte_reader_get_uint32_be (&mvhd_reader, &qtdemux->timescale))\n+      return FALSE;\n+    if (!gst_byte_reader_get_uint64_be (&mvhd_reader, &qtdemux->duration))\n+      return FALSE;\n@@ -14981,3 +17909,13 @@\n-    creation_time = QT_UINT32 ((guint8 *) mvhd->data + 12);\n-    qtdemux->timescale = QT_UINT32 ((guint8 *) mvhd->data + 20);\n-    qtdemux->duration = QT_UINT32 ((guint8 *) mvhd->data + 24);\n+    guint32 tmp;\n+\n+    if (!gst_byte_reader_get_uint32_be (&mvhd_reader, &tmp))\n+      return FALSE;\n+    creation_time = tmp;\n+    \/* modification time *\/\n+    if (!gst_byte_reader_skip (&mvhd_reader, 4))\n+      return FALSE;\n+    if (!gst_byte_reader_get_uint32_be (&mvhd_reader, &qtdemux->timescale))\n+      return FALSE;\n+    if (!gst_byte_reader_get_uint32_be (&mvhd_reader, &tmp))\n+      return FALSE;\n+    qtdemux->duration = tmp;\n@@ -14989,0 +17927,7 @@\n+  if (!gst_byte_reader_skip (&mvhd_reader, 4 + 2 + 2 + 2 * 4))\n+    return FALSE;\n+\n+  if (!qtdemux_parse_transformation_matrix (qtdemux, &mvhd_reader, matrix,\n+          \"mvhd\"))\n+    return FALSE;\n+\n@@ -15058,1 +18003,1 @@\n-      if (!qtdemux_parse_trak (qtdemux, trak))\n+      if (!qtdemux_parse_trak (qtdemux, trak, matrix))\n@@ -15061,1 +18006,1 @@\n-    qtdemux_parse_trak (qtdemux, trak);\n+    qtdemux_parse_trak (qtdemux, trak, matrix);\n@@ -15557,1 +18502,1 @@\n-               }\n+              }\n@@ -15600,1 +18545,1 @@\n-    const guint8 * stsd_entry_data, gchar ** codec_name)\n+    GNode * stsd_entry, gchar ** codec_name)\n@@ -15656,1 +18601,2 @@\n-      bps = QT_UINT16 (stsd_entry_data + 82);\n+      \/\/ Read VisualSampleEntry depth. Size is checked by the caller already.\n+      bps = QT_UINT16 ((const guint8 *) stsd_entry->data + 82);\n@@ -15712,0 +18658,1 @@\n+    case GST_MAKE_FOURCC ('m', '1', 'v', ' '):\n@@ -15889,0 +18836,13 @@\n+    case FOURCC_H266:\n+    case FOURCC_vvc1:\n+      _codec (\"H.266 \/ VVC\");\n+      caps = gst_caps_new_simple (\"video\/x-h266\",\n+          \"stream-format\", G_TYPE_STRING, \"vvc1\",\n+          \"alignment\", G_TYPE_STRING, \"au\", NULL);\n+      break;\n+    case FOURCC_vvi1:\n+      _codec (\"H.266 \/ VVC\");\n+      caps = gst_caps_new_simple (\"video\/x-h266\",\n+          \"stream-format\", G_TYPE_STRING, \"vvi1\",\n+          \"alignment\", G_TYPE_STRING, \"au\", NULL);\n+      break;\n@@ -15968,1 +18928,9 @@\n-      caps = gst_caps_from_string (\"video\/x-dnxhd\");\n+      caps =\n+          gst_caps_new_simple (\"video\/x-dnxhd\", \"profile\", G_TYPE_STRING,\n+          \"dnxhd\", NULL);\n+      break;\n+    case GST_MAKE_FOURCC ('A', 'V', 'd', 'h'):\n+      _codec (\"AVID DNxHR\");\n+      caps =\n+          gst_caps_new_simple (\"video\/x-dnxhd\", \"profile\", G_TYPE_STRING,\n+          \"dnxhr\", NULL);\n@@ -16062,0 +19030,91 @@\n+    case FOURCC_LAGS:\n+      _codec (\"Lagarith lossless video codec\");\n+      caps = gst_caps_new_empty_simple (\"video\/x-lagarith\");\n+      break;\n+    case FOURCC_Hap1:\n+    case FOURCC_Hap5:\n+    case FOURCC_HapY:\n+    case FOURCC_HapM:\n+    case FOURCC_HapA:\n+    case FOURCC_Hap7:\n+    case FOURCC_HapH:{\n+      gchar *variant =\n+          g_strdup_printf (\"%\" GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));\n+      caps = gst_caps_new_simple (\"video\/x-hap\",\n+          \"variant\", G_TYPE_STRING, variant, NULL);\n+      g_free (variant);\n+\n+      \/\/ https:\/\/github.com\/Vidvox\/hap\/blob\/master\/documentation\/HapVideoDRAFT.md\n+      switch (fourcc) {\n+        case FOURCC_Hap5:\n+          _codec (\"Hap Alpha\");\n+          break;\n+        case FOURCC_HapY:\n+          _codec (\"Hap Q\");\n+          break;\n+        case FOURCC_HapM:\n+          _codec (\"Hap Q Alpha\");\n+          break;\n+        case FOURCC_HapA:\n+          _codec (\"Hap Alpha-Only\");\n+          break;\n+        case FOURCC_Hap7:\n+          _codec (\"Hap R\");\n+          break;\n+        case FOURCC_HapH:\n+          _codec (\"Hap HDR\");\n+          break;\n+        case FOURCC_Hap1:\n+        default:\n+          _codec (\"Hap\");\n+          break;\n+      }\n+      break;\n+    }\n+    case FOURCC_uncv:\n+    {\n+      GNode *uncC_node, *cmpd_node;\n+\n+      GstByteReader reader;\n+      UncompressedFrameConfigBox uncC = { 0 };\n+      ComponentDefinitionBox cmpd = { 0 };\n+\n+      uncC_node =\n+          qtdemux_tree_get_child_by_type_full (stsd_entry, FOURCC_uncC,\n+          &reader);\n+      if (!uncC_node) {\n+        GST_WARNING_OBJECT (qtdemux,\n+            \"Expected to find uncC box when parsing uncv\");\n+        break;\n+      }\n+\n+      if (!qtdemux_parse_uncC (qtdemux, &reader, &uncC)) {\n+        GST_WARNING_OBJECT (qtdemux, \"Failed parsing uncC box\");\n+        break;\n+      }\n+\n+      cmpd_node =\n+          qtdemux_tree_get_child_by_type_full (stsd_entry, FOURCC_cmpd,\n+          &reader);\n+      if (uncC.version == 0 && !cmpd_node) {\n+        GST_WARNING_OBJECT (qtdemux,\n+            \"Expected to find cmpd box when parsing uncv\");\n+        break;\n+      }\n+\n+      if (cmpd_node && !qtdemux_parse_cmpd (qtdemux, &reader, &cmpd)) {\n+        GST_WARNING_OBJECT (qtdemux, \"Failed parsing cmpd box\");\n+        break;\n+      }\n+\n+      format = qtdemux_get_format_from_uncv (qtdemux, &uncC, &cmpd);\n+      gst_video_info_set_format (&stream->pre_info, format, entry->width,\n+          entry->height);\n+      qtdemux_set_info_from_uncv (qtdemux, entry, &uncC, &stream->pre_info);\n+      stream->alignment = 32;\n+\n+      \/* Free Memory *\/\n+      qtdemux_clear_uncC (&uncC);\n+      qtdemux_clear_cmpd (&cmpd);\n+      break;\n+    }\n@@ -16071,1 +19130,2 @@\n-    GstVideoInfo info;\n+    gst_video_info_set_format (&stream->info, format, entry->width,\n+        entry->height);\n@@ -16073,4 +19133,1 @@\n-    gst_video_info_init (&info);\n-    gst_video_info_set_format (&info, format, entry->width, entry->height);\n-\n-    caps = gst_video_info_to_caps (&info);\n+    caps = gst_video_info_to_caps (&stream->info);\n@@ -16079,0 +19136,6 @@\n+    \/* If pre_info is initialized, then row_alignment may be neccessary *\/\n+    if (stream->pre_info.size) {\n+      stream->needs_row_alignment =\n+          !gst_video_info_is_equal (&stream->info, &stream->pre_info);\n+    }\n+\n@@ -16101,2 +19164,3 @@\n-    QtDemuxStreamStsdEntry * entry, guint32 fourcc, const guint8 * data,\n-    int len, gchar ** codec_name)\n+    QtDemuxStreamStsdEntry * entry, guint32 fourcc,\n+    guint8 stsd_version, guint32 version,\n+    GNode * stsd_entry, gchar ** codec_name)\n@@ -16122,0 +19186,1 @@\n+      \/* FALLTHROUGH *\/\n@@ -16124,1 +19189,1 @@\n-      \/* fall-through *\/\n+      \/* FALLTHROUGH *\/\n@@ -16285,1 +19350,1 @@\n-    case GST_MAKE_FOURCC ('Q', 'D', 'M', 'C'):\n+    case FOURCC_QDMC:\n@@ -16292,8 +19357,8 @@\n-      if (FALSE && data) {\n-        caps = gst_caps_new_simple (\"audio\/x-qdm2\",\n-            \"framesize\", G_TYPE_INT, QT_UINT32 (data + 52),\n-            \"bitrate\", G_TYPE_INT, QT_UINT32 (data + 40),\n-            \"blocksize\", G_TYPE_INT, QT_UINT32 (data + 44), NULL);\n-      } else {\n-        caps = gst_caps_new_empty_simple (\"audio\/x-qdm2\");\n-      }\n+      \/\/ if (FALSE && data) {\n+      \/\/   caps = gst_caps_new_simple (\"audio\/x-qdm2\",\n+      \/\/       \"framesize\", G_TYPE_INT, QT_UINT32 (data + 52),\n+      \/\/       \"bitrate\", G_TYPE_INT, QT_UINT32 (data + 40),\n+      \/\/       \"blocksize\", G_TYPE_INT, QT_UINT32 (data + 44), NULL);\n+      \/\/ } else {\n+      caps = gst_caps_new_empty_simple (\"audio\/x-qdm2\");\n+      \/\/}\n@@ -16342,0 +19407,2 @@\n+      const guint8 *data;\n+      guint32 len;\n@@ -16357,4 +19424,8 @@\n-      if (data && len >= 36) {\n-        depth = QT_UINT32 (data + 24);\n-        flags = QT_UINT32 (data + 28);\n-        width = QT_UINT32 (data + 32) * 8 \/ entry->n_channels;\n+      data = stsd_entry->data;\n+      len = QT_UINT32 (data);\n+\n+      if (stsd_version == 0 && version == 0x00020000 && len >= 16 + 56) {\n+        \/* sample description entry (16) + sound sample description v0 (20) *\/\n+        depth = QT_UINT32 (data + 36 + 20);\n+        flags = QT_UINT32 (data + 36 + 24);\n+        width = QT_UINT32 (data + 36 + 28) * 8 \/ entry->n_channels;\n@@ -16362,0 +19433,1 @@\n+\n@@ -16404,0 +19476,9 @@\n+    case FOURCC_ipcm:\n+    case FOURCC_fpcm:\n+    {\n+      _codec (\"RAW PCM audio\");\n+      caps =\n+          gst_caps_new_simple (\"audio\/x-raw\", \"layout\", G_TYPE_STRING,\n+          \"interleaved\", NULL);\n+      break;\n+    }\n@@ -16444,1 +19525,1 @@\n-    const guint8 * stsd_entry_data, gchar ** codec_name)\n+    GNode * stsd_entry, gchar ** codec_name)\n@@ -16515,1 +19596,1 @@\n-    const guint8 * stsd_entry_data, gchar ** codec_name)\n+    GNode * stsd_entry, gchar ** codec_name)\n@@ -16523,0 +19604,1 @@\n+      const guint8 *stsd_entry_data = stsd_entry->data;\n@@ -16572,1 +19654,1 @@\n-    const guint8 * stsd_entry_data, gchar ** codec_name)\n+    GNode * stsd_entry, gchar ** codec_name)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/qtdemux.c","additions":4133,"deletions":1051,"binary":false,"changes":5184,"status":"modified"},{"patch":"@@ -340,0 +340,4 @@\n+  gboolean content_light_level_set;\n+  GstVideoContentLightLevel content_light_level;\n+  gboolean mastering_display_info_set;\n+  GstVideoMasteringDisplayInfo mastering_display_info;\n@@ -350,0 +354,2 @@\n+  gboolean needs_reorder;\n+  gint reorder_map[64];\n@@ -426,0 +432,4 @@\n+  GstVideoInfo info;\n+  GstVideoInfo pre_info;        \/* Original file info, may be unaligned *\/\n+  gboolean needs_row_alignment;\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/qtdemux.h","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -90,0 +90,24 @@\n+GNode *\n+qtdemux_tree_get_child_by_index_full (GNode * node, guint index,\n+    GstByteReader * parser)\n+{\n+  GNode *child;\n+  guint8 *buffer;\n+  guint32 child_len;\n+\n+  child = g_node_nth_child (node, index);\n+  if (child) {\n+    buffer = (guint8 *) child->data;\n+\n+    if (parser) {\n+      child_len = QT_UINT32 (buffer);\n+      if (G_UNLIKELY (child_len < (4 + 4)))\n+        return NULL;\n+      \/* FIXME: must verify if atom length < parent atom length *\/\n+      gst_byte_reader_init (parser, buffer + (4 + 4), child_len - (4 + 4));\n+    }\n+    return child;\n+  }\n+  return NULL;\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/qtdemux_tree.c","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+GNode *qtdemux_tree_get_child_by_index_full (GNode * node, guint index,\n+    GstByteReader * parser);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/qtdemux_tree.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-  {FOURCC_XdxT, \"XdxT\", 0},\n+  {FOURCC_XdxT, \"XdxT\", QT_FLAG_CONTAINER},\n@@ -214,0 +214,3 @@\n+  {FOURCC_vvc1, \"VVC codec configuration\", 0},\n+  {FOURCC_vvi1, \"VVC codec configuration\", 0},\n+  {FOURCC_vvcC, \"VVC codec configuration container\", 0},\n@@ -252,0 +255,4 @@\n+  {FOURCC_ipcm, \"RAW Integer PCM\", 0},\n+  {FOURCC_fpcm, \"RAW Float PCM\", 0},\n+  {FOURCC_pcmC, \"RAW PCM Configuration Box\", 0},\n+  {FOURCC_chnl, \"Channel Layout Box\", 0},\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/qtdemux_types.c","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -68,5 +68,2 @@\n-#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n-# define FORMATS \"{ S16LE, S24LE, S32LE, F32LE, F64LE }\"\n-#else\n-# define FORMATS \"{ S16BE, S24BE, S32BE, F32BE, F64BE }\"\n-#endif\n+#define FORMATS \"{ \" GST_AUDIO_NE (S16) \", \" GST_AUDIO_NE (S24) \", \" \\\n+    GST_AUDIO_NE (S32) \", \" GST_AUDIO_NE (F32) \", \" GST_AUDIO_NE (F64) \" }\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/spectrum\/gstspectrum.c","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+\/* reset seek event and destroy adapter if @hard is TRUE *\/\n@@ -224,1 +225,1 @@\n-gst_wavparse_reset (GstWavParse * wav)\n+gst_wavparse_reset (GstWavParse * wav, gboolean hard)\n@@ -246,2 +247,2 @@\n-  if (wav->seek_event)\n-    gst_event_unref (wav->seek_event);\n+  if (hard)\n+    g_clear_pointer (&wav->seek_event, gst_event_unref);\n@@ -251,2 +252,2 @@\n-    g_object_unref (wav->adapter);\n-    wav->adapter = NULL;\n+    if (hard)\n+      g_clear_object (&wav->adapter);\n@@ -283,1 +284,1 @@\n-  gst_wavparse_reset (wav);\n+  gst_wavparse_reset (wav, TRUE);\n@@ -296,1 +297,1 @@\n-  gst_wavparse_reset (wavparse);\n+  gst_wavparse_reset (wavparse, TRUE);\n@@ -311,2 +312,2 @@\n-    gst_pad_set_query_function (wavparse->sinkpad,\n-            GST_DEBUG_FUNCPTR (gst_wavparse_sink_query));\n+  gst_pad_set_query_function (wavparse->sinkpad,\n+      GST_DEBUG_FUNCPTR (gst_wavparse_sink_query));\n@@ -1333,2 +1334,3 @@\n-  \/* loop headers until we get data *\/\n-  while (!gotdata) {\n+  \/* loop headers until we got the data tag in push mode, or until we\n+   * reached the end of file in pull mode*\/\n+  while (!gotdata || !wav->streaming) {\n@@ -1342,3 +1344,3 @@\n-      if ((res =\n-              gst_wavparse_pull_range_exact (wav, wav->offset, 8,\n-                  &buf)) != GST_FLOW_OK)\n+      res = gst_wavparse_pull_range_exact (wav, wav->offset, 8, &buf);\n+      if (res == GST_FLOW_EOS) {\n+        break;\n@@ -1346,3 +1348,2 @@\n-        if (res == GST_FLOW_FLUSHING)\n-          goto exit;\n-        else\n+      } else if (res == GST_FLOW_FLUSHING) {\n+        goto exit;\n@@ -1350,0 +1351,1 @@\n+      } else if (res != GST_FLOW_OK) {\n@@ -1351,0 +1353,1 @@\n+      }\n@@ -1390,1 +1393,0 @@\n-          gotdata = TRUE;\n@@ -1419,0 +1421,1 @@\n+        gotdata = TRUE;\n@@ -1458,3 +1461,5 @@\n-            if ((res =\n-                    gst_wavparse_pull_range_exact (wav, wav->offset + 8,\n-                        data_size, &buf)) != GST_FLOW_OK)\n+            res =\n+                gst_wavparse_pull_range_exact (wav, wav->offset + 8,\n+                data_size, &buf);\n+            if (res == GST_FLOW_EOS)\n+              break;\n@@ -1462,1 +1467,1 @@\n-            if (res == GST_FLOW_FLUSHING)\n+            else if (res == GST_FLOW_FLUSHING)\n@@ -1464,1 +1469,0 @@\n-            else\n@@ -1466,0 +1470,1 @@\n+            else if (res != GST_FLOW_OK)\n@@ -1509,3 +1514,4 @@\n-          if ((res =\n-                  gst_wavparse_pull_range_exact (wav, wav->offset + 8, size,\n-                      &buf)) != GST_FLOW_OK)\n+          res =\n+              gst_wavparse_pull_range_exact (wav, wav->offset + 8, size, &buf);\n+          if (res == GST_FLOW_EOS)\n+            break;\n@@ -1513,1 +1519,1 @@\n-          if (res == GST_FLOW_FLUSHING)\n+          else if (res == GST_FLOW_FLUSHING)\n@@ -1515,1 +1521,0 @@\n-          else\n@@ -1517,0 +1522,1 @@\n+          else if (res != GST_FLOW_OK)\n@@ -1557,3 +1563,3 @@\n-          if ((res =\n-                  gst_wavparse_pull_range_exact (wav, wav->offset, 12,\n-                      &buf)) != GST_FLOW_OK)\n+          res = gst_wavparse_pull_range_exact (wav, wav->offset, 12, &buf);\n+          if (res == GST_FLOW_EOS)\n+            break;\n@@ -1561,1 +1567,1 @@\n-          if (res == GST_FLOW_FLUSHING)\n+          else if (res == GST_FLOW_FLUSHING)\n@@ -1563,1 +1569,0 @@\n-          else\n@@ -1565,0 +1570,1 @@\n+          else if (res != GST_FLOW_OK)\n@@ -1591,3 +1597,5 @@\n-                if ((res =\n-                        gst_wavparse_pull_range_exact (wav, wav->offset,\n-                            data_size, &buf)) != GST_FLOW_OK)\n+                res =\n+                    gst_wavparse_pull_range_exact (wav, wav->offset,\n+                    data_size, &buf);\n+                if (res == GST_FLOW_EOS)\n+                  break;\n@@ -1595,1 +1603,1 @@\n-                if (res == GST_FLOW_FLUSHING)\n+                else if (res == GST_FLOW_FLUSHING)\n@@ -1597,1 +1605,0 @@\n-                else\n@@ -1599,0 +1606,1 @@\n+                else if (res != GST_FLOW_OK)\n@@ -1636,3 +1644,6 @@\n-              if ((res =\n-                      gst_wavparse_pull_range_exact (wav, wav->offset,\n-                          data_size, &buf)) != GST_FLOW_OK)\n+              res =\n+                  gst_wavparse_pull_range_exact (wav, wav->offset,\n+                  data_size, &buf);\n+              if (res == GST_FLOW_EOS)\n+                break;\n+              else if (res != GST_FLOW_OK)\n@@ -1682,3 +1693,5 @@\n-          if ((res =\n-                  gst_wavparse_pull_range_exact (wav, wav->offset,\n-                      data_size, &buf)) != GST_FLOW_OK)\n+          res =\n+              gst_wavparse_pull_range_exact (wav, wav->offset, data_size, &buf);\n+          if (res == GST_FLOW_EOS)\n+            break;\n+          else if (res != GST_FLOW_OK)\n@@ -1726,3 +1739,5 @@\n-          if ((res =\n-                  gst_wavparse_pull_range_exact (wav, wav->offset,\n-                      data_size, &buf)) != GST_FLOW_OK)\n+          res =\n+              gst_wavparse_pull_range_exact (wav, wav->offset, data_size, &buf);\n+          if (res == GST_FLOW_EOS)\n+            break;\n+          else if (res != GST_FLOW_OK)\n@@ -1758,1 +1773,2 @@\n-      gotdata = TRUE;\n+      if (!wav->streaming)\n+        break;\n@@ -1762,0 +1778,3 @@\n+  if (!gotdata)\n+    goto no_data;\n+\n@@ -1830,0 +1849,5 @@\n+no_data:\n+  {\n+    GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL), (\"Stream without data\"));\n+    goto fail;\n+  }\n@@ -2458,1 +2482,1 @@\n-      \/* otherwise fall-through *\/\n+      \/* FALLTHROUGH *\/\n@@ -2470,1 +2494,1 @@\n-      \/* fall-through *\/\n+      \/* FALLTHROUGH *\/\n@@ -2524,0 +2548,7 @@\n+    case GST_EVENT_STREAM_START:\n+    {\n+      gst_wavparse_reset (wav, FALSE);\n+\n+      ret = gst_pad_event_default (wav->sinkpad, parent, event);\n+      break;\n+    }\n@@ -2670,1 +2701,0 @@\n-      \/* fall-through *\/\n@@ -2672,0 +2702,1 @@\n+      \/* FALLTHROUGH *\/\n@@ -3125,1 +3156,1 @@\n-      gst_wavparse_reset (wav);\n+      gst_wavparse_reset (wav, TRUE);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/wavparse\/gstwavparse.c","additions":83,"deletions":52,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"gstatdec.h\"\n+#include \"gstatenc.h\"\n@@ -53,1 +55,1 @@\n-ret |= GST_ELEMENT_REGISTER (osxaudiosink, plugin);\n+  ret |= GST_ELEMENT_REGISTER (osxaudiosink, plugin);\n@@ -56,0 +58,2 @@\n+  ret |= GST_ELEMENT_REGISTER (atdec, plugin);\n+  ret |= GST_ELEMENT_REGISTER (atenc, plugin);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudio.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -124,1 +124,0 @@\n-  ringbuffer->core_audio = gst_core_audio_new (GST_OBJECT (ringbuffer));\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudioringbuffer.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,1 +91,3 @@\n-  ARG_VOLUME\n+  ARG_VOLUME,\n+  ARG_UNIQUE_ID,\n+  ARG_CONFIGURE_SESSION,\n@@ -95,0 +97,1 @@\n+#define DEFAULT_CONFIGURE_SESSION TRUE\n@@ -182,0 +185,35 @@\n+\n+  \/**\n+   * osxaudiosink:unique-id\n+   *\n+   * Unique persistent ID for the output device\n+   *\n+   * Since: 1.26\n+   *\/\n+  g_object_class_install_property (gobject_class, ARG_UNIQUE_ID,\n+      g_param_spec_string (\"unique-id\", \"Unique ID\",\n+          \"Unique persistent ID for the input device\",\n+          NULL, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));\n+#else\n+  \/**\n+   * GstOsxAudioSink:configure-session:\n+   *\n+   * Whether the app-wide AVAudioSession should be automatically set up for audio playback.\n+   * This will set the category to AVAudioSessionCategoryPlayback and activate the session\n+   * when the element goes to READY. No other settings will be changed.\n+   *\n+   * The category change will only occur if current category is the default one (SoloAmbient)\n+   * to avoid setting the category 'lower' if an osxaudiosrc element is also running in the\n+   * same process.\n+   *\n+   * If your application needs to configure anything more than the category, set this to FALSE\n+   * for all osxaudiosink\/src instances and handle the AVAudioSession setup yourself.\n+   *\n+   * Since: 1.26\n+   *\/\n+  g_object_class_install_property (gobject_class, ARG_CONFIGURE_SESSION,\n+      g_param_spec_boolean (\"configure-session\",\n+          \"Enable automatic AVAudioSession setup\",\n+          \"Whether the app-wide AVAudioSession should be automatically configured for audio playback\",\n+          DEFAULT_CONFIGURE_SESSION,\n+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));\n@@ -215,0 +253,4 @@\n+\n+#ifdef HAVE_IOS\n+  sink->configure_session = DEFAULT_CONFIGURE_SESSION;\n+#endif\n@@ -228,0 +270,4 @@\n+#else\n+    case ARG_CONFIGURE_SESSION:\n+      sink->configure_session = g_value_get_boolean (value);\n+      break;\n@@ -251,0 +297,1 @@\n+      osxsink->unique_id = NULL;\n@@ -272,0 +319,1 @@\n+        osxsink->unique_id = ringbuffer->core_audio->unique_id;\n@@ -295,0 +343,9 @@\n+    case ARG_UNIQUE_ID:\n+      GST_OBJECT_LOCK (sink);\n+      g_value_set_string (value, sink->unique_id);\n+      GST_OBJECT_UNLOCK (sink);\n+      break;\n+#else\n+    case ARG_CONFIGURE_SESSION:\n+      g_value_set_boolean (value, sink->configure_session);\n+      break;\n@@ -521,0 +578,7 @@\n+  ringbuffer->core_audio = g_object_new (GST_TYPE_CORE_AUDIO,\n+      \"is-src\", FALSE, \"device\", osxsink->device_id,\n+#ifdef HAVE_IOS\n+      \"configure-session\", osxsink->configure_session,\n+#endif\n+      NULL);\n+  ringbuffer->core_audio->osxbuf = GST_OBJECT (ringbuffer);\n@@ -523,8 +587,0 @@\n-  ringbuffer->core_audio->is_src = FALSE;\n-\n-  \/* By default the coreaudio instance created by the ringbuffer\n-   * has device_id==kAudioDeviceUnknown. The user might have\n-   * selected a different one here\n-   *\/\n-  if (ringbuffer->core_audio->device_id != osxsink->device_id)\n-    ringbuffer->core_audio->device_id = osxsink->device_id;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudiosink.c","additions":65,"deletions":9,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+  const char *unique_id;\n@@ -90,0 +91,4 @@\n+\n+#ifdef HAVE_IOS\n+  gboolean configure_session;\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudiosink.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,1 +79,3 @@\n-  ARG_DEVICE\n+  ARG_DEVICE,\n+  ARG_UNIQUE_ID,\n+  ARG_CONFIGURE_SESSION,\n@@ -82,0 +84,2 @@\n+#define DEFAULT_CONFIGURE_SESSION TRUE\n+\n@@ -154,0 +158,33 @@\n+  \/**\n+   * osxaudiosrc:unique-id\n+   *\n+   * Unique persistent ID for the input device\n+   *\n+   * Since: 1.26\n+   *\/\n+  g_object_class_install_property (gobject_class, ARG_UNIQUE_ID,\n+      g_param_spec_string (\"unique-id\", \"Unique ID\",\n+          \"Unique persistent ID for the input device\",\n+          NULL, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));\n+\n+#ifdef HAVE_IOS\n+  \/**\n+   * GstOsxAudioSrc:configure-session:\n+   *\n+   * Whether the app-wide AVAudioSession should be automatically set up for audio capture.\n+   * This will set the category to AVAudioSessionCategoryPlayAndRecord and activate\n+   * the session when the element goes to READY. No other settings will be changed.\n+   *\n+   * If your application needs to configure anything more than the category, set this to FALSE\n+   * for all osxaudiosink\/src instances and handle the AVAudioSession setup yourself.\n+   *\n+   * Since: 1.26\n+   *\/\n+  g_object_class_install_property (gobject_class, ARG_CONFIGURE_SESSION,\n+      g_param_spec_boolean (\"configure-session\",\n+          \"Enable automatic AVAudioSession setup\",\n+          \"Whether the app-wide AVAudioSession should be automatically configured for audio capture\",\n+          DEFAULT_CONFIGURE_SESSION,\n+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));\n+#endif\n+\n@@ -171,0 +208,5 @@\n+  src->unique_id = NULL;\n+\n+#ifdef HAVE_IOS\n+  src->configure_session = DEFAULT_CONFIGURE_SESSION;\n+#endif\n@@ -183,0 +225,5 @@\n+#ifdef HAVE_IOS\n+    case ARG_CONFIGURE_SESSION:\n+      src->configure_session = g_value_get_boolean (value);\n+      break;\n+#endif\n@@ -199,0 +246,10 @@\n+    case ARG_UNIQUE_ID:\n+      GST_OBJECT_LOCK (src);\n+      g_value_set_string (value, src->unique_id);\n+      GST_OBJECT_UNLOCK (src);\n+      break;\n+#ifdef HAVE_IOS\n+    case ARG_CONFIGURE_SESSION:\n+      g_value_set_boolean (value, src->configure_session);\n+      break;\n+#endif\n@@ -216,0 +273,1 @@\n+      osxsrc->unique_id = NULL;\n@@ -219,0 +277,7 @@\n+#ifdef HAVE_IOS\n+    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:\n+      ringbuffer =\n+          GST_OSX_AUDIO_RING_BUFFER (GST_AUDIO_BASE_SRC (osxsrc)->ringbuffer);\n+      ringbuffer->core_audio->first_sample_time = -1;\n+      break;\n+#endif\n@@ -235,0 +300,1 @@\n+        osxsrc->unique_id = ringbuffer->core_audio->unique_id;\n@@ -326,0 +392,7 @@\n+  ringbuffer->core_audio = g_object_new (GST_TYPE_CORE_AUDIO,\n+      \"is-src\", TRUE, \"device\", osxsrc->device_id,\n+#ifdef HAVE_IOS\n+      \"configure-session\", osxsrc->configure_session,\n+#endif\n+      NULL);\n+  ringbuffer->core_audio->osxbuf = GST_OBJECT (ringbuffer);\n@@ -328,8 +401,0 @@\n-  ringbuffer->core_audio->is_src = TRUE;\n-\n-  \/* By default the coreaudio instance created by the ringbuffer\n-   * has device_id==kAudioDeviceUnknown. The user might have\n-   * selected a different one here\n-   *\/\n-  if (ringbuffer->core_audio->device_id != osxsrc->device_id)\n-    ringbuffer->core_audio->device_id = osxsrc->device_id;\n@@ -381,0 +446,11 @@\n+#ifdef HAVE_IOS\n+  \/* Timestamps don't always start from 0 on iOS, have to offset *\/\n+  if (buf->core_audio->first_sample_time == -1) {\n+    GST_ERROR (\"Setting first CoreAudio timestamp to %f\",\n+        inTimeStamp->mSampleTime);\n+    buf->core_audio->first_sample_time = inTimeStamp->mSampleTime;\n+  }\n+\n+  sample_position -= buf->core_audio->first_sample_time;\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudiosrc.c","additions":85,"deletions":9,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -76,0 +76,5 @@\n+  const char *unique_id;\n+\n+#ifdef HAVE_IOS\n+  gboolean configure_session;\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudiosrc.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include <CoreAudio\/CoreAudio.h>\n@@ -38,0 +39,13 @@\n+enum\n+{\n+  PROP_0,\n+  PROP_DEVICE,\n+  PROP_IS_SRC,\n+  PROP_CONFIGURE_SESSION,\n+};\n+\n+static void gst_core_audio_set_property (GObject * object, guint prop_id,\n+    const GValue * value, GParamSpec * pspec);\n+static void gst_core_audio_get_property (GObject * object, guint prop_id,\n+    GValue * value, GParamSpec * pspec);\n+\n@@ -43,0 +57,1 @@\n+  g_free (core_audio->unique_id);\n@@ -52,0 +67,21 @@\n+\n+  object_klass->set_property = gst_core_audio_set_property;\n+  object_klass->get_property = gst_core_audio_get_property;\n+\n+  g_object_class_install_property (object_klass, PROP_DEVICE,\n+      g_param_spec_int (\"device\", \"Device ID\", \"Device ID of input device\",\n+          0, G_MAXINT, 0,\n+          G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));\n+\n+  g_object_class_install_property (object_klass, PROP_IS_SRC,\n+      g_param_spec_boolean (\"is-src\", \"Is source\", \"Is a source device\",\n+          FALSE,\n+          G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));\n+\n+#ifdef HAVE_IOS\n+  g_object_class_install_property (object_klass, PROP_CONFIGURE_SESSION,\n+      g_param_spec_boolean (\"configure-session\",\n+          \"Enable automatic AVAudioSession setup\",\n+          \"Auto-configure the AVAudioSession for audio playback\/capture\", FALSE,\n+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY));\n+#endif\n@@ -59,0 +95,1 @@\n+  core_audio->unique_id = NULL;\n@@ -66,0 +103,2 @@\n+#else\n+  core_audio->configure_session = FALSE;\n@@ -72,0 +111,48 @@\n+static void\n+gst_core_audio_set_property (GObject * object, guint prop_id,\n+    const GValue * value, GParamSpec * pspec)\n+{\n+  GstCoreAudio *self = GST_CORE_AUDIO (object);\n+\n+  switch (prop_id) {\n+    case PROP_IS_SRC:\n+      self->is_src = g_value_get_boolean (value);\n+      break;\n+    case PROP_DEVICE:\n+      self->device_id = g_value_get_int (value);\n+      break;\n+#ifdef HAVE_IOS\n+    case PROP_CONFIGURE_SESSION:\n+      self->configure_session = g_value_get_boolean (value);\n+      break;\n+#endif\n+    default:\n+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n+      break;\n+  }\n+}\n+\n+static void\n+gst_core_audio_get_property (GObject * object, guint prop_id,\n+    GValue * value, GParamSpec * pspec)\n+{\n+  GstCoreAudio *self = GST_CORE_AUDIO (object);\n+\n+  switch (prop_id) {\n+    case PROP_IS_SRC:\n+      g_value_set_boolean (value, self->is_src);\n+      break;\n+    case PROP_DEVICE:\n+      g_value_set_int (value, self->device_id);\n+      break;\n+#ifdef HAVE_IOS\n+    case PROP_CONFIGURE_SESSION:\n+      g_value_set_boolean (value, self->configure_session);\n+      break;\n+#endif\n+    default:\n+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n+      break;\n+  }\n+}\n+\n@@ -131,11 +218,0 @@\n-GstCoreAudio *\n-gst_core_audio_new (GstObject * osxbuf)\n-{\n-  GstCoreAudio *core_audio;\n-\n-  core_audio = g_object_new (GST_TYPE_CORE_AUDIO, NULL);\n-  core_audio->osxbuf = osxbuf;\n-  core_audio->cached_caps = NULL;\n-  return core_audio;\n-}\n-\n@@ -371,1 +447,10 @@\n-  return gst_core_audio_select_device_impl (core_audio);\n+  gboolean ret = gst_core_audio_select_device_impl (core_audio);\n+\n+#ifndef HAVE_IOS\n+  if (core_audio->device_id != kAudioDeviceUnknown)\n+    core_audio->unique_id =\n+        gst_core_audio_device_get_prop (core_audio->device_id,\n+        kAudioDevicePropertyDeviceUID);\n+#endif\n+\n+  return ret;\n@@ -410,0 +495,23 @@\n+static gboolean\n+_core_audio_has_invalid_channel_labels (AudioChannelLayout * layout)\n+{\n+  guint i;\n+\n+  g_assert (layout->mChannelLayoutTag ==\n+      kAudioChannelLayoutTag_UseChannelDescriptions);\n+\n+  for (i = 0; i < layout->mNumberChannelDescriptions; ++i) {\n+    \/* Let's use our mapping to judge whether the value is valid.\n+     * It doesn't support all of the defined positions, but the missing ones\n+     * aren't useful to us anyway. *\/\n+    GstAudioChannelPosition p =\n+        gst_core_audio_channel_label_to_gst\n+        (layout->mChannelDescriptions[i].mChannelLabel, i, FALSE);\n+\n+    if (p == GST_AUDIO_CHANNEL_POSITION_INVALID)\n+      return TRUE;\n+  }\n+\n+  return FALSE;\n+}\n+\n@@ -420,0 +528,18 @@\n+  \/* For >16ch devices, CoreAudio can give out completely incorrect\n+   * channel positions by default - instead of using kAudioChannelLabel_Discrete_X,\n+   * it just returns incrementing values starting from 0, some of which are not\n+   * valid if you check against the CoreAudioBaseTypes.h header.\n+   * If such case is detected, let's just swap all positions to Discrete,\n+   * which map to GST_AUDIO_CHANNEL_POSITION_NONE. *\/\n+  if (_core_audio_has_invalid_channel_labels (layout)) {\n+    GST_DEBUG\n+        (\"Invalid channel positions given by CoreAudio, setting all to unpositioned\");\n+    if (pos) {\n+      for (i = 0; i < layout->mNumberChannelDescriptions; ++i)\n+        pos[i] = GST_AUDIO_CHANNEL_POSITION_NONE;\n+    }\n+    *channels = layout->mNumberChannelDescriptions;\n+    *channel_mask = 0;\n+    return;\n+  }\n+\n@@ -743,1 +869,1 @@\n-  guint i, channels;\n+  guint i, channels, channels_max = 0;\n@@ -775,0 +901,11 @@\n+    if (channel_mask != 0 && channels > 2 &&\n+        layout->mChannelLayoutTag ==\n+        kAudioChannelLayoutTag_UseChannelDescriptions) {\n+      \/* CoreAudio gave us a positioned layout, which might mean we're ignoring some unpositioned channels.\n+       * For example, with a 64ch output, macOS only allows assigning positions to 16 channels at most.\n+       * Let's make sure we also expose the actual maximum amount of channels in our caps,\n+       * without any positions assigned. *\/\n+      channels_max =\n+          MIN (layout->mNumberChannelDescriptions, GST_OSX_AUDIO_MAX_CHANNEL);\n+    }\n+\n@@ -859,1 +996,11 @@\n-        \/* Otherwise just add the caps *\/\n+        \/* Otherwise, if needed, add an unpositioned max-channels variant ... *\/\n+        if (channels_max > 0) {\n+          GstStructure *unpos_s = gst_structure_copy (in_s);\n+          gst_structure_set (unpos_s, \"channels\", G_TYPE_INT, channels_max,\n+              NULL);\n+          gst_structure_set (unpos_s, \"channel-mask\", GST_TYPE_BITMASK, 0,\n+              NULL);\n+          gst_caps_append_structure (caps, unpos_s);\n+        }\n+\n+        \/* ... and just add the caps *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxcoreaudio.c","additions":161,"deletions":14,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+  char *unique_id;\n+  gboolean is_default;\n@@ -120,0 +122,5 @@\n+\n+#ifdef HAVE_IOS\n+  gdouble first_sample_time;\n+  gboolean configure_session;\n+#endif\n@@ -131,2 +138,0 @@\n-GstCoreAudio * gst_core_audio_new                            (GstObject *osxbuf);\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxcoreaudio.h","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+  AudioUnitPropertyID callback_type;\n@@ -40,0 +41,3 @@\n+  callback_type = core_audio->is_src ?\n+      kAudioOutputUnitProperty_SetInputCallback :\n+      kAudioUnitProperty_SetRenderCallback;\n@@ -41,1 +45,1 @@\n-  status = AudioUnitSetProperty (core_audio->audiounit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Global, 0,        \/* N\/A for global *\/\n+  status = AudioUnitSetProperty (core_audio->audiounit, callback_type, kAudioUnitScope_Global, 0,       \/* N\/A for global *\/\n@@ -125,0 +129,3 @@\n+  \/\/ AudioOutputUnitStart on iOS can wait for the render callback to finish,\n+  \/\/ where in our case we set the ringbuffer timestamp, which also needs the ringbuf lock.\n+  GST_OBJECT_UNLOCK (core_audio->osxbuf);\n@@ -126,0 +133,1 @@\n+  GST_OBJECT_LOCK (core_audio->osxbuf);\n@@ -562,0 +570,50 @@\n+\n+#ifndef HAVE_IOS\n+char *\n+gst_core_audio_device_get_prop (AudioDeviceID device_id,\n+    AudioObjectPropertyElement prop_id)\n+{\n+  OSStatus status = noErr;\n+  UInt32 propertySize = 0;\n+  CFStringRef prop_val;\n+  gchar *result = NULL;\n+\n+  AudioObjectPropertyAddress propAddress = {\n+    prop_id,\n+    kAudioDevicePropertyScopeOutput,\n+    kAudioObjectPropertyElementMain\n+  };\n+\n+  propAddress.mScope = kAudioObjectPropertyScopeGlobal;\n+\n+  \/* Get the length of the device name *\/\n+  status = AudioObjectGetPropertyDataSize (device_id,\n+      &propAddress, 0, NULL, &propertySize);\n+  if (status != noErr) {\n+    goto beach;\n+  }\n+\n+  \/* Get the requested property *\/\n+  status = AudioObjectGetPropertyData (device_id,\n+      &propAddress, 0, NULL, &propertySize, &prop_val);\n+  if (status != noErr) {\n+    goto beach;\n+  }\n+\n+  \/* Convert to UTF-8 C String *\/\n+  CFIndex prop_len = CFStringGetLength (prop_val);\n+  CFIndex max_size =\n+      CFStringGetMaximumSizeForEncoding (prop_len, kCFStringEncodingUTF8) + 1;\n+  result = g_malloc (max_size);\n+\n+  if (!CFStringGetCString (prop_val, result, max_size, kCFStringEncodingUTF8)) {\n+    g_free (result);\n+    result = NULL;\n+  }\n+\n+  CFRelease (prop_val);\n+\n+beach:\n+  return result;\n+}\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxcoreaudiocommon.c","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+#pragma once\n+\n@@ -70,0 +72,5 @@\n+#ifndef HAVE_IOS\n+char * gst_core_audio_device_get_prop (AudioDeviceID device_id,\n+                                       AudioObjectPropertyElement prop_id);\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxcoreaudiocommon.h","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1227,0 +1227,3 @@\n+  \/* Find the ID of the default output device *\/\n+  AudioDeviceID default_device_id = _audio_system_get_default_device (output);\n+\n@@ -1230,4 +1233,0 @@\n-    AudioDeviceID default_device_id;\n-\n-    \/* Find the ID of the default output device *\/\n-    default_device_id = _audio_system_get_default_device (output);\n@@ -1307,1 +1306,1 @@\n-  if (res)\n+  if (res) {\n@@ -1309,0 +1308,2 @@\n+    core_audio->is_default = (device_id == default_device_id);\n+  }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxcoreaudiohal.c","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#import \"gstiosaudiosession.h\"\n@@ -28,0 +29,8 @@\n+  \/* On iOS, an AVAudioSession needs to be set up to 1) avoid playback being silenced\n+   * by silent mode and 2) to allow audio to be captured from the microphone.\n+   * However, AVAudioSession has a lot of settings and in more complicated scenarios,\n+   * apps\/users should handle that themselves. Disable auto-config through the\n+   * configure-session property on osxaudiosrc\/sink in those cases. *\/\n+  if (core_audio->configure_session)\n+    gst_ios_audio_session_setup (core_audio->is_src);\n+\n@@ -129,0 +138,1 @@\n+  core_audio->is_default = TRUE;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxcoreaudioremoteio.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -61,0 +61,20 @@\n+#if !GLIB_CHECK_VERSION(2, 81, 1)\n+#define g_sort_array(a,n,s,f,udata) gst_g_sort_array(a,n,s,f,udata)\n+\n+\/\/ Don't need to maintain ABI compat here (n_elements), since we never pass\n+\/\/ the function as pointer but always call it directly ourselves.\n+static inline void\n+gst_g_sort_array (const void       *array,\n+                  gssize            n_elements,\n+                  size_t            element_size,\n+                  GCompareDataFunc  compare_func,\n+                  void             *user_data)\n+{\n+  if (n_elements >= 0 && n_elements <= G_MAXINT) {\n+    g_qsort_with_data (array, n_elements, element_size, compare_func, user_data);\n+  } else {\n+    g_abort ();\n+  }\n+}\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/glib-compat-private.h","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -695,1 +695,0 @@\n-  _priv_gst_quarks_initialize ();\n@@ -868,0 +867,6 @@\n+  \/* Allow the `dots` tracer to set the `GST_DEBUG_DUMP_DOT_DIR` variable if it\n+   * was not set before *\/\n+#ifndef GST_DISABLE_GST_DEBUG\n+  if (!priv_gst_dump_dot_dir)\n+    priv_gst_dump_dot_dir = g_getenv (\"GST_DEBUG_DUMP_DOT_DIR\");\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gst.c","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include <gst\/gstidstr.h>\n@@ -99,0 +100,1 @@\n+#include <gst\/gstvecdeque.h>\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gst.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,0 @@\n-G_GNUC_INTERNAL  void  _priv_gst_quarks_initialize (void);\n@@ -192,1 +191,1 @@\n-gboolean priv__gst_structure_append_template_to_gstring (GQuark field_id,\n+gboolean priv__gst_structure_append_template_to_gstring (const gchar * field,\n@@ -253,0 +252,7 @@\n+\/* Internal variables used in gstutils.c and initialized in\n+ * _priv_gst_plugin_initialize(). *\/\n+G_GNUC_INTERNAL\n+extern GQuark _priv_gst_plugin_api_quark;\n+G_GNUC_INTERNAL\n+extern GQuark _priv_gst_plugin_api_flags_quark;\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gst_private.h","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -175,1 +175,8 @@\n-#if defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8)\n+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_ATOMICS__)\n+#include <stdatomic.h>\n+static inline gint64\n+gst_atomic_int64_inc (gint64 * atomic)\n+{\n+  return atomic_fetch_add ((_Atomic gint64 *) atomic, 1);\n+}\n+#elif defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8)\n@@ -2026,1 +2033,1 @@\n- * @size: the size to extract\n+ * @size: (in): the size to extract\n@@ -2530,2 +2537,2 @@\n- * @func: (scope call): a #GstBufferForeachMetaFunc to call\n- * @user_data: (closure): user data passed to @func\n+ * @func: (scope call) (closure user_data): a #GstBufferForeachMetaFunc to call\n+ * @user_data: user data passed to @func\n@@ -2844,1 +2851,3 @@\n-  GstReferenceTimestampMeta *dmeta, *smeta;\n+  const GstReferenceTimestampMeta *smeta, *ometa;\n+  GstReferenceTimestampMeta *dmeta;\n+  gpointer iter = NULL;\n@@ -2849,1 +2858,15 @@\n-  smeta = (GstReferenceTimestampMeta *) meta;\n+  smeta = (const GstReferenceTimestampMeta *) meta;\n+\n+  while ((ometa = (const GstReferenceTimestampMeta *)\n+          gst_buffer_iterate_meta_filtered (dest, &iter,\n+              GST_REFERENCE_TIMESTAMP_META_API_TYPE))) {\n+    if (ometa->timestamp == smeta->timestamp\n+        && ometa->duration == smeta->duration\n+        && gst_caps_is_equal (ometa->reference, smeta->reference)) {\n+      GST_CAT_TRACE (gst_reference_timestamp_meta_debug,\n+          \"Not copying reference timestamp metadata from buffer %p to %p because equal meta already exists\",\n+          buffer, dest);\n+      return TRUE;\n+    }\n+  }\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstbuffer.c","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -226,2 +226,2 @@\n- * @func: (scope call): a #GstBufferListFunc to call\n- * @user_data: (closure): user data passed to @func\n+ * @func: (scope call) (closure user_data): a #GstBufferListFunc to call\n+ * @user_data: user data passed to @func\n@@ -335,3 +335,3 @@\n- * Returns: (transfer none) (nullable): the buffer at @idx in @group\n- *     or %NULL when there is no buffer. The buffer remains valid as\n- *     long as @list is valid and buffer is not removed from the list.\n+ * Returns: (transfer none): the buffer at @idx in @group.\n+ *     The returned buffer remains valid as long as @list is valid and\n+ *     buffer is not removed from the list.\n@@ -358,2 +358,2 @@\n- * Returns: (transfer none) (nullable): the buffer at @idx in @group.\n- *     The returned  buffer remains valid as long as @list is valid and\n+ * Returns: (transfer none): the buffer at @idx in @group.\n+ *     The returned buffer remains valid as long as @list is valid and\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstbufferlist.c","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -73,2 +73,1 @@\n-#include \"gstatomicqueue.h\"\n-#include \"gstpoll.h\"\n+#include \"gstvecdeque.h\"\n@@ -76,1 +75,0 @@\n-#include \"gstquark.h\"\n@@ -95,2 +93,3 @@\n-  GstAtomicQueue *queue;\n-  GstPoll *poll;\n+  GMutex queue_lock;\n+  GCond queue_cond;\n+  GstVecDeque *queue;\n@@ -162,2 +161,4 @@\n-  priv->poll = gst_poll_new_timer ();\n-  priv->queue = gst_atomic_queue_new (16);\n+  priv->queue = gst_vec_deque_new (16);\n+  g_mutex_init (&priv->queue_lock);\n+  g_cond_init (&priv->queue_cond);\n+\n@@ -168,1 +169,1 @@\n-  priv->config = gst_structure_new_id_empty (GST_QUARK (BUFFER_POOL_CONFIG));\n+  priv->config = gst_structure_new_static_str_empty (\"GstBufferPoolConfig\");\n@@ -174,4 +175,0 @@\n-  \/* 1 control write for flushing - the flush token *\/\n-  gst_poll_write_control (priv->poll);\n-  \/* 1 control write for marking that we are not waiting for poll - the wait token *\/\n-  gst_poll_write_control (priv->poll);\n@@ -210,2 +207,3 @@\n-  gst_atomic_queue_unref (priv->queue);\n-  gst_poll_free (priv->poll);\n+  gst_vec_deque_free (priv->queue);\n+  g_mutex_clear (&priv->queue_lock);\n+  g_cond_clear (&priv->queue_cond);\n@@ -400,0 +398,4 @@\n+\n+  g_mutex_lock (&priv->queue_lock);\n+  g_cond_signal (&priv->queue_cond);\n+  g_mutex_unlock (&priv->queue_lock);\n@@ -408,0 +410,1 @@\n+  gboolean cleared;\n@@ -410,12 +413,3 @@\n-  while ((buffer = gst_atomic_queue_pop (priv->queue))) {\n-    while (!gst_poll_read_control (priv->poll)) {\n-      if (errno == EWOULDBLOCK) {\n-        \/* We put the buffer into the queue but did not finish writing control\n-         * yet, let's wait a bit and retry *\/\n-        g_thread_yield ();\n-        continue;\n-      } else {\n-        \/* Critical error but GstPoll already complained *\/\n-        break;\n-      }\n-    }\n+  g_mutex_lock (&priv->queue_lock);\n+  while ((buffer = gst_vec_deque_pop_head (priv->queue))) {\n+    g_mutex_unlock (&priv->queue_lock);\n@@ -423,0 +417,1 @@\n+    g_mutex_lock (&priv->queue_lock);\n@@ -424,1 +419,3 @@\n-  return priv->cur_buffers == 0;\n+  cleared = priv->cur_buffers == 0;\n+  g_mutex_unlock (&priv->queue_lock);\n+  return cleared;\n@@ -461,0 +458,2 @@\n+    \/* Wake up any waiters *\/\n+    g_mutex_lock (&priv->queue_lock);\n@@ -462,2 +461,2 @@\n-    \/* Write the flush token to wake up any waiters *\/\n-    gst_poll_write_control (priv->poll);\n+    g_cond_broadcast (&priv->queue_cond);\n+    g_mutex_unlock (&priv->queue_lock);\n@@ -471,13 +470,0 @@\n-    while (!gst_poll_read_control (priv->poll)) {\n-      if (errno == EWOULDBLOCK) {\n-        \/* This should not really happen unless flushing and unflushing\n-         * happens on different threads. Let's wait a bit to get back flush\n-         * token from the thread that was setting it to flushing *\/\n-        g_thread_yield ();\n-        continue;\n-      } else {\n-        \/* Critical error but GstPoll already complained *\/\n-        break;\n-      }\n-    }\n-\n@@ -846,5 +832,5 @@\n-  gst_structure_id_set (config,\n-      GST_QUARK (CAPS), GST_TYPE_CAPS, caps,\n-      GST_QUARK (SIZE), G_TYPE_UINT, size,\n-      GST_QUARK (MIN_BUFFERS), G_TYPE_UINT, min_buffers,\n-      GST_QUARK (MAX_BUFFERS), G_TYPE_UINT, max_buffers, NULL);\n+  gst_structure_set_static_str (config,\n+      \"caps\", GST_TYPE_CAPS, caps,\n+      \"size\", G_TYPE_UINT, size,\n+      \"min-buffers\", G_TYPE_UINT, min_buffers,\n+      \"max-buffers\", G_TYPE_UINT, max_buffers, NULL);\n@@ -879,3 +865,3 @@\n-  gst_structure_id_set (config,\n-      GST_QUARK (ALLOCATOR), GST_TYPE_ALLOCATOR, allocator,\n-      GST_QUARK (PARAMS), GST_TYPE_ALLOCATION_PARAMS, params, NULL);\n+  gst_structure_set_static_str (config,\n+      \"allocator\", GST_TYPE_ALLOCATOR, allocator,\n+      \"params\", GST_TYPE_ALLOCATION_PARAMS, params, NULL);\n@@ -903,1 +889,1 @@\n-  value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));\n+  value = gst_structure_get_value (config, \"options\");\n@@ -916,2 +902,2 @@\n-    gst_structure_id_take_value (config, GST_QUARK (OPTIONS), &new_array_val);\n-    value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));\n+    gst_structure_take_value_static_str (config, \"options\", &new_array_val);\n+    value = gst_structure_get_value (config, \"options\");\n@@ -941,1 +927,1 @@\n-  value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));\n+  value = gst_structure_get_value (config, \"options\");\n@@ -966,1 +952,1 @@\n-  value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));\n+  value = gst_structure_get_value (config, \"options\");\n@@ -994,1 +980,1 @@\n-  value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));\n+  value = gst_structure_get_value (config, \"options\");\n@@ -1026,2 +1012,1 @@\n-    *caps = g_value_get_boxed (gst_structure_id_get_value (config,\n-            GST_QUARK (CAPS)));\n+    *caps = g_value_get_boxed (gst_structure_get_value (config, \"caps\"));\n@@ -1029,4 +1014,4 @@\n-  return gst_structure_id_get (config,\n-      GST_QUARK (SIZE), G_TYPE_UINT, size,\n-      GST_QUARK (MIN_BUFFERS), G_TYPE_UINT, min_buffers,\n-      GST_QUARK (MAX_BUFFERS), G_TYPE_UINT, max_buffers, NULL);\n+  return gst_structure_get (config,\n+      \"size\", G_TYPE_UINT, size,\n+      \"min-buffers\", G_TYPE_UINT, min_buffers,\n+      \"max-buffers\", G_TYPE_UINT, max_buffers, NULL);\n@@ -1052,2 +1037,2 @@\n-    *allocator = g_value_get_object (gst_structure_id_get_value (config,\n-            GST_QUARK (ALLOCATOR)));\n+    *allocator = g_value_get_object (gst_structure_get_value (config,\n+            \"allocator\"));\n@@ -1057,2 +1042,1 @@\n-    p = g_value_get_boxed (gst_structure_id_get_value (config,\n-            GST_QUARK (PARAMS)));\n+    p = g_value_get_boxed (gst_structure_get_value (config, \"params\"));\n@@ -1115,0 +1099,1 @@\n+  g_mutex_lock (&priv->queue_lock);\n@@ -1120,1 +1105,3 @@\n-    *buffer = gst_atomic_queue_pop (priv->queue);\n+    *buffer = gst_vec_deque_pop_head (priv->queue);\n+    g_mutex_unlock (&priv->queue_lock);\n+\n@@ -1122,11 +1109,0 @@\n-      while (!gst_poll_read_control (priv->poll)) {\n-        if (errno == EWOULDBLOCK) {\n-          \/* We put the buffer into the queue but did not finish writing control\n-           * yet, let's wait a bit and retry *\/\n-          g_thread_yield ();\n-          continue;\n-        } else {\n-          \/* Critical error but GstPoll already complained *\/\n-          break;\n-        }\n-      }\n@@ -1155,28 +1131,8 @@\n-    \/* now we release the control socket, we wait for a buffer release or\n-     * flushing *\/\n-    if (!gst_poll_read_control (pool->priv->poll)) {\n-      if (errno == EWOULDBLOCK) {\n-        \/* This means that we have two threads trying to allocate buffers\n-         * already, and the other one already got the wait token. This\n-         * means that we only have to wait for the poll now and not write the\n-         * token afterwards: we will be woken up once the other thread is\n-         * woken up and that one will write the wait token it removed *\/\n-        GST_LOG_OBJECT (pool, \"waiting for free buffers or flushing\");\n-        gst_poll_wait (priv->poll, GST_CLOCK_TIME_NONE);\n-      } else {\n-        \/* This is a critical error, GstPoll already gave a warning *\/\n-        result = GST_FLOW_ERROR;\n-        break;\n-      }\n-    } else {\n-      \/* We're the first thread waiting, we got the wait token and have to\n-       * write it again later\n-       * OR\n-       * We're a second thread and just consumed the flush token and block all\n-       * other threads, in which case we must not wait and give it back\n-       * immediately *\/\n-      if (!GST_BUFFER_POOL_IS_FLUSHING (pool)) {\n-        GST_LOG_OBJECT (pool, \"waiting for free buffers or flushing\");\n-        gst_poll_wait (priv->poll, GST_CLOCK_TIME_NONE);\n-      }\n-      gst_poll_write_control (pool->priv->poll);\n+    \/* now we wait for a buffer release or flushing *\/\n+    g_mutex_lock (&priv->queue_lock);\n+    while (gst_vec_deque_get_length (priv->queue) == 0\n+        && !GST_BUFFER_POOL_IS_FLUSHING (pool)\n+        && g_atomic_int_get (&priv->cur_buffers) >= priv->max_buffers) {\n+      GST_LOG_OBJECT (pool, \"waiting for free buffers or flushing\");\n+      g_cond_wait (&priv->queue_cond, &priv->queue_lock);\n+      GST_LOG_OBJECT (pool, \"waited for free buffers or flushing\");\n@@ -1191,0 +1147,1 @@\n+    g_mutex_unlock (&priv->queue_lock);\n@@ -1334,2 +1291,4 @@\n-  gst_atomic_queue_push (pool->priv->queue, buffer);\n-  gst_poll_write_control (pool->priv->poll);\n+  g_mutex_lock (&pool->priv->queue_lock);\n+  gst_vec_deque_push_tail (pool->priv->queue, buffer);\n+  g_cond_signal (&pool->priv->queue_cond);\n+  g_mutex_unlock (&pool->priv->queue_lock);\n@@ -1361,1 +1320,4 @@\n-    gst_poll_write_control (pool->priv->poll);\n+\n+    g_mutex_lock (&pool->priv->queue_lock);\n+    g_cond_signal (&pool->priv->queue_cond);\n+    g_mutex_unlock (&pool->priv->queue_lock);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstbufferpool.c","additions":71,"deletions":109,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -160,0 +160,3 @@\n+   * Subclasses do not need to chain up to the parent's default implementation\n+   * if they don't want min-buffers based preallocation.\n+   *\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstbufferpool.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-#include \"gstatomicqueue.h\"\n+#include \"gstvecdeque.h\"\n@@ -143,1 +143,0 @@\n-  GstAtomicQueue *queue;\n@@ -145,0 +144,1 @@\n+  GstVecDeque *queue;\n@@ -255,1 +255,1 @@\n-  bus->priv->queue = gst_atomic_queue_new (32);\n+  bus->priv->queue = gst_vec_deque_new (32);\n@@ -270,1 +270,1 @@\n-      message = gst_atomic_queue_pop (bus->priv->queue);\n+      message = gst_vec_deque_pop_head (bus->priv->queue);\n@@ -274,1 +274,1 @@\n-    gst_atomic_queue_unref (bus->priv->queue);\n+    gst_vec_deque_free (bus->priv->queue);\n@@ -384,1 +384,2 @@\n-      guint length = gst_atomic_queue_length (bus->priv->queue);\n+      g_mutex_lock (&bus->priv->queue_lock);\n+      gsize length = gst_vec_deque_get_length (bus->priv->queue);\n@@ -386,1 +387,2 @@\n-        GST_WARNING_OBJECT (bus, \"queue overflows with %d messages. \"\n+        GST_WARNING_OBJECT (bus,\n+            \"queue overflows with %\" G_GSIZE_FORMAT \" messages. \"\n@@ -393,1 +395,1 @@\n-      gst_atomic_queue_push (bus->priv->queue, message);\n+      gst_vec_deque_push_tail (bus->priv->queue, message);\n@@ -396,0 +398,1 @@\n+      g_mutex_unlock (&bus->priv->queue_lock);\n@@ -418,1 +421,2 @@\n-      gst_atomic_queue_push (bus->priv->queue, message);\n+      g_mutex_lock (&bus->priv->queue_lock);\n+      gst_vec_deque_push_tail (bus->priv->queue, message);\n@@ -420,0 +424,1 @@\n+      g_mutex_unlock (&bus->priv->queue_lock);\n@@ -473,1 +478,3 @@\n-  result = gst_atomic_queue_length (bus->priv->queue) != 0;\n+  g_mutex_lock (&bus->priv->queue_lock);\n+  result = gst_vec_deque_get_length (bus->priv->queue) != 0;\n+  g_mutex_unlock (&bus->priv->queue_lock);\n@@ -550,2 +557,2 @@\n-    GST_LOG_OBJECT (bus, \"have %d messages\",\n-        gst_atomic_queue_length (bus->priv->queue));\n+    GST_LOG_OBJECT (bus, \"have %\" G_GSIZE_FORMAT \" messages\",\n+        gst_vec_deque_get_length (bus->priv->queue));\n@@ -553,1 +560,1 @@\n-    while ((message = gst_atomic_queue_pop (bus->priv->queue))) {\n+    while ((message = gst_vec_deque_pop_head (bus->priv->queue))) {\n@@ -713,1 +720,1 @@\n-  message = gst_atomic_queue_peek (bus->priv->queue);\n+  message = gst_vec_deque_peek_head (bus->priv->queue);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstbus.c","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+#include \"gstidstr-private.h\"\n@@ -287,0 +288,36 @@\n+\/**\n+ * gst_caps_new_id_str_empty_simple:\n+ * @media_type: the media type of the structure\n+ *\n+ * Creates a new #GstCaps that contains one #GstStructure with name\n+ * @media_type.\n+ *\n+ * Returns: (transfer full): the new #GstCaps\n+ *\n+ * Since: 1.26\n+ *\/\n+GstCaps *\n+gst_caps_new_id_str_empty_simple (const GstIdStr * media_type)\n+{\n+  GstCaps *caps;\n+  GstStructure *structure;\n+\n+  caps = gst_caps_new_empty ();\n+  if (gst_id_str_is_equal_to_str (media_type, \"ANY\")) {\n+    g_warning\n+        (\"media_type should not be ANY. Please consider using `gst_caps_new_any` or `gst_caps_from_string`.\");\n+  }\n+  if (gst_id_str_get_len (media_type) == 0\n+      || gst_id_str_is_equal_to_str (media_type, \"EMPTY\")\n+      || gst_id_str_is_equal_to_str (media_type, \"NONE\")) {\n+    g_warning\n+        (\"media_type should not be `%s`. Please consider using `gst_caps_new_empty` or `gst_caps_from_string`.\",\n+        gst_id_str_as_str (media_type));\n+  }\n+  structure = gst_structure_new_id_str_empty (media_type);\n+  if (structure)\n+    gst_caps_append_structure_unchecked (caps, structure, NULL);\n+\n+  return caps;\n+}\n+\n@@ -320,0 +357,74 @@\n+\/**\n+ * gst_caps_new_static_str_empty_simple:\n+ * @media_type: the media type of the structure\n+ *\n+ * Creates a new #GstCaps that contains one #GstStructure with name\n+ * @media_type.\n+ *\n+ * @media_type needs to be valid for the remaining lifetime of the process, e.g.\n+ * has to be a static string.\n+ *\n+ * Returns: (transfer full): the new #GstCaps\n+ *\n+ * Since: 1.26\n+ *\/\n+GstCaps *\n+gst_caps_new_static_str_empty_simple (const char *media_type)\n+{\n+  GstCaps *caps;\n+  GstStructure *structure;\n+\n+  caps = gst_caps_new_empty ();\n+  if (strcmp (\"ANY\", media_type) == 0) {\n+    g_warning\n+        (\"media_type should not be ANY. Please consider using `gst_caps_new_any` or `gst_caps_from_string`.\");\n+  }\n+  if (strcmp (\"\", media_type) == 0 || strcmp (\"EMPTY\", media_type) == 0\n+      || strcmp (\"NONE\", media_type) == 0) {\n+    g_warning\n+        (\"media_type should not be `%s`. Please consider using `gst_caps_new_empty` or `gst_caps_from_string`.\",\n+        media_type);\n+  }\n+  structure = gst_structure_new_static_str_empty (media_type);\n+  if (structure)\n+    gst_caps_append_structure_unchecked (caps, structure, NULL);\n+\n+  return caps;\n+}\n+\n+\/**\n+ * gst_caps_new_id_str_simple:\n+ * @media_type: the media type of the structure\n+ * @fieldname: first field to set\n+ * @...: additional arguments\n+ *\n+ * Creates a new #GstCaps that contains one #GstStructure.  The\n+ * structure is defined by the arguments, which have the same format\n+ * as gst_structure_new().\n+ *\n+ * Returns: (transfer full): the new #GstCaps\n+ *\n+ * Since: 1.26\n+ *\/\n+GstCaps *\n+gst_caps_new_id_str_simple (const GstIdStr * media_type,\n+    const GstIdStr * fieldname, ...)\n+{\n+  GstCaps *caps;\n+  GstStructure *structure;\n+  va_list var_args;\n+\n+  caps = gst_caps_new_empty ();\n+\n+  va_start (var_args, fieldname);\n+  structure = gst_structure_new_id_str_valist (media_type, fieldname, var_args);\n+  va_end (var_args);\n+\n+  if (structure)\n+    gst_caps_append_structure_unchecked (caps, structure, NULL);\n+  else\n+    gst_caps_replace (&caps, NULL);\n+\n+  return caps;\n+}\n+\n@@ -353,0 +464,40 @@\n+\/**\n+ * gst_caps_new_static_str_simple:\n+ * @media_type: the media type of the structure\n+ * @fieldname: first field to set\n+ * @...: additional arguments\n+ *\n+ * Creates a new #GstCaps that contains one #GstStructure.  The\n+ * structure is defined by the arguments, which have the same format\n+ * as gst_structure_new().\n+ *\n+ * @media_type, @fieldname and all other fieldnames need to be valid for the\n+ * remaining lifetime of the process, e.g. have to be static strings.\n+ *\n+ * Returns: (transfer full): the new #GstCaps\n+ *\n+ * Since: 1.26\n+ *\/\n+GstCaps *\n+gst_caps_new_static_str_simple (const char *media_type, const char *fieldname,\n+    ...)\n+{\n+  GstCaps *caps;\n+  GstStructure *structure;\n+  va_list var_args;\n+\n+  caps = gst_caps_new_empty ();\n+\n+  va_start (var_args, fieldname);\n+  structure =\n+      gst_structure_new_static_str_valist (media_type, fieldname, var_args);\n+  va_end (var_args);\n+\n+  if (structure)\n+    gst_caps_append_structure_unchecked (caps, structure, NULL);\n+  else\n+    gst_caps_replace (&caps, NULL);\n+\n+  return caps;\n+}\n+\n@@ -1095,0 +1246,30 @@\n+\/**\n+ * gst_caps_id_str_set_value:\n+ * @caps: a writable caps\n+ * @field: name of the field to set\n+ * @value: value to set the field to\n+ *\n+ * Sets the given @field on all structures of @caps to the given @value.\n+ * This is a convenience function for calling gst_structure_set_value() on\n+ * all structures of @caps.\n+ *\n+ * Since: 1.26\n+ **\/\n+void\n+gst_caps_id_str_set_value (GstCaps * caps, const GstIdStr * field,\n+    const GValue * value)\n+{\n+  guint i, len;\n+\n+  g_return_if_fail (GST_IS_CAPS (caps));\n+  g_return_if_fail (IS_WRITABLE (caps));\n+  g_return_if_fail (field != NULL);\n+  g_return_if_fail (G_IS_VALUE (value));\n+\n+  len = GST_CAPS_LEN (caps);\n+  for (i = 0; i < len; i++) {\n+    GstStructure *structure = gst_caps_get_structure_unchecked (caps, i);\n+    gst_structure_id_str_set_value (structure, field, value);\n+  }\n+}\n+\n@@ -1122,0 +1303,74 @@\n+\/**\n+ * gst_caps_set_value_static_str:\n+ * @caps: a writable caps\n+ * @field: name of the field to set\n+ * @value: value to set the field to\n+ *\n+ * Sets the given @field on all structures of @caps to the given @value.\n+ * This is a convenience function for calling gst_structure_set_value() on\n+ * all structures of @caps.\n+ *\n+ * @field needs to be valid for the remaining lifetime of the process, e.g.\n+ * has to be a static string.\n+ *\n+ * Since: 1.26\n+ **\/\n+void\n+gst_caps_set_value_static_str (GstCaps * caps, const char *field,\n+    const GValue * value)\n+{\n+  guint i, len;\n+\n+  g_return_if_fail (GST_IS_CAPS (caps));\n+  g_return_if_fail (IS_WRITABLE (caps));\n+  g_return_if_fail (field != NULL);\n+  g_return_if_fail (G_IS_VALUE (value));\n+\n+  len = GST_CAPS_LEN (caps);\n+  for (i = 0; i < len; i++) {\n+    GstStructure *structure = gst_caps_get_structure_unchecked (caps, i);\n+    gst_structure_set_value_static_str (structure, field, value);\n+  }\n+}\n+\n+\/**\n+ * gst_caps_id_str_set_simple_valist:\n+ * @caps: the #GstCaps to set\n+ * @field: first field to set\n+ * @varargs: additional parameters\n+ *\n+ * Sets fields in a #GstCaps.  The arguments must be passed in the same\n+ * manner as gst_structure_id_str_set(), and be %NULL-terminated.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_caps_id_str_set_simple_valist (GstCaps * caps, const GstIdStr * field,\n+    va_list varargs)\n+{\n+  GValue value = { 0, };\n+\n+  g_return_if_fail (GST_IS_CAPS (caps));\n+  g_return_if_fail (IS_WRITABLE (caps));\n+\n+  while (field) {\n+    GType type;\n+    char *err;\n+\n+    type = va_arg (varargs, GType);\n+\n+    G_VALUE_COLLECT_INIT (&value, type, varargs, 0, &err);\n+    if (G_UNLIKELY (err)) {\n+      g_critical (\"%s\", err);\n+      g_free (err);\n+      return;\n+    }\n+\n+    gst_caps_id_str_set_value (caps, field, &value);\n+\n+    g_value_unset (&value);\n+\n+    field = va_arg (varargs, const GstIdStr *);\n+  }\n+}\n+\n@@ -1160,0 +1415,68 @@\n+\/**\n+ * gst_caps_set_simple_static_str_valist:\n+ * @caps: the #GstCaps to set\n+ * @field: first field to set\n+ * @varargs: additional parameters\n+ *\n+ * Sets fields in a #GstCaps.  The arguments must be passed in the same\n+ * manner as gst_structure_set(), and be %NULL-terminated.\n+ *\n+ * @field and all other field names need to be valid for the remaining lifetime\n+ * of the process, e.g. have to be static strings.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_caps_set_simple_static_str_valist (GstCaps * caps, const char *field,\n+    va_list varargs)\n+{\n+  GValue value = { 0, };\n+\n+  g_return_if_fail (GST_IS_CAPS (caps));\n+  g_return_if_fail (IS_WRITABLE (caps));\n+\n+  while (field) {\n+    GType type;\n+    char *err;\n+\n+    type = va_arg (varargs, GType);\n+\n+    G_VALUE_COLLECT_INIT (&value, type, varargs, 0, &err);\n+    if (G_UNLIKELY (err)) {\n+      g_critical (\"%s\", err);\n+      g_free (err);\n+      return;\n+    }\n+\n+    gst_caps_set_value_static_str (caps, field, &value);\n+\n+    g_value_unset (&value);\n+\n+    field = va_arg (varargs, const gchar *);\n+  }\n+}\n+\n+\/**\n+ * gst_caps_id_str_set_simple:\n+ * @caps: the #GstCaps to set\n+ * @field: first field to set\n+ * @...: additional parameters\n+ *\n+ * Sets fields in a #GstCaps.  The arguments must be passed in the same\n+ * manner as gst_structure_id_str_set(), and be %NULL-terminated.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_caps_id_str_set_simple (GstCaps * caps, const GstIdStr * field, ...)\n+{\n+  va_list var_args;\n+\n+  g_return_if_fail (GST_IS_CAPS (caps));\n+  g_return_if_fail (IS_WRITABLE (caps));\n+\n+  va_start (var_args, field);\n+  gst_caps_id_str_set_simple_valist (caps, field, var_args);\n+  va_end (var_args);\n+}\n+\n@@ -1182,0 +1505,27 @@\n+\/**\n+ * gst_caps_set_simple_static_str:\n+ * @caps: the #GstCaps to set\n+ * @field: first field to set\n+ * @...: additional parameters\n+ *\n+ * Sets fields in a #GstCaps.  The arguments must be passed in the same\n+ * manner as gst_structure_set(), and be %NULL-terminated.\n+ *\n+ * @field and all other field names need to be valid for the remaining lifetime\n+ * of the process, e.g. have to be static strings.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_caps_set_simple_static_str (GstCaps * caps, const char *field, ...)\n+{\n+  va_list var_args;\n+\n+  g_return_if_fail (GST_IS_CAPS (caps));\n+  g_return_if_fail (IS_WRITABLE (caps));\n+\n+  va_start (var_args, field);\n+  gst_caps_set_simple_static_str_valist (caps, field, var_args);\n+  va_end (var_args);\n+}\n+\n@@ -1220,1 +1570,1 @@\n-gst_caps_is_fixed_foreach (GQuark field_id, const GValue * value,\n+gst_caps_is_fixed_foreach (const GstIdStr * field, const GValue * value,\n@@ -1257,1 +1607,2 @@\n-  return gst_structure_foreach (structure, gst_caps_is_fixed_foreach, NULL);\n+  return gst_structure_foreach_id_str (structure, gst_caps_is_fixed_foreach,\n+      NULL);\n@@ -1813,1 +2164,1 @@\n-gst_caps_structure_subtract_field (GQuark field_id, const GValue * value,\n+gst_caps_structure_subtract_field (const GstIdStr * field, const GValue * value,\n@@ -1821,1 +2172,1 @@\n-  other = gst_structure_id_get_value (e->subtract_from, field_id);\n+  other = gst_structure_id_str_get_value (e->subtract_from, field);\n@@ -1835,1 +2186,1 @@\n-    gst_structure_id_take_value (structure, field_id, &subtraction);\n+    gst_structure_id_str_take_value (structure, field, &subtraction);\n@@ -1850,1 +2201,1 @@\n-  ret = gst_structure_foreach ((GstStructure *) subtrahend,\n+  ret = gst_structure_foreach_id_str ((GstStructure *) subtrahend,\n@@ -1930,1 +2281,1 @@\n-      if (gst_structure_get_name_id (min) == gst_structure_get_name_id (sub) &&\n+      if (gst_structure_has_name (min, gst_structure_get_name (sub)) &&\n@@ -1975,1 +2326,2 @@\n-gst_caps_normalize_foreach (GQuark field_id, const GValue * value, gpointer ptr)\n+gst_caps_normalize_foreach (const GstIdStr * field, const GValue * value,\n+    gpointer ptr)\n@@ -1988,1 +2340,1 @@\n-      gst_structure_id_set_value (structure, field_id, v);\n+      gst_structure_id_str_set_value (structure, field, v);\n@@ -1994,1 +2346,1 @@\n-    gst_structure_id_take_value (nf->structure, field_id, &val);\n+    gst_structure_id_str_take_value (nf->structure, field, &val);\n@@ -2033,1 +2385,1 @@\n-    while (!gst_structure_foreach (nf.structure,\n+    while (!gst_structure_foreach_id_str (nf.structure,\n@@ -2060,1 +2412,1 @@\n-  GQuark name;\n+  GstIdStr name;\n@@ -2066,2 +2418,2 @@\n-gst_caps_structure_figure_out_union (GQuark field_id, const GValue * value,\n-    gpointer user_data)\n+gst_caps_structure_figure_out_union (const GstIdStr * field,\n+    const GValue * value, gpointer user_data)\n@@ -2070,1 +2422,1 @@\n-  const GValue *val = gst_structure_id_get_value (u->compare, field_id);\n+  const GValue *val = gst_structure_id_str_get_value (u->compare, field);\n@@ -2073,1 +2425,1 @@\n-    if (u->name)\n+    if (G_VALUE_TYPE (&u->value) != G_TYPE_INVALID)\n@@ -2081,1 +2433,1 @@\n-  if (u->name) {\n+  if (G_VALUE_TYPE (&u->value) != G_TYPE_INVALID) {\n@@ -2086,1 +2438,1 @@\n-  u->name = field_id;\n+  gst_id_str_copy_into (&u->name, field);\n@@ -2097,1 +2449,1 @@\n-  UnionField field = { 0, {0,}, NULL };\n+  UnionField field = { GST_ID_STR_INIT, G_VALUE_INIT, NULL };\n@@ -2117,1 +2469,1 @@\n-  if (gst_structure_foreach (simplify,\n+  if (gst_structure_foreach_id_str (simplify,\n@@ -2125,1 +2477,1 @@\n-        gst_structure_id_take_value (compare, field.name, &field.value);\n+        gst_structure_id_str_take_value (compare, &field.name, &field.value);\n@@ -2211,2 +2563,1 @@\n-    if (gst_structure_get_name_id (simplify) !=\n-        gst_structure_get_name_id (compare) ||\n+    if (!gst_structure_has_name (simplify, gst_structure_get_name (compare)) ||\n@@ -2222,3 +2573,2 @@\n-      if (gst_structure_get_name_id (simplify) !=\n-          gst_structure_get_name_id (compare) ||\n-          !gst_caps_features_is_equal (simplify_f, compare_f)) {\n+      if (!gst_structure_has_name (simplify, gst_structure_get_name (compare))\n+          || !gst_caps_features_is_equal (simplify_f, compare_f)) {\n@@ -2559,2 +2909,2 @@\n- * @func: (scope call): a function to call for each field\n- * @user_data: (closure): private data\n+ * @func: (scope call) (closure user_data): a function to call for each field\n+ * @user_data: private data\n@@ -2600,2 +2950,2 @@\n- * @func: (scope call): a function to call for each field\n- * @user_data: (closure): private data\n+ * @func: (scope call) (closure user_data): a function to call for each field\n+ * @user_data: private data\n@@ -2648,2 +2998,2 @@\n- * @func: (scope call): a function to call for each field\n- * @user_data: (closure): private data\n+ * @func: (scope call) (closure user_data): a function to call for each field\n+ * @user_data: private data\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstcaps.c","additions":382,"deletions":32,"binary":false,"changes":414,"status":"modified"},{"patch":"@@ -384,0 +384,3 @@\n+GST_API\n+GstCaps *         gst_caps_new_id_str_empty_simple (const GstIdStr *media_type) G_GNUC_WARN_UNUSED_RESULT;\n+\n@@ -387,0 +390,7 @@\n+GST_API\n+GstCaps *         gst_caps_new_static_str_empty_simple (const char    *media_type) G_GNUC_WARN_UNUSED_RESULT;\n+\n+GST_API\n+GstCaps *         gst_caps_new_id_str_simple       (const GstIdStr *media_type,\n+                                                    const GstIdStr *fieldname,\n+                                                    ...) G_GNUC_NULL_TERMINATED G_GNUC_WARN_UNUSED_RESULT;\n@@ -392,0 +402,4 @@\n+GstCaps *         gst_caps_new_static_str_simple   (const char    *media_type,\n+                                                    const char    *fieldname,\n+                                                    ...) G_GNUC_NULL_TERMINATED G_GNUC_WARN_UNUSED_RESULT;\n+GST_API\n@@ -462,0 +476,4 @@\n+GST_API\n+void              gst_caps_id_str_set_value        (GstCaps        *caps,\n+                                                    const GstIdStr *field,\n+                                                    const GValue   *value);\n@@ -467,0 +485,7 @@\n+void              gst_caps_set_value_static_str    (GstCaps       *caps,\n+                                                    const char    *field,\n+                                                    const GValue  *value);\n+GST_API\n+void              gst_caps_id_str_set_simple       (GstCaps        *caps,\n+                                                    const GstIdStr *field, ...) G_GNUC_NULL_TERMINATED;\n+GST_API\n@@ -470,0 +495,7 @@\n+void              gst_caps_set_simple_static_str   (GstCaps       *caps,\n+                                                    const char    *field, ...) G_GNUC_NULL_TERMINATED;\n+GST_API\n+void              gst_caps_id_str_set_simple_valist(GstCaps        *caps,\n+                                                    const GstIdStr *field,\n+                                                    va_list         varargs);\n+GST_API\n@@ -474,0 +506,4 @@\n+void              gst_caps_set_simple_static_str_valist (GstCaps       *caps,\n+                                                         const char    *field,\n+                                                         va_list        varargs);\n+GST_API\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstcaps.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+\/* FIXME: For deprecated GstCapsFeatures API usage *\/\n+#define GLIB_DISABLE_DEPRECATION_WARNINGS\n+\n@@ -56,0 +59,1 @@\n+#include \"gstidstr-private.h\"\n@@ -73,1 +77,1 @@\n-static GQuark _gst_caps_feature_memory_system_memory = 0;\n+static GstIdStr _gst_caps_feature_memory_system_memory = GST_ID_STR_INIT;\n@@ -93,2 +97,0 @@\n-  _gst_caps_feature_memory_system_memory =\n-      g_quark_from_static_string (GST_CAPS_FEATURE_MEMORY_SYSTEM_MEMORY);\n@@ -102,0 +104,2 @@\n+  gst_id_str_set_static_str (&_gst_caps_feature_memory_system_memory,\n+      GST_CAPS_FEATURE_MEMORY_SYSTEM_MEMORY);\n@@ -103,1 +107,2 @@\n-      gst_caps_features_new_id (_gst_caps_feature_memory_system_memory, 0);\n+      gst_caps_features_new_id_str (&_gst_caps_feature_memory_system_memory,\n+      NULL);\n@@ -119,0 +124,1 @@\n+  gst_id_str_clear (&_gst_caps_feature_memory_system_memory);\n@@ -186,1 +192,2 @@\n-  features->array = g_array_new (FALSE, FALSE, sizeof (GQuark));\n+  features->array = g_array_new (FALSE, FALSE, sizeof (GstIdStr));\n+  g_array_set_clear_func (features->array, (GDestroyNotify) gst_id_str_clear);\n@@ -237,0 +244,24 @@\n+\/**\n+ * gst_caps_features_new_single_static_str:\n+ * @feature: The feature\n+ *\n+ * Creates a new #GstCapsFeatures with a single feature.\n+ *\n+ * @feature needs to be valid for the remaining lifetime of the process, e.g. has\n+ * to be a static string.\n+ *\n+ * Returns: (transfer full): a new #GstCapsFeatures\n+ *\n+ * Since: 1.26\n+ *\/\n+GstCapsFeatures *\n+gst_caps_features_new_single_static_str (const gchar * feature)\n+{\n+  GstCapsFeatures *features;\n+  g_return_val_if_fail (feature != NULL, NULL);\n+\n+  features = gst_caps_features_new_empty ();\n+  gst_caps_features_add_static_str (features, feature);\n+  return features;\n+}\n+\n@@ -292,0 +323,62 @@\n+\/**\n+ * gst_caps_features_new_static_str:\n+ * @feature1: name of first feature to set\n+ * @...: additional features\n+ *\n+ * Creates a new #GstCapsFeatures with the given features.\n+ * The last argument must be %NULL.\n+ *\n+ * @feature1 and all other features need to be valid for the remaining lifetime\n+ * of the process, e.g. have to be a static string.\n+ *\n+ * Returns: (transfer full): a new, empty #GstCapsFeatures\n+ *\n+ * Since: 1.26\n+ *\/\n+GstCapsFeatures *\n+gst_caps_features_new_static_str (const gchar * feature1, ...)\n+{\n+  GstCapsFeatures *features;\n+  va_list varargs;\n+\n+  g_return_val_if_fail (feature1 != NULL, NULL);\n+\n+  va_start (varargs, feature1);\n+  features = gst_caps_features_new_static_str_valist (feature1, varargs);\n+  va_end (varargs);\n+\n+  return features;\n+}\n+\n+\/**\n+ * gst_caps_features_new_static_str_valist:\n+ * @feature1: name of first feature to set\n+ * @varargs: variable argument list\n+ *\n+ * Creates a new #GstCapsFeatures with the given features.\n+ *\n+ * @feature1 and all other features need to be valid for the remaining lifetime\n+ * of the process, e.g. have to be a static string.\n+ *\n+ * Returns: (transfer full): a new, empty #GstCapsFeatures\n+ *\n+ * Since: 1.26\n+ *\/\n+GstCapsFeatures *\n+gst_caps_features_new_static_str_valist (const gchar * feature1,\n+    va_list varargs)\n+{\n+  GstCapsFeatures *features;\n+\n+  g_return_val_if_fail (feature1 != NULL, NULL);\n+\n+  features = gst_caps_features_new_empty ();\n+\n+  while (feature1) {\n+    gst_caps_features_add_static_str (features, feature1);\n+    feature1 = va_arg (varargs, const gchar *);\n+  }\n+\n+  return features;\n+}\n+\n@@ -303,0 +396,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_caps_features_new_id_str().\n@@ -313,0 +408,1 @@\n+  G_GNUC_BEGIN_IGNORE_DEPRECATIONS;\n@@ -314,0 +410,1 @@\n+  G_GNUC_END_IGNORE_DEPRECATIONS;\n@@ -329,0 +426,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_caps_features_new_id_str_valist().\n@@ -340,0 +439,1 @@\n+    G_GNUC_BEGIN_IGNORE_DEPRECATIONS;\n@@ -341,0 +441,1 @@\n+    G_GNUC_END_IGNORE_DEPRECATIONS;\n@@ -347,0 +448,55 @@\n+\/**\n+ * gst_caps_features_new_id_str:\n+ * @feature1: name of first feature to set\n+ * @...: additional features\n+ *\n+ * Creates a new #GstCapsFeatures with the given features.\n+ * The last argument must be 0.\n+ *\n+ * Returns: (transfer full): a new, empty #GstCapsFeatures\n+ *\n+ * Since: 1.26\n+ *\/\n+GstCapsFeatures *\n+gst_caps_features_new_id_str (const GstIdStr * feature1, ...)\n+{\n+  GstCapsFeatures *features;\n+  va_list varargs;\n+\n+  g_return_val_if_fail (feature1 != NULL, NULL);\n+\n+  va_start (varargs, feature1);\n+  features = gst_caps_features_new_id_str_valist (feature1, varargs);\n+  va_end (varargs);\n+\n+  return features;\n+}\n+\n+\/**\n+ * gst_caps_features_new_id_str_valist:\n+ * @feature1: name of first feature to set\n+ * @varargs: variable argument list\n+ *\n+ * Creates a new #GstCapsFeatures with the given features.\n+ *\n+ * Returns: (transfer full): a new, empty #GstCapsFeatures\n+ *\n+ * Since: 1.26\n+ *\/\n+GstCapsFeatures *\n+gst_caps_features_new_id_str_valist (const GstIdStr * feature1, va_list varargs)\n+{\n+  GstCapsFeatures *features;\n+\n+  g_return_val_if_fail (feature1 != NULL, NULL);\n+\n+  features = gst_caps_features_new_empty ();\n+\n+  while (feature1) {\n+    gst_caps_features_add_id_str (features, feature1);\n+    feature1 = va_arg (varargs, const GstIdStr *);\n+  }\n+\n+  return features;\n+}\n+\n@@ -407,1 +563,2 @@\n-    gst_caps_features_add_id (copy, gst_caps_features_get_nth_id (features, i));\n+    gst_caps_features_add_id_str (copy,\n+        gst_caps_features_get_nth_id_str (features, i));\n@@ -484,1 +641,1 @@\n-    GQuark *quark = &g_array_index (features->array, GQuark, i);\n+    const GstIdStr *feature = &g_array_index (features->array, GstIdStr, i);\n@@ -486,1 +643,1 @@\n-    g_string_append (s, g_quark_to_string (*quark));\n+    g_string_append (s, gst_id_str_as_str (feature));\n@@ -614,1 +771,1 @@\n-  GQuark quark;\n+  const GstIdStr *feature_str;\n@@ -618,2 +775,2 @@\n-  quark = gst_caps_features_get_nth_id (features, i);\n-  if (!quark)\n+  feature_str = gst_caps_features_get_nth_id_str (features, i);\n+  if (!feature_str)\n@@ -622,1 +779,1 @@\n-  feature = g_quark_to_string (quark);\n+  feature = gst_id_str_as_str (feature_str);\n@@ -636,0 +793,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_caps_features_get_nth_id_str().\n@@ -640,1 +799,2 @@\n-  GQuark *quark;\n+  GQuark quark;\n+  const GstIdStr *feature_str;\n@@ -645,1 +805,1 @@\n-  quark = &g_array_index (features->array, GQuark, i);\n+  feature_str = gst_caps_features_get_nth_id_str (features, i);\n@@ -647,1 +807,26 @@\n-  return *quark;\n+  quark = g_quark_from_string (gst_id_str_as_str (feature_str));\n+  return quark;\n+}\n+\n+\/**\n+ * gst_caps_features_get_nth_id_str:\n+ * @features: a #GstCapsFeatures.\n+ * @i: index of the feature\n+ *\n+ * Returns the @i-th feature of @features.\n+ *\n+ * Returns: The @i-th feature of @features.\n+ *\n+ * Since: 1.26\n+ *\/\n+const GstIdStr *\n+gst_caps_features_get_nth_id_str (const GstCapsFeatures * features, guint i)\n+{\n+  const GstIdStr *feature;\n+\n+  g_return_val_if_fail (features != NULL, 0);\n+  g_return_val_if_fail (i < features->array->len, 0);\n+\n+  feature = &g_array_index (features->array, GstIdStr, i);\n+\n+  return feature;\n@@ -665,0 +850,3 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n+  gboolean res;\n+\n@@ -668,2 +856,6 @@\n-  return gst_caps_features_contains_id (features,\n-      g_quark_from_string (feature));\n+  \/\/ Not technically correct but the string is never leaving this scope and is never copied\n+  gst_id_str_set_static_str (&s, feature);\n+  res = gst_caps_features_contains_id_str (features, &s);\n+  gst_id_str_clear (&s);\n+\n+  return res;\n@@ -682,0 +874,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_caps_features_contains_id_str().\n@@ -686,1 +880,1 @@\n-  guint i, n;\n+  GstIdStr s = GST_ID_STR_INIT;\n@@ -691,0 +885,25 @@\n+  gst_id_str_set_static_str (&s, g_quark_to_string (feature));\n+\n+  return gst_caps_features_contains_id_str (features, &s);\n+}\n+\n+\/**\n+ * gst_caps_features_contains_id_str:\n+ * @features: a #GstCapsFeatures.\n+ * @feature: a feature\n+ *\n+ * Checks if @features contains @feature.\n+ *\n+ * Returns: %TRUE if @features contains @feature.\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_caps_features_contains_id_str (const GstCapsFeatures * features,\n+    const GstIdStr * feature)\n+{\n+  guint i, n;\n+\n+  g_return_val_if_fail (features != NULL, FALSE);\n+  g_return_val_if_fail (feature != NULL, FALSE);\n+\n@@ -695,2 +914,4 @@\n-  if (n == 0)\n-    return feature == _gst_caps_feature_memory_system_memory;\n+  if (n == 0) {\n+    return gst_id_str_is_equal (feature,\n+        &_gst_caps_feature_memory_system_memory);\n+  }\n@@ -699,1 +920,2 @@\n-    if (gst_caps_features_get_nth_id (features, i) == feature)\n+    if (gst_id_str_is_equal (gst_caps_features_get_nth_id_str (features, i),\n+            feature))\n@@ -733,2 +955,2 @@\n-      && gst_caps_features_contains_id (features2,\n-          _gst_caps_feature_memory_system_memory))\n+      && gst_caps_features_contains_id_str (features2,\n+          &_gst_caps_feature_memory_system_memory))\n@@ -737,2 +959,2 @@\n-      && gst_caps_features_contains_id (features1,\n-          _gst_caps_feature_memory_system_memory))\n+      && gst_caps_features_contains_id_str (features1,\n+          &_gst_caps_feature_memory_system_memory))\n@@ -746,2 +968,2 @@\n-    if (!gst_caps_features_contains_id (features2,\n-            gst_caps_features_get_nth_id (features1, i)))\n+    if (!gst_caps_features_contains_id_str (features2,\n+            gst_caps_features_get_nth_id_str (features1, i)))\n@@ -771,0 +993,24 @@\n+\/\/ Takes ownership of feature\n+static void\n+gst_caps_features_add_id_str_internal (GstCapsFeatures * features,\n+    GstIdStr * feature)\n+{\n+  if (!gst_caps_feature_name_is_valid (gst_id_str_as_str (feature))) {\n+    g_warning (\"Invalid caps feature name: %s\", gst_id_str_as_str (feature));\n+    gst_id_str_clear (feature);\n+    return;\n+  }\n+\n+  \/* If features is empty it will contain sysmem, however\n+   * we want to add it explicitly if it is attempted to be\n+   * added as first features\n+   *\/\n+  if (features->array->len > 0\n+      && gst_caps_features_contains_id_str (features, feature)) {\n+    gst_id_str_clear (feature);\n+    return;\n+  }\n+\n+  g_array_append_val (features->array, *feature);\n+}\n+\n@@ -783,0 +1029,2 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n@@ -788,1 +1036,31 @@\n-  gst_caps_features_add_id (features, g_quark_from_string (feature));\n+  gst_id_str_set (&s, feature);\n+\n+  gst_caps_features_add_id_str_internal (features, &s);\n+}\n+\n+\/**\n+ * gst_caps_features_add_static_str:\n+ * @features: a #GstCapsFeatures.\n+ * @feature: a feature.\n+ *\n+ * Adds @feature to @features.\n+ *\n+ * @feature needs to be valid for the remaining lifetime of the process, e.g. has\n+ * to be a static string.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_caps_features_add_static_str (GstCapsFeatures * features,\n+    const gchar * feature)\n+{\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n+  g_return_if_fail (features != NULL);\n+  g_return_if_fail (IS_MUTABLE (features));\n+  g_return_if_fail (feature != NULL);\n+  g_return_if_fail (!features->is_any);\n+\n+  gst_id_str_set_static_str (&s, feature);\n+\n+  gst_caps_features_add_id_str_internal (features, &s);\n@@ -799,0 +1077,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_caps_features_add_id_str().\n@@ -803,0 +1083,2 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n@@ -808,4 +1090,1 @@\n-  if (!gst_caps_feature_name_is_valid (g_quark_to_string (feature))) {\n-    g_warning (\"Invalid caps feature name: %s\", g_quark_to_string (feature));\n-    return;\n-  }\n+  gst_id_str_set_static_str (&s, g_quark_to_string (feature));\n@@ -813,7 +1092,2 @@\n-  \/* If features is empty it will contain sysmem, however\n-   * we want to add it explicitly if it is attempted to be\n-   * added as first features\n-   *\/\n-  if (features->array->len > 0\n-      && gst_caps_features_contains_id (features, feature))\n-    return;\n+  gst_caps_features_add_id_str_internal (features, &s);\n+}\n@@ -821,1 +1095,23 @@\n-  g_array_append_val (features->array, feature);\n+\/**\n+ * gst_caps_features_add_id_str:\n+ * @features: a #GstCapsFeatures.\n+ * @feature: a feature.\n+ *\n+ * Adds @feature to @features.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_caps_features_add_id_str (GstCapsFeatures * features,\n+    const GstIdStr * feature)\n+{\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n+  g_return_if_fail (features != NULL);\n+  g_return_if_fail (IS_MUTABLE (features));\n+  g_return_if_fail (feature != NULL);\n+  g_return_if_fail (!features->is_any);\n+\n+  gst_id_str_copy_into (&s, feature);\n+\n+  gst_caps_features_add_id_str_internal (features, &s);\n@@ -836,0 +1132,2 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n@@ -840,1 +1138,4 @@\n-  gst_caps_features_remove_id (features, g_quark_from_string (feature));\n+  \/\/ Not technically correct but the string is never leaving this scope and is never copied\n+  gst_id_str_set_static_str (&s, feature);\n+  gst_caps_features_remove_id_str (features, &s);\n+  gst_id_str_clear (&s);\n@@ -851,0 +1152,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_caps_features_remove_id_str().\n@@ -855,1 +1158,2 @@\n-  guint i, n;\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n@@ -861,0 +1165,24 @@\n+  gst_id_str_set_static_str (&s, g_quark_to_string (feature));\n+\n+  gst_caps_features_remove_id_str (features, &s);\n+}\n+\n+\/**\n+ * gst_caps_features_remove_id_str:\n+ * @features: a #GstCapsFeatures.\n+ * @feature: a feature.\n+ *\n+ * Removes @feature from @features.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_caps_features_remove_id_str (GstCapsFeatures * features,\n+    const GstIdStr * feature)\n+{\n+  guint i, n;\n+\n+  g_return_if_fail (features != NULL);\n+  g_return_if_fail (IS_MUTABLE (features));\n+  g_return_if_fail (feature != NULL);\n+\n@@ -863,1 +1191,1 @@\n-    GQuark quark = gst_caps_features_get_nth_id (features, i);\n+    const GstIdStr *f = gst_caps_features_get_nth_id_str (features, i);\n@@ -865,1 +1193,1 @@\n-    if (quark == feature) {\n+    if (gst_id_str_is_equal (f, feature)) {\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstcapsfeatures.c","additions":372,"deletions":44,"binary":false,"changes":416,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include <gst\/gstidstr.h>\n@@ -75,0 +76,3 @@\n+GST_API\n+GstCapsFeatures * gst_caps_features_new_single_static_str (const gchar *feature) G_GNUC_MALLOC;\n+\n@@ -78,0 +82,3 @@\n+GST_API\n+GstCapsFeatures * gst_caps_features_new_static_str (const gchar *feature1, ...) G_GNUC_NULL_TERMINATED;\n+\n@@ -82,0 +89,3 @@\n+GstCapsFeatures * gst_caps_features_new_static_str_valist (const gchar *feature1, va_list varargs);\n+\n+GST_DEPRECATED_FOR(gst_caps_features_new_id_str)\n@@ -84,1 +94,1 @@\n-GST_API\n+GST_DEPRECATED_FOR(gst_caps_features_new_id_str_valist)\n@@ -87,0 +97,6 @@\n+GST_API\n+GstCapsFeatures * gst_caps_features_new_id_str (const GstIdStr * feature1, ...);\n+\n+GST_API\n+GstCapsFeatures * gst_caps_features_new_id_str_valist (const GstIdStr * feature1, va_list varargs);\n+\n@@ -108,1 +124,1 @@\n-GST_API\n+GST_DEPRECATED_FOR(gst_caps_features_get_nth_id_str)\n@@ -112,1 +128,1 @@\n-gboolean          gst_caps_features_contains (const GstCapsFeatures * features, const gchar * feature);\n+const GstIdStr *  gst_caps_features_get_nth_id_str (const GstCapsFeatures * features, guint i);\n@@ -115,0 +131,3 @@\n+gboolean          gst_caps_features_contains (const GstCapsFeatures * features, const gchar * feature);\n+\n+GST_DEPRECATED_FOR(gst_caps_features_contains_id_str)\n@@ -117,0 +136,3 @@\n+GST_API\n+gboolean          gst_caps_features_contains_id_str (const GstCapsFeatures * features, const GstIdStr * feature);\n+\n@@ -127,1 +149,4 @@\n-void              gst_caps_features_add_id ( GstCapsFeatures * features, GQuark feature);\n+void              gst_caps_features_add_static_str (GstCapsFeatures * features, const gchar * feature);\n+\n+GST_DEPRECATED_FOR(gst_caps_features_add_id_str)\n+void              gst_caps_features_add_id (GstCapsFeatures * features, GQuark feature);\n@@ -130,1 +155,1 @@\n-void              gst_caps_features_remove (GstCapsFeatures * features, const gchar * feature);\n+void              gst_caps_features_add_id_str (GstCapsFeatures * features, const GstIdStr * feature);\n@@ -133,0 +158,3 @@\n+void              gst_caps_features_remove (GstCapsFeatures * features, const gchar * feature);\n+\n+GST_DEPRECATED_FOR(gst_caps_features_remove_id_str)\n@@ -135,0 +163,3 @@\n+GST_API\n+void              gst_caps_features_remove_id_str (GstCapsFeatures * features, const GstIdStr * feature);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstcapsfeatures.h","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -518,1 +518,1 @@\n- * @jitter: (out) (allow-none): a pointer that will contain the jitter,\n+ * @jitter: (out) (optional): a pointer that will contain the jitter,\n@@ -906,1 +906,1 @@\n- * @clock: (allow-none): a #GstClock to use\n+ * @clock: (nullable): a #GstClock to use\n@@ -999,1 +999,1 @@\n- * @clock: (allow-none): a #GstClock to use\n+ * @clock: (nullable): a #GstClock to use\n@@ -1217,4 +1217,4 @@\n- * @internal: (out) (allow-none): a location to store the internal time\n- * @external: (out) (allow-none): a location to store the external time\n- * @rate_num: (out) (allow-none): a location to store the rate numerator\n- * @rate_denom: (out) (allow-none): a location to store the rate denominator\n+ * @internal: (out) (optional): a location to store the internal time\n+ * @external: (out) (optional): a location to store the external time\n+ * @rate_num: (out) (optional): a location to store the rate numerator\n+ * @rate_denom: (out) (optional): a location to store the rate denominator\n@@ -1285,1 +1285,1 @@\n- * @master: (allow-none): a master #GstClock\n+ * @master: (nullable): a master #GstClock\n@@ -1455,2 +1455,2 @@\n- * @slave: a time on the slave\n- * @master: a time on the master\n+ * @observation_internal: a time on the internal clock\n+ * @observation_external: a time on the external clock\n@@ -1459,4 +1459,4 @@\n- * The time @master of the master clock and the time @slave of the slave\n- * clock are added to the list of observations. If enough observations\n- * are available, a linear regression algorithm is run on the\n- * observations and @clock is recalibrated.\n+ * The time @observation_external of the external or master clock and the time\n+ * @observation_internal of the internal or slave clock are added to the list of\n+ * observations. If enough observations are available, a linear regression\n+ * algorithm is run on the observations and @clock is recalibrated.\n@@ -1474,2 +1474,2 @@\n-gst_clock_add_observation (GstClock * clock, GstClockTime slave,\n-    GstClockTime master, gdouble * r_squared)\n+gst_clock_add_observation (GstClock * clock, GstClockTime observation_internal,\n+    GstClockTime observation_external, gdouble * r_squared)\n@@ -1479,2 +1479,2 @@\n-  if (!gst_clock_add_observation_unapplied (clock, slave, master, r_squared,\n-          &xbase, &b, &m_num, &m_denom))\n+  if (!gst_clock_add_observation_unapplied (clock, observation_internal,\n+          observation_external, r_squared, &xbase, &b, &m_num, &m_denom))\n@@ -1492,2 +1492,2 @@\n- * @slave: a time on the slave\n- * @master: a time on the master\n+ * @observation_internal: a time on the internal clock\n+ * @observation_external: a time on the external clock\n@@ -1495,4 +1495,4 @@\n- * @internal: (out) (allow-none): a location to store the internal time\n- * @external: (out) (allow-none): a location to store the external time\n- * @rate_num: (out) (allow-none): a location to store the rate numerator\n- * @rate_denom: (out) (allow-none): a location to store the rate denominator\n+ * @internal: (out) (optional): a location to store the internal time\n+ * @external: (out) (optional): a location to store the external time\n+ * @rate_num: (out) (optional): a location to store the rate numerator\n+ * @rate_denom: (out) (optional): a location to store the rate denominator\n@@ -1501,2 +1501,2 @@\n- * gst_clock_add_observation(), and return the result of the master clock\n- * estimation, without updating the internal calibration.\n+ * gst_clock_add_observation(), and return the result of the external or master\n+ * clock estimation, without updating the internal calibration.\n@@ -1512,3 +1512,3 @@\n-gst_clock_add_observation_unapplied (GstClock * clock, GstClockTime slave,\n-    GstClockTime master, gdouble * r_squared,\n-    GstClockTime * internal, GstClockTime * external,\n+gst_clock_add_observation_unapplied (GstClock * clock,\n+    GstClockTime internal_observation, GstClockTime external_observation,\n+    gdouble * r_squared, GstClockTime * internal, GstClockTime * external,\n@@ -1522,2 +1522,2 @@\n-  g_return_val_if_fail (GST_CLOCK_TIME_IS_VALID (slave), FALSE);\n-  g_return_val_if_fail (GST_CLOCK_TIME_IS_VALID (master), FALSE);\n+  g_return_val_if_fail (GST_CLOCK_TIME_IS_VALID (internal_observation), FALSE);\n+  g_return_val_if_fail (GST_CLOCK_TIME_IS_VALID (external_observation), FALSE);\n@@ -1531,2 +1531,3 @@\n-      \"adding observation slave %\" GST_TIME_FORMAT \", master %\" GST_TIME_FORMAT,\n-      GST_TIME_ARGS (slave), GST_TIME_ARGS (master));\n+      \"adding observation internal %\" GST_TIME_FORMAT \", external %\"\n+      GST_TIME_FORMAT, GST_TIME_ARGS (internal_observation),\n+      GST_TIME_ARGS (external_observation));\n@@ -1534,2 +1535,2 @@\n-  priv->times[(2 * priv->time_index)] = slave;\n-  priv->times[(2 * priv->time_index) + 1] = master;\n+  priv->times[(2 * priv->time_index)] = internal_observation;\n+  priv->times[(2 * priv->time_index) + 1] = external_observation;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstclock.c","additions":36,"deletions":35,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -613,2 +613,4 @@\n-gboolean                gst_clock_add_observation       (GstClock *clock, GstClockTime slave,\n-                                                         GstClockTime master, gdouble *r_squared);\n+gboolean                gst_clock_add_observation       (GstClock *clock,\n+                                                         GstClockTime observation_internal,\n+                                                         GstClockTime observation_external,\n+                                                         gdouble *r_squared);\n@@ -616,6 +618,8 @@\n-gboolean                gst_clock_add_observation_unapplied (GstClock *clock, GstClockTime slave,\n-                                                         GstClockTime master, gdouble *r_squared,\n-                                                         GstClockTime *internal,\n-                                                         GstClockTime *external,\n-                                                         GstClockTime *rate_num,\n-                                                         GstClockTime *rate_denom);\n+gboolean                gst_clock_add_observation_unapplied (GstClock *clock,\n+                                                             GstClockTime observation_internal,\n+                                                             GstClockTime observation_external,\n+                                                             gdouble *r_squared,\n+                                                             GstClockTime *internal,\n+                                                             GstClockTime *external,\n+                                                             GstClockTime *rate_num,\n+                                                             GstClockTime *rate_denom);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstclock.h","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-#include \"gstquark.h\"\n@@ -178,1 +177,1 @@\n-  structure = gst_structure_new_id_empty (GST_QUARK (CONTEXT));\n+  structure = gst_structure_new_static_str_empty (\"context\");\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstcontext.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -210,0 +210,1 @@\n+      \/* G_PARAM_CONSTRUCT_ONLY *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstcontrolbinding.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"gstidstr-private.h\"\n@@ -379,1 +380,1 @@\n-string_append_field (GQuark field, const GValue * value, gpointer ptr)\n+string_append_field (const GstIdStr * field, const GValue * value, gpointer ptr)\n@@ -386,1 +387,1 @@\n-    g_string_append_printf (str, \"  %18s: NULL\\\\l\", g_quark_to_string (field));\n+    g_string_append_printf (str, \"  %18s: NULL\\\\l\", gst_id_str_as_str (field));\n@@ -417,1 +418,1 @@\n-  g_string_append_printf (str, \"  %18s: %s\\\\l\", g_quark_to_string (field),\n+  g_string_append_printf (str, \"  %18s: %s\\\\l\", gst_id_str_as_str (field),\n@@ -461,1 +462,2 @@\n-        gst_structure_foreach (structure, string_append_field, (gpointer) str);\n+        gst_structure_foreach_id_str (structure, string_append_field,\n+            (gpointer) str);\n@@ -855,1 +857,0 @@\n-  FILE *out;\n@@ -871,2 +872,2 @@\n-  if ((out = fopen (full_file_name, \"wb\"))) {\n-    gchar *buf;\n+  GError *err = NULL;\n+  gchar *buf;\n@@ -874,2 +875,4 @@\n-    buf = gst_debug_bin_to_dot_data (bin, details);\n-    fputs (buf, out);\n+  buf = gst_debug_bin_to_dot_data (bin, details);\n+  if (!g_file_set_contents (full_file_name, buf, -1, &err)) {\n+    GST_WARNING (\"Failed to write file '%s' for writing: %s\", full_file_name,\n+        err->message);\n@@ -877,7 +880,0 @@\n-    g_free (buf);\n-    fclose (out);\n-\n-    GST_INFO (\"wrote bin graph to : '%s'\", full_file_name);\n-  } else {\n-    GST_WARNING (\"Failed to open file '%s' for writing: %s\", full_file_name,\n-        g_strerror (errno));\n@@ -885,0 +881,2 @@\n+  g_clear_error (&err);\n+  g_free (buf);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstdebugutils.c","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+#ifndef GST_DISABLE_DEPRECATED\n@@ -94,0 +95,3 @@\n+#endif\n+#define GST_DYNAMIC_TYPE_FACTORY_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DYNAMIC_TYPE_FACTORY,\\\n+                                                 GstDynamicTypeFactoryClass))\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstdynamictypefactory.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n-#include \"gstquark.h\"\n@@ -1429,2 +1428,2 @@\n- * @func: (scope call): function to call for each sink pad\n- * @user_data: (closure): user data passed to @func\n+ * @func: (scope call) (closure user_data): function to call for each sink pad\n+ * @user_data: user data passed to @func\n@@ -1455,2 +1454,2 @@\n- * @func: (scope call): function to call for each source pad\n- * @user_data: (closure): user data passed to @func\n+ * @func: (scope call) (closure user_data): function to call for each source pad\n+ * @user_data: user data passed to @func\n@@ -1481,2 +1480,2 @@\n- * @func: (scope call): function to call for each pad\n- * @user_data: (closure): user data passed to @func\n+ * @func: (scope call) (closure user_data): function to call for each pad\n+ * @user_data: user data passed to @func\n@@ -1533,1 +1532,0 @@\n-      gst_object_ref_sink (padtempl);\n@@ -1535,0 +1533,1 @@\n+      gst_object_ref_sink (templ);\n@@ -1664,5 +1663,5 @@\n-  gst_structure_id_set ((GstStructure *) klass->metadata,\n-      GST_QUARK (ELEMENT_METADATA_LONGNAME), G_TYPE_STRING, longname,\n-      GST_QUARK (ELEMENT_METADATA_KLASS), G_TYPE_STRING, classification,\n-      GST_QUARK (ELEMENT_METADATA_DESCRIPTION), G_TYPE_STRING, description,\n-      GST_QUARK (ELEMENT_METADATA_AUTHOR), G_TYPE_STRING, author, NULL);\n+  gst_structure_set_static_str ((GstStructure *) klass->metadata,\n+      GST_ELEMENT_METADATA_LONGNAME, G_TYPE_STRING, longname,\n+      GST_ELEMENT_METADATA_KLASS, G_TYPE_STRING, classification,\n+      GST_ELEMENT_METADATA_DESCRIPTION, G_TYPE_STRING, description,\n+      GST_ELEMENT_METADATA_AUTHOR, G_TYPE_STRING, author, NULL);\n@@ -1709,1 +1708,1 @@\n-  gst_structure_id_set_value (s, GST_QUARK (ELEMENT_METADATA_LONGNAME), &val);\n+  gst_structure_set_value_static_str (s, GST_ELEMENT_METADATA_LONGNAME, &val);\n@@ -1712,1 +1711,1 @@\n-  gst_structure_id_set_value (s, GST_QUARK (ELEMENT_METADATA_KLASS), &val);\n+  gst_structure_set_value_static_str (s, GST_ELEMENT_METADATA_KLASS, &val);\n@@ -1715,1 +1714,1 @@\n-  gst_structure_id_set_value (s, GST_QUARK (ELEMENT_METADATA_DESCRIPTION),\n+  gst_structure_set_value_static_str (s, GST_ELEMENT_METADATA_DESCRIPTION,\n@@ -1719,1 +1718,1 @@\n-  gst_structure_id_take_value (s, GST_QUARK (ELEMENT_METADATA_AUTHOR), &val);\n+  gst_structure_take_value_static_str (s, GST_ELEMENT_METADATA_AUTHOR, &val);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstelement.c","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-#include \"gstquark.h\"\n@@ -408,2 +407,2 @@\n-        gst_structure_new_id_empty (gst_event_type_to_quark (GST_EVENT_TYPE\n-            (event)));\n+        gst_structure_new_static_str_empty (gst_event_type_get_name\n+        (GST_EVENT_TYPE (event)));\n@@ -448,0 +447,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_event_has_name().\n@@ -452,6 +453,1 @@\n-  g_return_val_if_fail (GST_IS_EVENT (event), FALSE);\n-\n-  if (GST_EVENT_STRUCTURE (event) == NULL)\n-    return FALSE;\n-\n-  return (GST_EVENT_STRUCTURE (event)->name == name);\n+  return gst_event_has_name (event, g_quark_to_string (name));\n@@ -612,2 +608,2 @@\n-      gst_structure_new_id (GST_QUARK (EVENT_FLUSH_STOP),\n-          GST_QUARK (RESET_TIME), G_TYPE_BOOLEAN, reset_time, NULL));\n+      gst_structure_new_static_str (\"GstEventFlushStop\",\n+          \"reset-time\", G_TYPE_BOOLEAN, reset_time, NULL));\n@@ -636,2 +632,1 @@\n-        g_value_get_boolean (gst_structure_id_get_value (structure,\n-            GST_QUARK (RESET_TIME)));\n+        g_value_get_boolean (gst_structure_get_value (structure, \"reset-time\"));\n@@ -671,1 +666,1 @@\n-  struc = gst_structure_new_id_empty (GST_QUARK (EVENT_SELECT_STREAMS));\n+  struc = gst_structure_new_static_str_empty (\"GstEventSelectStreams\");\n@@ -681,1 +676,1 @@\n-  gst_structure_id_take_value (struc, GST_QUARK (STREAMS), &val);\n+  gst_structure_take_value (struc, \"streams\", &val);\n@@ -707,2 +702,1 @@\n-    const GValue *vlist =\n-        gst_structure_id_get_value (structure, GST_QUARK (STREAMS));\n+    const GValue *vlist = gst_structure_get_value (structure, \"streams\");\n@@ -744,2 +738,2 @@\n-  s = gst_structure_new_id (GST_QUARK (EVENT_STREAM_GROUP_DONE),\n-      GST_QUARK (GROUP_ID), G_TYPE_UINT, group_id, NULL);\n+  s = gst_structure_new_static_str (\"GstEventStreamGroupDone\",\n+      \"group-id\", G_TYPE_UINT, group_id, NULL);\n@@ -767,2 +761,2 @@\n-    gst_structure_id_get (GST_EVENT_STRUCTURE (event),\n-        GST_QUARK (GROUP_ID), G_TYPE_UINT, group_id, NULL);\n+    gst_structure_get (GST_EVENT_STRUCTURE (event),\n+        \"group-id\", G_TYPE_UINT, group_id, NULL);\n@@ -823,3 +817,3 @@\n-      gst_structure_new_id (GST_QUARK (EVENT_GAP),\n-          GST_QUARK (TIMESTAMP), GST_TYPE_CLOCK_TIME, timestamp,\n-          GST_QUARK (DURATION), GST_TYPE_CLOCK_TIME, duration, NULL));\n+      gst_structure_new_static_str (\"GstEventGap\",\n+          \"timestamp\", GST_TYPE_CLOCK_TIME, timestamp,\n+          \"duration\", GST_TYPE_CLOCK_TIME, duration, NULL));\n@@ -850,3 +844,3 @@\n-  gst_structure_id_get (structure,\n-      GST_QUARK (TIMESTAMP), GST_TYPE_CLOCK_TIME, timestamp,\n-      GST_QUARK (DURATION), GST_TYPE_CLOCK_TIME, duration, NULL);\n+  gst_structure_get (structure,\n+      \"timestamp\", GST_TYPE_CLOCK_TIME, timestamp,\n+      \"duration\", GST_TYPE_CLOCK_TIME, duration, NULL);\n@@ -873,2 +867,2 @@\n-  gst_structure_id_set (GST_EVENT_STRUCTURE (event),\n-      GST_QUARK (GAP_FLAGS), GST_TYPE_GAP_FLAGS, flags, NULL);\n+  gst_structure_set (GST_EVENT_STRUCTURE (event),\n+      \"gap-flags\", GST_TYPE_GAP_FLAGS, flags, NULL);\n@@ -897,2 +891,2 @@\n-  gst_structure_id_get (GST_EVENT_STRUCTURE (event),\n-      GST_QUARK (GAP_FLAGS), GST_TYPE_GAP_FLAGS, flags, NULL);\n+  gst_structure_get (GST_EVENT_STRUCTURE (event),\n+      \"gap-flags\", GST_TYPE_GAP_FLAGS, flags, NULL);\n@@ -923,2 +917,2 @@\n-      gst_structure_new_id (GST_QUARK (EVENT_CAPS),\n-          GST_QUARK (CAPS), GST_TYPE_CAPS, caps, NULL));\n+      gst_structure_new_static_str (\"GstEventCaps\", \"caps\", GST_TYPE_CAPS, caps,\n+          NULL));\n@@ -947,3 +941,1 @@\n-    *caps =\n-        g_value_get_boxed (gst_structure_id_get_value (structure,\n-            GST_QUARK (CAPS)));\n+    *caps = g_value_get_boxed (gst_structure_get_value (structure, \"caps\"));\n@@ -1004,2 +996,2 @@\n-      gst_structure_new_id (GST_QUARK (EVENT_SEGMENT),\n-          GST_QUARK (SEGMENT), GST_TYPE_SEGMENT, segment, NULL));\n+      gst_structure_new_static_str (\"GstEventSegment\",\n+          \"segment\", GST_TYPE_SEGMENT, segment, NULL));\n@@ -1029,2 +1021,2 @@\n-    *segment = g_value_get_boxed (gst_structure_id_get_value (structure,\n-            GST_QUARK (SEGMENT)));\n+    *segment = g_value_get_boxed (gst_structure_get_value (structure,\n+            \"segment\"));\n@@ -1080,1 +1072,2 @@\n-  s = gst_structure_new_empty (names[gst_tag_list_get_scope (taglist)]);\n+  s = gst_structure_new_static_str_empty (names[gst_tag_list_get_scope\n+          (taglist)]);\n@@ -1083,1 +1076,1 @@\n-  gst_structure_id_take_value (s, GST_QUARK (TAGLIST), &val);\n+  gst_structure_take_value (s, \"taglist\", &val);\n@@ -1105,2 +1098,1 @@\n-  val = gst_structure_id_get_value (GST_EVENT_STRUCTURE (event),\n-      GST_QUARK (TAGLIST));\n+  val = gst_structure_get_value (GST_EVENT_STRUCTURE (event), \"taglist\");\n@@ -1139,5 +1131,4 @@\n-  structure = gst_structure_new_id (GST_QUARK (EVENT_BUFFER_SIZE),\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (MINSIZE), G_TYPE_INT64, minsize,\n-      GST_QUARK (MAXSIZE), G_TYPE_INT64, maxsize,\n-      GST_QUARK (ASYNC), G_TYPE_BOOLEAN, async, NULL);\n+  structure = gst_structure_new_static_str (\"GstEventBufferSize\",\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"minsize\", G_TYPE_INT64, minsize,\n+      \"maxsize\", G_TYPE_INT64, maxsize, \"async\", G_TYPE_BOOLEAN, async, NULL);\n@@ -1171,2 +1162,1 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (FORMAT)));\n+        g_value_get_enum (gst_structure_get_value (structure, \"format\"));\n@@ -1175,2 +1165,1 @@\n-        g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (MINSIZE)));\n+        g_value_get_int64 (gst_structure_get_value (structure, \"minsize\"));\n@@ -1179,2 +1168,1 @@\n-        g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (MAXSIZE)));\n+        g_value_get_int64 (gst_structure_get_value (structure, \"maxsize\"));\n@@ -1182,3 +1170,1 @@\n-    *async =\n-        g_value_get_boolean (gst_structure_id_get_value (structure,\n-            GST_QUARK (ASYNC)));\n+    *async = g_value_get_boolean (gst_structure_get_value (structure, \"async\"));\n@@ -1254,5 +1240,4 @@\n-  structure = gst_structure_new_id (GST_QUARK (EVENT_QOS),\n-      GST_QUARK (TYPE), GST_TYPE_QOS_TYPE, type,\n-      GST_QUARK (PROPORTION), G_TYPE_DOUBLE, proportion,\n-      GST_QUARK (DIFF), G_TYPE_INT64, diff,\n-      GST_QUARK (TIMESTAMP), G_TYPE_UINT64, timestamp, NULL);\n+  structure = gst_structure_new_static_str (\"GstEventQOS\",\n+      \"type\", GST_TYPE_QOS_TYPE, type,\n+      \"proportion\", G_TYPE_DOUBLE, proportion,\n+      \"diff\", G_TYPE_INT64, diff, \"timestamp\", G_TYPE_UINT64, timestamp, NULL);\n@@ -1289,2 +1274,1 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (TYPE)));\n+        g_value_get_enum (gst_structure_get_value (structure, \"type\"));\n@@ -1293,2 +1277,1 @@\n-        g_value_get_double (gst_structure_id_get_value (structure,\n-            GST_QUARK (PROPORTION)));\n+        g_value_get_double (gst_structure_get_value (structure, \"proportion\"));\n@@ -1296,3 +1279,1 @@\n-    *diff =\n-        g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (DIFF)));\n+    *diff = g_value_get_int64 (gst_structure_get_value (structure, \"diff\"));\n@@ -1302,2 +1283,2 @@\n-        g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (DIFF)));\n+        g_value_get_int64 (gst_structure_get_value (structure,\n+            \"diff\"));\n@@ -1306,2 +1287,1 @@\n-        g_value_get_uint64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (TIMESTAMP)));\n+        g_value_get_uint64 (gst_structure_get_value (structure, \"timestamp\"));\n@@ -1406,10 +1386,9 @@\n-  structure = gst_structure_new_id (GST_QUARK (EVENT_SEEK),\n-      GST_QUARK (RATE), G_TYPE_DOUBLE, rate,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (FLAGS), GST_TYPE_SEEK_FLAGS, flags,\n-      GST_QUARK (CUR_TYPE), GST_TYPE_SEEK_TYPE, start_type,\n-      GST_QUARK (CUR), G_TYPE_INT64, start,\n-      GST_QUARK (STOP_TYPE), GST_TYPE_SEEK_TYPE, stop_type,\n-      GST_QUARK (STOP), G_TYPE_INT64, stop,\n-      GST_QUARK (TRICKMODE_INTERVAL), GST_TYPE_CLOCK_TIME, (GstClockTime) 0,\n-      NULL);\n+  structure = gst_structure_new_static_str (\"GstEventSeek\",\n+      \"rate\", G_TYPE_DOUBLE, rate,\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"flags\", GST_TYPE_SEEK_FLAGS, flags,\n+      \"cur-type\", GST_TYPE_SEEK_TYPE, start_type,\n+      \"cur\", G_TYPE_INT64, start,\n+      \"stop-type\", GST_TYPE_SEEK_TYPE, stop_type,\n+      \"stop\", G_TYPE_INT64, stop,\n+      \"trickmode-interval\", GST_TYPE_CLOCK_TIME, (GstClockTime) 0, NULL);\n@@ -1446,3 +1425,1 @@\n-    *rate =\n-        g_value_get_double (gst_structure_id_get_value (structure,\n-            GST_QUARK (RATE)));\n+    *rate = g_value_get_double (gst_structure_get_value (structure, \"rate\"));\n@@ -1451,2 +1428,1 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (FORMAT)));\n+        g_value_get_enum (gst_structure_get_value (structure, \"format\"));\n@@ -1455,2 +1431,1 @@\n-        g_value_get_flags (gst_structure_id_get_value (structure,\n-            GST_QUARK (FLAGS)));\n+        g_value_get_flags (gst_structure_get_value (structure, \"flags\"));\n@@ -1459,2 +1434,1 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (CUR_TYPE)));\n+        g_value_get_enum (gst_structure_get_value (structure, \"cur-type\"));\n@@ -1462,3 +1436,1 @@\n-    *start =\n-        g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (CUR)));\n+    *start = g_value_get_int64 (gst_structure_get_value (structure, \"cur\"));\n@@ -1467,2 +1439,1 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (STOP_TYPE)));\n+        g_value_get_enum (gst_structure_get_value (structure, \"stop-type\"));\n@@ -1470,3 +1441,1 @@\n-    *stop =\n-        g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (STOP)));\n+    *stop = g_value_get_int64 (gst_structure_get_value (structure, \"stop\"));\n@@ -1492,2 +1461,2 @@\n-  gst_structure_id_set (GST_EVENT_STRUCTURE (event),\n-      GST_QUARK (TRICKMODE_INTERVAL), GST_TYPE_CLOCK_TIME, interval, NULL);\n+  gst_structure_set_static_str (GST_EVENT_STRUCTURE (event),\n+      \"trickmode-interval\", GST_TYPE_CLOCK_TIME, interval, NULL);\n@@ -1516,2 +1485,2 @@\n-  gst_structure_id_get (GST_EVENT_STRUCTURE (event),\n-      GST_QUARK (TRICKMODE_INTERVAL), GST_TYPE_CLOCK_TIME, interval, NULL);\n+  gst_structure_get (GST_EVENT_STRUCTURE (event),\n+      \"trickmode-interval\", GST_TYPE_CLOCK_TIME, interval, NULL);\n@@ -1562,2 +1531,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (EVENT_LATENCY),\n-      GST_QUARK (LATENCY), G_TYPE_UINT64, latency, NULL);\n+  structure = gst_structure_new_static_str (\"GstEventLatency\",\n+      \"latency\", G_TYPE_UINT64, latency, NULL);\n@@ -1584,2 +1553,2 @@\n-        g_value_get_uint64 (gst_structure_id_get_value (GST_EVENT_STRUCTURE\n-            (event), GST_QUARK (LATENCY)));\n+        g_value_get_uint64 (gst_structure_get_value (GST_EVENT_STRUCTURE\n+            (event), \"latency\"));\n@@ -1623,6 +1592,6 @@\n-  structure = gst_structure_new_id (GST_QUARK (EVENT_STEP),\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (AMOUNT), G_TYPE_UINT64, amount,\n-      GST_QUARK (RATE), G_TYPE_DOUBLE, rate,\n-      GST_QUARK (FLUSH), G_TYPE_BOOLEAN, flush,\n-      GST_QUARK (INTERMEDIATE), G_TYPE_BOOLEAN, intermediate, NULL);\n+  structure = gst_structure_new_static_str (\"GstEventStep\",\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"amount\", G_TYPE_UINT64, amount,\n+      \"rate\", G_TYPE_DOUBLE, rate,\n+      \"flush\", G_TYPE_BOOLEAN, flush,\n+      \"intermediate\", G_TYPE_BOOLEAN, intermediate, NULL);\n@@ -1658,2 +1627,2 @@\n-        (GstFormat) g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (FORMAT)));\n+        (GstFormat) g_value_get_enum (gst_structure_get_value (structure,\n+            \"format\"));\n@@ -1661,2 +1630,2 @@\n-    *amount = g_value_get_uint64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (AMOUNT)));\n+    *amount = g_value_get_uint64 (gst_structure_get_value (structure,\n+            \"amount\"));\n@@ -1664,2 +1633,1 @@\n-    *rate = g_value_get_double (gst_structure_id_get_value (structure,\n-            GST_QUARK (RATE)));\n+    *rate = g_value_get_double (gst_structure_get_value (structure, \"rate\"));\n@@ -1667,2 +1635,1 @@\n-    *flush = g_value_get_boolean (gst_structure_id_get_value (structure,\n-            GST_QUARK (FLUSH)));\n+    *flush = g_value_get_boolean (gst_structure_get_value (structure, \"flush\"));\n@@ -1670,2 +1637,2 @@\n-    *intermediate = g_value_get_boolean (gst_structure_id_get_value (structure,\n-            GST_QUARK (INTERMEDIATE)));\n+    *intermediate = g_value_get_boolean (gst_structure_get_value (structure,\n+            \"intermediate\"));\n@@ -1720,2 +1687,3 @@\n-  structure = gst_structure_new_id (g_quark_from_string (name),\n-      GST_QUARK (MESSAGE), GST_TYPE_MESSAGE, msg, NULL);\n+  structure =\n+      gst_structure_new_static_str (name, \"message\", GST_TYPE_MESSAGE, msg,\n+      NULL);\n@@ -1745,2 +1713,2 @@\n-        GST_MESSAGE (g_value_dup_boxed (gst_structure_id_get_value\n-            (structure, GST_QUARK (MESSAGE))));\n+        GST_MESSAGE (g_value_dup_boxed (gst_structure_get_value\n+            (structure, \"message\")));\n@@ -1784,3 +1752,3 @@\n-  s = gst_structure_new_id (GST_QUARK (EVENT_STREAM_START),\n-      GST_QUARK (STREAM_ID), G_TYPE_STRING, stream_id,\n-      GST_QUARK (FLAGS), GST_TYPE_STREAM_FLAGS, GST_STREAM_FLAG_NONE, NULL);\n+  s = gst_structure_new_static_str (\"GstEventStreamStart\",\n+      \"stream-id\", G_TYPE_STRING, stream_id,\n+      \"flags\", GST_TYPE_STREAM_FLAGS, GST_STREAM_FLAG_NONE, NULL);\n@@ -1811,1 +1779,1 @@\n-  val = gst_structure_id_get_value (structure, GST_QUARK (STREAM_ID));\n+  val = gst_structure_get_value (structure, \"stream-id\");\n@@ -1833,2 +1801,2 @@\n-  gst_structure_id_set (GST_EVENT_STRUCTURE (event),\n-      GST_QUARK (STREAM), GST_TYPE_STREAM, stream, NULL);\n+  gst_structure_set (GST_EVENT_STRUCTURE (event),\n+      \"stream\", GST_TYPE_STREAM, stream, NULL);\n@@ -1854,2 +1822,2 @@\n-    gst_structure_id_get (GST_EVENT_STRUCTURE (event),\n-        GST_QUARK (STREAM), GST_TYPE_STREAM, stream, NULL);\n+    gst_structure_get (GST_EVENT_STRUCTURE (event),\n+        \"stream\", GST_TYPE_STREAM, stream, NULL);\n@@ -1873,2 +1841,2 @@\n-  gst_structure_id_set (GST_EVENT_STRUCTURE (event),\n-      GST_QUARK (FLAGS), GST_TYPE_STREAM_FLAGS, flags, NULL);\n+  gst_structure_set (GST_EVENT_STRUCTURE (event),\n+      \"flags\", GST_TYPE_STREAM_FLAGS, flags, NULL);\n@@ -1892,2 +1860,2 @@\n-    gst_structure_id_get (GST_EVENT_STRUCTURE (event),\n-        GST_QUARK (FLAGS), GST_TYPE_STREAM_FLAGS, flags, NULL);\n+    gst_structure_get (GST_EVENT_STRUCTURE (event),\n+        \"flags\", GST_TYPE_STREAM_FLAGS, flags, NULL);\n@@ -1920,2 +1888,2 @@\n-  gst_structure_id_set (GST_EVENT_STRUCTURE (event),\n-      GST_QUARK (GROUP_ID), G_TYPE_UINT, group_id, NULL);\n+  gst_structure_set (GST_EVENT_STRUCTURE (event),\n+      \"group-id\", G_TYPE_UINT, group_id, NULL);\n@@ -1943,2 +1911,2 @@\n-    return gst_structure_id_get (GST_EVENT_STRUCTURE (event),\n-        GST_QUARK (GROUP_ID), G_TYPE_UINT, group_id, NULL);\n+    return gst_structure_get (GST_EVENT_STRUCTURE (event),\n+        \"group-id\", G_TYPE_UINT, group_id, NULL);\n@@ -1975,2 +1943,2 @@\n-  s = gst_structure_new_id (GST_QUARK (EVENT_STREAM_COLLECTION),\n-      GST_QUARK (COLLECTION), GST_TYPE_STREAM_COLLECTION, collection, NULL);\n+  s = gst_structure_new_static_str (\"stream-collection\",\n+      \"collection\", GST_TYPE_STREAM_COLLECTION, collection, NULL);\n@@ -2002,2 +1970,2 @@\n-    gst_structure_id_get (structure,\n-        GST_QUARK (COLLECTION), GST_TYPE_STREAM_COLLECTION, collection, NULL);\n+    gst_structure_get (structure,\n+        \"collection\", GST_TYPE_STREAM_COLLECTION, collection, NULL);\n@@ -2021,1 +1989,1 @@\n-  GQuark id;\n+  const gchar *name;\n@@ -2030,1 +1998,1 @@\n-    id = GST_QUARK (EVENT_TOC_GLOBAL);\n+    name = \"GstEventTocGlobal\";\n@@ -2032,1 +2000,1 @@\n-    id = GST_QUARK (EVENT_TOC_CURRENT);\n+    name = \"GstEventTocCurrent\";\n@@ -2034,3 +2002,2 @@\n-  toc_struct = gst_structure_new_id (id,\n-      GST_QUARK (TOC), GST_TYPE_TOC, toc,\n-      GST_QUARK (UPDATED), G_TYPE_BOOLEAN, updated, NULL);\n+  toc_struct = gst_structure_new_static_str (name,\n+      \"toc\", GST_TYPE_TOC, toc, \"updated\", G_TYPE_BOOLEAN, updated, NULL);\n@@ -2060,3 +2027,2 @@\n-  gst_structure_id_get (structure,\n-      GST_QUARK (TOC), GST_TYPE_TOC, toc,\n-      GST_QUARK (UPDATED), G_TYPE_BOOLEAN, updated, NULL);\n+  gst_structure_get (structure,\n+      \"toc\", GST_TYPE_TOC, toc, \"updated\", G_TYPE_BOOLEAN, updated, NULL);\n@@ -2084,2 +2050,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (EVENT_TOC_SELECT),\n-      GST_QUARK (UID), G_TYPE_STRING, uid, NULL);\n+  structure = gst_structure_new_static_str (\"GstEventTocSelect\",\n+      \"uid\", G_TYPE_STRING, uid, NULL);\n@@ -2107,1 +2073,1 @@\n-  val = gst_structure_id_get_value (structure, GST_QUARK (UID));\n+  val = gst_structure_get_value (structure, \"uid\");\n@@ -2244,3 +2210,3 @@\n-  structure = gst_structure_new_id (GST_QUARK (EVENT_SEGMENT_DONE),\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (POSITION), G_TYPE_INT64, position, NULL);\n+  structure = gst_structure_new_static_str (\"GstEventSegmentDone\",\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"position\", G_TYPE_INT64, position, NULL);\n@@ -2274,1 +2240,1 @@\n-  val = gst_structure_id_get_value (structure, GST_QUARK (FORMAT));\n+  val = gst_structure_get_value (structure, \"format\");\n@@ -2278,1 +2244,1 @@\n-  val = gst_structure_id_get_value (structure, GST_QUARK (POSITION));\n+  val = gst_structure_get_value (structure, \"position\");\n@@ -2316,3 +2282,3 @@\n-      gst_structure_new_id (GST_QUARK (EVENT_INSTANT_RATE_CHANGE),\n-          GST_QUARK (RATE), G_TYPE_DOUBLE, rate_multiplier,\n-          GST_QUARK (FLAGS), GST_TYPE_SEGMENT_FLAGS, new_flags, NULL));\n+      gst_structure_new_static_str (\"GstEventInstantRateChange\",\n+          \"rate\", G_TYPE_DOUBLE, rate_multiplier,\n+          \"flags\", GST_TYPE_SEGMENT_FLAGS, new_flags, NULL));\n@@ -2345,3 +2311,2 @@\n-  gst_structure_id_get (structure, GST_QUARK (RATE), G_TYPE_DOUBLE,\n-      rate_multiplier, GST_QUARK (FLAGS), GST_TYPE_SEGMENT_FLAGS, new_flags,\n-      NULL);\n+  gst_structure_get (structure, \"rate\", G_TYPE_DOUBLE,\n+      rate_multiplier, \"flags\", GST_TYPE_SEGMENT_FLAGS, new_flags, NULL);\n@@ -2390,4 +2355,4 @@\n-      gst_structure_new_id (GST_QUARK (EVENT_INSTANT_RATE_SYNC_TIME),\n-          GST_QUARK (RATE), G_TYPE_DOUBLE, rate_multiplier,\n-          GST_QUARK (RUNNING_TIME), GST_TYPE_CLOCK_TIME, running_time,\n-          GST_QUARK (UPSTREAM_RUNNING_TIME), GST_TYPE_CLOCK_TIME,\n+      gst_structure_new_static_str (\"GstEventInstantRateSyncTime\",\n+          \"rate\", G_TYPE_DOUBLE, rate_multiplier,\n+          \"running-time\", GST_TYPE_CLOCK_TIME, running_time,\n+          \"upstream-running-time\", GST_TYPE_CLOCK_TIME,\n@@ -2424,3 +2389,3 @@\n-  gst_structure_id_get (structure, GST_QUARK (RATE), G_TYPE_DOUBLE,\n-      rate_multiplier, GST_QUARK (RUNNING_TIME), GST_TYPE_CLOCK_TIME,\n-      running_time, GST_QUARK (UPSTREAM_RUNNING_TIME), GST_TYPE_CLOCK_TIME,\n+  gst_structure_get (structure, \"rate\", G_TYPE_DOUBLE,\n+      rate_multiplier, \"running-time\", GST_TYPE_CLOCK_TIME,\n+      running_time, \"upstream-running-time\", GST_TYPE_CLOCK_TIME,\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstevent.c","additions":144,"deletions":179,"binary":false,"changes":323,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+#ifdef _MSC_VER\n+#pragma warning(disable: 5287)\n+#endif\n+\n@@ -489,1 +493,1 @@\n-GST_API\n+GST_DEPRECATED_FOR(gst_event_has_name)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstevent.h","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,296 @@\n+\/* GStreamer\n+ *\n+ * Copyright (C) 2024 Sebastian Dröge <sebastian@centricular.com>\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Library General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public\n+ * License along with this library; if not, write to the\n+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ *\/\n+\n+#ifndef __GST_ID_STR_PRIVATE_H__\n+#define __GST_ID_STR_PRIVATE_H__\n+\n+#include <gst\/gstconfig.h>\n+#include <gst\/gstidstr.h>\n+#include <glib-object.h>\n+#include <string.h>\n+\n+#ifdef GSTREAMER_LITE\n+#include \"glib-compat-private.h\"\n+#endif \/\/ GSTREAMER_LITE\n+\n+G_BEGIN_DECLS\n+\n+typedef struct {\n+  \/* < private > *\/\n+  union {\n+    struct {\n+      guint8 padding[15];\n+      \/\/ t == 0: Inline-allocated short_string\n+      \/\/ t == 1: Heap-allocated pointer_string that needs freeing\n+      \/\/ t == 2: Statically allocated pointer_string that needs no freeing\n+      guint8 t;\n+    } string_type;\n+    struct {\n+      gchar s[16];\n+      \/\/ t == 0 is the NUL terminator\n+    } short_string;\n+    struct {\n+      gchar *s;           \/\/ to be freed if t == 1\n+      guint32 len;       \/\/ Length of the string without NUL-terminator\n+#if GLIB_SIZEOF_VOID_P == 8\n+      guint8 padding[3]; \/\/ always zero\n+#elif GLIB_SIZEOF_VOID_P == 4\n+      guint8 padding[7]; \/\/ always zero\n+#else\n+  #error \"Only 32 bit and 64 bit pointers supported currently\"\n+#endif\n+      guint8 t; \/\/ always 1 or 2, see above\n+    } pointer_string;\n+  } s;\n+} GstIdStrPrivate;\n+\n+static inline void\n+_gst_id_str_init_inline (GstIdStr * s)\n+{\n+  GstIdStrPrivate *sp = (GstIdStrPrivate *) s;\n+  memset (sp, 0, sizeof (*sp));\n+}\n+\n+static inline gsize\n+_gst_id_str_get_len (const GstIdStr * s)\n+{\n+  GstIdStrPrivate *sp = (GstIdStrPrivate *) s;\n+\n+  switch (sp->s.string_type.t) {\n+    case 0:\n+      return strlen (sp->s.short_string.s);\n+    case 1:\n+    case 2:\n+      return sp->s.pointer_string.len;\n+    default:\n+      g_assert_not_reached ();\n+      return 0;\n+  }\n+}\n+\n+static inline void\n+_gst_id_str_set_with_len_inline (GstIdStr * s, const gchar * value, gsize len)\n+{\n+  GstIdStrPrivate *sp = (GstIdStrPrivate *) s;\n+\n+  g_assert (len <= G_MAXUINT32);\n+\n+  if (sp->s.string_type.t == 1) {\n+    if (sp->s.pointer_string.s == value)\n+      return;\n+    g_free (sp->s.pointer_string.s);\n+  }\n+\n+  if (len <= 15) {\n+    memcpy (sp->s.short_string.s, value, len);\n+    memset (&sp->s.short_string.s[len], 0, 16 - len);\n+  } else {\n+    sp->s.pointer_string.t = 1;\n+    sp->s.pointer_string.len = len;\n+    sp->s.pointer_string.s = (gchar *) g_malloc (len + 1);\n+    memcpy (sp->s.pointer_string.s, value, len);\n+    sp->s.pointer_string.s[len] = '\\0';\n+  }\n+}\n+\n+static inline void\n+_gst_id_str_set_inline (GstIdStr * s, const gchar * value)\n+{\n+  gsize len = strlen (value);\n+  _gst_id_str_set_with_len_inline (s, value, len);\n+}\n+\n+static inline void\n+_gst_id_str_set_static_str_with_len_inline (GstIdStr * s, const gchar * value, gsize len)\n+{\n+  GstIdStrPrivate *sp = (GstIdStrPrivate *) s;\n+\n+  g_assert (len <= G_MAXUINT32);\n+\n+  if (sp->s.string_type.t == 1)\n+    g_free (sp->s.pointer_string.s);\n+\n+  if (len <= 15) {\n+    memcpy (sp->s.short_string.s, value, len);\n+    memset (&sp->s.short_string.s[len], 0, 16 - len);\n+  } else {\n+    sp->s.pointer_string.t = 2;\n+    sp->s.pointer_string.len = len;\n+    sp->s.pointer_string.s = (gchar *) value;\n+  }\n+}\n+\n+static inline void\n+_gst_id_str_set_static_str_inline (GstIdStr * s, const gchar * value)\n+{\n+  gsize len = strlen (value);\n+  _gst_id_str_set_static_str_with_len_inline (s, value, len);\n+}\n+\n+static inline void\n+_gst_id_str_clear_inline (GstIdStr * s)\n+{\n+  GstIdStrPrivate *sp = (GstIdStrPrivate *) s;\n+\n+  if (sp->s.string_type.t == 1) {\n+    g_free (sp->s.pointer_string.s);\n+  }\n+  memset (sp, 0, sizeof (*sp));\n+}\n+\n+static inline void\n+_gst_id_str_copy_into_inline (GstIdStr * d,\n+    const GstIdStr * s)\n+{\n+  GstIdStrPrivate *sp = (GstIdStrPrivate *) s;\n+  GstIdStrPrivate *dp = (GstIdStrPrivate *) d;\n+\n+  _gst_id_str_clear_inline (d);\n+\n+  *dp = *sp;\n+  if (dp->s.string_type.t == 1) {\n+#ifndef GSTREAMER_LITE\n+#if GLIB_CHECK_VERSION (2, 68, 0)\n+      dp->s.pointer_string.s = (gchar *) g_memdup2 (dp->s.pointer_string.s, dp->s.pointer_string.len + 1);\n+#else\n+      dp->s.pointer_string.s = (gchar *) g_memdup (dp->s.pointer_string.s, dp->s.pointer_string.len + 1);\n+#endif\n+#else \/\/ GSTREAMER_LITE\n+      dp->s.pointer_string.s = (gchar *) g_memdup2 (dp->s.pointer_string.s, dp->s.pointer_string.len + 1);\n+#endif \/\/ GSTREAMER_LITE\n+  }\n+}\n+\n+static inline void\n+_gst_id_str_move_inline (GstIdStr * d,\n+    GstIdStr * s)\n+{\n+  GstIdStrPrivate *sp = (GstIdStrPrivate *) s;\n+  GstIdStrPrivate *dp = (GstIdStrPrivate *) d;\n+\n+  _gst_id_str_clear_inline (d);\n+\n+  memcpy (dp, s, sizeof (*sp));\n+  memset (sp, 0, sizeof (*sp));\n+}\n+\n+static inline GstIdStr *\n+_gst_id_str_new_inline (void)\n+{\n+  return (GstIdStr *) g_new0 (GstIdStrPrivate, 1);\n+}\n+\n+static inline GstIdStr *\n+_gst_id_str_copy_inline (const GstIdStr * s)\n+{\n+  GstIdStr *copy = _gst_id_str_new_inline ();\n+\n+  _gst_id_str_copy_into_inline (copy, s);\n+\n+  return copy;\n+}\n+\n+static inline void\n+_gst_id_str_free_inline (GstIdStr * s)\n+{\n+  _gst_id_str_clear_inline (s);\n+  g_free (s);\n+}\n+\n+static inline const gchar *\n+_gst_id_str_as_str_inline (const GstIdStr * s)\n+{\n+  GstIdStrPrivate *sp = (GstIdStrPrivate *) s;\n+\n+  switch (sp->s.string_type.t) {\n+    case 0:\n+      return sp->s.short_string.s;\n+    case 1:\n+    case 2:\n+      return sp->s.pointer_string.s;\n+    default:\n+      g_assert_not_reached ();\n+      return NULL;\n+  }\n+}\n+\n+static inline gboolean\n+_gst_id_str_is_equal_inline (const GstIdStr * s1,\n+    const GstIdStr * s2)\n+{\n+  GstIdStrPrivate *sp1 = (GstIdStrPrivate *) s1;\n+  GstIdStrPrivate *sp2 = (GstIdStrPrivate *) s2;\n+\n+  \/\/ Covers the short_string case and equal pointer_string pointers\n+  if (sp1 == sp2 || memcmp (sp1, sp2, sizeof (*sp1)) == 0)\n+    return TRUE;\n+\n+  \/\/ If one of the strings is a short_string then they can't be equal at this\n+  \/\/ point: either they're both short_strings and not the same, or one is a\n+  \/\/ short_string and the other a pointer_string which would mean that they have\n+  \/\/ different lengths.\n+  if (sp1->s.string_type.t == 0 || sp2->s.string_type.t == 0)\n+    return FALSE;\n+\n+  \/\/ Otherwise they're both pointer_strings\n+  if (sp1->s.pointer_string.len != sp2->s.pointer_string.len)\n+    return FALSE;\n+  return memcmp (sp1->s.pointer_string.s, sp2->s.pointer_string.s, sp1->s.pointer_string.len) == 0;\n+}\n+\n+static inline gboolean\n+_gst_id_str_is_equal_to_str_inline (const GstIdStr * s1,\n+    const gchar * s2)\n+{\n+  return strcmp (_gst_id_str_as_str_inline (s1), s2) == 0;\n+}\n+\n+static inline gboolean\n+_gst_id_str_is_equal_to_str_with_len_inline (const GstIdStr * s1,\n+    const gchar * s2, gsize len)\n+{\n+  GstIdStr s2_int = GST_ID_STR_INIT;\n+\n+  _gst_id_str_set_static_str_with_len_inline (&s2_int, s2, len);\n+  return _gst_id_str_is_equal_inline (s1, &s2_int);\n+}\n+\n+#ifndef GST_ID_STR_DISABLE_INLINES\n+#define gst_id_str_init(s) _gst_id_str_init_inline(s)\n+#define gst_id_str_get_len(s) _gst_id_str_get_len(s)\n+#define gst_id_str_set(s, value) _gst_id_str_set_inline(s, value)\n+#define gst_id_str_set_with_len(s, value, len) _gst_id_str_set_with_len_inline(s, value, len)\n+#define gst_id_str_set_static_str(s, value) _gst_id_str_set_static_str_inline(s, value)\n+#define gst_id_str_set_static_str_with_len(s, value, len) _gst_id_str_set_static_str_with_len_inline(s, value, len)\n+#define gst_id_str_clear(s) _gst_id_str_clear_inline(s)\n+#define gst_id_str_copy(s) _gst_id_str_copy_inline(s)\n+#define gst_id_str_new() _gst_id_str_new_inline()\n+#define gst_id_str_free(s) _gst_id_str_free_inline(s)\n+#define gst_id_str_copy_into(d, s) _gst_id_str_copy_into_inline(d, s)\n+#define gst_id_str_move(d, s) _gst_id_str_move_inline(d, s)\n+#define gst_id_str_is_equal(s1, s2) _gst_id_str_is_equal_inline(s1, s2)\n+#define gst_id_str_is_equal_to_str(s1, s2) _gst_id_str_is_equal_to_str_inline(s1, s2)\n+#define gst_id_str_is_equal_to_str_with_len(s1, s2, len) _gst_id_str_is_equal_to_str_with_len_inline(s1, s2, len)\n+#define gst_id_str_as_str(s) _gst_id_str_as_str_inline(s)\n+#endif\n+\n+G_END_DECLS\n+\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstidstr-private.h","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -0,0 +1,333 @@\n+\/* GStreamer\n+ *\n+ * Copyright (C) 2024 Sebastian Dröge <sebastian@centricular.com>\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Library General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public\n+ * License along with this library; if not, write to the\n+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ *\/\n+\n+\/**\n+ * SECTION:gstidstr\n+ * @title: GstIdStr\n+ * @short_description: String type optimized for short strings\n+ * @see_also: #GstStructure\n+ *\n+ * A #GstIdStr is string type optimized for short strings and used for structure\n+ * names, structure field names and in other places.\n+ *\n+ * Strings up to 16 bytes (including NUL terminator) are stored inline, other\n+ * strings are stored on the heap.\n+ *\n+ * ```cpp\n+ * GstIdStr s = GST_ID_STR_INIT;\n+ *\n+ * gst_id_str_set (&s, \"Hello, World!\");\n+ * g_print (\"%s\\n\", gst_id_str_as_str (&s));\n+ *\n+ * gst_id_str_clear (&s);\n+ * ```\n+ *\/\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+#define GST_ID_STR_DISABLE_INLINES\n+\n+#include \"gstidstr.h\"\n+#include \"gstidstr-private.h\"\n+\n+G_DEFINE_BOXED_TYPE (GstIdStr, gst_id_str, gst_id_str_copy, gst_id_str_free);\n+\n+\/\/ Make sure the string type fields are in the same place for each variant\n+\/\/ See https:\/\/developercommunity.visualstudio.com\/t\/C-offsetof-an-array-item-is-accepted-by\/10736612\n+#ifndef _MSC_VER\n+G_STATIC_ASSERT (G_STRUCT_OFFSET (GstIdStrPrivate,\n+        s.string_type.t) == G_STRUCT_OFFSET (GstIdStrPrivate,\n+        s.short_string.s[15]));\n+#endif\n+G_STATIC_ASSERT (G_STRUCT_OFFSET (GstIdStrPrivate,\n+        s.string_type.t) == G_STRUCT_OFFSET (GstIdStrPrivate,\n+        s.pointer_string.t));\n+\/\/ The overall struct should be 16 bytes large and at least pointer aligned\n+G_STATIC_ASSERT (sizeof (GstIdStrPrivate) == 16);\n+\/\/ See https:\/\/developercommunity.visualstudio.com\/t\/C-offsetof-an-array-item-is-accepted-by\/10736612\n+#ifndef _MSC_VER\n+#ifndef GSTREAMER_LITE\n+G_STATIC_ASSERT (G_ALIGNOF (GstIdStrPrivate) >= G_ALIGNOF (gpointer));\n+\/\/ Alignment and size of the private and public type must be the same\n+G_STATIC_ASSERT (G_ALIGNOF (GstIdStrPrivate) == G_ALIGNOF (GstIdStr));\n+#endif \/\/ GSTREAMER_LITE\n+#endif\n+G_STATIC_ASSERT (sizeof (GstIdStrPrivate) == sizeof (GstIdStr));\n+\n+\/**\n+ * gst_id_str_init:\n+ * @s: A %GstIdStr\n+ *\n+ * Initializes a (usually stack-allocated) id string @s. The newly-initialized\n+ * id string will contain an empty string by default as value.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_id_str_init (GstIdStr * s)\n+{\n+  _gst_id_str_init_inline (s);\n+}\n+\n+\/**\n+ * gst_id_str_get_len:\n+ * @s: A %GstIdStr\n+ *\n+ * Returns the length of @s, exluding the NUL-terminator. This is equivalent to\n+ * calling `strcmp()` but potentially faster.\n+ *\n+ * Since: 1.26\n+ *\/\n+gsize\n+gst_id_str_get_len (const GstIdStr * s)\n+{\n+  return _gst_id_str_get_len (s);\n+}\n+\n+\/**\n+ * gst_id_str_set:\n+ * @s: A %GstIdStr\n+ * @value: A NUL-terminated string\n+ *\n+ * Sets @s to the string @value.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_id_str_set (GstIdStr * s, const gchar * value)\n+{\n+  _gst_id_str_set_inline (s, value);\n+}\n+\n+\/**\n+ * gst_id_str_set_with_len:\n+ * @s: A %GstIdStr\n+ * @value: A string\n+ * @len: Length of the string\n+ *\n+ * Sets @s to the string @value of length @len. @value does not have to be\n+ * NUL-terminated and @len should not include the NUL-terminator.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_id_str_set_with_len (GstIdStr * s, const gchar * value, gsize len)\n+{\n+  _gst_id_str_set_with_len_inline (s, value, len);\n+}\n+\n+\/**\n+ * gst_id_str_set_static_str:\n+ * @s: A %GstIdStr\n+ * @value: A NUL-terminated string\n+ *\n+ * Sets @s to the string @value. @value needs to be valid for the remaining\n+ * lifetime of the process, e.g. has to be a static string.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_id_str_set_static_str (GstIdStr * s, const gchar * value)\n+{\n+  _gst_id_str_set_static_str_inline (s, value);\n+}\n+\n+\/**\n+ * gst_id_str_set_static_str_with_len:\n+ * @s: A %GstIdStr\n+ * @value: A string\n+ * @len: Length of the string\n+ *\n+ * Sets @s to the string @value of length @len. @value needs to be valid for the\n+ * remaining lifetime of the process, e.g. has to be a static string.\n+ *\n+ * @value must be NUL-terminated and @len should not include the\n+ * NUL-terminator.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_id_str_set_static_str_with_len (GstIdStr * s, const gchar * value,\n+    gsize len)\n+{\n+  _gst_id_str_set_static_str_with_len_inline (s, value, len);\n+}\n+\n+\/**\n+ * gst_id_str_clear:\n+ * @s: A %GstIdStr\n+ *\n+ * Clears @s and sets it to the empty string.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_id_str_clear (GstIdStr * s)\n+{\n+  _gst_id_str_clear_inline (s);\n+}\n+\n+\/**\n+ * gst_id_str_copy:\n+ * @s: A %GstIdStr\n+ *\n+ * Copies @s into newly allocated heap memory.\n+ *\n+ * Returns: (transfer full): A heap-allocated copy of @s.\n+ *\n+ * Since: 1.26\n+ *\/\n+GstIdStr *\n+gst_id_str_copy (const GstIdStr * s)\n+{\n+  return _gst_id_str_copy_inline (s);\n+}\n+\n+\/**\n+ * gst_id_str_new:\n+ *\n+ * Returns a newly heap allocated empty string.\n+ *\n+ * Returns: (transfer full): A heap-allocated string.\n+ *\n+ * Since: 1.26\n+ *\/\n+GstIdStr *\n+gst_id_str_new (void)\n+{\n+  return _gst_id_str_new_inline ();\n+}\n+\n+\/**\n+ * gst_id_str_free:\n+ * @s: A heap allocated %GstIdStr\n+ *\n+ * Frees @s. This should only be called for heap-allocated #GstIdStr.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_id_str_free (GstIdStr * s)\n+{\n+  _gst_id_str_free_inline (s);\n+}\n+\n+\/**\n+ * gst_id_str_copy_into:\n+ * @d: The destination %GstIdStr\n+ * @s: The source %GstIdStr\n+ *\n+ * Copies @s into @d.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_id_str_copy_into (GstIdStr * d, const GstIdStr * s)\n+{\n+  _gst_id_str_copy_into_inline (d, s);\n+}\n+\n+\/**\n+ * gst_id_str_move:\n+ * @d: The destination %GstIdStr\n+ * @s: The source %GstIdStr\n+ *\n+ * Moves @s into @d and resets @s.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_id_str_move (GstIdStr * d, GstIdStr * s)\n+{\n+  _gst_id_str_move_inline (d, s);\n+}\n+\n+\/**\n+ * gst_id_str_is_equal:\n+ * @s1: A %GstIdStr\n+ * @s2: A %GstIdStr\n+ *\n+ * Compares @s1 and @s2 for equality.\n+ *\n+ * Returns: %TRUE if @s1 and @s2 are equal.\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_id_str_is_equal (const GstIdStr * s1, const GstIdStr * s2)\n+{\n+  return _gst_id_str_is_equal_inline (s1, s2);\n+}\n+\n+\/**\n+ * gst_id_str_is_equal_to_str:\n+ * @s1: A %GstIdStr\n+ * @s2: A string\n+ *\n+ * Compares @s1 and @s2 for equality.\n+ *\n+ * Returns: %TRUE if @s1 and @s2 are equal.\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_id_str_is_equal_to_str (const GstIdStr * s1, const gchar * s2)\n+{\n+  return _gst_id_str_is_equal_to_str_inline (s1, s2);\n+}\n+\n+\/**\n+ * gst_id_str_is_equal_to_str_with_len:\n+ * @s1: A %GstIdStr\n+ * @s2: A string\n+ * @len: Length of @s2.\n+ *\n+ * Compares @s1 and @s2 with length @len for equality. @s2 does not have to be\n+ * NUL-terminated and @len should not include the NUL-terminator.\n+ *\n+ * This is generally faster than gst_id_str_is_equal_to_str() if the length is\n+ * already known.\n+ *\n+ * Returns: %TRUE if @s1 and @s2 are equal.\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_id_str_is_equal_to_str_with_len (const GstIdStr * s1, const gchar * s2,\n+    gsize len)\n+{\n+  return _gst_id_str_is_equal_to_str_with_len_inline (s1, s2, len);\n+}\n+\n+\/**\n+ * gst_id_str_as_str:\n+ * @s: A %GstIdStr\n+ *\n+ * Returns: the NUL-terminated string representation of @s.\n+ *\n+ * Since: 1.26\n+ *\/\n+const gchar *\n+gst_id_str_as_str (const GstIdStr * s)\n+{\n+  return _gst_id_str_as_str_inline (s);\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstidstr.c","additions":333,"deletions":0,"binary":false,"changes":333,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/* GStreamer\n+ *\n+ * Copyright (C) 2024 Sebastian Dröge <sebastian@centricular.com>\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Library General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public\n+ * License along with this library; if not, write to the\n+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ *\/\n+\n+#ifndef __GST_ID_STR_H__\n+#define __GST_ID_STR_H__\n+\n+#include <gst\/gstconfig.h>\n+#include <glib-object.h>\n+\n+G_BEGIN_DECLS\n+\n+\/**\n+ * GstIdStr:\n+ *\n+ * String type optimized for short strings.\n+ *\n+ * Strings are usually stack- or inline-allocated, and for short strings smaller\n+ * than 16 bytes (including NUL terminator) no heap allocations are performed.\n+ *\n+ * Since: 1.26\n+ *\/\n+typedef struct {\n+  \/* < private > *\/\n+  gpointer pointer;\n+#if GLIB_SIZEOF_VOID_P == 8\n+  guint8 padding[8];\n+#elif GLIB_SIZEOF_VOID_P == 4\n+  guint8 padding[12];\n+#else\n+  #error \"Only 32 bit and 64 bit pointers supported currently\"\n+#endif\n+} GstIdStr;\n+\n+\/**\n+ * GST_ID_STR_INIT:\n+ *\n+ * Initializer for #GstIdStr.\n+ *\n+ * Since: 1.26\n+ *\/\n+#define GST_ID_STR_INIT { .pointer = NULL, .padding = {0, } }\n+\n+GST_API\n+GType gst_id_str_get_type (void);\n+\n+GST_API\n+gsize gst_id_str_get_len (const GstIdStr *s) G_GNUC_PURE;\n+\n+GST_API\n+void gst_id_str_set (GstIdStr *s, const gchar *value);\n+\n+GST_API\n+void gst_id_str_set_with_len (GstIdStr *s, const gchar *value, gsize len);\n+\n+GST_API\n+void gst_id_str_set_static_str (GstIdStr *s, const gchar *value);\n+\n+GST_API\n+void gst_id_str_set_static_str_with_len (GstIdStr *s, const gchar *value, gsize len);\n+\n+GST_API\n+void gst_id_str_init (GstIdStr *s);\n+\n+GST_API\n+void gst_id_str_clear (GstIdStr *s);\n+\n+GST_API\n+GstIdStr * gst_id_str_new (void) G_GNUC_MALLOC;\n+\n+GST_API\n+GstIdStr * gst_id_str_copy (const GstIdStr *s) G_GNUC_MALLOC;\n+\n+GST_API\n+void gst_id_str_free (GstIdStr *s);\n+\n+GST_API\n+void gst_id_str_copy_into (GstIdStr *d, const GstIdStr *s);\n+\n+GST_API\n+void gst_id_str_move (GstIdStr *d, GstIdStr *s);\n+\n+GST_API\n+const gchar * gst_id_str_as_str (const GstIdStr *s) G_GNUC_PURE;\n+\n+GST_API\n+gboolean gst_id_str_is_equal (const GstIdStr *s1, const GstIdStr *s2) G_GNUC_PURE;\n+\n+GST_API\n+gboolean gst_id_str_is_equal_to_str (const GstIdStr *s1, const gchar *s2) G_GNUC_PURE;\n+\n+GST_API\n+gboolean gst_id_str_is_equal_to_str_with_len (const GstIdStr *s1, const gchar *s2, gsize len) G_GNUC_PURE;\n+\n+G_END_DECLS\n+\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstidstr.h","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -104,1 +104,0 @@\n-#include \"gstquark.h\"\n@@ -107,0 +106,1 @@\n+#include \"gstvecdeque.h\"\n@@ -363,1 +363,1 @@\n-static GMutex __log_func_mutex;\n+static GRWLock __log_func_mutex;\n@@ -634,0 +634,1 @@\n+  g_rw_lock_reader_lock (&__log_func_mutex);\n@@ -641,0 +642,2 @@\n+  g_rw_lock_reader_unlock (&__log_func_mutex);\n+\n@@ -726,0 +729,1 @@\n+  g_rw_lock_reader_lock (&__log_func_mutex);\n@@ -733,0 +737,1 @@\n+  g_rw_lock_reader_unlock (&__log_func_mutex);\n@@ -922,1 +927,1 @@\n-    if (G_UNLIKELY (pretty_tags && s->name == GST_QUARK (TAGLIST)))\n+    if (G_UNLIKELY (pretty_tags && gst_structure_has_name (s, \"taglist\")))\n@@ -1081,2 +1086,21 @@\n-static gchar *\n-gst_debug_print_object (gpointer ptr)\n+\/**\n+ * gst_debug_print_object:\n+ * @ptr: (nullable): the object\n+ *\n+ * Returns a string that represents @ptr. This is safe to call with\n+ * %GstStructure, %GstCapsFeatures, %GstMiniObject s (e.g. %GstCaps,\n+ * %GstBuffer or %GstMessage), and %GObjects (e.g. %GstElement or %GstPad).\n+ *\n+ * The string representation is meant to be used for debugging purposes and\n+ * might change between GStreamer versions.\n+ *\n+ * Passing other kind of pointers might or might not work and is generally\n+ * unsafe to do.\n+ *\n+ * Returns: (transfer full) (type gchar*): a string containing a string\n+ *     representation of the object\n+ *\n+ * Since: 1.26\n+ *\/\n+gchar *\n+gst_debug_print_object (gconstpointer ptr)\n@@ -1178,2 +1202,16 @@\n-static gchar *\n-gst_debug_print_segment (gpointer ptr)\n+\/**\n+ * gst_debug_print_segment:\n+ * @segment: (nullable): the %GstSegment\n+ *\n+ * Returns a string that represents @segments.\n+ *\n+ * The string representation is meant to be used for debugging purposes and\n+ * might change between GStreamer versions.\n+ *\n+ * Returns: (transfer full) (type gchar*): a string containing a string\n+ *     representation of the segment\n+ *\n+ * Since: 1.26\n+ *\/\n+gchar *\n+gst_debug_print_segment (const GstSegment * segment)\n@@ -1181,2 +1219,0 @@\n-  GstSegment *segment = (GstSegment *) ptr;\n-\n@@ -1734,1 +1770,0 @@\n-  GSList *list;\n@@ -1743,10 +1778,3 @@\n-  \/* FIXME: we leak the old list here - other threads might access it right now\n-   * in gst_debug_logv. Another solution is to lock the mutex in gst_debug_logv,\n-   * but that is waaay costly.\n-   * It'd probably be clever to use some kind of RCU here, but I don't know\n-   * anything about that.\n-   *\/\n-  g_mutex_lock (&__log_func_mutex);\n-  list = g_slist_copy (__log_functions);\n-  __log_functions = g_slist_prepend (list, entry);\n-  g_mutex_unlock (&__log_func_mutex);\n+  g_rw_lock_writer_lock (&__log_func_mutex);\n+  __log_functions = g_slist_prepend (__log_functions, entry);\n+  g_rw_lock_writer_unlock (&__log_func_mutex);\n@@ -1779,1 +1807,1 @@\n-  GSList *new, *cleanup = NULL;\n+  GSList *cleanup = NULL;\n@@ -1782,10 +1810,2 @@\n-  g_mutex_lock (&__log_func_mutex);\n-  new = __log_functions;\n-  cleanup = NULL;\n-  while ((found = g_slist_find_custom (new, data, func))) {\n-    if (new == __log_functions) {\n-      \/* make a copy when we have the first hit, so that we modify the copy and\n-       * make that the new list later *\/\n-      new = g_slist_copy (new);\n-      continue;\n-    }\n+  g_rw_lock_writer_lock (&__log_func_mutex);\n+  while ((found = g_slist_find_custom (__log_functions, data, func))) {\n@@ -1793,1 +1813,1 @@\n-    new = g_slist_delete_link (new, found);\n+    __log_functions = g_slist_delete_link (__log_functions, found);\n@@ -1796,3 +1816,1 @@\n-  \/* FIXME: We leak the old list here. See _add_log_function for why. *\/\n-  __log_functions = new;\n-  g_mutex_unlock (&__log_func_mutex);\n+  g_rw_lock_writer_unlock (&__log_func_mutex);\n@@ -2558,1 +2576,1 @@\n-  g_mutex_lock (&__log_func_mutex);\n+  g_rw_lock_writer_lock (&__log_func_mutex);\n@@ -2566,1 +2584,10 @@\n-  g_mutex_unlock (&__log_func_mutex);\n+  g_rw_lock_writer_unlock (&__log_func_mutex);\n+\n+#ifdef HAVE_UNWIND\n+# ifdef HAVE_DW\n+  if (_global_dwfl) {\n+    dwfl_end (_global_dwfl);\n+    _global_dwfl = NULL;\n+  }\n+# endif\n+#endif\n@@ -3541,1 +3568,1 @@\n-  GQueue log;\n+  GstVecDeque *log;\n@@ -3612,1 +3639,1 @@\n-      while ((buf = g_queue_pop_head (&log->log)))\n+      while ((buf = gst_vec_deque_pop_head (log->log)))\n@@ -3614,0 +3641,1 @@\n+      gst_vec_deque_free (log->log);\n@@ -3624,1 +3652,1 @@\n-    g_queue_init (&log->log);\n+    log->log = gst_vec_deque_new (2048);\n@@ -3639,8 +3667,0 @@\n-    \/* While using a GQueue here is not the most efficient thing to do, we\n-     * have to allocate a string for every output anyway and could just store\n-     * that instead of copying it to an actual ringbuffer.\n-     * Better than GQueue would be GstQueueArray, but that one is in\n-     * libgstbase and we can't use it here. That one allocation will not make\n-     * much of a difference anymore, considering the number of allocations\n-     * needed to get to this point...\n-     *\/\n@@ -3648,1 +3668,1 @@\n-      buf = g_queue_pop_head (&log->log);\n+      buf = gst_vec_deque_pop_head (log->log);\n@@ -3652,1 +3672,1 @@\n-    g_queue_push_tail (&log->log, output);\n+    gst_vec_deque_push_tail (log->log, output);\n@@ -3660,1 +3680,1 @@\n-    while ((buf = g_queue_pop_head (&log->log)))\n+    while ((buf = gst_vec_deque_pop_head (log->log)))\n@@ -3693,1 +3713,0 @@\n-    GList *l;\n@@ -3695,1 +3714,1 @@\n-    gsize len;\n+    gsize n_lines, line_len;\n@@ -3699,4 +3718,6 @@\n-    for (l = log->log.head; l; l = l->next) {\n-      len = strlen (l->data);\n-      memcpy (p, l->data, len);\n-      p += len;\n+    n_lines = gst_vec_deque_get_length (log->log);\n+    for (gsize i = 0; i < n_lines; i++) {\n+      const gchar *line = gst_vec_deque_peek_nth (log->log, i);\n+      line_len = strlen (line);\n+      memcpy (p, line, line_len);\n+      p += line_len;\n@@ -3722,1 +3743,1 @@\n-      while ((buf = g_queue_pop_head (&log->log)))\n+      while ((buf = gst_vec_deque_pop_head (log->log)))\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstinfo.c","additions":79,"deletions":58,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include <gst\/gstsegment.h>\n@@ -556,0 +557,6 @@\n+GST_API\n+gchar * gst_debug_print_object  (gconstpointer ptr);\n+\n+GST_API\n+gchar * gst_debug_print_segment (const GstSegment *segment);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstinfo.h","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -489,0 +489,1 @@\n+      case GST_ITERATOR_ERROR:\n@@ -532,1 +533,1 @@\n- * @user_data: (closure): user data passed to the compare function\n+ * @user_data: user data passed to the compare function\n@@ -581,1 +582,1 @@\n- * @func: (scope call): the fold function\n+ * @func: (scope call) (closure user_data): the fold function\n@@ -583,1 +584,1 @@\n- * @user_data: (closure): user data passed to the fold function\n+ * @user_data: user data passed to the fold function\n@@ -654,2 +655,2 @@\n- * @func: (scope call): the function to call for each element.\n- * @user_data: (closure): user data passed to the function\n+ * @func: (scope call) (closure user_data): the function to call for each element.\n+ * @user_data: user data passed to the function\n@@ -701,1 +702,1 @@\n- * @func: (scope call): the compare function to use\n+ * @func: (scope call) (closure user_data): the compare function to use\n@@ -703,1 +704,1 @@\n- * @user_data: (closure): user data passed to the compare function\n+ * @user_data: user data passed to the compare function\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstiterator.c","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  GST_TRACER_MEMORY_FREE_PRE (mem);\n@@ -99,0 +100,1 @@\n+  GST_TRACER_MEMORY_FREE_POST (mem);\n@@ -142,0 +144,1 @@\n+  GST_TRACER_MEMORY_INIT (mem);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstmemory.c","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#include \"gsterror.h\"\n@@ -55,1 +54,0 @@\n-#include \"gstquark.h\"\n@@ -119,2 +117,0 @@\n-static GQuark details_quark = 0;\n-\n@@ -135,1 +131,0 @@\n-  details_quark = g_quark_from_static_string (\"details\");\n@@ -402,0 +397,128 @@\n+\/* Internal function for setting details on a message. Checks for valid\n+ * arguments should be done before calling this.\n+ *\n+ * Will create a message structure if it doesn't have one already\n+ **\/\n+static void\n+message_set_details (GstMessage * message, GstStructure * details)\n+{\n+  GValue v = G_VALUE_INIT;\n+\n+  if (GST_MESSAGE_STRUCTURE (message) == NULL) {\n+    const gchar *message_name = gst_message_type_get_name (message->type);\n+    g_return_if_fail (message_name);\n+    GstStructure *structure = gst_structure_new_static_str_empty (message_name);\n+    gst_structure_set_parent_refcount (structure,\n+        &message->mini_object.refcount);\n+    GST_MESSAGE_STRUCTURE (message) = structure;\n+  }\n+  g_value_init (&v, GST_TYPE_STRUCTURE);\n+  g_value_take_boxed (&v, details);\n+  gst_structure_take_value (GST_MESSAGE_STRUCTURE (message), \"details\", &v);\n+}\n+\n+\/**\n+ * gst_message_set_details:\n+ * @message: A #GstMessage\n+ * @details: (transfer full) (nullable): A GstStructure with details\n+ *\n+ * Add @details to @message. Will fail if the message already has details set on\n+ * it or if it is not writable.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_message_set_details (GstMessage * message, GstStructure * details)\n+{\n+  g_return_if_fail (GST_IS_MESSAGE (message));\n+  g_return_if_fail (gst_message_is_writable (message));\n+  g_return_if_fail (details);\n+\n+  if (GST_MESSAGE_STRUCTURE (message)\n+      && gst_structure_has_field (GST_MESSAGE_STRUCTURE (message), \"details\")) {\n+    gst_structure_free (details);\n+    g_critical (\"Message already has details\");\n+    return;\n+  }\n+\n+  message_set_details (message, details);\n+}\n+\n+\/* Internal function for parsing details of a message.\n+ * Checks for valid arguments should be done before calling this.\n+ *\n+ * Will create a details structure if create_if_missing is TRUE\n+ *\/\n+static void\n+message_parse_details (GstMessage * message, GstStructure ** details,\n+    gboolean create_if_missing)\n+{\n+  *details = NULL;\n+\n+  if (GST_MESSAGE_STRUCTURE (message) == NULL && !create_if_missing)\n+    return;\n+\n+  if (GST_MESSAGE_STRUCTURE (message) &&\n+      gst_structure_has_field (GST_MESSAGE_STRUCTURE (message), \"details\")) {\n+    const GValue *v = gst_structure_get_value (GST_MESSAGE_STRUCTURE (message),\n+        \"details\");\n+    if (v && G_VALUE_TYPE (v) == GST_TYPE_STRUCTURE) {\n+      *details = g_value_get_boxed (v);\n+    }\n+  } else if (create_if_missing) {\n+    *details = gst_structure_new_static_str_empty (\"message-details\");\n+    message_set_details (message, (GstStructure *) * details);\n+  }\n+}\n+\n+\/**\n+ * gst_message_get_details:\n+ * @message: A #GstMessage\n+ *\n+ * Returns the optional details structure of the message. May be NULL if none.\n+ *\n+ * The returned structure must not be freed.\n+ *\n+ * Returns: (transfer none) (nullable): The details, or NULL if none.\n+ *\n+ * Since: 1.26\n+ *\/\n+const GstStructure *\n+gst_message_get_details (GstMessage * message)\n+{\n+  const GstStructure *details;\n+\n+  g_return_val_if_fail (GST_IS_MESSAGE (message), NULL);\n+\n+  message_parse_details (message, (GstStructure **) & details, FALSE);\n+\n+  return details;\n+}\n+\n+\/**\n+ * gst_message_writable_details:\n+ * @message: A writable #GstMessage\n+ *\n+ * Returns the details structure of the @message. If not present it will be\n+ * created. Use this function (instead of gst_message_get_details()) if you\n+ * want to write to the @details structure.\n+ *\n+ * The returned structure must not be freed.\n+ *\n+ * Returns: (transfer none): The details\n+ *\n+ * Since: 1.26\n+ *\/\n+GstStructure *\n+gst_message_writable_details (GstMessage * message)\n+{\n+  GstStructure *details;\n+\n+  g_return_val_if_fail (GST_IS_MESSAGE (message), NULL);\n+  g_return_val_if_fail (gst_message_is_writable (message), NULL);\n+\n+  message_parse_details (message, &details, TRUE);\n+\n+  return details;\n+}\n+\n@@ -431,3 +554,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_ERROR),\n-      GST_QUARK (GERROR), G_TYPE_ERROR, error,\n-      GST_QUARK (DEBUG), G_TYPE_STRING, debug, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageError\",\n+      \"gerror\", G_TYPE_ERROR, error, \"debug\", G_TYPE_STRING, debug, NULL);\n@@ -436,6 +558,1 @@\n-    GValue v = G_VALUE_INIT;\n-\n-    g_value_init (&v, GST_TYPE_STRUCTURE);\n-    g_value_take_boxed (&v, details);\n-    gst_structure_id_take_value (GST_MESSAGE_STRUCTURE (message), details_quark,\n-        &v);\n+    message_set_details (message, details);\n@@ -482,1 +599,3 @@\n-  const GValue *v;\n+  g_return_if_fail (GST_IS_MESSAGE (message));\n+  g_return_if_fail (GST_MESSAGE_TYPE (message) == GST_MESSAGE_ERROR);\n+  g_return_if_fail (structure != NULL);\n@@ -484,0 +603,17 @@\n+  message_parse_details (message, (GstStructure **) structure, FALSE);\n+}\n+\n+\/**\n+ * gst_message_parse_error_writable_details:\n+ * @message: The writable message object\n+ * @structure: (optional) (nullable) (transfer none) (out): A pointer to the returned details\n+ *\n+ * Returns the details structure if present or will create one if not present.\n+ * The returned structure must not be freed.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_message_parse_error_writable_details (GstMessage * message,\n+    GstStructure ** structure)\n+{\n@@ -486,0 +622,1 @@\n+  g_return_if_fail (gst_message_is_writable (message));\n@@ -488,6 +625,1 @@\n-  *structure = NULL;\n-  v = gst_structure_id_get_value (GST_MESSAGE_STRUCTURE (message),\n-      details_quark);\n-  if (v) {\n-    *structure = g_value_get_boxed (v);\n-  }\n+  message_parse_details (message, (GstStructure **) structure, TRUE);\n@@ -523,3 +655,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_WARNING),\n-      GST_QUARK (GERROR), G_TYPE_ERROR, error,\n-      GST_QUARK (DEBUG), G_TYPE_STRING, debug, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageWarning\",\n+      \"gerror\", G_TYPE_ERROR, error, \"debug\", G_TYPE_STRING, debug, NULL);\n@@ -528,6 +659,1 @@\n-    GValue v = G_VALUE_INIT;\n-\n-    g_value_init (&v, GST_TYPE_STRUCTURE);\n-    g_value_take_boxed (&v, details);\n-    gst_structure_id_take_value (GST_MESSAGE_STRUCTURE (message), details_quark,\n-        &v);\n+    message_set_details (message, details);\n@@ -572,1 +698,6 @@\n-  const GValue *v;\n+  g_return_if_fail (GST_IS_MESSAGE (message));\n+  g_return_if_fail (GST_MESSAGE_TYPE (message) == GST_MESSAGE_WARNING);\n+  g_return_if_fail (structure != NULL);\n+\n+  message_parse_details (message, (GstStructure **) structure, FALSE);\n+}\n@@ -574,0 +705,14 @@\n+\/**\n+ * gst_message_parse_warning_writable_details:\n+ * @message: The writable message object\n+ * @structure: (optional) (nullable) (transfer none) (out): A pointer to the returned details\n+ *\n+ * Returns the details structure if present or will create one if not present.\n+ * The returned structure must not be freed.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_message_parse_warning_writable_details (GstMessage * message,\n+    GstStructure ** structure)\n+{\n@@ -576,0 +721,1 @@\n+  g_return_if_fail (gst_message_is_writable (message));\n@@ -578,6 +724,1 @@\n-  *structure = NULL;\n-  v = gst_structure_id_get_value (GST_MESSAGE_STRUCTURE (message),\n-      details_quark);\n-  if (v) {\n-    *structure = g_value_get_boxed (v);\n-  }\n+  message_parse_details (message, (GstStructure **) structure, TRUE);\n@@ -613,3 +754,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_INFO),\n-      GST_QUARK (GERROR), G_TYPE_ERROR, error,\n-      GST_QUARK (DEBUG), G_TYPE_STRING, debug, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageInfo\",\n+      \"gerror\", G_TYPE_ERROR, error, \"debug\", G_TYPE_STRING, debug, NULL);\n@@ -618,6 +758,1 @@\n-    GValue v = G_VALUE_INIT;\n-\n-    g_value_init (&v, GST_TYPE_STRUCTURE);\n-    g_value_take_boxed (&v, details);\n-    gst_structure_id_take_value (GST_MESSAGE_STRUCTURE (message), details_quark,\n-        &v);\n+    message_set_details (message, details);\n@@ -662,1 +797,6 @@\n-  const GValue *v;\n+  g_return_if_fail (GST_IS_MESSAGE (message));\n+  g_return_if_fail (GST_MESSAGE_TYPE (message) == GST_MESSAGE_INFO);\n+  g_return_if_fail (structure != NULL);\n+\n+  message_parse_details (message, (GstStructure **) structure, FALSE);\n+}\n@@ -664,0 +804,14 @@\n+\/**\n+ * gst_message_parse_info_writable_details:\n+ * @message: The writable message object\n+ * @structure: (optional) (nullable) (transfer none) (out): A pointer to the returned details\n+ *\n+ * Returns the details structure if present or will create one if not present.\n+ * The returned structure must not be freed.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_message_parse_info_writable_details (GstMessage * message,\n+    GstStructure ** structure)\n+{\n@@ -666,0 +820,1 @@\n+  g_return_if_fail (gst_message_is_writable (message));\n@@ -668,6 +823,1 @@\n-  *structure = NULL;\n-  v = gst_structure_id_get_value (GST_MESSAGE_STRUCTURE (message),\n-      details_quark);\n-  if (v) {\n-    *structure = g_value_get_boxed (v);\n-  }\n+  message_parse_details (message, (GstStructure **) structure, TRUE);\n@@ -697,1 +847,1 @@\n-  s = gst_structure_new_id_empty (GST_QUARK (MESSAGE_TAG));\n+  s = gst_structure_new_static_str_empty (\"GstMessageTag\");\n@@ -700,1 +850,1 @@\n-  gst_structure_id_take_value (s, GST_QUARK (TAGLIST), &val);\n+  gst_structure_take_value (s, \"taglist\", &val);\n@@ -736,6 +886,6 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_BUFFERING),\n-      GST_QUARK (BUFFER_PERCENT), G_TYPE_INT, percent,\n-      GST_QUARK (BUFFERING_MODE), GST_TYPE_BUFFERING_MODE, GST_BUFFERING_STREAM,\n-      GST_QUARK (AVG_IN_RATE), G_TYPE_INT, -1,\n-      GST_QUARK (AVG_OUT_RATE), G_TYPE_INT, -1,\n-      GST_QUARK (BUFFERING_LEFT), G_TYPE_INT64, buffering_left, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageBuffering\",\n+      \"buffer-percent\", G_TYPE_INT, percent,\n+      \"buffering-mode\", GST_TYPE_BUFFERING_MODE, GST_BUFFERING_STREAM,\n+      \"avg-in-rate\", G_TYPE_INT, -1,\n+      \"avg-out-rate\", G_TYPE_INT, -1,\n+      \"buffering-left\", G_TYPE_INT64, buffering_left, NULL);\n@@ -768,4 +918,4 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_STATE_CHANGED),\n-      GST_QUARK (OLD_STATE), GST_TYPE_STATE, (gint) oldstate,\n-      GST_QUARK (NEW_STATE), GST_TYPE_STATE, (gint) newstate,\n-      GST_QUARK (PENDING_STATE), GST_TYPE_STATE, (gint) pending, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageStateChanged\",\n+      \"old-state\", GST_TYPE_STATE, (gint) oldstate,\n+      \"new-state\", GST_TYPE_STATE, (gint) newstate,\n+      \"pending-state\", GST_TYPE_STATE, (gint) pending, NULL);\n@@ -823,3 +973,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_CLOCK_PROVIDE),\n-      GST_QUARK (CLOCK), GST_TYPE_CLOCK, clock,\n-      GST_QUARK (READY), G_TYPE_BOOLEAN, ready, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageClockProvide\",\n+      \"clock\", GST_TYPE_CLOCK, clock, \"ready\", G_TYPE_BOOLEAN, ready, NULL);\n@@ -853,2 +1002,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_CLOCK_LOST),\n-      GST_QUARK (CLOCK), GST_TYPE_CLOCK, clock, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageClockLost\",\n+      \"clock\", GST_TYPE_CLOCK, clock, NULL);\n@@ -878,2 +1027,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_NEW_CLOCK),\n-      GST_QUARK (CLOCK), GST_TYPE_CLOCK, clock, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageNewClock\",\n+      \"clock\", GST_TYPE_CLOCK, clock, NULL);\n@@ -913,4 +1062,3 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_STRUCTURE_CHANGE),\n-      GST_QUARK (TYPE), GST_TYPE_STRUCTURE_CHANGE_TYPE, type,\n-      GST_QUARK (OWNER), GST_TYPE_ELEMENT, owner,\n-      GST_QUARK (BUSY), G_TYPE_BOOLEAN, busy, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageStructureChange\",\n+      \"type\", GST_TYPE_STRUCTURE_CHANGE_TYPE, type,\n+      \"owner\", GST_TYPE_ELEMENT, owner, \"busy\", G_TYPE_BOOLEAN, busy, NULL);\n@@ -946,3 +1094,3 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_SEGMENT_START),\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (POSITION), G_TYPE_INT64, position, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageSegmentStart\",\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"position\", G_TYPE_INT64, position, NULL);\n@@ -976,3 +1124,3 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_SEGMENT_DONE),\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (POSITION), G_TYPE_INT64, position, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageSegmentDone\",\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"position\", G_TYPE_INT64, position, NULL);\n@@ -1047,1 +1195,1 @@\n-      gst_structure_new_id_empty (GST_QUARK (MESSAGE_DURATION_CHANGED)));\n+      gst_structure_new_static_str_empty (\"GstMessageDurationChanged\"));\n@@ -1093,2 +1241,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_ASYNC_DONE),\n-      GST_QUARK (RUNNING_TIME), G_TYPE_UINT64, running_time, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageAsyncDone\",\n+      \"running-time\", G_TYPE_UINT64, running_time, NULL);\n@@ -1140,2 +1288,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_REQUEST_STATE),\n-      GST_QUARK (NEW_STATE), GST_TYPE_STATE, (gint) state, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageRequestState\",\n+      \"new-state\", GST_TYPE_STATE, (gint) state, NULL);\n@@ -1195,2 +1343,2 @@\n-        gst_structure_new_id_empty (gst_message_type_to_quark (GST_MESSAGE_TYPE\n-            (message)));\n+        gst_structure_new_static_str_empty (gst_message_type_get_name\n+        (GST_MESSAGE_TYPE (message)));\n@@ -1263,2 +1411,2 @@\n-  gst_structure_id_get (GST_MESSAGE_STRUCTURE (message),\n-      GST_QUARK (TAGLIST), GST_TYPE_TAG_LIST, tag_list, NULL);\n+  gst_structure_get (GST_MESSAGE_STRUCTURE (message),\n+      \"taglist\", GST_TYPE_TAG_LIST, tag_list, NULL);\n@@ -1285,2 +1433,2 @@\n-        g_value_get_int (gst_structure_id_get_value (GST_MESSAGE_STRUCTURE\n-            (message), GST_QUARK (BUFFER_PERCENT)));\n+        g_value_get_int (gst_structure_get_value (GST_MESSAGE_STRUCTURE\n+            (message), \"buffer-percent\"));\n@@ -1306,5 +1454,5 @@\n-  gst_structure_id_set (GST_MESSAGE_STRUCTURE (message),\n-      GST_QUARK (BUFFERING_MODE), GST_TYPE_BUFFERING_MODE, mode,\n-      GST_QUARK (AVG_IN_RATE), G_TYPE_INT, avg_in,\n-      GST_QUARK (AVG_OUT_RATE), G_TYPE_INT, avg_out,\n-      GST_QUARK (BUFFERING_LEFT), G_TYPE_INT64, buffering_left, NULL);\n+  gst_structure_set (GST_MESSAGE_STRUCTURE (message),\n+      \"buffering-mode\", GST_TYPE_BUFFERING_MODE, mode,\n+      \"avg-in-rate\", G_TYPE_INT, avg_in,\n+      \"avg-out-rate\", G_TYPE_INT, avg_out,\n+      \"buffering-left\", G_TYPE_INT64, buffering_left, NULL);\n@@ -1336,2 +1484,2 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (BUFFERING_MODE)));\n+        g_value_get_enum (gst_structure_get_value (structure,\n+            \"buffering-mode\"));\n@@ -1339,2 +1487,2 @@\n-    *avg_in = g_value_get_int (gst_structure_id_get_value (structure,\n-            GST_QUARK (AVG_IN_RATE)));\n+    *avg_in = g_value_get_int (gst_structure_get_value (structure,\n+            \"avg-in-rate\"));\n@@ -1342,2 +1490,2 @@\n-    *avg_out = g_value_get_int (gst_structure_id_get_value (structure,\n-            GST_QUARK (AVG_OUT_RATE)));\n+    *avg_out = g_value_get_int (gst_structure_get_value (structure,\n+            \"avg-out-rate\"));\n@@ -1346,2 +1494,2 @@\n-        g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (BUFFERING_LEFT)));\n+        g_value_get_int64 (gst_structure_get_value (structure,\n+            \"buffering-left\"));\n@@ -1392,2 +1540,1 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (OLD_STATE)));\n+        g_value_get_enum (gst_structure_get_value (structure, \"old-state\"));\n@@ -1396,2 +1543,1 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (NEW_STATE)));\n+        g_value_get_enum (gst_structure_get_value (structure, \"new-state\"));\n@@ -1400,2 +1546,1 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (PENDING_STATE)));\n+        g_value_get_enum (gst_structure_get_value (structure, \"pending-state\"));\n@@ -1427,1 +1572,1 @@\n-  clock_gvalue = gst_structure_id_get_value (structure, GST_QUARK (CLOCK));\n+  clock_gvalue = gst_structure_get_value (structure, \"clock\");\n@@ -1432,3 +1577,1 @@\n-    *ready =\n-        g_value_get_boolean (gst_structure_id_get_value (structure,\n-            GST_QUARK (READY)));\n+    *ready = g_value_get_boolean (gst_structure_get_value (structure, \"ready\"));\n@@ -1459,1 +1602,1 @@\n-  clock_gvalue = gst_structure_id_get_value (structure, GST_QUARK (CLOCK));\n+  clock_gvalue = gst_structure_get_value (structure, \"clock\");\n@@ -1488,1 +1631,1 @@\n-  clock_gvalue = gst_structure_id_get_value (structure, GST_QUARK (CLOCK));\n+  clock_gvalue = gst_structure_get_value (structure, \"clock\");\n@@ -1520,1 +1663,1 @@\n-  owner_gvalue = gst_structure_id_get_value (structure, GST_QUARK (OWNER));\n+  owner_gvalue = gst_structure_get_value (structure, \"owner\");\n@@ -1526,2 +1669,1 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (TYPE)));\n+        g_value_get_enum (gst_structure_get_value (structure, \"type\"));\n@@ -1531,3 +1673,1 @@\n-    *busy =\n-        g_value_get_boolean (gst_structure_id_get_value (structure,\n-            GST_QUARK (BUSY)));\n+    *busy = g_value_get_boolean (gst_structure_get_value (structure, \"busy\"));\n@@ -1575,3 +1715,2 @@\n-  gst_structure_id_get (GST_MESSAGE_STRUCTURE (message),\n-      GST_QUARK (GERROR), G_TYPE_ERROR, gerror,\n-      GST_QUARK (DEBUG), G_TYPE_STRING, debug, NULL);\n+  gst_structure_get (GST_MESSAGE_STRUCTURE (message),\n+      \"gerror\", G_TYPE_ERROR, gerror, \"debug\", G_TYPE_STRING, debug, NULL);\n@@ -1599,3 +1738,2 @@\n-  gst_structure_id_get (GST_MESSAGE_STRUCTURE (message),\n-      GST_QUARK (GERROR), G_TYPE_ERROR, gerror,\n-      GST_QUARK (DEBUG), G_TYPE_STRING, debug, NULL);\n+  gst_structure_get (GST_MESSAGE_STRUCTURE (message),\n+      \"gerror\", G_TYPE_ERROR, gerror, \"debug\", G_TYPE_STRING, debug, NULL);\n@@ -1622,3 +1760,2 @@\n-  gst_structure_id_get (GST_MESSAGE_STRUCTURE (message),\n-      GST_QUARK (GERROR), G_TYPE_ERROR, gerror,\n-      GST_QUARK (DEBUG), G_TYPE_STRING, debug, NULL);\n+  gst_structure_get (GST_MESSAGE_STRUCTURE (message),\n+      \"gerror\", G_TYPE_ERROR, gerror, \"debug\", G_TYPE_STRING, debug, NULL);\n@@ -1649,2 +1786,1 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (FORMAT)));\n+        g_value_get_enum (gst_structure_get_value (structure, \"format\"));\n@@ -1653,2 +1789,1 @@\n-        g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (POSITION)));\n+        g_value_get_int64 (gst_structure_get_value (structure, \"position\"));\n@@ -1679,2 +1814,1 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (FORMAT)));\n+        g_value_get_enum (gst_structure_get_value (structure, \"format\"));\n@@ -1683,2 +1817,1 @@\n-        g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (POSITION)));\n+        g_value_get_int64 (gst_structure_get_value (structure, \"position\"));\n@@ -1707,2 +1840,2 @@\n-        g_value_get_uint64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (RUNNING_TIME)));\n+        g_value_get_uint64 (gst_structure_get_value (structure,\n+            \"running-time\"));\n@@ -1731,2 +1864,1 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (NEW_STATE)));\n+        g_value_get_enum (gst_structure_get_value (structure, \"new-state\"));\n@@ -1755,3 +1887,3 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_STREAM_STATUS),\n-      GST_QUARK (TYPE), GST_TYPE_STREAM_STATUS_TYPE, (gint) type,\n-      GST_QUARK (OWNER), GST_TYPE_ELEMENT, owner, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageStreamStatus\",\n+      \"type\", GST_TYPE_STREAM_STATUS_TYPE, (gint) type,\n+      \"owner\", GST_TYPE_ELEMENT, owner, NULL);\n@@ -1786,1 +1918,1 @@\n-  owner_gvalue = gst_structure_id_get_value (structure, GST_QUARK (OWNER));\n+  owner_gvalue = gst_structure_get_value (structure, \"owner\");\n@@ -1791,2 +1923,1 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (TYPE)));\n+        g_value_get_enum (gst_structure_get_value (structure, \"type\"));\n@@ -1815,1 +1946,1 @@\n-  gst_structure_id_set_value (structure, GST_QUARK (OBJECT), object);\n+  gst_structure_set_value_static_str (structure, \"object\", object);\n@@ -1840,1 +1971,1 @@\n-  result = gst_structure_id_get_value (structure, GST_QUARK (OBJECT));\n+  result = gst_structure_get_value (structure, \"object\");\n@@ -1874,8 +2005,7 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_STEP_DONE),\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (AMOUNT), G_TYPE_UINT64, amount,\n-      GST_QUARK (RATE), G_TYPE_DOUBLE, rate,\n-      GST_QUARK (FLUSH), G_TYPE_BOOLEAN, flush,\n-      GST_QUARK (INTERMEDIATE), G_TYPE_BOOLEAN, intermediate,\n-      GST_QUARK (DURATION), G_TYPE_UINT64, duration,\n-      GST_QUARK (EOS), G_TYPE_BOOLEAN, eos, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageStepDone\",\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"amount\", G_TYPE_UINT64, amount,\n+      \"rate\", G_TYPE_DOUBLE, rate,\n+      \"flush\", G_TYPE_BOOLEAN, flush,\n+      \"intermediate\", G_TYPE_BOOLEAN, intermediate,\n+      \"duration\", G_TYPE_UINT64, duration, \"eos\", G_TYPE_BOOLEAN, eos, NULL);\n@@ -1913,8 +2043,7 @@\n-  gst_structure_id_get (structure,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (AMOUNT), G_TYPE_UINT64, amount,\n-      GST_QUARK (RATE), G_TYPE_DOUBLE, rate,\n-      GST_QUARK (FLUSH), G_TYPE_BOOLEAN, flush,\n-      GST_QUARK (INTERMEDIATE), G_TYPE_BOOLEAN, intermediate,\n-      GST_QUARK (DURATION), G_TYPE_UINT64, duration,\n-      GST_QUARK (EOS), G_TYPE_BOOLEAN, eos, NULL);\n+  gst_structure_get (structure,\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"amount\", G_TYPE_UINT64, amount,\n+      \"rate\", G_TYPE_DOUBLE, rate,\n+      \"flush\", G_TYPE_BOOLEAN, flush,\n+      \"intermediate\", G_TYPE_BOOLEAN, intermediate,\n+      \"duration\", G_TYPE_UINT64, duration, \"eos\", G_TYPE_BOOLEAN, eos, NULL);\n@@ -1955,7 +2084,7 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_STEP_START),\n-      GST_QUARK (ACTIVE), G_TYPE_BOOLEAN, active,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (AMOUNT), G_TYPE_UINT64, amount,\n-      GST_QUARK (RATE), G_TYPE_DOUBLE, rate,\n-      GST_QUARK (FLUSH), G_TYPE_BOOLEAN, flush,\n-      GST_QUARK (INTERMEDIATE), G_TYPE_BOOLEAN, intermediate, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageStepStart\",\n+      \"active\", G_TYPE_BOOLEAN, active,\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"amount\", G_TYPE_UINT64, amount,\n+      \"rate\", G_TYPE_DOUBLE, rate,\n+      \"flush\", G_TYPE_BOOLEAN, flush,\n+      \"intermediate\", G_TYPE_BOOLEAN, intermediate, NULL);\n@@ -1992,7 +2121,7 @@\n-  gst_structure_id_get (structure,\n-      GST_QUARK (ACTIVE), G_TYPE_BOOLEAN, active,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (AMOUNT), G_TYPE_UINT64, amount,\n-      GST_QUARK (RATE), G_TYPE_DOUBLE, rate,\n-      GST_QUARK (FLUSH), G_TYPE_BOOLEAN, flush,\n-      GST_QUARK (INTERMEDIATE), G_TYPE_BOOLEAN, intermediate, NULL);\n+  gst_structure_get (structure,\n+      \"active\", G_TYPE_BOOLEAN, active,\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"amount\", G_TYPE_UINT64, amount,\n+      \"rate\", G_TYPE_DOUBLE, rate,\n+      \"flush\", G_TYPE_BOOLEAN, flush,\n+      \"intermediate\", G_TYPE_BOOLEAN, intermediate, NULL);\n@@ -2035,12 +2164,12 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_QOS),\n-      GST_QUARK (LIVE), G_TYPE_BOOLEAN, live,\n-      GST_QUARK (RUNNING_TIME), G_TYPE_UINT64, running_time,\n-      GST_QUARK (STREAM_TIME), G_TYPE_UINT64, stream_time,\n-      GST_QUARK (TIMESTAMP), G_TYPE_UINT64, timestamp,\n-      GST_QUARK (DURATION), G_TYPE_UINT64, duration,\n-      GST_QUARK (JITTER), G_TYPE_INT64, (gint64) 0,\n-      GST_QUARK (PROPORTION), G_TYPE_DOUBLE, (gdouble) 1.0,\n-      GST_QUARK (QUALITY), G_TYPE_INT, (gint) 1000000,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, GST_FORMAT_UNDEFINED,\n-      GST_QUARK (PROCESSED), G_TYPE_UINT64, (guint64) - 1,\n-      GST_QUARK (DROPPED), G_TYPE_UINT64, (guint64) - 1, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageQOS\",\n+      \"live\", G_TYPE_BOOLEAN, live,\n+      \"running-time\", G_TYPE_UINT64, running_time,\n+      \"stream-time\", G_TYPE_UINT64, stream_time,\n+      \"timestamp\", G_TYPE_UINT64, timestamp,\n+      \"duration\", G_TYPE_UINT64, duration,\n+      \"jitter\", G_TYPE_INT64, (gint64) 0,\n+      \"proportion\", G_TYPE_DOUBLE, (gdouble) 1.0,\n+      \"quality\", G_TYPE_INT, (gint) 1000000,\n+      \"format\", GST_TYPE_FORMAT, GST_FORMAT_UNDEFINED,\n+      \"processed\", G_TYPE_UINT64, (guint64) - 1,\n+      \"dropped\", G_TYPE_UINT64, (guint64) - 1, NULL);\n@@ -2075,4 +2204,4 @@\n-  gst_structure_id_set (structure,\n-      GST_QUARK (JITTER), G_TYPE_INT64, jitter,\n-      GST_QUARK (PROPORTION), G_TYPE_DOUBLE, proportion,\n-      GST_QUARK (QUALITY), G_TYPE_INT, quality, NULL);\n+  gst_structure_set_static_str (structure,\n+      \"jitter\", G_TYPE_INT64, jitter,\n+      \"proportion\", G_TYPE_DOUBLE, proportion,\n+      \"quality\", G_TYPE_INT, quality, NULL);\n@@ -2110,4 +2239,4 @@\n-  gst_structure_id_set (structure,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (PROCESSED), G_TYPE_UINT64, processed,\n-      GST_QUARK (DROPPED), G_TYPE_UINT64, dropped, NULL);\n+  gst_structure_set_static_str (structure,\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"processed\", G_TYPE_UINT64, processed,\n+      \"dropped\", G_TYPE_UINT64, dropped, NULL);\n@@ -2148,6 +2277,6 @@\n-  gst_structure_id_get (structure,\n-      GST_QUARK (LIVE), G_TYPE_BOOLEAN, live,\n-      GST_QUARK (RUNNING_TIME), G_TYPE_UINT64, running_time,\n-      GST_QUARK (STREAM_TIME), G_TYPE_UINT64, stream_time,\n-      GST_QUARK (TIMESTAMP), G_TYPE_UINT64, timestamp,\n-      GST_QUARK (DURATION), G_TYPE_UINT64, duration, NULL);\n+  gst_structure_get (structure,\n+      \"live\", G_TYPE_BOOLEAN, live,\n+      \"running-time\", G_TYPE_UINT64, running_time,\n+      \"stream-time\", G_TYPE_UINT64, stream_time,\n+      \"timestamp\", G_TYPE_UINT64, timestamp,\n+      \"duration\", G_TYPE_UINT64, duration, NULL);\n@@ -2181,4 +2310,4 @@\n-  gst_structure_id_get (structure,\n-      GST_QUARK (JITTER), G_TYPE_INT64, jitter,\n-      GST_QUARK (PROPORTION), G_TYPE_DOUBLE, proportion,\n-      GST_QUARK (QUALITY), G_TYPE_INT, quality, NULL);\n+  gst_structure_get (structure,\n+      \"jitter\", G_TYPE_INT64, jitter,\n+      \"proportion\", G_TYPE_DOUBLE, proportion,\n+      \"quality\", G_TYPE_INT, quality, NULL);\n@@ -2217,4 +2346,4 @@\n-  gst_structure_id_get (structure,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (PROCESSED), G_TYPE_UINT64, processed,\n-      GST_QUARK (DROPPED), G_TYPE_UINT64, dropped, NULL);\n+  gst_structure_get (structure,\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"processed\", G_TYPE_UINT64, processed,\n+      \"dropped\", G_TYPE_UINT64, dropped, NULL);\n@@ -2252,6 +2381,5 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_PROGRESS),\n-      GST_QUARK (TYPE), GST_TYPE_PROGRESS_TYPE, type,\n-      GST_QUARK (CODE), G_TYPE_STRING, code,\n-      GST_QUARK (TEXT), G_TYPE_STRING, text,\n-      GST_QUARK (PERCENT), G_TYPE_INT, percent,\n-      GST_QUARK (TIMEOUT), G_TYPE_INT, timeout, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageProgress\",\n+      \"type\", GST_TYPE_PROGRESS_TYPE, type,\n+      \"code\", G_TYPE_STRING, code,\n+      \"text\", G_TYPE_STRING, text,\n+      \"percent\", G_TYPE_INT, percent, \"timeout\", G_TYPE_INT, timeout, NULL);\n@@ -2282,4 +2410,3 @@\n-  gst_structure_id_get (structure,\n-      GST_QUARK (TYPE), GST_TYPE_PROGRESS_TYPE, type,\n-      GST_QUARK (CODE), G_TYPE_STRING, code,\n-      GST_QUARK (TEXT), G_TYPE_STRING, text, NULL);\n+  gst_structure_get (structure,\n+      \"type\", GST_TYPE_PROGRESS_TYPE, type,\n+      \"code\", G_TYPE_STRING, code, \"text\", G_TYPE_STRING, text, NULL);\n@@ -2308,3 +2435,2 @@\n-  toc_struct = gst_structure_new_id (GST_QUARK (MESSAGE_TOC),\n-      GST_QUARK (TOC), GST_TYPE_TOC, toc,\n-      GST_QUARK (UPDATED), G_TYPE_BOOLEAN, updated, NULL);\n+  toc_struct = gst_structure_new_static_str (\"GstMessageToc\",\n+      \"toc\", GST_TYPE_TOC, toc, \"updated\", G_TYPE_BOOLEAN, updated, NULL);\n@@ -2334,3 +2460,2 @@\n-  gst_structure_id_get (GST_MESSAGE_STRUCTURE (message),\n-      GST_QUARK (TOC), GST_TYPE_TOC, toc,\n-      GST_QUARK (UPDATED), G_TYPE_BOOLEAN, updated, NULL);\n+  gst_structure_get (GST_MESSAGE_STRUCTURE (message),\n+      \"toc\", GST_TYPE_TOC, toc, \"updated\", G_TYPE_BOOLEAN, updated, NULL);\n@@ -2359,2 +2484,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_RESET_TIME),\n-      GST_QUARK (RUNNING_TIME), G_TYPE_UINT64, running_time, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageResetTime\",\n+      \"running-time\", G_TYPE_UINT64, running_time, NULL);\n@@ -2387,2 +2512,2 @@\n-        g_value_get_uint64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (RUNNING_TIME)));\n+        g_value_get_uint64 (gst_structure_get_value (structure,\n+            \"running-time\"));\n@@ -2409,1 +2534,1 @@\n-  s = gst_structure_new_id_empty (GST_QUARK (MESSAGE_STREAM_START));\n+  s = gst_structure_new_static_str_empty (\"GstMessageStreamStart\");\n@@ -2444,2 +2569,1 @@\n-  gst_structure_id_set (structure, GST_QUARK (GROUP_ID), G_TYPE_UINT, group_id,\n-      NULL);\n+  gst_structure_set (structure, \"group-id\", G_TYPE_UINT, group_id, NULL);\n@@ -2479,1 +2603,1 @@\n-  v = gst_structure_id_get_value (structure, GST_QUARK (GROUP_ID));\n+  v = gst_structure_get_value (structure, \"group-id\");\n@@ -2508,2 +2632,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_NEED_CONTEXT),\n-      GST_QUARK (CONTEXT_TYPE), G_TYPE_STRING, context_type, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageNeedContext\",\n+      \"context-type\", G_TYPE_STRING, context_type, NULL);\n@@ -2539,1 +2663,1 @@\n-    value = gst_structure_id_get_value (structure, GST_QUARK (CONTEXT_TYPE));\n+    value = gst_structure_get_value (structure, \"context-type\");\n@@ -2565,2 +2689,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_HAVE_CONTEXT),\n-      GST_QUARK (CONTEXT), GST_TYPE_CONTEXT, context, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageHaveContext\",\n+      \"context\", GST_TYPE_CONTEXT, context, NULL);\n@@ -2592,2 +2716,2 @@\n-    gst_structure_id_get (GST_MESSAGE_STRUCTURE (message),\n-        GST_QUARK (CONTEXT), GST_TYPE_CONTEXT, context, NULL);\n+    gst_structure_get (GST_MESSAGE_STRUCTURE (message),\n+        \"context\", GST_TYPE_CONTEXT, context, NULL);\n@@ -2619,2 +2743,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_DEVICE_ADDED),\n-      GST_QUARK (DEVICE), GST_TYPE_DEVICE, device, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageDeviceAdded\",\n+      \"device\", GST_TYPE_DEVICE, device, NULL);\n@@ -2645,2 +2769,2 @@\n-    gst_structure_id_get (GST_MESSAGE_STRUCTURE (message),\n-        GST_QUARK (DEVICE), GST_TYPE_DEVICE, device, NULL);\n+    gst_structure_get (GST_MESSAGE_STRUCTURE (message),\n+        \"device\", GST_TYPE_DEVICE, device, NULL);\n@@ -2671,2 +2795,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_DEVICE_REMOVED),\n-      GST_QUARK (DEVICE), GST_TYPE_DEVICE, device, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageDeviceRemoved\",\n+      \"device\", GST_TYPE_DEVICE, device, NULL);\n@@ -2697,2 +2821,2 @@\n-    gst_structure_id_get (GST_MESSAGE_STRUCTURE (message),\n-        GST_QUARK (DEVICE), GST_TYPE_DEVICE, device, NULL);\n+    gst_structure_get (GST_MESSAGE_STRUCTURE (message),\n+        \"device\", GST_TYPE_DEVICE, device, NULL);\n@@ -2726,3 +2850,3 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_DEVICE_CHANGED),\n-      GST_QUARK (DEVICE), GST_TYPE_DEVICE, device,\n-      GST_QUARK (DEVICE_CHANGED), GST_TYPE_DEVICE, changed_device, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageDeviceChanged\",\n+      \"device\", GST_TYPE_DEVICE, device,\n+      \"device-changed\", GST_TYPE_DEVICE, changed_device, NULL);\n@@ -2757,2 +2881,2 @@\n-    gst_structure_id_get (GST_MESSAGE_STRUCTURE (message),\n-        GST_QUARK (DEVICE), GST_TYPE_DEVICE, device, NULL);\n+    gst_structure_get (GST_MESSAGE_STRUCTURE (message),\n+        \"device\", GST_TYPE_DEVICE, device, NULL);\n@@ -2761,2 +2885,2 @@\n-    gst_structure_id_get (GST_MESSAGE_STRUCTURE (message),\n-        GST_QUARK (DEVICE_CHANGED), GST_TYPE_DEVICE, changed_device, NULL);\n+    gst_structure_get (GST_MESSAGE_STRUCTURE (message),\n+        \"device-changed\", GST_TYPE_DEVICE, changed_device, NULL);\n@@ -2786,1 +2910,1 @@\n-  structure = gst_structure_new_id_empty (GST_QUARK (MESSAGE_PROPERTY_NOTIFY));\n+  structure = gst_structure_new_static_str_empty (\"GstMessagePropertyNotify\");\n@@ -2790,1 +2914,1 @@\n-  gst_structure_id_take_value (structure, GST_QUARK (PROPERTY_NAME), &name_val);\n+  gst_structure_take_value (structure, \"property-name\", &name_val);\n@@ -2792,1 +2916,1 @@\n-    gst_structure_id_take_value (structure, GST_QUARK (PROPERTY_VALUE), val);\n+    gst_structure_take_value (structure, \"property-value\", val);\n@@ -2830,1 +2954,1 @@\n-    name_value = gst_structure_id_get_value (s, GST_QUARK (PROPERTY_NAME));\n+    name_value = gst_structure_get_value (s, \"property-name\");\n@@ -2835,2 +2959,1 @@\n-    *property_value =\n-        gst_structure_id_get_value (s, GST_QUARK (PROPERTY_VALUE));\n+    *property_value = gst_structure_get_value (s, \"property-value\");\n@@ -2862,2 +2985,2 @@\n-      gst_structure_new_id (GST_QUARK (MESSAGE_STREAM_COLLECTION),\n-      GST_QUARK (COLLECTION), GST_TYPE_STREAM_COLLECTION, collection, NULL);\n+      gst_structure_new_static_str (\"GstMessageStreamCollection\",\n+      \"collection\", GST_TYPE_STREAM_COLLECTION, collection, NULL);\n@@ -2889,2 +3012,2 @@\n-    gst_structure_id_get (GST_MESSAGE_STRUCTURE (message),\n-        GST_QUARK (COLLECTION), GST_TYPE_STREAM_COLLECTION, collection, NULL);\n+    gst_structure_get (GST_MESSAGE_STRUCTURE (message),\n+        \"collection\", GST_TYPE_STREAM_COLLECTION, collection, NULL);\n@@ -2925,2 +3048,2 @@\n-      gst_structure_new_id (GST_QUARK (MESSAGE_STREAMS_SELECTED),\n-      GST_QUARK (COLLECTION), GST_TYPE_STREAM_COLLECTION, collection, NULL);\n+      gst_structure_new_static_str (\"GstMessageStreamsSelected\",\n+      \"collection\", GST_TYPE_STREAM_COLLECTION, collection, NULL);\n@@ -2928,1 +3051,1 @@\n-  gst_structure_id_take_value (structure, GST_QUARK (STREAMS), &val);\n+  gst_structure_take_value (structure, \"streams\", &val);\n@@ -2954,3 +3077,1 @@\n-  val =\n-      gst_structure_id_get_value (GST_MESSAGE_STRUCTURE (msg),\n-      GST_QUARK (STREAMS));\n+  val = gst_structure_get_value (GST_MESSAGE_STRUCTURE (msg), \"streams\");\n@@ -2980,2 +3101,2 @@\n-      (GValue *) gst_structure_id_get_value (GST_MESSAGE_STRUCTURE (msg),\n-      GST_QUARK (STREAMS));\n+      (GValue *) gst_structure_get_value (GST_MESSAGE_STRUCTURE (msg),\n+      \"streams\");\n@@ -3007,3 +3128,1 @@\n-  streams =\n-      gst_structure_id_get_value (GST_MESSAGE_STRUCTURE (msg),\n-      GST_QUARK (STREAMS));\n+  streams = gst_structure_get_value (GST_MESSAGE_STRUCTURE (msg), \"streams\");\n@@ -3036,2 +3155,2 @@\n-    gst_structure_id_get (GST_MESSAGE_STRUCTURE (message),\n-        GST_QUARK (COLLECTION), GST_TYPE_STREAM_COLLECTION, collection, NULL);\n+    gst_structure_get (GST_MESSAGE_STRUCTURE (message),\n+        \"collection\", GST_TYPE_STREAM_COLLECTION, collection, NULL);\n@@ -3093,2 +3212,2 @@\n-  structure = gst_structure_new_id_empty (GST_QUARK (MESSAGE_REDIRECT));\n-  gst_structure_id_take_value (structure, GST_QUARK (REDIRECT_ENTRY_LOCATIONS),\n+  structure = gst_structure_new_static_str_empty (\"GstMessageRedirect\");\n+  gst_structure_take_value_static_str (structure, \"redirect-entry-locations\",\n@@ -3096,1 +3215,1 @@\n-  gst_structure_id_take_value (structure, GST_QUARK (REDIRECT_ENTRY_TAGLISTS),\n+  gst_structure_take_value_static_str (structure, \"redirect-entry-taglists\",\n@@ -3098,1 +3217,1 @@\n-  gst_structure_id_take_value (structure, GST_QUARK (REDIRECT_ENTRY_STRUCTURES),\n+  gst_structure_take_value_static_str (structure, \"redirect-entry-structures\",\n@@ -3140,2 +3259,2 @@\n-      (GValue *) gst_structure_id_get_value (structure,\n-      GST_QUARK (REDIRECT_ENTRY_LOCATIONS));\n+      (GValue *) gst_structure_get_value (structure,\n+      \"redirect-entry-locations\");\n@@ -3144,2 +3263,1 @@\n-      (GValue *) gst_structure_id_get_value (structure,\n-      GST_QUARK (REDIRECT_ENTRY_TAGLISTS));\n+      (GValue *) gst_structure_get_value (structure, \"redirect-entry-taglists\");\n@@ -3148,2 +3266,2 @@\n-      (GValue *) gst_structure_id_get_value (structure,\n-      GST_QUARK (REDIRECT_ENTRY_STRUCTURES));\n+      (GValue *) gst_structure_get_value (structure,\n+      \"redirect-entry-structures\");\n@@ -3205,2 +3323,1 @@\n-      gst_structure_id_get_value (structure,\n-      GST_QUARK (REDIRECT_ENTRY_LOCATIONS));\n+      gst_structure_get_value (structure, \"redirect-entry-locations\");\n@@ -3209,2 +3326,1 @@\n-      gst_structure_id_get_value (structure,\n-      GST_QUARK (REDIRECT_ENTRY_TAGLISTS));\n+      gst_structure_get_value (structure, \"redirect-entry-taglists\");\n@@ -3213,2 +3329,1 @@\n-      gst_structure_id_get_value (structure,\n-      GST_QUARK (REDIRECT_ENTRY_STRUCTURES));\n+      gst_structure_get_value (structure, \"redirect-entry-structures\");\n@@ -3259,2 +3374,1 @@\n-      gst_structure_id_get_value (structure,\n-      GST_QUARK (REDIRECT_ENTRY_LOCATIONS));\n+      gst_structure_get_value (structure, \"redirect-entry-locations\");\n@@ -3263,2 +3377,1 @@\n-      gst_structure_id_get_value (structure,\n-      GST_QUARK (REDIRECT_ENTRY_TAGLISTS));\n+      gst_structure_get_value (structure, \"redirect-entry-taglists\");\n@@ -3267,2 +3380,1 @@\n-      gst_structure_id_get_value (structure,\n-      GST_QUARK (REDIRECT_ENTRY_STRUCTURES));\n+      gst_structure_get_value (structure, \"redirect-entry-structures\");\n@@ -3304,2 +3416,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (MESSAGE_INSTANT_RATE_REQUEST),\n-      GST_QUARK (RATE), G_TYPE_DOUBLE, rate_multiplier, NULL);\n+  structure = gst_structure_new_static_str (\"GstMessageInstantRateRequest\",\n+      \"rate\", G_TYPE_DOUBLE, rate_multiplier, NULL);\n@@ -3332,2 +3444,1 @@\n-  gst_structure_id_get (structure, GST_QUARK (RATE), G_TYPE_DOUBLE,\n-      rate_multiplier, NULL);\n+  gst_structure_get (structure, \"rate\", G_TYPE_DOUBLE, rate_multiplier, NULL);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstmessage.c","additions":423,"deletions":312,"binary":false,"changes":735,"status":"modified"},{"patch":"@@ -471,0 +471,10 @@\n+GST_API\n+void            gst_message_set_details         (GstMessage *message, GstStructure *details);\n+\n+GST_API\n+const GstStructure *\n+                gst_message_get_details         (GstMessage *message);\n+\n+GST_API\n+GstStructure *  gst_message_writable_details    (GstMessage *message);\n+\n@@ -498,0 +508,3 @@\n+GST_API\n+void            gst_message_parse_error_writable_details (GstMessage *message, GstStructure **structure);\n+\n@@ -512,0 +525,3 @@\n+GST_API\n+void            gst_message_parse_warning_writable_details (GstMessage *message, GstStructure **structure);\n+\n@@ -526,0 +542,3 @@\n+GST_API\n+void            gst_message_parse_info_writable_details  (GstMessage *message, GstStructure **structure);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstmessage.h","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-#include \"gstquark.h\"\n@@ -61,0 +60,2 @@\n+static GQuark _gst_meta_tags_quark;\n+static GQuark _gst_allocation_meta_params_aggregator_quark;\n@@ -87,0 +88,3 @@\n+  _gst_meta_tags_quark = g_quark_from_static_string (\"tags\");\n+  _gst_allocation_meta_params_aggregator_quark =\n+      g_quark_from_static_string (\"GstAllocationMetaParamsAggregator\");\n@@ -142,1 +146,1 @@\n-  g_type_set_qdata (type, GST_QUARK (TAGS), g_strdupv ((gchar **) tags));\n+  g_type_set_qdata (type, _gst_meta_tags_quark, g_strdupv ((gchar **) tags));\n@@ -275,2 +279,2 @@\n- * @transform_func: (scope notified) (nullable): a #GstMetaTransformFunction\n- * @user_data: (closure): user data passed to @transform_func\n+ * @transform_func: (scope notified) (nullable) (closure user_data): a #GstMetaTransformFunction\n+ * @user_data: user data passed to @transform_func\n@@ -403,1 +407,1 @@\n-  tags = g_type_get_qdata (api, GST_QUARK (TAGS));\n+  tags = g_type_get_qdata (api, _gst_meta_tags_quark);\n@@ -411,0 +415,56 @@\n+\/**\n+ * gst_meta_api_type_aggregate_params:\n+ * @api: the GType of the API for which the parameters are being aggregated.\n+ * @aggregated_params: This structure will be updated with the\n+ *                     combined parameters from both @params0 and @params1.\n+ * @params0: a #GstStructure containing the new parameters to be aggregated.\n+ * @params1: a #GstStructure containing the new parameters to be aggregated.\n+ *\n+ * When a element like `tee` decides the allocation, each downstream element may\n+ * fill different parameters and pass them to gst_query_add_allocation_meta().\n+ * In order to keep these parameters, a merge operation is needed. This\n+ * aggregate function can combine the parameters from @params0 and @param1, and\n+ * write the result back into @aggregated_params.\n+ *\n+ * Returns: %TRUE if the parameters were successfully aggregated, %FALSE otherwise.\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_meta_api_type_aggregate_params (GType api,\n+    GstStructure ** aggregated_params, const GstStructure * params0,\n+    const GstStructure * params1)\n+{\n+  g_return_val_if_fail (api != 0, FALSE);\n+  g_return_val_if_fail (aggregated_params != NULL, FALSE);\n+\n+  GstAllocationMetaParamsAggregator aggregator_func =\n+      g_type_get_qdata (api, _gst_allocation_meta_params_aggregator_quark);\n+\n+  if (!aggregator_func)\n+    return FALSE;\n+\n+  return aggregator_func (aggregated_params, params0, params1);\n+}\n+\n+\/**\n+ * gst_meta_api_type_set_params_aggregator:\n+ * @api: the #GType of the API for which the aggregator function is being set.\n+ * @aggregator: (scope forever): the aggregator function to be associated with the given API\n+ *              type.\n+ *\n+ * This function sets the aggregator function for a specific API type.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_meta_api_type_set_params_aggregator (GType api,\n+    GstAllocationMetaParamsAggregator aggregator)\n+{\n+  g_return_if_fail (api != 0);\n+  g_return_if_fail (aggregator != NULL);\n+\n+  g_type_set_qdata (api, _gst_allocation_meta_params_aggregator_quark,\n+      (GstAllocationMetaParamsAggregator) aggregator);\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstmeta.c","additions":65,"deletions":5,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -299,0 +299,18 @@\n+\/**\n+ * GstAllocationMetaParamsAggregator:\n+ * @aggregated_params: This structure will be updated with the\n+ *                     combined parameters from both @params0 and @params1.\n+ * @params0: a #GstStructure containing the new parameters to be aggregated.\n+ * @params1: a #GstStructure containing the new parameters to be aggregated.\n+ *\n+ * The aggregator function will combine the parameters from @params0 and @param1\n+ * and write the result back into @aggregated_params.\n+ *\n+ * Returns: %TRUE if the parameters were successfully aggregated, %FALSE otherwise.\n+ *\n+ * Since: 1.26\n+ *\/\n+typedef gboolean (*GstAllocationMetaParamsAggregator) (GstStructure ** aggregated_params,\n+                                                       const GstStructure * params0,\n+                                                       const GstStructure * params1);\n+\n@@ -366,0 +384,10 @@\n+GST_API\n+gboolean             gst_meta_api_type_aggregate_params (GType api,\n+                                                         GstStructure ** aggregated_params,\n+                                                         const GstStructure * params0,\n+                                                         const GstStructure * params1);\n+\n+GST_API\n+void                 gst_meta_api_type_set_params_aggregator (GType api,\n+                                                              GstAllocationMetaParamsAggregator aggregator);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstmeta.h","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -198,0 +198,9 @@\n+typedef struct\n+{\n+  GstPad *pad;\n+  GstFlowReturn flow_res;\n+} PadChainListData;\n+\n+static gboolean list_process_buffer_writable (GstBuffer ** buffer, guint idx,\n+    gpointer userdata);\n+\n@@ -1411,3 +1420,3 @@\n- * @callback: #GstPadProbeCallback that will be called with notifications of\n- *           the pad state\n- * @user_data: (closure): user data passed to the callback\n+ * @callback: (closure user_data): #GstPadProbeCallback that will be called with\n+ *           notifications of the pad state\n+ * @user_data: user data passed to the callback\n@@ -4017,1 +4026,4 @@\n- * Set the offset that will be applied to the running time of @pad.\n+ * Set the offset that will be applied to the running time of @pad. Upon next\n+ * buffer, every sticky events (notably segment) will be pushed again with\n+ * their running time adjusted. For that reason this is only reliable on\n+ * source pads.\n@@ -4024,0 +4036,8 @@\n+  \/* Setting pad offset on a sink pad does not work reliably:\n+   * https:\/\/gitlab.freedesktop.org\/modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gstreamer\/-\/merge_requests\/6464 *\/\n+  if (GST_PAD_IS_SINK (pad)) {\n+    \/* Make it non fatal warning for backward compatibility. *\/\n+    GST_WARNING_OBJECT (pad,\n+        \"Setting pad offset only works reliably on source pads\");\n+  }\n+\n@@ -4057,1 +4077,8 @@\n-\/* should be called with pad LOCK *\/\n+\/* Push the sticky event in the #PadEvent pointed by @ev.\n+ *\n+ * Must be called with pad LOCK.\n+ *\n+ * This function will temporarily unlock the pad during the event push, so care\n+ * must be taken that all the arguments remain valid during the entire duration\n+ * of the call.  Note that events_foreach() already guarantees this by making a\n+ * stack copy of PadEvent and increasing the reference count of the event. *\/\n@@ -4083,0 +4110,12 @@\n+    GST_OBJECT_UNLOCK (pad);\n+    \/* The event argument remains valid during the unlock as the caller must\n+     * hold a strong reference to event during the call. *\/\n+    GST_TRACER_PAD_PUSH_EVENT_PRE (pad, event);\n+    GST_OBJECT_LOCK (pad);\n+    \/* Note that serialized events (and by extension, the events in the sticky\n+     * event list of the pad) are meant to be pushed while holding the srcpad\n+     * stream lock.\n+     * A FLUSH_START may have been pushed within the unlocked period, which\n+     * would set the pad flushing flag, but a FLUSH_STOP requires the stream\n+     * lock. *\/\n+\n@@ -4085,0 +4124,5 @@\n+\n+    GST_OBJECT_UNLOCK (pad);\n+    GST_TRACER_PAD_PUSH_EVENT_POST (pad, data->ret >= GST_FLOW_OK);\n+    GST_OBJECT_LOCK (pad);\n+\n@@ -4131,2 +4175,5 @@\n-\/* check sticky events and push them when needed. should be called\n- * with pad LOCK *\/\n+\/* Check the sticky event list of the pad and push all sticky events that\n+ * have not been yet received by downstream and that aren't priority-ordered\n+ * after the optional @event passed as argument.\n+ *\n+ * Must be called with pad LOCK. *\/\n@@ -4155,1 +4202,9 @@\n-        data.ret = gst_pad_push_event_unchecked (pad, gst_event_ref (ev->event),\n+        \/* Store and ref the event *before* unlocking, as the PadEvent list\n+         * may be modified during the unlocked period (e.g. by a flush or\n+         * instant rate change event). *\/\n+        GstEvent *event = gst_event_ref (ev->event);\n+        GST_OBJECT_UNLOCK (pad);\n+        GST_TRACER_PAD_PUSH_EVENT_PRE (pad, event);\n+        GST_OBJECT_LOCK (pad);\n+\n+        data.ret = gst_pad_push_event_unchecked (pad, event,\n@@ -4157,0 +4212,5 @@\n+\n+        GST_OBJECT_UNLOCK (pad);\n+        GST_TRACER_PAD_PUSH_EVENT_POST (pad, data.ret >= GST_FLOW_OK);\n+        GST_OBJECT_LOCK (pad);\n+\n@@ -4648,0 +4708,10 @@\n+static gboolean\n+list_process_buffer_writable (GstBuffer ** buffer, guint idx, gpointer userdata)\n+{\n+  PadChainListData *data = (PadChainListData *) (userdata);\n+  data->flow_res = gst_pad_chain_data_unchecked (data->pad,\n+      GST_PAD_PROBE_TYPE_BUFFER | GST_PAD_PROBE_TYPE_PUSH, *buffer);\n+  *buffer = NULL;\n+  return data->flow_res == GST_FLOW_OK;\n+}\n+\n@@ -4658,2 +4728,0 @@\n-  len = gst_buffer_list_length (list);\n-\n@@ -4661,8 +4729,16 @@\n-  for (i = 0; i < len; i++) {\n-    buffer = gst_buffer_list_get (list, i);\n-    ret =\n-        gst_pad_chain_data_unchecked (pad,\n-        GST_PAD_PROBE_TYPE_BUFFER | GST_PAD_PROBE_TYPE_PUSH,\n-        gst_buffer_ref (buffer));\n-    if (ret != GST_FLOW_OK)\n-      break;\n+\n+  if (gst_buffer_list_is_writable (list)) {\n+    PadChainListData data = {.pad = pad,.flow_res = GST_FLOW_OK };\n+    gst_buffer_list_foreach (list, list_process_buffer_writable, &data);\n+    ret = data.flow_res;\n+  } else {\n+    len = gst_buffer_list_length (list);\n+    for (i = 0; i < len; i++) {\n+      buffer = gst_buffer_list_get (list, i);\n+      ret =\n+          gst_pad_chain_data_unchecked (pad,\n+          GST_PAD_PROBE_TYPE_BUFFER | GST_PAD_PROBE_TYPE_PUSH,\n+          gst_buffer_ref (buffer));\n+      if (ret != GST_FLOW_OK)\n+        break;\n+    }\n@@ -4670,0 +4746,1 @@\n+\n@@ -5338,1 +5415,1 @@\n-  GQuark name_id = 0;\n+  const gchar *name = NULL;\n@@ -5340,0 +5417,1 @@\n+  gboolean changed_stream_id = FALSE;\n@@ -5356,1 +5434,1 @@\n-    GST_LOG_OBJECT (pad, \"Removing pending EOS, StreamGroupDone, TAG events\");\n+    GST_LOG_OBJECT (pad, \"Removing pending EOS, StreamGroupDone events\");\n@@ -5359,1 +5437,0 @@\n-    remove_event_by_type (pad, GST_EVENT_TAG);\n@@ -5367,1 +5444,1 @@\n-    name_id = gst_structure_get_name_id (gst_event_get_structure (event));\n+    name = gst_structure_get_name (gst_event_get_structure (event));\n@@ -5380,1 +5457,1 @@\n-      if (name_id && !gst_event_has_name_id (ev->event, name_id))\n+      if (name && !gst_event_has_name (ev->event, name))\n@@ -5383,0 +5460,9 @@\n+      if (type == GST_EVENT_STREAM_START && event != ev->event) {\n+        const gchar *old_stream_id, *new_stream_id;\n+\n+        gst_event_parse_stream_start (ev->event, &old_stream_id);\n+        gst_event_parse_stream_start (event, &new_stream_id);\n+\n+        changed_stream_id = !g_str_equal (old_stream_id, new_stream_id);\n+      }\n+\n@@ -5412,0 +5498,6 @@\n+    changed_stream_id = type == GST_EVENT_STREAM_START;\n+  }\n+\n+  if (changed_stream_id) {\n+    GST_LOG_OBJECT (pad, \"Removing pending TAG events\");\n+    remove_event_by_type (pad, GST_EVENT_TAG);\n@@ -5548,0 +5640,2 @@\n+          if (pad->ABI.abi.last_flowret == GST_FLOW_NOT_LINKED)\n+            pad->ABI.abi.last_flowret = GST_FLOW_OK;\n@@ -5681,2 +5775,2 @@\n- * @pad: a #GstPad to push the event to.\n- * @event: (transfer full): the #GstEvent to send to the pad.\n+ * @pad: the #GstPad that will push the event.\n+ * @event: (transfer full): the #GstEvent to push out of the pad.\n@@ -5848,0 +5942,1 @@\n+  GST_TRACER_PAD_SEND_EVENT_PRE (pad, event);\n@@ -5899,3 +5994,0 @@\n-    case GST_EVENT_RECONFIGURE:\n-      if (GST_PAD_IS_SRC (pad))\n-        GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);\n@@ -5910,1 +6002,3 @@\n-        case GST_EVENT_STREAM_START:\n+        case GST_EVENT_STREAM_START:{\n+          gboolean changed_stream_id = TRUE;\n+\n@@ -5922,0 +6016,20 @@\n+          for (guint i = 0; i < pad->priv->events->len; i++) {\n+            PadEvent *ev = &g_array_index (pad->priv->events, PadEvent, i);\n+\n+            if (GST_EVENT_TYPE (ev->event) == GST_EVENT_STREAM_START) {\n+              if (event == ev->event) {\n+                changed_stream_id = FALSE;\n+                break;\n+              }\n+\n+              const gchar *old_stream_id, *new_stream_id;\n+\n+              gst_event_parse_stream_start (ev->event, &old_stream_id);\n+              gst_event_parse_stream_start (event, &new_stream_id);\n+\n+              changed_stream_id = !g_str_equal (old_stream_id, new_stream_id);\n+\n+              break;\n+            }\n+          }\n+\n@@ -5926,1 +6040,0 @@\n-          remove_event_by_type (pad, GST_EVENT_TAG);\n@@ -5928,0 +6041,12 @@\n+\n+          if (changed_stream_id) {\n+            GST_LOG_OBJECT (pad, \"Removing pending TAG events\");\n+            remove_event_by_type (pad, GST_EVENT_TAG);\n+          }\n+          break;\n+        }\n+        case GST_EVENT_RECONFIGURE:\n+          if (GST_PAD_IS_SRC (pad))\n+            GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);\n+          if (pad->ABI.abi.last_flowret == GST_FLOW_NOT_LINKED)\n+            pad->ABI.abi.last_flowret = GST_FLOW_OK;\n@@ -6020,1 +6145,1 @@\n-  return ret;\n+  goto done;\n@@ -6031,1 +6156,2 @@\n-    return GST_FLOW_FLUSHING;\n+    ret = GST_FLOW_FLUSHING;\n+    goto done;\n@@ -6041,1 +6167,2 @@\n-    return GST_FLOW_FLUSHING;\n+    ret = GST_FLOW_FLUSHING;\n+    goto done;\n@@ -6051,1 +6178,2 @@\n-    return GST_FLOW_EOS;\n+    ret = GST_FLOW_EOS;\n+    goto done;\n@@ -6072,1 +6200,1 @@\n-    return ret;\n+    goto done;\n@@ -6082,1 +6210,2 @@\n-    return GST_FLOW_NOT_SUPPORTED;\n+    ret = GST_FLOW_NOT_SUPPORTED;\n+    goto done;\n@@ -6091,1 +6220,2 @@\n-    return GST_FLOW_FLUSHING;\n+    ret = GST_FLOW_FLUSHING;\n+    goto done;\n@@ -6100,1 +6230,1 @@\n-    return ret;\n+    goto done;\n@@ -6102,0 +6232,3 @@\n+done:\n+  GST_TRACER_PAD_SEND_EVENT_POST (pad, ret);\n+  return ret;\n@@ -6262,3 +6395,3 @@\n- * @foreach_func: (scope call): the #GstPadStickyEventsForeachFunction that\n- *                should be called for every event.\n- * @user_data: (closure): the optional user data.\n+ * @foreach_func: (scope call) (closure user_data): the\n+ *    #GstPadStickyEventsForeachFunction that should be called for every event.\n+ * @user_data: the optional user data.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstpad.c","additions":174,"deletions":41,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -551,0 +551,1 @@\n+      \/* G_PARAM_CONSTRUCT_ONLY *\/\n@@ -562,0 +563,1 @@\n+      \/* G_PARAM_CONSTRUCT_ONLY *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstpadtemplate.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -696,3 +696,0 @@\n-  if (latency == GST_CLOCK_TIME_NONE)\n-    return GST_BIN_CLASS (parent_class)->do_latency (bin);\n-\n@@ -707,4 +704,0 @@\n-    GST_OBJECT_LOCK (pipeline);\n-    pipeline->priv->min_latency = min_latency;\n-    GST_OBJECT_UNLOCK (pipeline);\n-\n@@ -725,7 +718,21 @@\n-    if (latency < min_latency) {\n-      \/* This is a problematic situation as we will most likely drop lots of\n-       * data if we configure a too low latency *\/\n-      GST_ELEMENT_WARNING (pipeline, CORE, CLOCK, (NULL),\n-          (\"Configured latency is lower than detected minimum latency: configured %\"\n-              GST_TIME_FORMAT \" < min %\" GST_TIME_FORMAT,\n-              GST_TIME_ARGS (latency), GST_TIME_ARGS (min_latency)));\n+    \/* If no static latency was configured then select the minimum latency *\/\n+    if (latency == GST_CLOCK_TIME_NONE) {\n+      latency = min_latency;\n+    } else {\n+      if (latency < min_latency) {\n+        \/* This is a problematic situation as we will most likely drop lots of\n+         * data if we configure a too low latency *\/\n+        GST_ELEMENT_WARNING (pipeline, CORE, CLOCK, (NULL),\n+            (\"Configured latency is lower than detected minimum latency: configured %\"\n+                GST_TIME_FORMAT \" < min %\" GST_TIME_FORMAT,\n+                GST_TIME_ARGS (latency), GST_TIME_ARGS (min_latency)));\n+      }\n+      if (max_latency < latency) {\n+        \/* and this is basically the same check as further above. There is not\n+         * enough buffering and the pipeline might not work correctly. *\/\n+        GST_ELEMENT_WARNING (pipeline, CORE, CLOCK, (NULL),\n+            (\"Impossible to configure latency: max %\" GST_TIME_FORMAT\n+                \" < configured %\" GST_TIME_FORMAT\n+                \". Add queues or other buffering elements.\",\n+                GST_TIME_ARGS (max_latency), GST_TIME_ARGS (latency)));\n+      }\n@@ -740,11 +747,17 @@\n-  \/* configure latency on elements *\/\n-  res =\n-      gst_element_send_event (GST_ELEMENT_CAST (pipeline),\n-      gst_event_new_latency (latency));\n-  if (res) {\n-    GST_INFO_OBJECT (pipeline, \"configured latency of %\" GST_TIME_FORMAT,\n-        GST_TIME_ARGS (latency));\n-  } else {\n-    GST_WARNING_OBJECT (pipeline,\n-        \"did not really configure latency of %\" GST_TIME_FORMAT,\n-        GST_TIME_ARGS (latency));\n+  if (latency != GST_CLOCK_TIME_NONE) {\n+    GST_OBJECT_LOCK (pipeline);\n+    pipeline->priv->min_latency = latency;\n+    GST_OBJECT_UNLOCK (pipeline);\n+\n+    \/* configure latency on elements *\/\n+    res =\n+        gst_element_send_event (GST_ELEMENT_CAST (pipeline),\n+        gst_event_new_latency (latency));\n+    if (res) {\n+      GST_INFO_OBJECT (pipeline, \"configured latency of %\" GST_TIME_FORMAT,\n+          GST_TIME_ARGS (latency));\n+    } else {\n+      GST_WARNING_OBJECT (pipeline,\n+          \"did not really configure latency of %\" GST_TIME_FORMAT,\n+          GST_TIME_ARGS (latency));\n+    }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstpipeline.c","additions":38,"deletions":25,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -328,0 +328,4 @@\n+  _priv_gst_plugin_api_quark = g_quark_from_static_string (\"plugin-api\");\n+  _priv_gst_plugin_api_flags_quark =\n+      g_quark_from_static_string (\"plugin-api-flags\");\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstplugin.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,100 +0,0 @@\n-\/* GStreamer\n- * Copyright (C) 2006 Jan Schmidt <thaytan@noraisin.net>\n- *\n- * gstquark.c: Registered quarks for the _priv_gst_quark_table, private to\n- *   GStreamer\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Library General Public\n- * License as published by the Free Software Foundation; either\n- * version 2 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Library General Public License for more details.\n- *\n- * You should have received a copy of the GNU Library General Public\n- * License along with this library; if not, write to the\n- * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n- * Boston, MA 02110-1301, USA.\n- *\/\n-\n-#include \"gst_private.h\"\n-#include \"gstquark.h\"\n-#include \"gstelementmetadata.h\"\n-\n-\/* These strings must match order and number declared in the GstQuarkId\n- * enum in gstquark.h! *\/\n-static const gchar *_quark_strings[] = {\n-  \"format\", \"current\", \"duration\", \"rate\",\n-  \"seekable\", \"segment-start\", \"segment-end\",\n-  \"src_format\", \"src_value\", \"dest_format\", \"dest_value\",\n-  \"start_format\", \"start_value\", \"stop_format\", \"stop_value\",\n-  \"gerror\", \"debug\", \"buffer-percent\", \"buffering-mode\",\n-  \"avg-in-rate\", \"avg-out-rate\", \"buffering-left\",\n-  \"estimated-total\", \"old-state\", \"new-state\", \"pending-state\",\n-  \"clock\", \"ready\", \"position\", \"reset-time\", \"live\", \"min-latency\",\n-  \"max-latency\", \"busy\", \"type\", \"owner\", \"update\", \"applied-rate\",\n-  \"start\", \"stop\", \"minsize\", \"maxsize\", \"async\", \"proportion\",\n-  \"diff\", \"timestamp\", \"flags\", \"cur-type\", \"cur\", \"stop-type\",\n-  \"latency\", \"uri\", \"object\", \"taglist\", \"GstEventSegment\",\n-  \"GstEventBufferSize\", \"GstEventQOS\", \"GstEventSeek\", \"GstEventLatency\",\n-  \"GstMessageError\", \"GstMessageWarning\", \"GstMessageInfo\",\n-  \"GstMessageBuffering\", \"GstMessageStateChanged\", \"GstMessageClockProvide\",\n-  \"GstMessageClockLost\", \"GstMessageNewClock\", \"GstMessageStructureChange\",\n-  \"GstMessageSegmentStart\", \"GstMessageSegmentDone\",\n-  \"GstMessageDurationChanged\",\n-  \"GstMessageAsyncDone\", \"GstMessageRequestState\", \"GstMessageStreamStatus\",\n-  \"GstQueryPosition\", \"GstQueryDuration\", \"GstQueryLatency\", \"GstQueryConvert\",\n-  \"GstQuerySegment\", \"GstQuerySeeking\", \"GstQueryFormats\", \"GstQueryBuffering\",\n-  \"GstQueryURI\", \"GstEventStep\", \"GstMessageStepDone\", \"amount\", \"flush\",\n-  \"intermediate\", \"GstMessageStepStart\", \"active\", \"eos\", \"sink-message\",\n-  \"message\", \"GstMessageQOS\", \"running-time\", \"stream-time\", \"jitter\",\n-  \"quality\", \"processed\", \"dropped\", \"buffering-ranges\", \"GstMessageProgress\",\n-  \"code\", \"text\", \"percent\", \"timeout\", \"GstBufferPoolConfig\", \"caps\", \"size\",\n-  \"min-buffers\", \"max-buffers\", \"prefix\", \"padding\", \"align\", \"time\",\n-  \"GstQueryAllocation\", \"need-pool\", \"meta\", \"pool\", \"GstEventCaps\",\n-  \"GstEventReconfigure\", \"segment\", \"GstQueryScheduling\", \"pull-mode\",\n-  \"allocator\", \"GstEventFlushStop\", \"options\", \"GstQueryAcceptCaps\",\n-  \"result\", \"GstQueryCaps\", \"filter\", \"modes\", \"GstEventStreamConfig\",\n-  \"setup-data\", \"stream-headers\", \"GstEventGap\", \"GstQueryDrain\", \"params\",\n-  \"GstEventTocSelect\", \"uid\", \"GstQueryToc\", GST_ELEMENT_METADATA_LONGNAME,\n-  GST_ELEMENT_METADATA_KLASS, GST_ELEMENT_METADATA_DESCRIPTION,\n-  GST_ELEMENT_METADATA_AUTHOR, \"toc\", \"toc-entry\", \"updated\", \"extend-uid\",\n-  \"uid\", \"tags\", \"sub-entries\", \"info\", \"GstMessageTag\", \"GstEventTag\",\n-  \"GstMessageResetTime\",\n-  \"GstMessageToc\", \"GstEventTocGlobal\", \"GstEventTocCurrent\",\n-  \"GstEventSegmentDone\",\n-  \"GstEventStreamStart\", \"stream-id\", \"GstQueryContext\",\n-  \"GstMessageNeedContext\", \"GstMessageHaveContext\", \"context\", \"context-type\",\n-  \"GstMessageStreamStart\", \"group-id\", \"uri-redirection\",\n-  \"GstMessageDeviceAdded\", \"GstMessageDeviceRemoved\", \"device\",\n-  \"uri-redirection-permanent\", \"GstMessagePropertyNotify\", \"property-name\",\n-  \"property-value\", \"streams\", \"GstEventSelectStreams\",\n-  \"GstMessageStreamCollection\", \"collection\", \"stream\", \"stream-collection\",\n-  \"GstMessageStreamsSelected\", \"GstMessageRedirect\", \"redirect-entry-locations\",\n-  \"redirect-entry-taglists\", \"redirect-entry-structures\",\n-  \"GstEventStreamGroupDone\", \"GstQueryBitrate\", \"nominal-bitrate\",\n-  \"GstMessageDeviceChanged\", \"device-changed\", \"trickmode-interval\",\n-  \"GstEventInstantRateChange\",\n-  \"GstEventInstantRateSyncTime\", \"GstMessageInstantRateRequest\",\n-  \"upstream-running-time\", \"base\", \"offset\", \"plugin-api\", \"plugin-api-flags\",\n-  \"gap-flags\", \"GstQuerySelectable\", \"selectable\"\n-};\n-\n-GQuark _priv_gst_quark_table[GST_QUARK_MAX];\n-\n-void\n-_priv_gst_quarks_initialize (void)\n-{\n-  gint i;\n-\n-  if (G_N_ELEMENTS (_quark_strings) != GST_QUARK_MAX)\n-    g_warning (\"the quark table is not consistent! %d != %d\",\n-        (int) G_N_ELEMENTS (_quark_strings), GST_QUARK_MAX);\n-\n-  for (i = 0; i < GST_QUARK_MAX; i++) {\n-    _priv_gst_quark_table[i] = g_quark_from_static_string (_quark_strings[i]);\n-  }\n-}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstquark.c","additions":0,"deletions":100,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -1,243 +0,0 @@\n-\/* GStreamer\n- * Copyright (C) 2006 Jan Schmidt <thaytan@noraisin.net>\n- *\n- * gstquark.h: Private header for storing quark info\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Library General Public\n- * License as published by the Free Software Foundation; either\n- * version 2 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Library General Public License for more details.\n- *\n- * You should have received a copy of the GNU Library General Public\n- * License along with this library; if not, write to the\n- * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n- * Boston, MA 02110-1301, USA.\n- *\/\n-\n-#ifndef __GST_QUARK_H__\n-#define __GST_QUARK_H__\n-\n-#include <glib.h>\n-\n-\/* These enums need to match the number and order\n- * of strings declared in _quark_table, in gstquark.c *\/\n-typedef enum _GstQuarkId\n-{\n-  GST_QUARK_FORMAT = 0,\n-  GST_QUARK_CURRENT = 1,\n-  GST_QUARK_DURATION = 2,\n-  GST_QUARK_RATE = 3,\n-  GST_QUARK_SEEKABLE = 4,\n-  GST_QUARK_SEGMENT_START = 5,\n-  GST_QUARK_SEGMENT_END = 6,\n-  GST_QUARK_SRC_FORMAT = 7,\n-  GST_QUARK_SRC_VALUE = 8,\n-  GST_QUARK_DEST_FORMAT = 9,\n-  GST_QUARK_DEST_VALUE = 10,\n-  GST_QUARK_START_FORMAT = 11,\n-  GST_QUARK_START_VALUE = 12,\n-  GST_QUARK_STOP_FORMAT = 13,\n-  GST_QUARK_STOP_VALUE = 14,\n-  GST_QUARK_GERROR = 15,\n-  GST_QUARK_DEBUG = 16,\n-  GST_QUARK_BUFFER_PERCENT = 17,\n-  GST_QUARK_BUFFERING_MODE = 18,\n-  GST_QUARK_AVG_IN_RATE = 19,\n-  GST_QUARK_AVG_OUT_RATE = 20,\n-  GST_QUARK_BUFFERING_LEFT = 21,\n-  GST_QUARK_ESTIMATED_TOTAL = 22,\n-  GST_QUARK_OLD_STATE = 23,\n-  GST_QUARK_NEW_STATE = 24,\n-  GST_QUARK_PENDING_STATE = 25,\n-  GST_QUARK_CLOCK = 26,\n-  GST_QUARK_READY = 27,\n-  GST_QUARK_POSITION = 28,\n-  GST_QUARK_RESET_TIME = 29,\n-  GST_QUARK_LIVE = 30,\n-  GST_QUARK_MIN_LATENCY = 31,\n-  GST_QUARK_MAX_LATENCY = 32,\n-  GST_QUARK_BUSY = 33,\n-  GST_QUARK_TYPE = 34,\n-  GST_QUARK_OWNER = 35,\n-  GST_QUARK_UPDATE = 36,\n-  GST_QUARK_APPLIED_RATE = 37,\n-  GST_QUARK_START = 38,\n-  GST_QUARK_STOP = 39,\n-  GST_QUARK_MINSIZE = 40,\n-  GST_QUARK_MAXSIZE = 41,\n-  GST_QUARK_ASYNC = 42,\n-  GST_QUARK_PROPORTION = 43,\n-  GST_QUARK_DIFF = 44,\n-  GST_QUARK_TIMESTAMP = 45,\n-  GST_QUARK_FLAGS = 46,\n-  GST_QUARK_CUR_TYPE = 47,\n-  GST_QUARK_CUR = 48,\n-  GST_QUARK_STOP_TYPE = 49,\n-  GST_QUARK_LATENCY = 50,\n-  GST_QUARK_URI = 51,\n-  GST_QUARK_OBJECT = 52,\n-  GST_QUARK_TAGLIST = 53,\n-  GST_QUARK_EVENT_SEGMENT = 54,\n-  GST_QUARK_EVENT_BUFFER_SIZE = 55,\n-  GST_QUARK_EVENT_QOS = 56,\n-  GST_QUARK_EVENT_SEEK = 57,\n-  GST_QUARK_EVENT_LATENCY = 58,\n-  GST_QUARK_MESSAGE_ERROR = 59,\n-  GST_QUARK_MESSAGE_WARNING = 60,\n-  GST_QUARK_MESSAGE_INFO = 61,\n-  GST_QUARK_MESSAGE_BUFFERING = 62,\n-  GST_QUARK_MESSAGE_STATE_CHANGED = 63,\n-  GST_QUARK_MESSAGE_CLOCK_PROVIDE = 64,\n-  GST_QUARK_MESSAGE_CLOCK_LOST = 65,\n-  GST_QUARK_MESSAGE_NEW_CLOCK = 66,\n-  GST_QUARK_MESSAGE_STRUCTURE_CHANGE = 67,\n-  GST_QUARK_MESSAGE_SEGMENT_START = 68,\n-  GST_QUARK_MESSAGE_SEGMENT_DONE = 69,\n-  GST_QUARK_MESSAGE_DURATION_CHANGED = 70,\n-  GST_QUARK_MESSAGE_ASYNC_DONE = 71,\n-  GST_QUARK_MESSAGE_REQUEST_STATE = 72,\n-  GST_QUARK_MESSAGE_STREAM_STATUS = 73,\n-  GST_QUARK_QUERY_POSITION = 74,\n-  GST_QUARK_QUERY_DURATION = 75,\n-  GST_QUARK_QUERY_LATENCY = 76,\n-  GST_QUARK_QUERY_CONVERT = 77,\n-  GST_QUARK_QUERY_SEGMENT = 78,\n-  GST_QUARK_QUERY_SEEKING = 79,\n-  GST_QUARK_QUERY_FORMATS = 80,\n-  GST_QUARK_QUERY_BUFFERING = 81,\n-  GST_QUARK_QUERY_URI = 82,\n-  GST_QUARK_EVENT_STEP = 83,\n-  GST_QUARK_MESSAGE_STEP_DONE = 84,\n-  GST_QUARK_AMOUNT = 85,\n-  GST_QUARK_FLUSH = 86,\n-  GST_QUARK_INTERMEDIATE = 87,\n-  GST_QUARK_MESSAGE_STEP_START = 88,\n-  GST_QUARK_ACTIVE = 89,\n-  GST_QUARK_EOS = 90,\n-  GST_QUARK_EVENT_SINK_MESSAGE = 91,\n-  GST_QUARK_MESSAGE = 92,\n-  GST_QUARK_MESSAGE_QOS = 93,\n-  GST_QUARK_RUNNING_TIME = 94,\n-  GST_QUARK_STREAM_TIME = 95,\n-  GST_QUARK_JITTER = 96,\n-  GST_QUARK_QUALITY = 97,\n-  GST_QUARK_PROCESSED = 98,\n-  GST_QUARK_DROPPED = 99,\n-  GST_QUARK_BUFFERING_RANGES = 100,\n-  GST_QUARK_MESSAGE_PROGRESS = 101,\n-  GST_QUARK_CODE = 102,\n-  GST_QUARK_TEXT = 103,\n-  GST_QUARK_PERCENT = 104,\n-  GST_QUARK_TIMEOUT = 105,\n-  GST_QUARK_BUFFER_POOL_CONFIG = 106,\n-  GST_QUARK_CAPS = 107,\n-  GST_QUARK_SIZE = 108,\n-  GST_QUARK_MIN_BUFFERS = 109,\n-  GST_QUARK_MAX_BUFFERS = 110,\n-  GST_QUARK_PREFIX = 111,\n-  GST_QUARK_PADDING = 112,\n-  GST_QUARK_ALIGN = 113,\n-  GST_QUARK_TIME = 114,\n-  GST_QUARK_QUERY_ALLOCATION = 115,\n-  GST_QUARK_NEED_POOL = 116,\n-  GST_QUARK_META = 117,\n-  GST_QUARK_POOL = 118,\n-  GST_QUARK_EVENT_CAPS = 119,\n-  GST_QUARK_EVENT_RECONFIGURE = 120,\n-  GST_QUARK_SEGMENT = 121,\n-  GST_QUARK_QUERY_SCHEDULING = 122,\n-  GST_QUARK_PULL_MODE = 123,\n-  GST_QUARK_ALLOCATOR = 124,\n-  GST_QUARK_EVENT_FLUSH_STOP = 125,\n-  GST_QUARK_OPTIONS = 126,\n-  GST_QUARK_QUERY_ACCEPT_CAPS = 127,\n-  GST_QUARK_RESULT = 128,\n-  GST_QUARK_QUERY_CAPS = 129,\n-  GST_QUARK_FILTER = 130,\n-  GST_QUARK_MODES = 131,\n-  GST_QUARK_EVENT_STREAM_CONFIG = 132,\n-  GST_QUARK_SETUP_DATA = 133,\n-  GST_QUARK_STREAM_HEADERS = 134,\n-  GST_QUARK_EVENT_GAP = 135,\n-  GST_QUARK_QUERY_DRAIN = 136,\n-  GST_QUARK_PARAMS = 137,\n-  GST_QUARK_EVENT_TOC_SELECT = 138,\n-  GST_QUARK_UID = 139,\n-  GST_QUARK_QUERY_TOC = 140,\n-  GST_QUARK_ELEMENT_METADATA_LONGNAME = 141,\n-  GST_QUARK_ELEMENT_METADATA_KLASS = 142,\n-  GST_QUARK_ELEMENT_METADATA_DESCRIPTION = 143,\n-  GST_QUARK_ELEMENT_METADATA_AUTHOR = 144,\n-  GST_QUARK_TOC = 145,\n-  GST_QUARK_TOC_ENTRY = 146,\n-  GST_QUARK_UPDATED = 147,\n-  GST_QUARK_EXTEND_UID = 148,\n-  GST_QUARK_TOC_UID = 149,\n-  GST_QUARK_TAGS = 150,\n-  GST_QUARK_SUB_ENTRIES = 151,\n-  GST_QUARK_INFO = 152,\n-  GST_QUARK_MESSAGE_TAG = 153,\n-  GST_QUARK_EVENT_TAG = 154,\n-  GST_QUARK_MESSAGE_RESET_TIME = 155,\n-  GST_QUARK_MESSAGE_TOC = 156,\n-  GST_QUARK_EVENT_TOC_GLOBAL = 157,\n-  GST_QUARK_EVENT_TOC_CURRENT = 158,\n-  GST_QUARK_EVENT_SEGMENT_DONE = 159,\n-  GST_QUARK_EVENT_STREAM_START = 160,\n-  GST_QUARK_STREAM_ID = 161,\n-  GST_QUARK_QUERY_CONTEXT = 162,\n-  GST_QUARK_MESSAGE_NEED_CONTEXT = 163,\n-  GST_QUARK_MESSAGE_HAVE_CONTEXT = 164,\n-  GST_QUARK_CONTEXT = 165,\n-  GST_QUARK_CONTEXT_TYPE = 166,\n-  GST_QUARK_MESSAGE_STREAM_START = 167,\n-  GST_QUARK_GROUP_ID = 168,\n-  GST_QUARK_URI_REDIRECTION = 169,\n-  GST_QUARK_MESSAGE_DEVICE_ADDED = 170,\n-  GST_QUARK_MESSAGE_DEVICE_REMOVED = 171,\n-  GST_QUARK_DEVICE = 172,\n-  GST_QUARK_URI_REDIRECTION_PERMANENT = 173,\n-  GST_QUARK_MESSAGE_PROPERTY_NOTIFY = 174,\n-  GST_QUARK_PROPERTY_NAME = 175,\n-  GST_QUARK_PROPERTY_VALUE = 176,\n-  GST_QUARK_STREAMS = 177,\n-  GST_QUARK_EVENT_SELECT_STREAMS = 178,\n-  GST_QUARK_MESSAGE_STREAM_COLLECTION = 179,\n-  GST_QUARK_COLLECTION = 180,\n-  GST_QUARK_STREAM = 181,\n-  GST_QUARK_EVENT_STREAM_COLLECTION = 182,\n-  GST_QUARK_MESSAGE_STREAMS_SELECTED = 183,\n-  GST_QUARK_MESSAGE_REDIRECT = 184,\n-  GST_QUARK_REDIRECT_ENTRY_LOCATIONS = 185,\n-  GST_QUARK_REDIRECT_ENTRY_TAGLISTS = 186,\n-  GST_QUARK_REDIRECT_ENTRY_STRUCTURES = 187,\n-  GST_QUARK_EVENT_STREAM_GROUP_DONE = 188,\n-  GST_QUARK_QUERY_BITRATE = 189,\n-  GST_QUARK_NOMINAL_BITRATE = 190,\n-  GST_QUARK_MESSAGE_DEVICE_CHANGED = 191,\n-  GST_QUARK_DEVICE_CHANGED = 192,\n-  GST_QUARK_TRICKMODE_INTERVAL = 193,\n-  GST_QUARK_EVENT_INSTANT_RATE_CHANGE = 194,\n-  GST_QUARK_EVENT_INSTANT_RATE_SYNC_TIME = 195,\n-  GST_QUARK_MESSAGE_INSTANT_RATE_REQUEST = 196,\n-  GST_QUARK_UPSTREAM_RUNNING_TIME = 197,\n-  GST_QUARK_BASE = 198,\n-  GST_QUARK_OFFSET = 199,\n-  GST_QUARK_PLUGIN_API = 200,\n-  GST_QUARK_PLUGIN_API_FLAGS = 201,\n-  GST_QUARK_GAP_FLAGS = 202,\n-  GST_QUARK_QUERY_SELECTABLE = 203,\n-  GST_QUARK_SELECTABLE = 204,\n-  GST_QUARK_MAX = 205\n-} GstQuarkId;\n-\n-extern GQuark _priv_gst_quark_table[GST_QUARK_MAX];\n-\n-#define GST_QUARK(q) _priv_gst_quark_table[GST_QUARK_##q]\n-\n-#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstquark.h","additions":0,"deletions":243,"binary":false,"changes":243,"status":"modified"},{"patch":"@@ -62,3 +62,0 @@\n-#include \"gstquark.h\"\n-#include \"gsturi.h\"\n-#include \"gstbufferpool.h\"\n@@ -240,3 +237,3 @@\n-  structure = gst_structure_new_id (GST_QUARK (QUERY_POSITION),\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (CURRENT), G_TYPE_INT64, G_GINT64_CONSTANT (-1), NULL);\n+  structure = gst_structure_new_static_str (\"GstQueryPosition\",\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"current\", G_TYPE_INT64, G_GINT64_CONSTANT (-1), NULL);\n@@ -265,2 +262,2 @@\n-  g_return_if_fail (format == g_value_get_enum (gst_structure_id_get_value (s,\n-              GST_QUARK (FORMAT))));\n+  g_return_if_fail (format == g_value_get_enum (gst_structure_get_value (s,\n+              \"format\")));\n@@ -268,3 +265,2 @@\n-  gst_structure_id_set (s,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (CURRENT), G_TYPE_INT64, cur, NULL);\n+  gst_structure_set (s,\n+      \"format\", GST_TYPE_FORMAT, format, \"current\", G_TYPE_INT64, cur, NULL);\n@@ -293,2 +289,2 @@\n-        (GstFormat) g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (FORMAT)));\n+        (GstFormat) g_value_get_enum (gst_structure_get_value (structure,\n+            \"format\"));\n@@ -296,2 +292,1 @@\n-    *cur = g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (CURRENT)));\n+    *cur = g_value_get_int64 (gst_structure_get_value (structure, \"current\"));\n@@ -319,3 +314,3 @@\n-  structure = gst_structure_new_id (GST_QUARK (QUERY_DURATION),\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (DURATION), G_TYPE_INT64, G_GINT64_CONSTANT (-1), NULL);\n+  structure = gst_structure_new_static_str (\"GstQueryDuration\",\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"duration\", G_TYPE_INT64, G_GINT64_CONSTANT (-1), NULL);\n@@ -344,4 +339,4 @@\n-  g_return_if_fail (format == g_value_get_enum (gst_structure_id_get_value (s,\n-              GST_QUARK (FORMAT))));\n-  gst_structure_id_set (s, GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (DURATION), G_TYPE_INT64, duration, NULL);\n+  g_return_if_fail (format == g_value_get_enum (gst_structure_get_value (s,\n+              \"format\")));\n+  gst_structure_set (s, \"format\", GST_TYPE_FORMAT, format,\n+      \"duration\", G_TYPE_INT64, duration, NULL);\n@@ -371,2 +366,2 @@\n-        (GstFormat) g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (FORMAT)));\n+        (GstFormat) g_value_get_enum (gst_structure_get_value (structure,\n+            \"format\"));\n@@ -374,2 +369,2 @@\n-    *duration = g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (DURATION)));\n+    *duration = g_value_get_int64 (gst_structure_get_value (structure,\n+            \"duration\"));\n@@ -396,4 +391,4 @@\n-  structure = gst_structure_new_id (GST_QUARK (QUERY_LATENCY),\n-      GST_QUARK (LIVE), G_TYPE_BOOLEAN, FALSE,\n-      GST_QUARK (MIN_LATENCY), G_TYPE_UINT64, G_GUINT64_CONSTANT (0),\n-      GST_QUARK (MAX_LATENCY), G_TYPE_UINT64, GST_CLOCK_TIME_NONE, NULL);\n+  structure = gst_structure_new_static_str (\"GstQueryLatency\",\n+      \"live\", G_TYPE_BOOLEAN, FALSE,\n+      \"min-latency\", G_TYPE_UINT64, G_GUINT64_CONSTANT (0),\n+      \"max-latency\", G_TYPE_UINT64, GST_CLOCK_TIME_NONE, NULL);\n@@ -425,4 +420,4 @@\n-  gst_structure_id_set (structure,\n-      GST_QUARK (LIVE), G_TYPE_BOOLEAN, live,\n-      GST_QUARK (MIN_LATENCY), G_TYPE_UINT64, min_latency,\n-      GST_QUARK (MAX_LATENCY), G_TYPE_UINT64, max_latency, NULL);\n+  gst_structure_set (structure,\n+      \"live\", G_TYPE_BOOLEAN, live,\n+      \"min-latency\", G_TYPE_UINT64, min_latency,\n+      \"max-latency\", G_TYPE_UINT64, max_latency, NULL);\n@@ -450,3 +445,1 @@\n-    *live =\n-        g_value_get_boolean (gst_structure_id_get_value (structure,\n-            GST_QUARK (LIVE)));\n+    *live = g_value_get_boolean (gst_structure_get_value (structure, \"live\"));\n@@ -454,2 +447,2 @@\n-    *min_latency = g_value_get_uint64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (MIN_LATENCY)));\n+    *min_latency = g_value_get_uint64 (gst_structure_get_value (structure,\n+            \"min-latency\"));\n@@ -457,2 +450,2 @@\n-    *max_latency = g_value_get_uint64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (MAX_LATENCY)));\n+    *max_latency = g_value_get_uint64 (gst_structure_get_value (structure,\n+            \"max-latency\"));\n@@ -482,5 +475,5 @@\n-  structure = gst_structure_new_id (GST_QUARK (QUERY_CONVERT),\n-      GST_QUARK (SRC_FORMAT), GST_TYPE_FORMAT, src_format,\n-      GST_QUARK (SRC_VALUE), G_TYPE_INT64, value,\n-      GST_QUARK (DEST_FORMAT), GST_TYPE_FORMAT, dest_format,\n-      GST_QUARK (DEST_VALUE), G_TYPE_INT64, G_GINT64_CONSTANT (-1), NULL);\n+  structure = gst_structure_new_static_str (\"GstQueryConvert\",\n+      \"src_format\", GST_TYPE_FORMAT, src_format,\n+      \"src_value\", G_TYPE_INT64, value,\n+      \"dest_format\", GST_TYPE_FORMAT, dest_format,\n+      \"dest_value\", G_TYPE_INT64, G_GINT64_CONSTANT (-1), NULL);\n@@ -512,5 +505,5 @@\n-  gst_structure_id_set (structure,\n-      GST_QUARK (SRC_FORMAT), GST_TYPE_FORMAT, src_format,\n-      GST_QUARK (SRC_VALUE), G_TYPE_INT64, src_value,\n-      GST_QUARK (DEST_FORMAT), GST_TYPE_FORMAT, dest_format,\n-      GST_QUARK (DEST_VALUE), G_TYPE_INT64, dest_value, NULL);\n+  gst_structure_set (structure,\n+      \"src_format\", GST_TYPE_FORMAT, src_format,\n+      \"src_value\", G_TYPE_INT64, src_value,\n+      \"dest_format\", GST_TYPE_FORMAT, dest_format,\n+      \"dest_value\", G_TYPE_INT64, dest_value, NULL);\n@@ -544,2 +537,2 @@\n-        (GstFormat) g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (SRC_FORMAT)));\n+        (GstFormat) g_value_get_enum (gst_structure_get_value (structure,\n+            \"src_format\"));\n@@ -547,2 +540,2 @@\n-    *src_value = g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (SRC_VALUE)));\n+    *src_value = g_value_get_int64 (gst_structure_get_value (structure,\n+            \"src_value\"));\n@@ -551,2 +544,2 @@\n-        (GstFormat) g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (DEST_FORMAT)));\n+        (GstFormat) g_value_get_enum (gst_structure_get_value (structure,\n+            \"dest_format\"));\n@@ -554,2 +547,2 @@\n-    *dest_value = g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (DEST_VALUE)));\n+    *dest_value = g_value_get_int64 (gst_structure_get_value (structure,\n+            \"dest_value\"));\n@@ -576,5 +569,5 @@\n-  structure = gst_structure_new_id (GST_QUARK (QUERY_SEGMENT),\n-      GST_QUARK (RATE), G_TYPE_DOUBLE, (gdouble) 0.0,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (START_VALUE), G_TYPE_INT64, G_GINT64_CONSTANT (-1),\n-      GST_QUARK (STOP_VALUE), G_TYPE_INT64, G_GINT64_CONSTANT (-1), NULL);\n+  structure = gst_structure_new_static_str (\"GstQuerySegment\",\n+      \"rate\", G_TYPE_DOUBLE, (gdouble) 0.0,\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"start_value\", G_TYPE_INT64, G_GINT64_CONSTANT (-1),\n+      \"stop_value\", G_TYPE_INT64, G_GINT64_CONSTANT (-1), NULL);\n@@ -616,5 +609,5 @@\n-  gst_structure_id_set (structure,\n-      GST_QUARK (RATE), G_TYPE_DOUBLE, rate,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (START_VALUE), G_TYPE_INT64, start_value,\n-      GST_QUARK (STOP_VALUE), G_TYPE_INT64, stop_value, NULL);\n+  gst_structure_set (structure,\n+      \"rate\", G_TYPE_DOUBLE, rate,\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"start_value\", G_TYPE_INT64, start_value,\n+      \"stop_value\", G_TYPE_INT64, stop_value, NULL);\n@@ -647,2 +640,1 @@\n-    *rate = g_value_get_double (gst_structure_id_get_value (structure,\n-            GST_QUARK (RATE)));\n+    *rate = g_value_get_double (gst_structure_get_value (structure, \"rate\"));\n@@ -651,2 +643,2 @@\n-        (GstFormat) g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (FORMAT)));\n+        (GstFormat) g_value_get_enum (gst_structure_get_value (structure,\n+            \"format\"));\n@@ -654,2 +646,2 @@\n-    *start_value = g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (START_VALUE)));\n+    *start_value = g_value_get_int64 (gst_structure_get_value (structure,\n+            \"start_value\"));\n@@ -657,2 +649,2 @@\n-    *stop_value = g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (STOP_VALUE)));\n+    *stop_value = g_value_get_int64 (gst_structure_get_value (structure,\n+            \"stop_value\"));\n@@ -748,2 +740,2 @@\n-        gst_structure_new_id_empty (gst_query_type_to_quark (GST_QUERY_TYPE\n-            (query)));\n+        gst_structure_new_static_str_empty (gst_query_type_get_name\n+        (GST_QUERY_TYPE (query)));\n@@ -773,5 +765,5 @@\n-  structure = gst_structure_new_id (GST_QUARK (QUERY_SEEKING),\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (SEEKABLE), G_TYPE_BOOLEAN, FALSE,\n-      GST_QUARK (SEGMENT_START), G_TYPE_INT64, G_GINT64_CONSTANT (-1),\n-      GST_QUARK (SEGMENT_END), G_TYPE_INT64, G_GINT64_CONSTANT (-1), NULL);\n+  structure = gst_structure_new_static_str (\"GstQuerySeeking\",\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"seekable\", G_TYPE_BOOLEAN, FALSE,\n+      \"segment-start\", G_TYPE_INT64, G_GINT64_CONSTANT (-1),\n+      \"segment-end\", G_TYPE_INT64, G_GINT64_CONSTANT (-1), NULL);\n@@ -804,5 +796,5 @@\n-  gst_structure_id_set (structure,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (SEEKABLE), G_TYPE_BOOLEAN, seekable,\n-      GST_QUARK (SEGMENT_START), G_TYPE_INT64, segment_start,\n-      GST_QUARK (SEGMENT_END), G_TYPE_INT64, segment_end, NULL);\n+  gst_structure_set (structure,\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"seekable\", G_TYPE_BOOLEAN, seekable,\n+      \"segment-start\", G_TYPE_INT64, segment_start,\n+      \"segment-end\", G_TYPE_INT64, segment_end, NULL);\n@@ -835,2 +827,2 @@\n-        (GstFormat) g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (FORMAT)));\n+        (GstFormat) g_value_get_enum (gst_structure_get_value (structure,\n+            \"format\"));\n@@ -838,2 +830,2 @@\n-    *seekable = g_value_get_boolean (gst_structure_id_get_value (structure,\n-            GST_QUARK (SEEKABLE)));\n+    *seekable = g_value_get_boolean (gst_structure_get_value (structure,\n+            \"seekable\"));\n@@ -841,2 +833,2 @@\n-    *segment_start = g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (SEGMENT_START)));\n+    *segment_start = g_value_get_int64 (gst_structure_get_value (structure,\n+            \"segment-start\"));\n@@ -844,2 +836,2 @@\n-    *segment_end = g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (SEGMENT_END)));\n+    *segment_end = g_value_get_int64 (gst_structure_get_value (structure,\n+            \"segment-end\"));\n@@ -849,1 +841,1 @@\n-ensure_array (GstStructure * s, GQuark quark, gsize element_size,\n+ensure_array (GstStructure * s, const gchar * fieldname, gsize element_size,\n@@ -855,1 +847,1 @@\n-  value = gst_structure_id_get_value (s, quark);\n+  value = gst_structure_get_value (s, fieldname);\n@@ -868,1 +860,1 @@\n-    gst_structure_id_take_value (s, quark, &new_array_val);\n+    gst_structure_take_value (s, fieldname, &new_array_val);\n@@ -889,1 +881,1 @@\n-  structure = gst_structure_new_id_empty (GST_QUARK (QUERY_FORMATS));\n+  structure = gst_structure_new_static_str_empty (\"GstQueryFormats\");\n@@ -1051,11 +1043,11 @@\n-  structure = gst_structure_new_id (GST_QUARK (QUERY_BUFFERING),\n-      GST_QUARK (BUSY), G_TYPE_BOOLEAN, FALSE,\n-      GST_QUARK (BUFFER_PERCENT), G_TYPE_INT, 100,\n-      GST_QUARK (BUFFERING_MODE), GST_TYPE_BUFFERING_MODE, GST_BUFFERING_STREAM,\n-      GST_QUARK (AVG_IN_RATE), G_TYPE_INT, -1,\n-      GST_QUARK (AVG_OUT_RATE), G_TYPE_INT, -1,\n-      GST_QUARK (BUFFERING_LEFT), G_TYPE_INT64, G_GINT64_CONSTANT (0),\n-      GST_QUARK (ESTIMATED_TOTAL), G_TYPE_INT64, G_GINT64_CONSTANT (-1),\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (START_VALUE), G_TYPE_INT64, G_GINT64_CONSTANT (-1),\n-      GST_QUARK (STOP_VALUE), G_TYPE_INT64, G_GINT64_CONSTANT (-1), NULL);\n+  structure = gst_structure_new_static_str (\"GstQueryBuffering\",\n+      \"busy\", G_TYPE_BOOLEAN, FALSE,\n+      \"buffer-percent\", G_TYPE_INT, 100,\n+      \"buffering-mode\", GST_TYPE_BUFFERING_MODE, GST_BUFFERING_STREAM,\n+      \"avg-in-rate\", G_TYPE_INT, -1,\n+      \"avg-out-rate\", G_TYPE_INT, -1,\n+      \"buffering-left\", G_TYPE_INT64, G_GINT64_CONSTANT (0),\n+      \"estimated-total\", G_TYPE_INT64, G_GINT64_CONSTANT (-1),\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"start_value\", G_TYPE_INT64, G_GINT64_CONSTANT (-1),\n+      \"stop_value\", G_TYPE_INT64, G_GINT64_CONSTANT (-1), NULL);\n@@ -1087,3 +1079,3 @@\n-  gst_structure_id_set (structure,\n-      GST_QUARK (BUSY), G_TYPE_BOOLEAN, busy,\n-      GST_QUARK (BUFFER_PERCENT), G_TYPE_INT, percent, NULL);\n+  gst_structure_set (structure,\n+      \"busy\", G_TYPE_BOOLEAN, busy,\n+      \"buffer-percent\", G_TYPE_INT, percent, NULL);\n@@ -1111,2 +1103,1 @@\n-    *busy = g_value_get_boolean (gst_structure_id_get_value (structure,\n-            GST_QUARK (BUSY)));\n+    *busy = g_value_get_boolean (gst_structure_get_value (structure, \"busy\"));\n@@ -1114,2 +1105,2 @@\n-    *percent = g_value_get_int (gst_structure_id_get_value (structure,\n-            GST_QUARK (BUFFER_PERCENT)));\n+    *percent = g_value_get_int (gst_structure_get_value (structure,\n+            \"buffer-percent\"));\n@@ -1138,5 +1129,5 @@\n-  gst_structure_id_set (structure,\n-      GST_QUARK (BUFFERING_MODE), GST_TYPE_BUFFERING_MODE, mode,\n-      GST_QUARK (AVG_IN_RATE), G_TYPE_INT, avg_in,\n-      GST_QUARK (AVG_OUT_RATE), G_TYPE_INT, avg_out,\n-      GST_QUARK (BUFFERING_LEFT), G_TYPE_INT64, buffering_left, NULL);\n+  gst_structure_set (structure,\n+      \"buffering-mode\", GST_TYPE_BUFFERING_MODE, mode,\n+      \"avg-in-rate\", G_TYPE_INT, avg_in,\n+      \"avg-out-rate\", G_TYPE_INT, avg_out,\n+      \"buffering-left\", G_TYPE_INT64, buffering_left, NULL);\n@@ -1168,2 +1159,2 @@\n-        g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (BUFFERING_MODE)));\n+        g_value_get_enum (gst_structure_get_value (structure,\n+            \"buffering-mode\"));\n@@ -1171,2 +1162,2 @@\n-    *avg_in = g_value_get_int (gst_structure_id_get_value (structure,\n-            GST_QUARK (AVG_IN_RATE)));\n+    *avg_in = g_value_get_int (gst_structure_get_value (structure,\n+            \"avg-in-rate\"));\n@@ -1174,2 +1165,2 @@\n-    *avg_out = g_value_get_int (gst_structure_id_get_value (structure,\n-            GST_QUARK (AVG_OUT_RATE)));\n+    *avg_out = g_value_get_int (gst_structure_get_value (structure,\n+            \"avg-out-rate\"));\n@@ -1178,2 +1169,2 @@\n-        g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (BUFFERING_LEFT)));\n+        g_value_get_int64 (gst_structure_get_value (structure,\n+            \"buffering-left\"));\n@@ -1203,5 +1194,5 @@\n-  gst_structure_id_set (structure,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,\n-      GST_QUARK (START_VALUE), G_TYPE_INT64, start,\n-      GST_QUARK (STOP_VALUE), G_TYPE_INT64, stop,\n-      GST_QUARK (ESTIMATED_TOTAL), G_TYPE_INT64, estimated_total, NULL);\n+  gst_structure_set (structure,\n+      \"format\", GST_TYPE_FORMAT, format,\n+      \"start_value\", G_TYPE_INT64, start,\n+      \"stop_value\", G_TYPE_INT64, stop,\n+      \"estimated-total\", G_TYPE_INT64, estimated_total, NULL);\n@@ -1235,2 +1226,2 @@\n-        (GstFormat) g_value_get_enum (gst_structure_id_get_value (structure,\n-            GST_QUARK (FORMAT)));\n+        (GstFormat) g_value_get_enum (gst_structure_get_value (structure,\n+            \"format\"));\n@@ -1238,2 +1229,2 @@\n-    *start = g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (START_VALUE)));\n+    *start = g_value_get_int64 (gst_structure_get_value (structure,\n+            \"start_value\"));\n@@ -1241,2 +1232,2 @@\n-    *stop = g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (STOP_VALUE)));\n+    *stop = g_value_get_int64 (gst_structure_get_value (structure,\n+            \"stop_value\"));\n@@ -1245,2 +1236,2 @@\n-        g_value_get_int64 (gst_structure_id_get_value (structure,\n-            GST_QUARK (ESTIMATED_TOTAL)));\n+        g_value_get_int64 (gst_structure_get_value (structure,\n+            \"estimated-total\"));\n@@ -1281,1 +1272,1 @@\n-  array = ensure_array (structure, GST_QUARK (BUFFERING_RANGES),\n+  array = ensure_array (structure, \"buffering-ranges\",\n@@ -1318,1 +1309,1 @@\n-  array = ensure_array (structure, GST_QUARK (BUFFERING_RANGES),\n+  array = ensure_array (structure, \"buffering-ranges\",\n@@ -1349,1 +1340,1 @@\n-  array = ensure_array (structure, GST_QUARK (BUFFERING_RANGES),\n+  array = ensure_array (structure, \"buffering-ranges\",\n@@ -1381,2 +1372,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (QUERY_URI),\n-      GST_QUARK (URI), G_TYPE_STRING, NULL, NULL);\n+  structure = gst_structure_new_static_str (\"GstQueryURI\",\n+      \"uri\", G_TYPE_STRING, NULL, NULL);\n@@ -1405,1 +1396,1 @@\n-  gst_structure_id_set (structure, GST_QUARK (URI), G_TYPE_STRING, uri, NULL);\n+  gst_structure_set (structure, \"uri\", G_TYPE_STRING, uri, NULL);\n@@ -1427,2 +1418,1 @@\n-    *uri = g_value_dup_string (gst_structure_id_get_value (structure,\n-            GST_QUARK (URI)));\n+    *uri = g_value_dup_string (gst_structure_get_value (structure, \"uri\"));\n@@ -1449,2 +1439,1 @@\n-  gst_structure_id_set (structure, GST_QUARK (URI_REDIRECTION),\n-      G_TYPE_STRING, uri, NULL);\n+  gst_structure_set (structure, \"uri-redirection\", G_TYPE_STRING, uri, NULL);\n@@ -1474,1 +1463,1 @@\n-    if (!gst_structure_id_get (structure, GST_QUARK (URI_REDIRECTION),\n+    if (!gst_structure_get (structure, \"uri-redirection\",\n@@ -1499,1 +1488,1 @@\n-  gst_structure_id_set (structure, GST_QUARK (URI_REDIRECTION_PERMANENT),\n+  gst_structure_set (structure, \"uri-redirection-permanent\",\n@@ -1526,1 +1515,1 @@\n-    if (!gst_structure_id_get (structure, GST_QUARK (URI_REDIRECTION_PERMANENT),\n+    if (!gst_structure_get (structure, \"uri-redirection-permanent\",\n@@ -1549,3 +1538,3 @@\n-  structure = gst_structure_new_id (GST_QUARK (QUERY_ALLOCATION),\n-      GST_QUARK (CAPS), GST_TYPE_CAPS, caps,\n-      GST_QUARK (NEED_POOL), G_TYPE_BOOLEAN, need_pool, NULL);\n+  structure = gst_structure_new_static_str (\"GstQueryAllocation\",\n+      \"caps\", GST_TYPE_CAPS, caps,\n+      \"need-pool\", G_TYPE_BOOLEAN, need_pool, NULL);\n@@ -1581,2 +1570,1 @@\n-    *caps = g_value_get_boxed (gst_structure_id_get_value (structure,\n-            GST_QUARK (CAPS)));\n+    *caps = g_value_get_boxed (gst_structure_get_value (structure, \"caps\"));\n@@ -1584,2 +1572,1 @@\n-  gst_structure_id_get (structure,\n-      GST_QUARK (NEED_POOL), G_TYPE_BOOLEAN, need_pool, NULL);\n+  gst_structure_get (structure, \"need-pool\", G_TYPE_BOOLEAN, need_pool, NULL);\n@@ -1625,1 +1612,1 @@\n-  array = ensure_array (structure, GST_QUARK (POOL),\n+  array = ensure_array (structure, \"pool\",\n@@ -1655,1 +1642,1 @@\n-  array = ensure_array (structure, GST_QUARK (POOL),\n+  array = ensure_array (structure, \"pool\",\n@@ -1686,1 +1673,1 @@\n-  array = ensure_array (structure, GST_QUARK (POOL),\n+  array = ensure_array (structure, \"pool\",\n@@ -1725,1 +1712,1 @@\n-  array = ensure_array (structure, GST_QUARK (POOL),\n+  array = ensure_array (structure, \"pool\",\n@@ -1760,1 +1747,1 @@\n-      ensure_array (structure, GST_QUARK (POOL), sizeof (AllocationPool),\n+      ensure_array (structure, \"pool\", sizeof (AllocationPool),\n@@ -1802,1 +1789,1 @@\n-      ensure_array (structure, GST_QUARK (META), sizeof (AllocationMeta),\n+      ensure_array (structure, \"meta\", sizeof (AllocationMeta),\n@@ -1830,1 +1817,1 @@\n-      ensure_array (structure, GST_QUARK (META), sizeof (AllocationMeta),\n+      ensure_array (structure, \"meta\", sizeof (AllocationMeta),\n@@ -1859,1 +1846,1 @@\n-      ensure_array (structure, GST_QUARK (META), sizeof (AllocationMeta),\n+      ensure_array (structure, \"meta\", sizeof (AllocationMeta),\n@@ -1890,1 +1877,1 @@\n-      ensure_array (structure, GST_QUARK (META), sizeof (AllocationMeta),\n+      ensure_array (structure, \"meta\", sizeof (AllocationMeta),\n@@ -1921,1 +1908,1 @@\n-      ensure_array (structure, GST_QUARK (META), sizeof (AllocationMeta),\n+      ensure_array (structure, \"meta\", sizeof (AllocationMeta),\n@@ -1970,1 +1957,1 @@\n-  array = ensure_array (structure, GST_QUARK (ALLOCATOR),\n+  array = ensure_array (structure, \"allocator\",\n@@ -2006,1 +1993,1 @@\n-  array = ensure_array (structure, GST_QUARK (ALLOCATOR),\n+  array = ensure_array (structure, \"allocator\",\n@@ -2033,1 +2020,1 @@\n-  array = ensure_array (structure, GST_QUARK (ALLOCATOR),\n+  array = ensure_array (structure, \"allocator\",\n@@ -2067,1 +2054,1 @@\n-  array = ensure_array (structure, GST_QUARK (ALLOCATOR),\n+  array = ensure_array (structure, \"allocator\",\n@@ -2104,1 +2091,1 @@\n-      ensure_array (structure, GST_QUARK (ALLOCATOR), sizeof (AllocationParam),\n+      ensure_array (structure, \"allocator\", sizeof (AllocationParam),\n@@ -2126,5 +2113,4 @@\n-  structure = gst_structure_new_id (GST_QUARK (QUERY_SCHEDULING),\n-      GST_QUARK (FLAGS), GST_TYPE_SCHEDULING_FLAGS, 0,\n-      GST_QUARK (MINSIZE), G_TYPE_INT, 1,\n-      GST_QUARK (MAXSIZE), G_TYPE_INT, -1,\n-      GST_QUARK (ALIGN), G_TYPE_INT, 0, NULL);\n+  structure = gst_structure_new_static_str (\"GstQueryScheduling\",\n+      \"flags\", GST_TYPE_SCHEDULING_FLAGS, 0,\n+      \"minsize\", G_TYPE_INT, 1,\n+      \"maxsize\", G_TYPE_INT, -1, \"align\", G_TYPE_INT, 0, NULL);\n@@ -2156,5 +2142,4 @@\n-  gst_structure_id_set (structure,\n-      GST_QUARK (FLAGS), GST_TYPE_SCHEDULING_FLAGS, flags,\n-      GST_QUARK (MINSIZE), G_TYPE_INT, minsize,\n-      GST_QUARK (MAXSIZE), G_TYPE_INT, maxsize,\n-      GST_QUARK (ALIGN), G_TYPE_INT, align, NULL);\n+  gst_structure_set (structure,\n+      \"flags\", GST_TYPE_SCHEDULING_FLAGS, flags,\n+      \"minsize\", G_TYPE_INT, minsize,\n+      \"maxsize\", G_TYPE_INT, maxsize, \"align\", G_TYPE_INT, align, NULL);\n@@ -2182,5 +2167,4 @@\n-  gst_structure_id_get (structure,\n-      GST_QUARK (FLAGS), GST_TYPE_SCHEDULING_FLAGS, flags,\n-      GST_QUARK (MINSIZE), G_TYPE_INT, minsize,\n-      GST_QUARK (MAXSIZE), G_TYPE_INT, maxsize,\n-      GST_QUARK (ALIGN), G_TYPE_INT, align, NULL);\n+  gst_structure_get (structure,\n+      \"flags\", GST_TYPE_SCHEDULING_FLAGS, flags,\n+      \"minsize\", G_TYPE_INT, minsize,\n+      \"maxsize\", G_TYPE_INT, maxsize, \"align\", G_TYPE_INT, align, NULL);\n@@ -2206,2 +2190,1 @@\n-  array =\n-      ensure_array (structure, GST_QUARK (MODES), sizeof (GstPadMode), NULL);\n+  array = ensure_array (structure, \"modes\", sizeof (GstPadMode), NULL);\n@@ -2230,2 +2213,1 @@\n-  array =\n-      ensure_array (structure, GST_QUARK (MODES), sizeof (GstPadMode), NULL);\n+  array = ensure_array (structure, \"modes\", sizeof (GstPadMode), NULL);\n@@ -2256,2 +2238,1 @@\n-  array =\n-      ensure_array (structure, GST_QUARK (MODES), sizeof (GstPadMode), NULL);\n+  array = ensure_array (structure, \"modes\", sizeof (GstPadMode), NULL);\n@@ -2288,2 +2269,1 @@\n-  array =\n-      ensure_array (structure, GST_QUARK (MODES), sizeof (GstPadMode), NULL);\n+  array = ensure_array (structure, \"modes\", sizeof (GstPadMode), NULL);\n@@ -2343,3 +2323,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (QUERY_ACCEPT_CAPS),\n-      GST_QUARK (CAPS), GST_TYPE_CAPS, caps,\n-      GST_QUARK (RESULT), G_TYPE_BOOLEAN, FALSE, NULL);\n+  structure = gst_structure_new_static_str (\"GstQueryAcceptCaps\",\n+      \"caps\", GST_TYPE_CAPS, caps, \"result\", G_TYPE_BOOLEAN, FALSE, NULL);\n@@ -2368,2 +2347,1 @@\n-  *caps = g_value_get_boxed (gst_structure_id_get_value (structure,\n-          GST_QUARK (CAPS)));\n+  *caps = g_value_get_boxed (gst_structure_get_value (structure, \"caps\"));\n@@ -2388,2 +2366,1 @@\n-  gst_structure_id_set (structure,\n-      GST_QUARK (RESULT), G_TYPE_BOOLEAN, result, NULL);\n+  gst_structure_set (structure, \"result\", G_TYPE_BOOLEAN, result, NULL);\n@@ -2407,2 +2384,1 @@\n-  gst_structure_id_get (structure,\n-      GST_QUARK (RESULT), G_TYPE_BOOLEAN, result, NULL);\n+  gst_structure_get (structure, \"result\", G_TYPE_BOOLEAN, result, NULL);\n@@ -2444,3 +2420,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (QUERY_CAPS),\n-      GST_QUARK (FILTER), GST_TYPE_CAPS, filter,\n-      GST_QUARK (CAPS), GST_TYPE_CAPS, NULL, NULL);\n+  structure = gst_structure_new_static_str (\"GstQueryCaps\",\n+      \"filter\", GST_TYPE_CAPS, filter, \"caps\", GST_TYPE_CAPS, NULL, NULL);\n@@ -2469,2 +2444,1 @@\n-  *filter = g_value_get_boxed (gst_structure_id_get_value (structure,\n-          GST_QUARK (FILTER)));\n+  *filter = g_value_get_boxed (gst_structure_get_value (structure, \"filter\"));\n@@ -2489,1 +2463,1 @@\n-  gst_structure_id_set (structure, GST_QUARK (CAPS), GST_TYPE_CAPS, caps, NULL);\n+  gst_structure_set (structure, \"caps\", GST_TYPE_CAPS, caps, NULL);\n@@ -2509,2 +2483,1 @@\n-  *caps = g_value_get_boxed (gst_structure_id_get_value (structure,\n-          GST_QUARK (CAPS)));\n+  *caps = g_value_get_boxed (gst_structure_get_value (structure, \"caps\"));\n@@ -2542,1 +2515,1 @@\n-  structure = gst_structure_new_id_empty (GST_QUARK (QUERY_DRAIN));\n+  structure = gst_structure_new_static_str_empty (\"GstQueryDrain\");\n@@ -2568,2 +2541,2 @@\n-  structure = gst_structure_new_id (GST_QUARK (QUERY_CONTEXT),\n-      GST_QUARK (CONTEXT_TYPE), G_TYPE_STRING, context_type, NULL);\n+  structure = gst_structure_new_static_str (\"GstQueryContext\",\n+      \"context-type\", G_TYPE_STRING, context_type, NULL);\n@@ -2598,2 +2571,1 @@\n-  gst_structure_id_set (s,\n-      GST_QUARK (CONTEXT), GST_TYPE_CONTEXT, context, NULL);\n+  gst_structure_set (s, \"context\", GST_TYPE_CONTEXT, context, NULL);\n@@ -2622,1 +2594,1 @@\n-  v = gst_structure_id_get_value (structure, GST_QUARK (CONTEXT));\n+  v = gst_structure_get_value (structure, \"context\");\n@@ -2651,1 +2623,1 @@\n-    value = gst_structure_id_get_value (structure, GST_QUARK (CONTEXT_TYPE));\n+    value = gst_structure_get_value (structure, \"context-type\");\n@@ -2675,1 +2647,1 @@\n-  structure = gst_structure_new_id_empty (GST_QUARK (QUERY_BITRATE));\n+  structure = gst_structure_new_static_str_empty (\"GstQueryBitrate\");\n@@ -2701,2 +2673,1 @@\n-  gst_structure_id_set (s,\n-      GST_QUARK (NOMINAL_BITRATE), G_TYPE_UINT, nominal_bitrate, NULL);\n+  gst_structure_set (s, \"nominal-bitrate\", G_TYPE_UINT, nominal_bitrate, NULL);\n@@ -2725,1 +2696,1 @@\n-    value = gst_structure_id_get_value (structure, GST_QUARK (NOMINAL_BITRATE));\n+    value = gst_structure_get_value (structure, \"nominal-bitrate\");\n@@ -2747,1 +2718,1 @@\n-  structure = gst_structure_new_id_empty (GST_QUARK (QUERY_SELECTABLE));\n+  structure = gst_structure_new_static_str_empty (\"GstQuerySelectable\");\n@@ -2772,2 +2743,1 @@\n-  gst_structure_id_set (s,\n-      GST_QUARK (SELECTABLE), G_TYPE_BOOLEAN, selectable, NULL);\n+  gst_structure_set (s, \"selectable\", G_TYPE_BOOLEAN, selectable, NULL);\n@@ -2795,2 +2765,1 @@\n-    const GValue *value =\n-        gst_structure_id_get_value (structure, GST_QUARK (SELECTABLE));\n+    const GValue *value = gst_structure_get_value (structure, \"selectable\");\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstquery.c","additions":205,"deletions":236,"binary":false,"changes":441,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+#ifdef _MSC_VER\n+#pragma warning(disable: 5287)\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstquery.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -720,1 +720,1 @@\n- * @filter: (scope call): the filter to use\n+ * @filter: (scope call) (closure user_data): the filter to use\n@@ -722,1 +722,1 @@\n- * @user_data: (closure): user data passed to the filter function\n+ * @user_data: user data passed to the filter function\n@@ -900,1 +900,1 @@\n- * @filter: (scope call): the filter to use\n+ * @filter: (scope call) (closure user_data): the filter to use\n@@ -902,1 +902,1 @@\n- * @user_data: (closure): user data passed to the filter function\n+ * @user_data: user data passed to the filter function\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstregistry.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+#ifdef _MSC_VER\n+#pragma warning(disable: 5287)\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstsegment.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,2 +93,2 @@\n- * - [GstValueArray](GST_TYPE_ARRAY) are inside curly brackets (`{` and `}`).\n- *   For example `a-structure, array={1, 2, 3}`\n+ * - [GstValueArray](GST_TYPE_ARRAY) are inside \"less and greater than\" (`<` and\n+ *   `>`). For example `a-structure, array=<1, 2, 3>\n@@ -99,2 +99,5 @@\n- * - [GstValueList](GST_TYPE_LIST) are inside \"less and greater than\" (`<` and\n- *   `>`). For example `a-structure, list=<1, 2, 3>\n+ * - [GstValueList](GST_TYPE_LIST) are inside curly brackets (`{` and `}`).\n+ *   For example `a-structure, list={1, 2, 3}`\n+ * - [GStrv](G_TYPE_STRV) are inside \"less and greater than\" (`<` and\n+ *   `>`) and each string is double-quoted.\n+ *   For example `a-structure, strv=(GStrv)<\"foo\", \"bar\">`. Since 1.26.0.\n@@ -145,1 +148,0 @@\n-#include \"gstquark.h\"\n@@ -147,0 +149,1 @@\n+#include \"gstidstr-private.h\"\n@@ -156,1 +159,1 @@\n-  GQuark name;\n+  GstIdStr name;\n@@ -164,0 +167,3 @@\n+  \/* Actual structure name *\/\n+  GstIdStr name;\n+\n@@ -179,0 +185,1 @@\n+#define GST_STRUCTURE_NAME(s) (&((GstStructureImpl*)(s))->name)\n@@ -191,1 +198,2 @@\n-    (structure->name == GST_QUARK (TAGLIST))\n+    (((const GstIdStrPrivate *) GST_STRUCTURE_NAME (structure))->s.string_type.t == 0 && \\\n+     (memcmp (((const GstIdStrPrivate *) GST_STRUCTURE_NAME (structure))->s.short_string.s, \"taglist\", sizeof (\"taglist\")) == 0))\n@@ -245,2 +253,2 @@\n-static GstStructureField *gst_structure_id_get_field (const GstStructure *\n-    structure, GQuark field);\n+static GstStructureField *gst_structure_id_str_get_field (const GstStructure *\n+    structure, const GstIdStr * fieldname);\n@@ -270,0 +278,1 @@\n+\/* takes ownership of @name *\/\n@@ -271,1 +280,1 @@\n-gst_structure_new_id_empty_with_size (GQuark quark, guint prealloc)\n+gst_structure_new_take_id_str_empty_with_size (GstIdStr * name, guint prealloc)\n@@ -285,1 +294,2 @@\n-  ((GstStructure *) structure)->name = quark;\n+  ((GstStructure *) structure)->name = 0;\n+  gst_id_str_move (&structure->name, name);\n@@ -297,0 +307,20 @@\n+static GstStructure *\n+gst_structure_new_id_str_empty_with_size (const GstIdStr * name, guint prealloc)\n+{\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n+  gst_id_str_copy_into (&s, name);\n+\n+  return gst_structure_new_take_id_str_empty_with_size (&s, prealloc);\n+}\n+\n+static GstStructure *\n+gst_structure_new_str_empty_with_size (const gchar * name, guint prealloc)\n+{\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n+  gst_id_str_set (&s, name);\n+\n+  return gst_structure_new_take_id_str_empty_with_size (&s, prealloc);\n+}\n+\n@@ -306,0 +336,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_structure_new_id_str_empty().\n@@ -310,0 +342,2 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n@@ -312,1 +346,3 @@\n-  return gst_structure_new_id_empty_with_size (quark, 0);\n+  gst_id_str_set_static_str (&s, g_quark_to_string (quark));\n+\n+  return gst_structure_new_take_id_str_empty_with_size (&s, 0);\n@@ -351,0 +387,22 @@\n+\/**\n+ * gst_structure_new_id_str_empty:\n+ * @name: name of new structure\n+ *\n+ * Creates a new, empty #GstStructure with the given name.\n+ *\n+ * Free-function: gst_structure_free\n+ *\n+ * Returns: (transfer full): a new, empty #GstStructure\n+ *\n+ * Since: 1.26\n+ *\/\n+GstStructure *\n+gst_structure_new_id_str_empty (const GstIdStr * name)\n+{\n+  g_return_val_if_fail (name != 0, NULL);\n+  g_return_val_if_fail (gst_structure_validate_name (gst_id_str_as_str (name)),\n+      NULL);\n+\n+  return gst_structure_new_id_str_empty_with_size (name, 0);\n+}\n+\n@@ -368,1 +426,62 @@\n-  return gst_structure_new_id_empty_with_size (g_quark_from_string (name), 0);\n+  return gst_structure_new_str_empty_with_size (name, 0);\n+}\n+\n+\/**\n+ * gst_structure_new_static_str_empty:\n+ * @name: name of new structure\n+ *\n+ * Creates a new, empty #GstStructure with the given @name.\n+ *\n+ * See gst_structure_set_name() for constraints on the @name parameter.\n+ *\n+ * @name needs to be valid for the remaining lifetime of the process, e.g. has\n+ * to be a static string.\n+ *\n+ * Free-function: gst_structure_free\n+ *\n+ * Returns: (transfer full): a new, empty #GstStructure\n+ *\n+ * Since: 1.26\n+ *\/\n+GstStructure *\n+gst_structure_new_static_str_empty (const gchar * name)\n+{\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n+  g_return_val_if_fail (gst_structure_validate_name (name), NULL);\n+\n+  gst_id_str_set_static_str (&s, name);\n+  return gst_structure_new_take_id_str_empty_with_size (&s, 0);\n+}\n+\n+\/**\n+ * gst_structure_new_static_str:\n+ * @name: name of new structure\n+ * @firstfield: name of first field to set\n+ * @...: additional arguments\n+ *\n+ * Creates a new #GstStructure with the given name.  Parses the\n+ * list of variable arguments and sets fields to the values listed.\n+ * Variable arguments should be passed as field name, field type,\n+ * and value.  Last variable argument should be %NULL.\n+ *\n+ * @name, @firstfield and all field names need to be valid for the remaining\n+ * lifetime of the process, e.g. have to be a static string.\n+ *\n+ * Free-function: gst_structure_free\n+ *\n+ * Returns: (transfer full): a new #GstStructure\n+ *\n+ * Since: 1.26\n+ *\/\n+GstStructure *\n+gst_structure_new_static_str (const gchar * name, const gchar * firstfield, ...)\n+{\n+  GstStructure *structure;\n+  va_list varargs;\n+\n+  va_start (varargs, firstfield);\n+  structure = gst_structure_new_static_str_valist (name, firstfield, varargs);\n+  va_end (varargs);\n+\n+  return structure;\n@@ -399,0 +518,47 @@\n+\/**\n+ * gst_structure_new_id_str_valist:\n+ * @name: name of new structure\n+ * @firstfield: name of first field to set\n+ * @varargs: variable argument list\n+ *\n+ * Creates a new #GstStructure with the given @name.  Structure fields\n+ * are set according to the varargs in a manner similar to\n+ * gst_structure_new_id_str().\n+ *\n+ * Free-function: gst_structure_free\n+ *\n+ * Returns: (transfer full): a new #GstStructure\n+ *\n+ * Since: 1.26\n+ *\/\n+GstStructure *\n+gst_structure_new_id_str_valist (const GstIdStr * name,\n+    const GstIdStr * firstfield, va_list varargs)\n+{\n+  GstStructure *structure;\n+  va_list copy;\n+  guint len = 0;\n+  const GstIdStr *field_copy = firstfield;\n+  GType type_copy;\n+\n+  g_return_val_if_fail (gst_structure_validate_name (gst_id_str_as_str (name)),\n+      NULL);\n+\n+  \/* Calculate size of varargs *\/\n+  va_copy (copy, varargs);\n+  while (field_copy) {\n+    type_copy = va_arg (copy, GType);\n+    G_VALUE_COLLECT_SKIP (type_copy, copy);\n+    field_copy = va_arg (copy, const GstIdStr *);\n+    len++;\n+  }\n+  va_end (copy);\n+\n+  structure = gst_structure_new_id_str_empty_with_size (name, len);\n+\n+  if (structure)\n+    gst_structure_id_str_set_valist (structure, firstfield, varargs);\n+\n+  return structure;\n+}\n+\n@@ -437,2 +603,1 @@\n-  structure =\n-      gst_structure_new_id_empty_with_size (g_quark_from_string (name), len);\n+  structure = gst_structure_new_str_empty_with_size (name, len);\n@@ -446,0 +611,54 @@\n+\/**\n+ * gst_structure_new_static_str_valist:\n+ * @name: name of new structure\n+ * @firstfield: name of first field to set\n+ * @varargs: variable argument list\n+ *\n+ * Creates a new #GstStructure with the given @name.  Structure fields\n+ * are set according to the varargs in a manner similar to\n+ * gst_structure_new().\n+ *\n+ * See gst_structure_set_name() for constraints on the @name parameter.\n+ *\n+ * @name, @firstfield and all field names need to be valid for the remaining\n+ * lifetime of the process, e.g. have to be a static string.\n+ *\n+ * Free-function: gst_structure_free\n+ *\n+ * Returns: (transfer full): a new #GstStructure\n+ *\n+ * Since: 1.26\n+ *\/\n+GstStructure *\n+gst_structure_new_static_str_valist (const gchar * name,\n+    const gchar * firstfield, va_list varargs)\n+{\n+  GstIdStr s = GST_ID_STR_INIT;\n+  GstStructure *structure;\n+  va_list copy;\n+  guint len = 0;\n+  const gchar *field_copy = firstfield;\n+  GType type_copy;\n+\n+  g_return_val_if_fail (gst_structure_validate_name (name), NULL);\n+\n+  \/* Calculate size of varargs *\/\n+  va_copy (copy, varargs);\n+  while (field_copy) {\n+    type_copy = va_arg (copy, GType);\n+    G_VALUE_COLLECT_SKIP (type_copy, copy);\n+    field_copy = va_arg (copy, gchar *);\n+    len++;\n+  }\n+  va_end (copy);\n+\n+  gst_id_str_set_static_str (&s, name);\n+\n+  structure = gst_structure_new_take_id_str_empty_with_size (&s, len);\n+\n+  if (structure)\n+    gst_structure_set_static_str_valist (structure, firstfield, varargs);\n+\n+  return structure;\n+}\n+\n@@ -502,1 +721,3 @@\n-  new_structure = gst_structure_new_id_empty_with_size (structure->name, len);\n+  new_structure =\n+      gst_structure_new_id_str_empty_with_size (GST_STRUCTURE_NAME (structure),\n+      len);\n@@ -505,1 +726,1 @@\n-    GstStructureField new_field = { 0 };\n+    GstStructureField new_field = { GST_ID_STR_INIT, G_VALUE_INIT };\n@@ -509,1 +730,1 @@\n-    new_field.name = field->name;\n+    gst_id_str_copy_into (&new_field.name, &field->name);\n@@ -542,0 +763,1 @@\n+    gst_id_str_clear (&field->name);\n@@ -546,0 +768,2 @@\n+  gst_id_str_clear (GST_STRUCTURE_NAME (structure));\n+\n@@ -632,1 +856,1 @@\n-  return g_quark_to_string (structure->name);\n+  return gst_id_str_as_str (GST_STRUCTURE_NAME (structure));\n@@ -647,2 +871,0 @@\n-  const gchar *structure_name;\n-\n@@ -652,6 +874,2 @@\n-  \/* getting the string is cheap and comparing short strings is too\n-   * should be faster than getting the quark for name and comparing the quarks\n-   *\/\n-  structure_name = g_quark_to_string (structure->name);\n-\n-  return (structure_name && strcmp (structure_name, name) == 0);\n+  return gst_id_str_is_equal_to_str (gst_structure_get_name_id_str (structure),\n+      name);\n@@ -667,0 +885,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_structure_get_name_id_str().\n@@ -673,1 +893,41 @@\n-  return structure->name;\n+  return\n+      g_quark_from_string (gst_id_str_as_str (GST_STRUCTURE_NAME (structure)));\n+}\n+\n+\/**\n+ * gst_structure_get_name_id_str:\n+ * @structure: a #GstStructure\n+ *\n+ * Get the name of @structure as a GstIdStr.\n+ *\n+ * Returns: the name of the structure.\n+ *\n+ * Since: 1.26\n+ *\/\n+const GstIdStr *\n+gst_structure_get_name_id_str (const GstStructure * structure)\n+{\n+  g_return_val_if_fail (structure != NULL, 0);\n+\n+  return GST_STRUCTURE_NAME (structure);\n+}\n+\n+\/**\n+ * gst_structure_set_name_id_str:\n+ * @structure: a #GstStructure\n+ * @name: the new name of the structure\n+ *\n+ * Sets the name of the structure to the given @name.  The string\n+ * provided is copied before being used. It must not be empty, start with a\n+ * letter and can be followed by letters, numbers and any of \"\/-_.:\".\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_structure_set_name_id_str (GstStructure * structure, const GstIdStr * name)\n+{\n+  g_return_if_fail (structure != NULL);\n+  g_return_if_fail (IS_MUTABLE (structure));\n+  g_return_if_fail (gst_structure_validate_name (gst_id_str_as_str (name)));\n+\n+  gst_id_str_copy_into (GST_STRUCTURE_NAME (structure), name);\n@@ -692,1 +952,25 @@\n-  structure->name = g_quark_from_string (name);\n+  gst_id_str_set (GST_STRUCTURE_NAME (structure), name);\n+}\n+\n+\/**\n+ * gst_structure_set_name_static_str:\n+ * @structure: a #GstStructure\n+ * @name: the new name of the structure\n+ *\n+ * Sets the name of the structure to the given @name.  The string\n+ * provided is copied before being used. It must not be empty, start with a\n+ * letter and can be followed by letters, numbers and any of \"\/-_.:\".\n+ *\n+ * @name needs to be valid for the remaining lifetime of the process, e.g. has\n+ * to be a static string.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_structure_set_name_static_str (GstStructure * structure, const gchar * name)\n+{\n+  g_return_if_fail (structure != NULL);\n+  g_return_if_fail (IS_MUTABLE (structure));\n+  g_return_if_fail (gst_structure_validate_name (name));\n+\n+  gst_id_str_set_static_str (GST_STRUCTURE_NAME (structure), name);\n@@ -695,0 +979,1 @@\n+\/* takes ownership of fieldname (but not value) *\/\n@@ -696,2 +981,2 @@\n-gst_structure_id_set_value_internal (GstStructure * structure, GQuark field,\n-    const GValue * value)\n+gst_structure_id_str_set_value_internal (GstStructure * structure,\n+    GstIdStr * fieldname, const GValue * value)\n@@ -699,1 +984,1 @@\n-  GstStructureField gsfield = { 0, {0,} };\n+  GstStructureField gsfield = { GST_ID_STR_INIT, G_VALUE_INIT };\n@@ -701,1 +986,1 @@\n-  gsfield.name = field;\n+  gst_id_str_move (&gsfield.name, fieldname);\n@@ -716,0 +1001,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_structure_id_str_set_value().\n@@ -721,0 +1008,1 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n@@ -726,1 +1014,2 @@\n-  gst_structure_id_set_value_internal (structure, field, value);\n+  gst_id_str_set_static_str (&s, g_quark_to_string (field));\n+  gst_structure_id_str_set_value_internal (structure, &s, value);\n@@ -743,0 +1032,59 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n+  g_return_if_fail (structure != NULL);\n+  g_return_if_fail (fieldname != NULL);\n+  g_return_if_fail (G_IS_VALUE (value));\n+  g_return_if_fail (IS_MUTABLE (structure));\n+\n+  gst_id_str_set (&s, fieldname);\n+  gst_structure_id_str_set_value_internal (structure, &s, value);\n+}\n+\n+\/**\n+ * gst_structure_set_value_static_str:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of the field to set\n+ * @value: the new value of the field\n+ *\n+ * Sets the field with the given name @field to @value.  If the field\n+ * does not exist, it is created.  If the field exists, the previous\n+ * value is replaced and freed.\n+ *\n+ * @fieldname needs to be valid for the remaining lifetime of the process, e.g.\n+ * has to be a static string.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_structure_set_value_static_str (GstStructure * structure,\n+    const gchar * fieldname, const GValue * value)\n+{\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n+  g_return_if_fail (structure != NULL);\n+  g_return_if_fail (fieldname != NULL);\n+  g_return_if_fail (G_IS_VALUE (value));\n+  g_return_if_fail (IS_MUTABLE (structure));\n+\n+  gst_id_str_set_static_str (&s, fieldname);\n+  gst_structure_id_str_set_value_internal (structure, &s, value);\n+}\n+\n+\/**\n+ * gst_structure_id_str_set_value:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of the field to set\n+ * @value: the new value of the field\n+ *\n+ * Sets the field with the given name @field to @value.  If the field\n+ * does not exist, it is created.  If the field exists, the previous\n+ * value is replaced and freed.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_structure_id_str_set_value (GstStructure * structure,\n+    const GstIdStr * fieldname, const GValue * value)\n+{\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n@@ -748,2 +1096,2 @@\n-  gst_structure_id_set_value_internal (structure,\n-      g_quark_from_string (fieldname), value);\n+  gst_id_str_copy_into (&s, fieldname);\n+  gst_structure_id_str_set_value_internal (structure, &s, value);\n@@ -752,0 +1100,1 @@\n+\/* takes ownership of both fieldname and value *\/\n@@ -753,2 +1102,2 @@\n-gst_structure_id_take_value_internal (GstStructure * structure, GQuark field,\n-    GValue * value)\n+gst_structure_id_str_take_value_internal (GstStructure * structure,\n+    GstIdStr * fieldname, GValue * value)\n@@ -756,1 +1105,1 @@\n-  GstStructureField gsfield = { 0, {0,} };\n+  GstStructureField gsfield = { GST_ID_STR_INIT, G_VALUE_INIT };\n@@ -758,1 +1107,1 @@\n-  gsfield.name = field;\n+  gst_id_str_move (&gsfield.name, fieldname);\n@@ -780,0 +1129,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_structure_id_str_take_value().\n@@ -785,0 +1136,2 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n@@ -789,1 +1142,2 @@\n-  gst_structure_id_take_value_internal (structure, field, value);\n+  gst_id_str_set_static_str (&s, g_quark_to_string (field));\n+  gst_structure_id_str_take_value_internal (structure, &s, value);\n@@ -806,0 +1160,2 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n@@ -811,2 +1167,58 @@\n-  gst_structure_id_take_value_internal (structure,\n-      g_quark_from_string (fieldname), value);\n+  gst_id_str_set (&s, fieldname);\n+  gst_structure_id_str_take_value_internal (structure, &s, value);\n+}\n+\n+\/**\n+ * gst_structure_take_value_static_str:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of the field to set\n+ * @value: (transfer full): the new value of the field\n+ *\n+ * Sets the field with the given name @field to @value.  If the field\n+ * does not exist, it is created.  If the field exists, the previous\n+ * value is replaced and freed. The function will take ownership of @value.\n+ *\n+ * @fieldname needs to be valid for the remaining lifetime of the process, e.g.\n+ * has to be a static string.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_structure_take_value_static_str (GstStructure * structure,\n+    const gchar * fieldname, GValue * value)\n+{\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n+  g_return_if_fail (structure != NULL);\n+  g_return_if_fail (fieldname != NULL);\n+  g_return_if_fail (G_IS_VALUE (value));\n+  g_return_if_fail (IS_MUTABLE (structure));\n+\n+  gst_id_str_set_static_str (&s, fieldname);\n+  gst_structure_id_str_take_value_internal (structure, &s, value);\n+}\n+\n+\/**\n+ * gst_structure_id_str_take_value:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of the field to set\n+ * @value: (transfer full): the new value of the field\n+ *\n+ * Sets the field with the given GstIdStr @field to @value.  If the field\n+ * does not exist, it is created.  If the field exists, the previous\n+ * value is replaced and freed.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_structure_id_str_take_value (GstStructure * structure,\n+    const GstIdStr * fieldname, GValue * value)\n+{\n+  GstIdStr s = GST_ID_STR_INIT;\n+\n+  g_return_if_fail (structure != NULL);\n+  g_return_if_fail (G_IS_VALUE (value));\n+  g_return_if_fail (IS_MUTABLE (structure));\n+\n+  gst_id_str_copy_into (&s, fieldname);\n+  gst_structure_id_str_take_value_internal (structure, &s, value);\n@@ -817,1 +1229,1 @@\n-    const gchar * fieldname, va_list varargs)\n+    gboolean static_string, const gchar * fieldname, va_list varargs)\n@@ -823,3 +1235,1 @@\n-    GstStructureField field = { 0 };\n-\n-    field.name = g_quark_from_string (fieldname);\n+    GstStructureField field = { GST_ID_STR_INIT, G_VALUE_INIT };\n@@ -827,0 +1237,4 @@\n+    if (static_string)\n+      gst_id_str_set_static_str (&field.name, fieldname);\n+    else\n+      gst_id_str_set (&field.name, fieldname);\n@@ -833,0 +1247,1 @@\n+      gst_id_str_clear (&field.name);\n@@ -837,1 +1252,1 @@\n-    fieldname = va_arg (varargs, gchar *);\n+    fieldname = va_arg (varargs, const gchar *);\n@@ -861,1 +1276,31 @@\n-  gst_structure_set_valist_internal (structure, field, varargs);\n+  gst_structure_set_valist_internal (structure, FALSE, field, varargs);\n+  va_end (varargs);\n+}\n+\n+\/**\n+ * gst_structure_set_static_str:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of the field to set\n+ * @...: variable arguments\n+ *\n+ * Parses the variable arguments and sets fields accordingly. Fields that\n+ * weren't already part of the structure are added as needed.\n+ * Variable arguments should be in the form field name, field type\n+ * (as a GType), value(s).  The last variable argument should be %NULL.\n+ *\n+ * @fieldname and all other field names needs to be valid for the remaining\n+ * lifetime of the process, e.g. has to be a static string.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_structure_set_static_str (GstStructure * structure, const gchar * field,\n+    ...)\n+{\n+  va_list varargs;\n+\n+  g_return_if_fail (structure != NULL);\n+  g_return_if_fail (IS_MUTABLE (structure) || field == NULL);\n+\n+  va_start (varargs, field);\n+  gst_structure_set_valist_internal (structure, TRUE, field, varargs);\n@@ -880,1 +1325,24 @@\n-  gst_structure_set_valist_internal (structure, fieldname, varargs);\n+  gst_structure_set_valist_internal (structure, FALSE, fieldname, varargs);\n+}\n+\n+\/**\n+ * gst_structure_set_static_str_valist:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of the field to set\n+ * @varargs: variable arguments\n+ *\n+ * va_list form of gst_structure_set_static_str().\n+ *\n+ * @fieldname and all other field names needs to be valid for the remaining\n+ * lifetime of the process, e.g. has to be a static string.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_structure_set_static_str_valist (GstStructure * structure,\n+    const gchar * fieldname, va_list varargs)\n+{\n+  g_return_if_fail (structure != NULL);\n+  g_return_if_fail (IS_MUTABLE (structure));\n+\n+  gst_structure_set_valist_internal (structure, TRUE, fieldname, varargs);\n@@ -891,1 +1359,1 @@\n-    GstStructureField field = { 0 };\n+    GstStructureField field = { GST_ID_STR_INIT, G_VALUE_INIT };\n@@ -893,1 +1361,1 @@\n-    field.name = fieldname;\n+    gst_id_str_set_static_str (&field.name, g_quark_to_string (fieldname));\n@@ -900,0 +1368,1 @@\n+      gst_id_str_clear (&field.name);\n@@ -919,0 +1388,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_structure_id_str_set().\n@@ -939,0 +1410,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_structure_id_str_set_valist().\n@@ -950,0 +1423,73 @@\n+static void\n+gst_structure_id_str_set_valist_internal (GstStructure * structure,\n+    const GstIdStr * fieldname, va_list varargs)\n+{\n+  gchar *err = NULL;\n+  GType type;\n+\n+  while (fieldname) {\n+    GstStructureField field = { GST_ID_STR_INIT, G_VALUE_INIT };\n+\n+    gst_id_str_copy_into (&field.name, fieldname);\n+    type = va_arg (varargs, GType);\n+\n+    G_VALUE_COLLECT_INIT (&field.value, type, varargs, 0, &err);\n+    if (G_UNLIKELY (err)) {\n+      g_critical (\"%s\", err);\n+      g_free (err);\n+      gst_id_str_clear (&field.name);\n+      return;\n+    }\n+    gst_structure_set_field (structure, &field);\n+\n+    fieldname = va_arg (varargs, const GstIdStr *);\n+  }\n+}\n+\n+\/**\n+ * gst_structure_id_str_set:\n+ * @structure: a #GstStructure\n+ * @fieldname: the the name of the field to set\n+ * @...: variable arguments\n+ *\n+ * Identical to gst_structure_set, except that field names are\n+ * passed using a GstIdStr for the field name. This allows more efficient\n+ * setting of the structure if the caller already owns the associated\n+ * GstIdStr values or if they can be built from static literals.\n+ * The last variable argument must be %NULL.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_structure_id_str_set (GstStructure * structure, const GstIdStr * fieldname,\n+    ...)\n+{\n+  va_list varargs;\n+\n+  g_return_if_fail (structure != NULL);\n+\n+  va_start (varargs, fieldname);\n+  gst_structure_id_str_set_valist_internal (structure, fieldname, varargs);\n+  va_end (varargs);\n+}\n+\n+\/**\n+ * gst_structure_id_str_set_valist:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of the field to set\n+ * @varargs: variable arguments\n+ *\n+ * va_list form of gst_structure_id_str_set().\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_structure_id_str_set_valist (GstStructure * structure,\n+    const GstIdStr * fieldname, va_list varargs)\n+{\n+  g_return_if_fail (structure != NULL);\n+  g_return_if_fail (IS_MUTABLE (structure));\n+\n+  gst_structure_id_str_set_valist_internal (structure, fieldname, varargs);\n+}\n+\n@@ -966,0 +1512,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_structure_new_id_str().\n@@ -970,0 +1518,1 @@\n+  GstIdStr name = GST_ID_STR_INIT;\n@@ -992,1 +1541,2 @@\n-  s = gst_structure_new_id_empty_with_size (name_quark, len);\n+  gst_id_str_set_static_str (&name, g_quark_to_string (name_quark));\n+  s = gst_structure_new_take_id_str_empty_with_size (&name, len);\n@@ -1000,0 +1550,55 @@\n+\/**\n+ * gst_structure_new_id_str:\n+ * @name: name of new structure\n+ * @fieldname: the GstIdStr for the name of the field to set\n+ * @...: variable arguments\n+ *\n+ * Creates a new #GstStructure with the given name as a GQuark, followed by\n+ * fieldname GstIdStr, GType, argument(s) \"triplets\" in the same format as\n+ * gst_structure_id_str_set(). Basically a convenience wrapper around\n+ * gst_structure_new_id_str_empty() and gst_structure_id_str_set().\n+ *\n+ * The last variable argument must be %NULL (or 0).\n+ *\n+ * Free-function: gst_structure_free\n+ *\n+ * Returns: (transfer full): a new #GstStructure\n+ *\n+ * Since: 1.26\n+ *\/\n+GstStructure *\n+gst_structure_new_id_str (const GstIdStr * name, const GstIdStr * fieldname,\n+    ...)\n+{\n+  GstStructure *s;\n+  va_list varargs;\n+  va_list copy;\n+  guint len = 0;\n+  const GstIdStr *fieldname_copy = fieldname;\n+  GType type_copy;\n+\n+  g_return_val_if_fail (name != 0, NULL);\n+  g_return_val_if_fail (gst_structure_validate_name (gst_id_str_as_str (name)),\n+      NULL);\n+  g_return_val_if_fail (fieldname != NULL, NULL);\n+\n+  va_start (varargs, fieldname);\n+\n+  \/* Calculate size of varargs *\/\n+  va_copy (copy, varargs);\n+  while (fieldname_copy) {\n+    type_copy = va_arg (copy, GType);\n+    G_VALUE_COLLECT_SKIP (type_copy, copy);\n+    fieldname_copy = va_arg (copy, const GstIdStr *);\n+    len++;\n+  }\n+  va_end (copy);\n+\n+  s = gst_structure_new_id_str_empty_with_size (name, len);\n+\n+  gst_structure_id_str_set_valist_internal (s, fieldname, varargs);\n+  va_end (varargs);\n+\n+  return s;\n+}\n+\n@@ -1006,6 +1611,3 @@\n-\/* If the structure currently contains a field with the same name, it is\n- * replaced with the provided field. Otherwise, the field is added to the\n- * structure. The field's value is not deeply copied.\n- *\/\n-static void\n-gst_structure_set_field (GstStructure * structure, GstStructureField * field)\n+static gboolean\n+gst_structure_validate_field_value (const GstStructure * structure,\n+    const gchar * field_name, const GValue * value)\n@@ -1013,1 +1615,0 @@\n-  GstStructureField *f;\n@@ -1015,1 +1616,1 @@\n-  guint i, len;\n+  gboolean is_tag_list;\n@@ -1017,1 +1618,1 @@\n-  len = GST_STRUCTURE_LEN (structure);\n+  is_tag_list = IS_TAGLIST (structure);\n@@ -1019,1 +1620,1 @@\n-  field_value_type = G_VALUE_TYPE (&field->value);\n+  field_value_type = G_VALUE_TYPE (value);\n@@ -1023,1 +1624,1 @@\n-    s = g_value_get_string (&field->value);\n+    s = g_value_get_string (value);\n@@ -1026,1 +1627,1 @@\n-    if (G_UNLIKELY (IS_TAGLIST (structure) && (s == NULL || *s == '\\0'))) {\n+    if (G_UNLIKELY (is_tag_list && (s == NULL || *s == '\\0'))) {\n@@ -1029,3 +1630,2 @@\n-            \"Please file a bug.\", g_quark_to_string (field->name));\n-        g_value_unset (&field->value);\n-        return;\n+            \"Please file a bug.\", field_name);\n+        return FALSE;\n@@ -1035,3 +1635,2 @@\n-            \"Please file a bug.\", g_quark_to_string (field->name));\n-        g_value_unset (&field->value);\n-        return;\n+            \"Please file a bug.\", field_name);\n+        return FALSE;\n@@ -1042,4 +1641,2 @@\n-          IS_TAGLIST (structure) ? \"taglist\" : \"structure\",\n-          g_quark_to_string (field->name));\n-      g_value_unset (&field->value);\n-      return;\n+          is_tag_list ? \"taglist\" : \"structure\", field_name);\n+      return FALSE;\n@@ -1050,1 +1647,1 @@\n-    d = g_value_get_boxed (&field->value);\n+    d = g_value_get_boxed (value);\n@@ -1053,1 +1650,1 @@\n-    if (G_UNLIKELY ((IS_TAGLIST (structure) && d == NULL))) {\n+    if (G_UNLIKELY ((is_tag_list && d == NULL))) {\n@@ -1055,3 +1652,2 @@\n-          \"Please file a bug.\", g_quark_to_string (field->name));\n-      g_value_unset (&field->value);\n-      return;\n+          \"Please file a bug.\", field_name);\n+      return FALSE;\n@@ -1061,4 +1657,2 @@\n-          IS_TAGLIST (structure) ? \"taglist\" : \"structure\",\n-          g_quark_to_string (field->name));\n-      g_value_unset (&field->value);\n-      return;\n+          is_tag_list ? \"taglist\" : \"structure\", field_name);\n+      return FALSE;\n@@ -1068,0 +1662,20 @@\n+  return TRUE;\n+}\n+\n+\/* If the structure currently contains a field with the same name, it is\n+ * replaced with the provided field. Otherwise, the field is added to the\n+ * structure. The field's value is not deeply copied.\n+ *\/\n+static void\n+gst_structure_set_field (GstStructure * structure, GstStructureField * field)\n+{\n+  GstStructureField *f;\n+  guint i, len;\n+\n+  if (!gst_structure_validate_field_value (structure,\n+          gst_id_str_as_str (&field->name), &field->value)) {\n+    g_value_unset (&field->value);\n+    return;\n+  }\n+\n+  len = GST_STRUCTURE_LEN (structure);\n@@ -1071,1 +1685,1 @@\n-    if (G_UNLIKELY (f->name == field->name)) {\n+    if (G_UNLIKELY (gst_id_str_is_equal (&f->name, &field->name))) {\n@@ -1073,1 +1687,2 @@\n-      memcpy (f, field, sizeof (GstStructureField));\n+      f->value = field->value;\n+      gst_id_str_clear (&field->name);\n@@ -1084,1 +1699,2 @@\n-gst_structure_id_get_field (const GstStructure * structure, GQuark field_id)\n+gst_structure_id_str_get_field (const GstStructure * structure,\n+    const GstIdStr * fieldname)\n@@ -1094,1 +1710,1 @@\n-    if (G_UNLIKELY (field->name == field_id))\n+    if (G_UNLIKELY (gst_id_str_is_equal (&field->name, fieldname)))\n@@ -1107,0 +1723,3 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n+  GstStructureField *res;\n+\n@@ -1110,2 +1729,6 @@\n-  return gst_structure_id_get_field (structure,\n-      g_quark_from_string (fieldname));\n+  \/\/ Not technically correct but the string is never leaving this scope and is never copied\n+  gst_id_str_set_static_str (&s, fieldname);\n+  res = gst_structure_id_str_get_field (structure, &s);\n+  gst_id_str_clear (&s);\n+\n+  return res;\n@@ -1140,0 +1763,28 @@\n+\/**\n+ * gst_structure_id_str_get_value:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of the field to get\n+ *\n+ * Get the value of the field with name @fieldname.\n+ *\n+ * Returns: (nullable): the #GValue corresponding to the field with the given\n+ * name.\n+ *\n+ * Since: 1.26\n+ *\/\n+const GValue *\n+gst_structure_id_str_get_value (const GstStructure * structure,\n+    const GstIdStr * fieldname)\n+{\n+  GstStructureField *field;\n+\n+  g_return_val_if_fail (structure != NULL, NULL);\n+  g_return_val_if_fail (fieldname != NULL, NULL);\n+\n+  field = gst_structure_id_str_get_field (structure, fieldname);\n+  if (field == NULL)\n+    return NULL;\n+\n+  return &field->value;\n+}\n+\n@@ -1154,0 +1805,1 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n@@ -1157,1 +1809,2 @@\n-  gsfield = gst_structure_id_get_field (structure, field);\n+  gst_id_str_set_static_str (&s, g_quark_to_string (field));\n+  gsfield = gst_structure_id_str_get_field (structure, &s);\n@@ -1175,0 +1828,1 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n@@ -1176,1 +1830,0 @@\n-  GQuark id;\n@@ -1183,1 +1836,2 @@\n-  id = g_quark_from_string (fieldname);\n+  \/\/ Not technically correct but the string is never leaving this scope and is never copied\n+  gst_id_str_set_static_str (&s, fieldname);\n@@ -1185,1 +1839,0 @@\n-\n@@ -1189,1 +1842,1 @@\n-    if (field->name == id) {\n+    if (gst_id_str_is_equal (&field->name, &s)) {\n@@ -1193,0 +1846,2 @@\n+      gst_id_str_clear (&field->name);\n+      gst_id_str_clear (&s);\n@@ -1197,0 +1852,1 @@\n+  gst_id_str_clear (&s);\n@@ -1247,0 +1903,88 @@\n+\/**\n+ * gst_structure_id_str_remove_field:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of the field to remove\n+ *\n+ * Removes the field with the given name.  If the field with the given\n+ * name does not exist, the structure is unchanged.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_structure_id_str_remove_field (GstStructure * structure,\n+    const GstIdStr * fieldname)\n+{\n+  GstStructureField *field;\n+  guint i, len;\n+\n+  g_return_if_fail (structure != NULL);\n+  g_return_if_fail (fieldname != NULL);\n+  g_return_if_fail (IS_MUTABLE (structure));\n+\n+  len = GST_STRUCTURE_LEN (structure);\n+  for (i = 0; i < len; i++) {\n+    field = GST_STRUCTURE_FIELD (structure, i);\n+\n+    if (gst_id_str_is_equal (&field->name, fieldname)) {\n+      if (G_IS_VALUE (&field->value)) {\n+        g_value_unset (&field->value);\n+      }\n+      gst_id_str_clear (&field->name);\n+      _structure_remove_index (structure, i);\n+      return;\n+    }\n+  }\n+}\n+\n+\/**\n+ * gst_structure_id_str_remove_fields:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of the field to remove\n+ * @...: %NULL-terminated list of more fieldnames to remove\n+ *\n+ * Removes the fields with the given names. If a field does not exist, the\n+ * argument is ignored.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_structure_id_str_remove_fields (GstStructure * structure,\n+    const GstIdStr * fieldname, ...)\n+{\n+  va_list varargs;\n+\n+  g_return_if_fail (structure != NULL);\n+  g_return_if_fail (fieldname != NULL);\n+  \/* mutability checked in remove_field *\/\n+\n+  va_start (varargs, fieldname);\n+  gst_structure_id_str_remove_fields_valist (structure, fieldname, varargs);\n+  va_end (varargs);\n+}\n+\n+\/**\n+ * gst_structure_id_str_remove_fields_valist:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of the field to remove\n+ * @varargs: %NULL-terminated list of more fieldnames to remove\n+ *\n+ * va_list form of gst_structure_id_str_remove_fields().\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_structure_id_str_remove_fields_valist (GstStructure * structure,\n+    const GstIdStr * fieldname, va_list varargs)\n+{\n+  const GstIdStr *field = fieldname;\n+\n+  g_return_if_fail (structure != NULL);\n+  g_return_if_fail (fieldname != NULL);\n+  \/* mutability checked in remove_field *\/\n+\n+  while (field) {\n+    gst_structure_id_str_remove_field (structure, field);\n+    field = va_arg (varargs, const GstIdStr *);\n+  }\n+}\n+\n@@ -1262,2 +2006,142 @@\n-  for (i = GST_STRUCTURE_LEN (structure) - 1; i >= 0; i--) {\n-    field = GST_STRUCTURE_FIELD (structure, i);\n+  for (i = GST_STRUCTURE_LEN (structure) - 1; i >= 0; i--) {\n+    field = GST_STRUCTURE_FIELD (structure, i);\n+\n+    if (G_IS_VALUE (&field->value)) {\n+      g_value_unset (&field->value);\n+    }\n+    gst_id_str_clear (&field->name);\n+    _structure_remove_index (structure, i);\n+  }\n+}\n+\n+\/**\n+ * gst_structure_get_field_type:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of the field\n+ *\n+ * Finds the field with the given name, and returns the type of the\n+ * value it contains.  If the field is not found, G_TYPE_INVALID is\n+ * returned.\n+ *\n+ * Returns: the #GValue of the field\n+ *\/\n+GType\n+gst_structure_get_field_type (const GstStructure * structure,\n+    const gchar * fieldname)\n+{\n+  GstStructureField *field;\n+\n+  g_return_val_if_fail (structure != NULL, G_TYPE_INVALID);\n+  g_return_val_if_fail (fieldname != NULL, G_TYPE_INVALID);\n+\n+  field = gst_structure_get_field (structure, fieldname);\n+  if (field == NULL)\n+    return G_TYPE_INVALID;\n+\n+  return G_VALUE_TYPE (&field->value);\n+}\n+\n+\/**\n+ * gst_structure_id_str_get_field_type:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of the field\n+ *\n+ * Finds the field with the given name, and returns the type of the\n+ * value it contains.  If the field is not found, G_TYPE_INVALID is\n+ * returned.\n+ *\n+ * Returns: the #GValue of the field\n+ *\n+ * Since: 1.26\n+ *\/\n+GType\n+gst_structure_id_str_get_field_type (const GstStructure * structure,\n+    const GstIdStr * fieldname)\n+{\n+  GstStructureField *field;\n+\n+  g_return_val_if_fail (structure != NULL, G_TYPE_INVALID);\n+  g_return_val_if_fail (fieldname != NULL, G_TYPE_INVALID);\n+\n+  field = gst_structure_id_str_get_field (structure, fieldname);\n+  if (field == NULL)\n+    return G_TYPE_INVALID;\n+\n+  return G_VALUE_TYPE (&field->value);\n+}\n+\n+\/**\n+ * gst_structure_n_fields:\n+ * @structure: a #GstStructure\n+ *\n+ * Get the number of fields in the structure.\n+ *\n+ * Returns: the number of fields in the structure\n+ *\/\n+gint\n+gst_structure_n_fields (const GstStructure * structure)\n+{\n+  g_return_val_if_fail (structure != NULL, 0);\n+\n+  return GST_STRUCTURE_LEN (structure);\n+}\n+\n+\/**\n+ * gst_structure_nth_field_name:\n+ * @structure: a #GstStructure\n+ * @index: the index to get the name of\n+ *\n+ * Get the name of the given field number, counting from 0 onwards.\n+ *\n+ * Returns: the name of the given field number\n+ *\/\n+const gchar *\n+gst_structure_nth_field_name (const GstStructure * structure, guint index)\n+{\n+  GstStructureField *field;\n+\n+  g_return_val_if_fail (structure != NULL, NULL);\n+  g_return_val_if_fail (index < GST_STRUCTURE_LEN (structure), NULL);\n+\n+  field = GST_STRUCTURE_FIELD (structure, index);\n+\n+  return gst_id_str_as_str (&field->name);\n+}\n+\n+\/**\n+ * gst_structure_id_str_nth_field_name:\n+ * @structure: a #GstStructure\n+ * @index: the index to get the name of\n+ *\n+ * Get the name (as a GstIdStr) of the given field number,\n+ * counting from 0 onwards.\n+ *\n+ * Returns: the name of the given field number\n+ *\n+ * Since: 1.26\n+ *\/\n+const GstIdStr *\n+gst_structure_id_str_nth_field_name (const GstStructure * structure,\n+    guint index)\n+{\n+  GstStructureField *field;\n+\n+  g_return_val_if_fail (structure != NULL, NULL);\n+  g_return_val_if_fail (index < GST_STRUCTURE_LEN (structure), NULL);\n+\n+  field = GST_STRUCTURE_FIELD (structure, index);\n+\n+  return &field->name;\n+}\n+\n+typedef struct\n+{\n+  GstStructureForeachFunc func;\n+  gpointer user_data;\n+} ForeachAdapterData;\n+\n+static gboolean\n+foreach_quark_adapter (const GstIdStr * fieldname, const GValue * value,\n+    gpointer user_data)\n+{\n+  ForeachAdapterData *data = user_data;\n@@ -1265,5 +2149,2 @@\n-    if (G_IS_VALUE (&field->value)) {\n-      g_value_unset (&field->value);\n-    }\n-    _structure_remove_index (structure, i);\n-  }\n+  return data->func (g_quark_from_string (gst_id_str_as_str (fieldname)), value,\n+      data->user_data);\n@@ -1273,1 +2154,1 @@\n- * gst_structure_get_field_type:\n+ * gst_structure_foreach:\n@@ -1275,1 +2156,2 @@\n- * @fieldname: the name of the field\n+ * @func: (scope call) (closure user_data): a function to call for each field\n+ * @user_data: private data\n@@ -1277,3 +2159,3 @@\n- * Finds the field with the given name, and returns the type of the\n- * value it contains.  If the field is not found, G_TYPE_INVALID is\n- * returned.\n+ * Calls the provided function once for each field in the #GstStructure. The\n+ * function must not modify the fields. Also see gst_structure_map_in_place()\n+ * and gst_structure_filter_and_map_in_place().\n@@ -1281,1 +2163,4 @@\n- * Returns: the #GValue of the field\n+ * Returns: %TRUE if the supplied function returns %TRUE For each of the fields,\n+ * %FALSE otherwise.\n+ *\n+ * Deprecated: 1.26: Use gst_structure_foreach_id_str().\n@@ -1283,3 +2168,3 @@\n-GType\n-gst_structure_get_field_type (const GstStructure * structure,\n-    const gchar * fieldname)\n+gboolean\n+gst_structure_foreach (const GstStructure * structure,\n+    GstStructureForeachFunc func, gpointer user_data)\n@@ -1287,1 +2172,1 @@\n-  GstStructureField *field;\n+  ForeachAdapterData data = { func, user_data };\n@@ -1289,2 +2174,2 @@\n-  g_return_val_if_fail (structure != NULL, G_TYPE_INVALID);\n-  g_return_val_if_fail (fieldname != NULL, G_TYPE_INVALID);\n+  return gst_structure_foreach_id_str (structure, foreach_quark_adapter, &data);\n+}\n@@ -1292,3 +2177,5 @@\n-  field = gst_structure_get_field (structure, fieldname);\n-  if (field == NULL)\n-    return G_TYPE_INVALID;\n+typedef struct\n+{\n+  GstStructureMapFunc func;\n+  gpointer user_data;\n+} MapInPlaceAdapterData;\n@@ -1296,1 +2183,8 @@\n-  return G_VALUE_TYPE (&field->value);\n+static gboolean\n+map_in_place_quark_adapter (const GstIdStr * fieldname, GValue * value,\n+    gpointer user_data)\n+{\n+  MapInPlaceAdapterData *data = user_data;\n+\n+  return data->func (g_quark_from_string (gst_id_str_as_str (fieldname)), value,\n+      data->user_data);\n@@ -1300,1 +2194,1 @@\n- * gst_structure_n_fields:\n+ * gst_structure_map_in_place:\n@@ -1302,0 +2196,2 @@\n+ * @func: (scope call) (closure user_data): a function to call for each field\n+ * @user_data: private data\n@@ -1303,1 +2199,3 @@\n- * Get the number of fields in the structure.\n+ * Calls the provided function once for each field in the #GstStructure. In\n+ * contrast to gst_structure_foreach(), the function may modify but not delete the\n+ * fields. The structure must be mutable.\n@@ -1305,1 +2203,4 @@\n- * Returns: the number of fields in the structure\n+ * Returns: %TRUE if the supplied function returns %TRUE For each of the fields,\n+ * %FALSE otherwise.\n+ *\n+ * Deprecated: 1.26: Use gst_structure_map_in_place_id_str().\n@@ -1307,2 +2208,3 @@\n-gint\n-gst_structure_n_fields (const GstStructure * structure)\n+gboolean\n+gst_structure_map_in_place (GstStructure * structure,\n+    GstStructureMapFunc func, gpointer user_data)\n@@ -1310,1 +2212,1 @@\n-  g_return_val_if_fail (structure != NULL, 0);\n+  MapInPlaceAdapterData data = { func, user_data };\n@@ -1312,1 +2214,18 @@\n-  return GST_STRUCTURE_LEN (structure);\n+  return gst_structure_map_in_place_id_str (structure,\n+      map_in_place_quark_adapter, &data);\n+}\n+\n+typedef struct\n+{\n+  GstStructureFilterMapFunc func;\n+  gpointer user_data;\n+} FilterAndMapInPlaceAdapterData;\n+\n+static gboolean\n+filter_and_map_in_place_quark_adapter (const GstIdStr * fieldname,\n+    GValue * value, gpointer user_data)\n+{\n+  FilterAndMapInPlaceAdapterData *data = user_data;\n+\n+  return data->func (g_quark_from_string (gst_id_str_as_str (fieldname)), value,\n+      data->user_data);\n@@ -1316,1 +2235,1 @@\n- * gst_structure_nth_field_name:\n+ * gst_structure_filter_and_map_in_place:\n@@ -1318,1 +2237,2 @@\n- * @index: the index to get the name of\n+ * @func: (scope call) (closure user_data): a function to call for each field\n+ * @user_data: private data\n@@ -1320,1 +2240,5 @@\n- * Get the name of the given field number, counting from 0 onwards.\n+ * Calls the provided function once for each field in the #GstStructure. In\n+ * contrast to gst_structure_foreach(), the function may modify the fields.\n+ * In contrast to gst_structure_map_in_place(), the field is removed from\n+ * the structure if %FALSE is returned from the function.\n+ * The structure must be mutable.\n@@ -1322,1 +2246,3 @@\n- * Returns: the name of the given field number\n+ * Since: 1.6\n+ *\n+ * Deprecated: 1.26: Use gst_structure_filter_and_map_in_place_id_str().\n@@ -1324,2 +2250,3 @@\n-const gchar *\n-gst_structure_nth_field_name (const GstStructure * structure, guint index)\n+void\n+gst_structure_filter_and_map_in_place (GstStructure * structure,\n+    GstStructureFilterMapFunc func, gpointer user_data)\n@@ -1327,6 +2254,1 @@\n-  GstStructureField *field;\n-\n-  g_return_val_if_fail (structure != NULL, NULL);\n-  g_return_val_if_fail (index < GST_STRUCTURE_LEN (structure), NULL);\n-\n-  field = GST_STRUCTURE_FIELD (structure, index);\n+  FilterAndMapInPlaceAdapterData data = { func, user_data };\n@@ -1334,1 +2256,2 @@\n-  return g_quark_to_string (field->name);\n+  gst_structure_filter_and_map_in_place_id_str (structure,\n+      filter_and_map_in_place_quark_adapter, &data);\n@@ -1338,1 +2261,1 @@\n- * gst_structure_foreach:\n+ * gst_structure_foreach_id_str:\n@@ -1340,2 +2263,2 @@\n- * @func: (scope call): a function to call for each field\n- * @user_data: (closure): private data\n+ * @func: (scope call) (closure user_data): a function to call for each field\n+ * @user_data: private data\n@@ -1344,2 +2267,2 @@\n- * function must not modify the fields. Also see gst_structure_map_in_place()\n- * and gst_structure_filter_and_map_in_place().\n+ * function must not modify the fields. Also see gst_structure_map_in_place_id_str()\n+ * and gst_structure_filter_and_map_in_place_id_str().\n@@ -1349,0 +2272,2 @@\n+ *\n+ * Since: 1.26\n@@ -1351,2 +2276,2 @@\n-gst_structure_foreach (const GstStructure * structure,\n-    GstStructureForeachFunc func, gpointer user_data)\n+gst_structure_foreach_id_str (const GstStructure * structure,\n+    GstStructureForeachIdStrFunc func, gpointer user_data)\n@@ -1366,1 +2291,1 @@\n-    ret = func (field->name, &field->value, user_data);\n+    ret = func (&field->name, &field->value, user_data);\n@@ -1375,1 +2300,1 @@\n- * gst_structure_map_in_place:\n+ * gst_structure_map_in_place_id_str:\n@@ -1377,2 +2302,2 @@\n- * @func: (scope call): a function to call for each field\n- * @user_data: (closure): private data\n+ * @func: (scope call) (closure user_data): a function to call for each field\n+ * @user_data: private data\n@@ -1381,1 +2306,1 @@\n- * contrast to gst_structure_foreach(), the function may modify but not delete the\n+ * contrast to gst_structure_foreach_id_str(), the function may modify but not delete the\n@@ -1386,0 +2311,2 @@\n+ *\n+ * Since: 1.26\n@@ -1388,2 +2315,2 @@\n-gst_structure_map_in_place (GstStructure * structure,\n-    GstStructureMapFunc func, gpointer user_data)\n+gst_structure_map_in_place_id_str (GstStructure * structure,\n+    GstStructureMapIdStrFunc func, gpointer user_data)\n@@ -1403,1 +2330,1 @@\n-    ret = func (field->name, &field->value, user_data);\n+    ret = func (&field->name, &field->value, user_data);\n@@ -1412,1 +2339,1 @@\n- * gst_structure_filter_and_map_in_place:\n+ * gst_structure_filter_and_map_in_place_id_str:\n@@ -1414,2 +2341,2 @@\n- * @func: (scope call): a function to call for each field\n- * @user_data: (closure): private data\n+ * @func: (scope call) (closure user_data): a function to call for each field\n+ * @user_data: private data\n@@ -1418,2 +2345,2 @@\n- * contrast to gst_structure_foreach(), the function may modify the fields.\n- * In contrast to gst_structure_map_in_place(), the field is removed from\n+ * contrast to gst_structure_foreach_id_str(), the function may modify the fields.\n+ * In contrast to gst_structure_map_in_place_id_str(), the field is removed from\n@@ -1423,1 +2350,1 @@\n- * Since: 1.6\n+ * Since: 1.26\n@@ -1426,2 +2353,2 @@\n-gst_structure_filter_and_map_in_place (GstStructure * structure,\n-    GstStructureFilterMapFunc func, gpointer user_data)\n+gst_structure_filter_and_map_in_place_id_str (GstStructure * structure,\n+    GstStructureFilterMapIdStrFunc func, gpointer user_data)\n@@ -1441,1 +2368,1 @@\n-    ret = func (field->name, &field->value, user_data);\n+    ret = func (&field->name, &field->value, user_data);\n@@ -1447,0 +2374,1 @@\n+      gst_id_str_clear (&field->name);\n@@ -1463,0 +2391,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_structure_id_str_has_field().\n@@ -1467,1 +2397,1 @@\n-  GstStructureField *f;\n+  GstIdStr s = GST_ID_STR_INIT;\n@@ -1472,1 +2402,26 @@\n-  f = gst_structure_id_get_field (structure, field);\n+  gst_id_str_set_static_str (&s, g_quark_to_string (field));\n+\n+  return gst_structure_id_str_has_field (structure, &s);\n+}\n+\n+\/**\n+ * gst_structure_id_str_has_field:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of a field\n+ *\n+ * Check if @structure contains a field named @fieldname.\n+ *\n+ * Returns: %TRUE if the structure contains a field with the given name\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_structure_id_str_has_field (const GstStructure * structure,\n+    const GstIdStr * fieldname)\n+{\n+  GstStructureField *f;\n+\n+  g_return_val_if_fail (structure != NULL, FALSE);\n+  g_return_val_if_fail (fieldname != NULL, FALSE);\n+\n+  f = gst_structure_id_str_get_field (structure, fieldname);\n@@ -1490,0 +2445,3 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n+  gboolean res;\n+\n@@ -1493,2 +2451,6 @@\n-  return gst_structure_id_has_field (structure,\n-      g_quark_from_string (fieldname));\n+  \/\/ Not technically correct but the string is never leaving this scope and is never copied\n+  gst_id_str_set_static_str (&s, fieldname);\n+  res = gst_structure_id_str_has_field (structure, &s);\n+  gst_id_str_clear (&s);\n+\n+  return res;\n@@ -1506,0 +2468,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_structure_id_str_has_field_typed().\n@@ -1511,1 +2475,1 @@\n-  GstStructureField *f;\n+  GstIdStr s = GST_ID_STR_INIT;\n@@ -1516,1 +2480,27 @@\n-  f = gst_structure_id_get_field (structure, field);\n+  gst_id_str_set_static_str (&s, g_quark_to_string (field));\n+\n+  return gst_structure_id_str_has_field_typed (structure, &s, type);\n+}\n+\n+\/**\n+ * gst_structure_id_str_has_field_typed:\n+ * @structure: a #GstStructure\n+ * @fieldname: the name of a field\n+ * @type: the type of a value\n+ *\n+ * Check if @structure contains a field named @fieldname and with GType @type.\n+ *\n+ * Returns: %TRUE if the structure contains a field with the given name and type\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_structure_id_str_has_field_typed (const GstStructure * structure,\n+    const GstIdStr * fieldname, GType type)\n+{\n+  GstStructureField *f;\n+\n+  g_return_val_if_fail (structure != NULL, FALSE);\n+  g_return_val_if_fail (fieldname != NULL, FALSE);\n+\n+  f = gst_structure_id_str_get_field (structure, fieldname);\n@@ -1537,0 +2527,3 @@\n+  GstIdStr s = GST_ID_STR_INIT;\n+  gboolean res;\n+\n@@ -1540,2 +2533,6 @@\n-  return gst_structure_id_has_field_typed (structure,\n-      g_quark_from_string (fieldname), type);\n+  \/\/ Not technically correct but the string is never leaving this scope and is never copied\n+  gst_id_str_set_static_str (&s, fieldname);\n+  res = gst_structure_id_str_has_field_typed (structure, &s, type);\n+  gst_id_str_clear (&s);\n+\n+  return res;\n@@ -2065,1 +3062,1 @@\n-    g_string_append (s, g_quark_to_string (field->name));\n+    g_string_append (s, gst_id_str_as_str (&field->name));\n@@ -2074,1 +3071,1 @@\n-      g_string_append (s, g_quark_to_string (substruct->name));\n+      g_string_append (s, gst_structure_get_name (substruct));\n@@ -2099,0 +3096,4 @@\n+    } else if (G_TYPE_CHECK_VALUE_TYPE (&field->value, G_TYPE_ARRAY)) {\n+      GArray *arr = g_value_get_boxed (&field->value);\n+      g_string_append_printf (s, \"[%d %s]\", arr->len,\n+          arr->len == 1 ? \"entry\" : \"entries\");\n@@ -2102,1 +3103,1 @@\n-            g_quark_to_string (field->name),\n+            gst_id_str_as_str (&field->name),\n@@ -2116,1 +3117,1 @@\n-priv__gst_structure_append_template_to_gstring (GQuark field_id,\n+priv__gst_structure_append_template_to_gstring (const gchar * field,\n@@ -2124,1 +3125,1 @@\n-  g_string_append (s, g_quark_to_string (field_id));\n+  g_string_append (s, field);\n@@ -2180,1 +3181,1 @@\n-  g_string_append (s, g_quark_to_string (structure->name));\n+  g_string_append (s, gst_structure_get_name (structure));\n@@ -2298,1 +3299,1 @@\n-  field->name = g_quark_from_string (name);\n+  gst_id_str_set (&field->name, name);\n@@ -2871,1 +3872,1 @@\n-default_fixate (GQuark field_id, const GValue * value, gpointer data)\n+default_fixate (const GstIdStr * fieldname, GValue * value, gpointer data)\n@@ -2877,1 +3878,5 @@\n-    gst_structure_id_take_value (s, field_id, &v);\n+    if (gst_structure_validate_field_value (s, gst_id_str_as_str (fieldname),\n+            value)) {\n+      g_value_unset (value);\n+      *value = v;\n+    }\n@@ -2902,1 +3907,1 @@\n-  return default_fixate (field->name, &field->value, structure);\n+  return default_fixate (&field->name, &field->value, structure);\n@@ -2998,0 +4003,70 @@\n+\/**\n+ * gst_structure_id_str_get_valist:\n+ * @structure: a #GstStructure\n+ * @first_fieldname: the name of the first field to read\n+ * @args: variable arguments\n+ *\n+ * Parses the variable arguments and reads fields from @structure accordingly.\n+ * valist-variant of gst_structure_id_str_get(). Look at the documentation of\n+ * gst_structure_id_str_get() for more details.\n+ *\n+ * Returns: %TRUE, or %FALSE if there was a problem reading any of the fields\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_structure_id_str_get_valist (const GstStructure * structure,\n+    const GstIdStr * first_fieldname, va_list args)\n+{\n+  const GstIdStr *fieldname;\n+  GType expected_type = G_TYPE_INVALID;\n+\n+  g_return_val_if_fail (GST_IS_STRUCTURE (structure), FALSE);\n+  g_return_val_if_fail (first_fieldname != NULL, FALSE);\n+\n+  fieldname = first_fieldname;\n+  while (fieldname) {\n+    const GValue *val = NULL;\n+    gchar *err = NULL;\n+\n+    expected_type = va_arg (args, GType);\n+\n+    val = gst_structure_id_str_get_value (structure, fieldname);\n+\n+    if (val == NULL)\n+      goto no_such_field;\n+\n+    if (G_VALUE_TYPE (val) != expected_type)\n+      goto wrong_type;\n+\n+    GST_VALUE_LCOPY (val, args, 0, &err, gst_id_str_as_str (fieldname));\n+    if (err) {\n+      g_warning (\"%s: %s\", G_STRFUNC, err);\n+      g_free (err);\n+      return FALSE;\n+    }\n+\n+    fieldname = va_arg (args, const GstIdStr *);\n+  }\n+\n+  return TRUE;\n+\n+\/* ERRORS *\/\n+no_such_field:\n+  {\n+    GST_INFO (\"Expected field '%s' in structure: %\" GST_PTR_FORMAT,\n+        gst_id_str_as_str (fieldname), structure);\n+    return FALSE;\n+  }\n+wrong_type:\n+  {\n+    GST_INFO (\"Expected field '%s' in structure to be of type '%s', but \"\n+        \"field was of type '%s': %\" GST_PTR_FORMAT,\n+        gst_id_str_as_str (fieldname),\n+        GST_STR_NULL (g_type_name (expected_type)),\n+        G_VALUE_TYPE_NAME (gst_structure_id_str_get_value (structure,\n+                fieldname)), structure);\n+    return FALSE;\n+  }\n+}\n+\n@@ -3009,0 +4084,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_structure_id_str_get_valist().\n@@ -3027,0 +4104,1 @@\n+    G_GNUC_BEGIN_IGNORE_DEPRECATIONS;\n@@ -3028,0 +4106,1 @@\n+    G_GNUC_END_IGNORE_DEPRECATIONS;\n@@ -3056,0 +4135,1 @@\n+    G_GNUC_BEGIN_IGNORE_DEPRECATIONS;\n@@ -3062,0 +4142,1 @@\n+    G_GNUC_END_IGNORE_DEPRECATIONS;\n@@ -3103,0 +4184,39 @@\n+\/**\n+ * gst_structure_id_str_get:\n+ * @structure: a #GstStructure\n+ * @first_fieldname: the name of the first field to read\n+ * @...: variable arguments\n+ *\n+ * Parses the variable arguments and reads fields from @structure accordingly.\n+ * Variable arguments should be in the form field name (as GstIdStr), field type\n+ * (as a GType), pointer(s) to a variable(s) to hold the return value(s). The\n+ * last variable argument should be %NULL.\n+ *\n+ * For refcounted (mini)objects you will receive a new reference which\n+ * you must release with a suitable _unref\\() when no longer needed. For\n+ * strings and boxed types you will receive a copy which you will need to\n+ * release with either g_free() or the suitable function for the boxed type.\n+ *\n+ * Returns: %FALSE if there was a problem reading any of the fields (e.g.\n+ *     because the field requested did not exist, or was of a type other\n+ *     than the type specified), otherwise %TRUE.\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_structure_id_str_get (const GstStructure * structure,\n+    const GstIdStr * first_fieldname, ...)\n+{\n+  gboolean ret;\n+  va_list args;\n+\n+  g_return_val_if_fail (GST_IS_STRUCTURE (structure), FALSE);\n+  g_return_val_if_fail (first_fieldname != NULL, FALSE);\n+\n+  va_start (args, first_fieldname);\n+  ret = gst_structure_id_str_get_valist (structure, first_fieldname, args);\n+  va_end (args);\n+\n+  return ret;\n+}\n+\n@@ -3128,0 +4248,2 @@\n+ *\n+ * Deprecated: 1.26: Use gst_structure_id_str_get().\n@@ -3140,0 +4262,1 @@\n+  G_GNUC_BEGIN_IGNORE_DEPRECATIONS;\n@@ -3141,0 +4264,1 @@\n+  G_GNUC_END_IGNORE_DEPRECATIONS;\n@@ -3147,1 +4271,1 @@\n-gst_structure_is_equal_foreach (GQuark field_id, const GValue * val2,\n+gst_structure_is_equal_foreach (const GstIdStr * fieldname, const GValue * val2,\n@@ -3151,1 +4275,1 @@\n-  const GValue *val1 = gst_structure_id_get_value (struct1, field_id);\n+  const GValue *val1 = gst_structure_id_str_get_value (struct1, fieldname);\n@@ -3181,1 +4305,2 @@\n-  if (structure1->name != structure2->name) {\n+  if (!gst_id_str_is_equal (GST_STRUCTURE_NAME (structure1),\n+          GST_STRUCTURE_NAME (structure2))) {\n@@ -3188,2 +4313,2 @@\n-  return gst_structure_foreach (structure1, gst_structure_is_equal_foreach,\n-      (gpointer) structure2);\n+  return gst_structure_foreach_id_str (structure1,\n+      gst_structure_is_equal_foreach, (gpointer) structure2);\n@@ -3211,1 +4336,2 @@\n-  if (G_UNLIKELY (struct1->name != struct2->name))\n+  if (!gst_id_str_is_equal (GST_STRUCTURE_NAME (struct1),\n+          GST_STRUCTURE_NAME (struct2)))\n@@ -3218,1 +4344,3 @@\n-  dest = gst_structure_new_id_empty_with_size (struct1->name, MIN (len1, len2));\n+  dest =\n+      gst_structure_new_id_str_empty_with_size (GST_STRUCTURE_NAME (struct1),\n+      MIN (len1, len2));\n@@ -3227,2 +4355,2 @@\n-      if (field1->name == field2->name) {\n-        GValue dest_value = { 0 };\n+      if (gst_id_str_is_equal (&field1->name, &field2->name)) {\n+        GValue dest_value = G_VALUE_INIT;\n@@ -3232,1 +4360,1 @@\n-          gst_structure_id_take_value (dest, field1->name, &dest_value);\n+          gst_structure_id_str_take_value (dest, &field1->name, &dest_value);\n@@ -3242,1 +4370,1 @@\n-      gst_structure_id_set_value (dest, field1->name, &field1->value);\n+      gst_structure_id_str_set_value (dest, &field1->name, &field1->value);\n@@ -3253,1 +4381,1 @@\n-      if (field1->name == field2->name) {\n+      if (gst_id_str_is_equal (&field1->name, &field2->name)) {\n@@ -3259,1 +4387,1 @@\n-      gst_structure_id_set_value (dest, field2->name, &field2->value);\n+      gst_structure_id_str_set_value (dest, &field2->name, &field2->value);\n@@ -3271,2 +4399,2 @@\n-gst_caps_structure_can_intersect_field (GQuark id, const GValue * val1,\n-    gpointer data)\n+gst_caps_structure_can_intersect_field (const GstIdStr * fieldname,\n+    const GValue * val1, gpointer data)\n@@ -3275,1 +4403,1 @@\n-  const GValue *val2 = gst_structure_id_get_value (other, id);\n+  const GValue *val2 = gst_structure_id_str_get_value (other, fieldname);\n@@ -3313,1 +4441,2 @@\n-  if (G_UNLIKELY (struct1->name != struct2->name))\n+  if (G_UNLIKELY (!gst_id_str_is_equal (GST_STRUCTURE_NAME (struct1),\n+              GST_STRUCTURE_NAME (struct2))))\n@@ -3317,1 +4446,1 @@\n-  return gst_structure_foreach ((GstStructure *) struct1,\n+  return gst_structure_foreach_id_str ((GstStructure *) struct1,\n@@ -3341,1 +4470,2 @@\n-  if (G_UNLIKELY (superset->name != subset->name))\n+  if (G_UNLIKELY (!gst_id_str_is_equal (GST_STRUCTURE_NAME (superset),\n+              GST_STRUCTURE_NAME (subset))))\n@@ -3354,1 +4484,1 @@\n-      if (subfield->name == superfield->name) {\n+      if (gst_id_str_is_equal (&subfield->name, &superfield->name)) {\n@@ -3397,1 +4527,1 @@\n-  gst_structure_foreach (structure, default_fixate, structure);\n+  gst_structure_map_in_place_id_str (structure, default_fixate, structure);\n@@ -3494,2 +4624,3 @@\n-    gst_structure_id_set_value_internal (structure,\n-        g_quark_from_string (fieldname), &value);\n+    GstIdStr s = GST_ID_STR_INIT;\n+    gst_id_str_set (&s, fieldname);\n+    gst_structure_id_str_take_value_internal (structure, &s, &value);\n@@ -3498,0 +4629,1 @@\n+    g_value_unset (&value);\n@@ -3501,1 +4633,0 @@\n-  g_value_unset (&value);\n@@ -3583,0 +4714,20 @@\n+\n+\n+\/**\n+ * gst_structure_is_writable:\n+ * @structure: a #GstStructure\n+ *\n+ * Checks if the structure is writable. %TRUE if parent\n+ * is not set or its refcount is 1, %FALSE otherwise.\n+ *\n+ * Returns: %TRUE if the structure is writable.\n+ *\n+ * Since: 1.26.2\n+ *\/\n+gboolean\n+gst_structure_is_writable (const GstStructure * structure)\n+{\n+  g_return_val_if_fail (GST_IS_STRUCTURE (structure), FALSE);\n+\n+  return IS_MUTABLE (structure);\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gststructure.c","additions":1355,"deletions":204,"binary":false,"changes":1559,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include <gst\/gstidstr.h>\n@@ -121,0 +122,55 @@\n+\/**\n+ * GstStructureForeachIdStrFunc:\n+ * @fieldname: the #GstIdStr field name\n+ * @value: the #GValue of the field\n+ * @user_data: user data\n+ *\n+ * A function that will be called in gst_structure_foreach_id_str(). The\n+ * function may not modify @value.\n+ *\n+ * Returns: %TRUE if the foreach operation should continue, %FALSE if\n+ * the foreach operation should stop with %FALSE.\n+ *\n+ * Since: 1.26\n+ *\/\n+typedef gboolean (*GstStructureForeachIdStrFunc) (const GstIdStr * fieldname,\n+                                                  const GValue   * value,\n+                                                  gpointer         user_data);\n+\n+\/**\n+ * GstStructureMapIdStrFunc:\n+ * @fieldname: the #GstIdStr field name\n+ * @value: the #GValue of the field\n+ * @user_data: user data\n+ *\n+ * A function that will be called in gst_structure_map_in_place_id_str(). The\n+ * function may modify @value.\n+ *\n+ * Returns: %TRUE if the map operation should continue, %FALSE if\n+ * the map operation should stop with %FALSE.\n+ *\n+ * Since: 1.26\n+ *\/\n+typedef gboolean (*GstStructureMapIdStrFunc)     (const GstIdStr * fieldname,\n+                                                  GValue         * value,\n+                                                  gpointer         user_data);\n+\n+\/**\n+ * GstStructureFilterMapIdStrFunc:\n+ * @fieldname: the #GstIdStr field name\n+ * @value: the #GValue of the field\n+ * @user_data: user data\n+ *\n+ * A function that will be called in gst_structure_filter_and_map_in_place_id_str().\n+ * The function may modify @value, and the value will be removed from the\n+ * structure if %FALSE is returned.\n+ *\n+ * Returns: %TRUE if the field should be preserved, %FALSE if it\n+ * should be removed.\n+ *\n+ * Since: 1.26\n+ *\/\n+typedef gboolean (*GstStructureFilterMapIdStrFunc) (const GstIdStr * fieldname,\n+                                                   GValue          * value,\n+                                                   gpointer          user_data);\n+\n@@ -141,0 +197,3 @@\n+GstStructure *        gst_structure_new_static_str_empty (const gchar * name) G_GNUC_MALLOC;\n+\n+GST_DEPRECATED_FOR(gst_structure_new_id_str_empty)\n@@ -143,0 +202,3 @@\n+GST_API\n+GstStructure *        gst_structure_new_id_str_empty     (const GstIdStr *name) G_GNUC_MALLOC;\n+\n@@ -148,0 +210,8 @@\n+GstStructure *        gst_structure_new_static_str       (const gchar * name,\n+                                                          const gchar * firstfield,\n+                                                          ...) G_GNUC_NULL_TERMINATED  G_GNUC_MALLOC;\n+GST_API\n+GstStructure *        gst_structure_new_id_str_valist    (const GstIdStr * name,\n+                                                          const GstIdStr * firstfield,\n+                                                          va_list       varargs) G_GNUC_MALLOC;\n+GST_API\n@@ -152,0 +222,4 @@\n+GstStructure *        gst_structure_new_static_str_valist(const gchar * name,\n+                                                          const gchar * firstfield,\n+                                                          va_list       varargs) G_GNUC_MALLOC;\n+GST_DEPRECATED_FOR(gst_structure_new_id_str)\n@@ -155,0 +229,6 @@\n+\n+GST_API\n+GstStructure *        gst_structure_new_id_str           (const GstIdStr *name,\n+                                                          const GstIdStr *fieldname,\n+                                                          ...) G_GNUC_NULL_TERMINATED G_GNUC_MALLOC;\n+\n@@ -177,1 +257,1 @@\n-GST_API\n+GST_DEPRECATED_FOR(gst_structure_get_name_id_str)\n@@ -180,0 +260,3 @@\n+GST_API\n+const GstIdStr *      gst_structure_get_name_id_str      (const GstStructure  * structure);\n+\n@@ -184,0 +267,3 @@\n+void                  gst_structure_set_name_id_str      (GstStructure        * structure,\n+                                                          const GstIdStr      * name);\n+GST_API\n@@ -187,0 +273,3 @@\n+void                  gst_structure_set_name_static_str  (GstStructure        * structure,\n+                                                          const gchar         * name);\n+GST_DEPRECATED_FOR(gst_structure_id_str_set_value)\n@@ -191,0 +280,4 @@\n+void                  gst_structure_id_str_set_value     (GstStructure        * structure,\n+                                                          const GstIdStr      * fieldname,\n+                                                          const GValue        * value);\n+GST_API\n@@ -195,0 +288,4 @@\n+void                  gst_structure_set_value_static_str (GstStructure        * structure,\n+                                                          const gchar         * fieldname,\n+                                                          const GValue        * value);\n+GST_API\n@@ -202,1 +299,1 @@\n-GST_API\n+GST_DEPRECATED_FOR(gst_structure_id_str_take_value)\n@@ -207,0 +304,4 @@\n+void                  gst_structure_id_str_take_value    (GstStructure        * structure,\n+                                                          const GstIdStr      * fieldname,\n+                                                          GValue              * value);\n+GST_API\n@@ -211,0 +312,4 @@\n+void                  gst_structure_take_value_static_str(GstStructure        * structure,\n+                                                          const gchar         * fieldname,\n+                                                          GValue              * value);\n+GST_API\n@@ -215,0 +320,4 @@\n+void                  gst_structure_set_static_str       (GstStructure        * structure,\n+                                                          const gchar         * fieldname,\n+                                                          ...) G_GNUC_NULL_TERMINATED;\n+GST_API\n@@ -219,0 +328,4 @@\n+void                  gst_structure_set_static_str_valist(GstStructure        * structure,\n+                                                          const gchar         * fieldname,\n+                                                          va_list varargs);\n+GST_DEPRECATED_FOR(gst_structure_id_str_set)\n@@ -223,0 +336,4 @@\n+void                  gst_structure_id_str_set           (GstStructure        * structure,\n+                                                          const GstIdStr      * fieldname,\n+                                                          ...) G_GNUC_NULL_TERMINATED;\n+GST_DEPRECATED_FOR(gst_structure_id_str_set_valist)\n@@ -227,0 +344,4 @@\n+void                  gst_structure_id_str_set_valist    (GstStructure        * structure,\n+                                                          const GstIdStr      * fieldname,\n+                                                          va_list varargs);\n+GST_API\n@@ -235,0 +356,8 @@\n+gboolean              gst_structure_id_str_get_valist    (const GstStructure  * structure,\n+                                                          const GstIdStr      * first_fieldname,\n+                                                          va_list              args);\n+GST_API\n+gboolean              gst_structure_id_str_get           (const GstStructure  * structure,\n+                                                          const GstIdStr      * first_fieldname,\n+                                                          ...) G_GNUC_NULL_TERMINATED;\n+GST_DEPRECATED_FOR(gst_structure_id_str_get_valist)\n@@ -238,1 +367,1 @@\n-GST_API\n+GST_DEPRECATED_FOR(gst_structure_id_str_get)\n@@ -242,1 +371,1 @@\n-GST_API\n+GST_DEPRECATED_FOR(gst_structure_id_str_get_value)\n@@ -246,0 +375,3 @@\n+const GValue *        gst_structure_id_str_get_value     (const GstStructure  * structure,\n+                                                          const GstIdStr      * fieldname);\n+GST_API\n@@ -260,0 +392,11 @@\n+void                  gst_structure_id_str_remove_field  (GstStructure        * structure,\n+                                                          const GstIdStr      * fieldname);\n+GST_API\n+void                  gst_structure_id_str_remove_fields (GstStructure        * structure,\n+                                                          const GstIdStr      * fieldname,\n+                                                          ...) G_GNUC_NULL_TERMINATED;\n+GST_API\n+void                  gst_structure_id_str_remove_fields_valist(GstStructure  * structure,\n+                                                          const GstIdStr      * fieldname,\n+                                                          va_list               varargs);\n+GST_API\n@@ -266,0 +409,3 @@\n+GType                 gst_structure_id_str_get_field_type(const GstStructure  * structure,\n+                                                          const GstIdStr      * fieldname);\n+GST_DEPRECATED_FOR(gst_structure_foreach_id_str)\n@@ -269,1 +415,1 @@\n-GST_API\n+GST_DEPRECATED_FOR(gst_structure_map_in_place_id_str)\n@@ -273,0 +419,4 @@\n+GST_DEPRECATED_FOR(gst_structure_filter_and_map_in_place_id_str)\n+void                  gst_structure_filter_and_map_in_place (GstStructure             * structure,\n+                                                              GstStructureFilterMapFunc func,\n+                                                              gpointer                  user_data);\n@@ -274,3 +424,11 @@\n-void                  gst_structure_filter_and_map_in_place (GstStructure        * structure,\n-                                                          GstStructureFilterMapFunc   func,\n-                                                          gpointer              user_data);\n+gboolean              gst_structure_foreach_id_str       (const GstStructure         * structure,\n+                                                          GstStructureForeachIdStrFunc func,\n+                                                          gpointer                     user_data);\n+GST_API\n+gboolean              gst_structure_map_in_place_id_str  (GstStructure           * structure,\n+                                                          GstStructureMapIdStrFunc func,\n+                                                          gpointer                 user_data);\n+GST_API\n+void                  gst_structure_filter_and_map_in_place_id_str (GstStructure                 * structure,\n+                                                                    GstStructureFilterMapIdStrFunc func,\n+                                                                    gpointer                       user_data);\n@@ -284,0 +442,3 @@\n+const GstIdStr *      gst_structure_id_str_nth_field_name(const GstStructure  * structure,\n+                                                          guint                 index);\n+GST_DEPRECATED_FOR(gst_structure_id_str_has_field)\n@@ -286,1 +447,1 @@\n-GST_API\n+GST_DEPRECATED_FOR(gst_structure_id_str_has_field_typed)\n@@ -297,0 +458,7 @@\n+GST_API\n+gboolean              gst_structure_id_str_has_field     (const GstStructure  * structure,\n+                                                          const GstIdStr      * fieldname);\n+GST_API\n+gboolean              gst_structure_id_str_has_field_typed(const GstStructure  * structure,\n+                                                          const GstIdStr      * fieldname,\n+                                                          GType                 type);\n@@ -421,0 +589,3 @@\n+GST_API\n+gboolean              gst_structure_is_writable   (const GstStructure        * structure);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gststructure.h","additions":180,"deletions":9,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-#if defined(__BIONIC__)\n+#if defined(__ANDROID__)\n@@ -322,1 +322,1 @@\n-#if defined(__BIONIC__)\n+#if defined(__ANDROID__)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstsystemclock.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"gstquark.h\"\n@@ -47,0 +46,1 @@\n+#include \"gstidstr-private.h\"\n@@ -71,0 +71,1 @@\n+  GstIdStr name;\n@@ -76,1 +77,0 @@\n-  GQuark name_quark;            \/* quark for the name *\/\n@@ -553,1 +553,1 @@\n-  info = g_new (GstTagInfo, 1);\n+  info = g_new0 (GstTagInfo, 1);\n@@ -556,1 +556,1 @@\n-  info->name_quark = g_quark_from_static_string (name);\n+  gst_id_str_set_static_str (&info->name, name);\n@@ -758,1 +758,1 @@\n-  s = gst_structure_new_id_empty (GST_QUARK (TAGLIST));\n+  s = gst_structure_new_empty (\"taglist\");\n@@ -959,1 +959,1 @@\n-gst_tag_list_fields_equal (GQuark field_id, const GValue * value2,\n+gst_tag_list_fields_equal (const GstIdStr * field, const GValue * value2,\n@@ -963,1 +963,1 @@\n-  const GValue *value1 = gst_structure_id_get_value (struct1, field_id);\n+  const GValue *value1 = gst_structure_id_str_get_value (struct1, field);\n@@ -1020,1 +1020,2 @@\n-  return gst_structure_foreach (s1, gst_tag_list_fields_equal, (gpointer) s2);\n+  return gst_structure_foreach_id_str (s1, gst_tag_list_fields_equal,\n+      (gpointer) s2);\n@@ -1036,1 +1037,1 @@\n-  GQuark tag_quark;\n+  const GstIdStr *tag_name;\n@@ -1054,1 +1055,1 @@\n-  tag_quark = info->name_quark;\n+  tag_name = &info->name;\n@@ -1057,1 +1058,1 @@\n-      && (value2 = gst_structure_id_get_value (list, tag_quark)) != NULL) {\n+      && (value2 = gst_structure_id_str_get_value (list, tag_name)) != NULL) {\n@@ -1063,1 +1064,1 @@\n-        gst_structure_id_set_value (list, tag_quark, value);\n+        gst_structure_id_str_set_value (list, tag_name, value);\n@@ -1070,1 +1071,1 @@\n-          gst_structure_id_take_value (list, tag_quark, &dest);\n+          gst_structure_id_str_take_value (list, tag_name, &dest);\n@@ -1078,1 +1079,1 @@\n-          gst_structure_id_take_value (list, tag_quark, &dest);\n+          gst_structure_id_str_take_value (list, tag_name, &dest);\n@@ -1092,1 +1093,1 @@\n-        if (gst_structure_id_get_value (list, tag_quark) != NULL)\n+        if (gst_structure_id_str_get_value (list, tag_name) != NULL)\n@@ -1098,1 +1099,1 @@\n-        gst_structure_id_set_value (list, tag_quark, value);\n+        gst_structure_id_str_set_value (list, tag_name, value);\n@@ -1110,1 +1111,1 @@\n-gst_tag_list_copy_foreach (GQuark tag_quark, const GValue * value,\n+gst_tag_list_copy_foreach (const GstIdStr * field, const GValue * value,\n@@ -1116,1 +1117,1 @@\n-  tag = g_quark_to_string (tag_quark);\n+  tag = gst_id_str_as_str (field);\n@@ -1146,1 +1147,1 @@\n-  gst_structure_foreach (GST_TAG_LIST_STRUCTURE (from),\n+  gst_structure_foreach_id_str (GST_TAG_LIST_STRUCTURE (from),\n@@ -1403,1 +1404,1 @@\n-structure_foreach_wrapper (GQuark field_id, const GValue * value,\n+structure_foreach_wrapper (const GstIdStr * field, const GValue * value,\n@@ -1408,1 +1409,1 @@\n-  data->func (data->tag_list, g_quark_to_string (field_id), data->data);\n+  data->func (data->tag_list, gst_id_str_as_str (field), data->data);\n@@ -1415,2 +1416,2 @@\n- * @func: (scope call): function to be called for each tag\n- * @user_data: (closure): user specified data\n+ * @func: (scope call) (closure user_data): function to be called for each tag\n+ * @user_data: user specified data\n@@ -1433,1 +1434,1 @@\n-  gst_structure_foreach (GST_TAG_LIST_STRUCTURE (list),\n+  gst_structure_foreach_id_str (GST_TAG_LIST_STRUCTURE (list),\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttaglist.c","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -236,2 +236,2 @@\n- * @func: (scope async): the function to call\n- * @user_data: (closure): data to pass to @func\n+ * @func: (scope async) (closure user_data): the function to call\n+ * @user_data: data to pass to @func\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttaskpool.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-#include \"gstquark.h\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttoc.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,0 +55,5 @@\n+typedef struct\n+{\n+  gboolean use_structure_params;\n+} GstTracerClassPrivate;\n+\n@@ -65,0 +70,4 @@\n+#define _do_init \\\n+    g_type_add_class_private (g_define_type_id, \\\n+        sizeof (GstTracerClassPrivate));\n+\n@@ -66,1 +75,2 @@\n-G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE (GstTracer, gst_tracer, GST_TYPE_OBJECT);\n+G_DEFINE_ABSTRACT_TYPE_WITH_CODE (GstTracer, gst_tracer, GST_TYPE_OBJECT,\n+    G_ADD_PRIVATE (GstTracer) _do_init);\n@@ -73,0 +83,2 @@\n+\n+  G_OBJECT_CLASS (parent_class)->dispose (object);\n@@ -105,0 +117,1 @@\n+      g_free (self->priv->params);\n@@ -195,0 +208,45 @@\n+\n+\/**\n+ * gst_tracer_class_uses_structure_params:\n+ * @tracer_class: the #GstTracerClass to to check\n+ *\n+ * If set, the tracer subsystem will consider parameters passed to the\n+ * `GST_TRACERS` environment variable as a #GstStructure and use its\n+ * fields as properties to instanciate the tracer.\n+ *\n+ * Returns: %TRUE if the tracer uses structure parameters, %FALSE otherwise\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_tracer_class_uses_structure_params (GstTracerClass * tracer_class)\n+{\n+  g_return_val_if_fail (GST_IS_TRACER_CLASS (tracer_class), FALSE);\n+\n+  return G_TYPE_CLASS_GET_PRIVATE (tracer_class, GST_TYPE_TRACER,\n+      GstTracerClassPrivate)->use_structure_params;\n+}\n+\n+\/**\n+ * gst_tracer_class_set_use_structure_params:\n+ * @tracer_class: the #GstTracerFactoryClass to mark as using structure parameters\n+ * @use_structure_params: %TRUE to use structure parameters, %FALSE otherwise\n+ *\n+ * Sets whether the tracer should use structure parameters for configuration.\n+ * This function configures how parameters should be passed when instantiating\n+ * the tracer.\n+ *\n+ * This is typically called in the tracer's class initialization function to\n+ * indicate its parameter handling preference.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_tracer_class_set_use_structure_params (GstTracerClass * tracer_class,\n+    gboolean use_structure_params)\n+{\n+  g_return_if_fail (GST_IS_TRACER_CLASS (tracer_class));\n+\n+  G_TYPE_CLASS_GET_PRIVATE (tracer_class, GST_TYPE_TRACER,\n+      GstTracerClassPrivate)->use_structure_params = use_structure_params;\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttracer.c","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -78,0 +78,6 @@\n+GST_API\n+gboolean gst_tracer_class_uses_structure_params  (GstTracerClass *tracer_class);\n+GST_API\n+void gst_tracer_class_set_use_structure_params   (GstTracerClass *tracer_class,\n+                                                  gboolean use_structure_params);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttracer.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gsttracer.h\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttracerfactory.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttracerfactory.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-build_field_template (GQuark field_id, const GValue * value, gpointer user_data)\n+build_field_template (const GstIdStr * field, const GValue * value,\n+    gpointer user_data)\n@@ -72,1 +73,1 @@\n-        g_quark_to_string (field_id), G_VALUE_TYPE_NAME (value));\n+        gst_id_str_as_str (field), G_VALUE_TYPE_NAME (value));\n@@ -81,1 +82,1 @@\n-    gchar *opt_name = g_strconcat (\"have-\", g_quark_to_string (field_id), NULL);\n+    gchar *opt_name = g_strconcat (\"have-\", gst_id_str_as_str (field), NULL);\n@@ -85,2 +86,2 @@\n-    priv__gst_structure_append_template_to_gstring (g_quark_from_string\n-        (opt_name), &template_value, s);\n+    priv__gst_structure_append_template_to_gstring (opt_name, &template_value,\n+        s);\n@@ -92,1 +93,2 @@\n-  res = priv__gst_structure_append_template_to_gstring (field_id,\n+  res =\n+      priv__gst_structure_append_template_to_gstring (gst_id_str_as_str (field),\n@@ -103,1 +105,1 @@\n-  gchar *name = (gchar *) g_quark_to_string (structure->name);\n+  gchar *name = (gchar *) gst_structure_get_name (structure);\n@@ -119,1 +121,1 @@\n-  gst_structure_foreach (structure, build_field_template, s);\n+  gst_structure_foreach_id_str (structure, build_field_template, s);\n@@ -138,0 +140,2 @@\n+\n+  G_OBJECT_CLASS (parent_class)->dispose (object);\n@@ -192,1 +196,0 @@\n-  GQuark id;\n@@ -200,1 +203,0 @@\n-    id = g_quark_from_string (firstfield);\n@@ -222,1 +224,1 @@\n-    gst_structure_id_take_value (structure, id, &val);\n+    gst_structure_take_value (structure, firstfield, &val);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttracerrecord.c","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gstvalue.h\"\n@@ -59,1 +60,2 @@\n-  \"pad-chain-list-post\",\n+  \"pad-chain-list-post\", \"pad-send-event-pre\", \"pad-send-event-post\",\n+  \"memory-init\", \"memory-free-pre\", \"memory-free-post\",\n@@ -69,0 +71,174 @@\n+static gchar *\n+list_available_tracer_properties (GObjectClass * class)\n+{\n+  GParamSpec **properties;\n+  guint n_properties;\n+  GString *props_str;\n+  guint i;\n+\n+  props_str = g_string_new (NULL);\n+  properties = g_object_class_list_properties (class, &n_properties);\n+\n+  if (n_properties == 0) {\n+    g_string_append (props_str, \"No properties available\");\n+    g_free (properties);\n+    return g_string_free (props_str, FALSE);\n+  }\n+\n+  g_string_append (props_str, \"Available properties:\");\n+\n+  for (i = 0; i < n_properties; i++) {\n+    GParamSpec *prop = properties[i];\n+\n+    if (!((prop->flags & G_PARAM_CONSTRUCT)\n+            || (prop->flags & G_PARAM_CONSTRUCT_ONLY))\n+        || !(prop->flags & G_PARAM_WRITABLE))\n+      continue;\n+\n+    if (!g_strcmp0 (g_param_spec_get_name (prop), \"parent\"))\n+      continue;\n+    if (!g_strcmp0 (g_param_spec_get_name (prop), \"params\"))\n+      continue;\n+\n+    const gchar *type_name = G_PARAM_SPEC_TYPE_NAME (prop);\n+    GValue default_value = G_VALUE_INIT;\n+\n+    \/* Get default value if possible *\/\n+    g_value_init (&default_value, prop->value_type);\n+    g_param_value_set_default (prop, &default_value);\n+    gchar *default_str = g_strdup_value_contents (&default_value);\n+\n+    g_string_append_printf (props_str,\n+        \"\\n  '%s' (%s) (Default: %s): %s\",\n+        g_param_spec_get_name (prop),\n+        type_name,\n+        default_str,\n+        g_param_spec_get_blurb (prop) ? g_param_spec_get_blurb (prop) :\n+        \"(no description available)\");\n+\n+    g_free (default_str);\n+    g_value_unset (&default_value);\n+  }\n+\n+  g_free (properties);\n+  return g_string_free (props_str, FALSE);\n+}\n+\n+static void\n+gst_tracer_utils_create_tracer (GstTracerFactory * factory, const gchar * name,\n+    const gchar * params)\n+{\n+  gchar *available_props = NULL;\n+  GObjectClass *gobject_class = g_type_class_ref (factory->type);\n+  GstTracer *tracer = NULL;\n+  const gchar **names = NULL;\n+  GValue *values = NULL;\n+  gint n_properties = 1;\n+  GstStructure *structure = NULL;\n+\n+  if (gst_tracer_class_uses_structure_params (GST_TRACER_CLASS (gobject_class))) {\n+    GST_DEBUG (\"Use structure parameters for %s\", params);\n+\n+    if (!params) {\n+      n_properties = 0;\n+      goto create;\n+    }\n+\n+    gchar *struct_str = g_strdup_printf (\"%s,%s\", name, params);\n+    structure = gst_structure_from_string (struct_str, NULL);\n+    g_free (struct_str);\n+\n+    if (!structure) {\n+      available_props = list_available_tracer_properties (gobject_class);\n+      g_warning\n+          (\"Can't instantiate `%s` tracer: invalid parameters '%s'\\n  %s\\n\",\n+          name, params, available_props);\n+      goto done;\n+    }\n+    n_properties = gst_structure_n_fields (structure);\n+\n+    names = g_new0 (const gchar *, n_properties);\n+    values = g_new0 (GValue, n_properties);\n+    for (gint i = 0; i < n_properties; i++) {\n+      const gchar *field_name = gst_structure_nth_field_name (structure, i);\n+      const GValue *field_value =\n+          gst_structure_get_value (structure, field_name);\n+      GParamSpec *pspec =\n+          g_object_class_find_property (gobject_class, field_name);\n+\n+      if (!pspec) {\n+        available_props = list_available_tracer_properties (gobject_class);\n+        g_warning\n+            (\"Can't instantiate `%s` tracer: property '%s' not found\\n  %s\\n\",\n+            name, field_name, available_props);\n+        goto done;\n+      }\n+\n+      if (G_VALUE_TYPE (field_value) == pspec->value_type) {\n+        names[i] = field_name;\n+        g_value_init (&values[i], G_VALUE_TYPE (field_value));\n+        g_value_copy (field_value, &values[i]);\n+      } else if (G_VALUE_TYPE (field_value) == G_TYPE_STRING) {\n+        names[i] = field_name;\n+        g_value_init (&values[i], G_PARAM_SPEC_VALUE_TYPE (pspec));\n+        if (!gst_value_deserialize_with_pspec (&values[i],\n+                g_value_get_string (field_value), pspec)) {\n+          available_props = list_available_tracer_properties (gobject_class);\n+          g_warning\n+              (\"Can't instantiate `%s` tracer: invalid property '%s' value: '%s'\\n  %s\\n\",\n+              name, field_name, g_value_get_string (field_value),\n+              available_props);\n+          goto done;\n+        }\n+      } else {\n+        available_props = list_available_tracer_properties (gobject_class);\n+        g_warning\n+            (\"Can't instantiate `%s` tracer: property '%s' type mismatch, expected %s, got %s\\n  %s\\n\",\n+            name, field_name, g_type_name (pspec->value_type),\n+            g_type_name (G_VALUE_TYPE (field_value)), available_props);\n+        goto done;\n+      }\n+    }\n+  } else {\n+    names = g_new0 (const gchar *, n_properties);\n+    names[0] = (const gchar *) \"params\";\n+    values = g_new0 (GValue, 1);\n+    g_value_init (&values[0], G_TYPE_STRING);\n+    g_value_set_string (&values[0], params);\n+  }\n+  GST_INFO_OBJECT (factory, \"creating tracer: type-id=%u\",\n+      (guint) factory->type);\n+\n+create:\n+  tracer =\n+      GST_TRACER (g_object_new_with_properties (factory->type,\n+          n_properties, names, values));\n+\n+done:\n+  g_free (available_props);\n+\n+  if (structure)\n+    gst_structure_free (structure);\n+\n+  if (values) {\n+    for (gint j = 0; j < n_properties; j++) {\n+      if (G_VALUE_TYPE (&values[j]) != G_TYPE_INVALID)\n+        g_value_unset (&values[j]);\n+    }\n+  }\n+\n+  g_free (names);\n+  g_free (values);\n+\n+  if (tracer) {\n+    \/* Clear floating flag *\/\n+    gst_object_ref_sink (tracer);\n+\n+    \/* tracers register them self to the hooks *\/\n+    gst_object_unref (tracer);\n+\n+  }\n+\n+  g_type_class_unref (gobject_class);\n+}\n+\n@@ -131,12 +307,2 @@\n-          GstTracer *tracer;\n-\n-          GST_INFO_OBJECT (factory, \"creating tracer: type-id=%u\",\n-              (guint) factory->type);\n-\n-          tracer = g_object_new (factory->type, \"params\", params, NULL);\n-\n-          \/* Clear floating flag *\/\n-          gst_object_ref_sink (tracer);\n-\n-          \/* tracers register them self to the hooks *\/\n-          gst_object_unref (tracer);\n+          gst_tracer_utils_create_tracer (factory, t[i], params);\n+          gst_object_unref (factory);\n@@ -144,2 +310,1 @@\n-          GST_WARNING_OBJECT (feature,\n-              \"loading plugin containing feature %s failed!\", t[i]);\n+          g_warning (\"loading plugin containing feature %s failed!\", t[i]);\n@@ -147,2 +312,3 @@\n-      } else {\n-        GST_WARNING (\"no tracer named '%s'\", t[i]);\n+        gst_object_unref (feature);\n+      } else if (t[i][0] != '\\0') {\n+        g_warning (\"no tracer named '%s'\", t[i]);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttracerutils.c","additions":183,"deletions":17,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -87,0 +87,26 @@\n+  GST_TRACER_QUARK_HOOK_PAD_SEND_EVENT_PRE,\n+  GST_TRACER_QUARK_HOOK_PAD_SEND_EVENT_POST,\n+  \/**\n+   * GST_TRACER_QUARK_HOOK_MEMORY_INIT:\n+   *\n+   * Post-hook for memory initialization named \"memory-init\".\n+   *\n+   * Since: 1.26\n+   *\/\n+  GST_TRACER_QUARK_HOOK_MEMORY_INIT,\n+  \/**\n+   * GST_TRACER_QUARK_HOOK_MEMORY_FREE_PRE:\n+   *\n+   * Pre-hook for memory freeing named \"memory-free-pre\".\n+   *\n+   * Since: 1.26\n+   *\/\n+  GST_TRACER_QUARK_HOOK_MEMORY_FREE_PRE,\n+  \/**\n+   * GST_TRACER_QUARK_HOOK_MEMORY_FREE_POST:\n+   *\n+   * Post-hook for memory freeing named \"memory-free-post\".\n+   *\n+   * Since: 1.26\n+   *\/\n+  GST_TRACER_QUARK_HOOK_MEMORY_FREE_POST,\n@@ -237,1 +263,6 @@\n- * Pre-hook for gst_pad_push_event() named \"pad-push-event-pre\".\n+ * Pre-hook for when an event is pushed through a pad, named\n+ * \"pad-push-event-pre\".\n+ *\n+ * Called by gst_pad_push_event(). Also called by functions other than\n+ * gst_pad_push_event() that call gst_pad_push_event_unchecked() directly,\n+ * namely push_sticky() and check_sticky().\n@@ -253,1 +284,6 @@\n- * Post-hook for gst_pad_push_event() named \"pad-push-event-post\".\n+ * Post-hook for when an event has been pushed through a pad, named\n+ * \"pad-push-event-post\".\n+ *\n+ * Called by gst_pad_push_event(). Also called by functions other than\n+ * gst_pad_push_event() that call gst_pad_push_event_unchecked() directly,\n+ * namely push_sticky() and check_sticky().\n@@ -262,0 +298,32 @@\n+\/**\n+ * GstTracerHookPadSendEventPre:\n+ * @self: the tracer instance\n+ * @ts: the current timestamp\n+ * @pad: the pad\n+ * @event: the event\n+    *\n+ * Pre-hook for gst_pad_send_event_unchecked() named \"pad-send-event-pre\".\n+ *\/\n+typedef void (*GstTracerHookPadSendEventPre) (GObject *self, GstClockTime ts,\n+    GstPad *pad, GstEvent *event);\n+#define GST_TRACER_PAD_SEND_EVENT_PRE(pad, event) G_STMT_START{ \\\n+  GST_TRACER_DISPATCH(GST_TRACER_QUARK(HOOK_PAD_SEND_EVENT_PRE), \\\n+    GstTracerHookPadSendEventPre, (GST_TRACER_ARGS, pad, event)); \\\n+}G_STMT_END\n+\n+\/**\n+ * GstTracerHookPadSendEventPost:\n+ * @self: the tracer instance\n+ * @ts: the current timestamp\n+ * @pad: the pad\n+ * @res: the result of gst_pad_send_event_unchecked()\n+ *\n+ * Post-hook for gst_pad_send_event_unchecked() named \"pad-send-event-post\".\n+ *\/\n+typedef void (*GstTracerHookPadSendEventPost) (GObject *self, GstClockTime ts,\n+    GstPad *pad, GstFlowReturn res);\n+#define GST_TRACER_PAD_SEND_EVENT_POST(pad, res) G_STMT_START{ \\\n+  GST_TRACER_DISPATCH(GST_TRACER_QUARK(HOOK_PAD_SEND_EVENT_POST), \\\n+    GstTracerHookPadSendEventPost, (GST_TRACER_ARGS, pad, res)); \\\n+}G_STMT_END\n+\n@@ -842,0 +910,73 @@\n+\/**\n+ * GstTracerHookMemoryInit:\n+ * @self: the tracer instance\n+ * @ts: the current timestamp\n+ * @mem:  The GstMemory that was initialized\n+ *\n+ * Hook for memory initialization named \"memory-init\".\n+ *\n+ * Since: 1.26\n+ *\/\n+typedef void (*GstTracerHookMemoryInit) (GObject *self, GstClockTime ts,\n+    GstMemory *mem);\n+\/**\n+ * GST_TRACER_MEMORY_INIT:\n+ * @mem: a #GstMemory\n+ *\n+ * Dispatches the \"memory-init\" hook.\n+ *\n+ * Since: 1.26\n+ *\/\n+#define GST_TRACER_MEMORY_INIT(mem) G_STMT_START{ \\\n+  GST_TRACER_DISPATCH(GST_TRACER_QUARK(HOOK_MEMORY_INIT), \\\n+    GstTracerHookMemoryInit, (GST_TRACER_ARGS, mem)); \\\n+}G_STMT_END\n+\n+\/**\n+ * GstTracerHookMemoryFreePre:\n+ * @self: the tracer instance\n+ * @ts: the current timestamp\n+ * @mem: the memory object for which the memory will be freed.\n+ *\n+ * Pre-hook for memory freeing named \"memory-free-pre\".\n+ *\n+ * Since: 1.26\n+ *\/\n+typedef void (*GstTracerHookMemoryFreePre) (GObject *self, GstClockTime ts, GstMemory *mem);\n+\/**\n+ * GST_TRACER_MEMORY_FREE_PRE:\n+ * @mem: the memory object\n+ *\n+ * Dispatches the \"memory-free-pre\" hook.\n+ *\n+ * Since: 1.26\n+ *\/\n+#define GST_TRACER_MEMORY_FREE_PRE(mem) G_STMT_START{ \\\n+  GST_TRACER_DISPATCH(GST_TRACER_QUARK(HOOK_MEMORY_FREE_PRE), \\\n+    GstTracerHookMemoryFreePre, (GST_TRACER_ARGS, mem)); \\\n+}G_STMT_END\n+\n+\/**\n+ * GstTracerHookMemoryFreePost:\n+ * @self: the tracer instance\n+ * @ts: the current timestamp\n+ * @mem: pointer to the memory object that has been freed\n+ *\n+ * Post-hook for memory freeing named \"memory-free-post\".\n+ *\n+ * Since: 1.26\n+ *\/\n+typedef void (*GstTracerHookMemoryFreePost) (GObject *self, GstClockTime ts, GstMemory *mem);\n+\/**\n+ * GST_TRACER_MEMORY_FREE_POST:\n+ * @mem: pointer to the memory object that has been freed\n+ *\n+ * Dispatches the \"memory-free-post\" hook.\n+ *\n+ * Since: 1.26\n+ *\/\n+#define GST_TRACER_MEMORY_FREE_POST(mem) G_STMT_START{ \\\n+  GST_TRACER_DISPATCH(GST_TRACER_QUARK(HOOK_MEMORY_FREE_POST), \\\n+    GstTracerHookMemoryFreePost, (GST_TRACER_ARGS, mem)); \\\n+}G_STMT_END\n+\n@@ -895,0 +1036,6 @@\n+#define GST_TRACER_PAD_SEND_EVENT_PRE(pad, event)\n+#define GST_TRACER_PAD_SEND_EVENT_POST(pad, res)\n+#define GST_TRACER_MEMORY_INIT(mem)\n+#define GST_TRACER_MEMORY_FREE_PRE(mem)\n+#define GST_TRACER_MEMORY_FREE_POST(mem)\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsttracerutils.h","additions":149,"deletions":2,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -2031,1 +2031,1 @@\n-      uri->port != GST_URI_NO_PORT)\n+      uri->port != GST_URI_NO_PORT || !g_strcmp0 (uri->scheme, \"file\")) {\n@@ -2033,0 +2033,1 @@\n+  }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gsturi.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"gstquark.h\"\n@@ -3563,1 +3562,2 @@\n- * @search_func: (scope call): function to compare two elements, @search_data will always be passed as second argument\n+ * @search_func: (scope call) (closure user_data): function to compare two\n+ *    elements, @search_data will always be passed as second argument\n@@ -3566,1 +3566,1 @@\n- * @user_data: (closure): data to pass to @search_func\n+ * @user_data: data to pass to @search_func\n@@ -3947,0 +3947,80 @@\n+\/**\n+ * gst_util_fraction_multiply_int64:\n+ * @a_n: Numerator of first value\n+ * @a_d: Denominator of first value\n+ * @b_n: Numerator of second value\n+ * @b_d: Denominator of second value\n+ * @res_n: (out): Pointer to #gint to hold the result numerator\n+ * @res_d: (out): Pointer to #gint to hold the result denominator\n+ *\n+ * Multiplies the fractions @a_n\/@a_d and @b_n\/@b_d and stores\n+ * the result in @res_n and @res_d.\n+ *\n+ * Returns: %FALSE on overflow, %TRUE otherwise.\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_util_fraction_multiply_int64 (gint64 a_n, gint64 a_d, gint64 b_n,\n+    gint64 b_d, gint64 * res_n, gint64 * res_d)\n+{\n+  gint gcd;\n+  gint64 initial_a_n, initial_a_d;\n+\n+  initial_a_n = a_n;\n+  initial_a_d = a_d;\n+\n+  g_return_val_if_fail (res_n != NULL, FALSE);\n+  g_return_val_if_fail (res_d != NULL, FALSE);\n+  g_return_val_if_fail (a_d != 0, FALSE);\n+  g_return_val_if_fail (b_d != 0, FALSE);\n+\n+  \/* early out if either is 0, as its gcd would be 0 *\/\n+  if (a_n == 0 || b_n == 0) {\n+    *res_n = 0;\n+    *res_d = 1;\n+    return TRUE;\n+  }\n+\n+  gcd = gst_util_greatest_common_divisor_int64 (a_n, a_d);\n+  a_n \/= gcd;\n+  a_d \/= gcd;\n+\n+  gcd = gst_util_greatest_common_divisor_int64 (b_n, b_d);\n+  b_n \/= gcd;\n+  b_d \/= gcd;\n+\n+  gcd = gst_util_greatest_common_divisor_int64 (a_n, b_d);\n+  a_n \/= gcd;\n+  b_d \/= gcd;\n+\n+  gcd = gst_util_greatest_common_divisor_int64 (a_d, b_n);\n+  a_d \/= gcd;\n+  b_n \/= gcd;\n+\n+  \/* This would result in overflow *\/\n+  if (a_n != 0 && G_MAXINT64 \/ ABS (a_n) < ABS (b_n)) {\n+    gcd = gst_util_greatest_common_divisor_int64 (initial_a_n, initial_a_d);\n+    GST_INFO (\"gcd(a_n(%\" G_GINT64_FORMAT \"), a_d(%\" G_GINT64_FORMAT \")) = %d\",\n+        initial_a_n, initial_a_d, gcd);\n+    GST_INFO (\"Integer overflow in numerator multiplication: %\" G_GINT64_FORMAT\n+        \" * %\" G_GINT64_FORMAT \" > G_MAXINT64\", ABS (a_n), ABS (b_n));\n+    return FALSE;\n+  }\n+  if (G_MAXINT64 \/ ABS (a_d) < ABS (b_d)) {\n+    GST_ERROR (\"Integer overflow in denominator multiplication: %\"\n+        G_GINT64_FORMAT \" * %\" G_GINT64_FORMAT \" > G_MAXINT64\", ABS (a_d),\n+        ABS (b_d));\n+    return FALSE;\n+  }\n+\n+  *res_n = a_n * b_n;\n+  *res_d = a_d * b_d;\n+\n+  gcd = gst_util_greatest_common_divisor_int64 (*res_n, *res_d);\n+  *res_n \/= gcd;\n+  *res_d \/= gcd;\n+\n+  return TRUE;\n+}\n+\n@@ -4541,0 +4621,45 @@\n+\/**\n+ * gst_util_floor_log2:\n+ * @v: a #guint32 value.\n+ *\n+ * Returns smallest integral value not bigger than log2(v).\n+ *\n+ * Returns: a computed #guint val.\n+ *\n+ * Since: 1.26\n+ *\/\n+guint\n+gst_util_floor_log2 (guint32 v)\n+{\n+  guint32 result = 0;\n+\n+  g_return_val_if_fail (v != 0, -1);\n+\n+  if (v & 0xffff0000) {\n+    v >>= 16;\n+    result += 16;\n+  }\n+\n+  if (v & 0xff00) {\n+    v >>= 8;\n+    result += 8;\n+  }\n+\n+  if (v & 0xf0) {\n+    v >>= 4;\n+    result += 4;\n+  }\n+\n+  if (v & 0xc) {\n+    v >>= 2;\n+    result += 2;\n+  }\n+\n+  if (v & 0x2) {\n+    v >>= 1;\n+    result += 1;\n+  }\n+\n+  return result;\n+}\n+\n@@ -4794,0 +4919,4 @@\n+\/* Initialized in _priv_gst_plugin_initialize(). *\/\n+GQuark _priv_gst_plugin_api_quark;\n+GQuark _priv_gst_plugin_api_flags_quark;\n+\n@@ -4815,2 +4944,2 @@\n-  g_type_set_qdata (type, GST_QUARK (PLUGIN_API), GINT_TO_POINTER (TRUE));\n-  g_type_set_qdata (type, GST_QUARK (PLUGIN_API_FLAGS),\n+  g_type_set_qdata (type, _priv_gst_plugin_api_quark, GINT_TO_POINTER (TRUE));\n+  g_type_set_qdata (type, _priv_gst_plugin_api_flags_quark,\n@@ -4836,1 +4965,1 @@\n-      !!GPOINTER_TO_INT (g_type_get_qdata (type, GST_QUARK (PLUGIN_API)));\n+      !!GPOINTER_TO_INT (g_type_get_qdata (type, _priv_gst_plugin_api_quark));\n@@ -4840,1 +4969,2 @@\n-        GPOINTER_TO_INT (g_type_get_qdata (type, GST_QUARK (PLUGIN_API_FLAGS)));\n+        GPOINTER_TO_INT (g_type_get_qdata (type,\n+            _priv_gst_plugin_api_flags_quark));\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstutils.c","additions":137,"deletions":7,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -1225,0 +1225,3 @@\n+gboolean      gst_util_fraction_multiply_int64  (gint64 a_n, gint64 a_d, gint64 b_n, gint64 b_d,\n+                                                 gint64 *res_n, gint64 *res_d);\n+GST_API\n@@ -1247,0 +1250,3 @@\n+GST_API\n+guint         gst_util_floor_log2               (guint32 v);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstutils.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#include \"gstquark.h\"\n@@ -104,0 +103,2 @@\n+static gboolean _priv_gst_value_parse_strv (const gchar * s,\n+    const gchar ** after, GValue * dest);\n@@ -357,1 +358,1 @@\n-  gchar *s_val;\n+  gchar *s_val = NULL;\n@@ -2817,2 +2818,7 @@\n-    g_value_init (value, GST_TYPE_ARRAY);\n-    ret = _priv_gst_value_parse_array (s, &s, value, type, pspec);\n+    if (type == G_TYPE_STRV) {\n+      g_value_init (value, G_TYPE_STRV);\n+      ret = _priv_gst_value_parse_strv (s, (const gchar **) &s, value);\n+    } else {\n+      g_value_init (value, GST_TYPE_ARRAY);\n+      ret = _priv_gst_value_parse_array (s, &s, value, type, pspec);\n+    }\n@@ -2898,12 +2904,12 @@\n-  s = gst_structure_new_id (GST_QUARK (SEGMENT),\n-      GST_QUARK (FLAGS), GST_TYPE_SEGMENT_FLAGS, seg->flags,\n-      GST_QUARK (RATE), G_TYPE_DOUBLE, seg->rate,\n-      GST_QUARK (APPLIED_RATE), G_TYPE_DOUBLE, seg->applied_rate,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, seg->format,\n-      GST_QUARK (BASE), G_TYPE_UINT64, seg->base,\n-      GST_QUARK (OFFSET), G_TYPE_UINT64, seg->offset,\n-      GST_QUARK (START), G_TYPE_UINT64, seg->start,\n-      GST_QUARK (STOP), G_TYPE_UINT64, seg->stop,\n-      GST_QUARK (TIME), G_TYPE_UINT64, seg->time,\n-      GST_QUARK (POSITION), G_TYPE_UINT64, seg->position,\n-      GST_QUARK (DURATION), G_TYPE_UINT64, seg->duration, NULL);\n+  s = gst_structure_new_static_str (\"segment\",\n+      \"flags\", GST_TYPE_SEGMENT_FLAGS, seg->flags,\n+      \"rate\", G_TYPE_DOUBLE, seg->rate,\n+      \"applied-rate\", G_TYPE_DOUBLE, seg->applied_rate,\n+      \"format\", GST_TYPE_FORMAT, seg->format,\n+      \"base\", G_TYPE_UINT64, seg->base,\n+      \"offset\", G_TYPE_UINT64, seg->offset,\n+      \"start\", G_TYPE_UINT64, seg->start,\n+      \"stop\", G_TYPE_UINT64, seg->stop,\n+      \"time\", G_TYPE_UINT64, seg->time,\n+      \"position\", G_TYPE_UINT64, seg->position,\n+      \"duration\", G_TYPE_UINT64, seg->duration, NULL);\n@@ -2958,12 +2964,12 @@\n-  res = gst_structure_id_get (str,\n-      GST_QUARK (FLAGS), GST_TYPE_SEGMENT_FLAGS, &seg.flags,\n-      GST_QUARK (RATE), G_TYPE_DOUBLE, &seg.rate,\n-      GST_QUARK (APPLIED_RATE), G_TYPE_DOUBLE, &seg.applied_rate,\n-      GST_QUARK (FORMAT), GST_TYPE_FORMAT, &seg.format,\n-      GST_QUARK (BASE), G_TYPE_UINT64, &seg.base,\n-      GST_QUARK (OFFSET), G_TYPE_UINT64, &seg.offset,\n-      GST_QUARK (START), G_TYPE_UINT64, &seg.start,\n-      GST_QUARK (STOP), G_TYPE_UINT64, &seg.stop,\n-      GST_QUARK (TIME), G_TYPE_UINT64, &seg.time,\n-      GST_QUARK (POSITION), G_TYPE_UINT64, &seg.position,\n-      GST_QUARK (DURATION), G_TYPE_UINT64, &seg.duration, NULL);\n+  res = gst_structure_get (str,\n+      \"flags\", GST_TYPE_SEGMENT_FLAGS, &seg.flags,\n+      \"rate\", G_TYPE_DOUBLE, &seg.rate,\n+      \"applied-rate\", G_TYPE_DOUBLE, &seg.applied_rate,\n+      \"format\", GST_TYPE_FORMAT, &seg.format,\n+      \"base\", G_TYPE_UINT64, &seg.base,\n+      \"offset\", G_TYPE_UINT64, &seg.offset,\n+      \"start\", G_TYPE_UINT64, &seg.start,\n+      \"stop\", G_TYPE_UINT64, &seg.stop,\n+      \"time\", G_TYPE_UINT64, &seg.time,\n+      \"position\", G_TYPE_UINT64, &seg.position,\n+      \"duration\", G_TYPE_UINT64, &seg.duration, NULL);\n@@ -4542,0 +4548,3 @@\n+  } else if (type2 == GST_TYPE_CAPS) {\n+    return gst_caps_is_subset (gst_value_get_caps (value1),\n+        gst_value_get_caps (value2));\n@@ -4741,1 +4750,2 @@\n-structure_field_union_into (GQuark field_id, GValue * val, gpointer user_data)\n+structure_field_union_into (const GstIdStr * field, GValue * val,\n+    gpointer user_data)\n@@ -4747,1 +4757,1 @@\n-  other_value = gst_structure_id_get_value (other, field_id);\n+  other_value = gst_structure_id_str_get_value (other, field);\n@@ -4762,1 +4772,1 @@\n-structure_field_union_from (GQuark field_id, const GValue * other_val,\n+structure_field_union_from (const GstIdStr * field, const GValue * other_val,\n@@ -4768,1 +4778,1 @@\n-  result_value = gst_structure_id_get_value (result, field_id);\n+  result_value = gst_structure_id_str_get_value (result, field);\n@@ -4770,1 +4780,1 @@\n-    gst_structure_id_set_value (result, field_id, other_val);\n+    gst_structure_id_str_set_value (result, field, other_val);\n@@ -4797,1 +4807,1 @@\n-      gst_structure_map_in_place (result, structure_field_union_into,\n+      gst_structure_map_in_place_id_str (result, structure_field_union_into,\n@@ -4802,1 +4812,2 @@\n-      gst_structure_foreach (s2, structure_field_union_from, (gpointer) result);\n+      gst_structure_foreach_id_str (s2, structure_field_union_from,\n+      (gpointer) result);\n@@ -6358,0 +6369,22 @@\n+static gboolean\n+gst_value_intersect_caps (GValue * dest, const GValue * value1, const GValue *\n+    value2)\n+{\n+  gboolean empty;\n+  GstCaps *icaps;\n+  GstCaps *caps1 = g_value_get_boxed (value1);\n+  GstCaps *caps2 = g_value_get_boxed (value2);\n+  g_return_val_if_fail (caps1 != NULL, FALSE);\n+  g_return_val_if_fail (caps2 != NULL, FALSE);\n+\n+  icaps = gst_caps_intersect (caps1, caps2);\n+  empty = gst_caps_is_empty (icaps);\n+\n+  if (dest != NULL) {\n+    g_value_init (dest, GST_TYPE_CAPS);\n+    gst_value_set_caps (dest, icaps);\n+  }\n+  gst_caps_unref (icaps);\n+  return !empty;\n+}\n+\n@@ -6418,0 +6451,2 @@\n+    if (type1 == GST_TYPE_CAPS)\n+      return gst_value_intersect_caps (dest, value1, value2);\n@@ -6832,1 +6867,1 @@\n-structure_field_is_fixed (GQuark field_id, const GValue * val,\n+structure_field_is_fixed (const GstIdStr * field, const GValue * val,\n@@ -6880,1 +6915,1 @@\n-    return gst_structure_foreach (gst_value_get_structure (value),\n+    return gst_structure_foreach_id_str (gst_value_get_structure (value),\n@@ -7500,0 +7535,1 @@\n+  GstDateTime *gst_datetime;\n@@ -7507,2 +7543,7 @@\n-  datetime =\n-      gst_date_time_to_g_date_time (gst_date_time_new_from_iso8601_string (s));\n+  gst_datetime = gst_date_time_new_from_iso8601_string (s);\n+  if (gst_datetime == NULL) {\n+    GST_WARNING (\"Failed to deserialize date time string '%s'\", s);\n+    return FALSE;\n+  }\n+  datetime = gst_date_time_to_g_date_time (gst_datetime);\n+  gst_date_time_unref (gst_datetime);\n@@ -7558,1 +7599,1 @@\n-    g_value_set_boxed (dest, g_bytes_new (NULL, 0));\n+    g_value_take_boxed (dest, g_bytes_new (NULL, 0));\n@@ -7563,1 +7604,1 @@\n-  g_value_set_boxed (dest, g_bytes_new_take (data, len));\n+  g_value_take_boxed (dest, g_bytes_new_take (data, len));\n@@ -8060,0 +8101,24 @@\n+static void\n+gst_value_transform_allocation_params_string (const GValue * value1,\n+    GValue * dest_value)\n+{\n+  GstAllocationParams *params = value1->data[0].v_pointer;\n+  gchar *res;\n+\n+  if (params) {\n+    GstStructure *s = NULL;\n+\n+    s = gst_structure_new_static_str (\"GstAllocationParams\",\n+        \"flags\", GST_TYPE_MEMORY_FLAGS, params->flags,\n+        \"align\", G_TYPE_UINT64, params->align,\n+        \"prefix\", G_TYPE_UINT64, params->prefix,\n+        \"padding\", G_TYPE_UINT64, params->padding, NULL);\n+\n+    res = gst_structure_to_string (s);\n+    gst_structure_free (s);\n+  } else {\n+    res = g_strdup (\"NULL\");\n+  }\n+\n+  dest_value->data[0].v_pointer = res;\n+}\n@@ -8098,0 +8163,121 @@\n+\/*********\n+ * GStrv *\n+ *********\/\n+\n+static gchar *\n+gst_value_serialize_strv (const GValue * value)\n+{\n+  const gchar **strv = g_value_get_boxed (value);\n+  GString *str = g_string_new (\"<\");\n+\n+  while (*strv != NULL) {\n+    const gchar *s = *strv;\n+\n+    \/* Add separator if it's not the first string *\/\n+    if (str->len > 1)\n+      g_string_append_c (str, ',');\n+\n+    g_string_append_c (str, '\\\"');\n+\n+    \/* Escape \\ to \\\\ and \" to \\\" *\/\n+    while (*s != '\\0') {\n+      if (*s == '\\\"' || *s == '\\\\')\n+        g_string_append_c (str, '\\\\');\n+      g_string_append_c (str, *s);\n+      s++;\n+    }\n+\n+    g_string_append_c (str, '\\\"');\n+\n+    strv++;\n+  }\n+\n+  g_string_append_c (str, '>');\n+\n+  return g_string_free (str, FALSE);\n+}\n+\n+static gboolean\n+_priv_gst_value_parse_strv (const gchar * s, const gchar ** after,\n+    GValue * dest)\n+{\n+  \/* Parse the format <\"foo\",\"bar\"> with spaces allowed between delimiters,\n+   * and \\ for escaping. *\/\n+  if (*s != '<')\n+    return FALSE;\n+  s++;\n+\n+  while (g_ascii_isspace (*s))\n+    s++;\n+\n+  GPtrArray *strv = g_ptr_array_new_with_free_func (g_free);\n+  while (*s != '>') {\n+    if (*s != '\\\"')\n+      goto error;\n+    s++;\n+\n+    \/* Find string end and check if we need to unescape it *\/\n+    gboolean escaped = FALSE;\n+    const gchar *start = s;\n+    while (*s != '\\\"') {\n+      if (*s == '\\\\') {\n+        escaped = TRUE;\n+        s++;\n+      }\n+      if (*s == '\\0')\n+        goto error;\n+      s++;\n+    }\n+    s++;\n+\n+    \/* Always copy the whole string and unescape inplace *\/\n+    gchar *substr = g_strndup (start, s - start - 1);\n+    if (escaped) {\n+      gchar *p1 = substr;\n+      const gchar *p2 = substr;\n+      while (*p2 != '\\0') {\n+        if (*p2 == '\\\\')\n+          p2++;\n+        *p1 = *p2;\n+        p1++;\n+        p2++;\n+      }\n+      *p1 = '\\0';\n+    }\n+\n+    g_ptr_array_add (strv, substr);\n+\n+    while (g_ascii_isspace (*s))\n+      s++;\n+\n+    if (*s == ',') {\n+      s++;\n+      while (g_ascii_isspace (*s))\n+        s++;\n+    }\n+  }\n+\n+  g_ptr_array_add (strv, NULL);\n+  g_value_take_boxed (dest, g_ptr_array_free (strv, FALSE));\n+\n+  *after = s + 1;\n+\n+  return TRUE;\n+\n+error:\n+  g_ptr_array_free (strv, TRUE);\n+  return FALSE;\n+}\n+\n+static gboolean\n+gst_value_deserialize_strv (GValue * dest, const gchar * s)\n+{\n+  \/* If it's not starting with '<' assume it's a simple comma separated list\n+   * with no escaping. This makes usage in gst-launch-1.0 easier. *\/\n+  if (*s != '<') {\n+    g_value_take_boxed (dest, g_strsplit (s, \",\", -1));\n+    return TRUE;\n+  }\n+  return _priv_gst_value_parse_strv (s, &s, dest);\n+}\n+\n@@ -8332,0 +8518,1 @@\n+  REGISTER_SERIALIZATION (G_TYPE_GTYPE, gtype);\n@@ -8336,0 +8523,1 @@\n+  REGISTER_SERIALIZATION_NO_COMPARE (G_TYPE_STRV, strv);\n@@ -8343,1 +8531,0 @@\n-\n@@ -8347,1 +8534,0 @@\n-\n@@ -8349,1 +8535,0 @@\n-\n@@ -8351,1 +8536,0 @@\n-\n@@ -8354,1 +8538,0 @@\n-\n@@ -8358,1 +8541,0 @@\n-\n@@ -8361,2 +8543,0 @@\n-  REGISTER_SERIALIZATION (G_TYPE_GTYPE, gtype);\n-\n@@ -8420,0 +8600,2 @@\n+  g_value_register_transform_func (GST_TYPE_ALLOCATION_PARAMS, G_TYPE_STRING,\n+      gst_value_transform_allocation_params_string);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstvalue.c","additions":231,"deletions":49,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -0,0 +1,996 @@\n+\/* GStreamer\n+ * Copyright (C) 2009 Edward Hervey <bilboed@bilboed.com>\n+ * Copyright (C) 2015 Tim-Philipp Müller <tim@centricular.com>\n+ *\n+ * gstvecdeque.c:\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Library General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public\n+ * License along with this library; if not, write to the\n+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ *\/\n+\n+\/**\n+ * SECTION:gstvecdeque\n+ * @title: GstVecDeque\n+ * @short_description: Array based double-ended queue object\n+ *\n+ * #GstVecDeque is an object that provides standard double-ended queue (deque)\n+ * functionality based on an array instead of linked lists. This reduces the\n+ * overhead caused by memory management by a large factor.\n+ *\/\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+#include <string.h>\n+#include <gst\/gst.h>\n+#include \"gstvecdeque.h\"\n+\n+#include \"glib-compat-private.h\"\n+\n+#define gst_vec_deque_idx(a, i) \\\n+  ((a)->array + (((a)->head + (i)) % (a)->size) * (a)->elt_size)\n+\n+struct _GstVecDeque\n+{\n+  \/* < private > *\/\n+  guint8 *array;\n+  gsize size;\n+  gsize head;\n+  gsize tail;\n+  gsize length;\n+  gsize elt_size;\n+  gboolean struct_array;\n+  GDestroyNotify clear_func;\n+};\n+\n+typedef struct\n+{\n+  GCompareDataFunc func;\n+  gpointer user_data;\n+} QueueSortData;\n+\n+\/**\n+ * gst_vec_deque_new_for_struct: (skip)\n+ * @struct_size: Size of each element (e.g. structure) in the array\n+ * @initial_size: Initial size of the new queue\n+ *\n+ * Allocates a new #GstVecDeque object for elements (e.g. structures)\n+ * of size @struct_size, with an initial queue size of @initial_size.\n+ *\n+ * Returns: a new #GstVecDeque object\n+ *\n+ * Since: 1.26\n+ *\/\n+GstVecDeque *\n+gst_vec_deque_new_for_struct (gsize struct_size, gsize initial_size)\n+{\n+  GstVecDeque *array;\n+\n+  g_return_val_if_fail (struct_size > 0, NULL);\n+\n+  array = g_new (GstVecDeque, 1);\n+  array->elt_size = struct_size;\n+  array->size = initial_size;\n+  array->array = g_malloc0_n (initial_size, struct_size);\n+  array->head = 0;\n+  array->tail = 0;\n+  array->length = 0;\n+  array->struct_array = TRUE;\n+  array->clear_func = NULL;\n+  return array;\n+}\n+\n+\/**\n+ * gst_vec_deque_new: (skip)\n+ * @initial_size: Initial size of the new queue\n+ *\n+ * Allocates a new #GstVecDeque object with an initial\n+ * queue size of @initial_size.\n+ *\n+ * Returns: a new #GstVecDeque object\n+ *\n+ * Since: 1.26\n+ *\/\n+GstVecDeque *\n+gst_vec_deque_new (gsize initial_size)\n+{\n+  GstVecDeque *array;\n+\n+  array = gst_vec_deque_new_for_struct (sizeof (gpointer), initial_size);\n+  array->struct_array = FALSE;\n+  return array;\n+}\n+\n+\/**\n+ * gst_vec_deque_free: (skip)\n+ * @array: a #GstVecDeque object\n+ *\n+ * Frees queue @array and all memory associated to it.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_vec_deque_free (GstVecDeque * array)\n+{\n+  g_return_if_fail (array != NULL);\n+  gst_vec_deque_clear (array);\n+  g_free (array->array);\n+  g_free (array);\n+}\n+\n+\/**\n+ * gst_vec_deque_set_clear_func: (skip)\n+ * @array: a #GstVecDeque object\n+ * @clear_func: a function to clear an element of @array\n+ *\n+ * Sets a function to clear an element of @array.\n+ *\n+ * The @clear_func will be called when an element in the array\n+ * data segment is removed and when the array is freed and data\n+ * segment is deallocated as well. @clear_func will be passed a\n+ * pointer to the element to clear, rather than the element itself.\n+ *\n+ * Note that in contrast with other uses of #GDestroyNotify\n+ * functions, @clear_func is expected to clear the contents of\n+ * the array element it is given, but not free the element itself.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_vec_deque_set_clear_func (GstVecDeque * array, GDestroyNotify clear_func)\n+{\n+  g_return_if_fail (array != NULL);\n+  array->clear_func = clear_func;\n+}\n+\n+static void\n+gst_vec_deque_clear_idx (GstVecDeque * array, gsize idx)\n+{\n+  gsize pos;\n+\n+  if (!array->clear_func)\n+    return;\n+\n+  pos = (idx + array->head) % array->size;\n+  if (array->struct_array)\n+    array->clear_func (array->array + pos * array->elt_size);\n+  else\n+    array->clear_func (*(gpointer *) (array->array + pos * array->elt_size));\n+}\n+\n+\/**\n+ * gst_vec_deque_clear: (skip)\n+ * @array: a #GstVecDeque object\n+ *\n+ * Clears queue @array and frees all memory associated to it.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_vec_deque_clear (GstVecDeque * array)\n+{\n+  g_return_if_fail (array != NULL);\n+\n+  if (array->clear_func != NULL) {\n+    gsize i;\n+\n+    for (i = 0; i < array->length; i++) {\n+      gst_vec_deque_clear_idx (array, i);\n+    }\n+  }\n+\n+  array->head = 0;\n+  array->tail = 0;\n+  array->length = 0;\n+}\n+\n+\/**\n+ * gst_vec_deque_pop_head_struct: (skip)\n+ * @array: a #GstVecDeque object\n+ *\n+ * Returns the head of the queue @array and removes it from the queue.\n+ *\n+ * Returns: (nullable): pointer to element or struct, or NULL if @array was empty. The\n+ *    data pointed to by the returned pointer stays valid only as long as\n+ *    the queue array is not modified further!\n+ *\n+ * Since: 1.26\n+ *\/\n+gpointer\n+gst_vec_deque_pop_head_struct (GstVecDeque * array)\n+{\n+  gpointer p_struct;\n+  g_return_val_if_fail (array != NULL, NULL);\n+  \/* empty array *\/\n+  if (G_UNLIKELY (array->length == 0))\n+    return NULL;\n+\n+  p_struct = array->array + (array->elt_size * array->head);\n+\n+  array->head++;\n+  array->head %= array->size;\n+  array->length--;\n+\n+  return p_struct;\n+}\n+\n+\/**\n+ * gst_vec_deque_pop_head: (skip)\n+ * @array: a #GstVecDeque object\n+ *\n+ * Returns and head of the queue @array and removes\n+ * it from the queue.\n+ *\n+ * Returns: The head of the queue\n+ *\n+ * Since: 1.26\n+ *\/\n+gpointer\n+gst_vec_deque_pop_head (GstVecDeque * array)\n+{\n+  gpointer ret;\n+  g_return_val_if_fail (array != NULL, NULL);\n+\n+  \/* empty array *\/\n+  if (G_UNLIKELY (array->length == 0))\n+    return NULL;\n+\n+  ret = *(gpointer *) (array->array + (sizeof (gpointer) * array->head));\n+  array->head++;\n+  array->head %= array->size;\n+  array->length--;\n+  return ret;\n+}\n+\n+\/**\n+ * gst_vec_deque_peek_head_struct: (skip)\n+ * @array: a #GstVecDeque object\n+ *\n+ * Returns the head of the queue @array without removing it from the queue.\n+ *\n+ * Returns: (nullable): pointer to element or struct, or NULL if @array was empty. The\n+ *    data pointed to by the returned pointer stays valid only as long as\n+ *    the queue array is not modified further!\n+ *\n+ * Since: 1.26\n+ *\/\n+gpointer\n+gst_vec_deque_peek_head_struct (GstVecDeque * array)\n+{\n+  g_return_val_if_fail (array != NULL, NULL);\n+  \/* empty array *\/\n+  if (G_UNLIKELY (array->length == 0))\n+    return NULL;\n+\n+  return array->array + (array->elt_size * array->head);\n+}\n+\n+\/**\n+ * gst_vec_deque_peek_head: (skip)\n+ * @array: a #GstVecDeque object\n+ *\n+ * Returns the head of the queue @array and does not\n+ * remove it from the queue.\n+ *\n+ * Returns: The head of the queue\n+ *\n+ * Since: 1.26\n+ *\/\n+gpointer\n+gst_vec_deque_peek_head (GstVecDeque * array)\n+{\n+  g_return_val_if_fail (array != NULL, NULL);\n+  \/* empty array *\/\n+  if (G_UNLIKELY (array->length == 0))\n+    return NULL;\n+\n+  return *(gpointer *) (array->array + (sizeof (gpointer) * array->head));\n+}\n+\n+\/**\n+ * gst_vec_deque_peek_nth: (skip)\n+ *\n+ * Returns the item at @idx in @array, but does not remove it from the queue.\n+ *\n+ * Returns: (nullable): The item, or %NULL if @idx was out of bounds\n+ *\n+ * Since: 1.26\n+ *\/\n+gpointer\n+gst_vec_deque_peek_nth (GstVecDeque * array, gsize idx)\n+{\n+  g_return_val_if_fail (array != NULL, NULL);\n+  g_return_val_if_fail (idx < array->length, NULL);\n+\n+  idx = (array->head + idx) % array->size;\n+\n+  return *(gpointer *) (array->array + (sizeof (gpointer) * idx));\n+}\n+\n+\/**\n+ * gst_vec_deque_peek_nth_struct: (skip)\n+ *\n+ * Returns the item at @idx in @array, but does not remove it from the queue.\n+ *\n+ * Returns: (nullable): The item, or %NULL if @idx was out of bounds\n+ *\n+ * Since: 1.26\n+ *\/\n+gpointer\n+gst_vec_deque_peek_nth_struct (GstVecDeque * array, gsize idx)\n+{\n+  g_return_val_if_fail (array != NULL, NULL);\n+  g_return_val_if_fail (idx < array->length, NULL);\n+\n+  idx = (array->head + idx) % array->size;\n+\n+  return array->array + (array->elt_size * idx);\n+}\n+\n+static void\n+gst_vec_deque_do_expand (GstVecDeque * array)\n+{\n+  gsize elt_size = array->elt_size;\n+  \/* newsize is 50% bigger *\/\n+  gsize oldsize = array->size;\n+  gsize newsize;\n+\n+  if (!g_size_checked_mul (&newsize, oldsize, 2))\n+    g_error (\"growing the queue array would overflow\");\n+  newsize = MAX (newsize, 16);\n+\n+  \/* copy over data *\/\n+  if (array->tail != 0) {\n+    guint8 *array2 = NULL;\n+    gsize t1 = 0;\n+    gsize t2 = 0;\n+\n+    array2 = g_malloc0_n (newsize, elt_size);\n+    t1 = array->head;\n+    t2 = oldsize - array->head;\n+\n+    \/* [0-----TAIL][HEAD------SIZE]\n+     *\n+     * We want to end up with\n+     * [HEAD------------------TAIL][----FREEDATA------NEWSIZE]\n+     *\n+     * 1) move [HEAD-----SIZE] part to beginning of new array\n+     * 2) move [0-------TAIL] part new array, after previous part\n+     *\/\n+\n+    memcpy (array2, array->array + (elt_size * (gsize) array->head),\n+        t2 * elt_size);\n+    memcpy (array2 + t2 * elt_size, array->array, t1 * elt_size);\n+\n+    g_free (array->array);\n+    array->array = array2;\n+    array->head = 0;\n+  } else {\n+    \/* Fast path, we just need to grow the array *\/\n+    array->array = g_realloc_n (array->array, newsize, elt_size);\n+    memset (array->array + elt_size * oldsize, 0,\n+        elt_size * (newsize - oldsize));\n+  }\n+  array->tail = oldsize;\n+  array->size = newsize;\n+}\n+\n+\/**\n+ * gst_vec_deque_push_tail_struct: (skip)\n+ * @array: a #GstVecDeque object\n+ * @p_struct: address of element or structure to push to the tail of the queue\n+ *\n+ * Pushes the element at address @p_struct to the tail of the queue @array\n+ * (Copies the contents of a structure of the struct_size specified when\n+ * creating the queue into the array).\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_vec_deque_push_tail_struct (GstVecDeque * array, gpointer p_struct)\n+{\n+  gsize elt_size;\n+\n+  g_return_if_fail (p_struct != NULL);\n+  g_return_if_fail (array != NULL);\n+  elt_size = array->elt_size;\n+\n+  \/* Check if we need to make room *\/\n+  if (G_UNLIKELY (array->length == array->size))\n+    gst_vec_deque_do_expand (array);\n+\n+  memcpy (array->array + elt_size * array->tail, p_struct, elt_size);\n+  array->tail++;\n+  array->tail %= array->size;\n+  array->length++;\n+}\n+\n+\/**\n+ * gst_vec_deque_push_tail: (skip)\n+ * @array: a #GstVecDeque object\n+ * @data: object to push\n+ *\n+ * Pushes @data to the tail of the queue @array.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_vec_deque_push_tail (GstVecDeque * array, gpointer data)\n+{\n+  g_return_if_fail (array != NULL);\n+\n+  \/* Check if we need to make room *\/\n+  if (G_UNLIKELY (array->length == array->size))\n+    gst_vec_deque_do_expand (array);\n+\n+  *(gpointer *) (array->array + sizeof (gpointer) * array->tail) = data;\n+  array->tail++;\n+  array->tail %= array->size;\n+  array->length++;\n+}\n+\n+\/* Moves all elements in the queue placed after the given position in the internal array *\/\n+static void\n+gst_vec_deque_move_data_after_position (GstVecDeque * array, gsize pos)\n+{\n+  gsize elt_size = array->elt_size;\n+\n+  \/* If the array does not wrap around OR if it does, but we're inserting past that point *\/\n+  if (array->head < array->tail ||\n+      (array->head >= array->tail && pos < array->head)) {\n+    memmove (array->array + (pos + 1) * elt_size, array->array + pos * elt_size,\n+        (array->tail - pos) * elt_size);\n+    return;\n+  }\n+\n+  \/* Otherwise, array wraps around and we're inserting before the breaking point.\n+   * First, move everything past that point by one place. *\/\n+  memmove (array->array + elt_size, array->array, array->tail * elt_size);\n+\n+  \/* Then move the last element from before the wrap-around point to right after it. *\/\n+  memcpy (array->array, array->array + (array->size - 1) * elt_size, elt_size);\n+\n+  \/* If we're inserting right before the breaking point, no further action is needed.\n+   * Otherwise, move data between insertion point and the breaking point by one place. *\/\n+  if (pos != array->size - 1) {\n+    memmove (array->array + (pos + 1) * elt_size, array->array + pos * elt_size,\n+        (array->size - pos - 1) * elt_size);\n+  }\n+}\n+\n+\/**\n+ * gst_vec_deque_push_sorted: (skip)\n+ * @array: a #GstVecDeque object\n+ * @data: object to push\n+ * @func: comparison function\n+ * @user_data: (nullable): data for comparison function\n+ *\n+ * Pushes @data to the queue @array, finding the correct position\n+ * by comparing @data with each array element using @func.\n+ *\n+ * This has a time complexity of O(n), so depending on the size of the queue\n+ * and expected access patterns, a different data structure might be better.\n+ *\n+ * Assumes that the array is already sorted. If it is not, make sure\n+ * to call gst_vec_deque_sort() first.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_vec_deque_push_sorted (GstVecDeque * array, gpointer data,\n+    GCompareDataFunc func, gpointer user_data)\n+{\n+  gsize i;\n+  gpointer *p_element;\n+\n+  g_return_if_fail (array != NULL);\n+  g_return_if_fail (func != NULL);\n+\n+  \/* Check if we need to make room *\/\n+  if (G_UNLIKELY (array->length == array->size))\n+    gst_vec_deque_do_expand (array);\n+\n+  \/* Compare against each element, assuming they're already sorted *\/\n+  for (i = 0; i < array->length; i++) {\n+    p_element = (gpointer *) gst_vec_deque_idx (array, i);\n+\n+    if (func (*p_element, data, user_data) > 0) {\n+      gsize pos = (array->head + i) % array->size;\n+      gst_vec_deque_move_data_after_position (array, pos);\n+\n+      *p_element = data;\n+      goto finish;\n+    }\n+  }\n+\n+  \/* No 'bigger' element found - append to tail *\/\n+  *(gpointer *) (array->array + array->elt_size * array->tail) = data;\n+\n+finish:\n+  array->tail++;\n+  array->tail %= array->size;\n+  array->length++;\n+}\n+\n+\/**\n+ * gst_vec_deque_push_sorted_struct: (skip)\n+ * @array: a #GstVecDeque object\n+ * @p_struct: address of element or structure to push into the queue\n+ * @func: comparison function\n+ * @user_data: (nullable): data for comparison function\n+ *\n+ * Pushes the element at address @p_struct into the queue @array\n+ * (copying the contents of a structure of the struct_size specified\n+ * when creating the queue into the array), finding the correct position\n+ * by comparing the element at @p_struct with each element in the array using @func.\n+ *\n+ * This has a time complexity of O(n), so depending on the size of the queue\n+ * and expected access patterns, a different data structure might be better.\n+ *\n+ * Assumes that the array is already sorted. If it is not, make sure\n+ * to call gst_vec_deque_sort() first.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_vec_deque_push_sorted_struct (GstVecDeque * array, gpointer p_struct,\n+    GCompareDataFunc func, gpointer user_data)\n+{\n+  gsize i;\n+  gpointer p_element;\n+\n+  g_return_if_fail (array != NULL);\n+  g_return_if_fail (p_struct != NULL);\n+  g_return_if_fail (func != NULL);\n+\n+  \/* Check if we need to make room *\/\n+  if (G_UNLIKELY (array->length == array->size))\n+    gst_vec_deque_do_expand (array);\n+\n+  \/* Compare against each element, assuming they're already sorted *\/\n+  for (i = 0; i < array->length; i++) {\n+    p_element = gst_vec_deque_idx (array, i);\n+\n+    if (func (p_element, p_struct, user_data) > 0) {\n+      gsize pos = (array->head + i) % array->size;\n+      gst_vec_deque_move_data_after_position (array, pos);\n+\n+      memcpy (p_element, p_struct, array->elt_size);\n+      goto finish;\n+    }\n+  }\n+\n+  \/* No 'bigger' element found - append to tail *\/\n+  memcpy (array->array + array->elt_size * array->tail, p_struct,\n+      array->elt_size);\n+\n+finish:\n+  array->tail++;\n+  array->tail %= array->size;\n+  array->length++;\n+}\n+\n+static int\n+compare_wrapper (gpointer * a, gpointer * b, QueueSortData * sort_data)\n+{\n+  return sort_data->func (*a, *b, sort_data->user_data);\n+}\n+\n+\/**\n+ * gst_vec_deque_sort: (skip)\n+ * @array: a #GstVecDeque object\n+ * @compare_func: comparison function\n+ * @user_data: (nullable): data for comparison function\n+ *\n+ * Sorts the queue @array by comparing elements against each other using\n+ * the provided @compare_func.\n+ *\n+ * Since: 1.26\n+ *\/\n+void\n+gst_vec_deque_sort (GstVecDeque * array, GCompareDataFunc compare_func,\n+    gpointer user_data)\n+{\n+  g_return_if_fail (array != NULL);\n+  g_return_if_fail (compare_func != NULL);\n+\n+  if (array->length == 0)\n+    return;\n+\n+  \/* To be able to use g_sort_array, we might need to rearrange:\n+   * [0-----TAIL][HEAD-----SIZE] -> [HEAD-------TAIL] *\/\n+  if (array->head >= array->tail) {\n+    gsize t1 = array->head;\n+    gsize t2 = array->size - array->head;\n+    gsize elt_size = array->elt_size;\n+\n+    \/* Copy [0-------TAIL] part to a temporary buffer *\/\n+    guint8 *tmp = g_malloc0_n (t1, elt_size);\n+    memcpy (tmp, array->array, t1 * elt_size);\n+\n+    \/* Move [HEAD-----SIZE] part to the beginning of the original array *\/\n+    memmove (array->array, array->array + (elt_size * array->head),\n+        t2 * elt_size);\n+\n+    \/* Copy the temporary buffer to the end of the original array *\/\n+    memmove (array->array + (t2 * elt_size), tmp, t1 * elt_size);\n+    g_free (tmp);\n+\n+    array->head = 0;\n+    array->tail = array->length % array->size;\n+  }\n+\n+  if (array->struct_array) {\n+    g_sort_array (array->array +\n+        (array->head % array->size) * array->elt_size, array->length,\n+        array->elt_size, compare_func, user_data);\n+  } else {\n+    \/* For non-struct arrays, we need to wrap the provided compare function\n+     * to dereference our pointers before passing them for comparison.\n+     * This matches the behaviour of gst_vec_deque_find(). *\/\n+    QueueSortData sort_data = { compare_func, user_data };\n+    g_sort_array (array->array +\n+        (array->head % array->size) * array->elt_size, array->length,\n+        array->elt_size, (GCompareDataFunc) compare_wrapper, &sort_data);\n+  }\n+}\n+\n+\/**\n+ * gst_vec_deque_peek_tail: (skip)\n+ * @array: a #GstVecDeque object\n+ *\n+ * Returns the tail of the queue @array, but does not remove it from the queue.\n+ *\n+ * Returns: The tail of the queue\n+ *\n+ * Since: 1.26\n+ *\/\n+gpointer\n+gst_vec_deque_peek_tail (GstVecDeque * array)\n+{\n+  gsize len, idx;\n+\n+  g_return_val_if_fail (array != NULL, NULL);\n+\n+  len = array->length;\n+\n+  \/* empty array *\/\n+  if (len == 0)\n+    return NULL;\n+\n+  idx = (array->head + (len - 1)) % array->size;\n+\n+  return *(gpointer *) (array->array + (sizeof (gpointer) * idx));\n+}\n+\n+\/**\n+ * gst_vec_deque_peek_tail_struct: (skip)\n+ * @array: a #GstVecDeque object\n+ *\n+ * Returns the tail of the queue @array, but does not remove it from the queue.\n+ *\n+ * Returns: The tail of the queue\n+ *\n+ * Since: 1.26\n+ *\/\n+gpointer\n+gst_vec_deque_peek_tail_struct (GstVecDeque * array)\n+{\n+  gsize len, idx;\n+\n+  g_return_val_if_fail (array != NULL, NULL);\n+\n+  len = array->length;\n+\n+  \/* empty array *\/\n+  if (len == 0)\n+    return NULL;\n+\n+  idx = (array->head + (len - 1)) % array->size;\n+\n+  return array->array + (array->elt_size * idx);\n+}\n+\n+\/**\n+ * gst_vec_deque_pop_tail: (skip)\n+ * @array: a #GstVecDeque object\n+ *\n+ * Returns the tail of the queue @array and removes\n+ * it from the queue.\n+ *\n+ * Returns: The tail of the queue\n+ *\n+ * Since: 1.26\n+ *\/\n+gpointer\n+gst_vec_deque_pop_tail (GstVecDeque * array)\n+{\n+  gpointer ret;\n+  gsize len, idx;\n+\n+  g_return_val_if_fail (array != NULL, NULL);\n+\n+  len = array->length;\n+\n+  \/* empty array *\/\n+  if (len == 0)\n+    return NULL;\n+\n+  idx = (array->head + (len - 1)) % array->size;\n+\n+  ret = *(gpointer *) (array->array + (sizeof (gpointer) * idx));\n+\n+  array->tail = idx;\n+  array->length--;\n+\n+  return ret;\n+}\n+\n+\/**\n+ * gst_vec_deque_pop_tail_struct: (skip)\n+ * @array: a #GstVecDeque object\n+ *\n+ * Returns the tail of the queue @array and removes\n+ * it from the queue.\n+ *\n+ * Returns: The tail of the queue\n+ *\n+ * Since: 1.26\n+ *\/\n+gpointer\n+gst_vec_deque_pop_tail_struct (GstVecDeque * array)\n+{\n+  gpointer ret;\n+  gsize len, idx;\n+\n+  g_return_val_if_fail (array != NULL, NULL);\n+\n+  len = array->length;\n+\n+  \/* empty array *\/\n+  if (len == 0)\n+    return NULL;\n+\n+  idx = (array->head + (len - 1)) % array->size;\n+\n+  ret = array->array + (array->elt_size * idx);\n+\n+  array->tail = idx;\n+  array->length--;\n+\n+  return ret;\n+}\n+\n+\/**\n+ * gst_vec_deque_is_empty: (skip)\n+ * @array: a #GstVecDeque object\n+ *\n+ * Checks if the queue @array is empty.\n+ *\n+ * Returns: %TRUE if the queue @array is empty\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_vec_deque_is_empty (GstVecDeque * array)\n+{\n+  g_return_val_if_fail (array != NULL, FALSE);\n+  return (array->length == 0);\n+}\n+\n+\n+\/**\n+ * gst_vec_deque_drop_struct: (skip)\n+ * @array: a #GstVecDeque object\n+ * @idx: index to drop\n+ * @p_struct: address into which to store the data of the dropped structure, or NULL\n+ *\n+ * Drops the queue element at position @idx from queue @array and copies the\n+ * data of the element or structure that was removed into @p_struct if\n+ * @p_struct is set (not NULL).\n+ *\n+ * Returns: TRUE on success, or FALSE on error\n+ *\n+ * Since: 1.26\n+ *\/\n+gboolean\n+gst_vec_deque_drop_struct (GstVecDeque * array, gsize idx, gpointer p_struct)\n+{\n+  gsize first_item_index, last_item_index;\n+  gsize actual_idx;\n+  gsize elt_size;\n+\n+  g_return_val_if_fail (array != NULL, FALSE);\n+  actual_idx = (array->head + idx) % array->size;\n+\n+  g_return_val_if_fail (array->length > 0, FALSE);\n+  g_return_val_if_fail (actual_idx < array->size, FALSE);\n+\n+  elt_size = array->elt_size;\n+\n+  first_item_index = array->head;\n+\n+  \/* tail points to the first free spot *\/\n+  last_item_index = (array->tail - 1 + array->size) % array->size;\n+\n+  if (p_struct != NULL)\n+    memcpy (p_struct, array->array + elt_size * actual_idx, elt_size);\n+\n+  \/* simple case actual_idx == first item *\/\n+  if (actual_idx == first_item_index) {\n+    \/* clear current head position if needed *\/\n+    if (p_struct == NULL)\n+      gst_vec_deque_clear_idx (array, idx);\n+\n+    \/* move the head plus one *\/\n+    array->head++;\n+    array->head %= array->size;\n+    array->length--;\n+    return TRUE;\n+  }\n+\n+  \/* simple case idx == last item *\/\n+  if (actual_idx == last_item_index) {\n+    \/* clear current tail position if needed *\/\n+    if (p_struct == NULL)\n+      gst_vec_deque_clear_idx (array, idx);\n+\n+    \/* move tail minus one, potentially wrapping *\/\n+    array->tail = (array->tail - 1 + array->size) % array->size;\n+    array->length--;\n+    return TRUE;\n+  }\n+\n+  \/* non-wrapped case *\/\n+  if (first_item_index < last_item_index) {\n+    \/* clear idx if needed *\/\n+    if (p_struct == NULL)\n+      gst_vec_deque_clear_idx (array, idx);\n+\n+    g_assert (first_item_index < actual_idx && actual_idx < last_item_index);\n+    \/* move everything beyond actual_idx one step towards zero in array *\/\n+    memmove (array->array + elt_size * actual_idx,\n+        array->array + elt_size * (actual_idx + 1),\n+        (last_item_index - actual_idx) * elt_size);\n+    \/* tail might wrap, ie if tail == 0 (and last_item_index == size) *\/\n+    array->tail = (array->tail - 1 + array->size) % array->size;\n+    array->length--;\n+    return TRUE;\n+  }\n+\n+  \/* only wrapped cases left *\/\n+  g_assert (first_item_index > last_item_index);\n+\n+  if (actual_idx < last_item_index) {\n+    \/* clear idx if needed *\/\n+    if (p_struct == NULL)\n+      gst_vec_deque_clear_idx (array, idx);\n+\n+    \/* actual_idx is before last_item_index, move data towards zero *\/\n+    memmove (array->array + elt_size * actual_idx,\n+        array->array + elt_size * (actual_idx + 1),\n+        (last_item_index - actual_idx) * elt_size);\n+    \/* tail should not wrap in this case! *\/\n+    g_assert (array->tail > 0);\n+    array->tail--;\n+    array->length--;\n+    return TRUE;\n+  }\n+\n+  if (actual_idx > first_item_index) {\n+    \/* clear idx if needed *\/\n+    if (p_struct == NULL)\n+      gst_vec_deque_clear_idx (array, idx);\n+\n+    \/* actual_idx is after first_item_index, move data to higher indices *\/\n+    memmove (array->array + elt_size * (first_item_index + 1),\n+        array->array + elt_size * first_item_index,\n+        (actual_idx - first_item_index) * elt_size);\n+    array->head++;\n+    \/* head should not wrap in this case! *\/\n+    g_assert (array->head < array->size);\n+    array->length--;\n+    return TRUE;\n+  }\n+\n+  g_return_val_if_reached (FALSE);\n+}\n+\n+\/**\n+ * gst_vec_deque_drop_element: (skip)\n+ * @array: a #GstVecDeque object\n+ * @idx: index to drop\n+ *\n+ * Drops the queue element at position @idx from queue @array.\n+ *\n+ * Returns: the dropped element\n+ *\n+ * Since: 1.26\n+ *\/\n+gpointer\n+gst_vec_deque_drop_element (GstVecDeque * array, gsize idx)\n+{\n+  gpointer ptr;\n+\n+  if (!gst_vec_deque_drop_struct (array, idx, &ptr))\n+    return NULL;\n+\n+  return ptr;\n+}\n+\n+\/**\n+ * gst_vec_deque_find: (skip)\n+ * @array: a #GstVecDeque object\n+ * @func: (nullable): comparison function, or %NULL to find @data by value\n+ * @data: data for comparison function\n+ *\n+ * Finds an element in the queue @array, either by comparing every element\n+ * with @func or by looking up @data if no compare function @func is provided,\n+ * and returning the index of the found element.\n+ *\n+ * Returns: Index of the found element or -1 if nothing was found.\n+ *\n+ * Since: 1.26\n+ *\/\n+gsize\n+gst_vec_deque_find (GstVecDeque * array, GCompareFunc func, gpointer data)\n+{\n+  gpointer p_element;\n+  gsize elt_size;\n+  gsize i;\n+\n+  \/* For struct arrays we need to implement this differently so that\n+   * the user gets a pointer to the element data not the dereferenced\n+   * pointer itself *\/\n+\n+  g_return_val_if_fail (array != NULL, -1);\n+  g_return_val_if_fail (array->struct_array == FALSE, -1);\n+\n+  elt_size = array->elt_size;\n+\n+  if (func != NULL) {\n+    \/* Scan from head to tail *\/\n+    for (i = 0; i < array->length; i++) {\n+      p_element = array->array + ((i + array->head) % array->size) * elt_size;\n+      if (func (*(gpointer *) p_element, data) == 0)\n+        return i;\n+    }\n+  } else {\n+    for (i = 0; i < array->length; i++) {\n+      p_element = array->array + ((i + array->head) % array->size) * elt_size;\n+      if (*(gpointer *) p_element == data)\n+        return i;\n+    }\n+  }\n+\n+  return -1;\n+}\n+\n+\/**\n+ * gst_vec_deque_get_length: (skip)\n+ * @array: a #GstVecDeque object\n+ *\n+ * Returns the length of the queue @array\n+ *\n+ * Returns: the length of the queue @array.\n+ *\n+ * Since: 1.26\n+ *\/\n+gsize\n+gst_vec_deque_get_length (GstVecDeque * array)\n+{\n+  g_return_val_if_fail (array != NULL, 0);\n+  return array->length;\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstvecdeque.c","additions":996,"deletions":0,"binary":false,"changes":996,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/* GStreamer\n+ * Copyright (C) 2009-2010 Edward Hervey <bilboed@bilboed.com>\n+ *\n+ * gstvecdeque.h:\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Library General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public\n+ * License along with this library; if not, write to the\n+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ *\/\n+\n+#include <glib.h>\n+\n+#ifndef __GST_VEC_DEQUE_H__\n+#define __GST_VEC_DEQUE_H__\n+\n+#include <glib.h>\n+#include <gst\/gstconfig.h>\n+\n+G_BEGIN_DECLS\n+\n+\/**\n+ * GstVecDeque: (skip)\n+ *\n+ * Since: 1.26\n+ *\/\n+typedef struct _GstVecDeque GstVecDeque;\n+\n+GST_API\n+GstVecDeque *   gst_vec_deque_new     (gsize initial_size);\n+\n+GST_API\n+void            gst_vec_deque_free    (GstVecDeque * array);\n+\n+GST_API\n+void            gst_vec_deque_set_clear_func (GstVecDeque *array,\n+                                              GDestroyNotify clear_func);\n+\n+GST_API\n+void            gst_vec_deque_clear     (GstVecDeque * array);\n+\n+GST_API\n+gpointer        gst_vec_deque_pop_head  (GstVecDeque * array);\n+\n+GST_API\n+gpointer        gst_vec_deque_peek_head (GstVecDeque * array);\n+\n+GST_API\n+gpointer        gst_vec_deque_peek_nth  (GstVecDeque * array, gsize idx);\n+\n+GST_API\n+gpointer        gst_vec_deque_pop_tail  (GstVecDeque * array);\n+\n+GST_API\n+gpointer        gst_vec_deque_peek_tail (GstVecDeque * array);\n+\n+GST_API\n+void            gst_vec_deque_push_tail (GstVecDeque * array,\n+                                         gpointer        data);\n+GST_API\n+gboolean        gst_vec_deque_is_empty  (GstVecDeque * array);\n+\n+GST_API\n+gpointer        gst_vec_deque_drop_element (GstVecDeque * array,\n+                                            gsize           idx);\n+GST_API\n+gsize           gst_vec_deque_find (GstVecDeque * array,\n+                                    GCompareFunc    func,\n+                                    gpointer        data);\n+GST_API\n+gsize           gst_vec_deque_get_length (GstVecDeque * array);\n+\n+\/* Functions for use with structures *\/\n+\n+GST_API\n+GstVecDeque * gst_vec_deque_new_for_struct (gsize struct_size,\n+                                            gsize initial_size);\n+GST_API\n+void            gst_vec_deque_push_tail_struct (GstVecDeque * array,\n+                                                  gpointer        p_struct);\n+GST_API\n+gpointer        gst_vec_deque_pop_head_struct  (GstVecDeque * array);\n+\n+GST_API\n+gpointer        gst_vec_deque_peek_head_struct (GstVecDeque * array);\n+\n+GST_API\n+gpointer        gst_vec_deque_peek_nth_struct  (GstVecDeque * array, gsize idx);\n+\n+GST_API\n+gboolean        gst_vec_deque_drop_struct      (GstVecDeque * array,\n+                                                gsize           idx,\n+                                                gpointer        p_struct);\n+GST_API\n+gpointer        gst_vec_deque_pop_tail_struct  (GstVecDeque * array);\n+\n+GST_API\n+gpointer        gst_vec_deque_peek_tail_struct (GstVecDeque * array);\n+\n+GST_API\n+void            gst_vec_deque_push_sorted (GstVecDeque * array,\n+                                           gpointer data,\n+                                           GCompareDataFunc func,\n+                                           gpointer user_data);\n+\n+GST_API\n+void            gst_vec_deque_push_sorted_struct (GstVecDeque * array,\n+                                                  gpointer p_struct,\n+                                                  GCompareDataFunc func,\n+                                                  gpointer user_data);\n+\n+GST_API\n+void            gst_vec_deque_sort (GstVecDeque *array,\n+                                    GCompareDataFunc compare_func,\n+                                    gpointer user_data);\n+\n+G_END_DECLS\n+\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstvecdeque.h","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -41,0 +41,12 @@\n+#ifndef GST_DISABLE_DEPRECATED\n+#define GST_BASE_DEPRECATED GST_BASE_API\n+#define GST_BASE_DEPRECATED_FOR(f) GST_BASE_API\n+#define GST_BASE_DEPRECATED_TYPE\n+#define GST_BASE_DEPRECATED_TYPE_FOR(f)\n+#else\n+#define GST_BASE_DEPRECATED G_DEPRECATED GST_BASE_API\n+#define GST_BASE_DEPRECATED_FOR(f) G_DEPRECATED_FOR(f) GST_BASE_API\n+#define GST_BASE_DEPRECATED_TYPE G_DEPRECATED\n+#define GST_BASE_DEPRECATED_TYPE_FOR(f) G_DEPRECATED_FOR(f)\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/base-prelude.h","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-  GstQueueArray *bufqueue;\n+  GstVecDeque *bufqueue;\n@@ -212,1 +212,1 @@\n-  adapter->bufqueue = gst_queue_array_new (10);\n+  adapter->bufqueue = gst_vec_deque_new (10);\n@@ -232,1 +232,1 @@\n-  gst_queue_array_free (adapter->bufqueue);\n+  gst_vec_deque_free (adapter->bufqueue);\n@@ -265,1 +265,1 @@\n-  while ((obj = gst_queue_array_pop_head (adapter->bufqueue)))\n+  while ((obj = gst_vec_deque_pop_head (adapter->bufqueue)))\n@@ -337,1 +337,1 @@\n-  buf = gst_queue_array_peek_nth (adapter->bufqueue, idx++);\n+  buf = gst_vec_deque_peek_nth (adapter->bufqueue, idx++);\n@@ -341,1 +341,1 @@\n-    buf = gst_queue_array_peek_nth (adapter->bufqueue, idx++);\n+    buf = gst_vec_deque_peek_nth (adapter->bufqueue, idx++);\n@@ -356,1 +356,1 @@\n-    buf = gst_queue_array_peek_nth (adapter->bufqueue, idx++);\n+    buf = gst_vec_deque_peek_nth (adapter->bufqueue, idx++);\n@@ -389,1 +389,1 @@\n-  if (gst_queue_array_is_empty (adapter->bufqueue)) {\n+  if (gst_vec_deque_is_empty (adapter->bufqueue)) {\n@@ -392,1 +392,1 @@\n-    gst_queue_array_push_tail (adapter->bufqueue, buf);\n+    gst_vec_deque_push_tail (adapter->bufqueue, buf);\n@@ -398,1 +398,1 @@\n-    gst_queue_array_push_tail (adapter->bufqueue, buf);\n+    gst_vec_deque_push_tail (adapter->bufqueue, buf);\n@@ -510,1 +510,1 @@\n-    cur = gst_queue_array_peek_head (adapter->bufqueue);\n+    cur = gst_vec_deque_peek_head (adapter->bufqueue);\n@@ -571,1 +571,1 @@\n-    GstBuffer *cur = gst_queue_array_peek_head (adapter->bufqueue);\n+    GstBuffer *cur = gst_vec_deque_peek_head (adapter->bufqueue);\n@@ -651,1 +651,1 @@\n-  cur = gst_queue_array_peek_head (adapter->bufqueue);\n+  cur = gst_vec_deque_peek_head (adapter->bufqueue);\n@@ -665,1 +665,1 @@\n-    gst_buffer_unref (gst_queue_array_pop_head (adapter->bufqueue));\n+    gst_buffer_unref (gst_vec_deque_pop_head (adapter->bufqueue));\n@@ -667,1 +667,1 @@\n-    if (gst_queue_array_is_empty (adapter->bufqueue)) {\n+    if (gst_vec_deque_is_empty (adapter->bufqueue)) {\n@@ -672,1 +672,1 @@\n-    cur = gst_queue_array_peek_head (adapter->bufqueue);\n+    cur = gst_vec_deque_peek_head (adapter->bufqueue);\n@@ -831,1 +831,1 @@\n-  cur = gst_queue_array_peek_head (adapter->bufqueue);\n+  cur = gst_vec_deque_peek_head (adapter->bufqueue);\n@@ -840,1 +840,1 @@\n-  len = gst_queue_array_get_length (adapter->bufqueue);\n+  len = gst_vec_deque_get_length (adapter->bufqueue);\n@@ -845,1 +845,1 @@\n-    cur = gst_queue_array_peek_nth (adapter->bufqueue, idx);\n+    cur = gst_vec_deque_peek_nth (adapter->bufqueue, idx);\n@@ -983,1 +983,1 @@\n-  cur = gst_queue_array_peek_head (adapter->bufqueue);\n+  cur = gst_vec_deque_peek_head (adapter->bufqueue);\n@@ -1023,1 +1023,1 @@\n-    len = gst_queue_array_get_length (adapter->bufqueue);\n+    len = gst_vec_deque_get_length (adapter->bufqueue);\n@@ -1026,1 +1026,1 @@\n-      cur = gst_queue_array_peek_nth (adapter->bufqueue, idx);\n+      cur = gst_vec_deque_peek_nth (adapter->bufqueue, idx);\n@@ -1114,1 +1114,1 @@\n-    cur = gst_queue_array_peek_head (adapter->bufqueue);\n+    cur = gst_vec_deque_peek_head (adapter->bufqueue);\n@@ -1163,1 +1163,1 @@\n-    cur = gst_queue_array_peek_nth (adapter->bufqueue, idx++);\n+    cur = gst_vec_deque_peek_nth (adapter->bufqueue, idx++);\n@@ -1229,1 +1229,1 @@\n-    cur = gst_queue_array_peek_head (adapter->bufqueue);\n+    cur = gst_vec_deque_peek_head (adapter->bufqueue);\n@@ -1286,1 +1286,1 @@\n-    cur = gst_queue_array_peek_nth (adapter->bufqueue, idx++);\n+    cur = gst_vec_deque_peek_nth (adapter->bufqueue, idx++);\n@@ -1317,0 +1317,4 @@\n+ * Calling gst_adapter_map() with the amount of bytes returned by this function\n+ * may require expensive operations (like copying the data into a temporary\n+ * buffer) in some cases.\n+ *\n@@ -1331,2 +1335,5 @@\n- * Gets the maximum number of bytes that are immediately available without\n- * requiring any expensive operations (like copying the data into a\n+ * Gets the maximum number of bytes that can be retrieved in a single map\n+ * operation without merging buffers.\n+ *\n+ * Calling gst_adapter_map() with the amount of bytes returned by this function\n+ * will never require any expensive operations (like copying the data into a\n@@ -1358,1 +1365,1 @@\n-    cur = gst_queue_array_peek_nth (adapter->bufqueue, idx++);\n+    cur = gst_vec_deque_peek_nth (adapter->bufqueue, idx++);\n@@ -1457,1 +1464,1 @@\n- * before the first byte with an offset is removed from the adapter, the offset\n+ * before the first byte with an offset is added to the adapter, the offset\n@@ -1486,1 +1493,1 @@\n- * the first byte with a pts is removed from the adapter, the pts\n+ * the first byte with a pts is added to the adapter, the pts\n@@ -1513,1 +1520,1 @@\n- * the first byte with a dts is removed from the adapter, the dts\n+ * the first byte with a dts is added to the adapter, the dts\n@@ -1541,1 +1548,1 @@\n- * the first byte with a pts is removed from the adapter, the pts\n+ * the first byte with a pts is added to the adapter, the pts\n@@ -1560,1 +1567,1 @@\n-  len = gst_queue_array_get_length (adapter->bufqueue);\n+  len = gst_vec_deque_get_length (adapter->bufqueue);\n@@ -1563,1 +1570,1 @@\n-    cur = gst_queue_array_peek_nth (adapter->bufqueue, idx++);\n+    cur = gst_vec_deque_peek_nth (adapter->bufqueue, idx++);\n@@ -1591,1 +1598,1 @@\n- * the first byte with a dts is removed from the adapter, the dts\n+ * the first byte with a dts is added to the adapter, the dts\n@@ -1610,1 +1617,1 @@\n-  len = gst_queue_array_get_length (adapter->bufqueue);\n+  len = gst_vec_deque_get_length (adapter->bufqueue);\n@@ -1613,1 +1620,1 @@\n-    cur = gst_queue_array_peek_nth (adapter->bufqueue, idx++);\n+    cur = gst_vec_deque_peek_nth (adapter->bufqueue, idx++);\n@@ -1683,1 +1690,1 @@\n-  buf = gst_queue_array_peek_nth (adapter->bufqueue, idx++);\n+  buf = gst_vec_deque_peek_nth (adapter->bufqueue, idx++);\n@@ -1689,1 +1696,1 @@\n-    buf = gst_queue_array_peek_nth (adapter->bufqueue, idx++);\n+    buf = gst_vec_deque_peek_nth (adapter->bufqueue, idx++);\n@@ -1728,1 +1735,1 @@\n-    buf = gst_queue_array_peek_nth (adapter->bufqueue, idx++);\n+    buf = gst_vec_deque_peek_nth (adapter->bufqueue, idx++);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstadapter.c","additions":48,"deletions":41,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -960,6 +960,1 @@\n-    return;\n-\n-  if (gst_tag_list_is_empty (merged_tags)) {\n-    gst_tag_list_unref (merged_tags);\n-    return;\n-  }\n+    merged_tags = gst_tag_list_new_empty ();\n@@ -968,2 +963,2 @@\n-    \/* only add bitrate tags to non-empty taglists for now, and only if neither\n-     * upstream tags nor the subclass sets the bitrate tag in question already *\/\n+    \/* only add bitrate tags if neither upstream tags nor the subclass sets the\n+     * bitrate tag in question already *\/\n@@ -988,0 +983,5 @@\n+  if (gst_tag_list_is_empty (merged_tags)) {\n+    gst_tag_list_unref (merged_tags);\n+    return;\n+  }\n+\n@@ -1119,1 +1119,1 @@\n-update_upstream_provided (GQuark field_id, const GValue * value,\n+update_upstream_provided (const GstIdStr * field, const GValue * value,\n@@ -1129,2 +1129,2 @@\n-    if (!gst_structure_id_has_field (structure, field_id)) {\n-      gst_structure_id_set_value (structure, field_id, value);\n+    if (!gst_structure_has_field (structure, gst_id_str_as_str (field))) {\n+      gst_structure_id_str_set_value (structure, field, value);\n@@ -1170,1 +1170,2 @@\n-    gst_structure_foreach (structure, update_upstream_provided, default_caps);\n+    gst_structure_foreach_id_str (structure, update_upstream_provided,\n+        default_caps);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstbaseparse.c","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-  guint32 segment_seqnum;\n@@ -3284,1 +3283,0 @@\n-      basesink->priv->segment_seqnum = GST_SEQNUM_INVALID;\n@@ -3561,1 +3559,0 @@\n-      basesink->priv->segment_seqnum = seqnum;\n@@ -5722,1 +5719,0 @@\n-      priv->segment_seqnum = GST_SEQNUM_INVALID;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstbasesink.c","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1847,0 +1847,1 @@\n+    GST_OBJECT_LOCK (src);\n@@ -1849,0 +1850,1 @@\n+    GST_OBJECT_UNLOCK (src);\n@@ -1908,1 +1910,0 @@\n-      src->priv->segment_pending = TRUE;\n@@ -1911,0 +1912,1 @@\n+      src->priv->segment_pending = TRUE;\n@@ -2888,0 +2890,1 @@\n+  GstEvent *seg_event = NULL;\n@@ -2976,1 +2979,2 @@\n-    GstEvent *seg_event = gst_event_new_segment (&src->segment);\n+    \/* generate the event but do not send until outside of live_lock  *\/\n+    seg_event = gst_event_new_segment (&src->segment);\n@@ -2978,0 +2982,1 @@\n+    GST_OBJECT_LOCK (src);\n@@ -2980,1 +2985,0 @@\n-    gst_pad_push_event (pad, seg_event);\n@@ -2982,0 +2986,1 @@\n+    GST_OBJECT_UNLOCK (src);\n@@ -2984,0 +2989,1 @@\n+  \/* collect any pending events *\/\n@@ -2992,0 +2998,1 @@\n+  GST_LIVE_UNLOCK (src);\n@@ -2993,1 +3000,5 @@\n-  \/* Push out pending events if any *\/\n+  \/* now outside the live_lock we can push the segment event *\/\n+  if (G_UNLIKELY (seg_event))\n+    gst_pad_push_event (pad, seg_event);\n+\n+  \/* and the pending events if any *\/\n@@ -3073,1 +3084,0 @@\n-  GST_LIVE_UNLOCK (src);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstbasesrc.c","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -658,1 +658,1 @@\n-        GST_DEBUG_OBJECT (pad, \"our template  %\" GST_PTR_FORMAT, otempl);\n+        GST_DEBUG_OBJECT (pad, \"other template  %\" GST_PTR_FORMAT, otempl);\n@@ -690,1 +690,1 @@\n-    GST_DEBUG_OBJECT (pad, \"our template  %\" GST_PTR_FORMAT, otempl);\n+    GST_DEBUG_OBJECT (pad, \"other template  %\" GST_PTR_FORMAT, otempl);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstbasetransform.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -307,2 +307,2 @@\n- * @func: (scope call): the function to set\n- * @user_data: (closure): user data passed to the function\n+ * @func: (scope call) (closure user_data): the function to set\n+ * @user_data: user data passed to the function\n@@ -332,2 +332,2 @@\n- * @func: (scope call): the function to set\n- * @user_data: (closure): user data passed to the function\n+ * @func: (scope call) (closure user_data): the function to set\n+ * @user_data: user data passed to the function\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstcollectpads.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  GstQueueArray *queue;\n+  GstVecDeque *queue;\n@@ -110,1 +110,1 @@\n-               \" ns, %u elements\",                                      \\\n+               \" ns, %\" G_GSIZE_FORMAT \" elements\",                     \\\n@@ -115,1 +115,1 @@\n-               gst_queue_array_get_length (q->priv->queue))\n+               gst_vec_deque_get_length (q->priv->queue))\n@@ -207,1 +207,1 @@\n-  queue->priv->queue = gst_queue_array_new (50);\n+  queue->priv->queue = gst_vec_deque_new (50);\n@@ -253,2 +253,2 @@\n-  while (!gst_queue_array_is_empty (priv->queue)) {\n-    GstDataQueueItem *item = gst_queue_array_pop_head (priv->queue);\n+  while (!gst_vec_deque_is_empty (priv->queue)) {\n+    GstDataQueueItem *item = gst_vec_deque_pop_head (priv->queue);\n@@ -274,1 +274,1 @@\n-  gst_queue_array_free (priv->queue);\n+  gst_vec_deque_free (priv->queue);\n@@ -304,1 +304,1 @@\n-  return (gst_queue_array_get_length (priv->queue) == 0);\n+  return (gst_vec_deque_get_length (priv->queue) == 0);\n@@ -422,1 +422,1 @@\n-  gst_queue_array_push_tail (priv->queue, item);\n+  gst_vec_deque_push_tail (priv->queue, item);\n@@ -601,1 +601,1 @@\n-  *item = gst_queue_array_pop_head (priv->queue);\n+  *item = gst_vec_deque_pop_head (priv->queue);\n@@ -671,1 +671,1 @@\n-  *item = gst_queue_array_peek_head (priv->queue);\n+  *item = gst_vec_deque_peek_head (priv->queue);\n@@ -711,1 +711,1 @@\n-  idx = gst_queue_array_find (priv->queue, is_of_type, GSIZE_TO_POINTER (type));\n+  idx = gst_vec_deque_find (priv->queue, is_of_type, GSIZE_TO_POINTER (type));\n@@ -716,1 +716,1 @@\n-  leak = gst_queue_array_drop_element (priv->queue, idx);\n+  leak = gst_vec_deque_drop_element (priv->queue, idx);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstdataqueue.c","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include <string.h>\n@@ -40,22 +39,0 @@\n-#define gst_queue_array_idx(a, i) \\\n-  ((a)->array + (((a)->head + (i)) % (a)->size) * (a)->elt_size)\n-\n-struct _GstQueueArray\n-{\n-  \/* < private > *\/\n-  guint8 *array;\n-  guint size;\n-  guint head;\n-  guint tail;\n-  guint length;\n-  guint elt_size;\n-  gboolean struct_array;\n-  GDestroyNotify clear_func;\n-};\n-\n-typedef struct\n-{\n-  GCompareDataFunc func;\n-  gpointer user_data;\n-} QueueSortData;\n-\n@@ -73,0 +50,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -77,14 +55,2 @@\n-  GstQueueArray *array;\n-\n-  g_return_val_if_fail (struct_size > 0, NULL);\n-\n-  array = g_new (GstQueueArray, 1);\n-  array->elt_size = struct_size;\n-  array->size = initial_size;\n-  array->array = g_malloc0 (struct_size * initial_size);\n-  array->head = 0;\n-  array->tail = 0;\n-  array->length = 0;\n-  array->struct_array = TRUE;\n-  array->clear_func = NULL;\n-  return array;\n+  return (GstQueueArray *) gst_vec_deque_new_for_struct (struct_size,\n+      initial_size);\n@@ -107,5 +73,1 @@\n-  GstQueueArray *array;\n-\n-  array = gst_queue_array_new_for_struct (sizeof (gpointer), initial_size);\n-  array->struct_array = FALSE;\n-  return array;\n+  return (GstQueueArray *) gst_vec_deque_new (initial_size);\n@@ -121,0 +83,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -125,4 +88,1 @@\n-  g_return_if_fail (array != NULL);\n-  gst_queue_array_clear (array);\n-  g_free (array->array);\n-  g_free (array);\n+  gst_vec_deque_free ((GstVecDeque *) array);\n@@ -148,0 +108,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -153,17 +114,1 @@\n-  g_return_if_fail (array != NULL);\n-  array->clear_func = clear_func;\n-}\n-\n-static void\n-gst_queue_array_clear_idx (GstQueueArray * array, guint idx)\n-{\n-  guint pos;\n-\n-  if (!array->clear_func)\n-    return;\n-\n-  pos = (idx + array->head) % array->size;\n-  if (array->struct_array)\n-    array->clear_func (array->array + pos * array->elt_size);\n-  else\n-    array->clear_func (*(gpointer *) (array->array + pos * array->elt_size));\n+  gst_vec_deque_set_clear_func ((GstVecDeque *) array, clear_func);\n@@ -179,0 +124,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -183,13 +129,1 @@\n-  g_return_if_fail (array != NULL);\n-\n-  if (array->clear_func != NULL) {\n-    guint i;\n-\n-    for (i = 0; i < array->length; i++) {\n-      gst_queue_array_clear_idx (array, i);\n-    }\n-  }\n-\n-  array->head = 0;\n-  array->tail = 0;\n-  array->length = 0;\n+  gst_vec_deque_clear ((GstVecDeque *) array);\n@@ -209,0 +143,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -213,13 +148,1 @@\n-  gpointer p_struct;\n-  g_return_val_if_fail (array != NULL, NULL);\n-  \/* empty array *\/\n-  if (G_UNLIKELY (array->length == 0))\n-    return NULL;\n-\n-  p_struct = array->array + (array->elt_size * array->head);\n-\n-  array->head++;\n-  array->head %= array->size;\n-  array->length--;\n-\n-  return p_struct;\n+  return gst_vec_deque_pop_head_struct ((GstVecDeque *) array);\n@@ -238,0 +161,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -242,12 +166,1 @@\n-  gpointer ret;\n-  g_return_val_if_fail (array != NULL, NULL);\n-\n-  \/* empty array *\/\n-  if (G_UNLIKELY (array->length == 0))\n-    return NULL;\n-\n-  ret = *(gpointer *) (array->array + (sizeof (gpointer) * array->head));\n-  array->head++;\n-  array->head %= array->size;\n-  array->length--;\n-  return ret;\n+  return gst_vec_deque_pop_head ((GstVecDeque *) array);\n@@ -267,0 +180,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -271,6 +185,1 @@\n-  g_return_val_if_fail (array != NULL, NULL);\n-  \/* empty array *\/\n-  if (G_UNLIKELY (array->length == 0))\n-    return NULL;\n-\n-  return array->array + (array->elt_size * array->head);\n+  return gst_vec_deque_peek_head_struct ((GstVecDeque *) array);\n@@ -289,0 +198,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -293,6 +203,1 @@\n-  g_return_val_if_fail (array != NULL, NULL);\n-  \/* empty array *\/\n-  if (G_UNLIKELY (array->length == 0))\n-    return NULL;\n-\n-  return *(gpointer *) (array->array + (sizeof (gpointer) * array->head));\n+  return gst_vec_deque_peek_head ((GstVecDeque *) array);\n@@ -309,0 +214,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -313,6 +219,1 @@\n-  g_return_val_if_fail (array != NULL, NULL);\n-  g_return_val_if_fail (idx < array->length, NULL);\n-\n-  idx = (array->head + idx) % array->size;\n-\n-  return *(gpointer *) (array->array + (sizeof (gpointer) * idx));\n+  return gst_vec_deque_peek_nth ((GstVecDeque *) array, idx);\n@@ -329,0 +230,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -333,54 +235,1 @@\n-  g_return_val_if_fail (array != NULL, NULL);\n-  g_return_val_if_fail (idx < array->length, NULL);\n-\n-  idx = (array->head + idx) % array->size;\n-\n-  return array->array + (array->elt_size * idx);\n-}\n-\n-static void\n-gst_queue_array_do_expand (GstQueueArray * array)\n-{\n-  gsize elt_size = array->elt_size;\n-  \/* newsize is 50% bigger *\/\n-  gsize oldsize = array->size;\n-  guint64 newsize;\n-\n-  newsize = MAX ((3 * (guint64) oldsize) \/ 2, (guint64) oldsize + 1);\n-  if (newsize > G_MAXUINT)\n-    g_error (\"growing the queue array would overflow\");\n-\n-  \/* copy over data *\/\n-  if (array->tail != 0) {\n-    guint8 *array2 = NULL;\n-    gsize t1 = 0;\n-    gsize t2 = 0;\n-\n-    array2 = g_malloc0_n (newsize, elt_size);\n-    t1 = array->head;\n-    t2 = oldsize - array->head;\n-\n-    \/* [0-----TAIL][HEAD------SIZE]\n-     *\n-     * We want to end up with\n-     * [HEAD------------------TAIL][----FREEDATA------NEWSIZE]\n-     *\n-     * 1) move [HEAD-----SIZE] part to beginning of new array\n-     * 2) move [0-------TAIL] part new array, after previous part\n-     *\/\n-\n-    memcpy (array2, array->array + (elt_size * (gsize) array->head),\n-        t2 * elt_size);\n-    memcpy (array2 + t2 * elt_size, array->array, t1 * elt_size);\n-\n-    g_free (array->array);\n-    array->array = array2;\n-    array->head = 0;\n-  } else {\n-    \/* Fast path, we just need to grow the array *\/\n-    array->array = g_realloc_n (array->array, newsize, elt_size);\n-    memset (array->array + elt_size * oldsize, 0,\n-        elt_size * (newsize - oldsize));\n-  }\n-  array->tail = oldsize;\n-  array->size = newsize;\n+  return gst_vec_deque_peek_nth_struct ((GstVecDeque *) array, idx);\n@@ -399,0 +248,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -403,14 +253,1 @@\n-  guint elt_size;\n-\n-  g_return_if_fail (p_struct != NULL);\n-  g_return_if_fail (array != NULL);\n-  elt_size = array->elt_size;\n-\n-  \/* Check if we need to make room *\/\n-  if (G_UNLIKELY (array->length == array->size))\n-    gst_queue_array_do_expand (array);\n-\n-  memcpy (array->array + elt_size * array->tail, p_struct, elt_size);\n-  array->tail++;\n-  array->tail %= array->size;\n-  array->length++;\n+  gst_vec_deque_push_tail_struct ((GstVecDeque *) array, p_struct);\n@@ -427,0 +264,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -431,39 +269,1 @@\n-  g_return_if_fail (array != NULL);\n-\n-  \/* Check if we need to make room *\/\n-  if (G_UNLIKELY (array->length == array->size))\n-    gst_queue_array_do_expand (array);\n-\n-  *(gpointer *) (array->array + sizeof (gpointer) * array->tail) = data;\n-  array->tail++;\n-  array->tail %= array->size;\n-  array->length++;\n-}\n-\n-\/* Moves all elements in the queue placed after the given position in the internal array *\/\n-static void\n-gst_queue_array_move_data_after_position (GstQueueArray * array, guint pos)\n-{\n-  guint elt_size = array->elt_size;\n-\n-  \/* If the array does not wrap around OR if it does, but we're inserting past that point *\/\n-  if (array->head < array->tail ||\n-      (array->head >= array->tail && pos < array->head)) {\n-    memmove (array->array + (pos + 1) * elt_size, array->array + pos * elt_size,\n-        (array->tail - pos) * elt_size);\n-    return;\n-  }\n-\n-  \/* Otherwise, array wraps around and we're inserting before the breaking point.\n-   * First, move everything past that point by one place. *\/\n-  memmove (array->array + elt_size, array->array, array->tail * elt_size);\n-\n-  \/* Then move the last element from before the wrap-around point to right after it. *\/\n-  memcpy (array->array, array->array + (array->size - 1) * elt_size, elt_size);\n-\n-  \/* If we're inserting right before the breaking point, no further action is needed.\n-   * Otherwise, move data between insertion point and the breaking point by one place. *\/\n-  if (pos != array->size - 1) {\n-    memmove (array->array + (pos + 1) * elt_size, array->array + pos * elt_size,\n-        (array->size - pos - 1) * elt_size);\n-  }\n+  gst_vec_deque_push_tail ((GstVecDeque *) array, data);\n@@ -489,0 +289,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -494,30 +295,1 @@\n-  guint i;\n-  gpointer *p_element;\n-\n-  g_return_if_fail (array != NULL);\n-  g_return_if_fail (func != NULL);\n-\n-  \/* Check if we need to make room *\/\n-  if (G_UNLIKELY (array->length == array->size))\n-    gst_queue_array_do_expand (array);\n-\n-  \/* Compare against each element, assuming they're already sorted *\/\n-  for (i = 0; i < array->length; i++) {\n-    p_element = (gpointer *) gst_queue_array_idx (array, i);\n-\n-    if (func (*p_element, data, user_data) > 0) {\n-      guint pos = (array->head + i) % array->size;\n-      gst_queue_array_move_data_after_position (array, pos);\n-\n-      *p_element = data;\n-      goto finish;\n-    }\n-  }\n-\n-  \/* No 'bigger' element found - append to tail *\/\n-  *(gpointer *) (array->array + array->elt_size * array->tail) = data;\n-\n-finish:\n-  array->tail++;\n-  array->tail %= array->size;\n-  array->length++;\n+  gst_vec_deque_push_sorted ((GstVecDeque *) array, data, func, user_data);\n@@ -545,0 +317,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -550,38 +323,2 @@\n-  guint i;\n-  gpointer p_element;\n-\n-  g_return_if_fail (array != NULL);\n-  g_return_if_fail (p_struct != NULL);\n-  g_return_if_fail (func != NULL);\n-\n-  \/* Check if we need to make room *\/\n-  if (G_UNLIKELY (array->length == array->size))\n-    gst_queue_array_do_expand (array);\n-\n-  \/* Compare against each element, assuming they're already sorted *\/\n-  for (i = 0; i < array->length; i++) {\n-    p_element = gst_queue_array_idx (array, i);\n-\n-    if (func (p_element, p_struct, user_data) > 0) {\n-      guint pos = (array->head + i) % array->size;\n-      gst_queue_array_move_data_after_position (array, pos);\n-\n-      memcpy (p_element, p_struct, array->elt_size);\n-      goto finish;\n-    }\n-  }\n-\n-  \/* No 'bigger' element found - append to tail *\/\n-  memcpy (array->array + array->elt_size * array->tail, p_struct,\n-      array->elt_size);\n-\n-finish:\n-  array->tail++;\n-  array->tail %= array->size;\n-  array->length++;\n-}\n-\n-static int\n-compare_wrapper (gpointer * a, gpointer * b, QueueSortData * sort_data)\n-{\n-  return sort_data->func (*a, *b, sort_data->user_data);\n+  gst_vec_deque_push_sorted_struct ((GstVecDeque *) array, p_struct, func,\n+      user_data);\n@@ -600,0 +337,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -605,42 +343,1 @@\n-  g_return_if_fail (array != NULL);\n-  g_return_if_fail (compare_func != NULL);\n-\n-  if (array->length == 0)\n-    return;\n-\n-  \/* To be able to use g_qsort_with_data, we might need to rearrange:\n-   * [0-----TAIL][HEAD-----SIZE] -> [HEAD-------TAIL] *\/\n-  if (array->head >= array->tail) {\n-    gsize t1 = array->head;\n-    gsize t2 = array->size - array->head;\n-    gsize elt_size = array->elt_size;\n-\n-    \/* Copy [0-------TAIL] part to a temporary buffer *\/\n-    guint8 *tmp = g_malloc0_n (t1, elt_size);\n-    memcpy (tmp, array->array, t1 * elt_size);\n-\n-    \/* Move [HEAD-----SIZE] part to the beginning of the original array *\/\n-    memmove (array->array, array->array + (elt_size * array->head),\n-        t2 * elt_size);\n-\n-    \/* Copy the temporary buffer to the end of the original array *\/\n-    memmove (array->array + (t2 * elt_size), tmp, t1 * elt_size);\n-    g_free (tmp);\n-\n-    array->head = 0;\n-    array->tail = array->length % array->size;\n-  }\n-\n-  if (array->struct_array) {\n-    g_qsort_with_data (array->array +\n-        (array->head % array->size) * array->elt_size, array->length,\n-        array->elt_size, compare_func, user_data);\n-  } else {\n-    \/* For non-struct arrays, we need to wrap the provided compare function\n-     * to dereference our pointers before passing them for comparison.\n-     * This matches the behaviour of gst_queue_array_find(). *\/\n-    QueueSortData sort_data = { compare_func, user_data };\n-    g_qsort_with_data (array->array +\n-        (array->head % array->size) * array->elt_size, array->length,\n-        array->elt_size, (GCompareDataFunc) compare_wrapper, &sort_data);\n-  }\n+  gst_vec_deque_sort ((GstVecDeque *) array, compare_func, user_data);\n@@ -658,0 +355,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -662,13 +360,1 @@\n-  guint len, idx;\n-\n-  g_return_val_if_fail (array != NULL, NULL);\n-\n-  len = array->length;\n-\n-  \/* empty array *\/\n-  if (len == 0)\n-    return NULL;\n-\n-  idx = (array->head + (len - 1)) % array->size;\n-\n-  return *(gpointer *) (array->array + (sizeof (gpointer) * idx));\n+  return gst_vec_deque_peek_tail ((GstVecDeque *) array);\n@@ -686,0 +372,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -690,13 +377,1 @@\n-  guint len, idx;\n-\n-  g_return_val_if_fail (array != NULL, NULL);\n-\n-  len = array->length;\n-\n-  \/* empty array *\/\n-  if (len == 0)\n-    return NULL;\n-\n-  idx = (array->head + (len - 1)) % array->size;\n-\n-  return array->array + (array->elt_size * idx);\n+  return gst_vec_deque_peek_tail_struct ((GstVecDeque *) array);\n@@ -715,0 +390,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -719,19 +395,1 @@\n-  gpointer ret;\n-  guint len, idx;\n-\n-  g_return_val_if_fail (array != NULL, NULL);\n-\n-  len = array->length;\n-\n-  \/* empty array *\/\n-  if (len == 0)\n-    return NULL;\n-\n-  idx = (array->head + (len - 1)) % array->size;\n-\n-  ret = *(gpointer *) (array->array + (sizeof (gpointer) * idx));\n-\n-  array->tail = idx;\n-  array->length--;\n-\n-  return ret;\n+  return gst_vec_deque_pop_tail ((GstVecDeque *) array);\n@@ -750,0 +408,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -754,19 +413,1 @@\n-  gpointer ret;\n-  guint len, idx;\n-\n-  g_return_val_if_fail (array != NULL, NULL);\n-\n-  len = array->length;\n-\n-  \/* empty array *\/\n-  if (len == 0)\n-    return NULL;\n-\n-  idx = (array->head + (len - 1)) % array->size;\n-\n-  ret = array->array + (array->elt_size * idx);\n-\n-  array->tail = idx;\n-  array->length--;\n-\n-  return ret;\n+  return gst_vec_deque_pop_tail_struct ((GstVecDeque *) array);\n@@ -784,0 +425,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -788,2 +430,1 @@\n-  g_return_val_if_fail (array != NULL, FALSE);\n-  return (array->length == 0);\n+  return gst_vec_deque_is_empty ((GstVecDeque *) array);\n@@ -806,0 +447,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -811,98 +453,1 @@\n-  int first_item_index, last_item_index;\n-  guint actual_idx;\n-  guint elt_size;\n-\n-  g_return_val_if_fail (array != NULL, FALSE);\n-  actual_idx = (array->head + idx) % array->size;\n-\n-  g_return_val_if_fail (array->length > 0, FALSE);\n-  g_return_val_if_fail (actual_idx < array->size, FALSE);\n-\n-  elt_size = array->elt_size;\n-\n-  first_item_index = array->head;\n-\n-  \/* tail points to the first free spot *\/\n-  last_item_index = (array->tail - 1 + array->size) % array->size;\n-\n-  if (p_struct != NULL)\n-    memcpy (p_struct, array->array + elt_size * actual_idx, elt_size);\n-\n-  \/* simple case actual_idx == first item *\/\n-  if (actual_idx == first_item_index) {\n-    \/* clear current head position if needed *\/\n-    if (p_struct == NULL)\n-      gst_queue_array_clear_idx (array, idx);\n-\n-    \/* move the head plus one *\/\n-    array->head++;\n-    array->head %= array->size;\n-    array->length--;\n-    return TRUE;\n-  }\n-\n-  \/* simple case idx == last item *\/\n-  if (actual_idx == last_item_index) {\n-    \/* clear current tail position if needed *\/\n-    if (p_struct == NULL)\n-      gst_queue_array_clear_idx (array, idx);\n-\n-    \/* move tail minus one, potentially wrapping *\/\n-    array->tail = (array->tail - 1 + array->size) % array->size;\n-    array->length--;\n-    return TRUE;\n-  }\n-\n-  \/* non-wrapped case *\/\n-  if (first_item_index < last_item_index) {\n-    \/* clear idx if needed *\/\n-    if (p_struct == NULL)\n-      gst_queue_array_clear_idx (array, idx);\n-\n-    g_assert (first_item_index < actual_idx && actual_idx < last_item_index);\n-    \/* move everything beyond actual_idx one step towards zero in array *\/\n-    memmove (array->array + elt_size * actual_idx,\n-        array->array + elt_size * (actual_idx + 1),\n-        (last_item_index - actual_idx) * elt_size);\n-    \/* tail might wrap, ie if tail == 0 (and last_item_index == size) *\/\n-    array->tail = (array->tail - 1 + array->size) % array->size;\n-    array->length--;\n-    return TRUE;\n-  }\n-\n-  \/* only wrapped cases left *\/\n-  g_assert (first_item_index > last_item_index);\n-\n-  if (actual_idx < last_item_index) {\n-    \/* clear idx if needed *\/\n-    if (p_struct == NULL)\n-      gst_queue_array_clear_idx (array, idx);\n-\n-    \/* actual_idx is before last_item_index, move data towards zero *\/\n-    memmove (array->array + elt_size * actual_idx,\n-        array->array + elt_size * (actual_idx + 1),\n-        (last_item_index - actual_idx) * elt_size);\n-    \/* tail should not wrap in this case! *\/\n-    g_assert (array->tail > 0);\n-    array->tail--;\n-    array->length--;\n-    return TRUE;\n-  }\n-\n-  if (actual_idx > first_item_index) {\n-    \/* clear idx if needed *\/\n-    if (p_struct == NULL)\n-      gst_queue_array_clear_idx (array, idx);\n-\n-    \/* actual_idx is after first_item_index, move data to higher indices *\/\n-    memmove (array->array + elt_size * (first_item_index + 1),\n-        array->array + elt_size * first_item_index,\n-        (actual_idx - first_item_index) * elt_size);\n-    array->head++;\n-    \/* head should not wrap in this case! *\/\n-    g_assert (array->head < array->size);\n-    array->length--;\n-    return TRUE;\n-  }\n-\n-  g_return_val_if_reached (FALSE);\n+  return gst_vec_deque_drop_struct ((GstVecDeque *) array, idx, p_struct);\n@@ -921,0 +466,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -925,6 +471,1 @@\n-  gpointer ptr;\n-\n-  if (!gst_queue_array_drop_struct (array, idx, &ptr))\n-    return NULL;\n-\n-  return ptr;\n+  return gst_vec_deque_drop_element ((GstVecDeque *) array, idx);\n@@ -946,0 +487,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -950,29 +492,1 @@\n-  gpointer p_element;\n-  guint elt_size;\n-  guint i;\n-\n-  \/* For struct arrays we need to implement this differently so that\n-   * the user gets a pointer to the element data not the dereferenced\n-   * pointer itself *\/\n-\n-  g_return_val_if_fail (array != NULL, -1);\n-  g_return_val_if_fail (array->struct_array == FALSE, -1);\n-\n-  elt_size = array->elt_size;\n-\n-  if (func != NULL) {\n-    \/* Scan from head to tail *\/\n-    for (i = 0; i < array->length; i++) {\n-      p_element = array->array + ((i + array->head) % array->size) * elt_size;\n-      if (func (*(gpointer *) p_element, data) == 0)\n-        return i;\n-    }\n-  } else {\n-    for (i = 0; i < array->length; i++) {\n-      p_element = array->array + ((i + array->head) % array->size) * elt_size;\n-      if (*(gpointer *) p_element == data)\n-        return i;\n-    }\n-  }\n-\n-  return -1;\n+  return gst_vec_deque_find ((GstVecDeque *) array, func, data);\n@@ -990,0 +504,1 @@\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -994,2 +509,1 @@\n-  g_return_val_if_fail (array != NULL, 0);\n-  return array->length;\n+  return gst_vec_deque_get_length ((GstVecDeque *) array);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstqueuearray.c","additions":51,"deletions":537,"binary":false,"changes":588,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+ *\n+ * Deprecated: 1.26: Use #GstVecDeque instead.\n@@ -34,1 +36,1 @@\n-typedef struct _GstQueueArray GstQueueArray;\n+typedef struct _GstQueueArray GST_BASE_DEPRECATED_TYPE_FOR(GstVecDeque) GstQueueArray;\n@@ -36,1 +38,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_new)\n@@ -39,1 +41,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_free)\n@@ -42,1 +44,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_set_clear_func)\n@@ -46,1 +48,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_clear)\n@@ -49,1 +51,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_pop_head)\n@@ -52,1 +54,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_peek_head)\n@@ -55,1 +57,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_peek_nth)\n@@ -58,1 +60,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_pop_tail)\n@@ -61,1 +63,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_peek_tail)\n@@ -64,1 +66,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_push_tail)\n@@ -67,1 +69,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_is_empty)\n@@ -70,1 +72,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_drop_element)\n@@ -73,1 +75,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_find)\n@@ -77,1 +79,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_get_length)\n@@ -82,1 +84,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_new_for_struct)\n@@ -85,1 +87,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_push_tail_struct)\n@@ -88,1 +90,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_pop_head_struct)\n@@ -91,1 +93,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_peek_head_struct)\n@@ -94,1 +96,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_peek_nth_struct)\n@@ -97,1 +99,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_drop_struct)\n@@ -101,1 +103,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_pop_tail_struct)\n@@ -104,1 +106,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_peek_tail_struct)\n@@ -107,1 +109,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_push_sorted)\n@@ -113,1 +115,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_push_sorted_struct)\n@@ -119,1 +121,1 @@\n-GST_BASE_API\n+GST_BASE_DEPRECATED_FOR(gst_vec_deque_sort)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gstqueuearray.h","additions":28,"deletions":26,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -582,0 +582,8 @@\n+static guint64\n+buf_helper_get_length (gpointer data)\n+{\n+  GstTypeFindBufHelper *helper = (GstTypeFindBufHelper *) data;\n+\n+  return helper->size;\n+}\n+\n@@ -673,1 +681,1 @@\n-  find.get_length = NULL;\n+  find.get_length = buf_helper_get_length;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/base\/gsttypefindhelper.c","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -308,0 +308,2 @@\n+      if (self->cs)\n+        gst_object_unref (self->cs);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/libs\/gst\/controller\/gstdirectcontrolbinding.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,3 +39,3 @@\n- * #GstQueue:current-level-buffers property. You can track changes\n- * by connecting to the notify::current-level-buffers signal (which\n- * like all signals will be emitted from the streaming thread). The same\n+ * #GstQueue:current-level-buffers property. If you set #queue:notify-levels to TRUE,\n+ * you can track changes by connecting to the notify::current-level-buffers signal\n+ * (which like all signals will be emitted from the streaming thread). The same\n@@ -86,1 +86,1 @@\n-                      \"-%\" G_GUINT64_FORMAT \" ns, %u items\", \\\n+                      \"-%\" G_GUINT64_FORMAT \" ns, %\" G_GSIZE_FORMAT \" items\", \\\n@@ -97,1 +97,1 @@\n-                      gst_queue_array_get_length (queue->queue))\n+                      gst_vec_deque_get_length (queue->queue))\n@@ -125,1 +125,3 @@\n-  PROP_FLUSH_ON_EOS\n+  PROP_FLUSH_ON_EOS,\n+  PROP_NOTIFY_LEVELS,\n+  PROP_LAST\n@@ -128,0 +130,2 @@\n+GParamSpec *properties[PROP_LAST];\n+\n@@ -147,0 +151,6 @@\n+#define GST_QUEUE_MUTEX_UNLOCK_NOTIFY_LEVELS(q, prev_level) G_STMT_START { \\\n+    GstQueueSize new_level = queue->cur_level;                             \\\n+    g_mutex_unlock (&q->qlock);                                            \\\n+    gst_queue_notify_levels (queue, &prev_level, &new_level);              \\\n+} G_STMT_END\n+\n@@ -320,1 +330,1 @@\n-  g_object_class_install_property (gobject_class, PROP_CUR_LEVEL_BYTES,\n+  properties[PROP_CUR_LEVEL_BYTES] =\n@@ -322,3 +332,4 @@\n-          \"Current amount of data in the queue (bytes)\",\n-          0, G_MAXUINT, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));\n-  g_object_class_install_property (gobject_class, PROP_CUR_LEVEL_BUFFERS,\n+      \"Current amount of data in the queue (bytes)\",\n+      0, G_MAXUINT, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);\n+\n+  properties[PROP_CUR_LEVEL_BUFFERS] =\n@@ -326,3 +337,4 @@\n-          \"Current number of buffers in the queue\",\n-          0, G_MAXUINT, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));\n-  g_object_class_install_property (gobject_class, PROP_CUR_LEVEL_TIME,\n+      \"Current number of buffers in the queue\",\n+      0, G_MAXUINT, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);\n+\n+  properties[PROP_CUR_LEVEL_TIME] =\n@@ -330,2 +342,2 @@\n-          \"Current amount of data in the queue (in ns)\",\n-          0, G_MAXUINT64, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));\n+      \"Current amount of data in the queue (in ns)\",\n+      0, G_MAXUINT64, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);\n@@ -333,1 +345,1 @@\n-  g_object_class_install_property (gobject_class, PROP_MAX_SIZE_BYTES,\n+  properties[PROP_MAX_SIZE_BYTES] =\n@@ -335,5 +347,5 @@\n-          \"Max. amount of data in the queue (bytes, 0=disable)\",\n-          0, G_MAXUINT, DEFAULT_MAX_SIZE_BYTES,\n-          G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |\n-          G_PARAM_STATIC_STRINGS));\n-  g_object_class_install_property (gobject_class, PROP_MAX_SIZE_BUFFERS,\n+      \"Max. amount of data in the queue (bytes, 0=disable)\",\n+      0, G_MAXUINT, DEFAULT_MAX_SIZE_BYTES,\n+      G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_STATIC_STRINGS);\n+\n+  properties[PROP_MAX_SIZE_BUFFERS] =\n@@ -341,5 +353,5 @@\n-          \"Max. number of buffers in the queue (0=disable)\", 0, G_MAXUINT,\n-          DEFAULT_MAX_SIZE_BUFFERS,\n-          G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |\n-          G_PARAM_STATIC_STRINGS));\n-  g_object_class_install_property (gobject_class, PROP_MAX_SIZE_TIME,\n+      \"Max. number of buffers in the queue (0=disable)\", 0, G_MAXUINT,\n+      DEFAULT_MAX_SIZE_BUFFERS,\n+      G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_STATIC_STRINGS);\n+\n+  properties[PROP_MAX_SIZE_TIME] =\n@@ -347,4 +359,3 @@\n-          \"Max. amount of data in the queue (in ns, 0=disable)\", 0, G_MAXUINT64,\n-          DEFAULT_MAX_SIZE_TIME,\n-          G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |\n-          G_PARAM_STATIC_STRINGS));\n+      \"Max. amount of data in the queue (in ns, 0=disable)\", 0, G_MAXUINT64,\n+      DEFAULT_MAX_SIZE_TIME,\n+      G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_STATIC_STRINGS);\n@@ -352,1 +363,1 @@\n-  g_object_class_install_property (gobject_class, PROP_MIN_THRESHOLD_BYTES,\n+  properties[PROP_MIN_THRESHOLD_BYTES] =\n@@ -354,5 +365,5 @@\n-          \"Min. amount of data in the queue to allow reading (bytes, 0=disable)\",\n-          0, G_MAXUINT, 0,\n-          G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |\n-          G_PARAM_STATIC_STRINGS));\n-  g_object_class_install_property (gobject_class, PROP_MIN_THRESHOLD_BUFFERS,\n+      \"Min. amount of data in the queue to allow reading (bytes, 0=disable)\",\n+      0, G_MAXUINT, 0,\n+      G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_STATIC_STRINGS);\n+\n+  properties[PROP_MIN_THRESHOLD_BUFFERS] =\n@@ -360,5 +371,5 @@\n-          \"Min. number of buffers in the queue to allow reading (0=disable)\", 0,\n-          G_MAXUINT, 0,\n-          G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |\n-          G_PARAM_STATIC_STRINGS));\n-  g_object_class_install_property (gobject_class, PROP_MIN_THRESHOLD_TIME,\n+      \"Min. number of buffers in the queue to allow reading (0=disable)\", 0,\n+      G_MAXUINT, 0,\n+      G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_STATIC_STRINGS);\n+\n+  properties[PROP_MIN_THRESHOLD_TIME] =\n@@ -366,4 +377,3 @@\n-          \"Min. amount of data in the queue to allow reading (in ns, 0=disable)\",\n-          0, G_MAXUINT64, 0,\n-          G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |\n-          G_PARAM_STATIC_STRINGS));\n+      \"Min. amount of data in the queue to allow reading (in ns, 0=disable)\",\n+      0, G_MAXUINT64, 0,\n+      G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_STATIC_STRINGS);\n@@ -371,1 +381,1 @@\n-  g_object_class_install_property (gobject_class, PROP_LEAKY,\n+  properties[PROP_LEAKY] =\n@@ -373,4 +383,3 @@\n-          \"Where the queue leaks, if at all\",\n-          GST_TYPE_QUEUE_LEAKY, GST_QUEUE_NO_LEAK,\n-          G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |\n-          G_PARAM_STATIC_STRINGS));\n+      \"Where the queue leaks, if at all\",\n+      GST_TYPE_QUEUE_LEAKY, GST_QUEUE_NO_LEAK,\n+      G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_STATIC_STRINGS);\n@@ -384,1 +393,1 @@\n-  g_object_class_install_property (gobject_class, PROP_SILENT,\n+  properties[PROP_SILENT] =\n@@ -386,3 +395,2 @@\n-          \"Don't emit queue signals\", FALSE,\n-          G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |\n-          G_PARAM_STATIC_STRINGS));\n+      \"Don't emit queue signals\", FALSE,\n+      G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_STATIC_STRINGS);\n@@ -405,1 +413,1 @@\n-  g_object_class_install_property (gobject_class, PROP_FLUSH_ON_EOS,\n+  properties[PROP_FLUSH_ON_EOS] =\n@@ -407,3 +415,2 @@\n-          \"Discard all data in the queue when an EOS event is received\", FALSE,\n-          G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |\n-          G_PARAM_STATIC_STRINGS));\n+      \"Discard all data in the queue when an EOS event is received\", FALSE,\n+      G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_STATIC_STRINGS);\n@@ -411,0 +418,15 @@\n+  \/**\n+   * GstQueue:notify-levels\n+   *\n+   * Whether to emit `notify:property-name` signals on levels changes or not\n+   *\n+   * Default: %FALSE\n+   *\n+   * Since: 1.26\n+   *\/\n+  properties[PROP_NOTIFY_LEVELS] =\n+      g_param_spec_boolean (\"notify-levels\", \"Notify-Levels\",\n+      \"Whether to emit `notify` signals on levels changes or not\", FALSE,\n+      G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING | G_PARAM_STATIC_STRINGS);\n+\n+  g_object_class_install_properties (gobject_class, PROP_LAST, properties);\n@@ -477,1 +499,1 @@\n-      gst_queue_array_new_for_struct (sizeof (GstQueueItem),\n+      gst_vec_deque_new_for_struct (sizeof (GstQueueItem),\n@@ -502,1 +524,1 @@\n-  while ((qitem = gst_queue_array_pop_head_struct (queue->queue))) {\n+  while ((qitem = gst_vec_deque_pop_head_struct (queue->queue))) {\n@@ -507,1 +529,1 @@\n-  gst_queue_array_free (queue->queue);\n+  gst_vec_deque_free (queue->queue);\n@@ -755,0 +777,18 @@\n+static void\n+gst_queue_notify_levels (GstQueue * queue, GstQueueSize * prev_level,\n+    GstQueueSize * new_level)\n+{\n+  if (!queue->notify_levels) {\n+    return;\n+  }\n+  if (new_level->buffers != prev_level->buffers)\n+    g_object_notify_by_pspec ((GObject *) queue,\n+        properties[PROP_CUR_LEVEL_BUFFERS]);\n+  if (new_level->bytes != prev_level->bytes)\n+    g_object_notify_by_pspec ((GObject *) queue,\n+        properties[PROP_CUR_LEVEL_BYTES]);\n+  if (new_level->time != prev_level->time)\n+    g_object_notify_by_pspec ((GObject *) queue,\n+        properties[PROP_CUR_LEVEL_TIME]);\n+}\n+\n@@ -760,1 +800,1 @@\n-  while ((qitem = gst_queue_array_pop_head_struct (queue->queue))) {\n+  while ((qitem = gst_vec_deque_pop_head_struct (queue->queue))) {\n@@ -807,1 +847,1 @@\n-  gst_queue_array_push_tail_struct (queue->queue, &qitem);\n+  gst_vec_deque_push_tail_struct (queue->queue, &qitem);\n@@ -828,1 +868,1 @@\n-  gst_queue_array_push_tail_struct (queue->queue, &qitem);\n+  gst_vec_deque_push_tail_struct (queue->queue, &qitem);\n@@ -853,1 +893,1 @@\n-      if (gst_queue_array_is_empty (queue->queue)) {\n+      if (gst_vec_deque_is_empty (queue->queue)) {\n@@ -872,1 +912,1 @@\n-  gst_queue_array_push_tail_struct (queue->queue, &qitem);\n+  gst_vec_deque_push_tail_struct (queue->queue, &qitem);\n@@ -884,1 +924,1 @@\n-  qitem = gst_queue_array_pop_head_struct (queue->queue);\n+  qitem = gst_vec_deque_pop_head_struct (queue->queue);\n@@ -1033,0 +1073,1 @@\n+        GstQueueSize prev_level = queue->cur_level;\n@@ -1086,1 +1127,1 @@\n-        GST_QUEUE_MUTEX_UNLOCK (queue);\n+        GST_QUEUE_MUTEX_UNLOCK_NOTIFY_LEVELS (queue, prev_level);\n@@ -1134,1 +1175,1 @@\n-        gst_queue_array_push_tail_struct (queue->queue, &qitem);\n+        gst_vec_deque_push_tail_struct (queue->queue, &qitem);\n@@ -1165,1 +1206,1 @@\n-  tail = gst_queue_array_peek_tail_struct (queue->queue);\n+  tail = gst_vec_deque_peek_tail_struct (queue->queue);\n@@ -1253,0 +1294,1 @@\n+  GstQueueSize prev_level = queue->cur_level;\n@@ -1300,0 +1342,1 @@\n+      {\n@@ -1301,0 +1344,5 @@\n+\n+        if (!queue->silent) {\n+          GST_QUEUE_MUTEX_UNLOCK_NOTIFY_LEVELS (queue, prev_level);\n+          GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);\n+        }\n@@ -1302,0 +1350,1 @@\n+      }\n@@ -1356,1 +1405,1 @@\n-  GST_QUEUE_MUTEX_UNLOCK (queue);\n+  GST_QUEUE_MUTEX_UNLOCK_NOTIFY_LEVELS (queue, prev_level);\n@@ -1363,1 +1412,1 @@\n-    GST_QUEUE_MUTEX_UNLOCK (queue);\n+    GST_QUEUE_MUTEX_UNLOCK_NOTIFY_LEVELS (queue, prev_level);\n@@ -1608,0 +1657,2 @@\n+  GstQueueSize prev_level = queue->cur_level;\n+\n@@ -1613,1 +1664,1 @@\n-  GST_QUEUE_MUTEX_UNLOCK (queue);\n+  GST_QUEUE_MUTEX_UNLOCK_NOTIFY_LEVELS (queue, prev_level);\n@@ -1646,0 +1697,1 @@\n+\n@@ -1926,0 +1978,3 @@\n+    case PROP_NOTIFY_LEVELS:\n+      queue->notify_levels = g_value_get_boolean (value);\n+      break;\n@@ -1979,0 +2034,3 @@\n+    case PROP_NOTIFY_LEVELS:\n+      g_value_set_boolean (value, queue->notify_levels);\n+      break;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/plugins\/elements\/gstqueue.c","additions":131,"deletions":73,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  GstQueueArray *queue;\n+  GstVecDeque *queue;\n@@ -132,1 +132,2 @@\n-  gboolean silent;      \/* don't emit signals *\/\n+  gboolean silent;             \/* don't emit signals *\/\n+  gboolean notify_levels;      \/* emit 'notify' signals on level changes *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/plugins\/elements\/gstqueue.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -723,1 +723,0 @@\n-          \/* fall through *\/\n@@ -725,0 +724,1 @@\n+          \/* FALLTHROUGH *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/plugins\/elements\/gsttypefindelement.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-#undef GST_DISABLE_GST_TRACER_HOOKS\n+#define GST_DISABLE_GST_TRACER_HOOKS 1\n@@ -473,1 +473,1 @@\n-#define PACKAGE_STRING \"GStreamer 1.24.10\"\n+#define PACKAGE_STRING \"GStreamer 1.26.5\"\n@@ -482,1 +482,1 @@\n-#define PACKAGE_VERSION \"1.24.10\"\n+#define PACKAGE_VERSION \"1.26.5\"\n@@ -522,1 +522,1 @@\n-#define VERSION \"1.24.10\"\n+#define VERSION \"1.26.5\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/projects\/build\/linux\/common\/config.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#undef GST_DISABLE_GST_TRACER_HOOKS\n+#define GST_DISABLE_GST_TRACER_HOOKS 1\n@@ -477,1 +477,1 @@\n-#define PACKAGE_STRING \"GStreamer 1.24.10\"\n+#define PACKAGE_STRING \"GStreamer 1.26.5\"\n@@ -486,1 +486,1 @@\n-#define PACKAGE_VERSION \"1.24.10\"\n+#define PACKAGE_VERSION \"1.26.5\"\n@@ -526,1 +526,1 @@\n-#define VERSION \"1.24.10\"\n+#define VERSION \"1.26.5\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/projects\/build\/osx\/common\/x86_64\/config.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#undef GST_DISABLE_GST_TRACER_HOOKS\n+#define GST_DISABLE_GST_TRACER_HOOKS 1\n@@ -478,1 +478,1 @@\n-#define PACKAGE_STRING \"GStreamer 1.24.10\"\n+#define PACKAGE_STRING \"GStreamer 1.26.5\"\n@@ -487,1 +487,1 @@\n-#define PACKAGE_VERSION \"1.24.10\"\n+#define PACKAGE_VERSION \"1.26.5\"\n@@ -527,1 +527,1 @@\n-#define VERSION \"1.24.10\"\n+#define VERSION \"1.26.5\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/projects\/build\/win32\/common\/config.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+          gstreamer\/gst\/gstidstr.c \\\n@@ -158,0 +159,1 @@\n+          gstreamer\/gst\/gstvecdeque.c \\\n@@ -219,0 +221,3 @@\n+          gst-plugins-base\/gst-libs\/gst\/video\/gstvideometa.c \\\n+          gst-plugins-base\/gst-libs\/gst\/video\/gstvideopool.c \\\n+          gst-plugins-base\/gst-libs\/gst\/video\/gstvideotimecode.c \\\n@@ -224,0 +229,2 @@\n+          gst-plugins-base\/gst-libs\/gst\/video\/video-frame.c \\\n+          gst-plugins-base\/gst-libs\/gst\/video\/video-hdr.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/linux\/gstreamer-lite\/Makefile","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+            gstreamer\/gst\/gstidstr.c \\\n@@ -153,0 +154,1 @@\n+            gstreamer\/gst\/gstvecdeque.c \\\n@@ -214,0 +216,3 @@\n+            gst-plugins-base\/gst-libs\/gst\/video\/gstvideometa.c \\\n+            gst-plugins-base\/gst-libs\/gst\/video\/gstvideopool.c \\\n+            gst-plugins-base\/gst-libs\/gst\/video\/gstvideotimecode.c \\\n@@ -219,0 +224,2 @@\n+            gst-plugins-base\/gst-libs\/gst\/video\/video-frame.c \\\n+            gst-plugins-base\/gst-libs\/gst\/video\/video-hdr.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/mac\/gstreamer-lite\/Makefile","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+gst_video_alignment_reset\t@155\tNONAME\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/win\/gstreamer-lite.def","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+            gstreamer\/gst\/gstidstr.c \\\n@@ -92,0 +93,1 @@\n+            gstreamer\/gst\/gstvecdeque.c \\\n@@ -153,0 +155,3 @@\n+            gst-plugins-base\/gst-libs\/gst\/video\/gstvideometa.c \\\n+            gst-plugins-base\/gst-libs\/gst\/video\/gstvideopool.c \\\n+            gst-plugins-base\/gst-libs\/gst\/video\/gstvideotimecode.c \\\n@@ -158,0 +163,2 @@\n+            gst-plugins-base\/gst-libs\/gst\/video\/video-frame.c \\\n+            gst-plugins-base\/gst-libs\/gst\/video\/video-hdr.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/win\/gstreamer-lite\/Makefile.gstreamer","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -155,0 +155,1 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-base\\gst-libs\\gst\\video\\video-hdr.c\" \/>\r\n@@ -287,0 +288,3 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gstreamer\\gst\\gstidstr.c\">\r\n+      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">WIN32;_WINDOWS;LIBGSTREAMER_EXPORTS;HAVE_CONFIG_H;HAVE_WIN32;LIBDSHOW_EXPORTS;GSTREAMER_LITE;GST_REMOVE_DEPRECATED;GST_REMOVE_DISABLED;GST_DISABLE_GST_DEBUG;GST_DISABLE_LOADSAVE;_USE_MATH_DEFINES;_USRDLL;_WINDLL;_MBCS;%(PreprocessorDefinitions)<\/PreprocessorDefinitions>\r\n+    <\/ClCompile>\r\n@@ -386,0 +390,3 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gstreamer\\gst\\gstvecdeque.c\">\r\n+      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">WIN32;_WINDOWS;LIBGSTREAMER_EXPORTS;HAVE_CONFIG_H;HAVE_WIN32;LIBDSHOW_EXPORTS;GSTREAMER_LITE;GST_REMOVE_DEPRECATED;GST_REMOVE_DISABLED;GST_DISABLE_GST_DEBUG;GST_DISABLE_LOADSAVE;_USE_MATH_DEFINES;_USRDLL;_WINDLL;_MBCS;%(PreprocessorDefinitions)<\/PreprocessorDefinitions>\r\n+    <\/ClCompile>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/gstreamer\/gstreamer.vcxproj","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -177,0 +177,3 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gstreamer\\gst\\gstidstr.c\">\r\n+      <Filter>gstreamer\\gst<\/Filter>\r\n+    <\/ClCompile>\r\n@@ -276,0 +279,3 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gstreamer\\gst\\gstvecdeque.c\">\r\n+      <Filter>gstreamer\\gst<\/Filter>\r\n+    <\/ClCompile>\r\n@@ -642,0 +648,3 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\gstreamer-lite\\gst-plugins-base\\gst-libs\\gst\\video\\video-hdr.c\">\r\n+      <Filter>gst-plugins-base\\gst-libs\\gst\\video<\/Filter>\r\n+    <\/ClCompile>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/gstreamer\/gstreamer.vcxproj.filters","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}