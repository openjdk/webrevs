{"files":[{"patch":"@@ -102,1 +102,2 @@\n-static HRESULT mfwrapper_load_decoder(GstMFWrapper *decoder, GstCaps *caps);\n+static HRESULT mfwrapper_load_decoder_caps(GstMFWrapper *decoder, GstCaps *caps);\n+static HRESULT mfwrapper_load_decoder_media_types(GstMFWrapper *decoder, GUID majorType, GUID subType);\n@@ -201,2 +202,2 @@\n-    decoder->force_discontinuity = FALSE;\n-    decoder->force_output_discontinuity = FALSE;\n+    decoder->is_force_discontinuity = FALSE;\n+    decoder->is_force_output_discontinuity = FALSE;\n@@ -230,0 +231,1 @@\n+    decoder->is_send_header = FALSE;\n@@ -239,0 +241,2 @@\n+\n+    decoder->is_set_caps = TRUE;\n@@ -245,2 +249,7 @@\n-    \/\/ No need to free pDecoderBuffer, it will be release when interface is\n-    \/\/ release by MF.\n+    if (decoder->header != NULL)\n+    {\n+        delete[] decoder->header;\n+        decoder->header = NULL;\n+        decoder->header_size = 0;\n+    }\n+\n@@ -248,0 +257,3 @@\n+    \/\/ No need to free pDecoderBuffer, it will be released when\n+    \/\/ pDecoderOutput is released.\n+    decoder->pDecoderBuffer = NULL;\n@@ -252,2 +264,0 @@\n-        \/\/ No need to free pColorConvertBuffer, it will be release when interface is\n-        \/\/ release by MF.\n@@ -255,0 +265,3 @@\n+        \/\/ No need to free pColorConvertBuffer, it will be released when\n+        \/\/ pColorConvertOutput is released.\n+        decoder->pColorConvertBuffer[i] = NULL;\n@@ -313,1 +326,1 @@\n-        hr = mfwrapper_load_decoder(decoder, caps);\n+        hr = mfwrapper_load_decoder_caps(decoder, caps);\n@@ -396,1 +409,1 @@\n-        decoder->force_output_discontinuity = TRUE;\n+        decoder->is_force_output_discontinuity = TRUE;\n@@ -519,1 +532,1 @@\n-    if (SUCCEEDED(hr) && decoder->force_discontinuity)\n+    if (SUCCEEDED(hr) && decoder->is_force_discontinuity)\n@@ -522,1 +535,1 @@\n-        decoder->force_discontinuity = FALSE;\n+        decoder->is_force_discontinuity = FALSE;\n@@ -536,1 +549,2 @@\n-    if (SUCCEEDED(hr) && decoder->header != NULL && decoder->header_size > 0)\n+    if (SUCCEEDED(hr) && decoder->is_send_header &&\n+            decoder->header != NULL && decoder->header_size > 0)\n@@ -553,1 +567,2 @@\n-    if (SUCCEEDED(hr) && decoder->header != NULL && decoder->header_size > 0)\n+    if (SUCCEEDED(hr) && decoder->is_send_header &&\n+            decoder->header != NULL && decoder->header_size > 0)\n@@ -555,0 +570,1 @@\n+        decoder->is_send_header = FALSE;\n@@ -582,7 +598,0 @@\n-    if (decoder->header != NULL)\n-    {\n-        delete[] decoder->header;\n-        decoder->header = NULL;\n-        decoder->header_size = 0;\n-    }\n-\n@@ -1060,0 +1069,3 @@\n+\n+            decoder->is_set_caps = TRUE; \/\/ Only set caps if resolution changed, so\n+            \/\/ we do not trigger it during decoder reload.\n@@ -1084,1 +1096,1 @@\n-    if (SUCCEEDED(hr) && bInitColorConverter)\n+    if (SUCCEEDED(hr) && bInitColorConverter && decoder->is_set_caps)\n@@ -1091,0 +1103,8 @@\n+        \/\/ Free old ones if any\n+        for (int i = 0; i < MAX_COLOR_CONVERT; i++)\n+        {\n+            SafeRelease(&decoder->pColorConvertOutput[i]);\n+            decoder->pColorConvertBuffer[i] = NULL;\n+            SafeRelease(&decoder->pColorConvert[i]);\n+        }\n+\n@@ -1112,1 +1132,2 @@\n-    if (SUCCEEDED(hr))\n+    if (SUCCEEDED(hr) && decoder->is_set_caps)\n+    {\n@@ -1115,5 +1136,5 @@\n-    \/\/ By now we should have output sample created. Figure out which one we\n-    \/\/ will use to deliver frames and update media buffer in this sample to\n-    \/\/ use GStreamer memory directly.\n-    if (SUCCEEDED(hr))\n-        hr = mfwrapper_configure_media_buffer(decoder);\n+        \/\/ By now we should have output sample created. Figure out which one we\n+        \/\/ will use to deliver frames and update media buffer in this sample to\n+        \/\/ use GStreamer memory directly.\n+        if (SUCCEEDED(hr))\n+            hr = mfwrapper_configure_media_buffer(decoder);\n@@ -1121,4 +1142,7 @@\n-    \/\/ Configure GStreamer buffer pool to avoid memory allocation for each\n-    \/\/ buffer.\n-    if (SUCCEEDED(hr))\n-        hr = mfwrapper_configure_buffer_pool(decoder);\n+        \/\/ Configure GStreamer buffer pool to avoid memory allocation for each\n+        \/\/ buffer.\n+        if (SUCCEEDED(hr))\n+            hr = mfwrapper_configure_buffer_pool(decoder);\n+\n+        decoder->is_set_caps = FALSE;\n+    }\n@@ -1315,1 +1339,1 @@\n-    if (SUCCEEDED(hr) && decoder->force_output_discontinuity)\n+    if (SUCCEEDED(hr) && decoder->is_force_output_discontinuity)\n@@ -1319,1 +1343,1 @@\n-        decoder->force_output_discontinuity = FALSE;\n+        decoder->is_force_output_discontinuity = FALSE;\n@@ -1447,0 +1471,69 @@\n+\/\/ This function will unload old instance of decoder and will create a new one.\n+\/\/ Input and Output media formats will be exactly same as old one.\n+\/\/ This function will not trigger format change downstream, so it should not\n+\/\/ be used as reload for format change.\n+\/\/ NOTE: This function should be called when stream lock is aquired. From\n+\/\/ serialized events for example like GST_EVENT_FLUSH_STOP.\n+static gboolean mfwrapper_reload_decoder(GstMFWrapper *decoder)\n+{\n+    HRESULT hr = S_OK;\n+\n+    IMFMediaType *pInputType = NULL;\n+    IMFMediaType *pOutputType = NULL;\n+\n+    DWORD dwStatus = 0;\n+\n+    GUID majorType;\n+    GUID subType;\n+\n+    if (decoder == NULL || decoder->pDecoder == NULL)\n+        return false;\n+\n+    \/\/ Save copy of old decoder\n+    IMFTransform *pOldDecoder = decoder->pDecoder;\n+\n+    decoder->pDecoder = NULL;\n+\n+    hr = pOldDecoder->GetInputCurrentType(0, &pInputType);\n+    if (SUCCEEDED(hr))\n+        hr = pOldDecoder->GetOutputCurrentType(0, &pOutputType);\n+    if (SUCCEEDED(hr))\n+        hr = pInputType->GetGUID(MF_MT_MAJOR_TYPE, &majorType);\n+    if (SUCCEEDED(hr))\n+        hr = pInputType->GetGUID(MF_MT_SUBTYPE, &subType);\n+\n+    \/\/ Load decoder based on media types of current one\n+    hr = mfwrapper_load_decoder_media_types(decoder, majorType, subType);\n+\n+    \/\/ Copy input and output types and we should be good to go\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->SetInputType(0, pInputType, 0);\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->SetOutputType(0, pOutputType, 0);\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->GetInputStatus(0, &dwStatus);\n+\n+    if (FAILED(hr) || dwStatus != MFT_INPUT_STATUS_ACCEPT_DATA) {\n+        hr = E_FAIL;\n+    }\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, NULL);\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_NOTIFY_BEGIN_STREAMING, NULL);\n+\n+    if (SUCCEEDED(hr))\n+        hr = decoder->pDecoder->ProcessMessage(MFT_MESSAGE_NOTIFY_START_OF_STREAM, NULL);\n+\n+    SafeRelease(&pInputType);\n+    SafeRelease(&pOutputType);\n+    SafeRelease(&pOldDecoder);\n+\n+    if (FAILED(hr))\n+        return false;\n+\n+    return true;\n+}\n+\n@@ -1457,1 +1550,1 @@\n-        decoder->force_discontinuity = TRUE;\n+        decoder->is_force_discontinuity = TRUE;\n@@ -1474,3 +1567,1 @@\n-            decoder->pDecoder->\n-                    ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n-            for (int i = 0; i < MAX_COLOR_CONVERT; i++)\n+            if (!mfwrapper_reload_decoder(decoder))\n@@ -1478,1 +1569,12 @@\n-                if (decoder->pColorConvert[i])\n+                decoder->is_decoder_error = TRUE;\n+                gst_element_message_full(GST_ELEMENT(decoder), GST_MESSAGE_ERROR,\n+                                     GST_STREAM_ERROR, GST_STREAM_ERROR_DECODE,\n+                                     g_strdup(\"Failed to reload decoder\"), NULL,\n+                                     (\"mfwrapper.c\"), (\"mfwrapper_sink_event\"), 0);\n+            }\n+            else\n+            {\n+                \/\/ Send header after reload\n+                decoder->is_send_header = TRUE;\n+\n+                for (int i = 0; i < MAX_COLOR_CONVERT; i++)\n@@ -1480,2 +1582,5 @@\n-                    decoder->pColorConvert[i]->\n-                            ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+                    if (decoder->pColorConvert[i])\n+                    {\n+                        decoder->pColorConvert[i]->\n+                                ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+                    }\n@@ -1486,0 +1591,2 @@\n+        \/\/ Even if reload failed with critical error push event to unblock\n+        \/\/ pipeline.\n@@ -1587,1 +1694,1 @@\n-static HRESULT mfwrapper_load_decoder(GstMFWrapper *decoder, GstCaps *caps)\n+static HRESULT mfwrapper_load_decoder_caps(GstMFWrapper *decoder, GstCaps *caps)\n@@ -1589,3 +1696,0 @@\n-    HRESULT hr = S_OK;\n-    UINT32 count = 0;\n-\n@@ -1595,0 +1699,15 @@\n+    if (decoder->pDecoder)\n+        return S_OK;\n+\n+    if (!mfwrapper_get_mf_media_types(caps, &majorType, &subType))\n+        return E_FAIL;\n+\n+    return mfwrapper_load_decoder_media_types(decoder, majorType, subType);\n+}\n+\n+static HRESULT mfwrapper_load_decoder_media_types(GstMFWrapper *decoder,\n+                                                  GUID majorType, GUID subType)\n+{\n+    HRESULT hr = S_OK;\n+    UINT32 count = 0;\n+\n@@ -1602,3 +1721,0 @@\n-    if (!mfwrapper_get_mf_media_types(caps, &majorType, &subType))\n-        return E_FAIL;\n-\n@@ -1836,0 +1952,2 @@\n+\n+            decoder->is_send_header = TRUE;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfwrapper.cpp","additions":165,"deletions":47,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -80,2 +80,2 @@\n-    gboolean force_discontinuity;\n-    gboolean force_output_discontinuity;\n+    gboolean is_force_discontinuity;\n+    gboolean is_force_output_discontinuity;\n@@ -97,0 +97,1 @@\n+    gboolean is_send_header;\n@@ -106,0 +107,2 @@\n+\n+    gboolean is_set_caps;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfwrapper.h","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}