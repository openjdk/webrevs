{"files":[{"patch":"@@ -87,0 +87,1 @@\n+def gtk3expCCFlags = [ \"-Wno-deprecated-declarations\" ];\n@@ -141,0 +142,1 @@\n+            gtk3expCCFlags.addAll(cflagsGTK3.split(\" \"))\n@@ -215,1 +217,1 @@\n-LINUX.glass.variants = [\"glass\", \"glassgtk2\", \"glassgtk3\"]\n+LINUX.glass.variants = [\"glass\", \"glassgtk2\", \"glassgtk3\", \"glassgtk2_exp\", \"glassgtk3_exp\"]\n@@ -225,0 +227,5 @@\n+FileTree ft_gtkexp = fileTree(\"${project(\":graphics\").projectDir}\/src\/main\/native-glass\/gtk_experimental\/\") {\n+    exclude(\"**\/launcher.c\")\n+}\n+\n+\n@@ -253,0 +260,20 @@\n+LINUX.glass.glassgtk2_exp = [:]\n+LINUX.glass.glassgtk2_exp.nativeSource =  ft_gtkexp.getFiles()\n+LINUX.glass.glassgtk2_exp.compiler = compiler\n+LINUX.glass.glassgtk2_exp.ccFlags = IS_STATIC_BUILD ?\n+        [\"-fno-threadsafe-statics\", ccFlags, gtk2CCFlags].flatten() :\n+        [cppFlags, gtk2CCFlags, \"-Werror\"].flatten()\n+LINUX.glass.glassgtk2_exp.linker = linker\n+LINUX.glass.glassgtk2_exp.linkFlags = IS_STATIC_BUILD ? linkFlags : [linkFlags, gtk2LinkFlags].flatten()\n+LINUX.glass.glassgtk2_exp.lib = \"glassgtk2_exp\"\n+\n+LINUX.glass.glassgtk3_exp = [:]\n+LINUX.glass.glassgtk3_exp.nativeSource =  ft_gtkexp.getFiles()\n+LINUX.glass.glassgtk3_exp.compiler = compiler\n+LINUX.glass.glassgtk3_exp.ccFlags = IS_STATIC_BUILD ?\n+        [\"-fno-threadsafe-statics\", ccFlags, gtk3expCCFlags].flatten() :\n+        [cppFlags, gtk3expCCFlags, \"-Werror\"].flatten()\n+LINUX.glass.glassgtk3_exp.linker = linker\n+LINUX.glass.glassgtk3_exp.linkFlags = IS_STATIC_BUILD ? linkFlags : [linkFlags, gtk3LinkFlags].flatten()\n+LINUX.glass.glassgtk3_exp.lib = \"glassgtk3_exp\"\n+\n","filename":"buildSrc\/linux.gradle","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -158,0 +158,4 @@\n+\n+        boolean gtkExperimental = AccessController.doPrivileged((PrivilegedAction<Boolean>) () ->\n+                Boolean.getBoolean(\"javafx.gtk.experimental\"));\n+\n@@ -179,0 +183,1 @@\n+                String libName = (gtkExperimental) ? \"glassgtk2_exp\" : \"glassgtk2\";\n@@ -180,1 +185,1 @@\n-                    System.out.println(\"Glass GTK library to load is glassgtk2\");\n+                    System.out.println(String.format(\"Glass GTK library to load is %s\", libName));\n@@ -182,1 +187,2 @@\n-                NativeLibLoader.loadLibrary(\"glassgtk2\");\n+\n+                NativeLibLoader.loadLibrary(libName);\n@@ -184,0 +190,1 @@\n+                String libName = (gtkExperimental) ? \"glassgtk3_exp\" : \"glassgtk3\";\n@@ -185,1 +192,1 @@\n-                    System.out.println(\"Glass GTK library to load is glassgtk3\");\n+                    System.out.println(String.format(\"Glass GTK library to load is %s\", libName));\n@@ -187,1 +194,2 @@\n-                NativeLibLoader.loadLibrary(\"glassgtk3\");\n+\n+                NativeLibLoader.loadLibrary(libName);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkApplication.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+    private static boolean USE_EXPERIMENTAL_GTK_IMPL = Boolean.getBoolean(\"javafx.gtk.experimental\");\n@@ -204,10 +205,12 @@\n-        if ((w <= 0) && (cw > 0) || (h <= 0) && (ch > 0)) {\n-            final int[] extarr = new int[4];\n-            getFrameExtents(ptr, extarr);\n-\n-            \/\/ TODO: ((w <= 0) && (cw <= 0)) || ((h <= 0) && (ch <= 0))\n-            notifyResize(WindowEvent.RESIZE,\n-                         ((w <= 0) && (cw > 0)) ? cw + extarr[0] + extarr[1]\n-                                                : w,\n-                         ((h <= 0) && (ch > 0)) ? ch + extarr[2] + extarr[3]\n-                                                : h);\n+        if (!USE_EXPERIMENTAL_GTK_IMPL) {\n+            if ((w <= 0) && (cw > 0) || (h <= 0) && (ch > 0)) {\n+                final int[] extarr = new int[4];\n+                getFrameExtents(ptr, extarr);\n+\n+                \/\/ TODO: ((w <= 0) && (cw <= 0)) || ((h <= 0) && (ch <= 0))\n+                notifyResize(WindowEvent.RESIZE,\n+                        ((w <= 0) && (cw > 0)) ? cw + extarr[0] + extarr[1]\n+                                : w,\n+                        ((h <= 0) && (ch > 0)) ? ch + extarr[2] + extarr[3]\n+                                : h);\n+            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkWindow.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,473 @@\n+\/*\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <X11\/Xlib.h>\n+#include <X11\/Xatom.h>\n+#include <gdk\/gdk.h>\n+#include <gdk\/gdkx.h>\n+#include <gtk\/gtk.h>\n+#include <glib.h>\n+\n+#include <cstdlib>\n+#include <com_sun_glass_ui_gtk_GtkApplication.h>\n+#include <com_sun_glass_events_WindowEvent.h>\n+#include <com_sun_glass_events_MouseEvent.h>\n+#include <com_sun_glass_events_ViewEvent.h>\n+#include <com_sun_glass_events_KeyEvent.h>\n+#include <jni.h>\n+\n+#include \"glass_general.h\"\n+#include \"glass_evloop.h\"\n+#include \"glass_dnd.h\"\n+#include \"glass_window.h\"\n+#include \"glass_screen.h\"\n+\n+GdkEventFunc process_events_prev;\n+static void process_events(GdkEvent*, gpointer);\n+\n+JNIEnv* mainEnv; \/\/ Use only with main loop thread!!!\n+\n+extern gboolean disableGrab;\n+\n+static gboolean call_runnable (gpointer data)\n+{\n+    RunnableContext* context = reinterpret_cast<RunnableContext*>(data);\n+\n+    JNIEnv *env;\n+    int envStatus = javaVM->GetEnv((void **)&env, JNI_VERSION_1_6);\n+    if (envStatus == JNI_EDETACHED) {\n+        javaVM->AttachCurrentThread((void **)&env, NULL);\n+    }\n+\n+    env->CallVoidMethod(context->runnable, jRunnableRun, NULL);\n+    LOG_EXCEPTION(env);\n+    env->DeleteGlobalRef(context->runnable);\n+    free(context);\n+\n+    if (envStatus == JNI_EDETACHED) {\n+        javaVM->DetachCurrentThread();\n+    }\n+\n+    return FALSE;\n+}\n+\n+extern \"C\" {\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n+static void init_threads() {\n+    gboolean is_g_thread_get_initialized = FALSE;\n+    if (glib_check_version(2, 32, 0)) { \/\/ < 2.32\n+        if (!glib_check_version(2, 20, 0)) {\n+            is_g_thread_get_initialized = g_thread_get_initialized();\n+        }\n+        if (!is_g_thread_get_initialized) {\n+            g_thread_init(NULL);\n+        }\n+    }\n+    gdk_threads_init();\n+}\n+#pragma GCC diagnostic pop\n+\n+jboolean gtk_verbose = JNI_FALSE;\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    _initGTK\n+ * Signature: (IZ)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkApplication__1initGTK\n+  (JNIEnv *env, jclass clazz, jint version, jboolean verbose, jfloat uiScale)\n+{\n+    (void) clazz;\n+    (void) version;\n+\n+    OverrideUIScale = uiScale;\n+    gtk_verbose = verbose;\n+\n+    env->ExceptionClear();\n+\n+#if !GTK_CHECK_VERSION(3, 6, 0)\n+    init_threads();\n+    gdk_threads_enter();\n+#endif\n+\n+    gtk_init(NULL, NULL);\n+\n+    return JNI_TRUE;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    _queryLibrary\n+ * Signature: Signature: (IZ)I\n+ *\/\n+#ifndef STATIC_BUILD\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkApplication__1queryLibrary\n+  (JNIEnv *env, jclass clazz, jint suggestedVersion, jboolean verbose)\n+{\n+    \/\/ If we are being called, then the launcher is\n+    \/\/ not in use, and we are in the proper glass library already.\n+    \/\/ This can be done by renaming the gtk versioned native\n+    \/\/ libraries to be libglass.so\n+    \/\/ Note: we will make no effort to complain if the suggestedVersion\n+    \/\/ is out of phase.\n+\n+    (void)env;\n+    (void)clazz;\n+    (void)suggestedVersion;\n+    (void)verbose;\n+\n+    Display *display = XOpenDisplay(NULL);\n+    if (display == NULL) {\n+        return com_sun_glass_ui_gtk_GtkApplication_QUERY_NO_DISPLAY;\n+    }\n+    XCloseDisplay(display);\n+\n+    return com_sun_glass_ui_gtk_GtkApplication_QUERY_USE_CURRENT;\n+}\n+#endif\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    _init\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkApplication__1init\n+  (JNIEnv * env, jobject obj, jlong handler, jboolean _disableGrab)\n+{\n+    (void)obj;\n+\n+    mainEnv = env;\n+    process_events_prev = (GdkEventFunc) handler;\n+    disableGrab = (gboolean) _disableGrab;\n+\n+    glass_gdk_x11_display_set_window_scale(gdk_display_get_default(), 1);\n+    gdk_event_handler_set(process_events, NULL, NULL);\n+\n+    GdkScreen *default_gdk_screen = gdk_screen_get_default();\n+    if (default_gdk_screen != NULL) {\n+        g_signal_connect(G_OBJECT(default_gdk_screen), \"monitors-changed\",\n+                         G_CALLBACK(screen_settings_changed), NULL);\n+        g_signal_connect(G_OBJECT(default_gdk_screen), \"size-changed\",\n+                         G_CALLBACK(screen_settings_changed), NULL);\n+    }\n+\n+    GdkWindow *root = gdk_screen_get_root_window(default_gdk_screen);\n+    gdk_window_set_events(root, static_cast<GdkEventMask>(gdk_window_get_events(root) | GDK_PROPERTY_CHANGE_MASK));\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    _runLoop\n+ * Signature: (Ljava\/lang\/Runnable;Z)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkApplication__1runLoop\n+  (JNIEnv * env, jobject obj, jobject launchable, jboolean noErrorTrap)\n+{\n+    (void)obj;\n+    (void)noErrorTrap;\n+\n+    env->CallVoidMethod(launchable, jRunnableRun);\n+    CHECK_JNI_EXCEPTION(env);\n+\n+    \/\/ GTK installs its own X error handler that conflicts with AWT.\n+    \/\/ During drag and drop, AWT hides errors so we need to hide them\n+    \/\/ to avoid exit()'ing.  It's not clear that we don't want to hide\n+    \/\/ X error all the time, otherwise FX will exit().\n+    \/\/\n+    \/\/ A better solution would be to coordinate with AWT and save and\n+    \/\/ restore the X handler.\n+\n+    \/\/ Disable X error handling\n+#ifndef VERBOSE\n+    if (!noErrorTrap) {\n+#if GTK_CHECK_VERSION(3, 0, 0)\n+        gdk_x11_display_error_trap_push(gdk_display_get_default());\n+#else\n+        gdk_error_trap_push();\n+#endif\n+    }\n+#endif\n+\n+    gtk_main();\n+\n+    \/\/ When the last JFrame closes and DISPOSE_ON_CLOSE is specified,\n+    \/\/ Java exits with an X error. X error are hidden during the FX\n+    \/\/ event loop and should be restored when the event loop exits. Unfortunately,\n+    \/\/ this is too early. The fix is to never restore X errors.\n+    \/\/\n+    \/\/ See RT-21408 & RT-20756\n+\n+    \/\/ Restore X error handling\n+    \/\/ #ifndef VERBOSE\n+    \/\/     if (!noErrorTrap) {\n+    \/\/         gdk_error_trap_pop();\n+    \/\/     }\n+    \/\/ #endif\n+\n+#if !GTK_CHECK_VERSION(3, 6, 0)\n+    gdk_threads_leave();\n+#endif\n+\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    _terminateLoop\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkApplication__1terminateLoop\n+  (JNIEnv * env, jobject obj)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    gtk_main_quit();\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    _submitForLaterInvocation\n+ * Signature: (Ljava\/lang\/Runnable;)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkApplication__1submitForLaterInvocation\n+  (JNIEnv * env, jobject obj, jobject runnable)\n+{\n+    (void)obj;\n+\n+    RunnableContext* context = (RunnableContext*)malloc(sizeof(RunnableContext));\n+    context->runnable = env->NewGlobalRef(runnable);\n+    gdk_threads_add_idle_full(G_PRIORITY_HIGH_IDLE + 30, call_runnable, context, NULL);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    enterNestedEventLoopImpl\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkApplication_enterNestedEventLoopImpl\n+  (JNIEnv * env, jobject obj)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    gtk_main();\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    leaveNestedEventLoopImpl\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkApplication_leaveNestedEventLoopImpl\n+  (JNIEnv * env, jobject obj)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    gtk_main_quit();\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    staticScreen_getScreens\n+ * Signature: ()[Lcom\/sun\/glass\/ui\/Screen;\n+ *\/\n+JNIEXPORT jobjectArray JNICALL Java_com_sun_glass_ui_gtk_GtkApplication_staticScreen_1getScreens\n+  (JNIEnv * env, jobject obj)\n+{\n+    (void)obj;\n+\n+    try {\n+        return rebuild_screens(env);\n+    } catch (jni_exception&) {\n+        return NULL;\n+    }\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    staticTimer_getMinPeriod\n+ * Signature: ()I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkApplication_staticTimer_1getMinPeriod\n+  (JNIEnv * env, jobject obj)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    return 0; \/\/ There are no restrictions on period in g_threads\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    staticTimer_getMaxPeriod\n+ * Signature: ()I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkApplication_staticTimer_1getMaxPeriod\n+  (JNIEnv * env, jobject obj)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    return 10000; \/\/ There are no restrictions on period in g_threads\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    staticView_getMultiClickTime\n+ * Signature: ()J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_gtk_GtkApplication_staticView_1getMultiClickTime\n+  (JNIEnv * env, jobject obj)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    static gint multi_click_time = -1;\n+    if (multi_click_time == -1) {\n+        g_object_get(gtk_settings_get_default(), \"gtk-double-click-time\", &multi_click_time, NULL);\n+    }\n+    return (jlong)multi_click_time;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    staticView_getMultiClickMaxX\n+ * Signature: ()I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkApplication_staticView_1getMultiClickMaxX\n+  (JNIEnv * env, jobject obj)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    static gint multi_click_dist = -1;\n+\n+    if (multi_click_dist == -1) {\n+        g_object_get(gtk_settings_get_default(), \"gtk-double-click-distance\", &multi_click_dist, NULL);\n+    }\n+    return multi_click_dist;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    staticView_getMultiClickMaxY\n+ * Signature: ()I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkApplication_staticView_1getMultiClickMaxY\n+  (JNIEnv * env, jobject obj)\n+{\n+    return Java_com_sun_glass_ui_gtk_GtkApplication_staticView_1getMultiClickMaxX(env, obj);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    _supportsTransparentWindows\n+ * Signature: ()Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkApplication__1supportsTransparentWindows\n+  (JNIEnv * env, jobject obj) {\n+    (void)env;\n+    (void)obj;\n+\n+    return gdk_screen_is_composited(gdk_screen_get_default());\n+}\n+\n+} \/\/ extern \"C\"\n+\n+bool is_window_enabled_for_event(GdkWindow * window, WindowContext *ctx, gint event_type) {\n+\n+\n+    if (gdk_window_is_destroyed(window)) {\n+        return FALSE;\n+    }\n+\n+    \/*\n+     * GDK_DELETE can be blocked for disabled window e.q. parent window\n+     * which prevents from closing it\n+     *\/\n+    switch (event_type) {\n+        case GDK_CONFIGURE:\n+        case GDK_DESTROY:\n+        case GDK_EXPOSE:\n+        case GDK_DAMAGE:\n+        case GDK_WINDOW_STATE:\n+        case GDK_FOCUS_CHANGE:\n+            return TRUE;\n+            break;\n+    }\/\/switch\n+\n+    if (ctx != NULL) {\n+        return ctx->isEnabled();\n+    }\n+    return TRUE;\n+}\n+\n+static void process_events(GdkEvent* event, gpointer data)\n+{\n+    GdkWindow* window = event->any.window;\n+    WindowContext *ctx = window != NULL ? (WindowContext*)\n+        g_object_get_data(G_OBJECT(window), GDK_WINDOW_DATA_CONTEXT) : NULL;\n+\n+    if ((window != NULL)\n+            && !is_window_enabled_for_event(window, ctx, event->type)) {\n+        return;\n+    }\n+\n+    if (ctx != NULL && ctx->hasIME() && ctx->filterIME(event)) {\n+        return;\n+    }\n+\n+    glass_evloop_call_hooks(event);\n+\n+    if (ctx != NULL) {\n+        EventsCounterHelper helper(ctx);\n+\n+        if (event->type == GDK_EXPOSE) {\n+            ctx->process_expose(&event->expose);\n+        } else if (event->type == GDK_DRAG_LEAVE) {\n+            dnd_drag_leave_callback(ctx);\n+        } else {\n+            gtk_main_do_event(event);\n+        }\n+    } else {\n+        if (window == gdk_screen_get_root_window(gdk_screen_get_default())) {\n+            if (event->any.type == GDK_PROPERTY_NOTIFY) {\n+                if (event->property.atom == gdk_atom_intern_static_string(\"_NET_WORKAREA\")\n+                        || event->property.atom == gdk_atom_intern_static_string(\"_NET_CURRENT_DESKTOP\")) {\n+                    screen_settings_changed(gdk_screen_get_default(), NULL);\n+                }\n+            }\n+        }\n+\n+        \/\/process only for non-FX windows\n+        if (process_events_prev != NULL) {\n+            (*process_events_prev)(event, data);\n+        } else {\n+            gtk_main_do_event(event);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/GlassApplication.cpp","additions":473,"deletions":0,"binary":false,"changes":473,"status":"added"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <com_sun_glass_ui_gtk_GtkCommonDialogs.h>\n+#include \"glass_general.h\"\n+#include \"glass_window.h\"\n+\n+#include <gdk\/gdk.h>\n+#include <gtk\/gtk.h>\n+\n+#include <cstring>\n+#include <cstdlib>\n+\n+static GSList* setup_GtkFileFilters(GtkFileChooser*, JNIEnv*, jobjectArray, int default_filter_index);\n+\n+static void free_fname(char* fname, gpointer unused) {\n+    (void)unused;\n+\n+    g_free(fname);\n+}\n+\n+static gboolean jstring_to_utf_get(JNIEnv *env, jstring jstr,\n+                                   const char **cstr) {\n+    const char *newstr;\n+\n+    if (jstr == NULL) {\n+        *cstr = NULL;\n+        return TRUE;\n+    }\n+\n+    newstr = env->GetStringUTFChars(jstr, NULL);\n+    if (newstr != NULL) {\n+        *cstr = newstr;\n+        return TRUE;\n+    }\n+\n+    return FALSE;\n+}\n+\n+static void jstring_to_utf_release(JNIEnv *env, jstring jstr,\n+                                   const char *cstr) {\n+    if (cstr != NULL) {\n+        env->ReleaseStringUTFChars(jstr, cstr);\n+    }\n+}\n+\n+static GtkWindow *gdk_window_handle_to_gtk(jlong handle) {\n+    return  (handle != 0)\n+                ? ((WindowContext*)JLONG_TO_PTR(handle))->get_gtk_window()\n+                : NULL;\n+}\n+\n+static jobject create_empty_result() {\n+    jclass jFileChooserResult = (jclass) mainEnv->FindClass(\"com\/sun\/glass\/ui\/CommonDialogs$FileChooserResult\");\n+    if (EXCEPTION_OCCURED(mainEnv)) return NULL;\n+    jmethodID jFileChooserResultInit = mainEnv->GetMethodID(jFileChooserResult, \"<init>\", \"()V\");\n+    if (EXCEPTION_OCCURED(mainEnv)) return NULL;\n+    jobject jResult = mainEnv->NewObject(jFileChooserResult, jFileChooserResultInit);\n+    if (EXCEPTION_OCCURED(mainEnv)) return NULL;\n+    return jResult;\n+}\n+\n+extern \"C\" {\n+\n+JNIEXPORT jobject JNICALL Java_com_sun_glass_ui_gtk_GtkCommonDialogs__1showFileChooser\n+  (JNIEnv *env, jclass clazz, jlong parent, jstring folder, jstring name, jstring title,\n+   jint type, jboolean multiple, jobjectArray jFilters, jint default_filter_index) {\n+    (void)clazz;\n+\n+    jobjectArray jFileNames = NULL;\n+    char* filename;\n+    jstring jfilename;\n+\n+    const char* chooser_folder;\n+    const char* chooser_filename;\n+    const char* chooser_title;\n+    const int chooser_type = type == 0 ? GTK_FILE_CHOOSER_ACTION_OPEN : GTK_FILE_CHOOSER_ACTION_SAVE;\n+\n+    if (!jstring_to_utf_get(env, folder, &chooser_folder)) {\n+        return create_empty_result();\n+    }\n+\n+    if (!jstring_to_utf_get(env, title, &chooser_title)) {\n+        jstring_to_utf_release(env, folder, chooser_folder);\n+        return create_empty_result();\n+    }\n+\n+    if (!jstring_to_utf_get(env, name, &chooser_filename)) {\n+        jstring_to_utf_release(env, folder, chooser_folder);\n+        jstring_to_utf_release(env, title, chooser_title);\n+        return create_empty_result();\n+    }\n+\n+    GtkWidget* chooser = gtk_file_chooser_dialog_new(chooser_title, gdk_window_handle_to_gtk(parent),\n+            static_cast<GtkFileChooserAction>(chooser_type),\n+            \"_Cancel\",\n+            GTK_RESPONSE_CANCEL,\n+            (chooser_type == GTK_FILE_CHOOSER_ACTION_OPEN ? \"_Open\" : \"_Save\"),\n+            GTK_RESPONSE_ACCEPT,\n+            NULL);\n+\n+    if (chooser_type == GTK_FILE_CHOOSER_ACTION_SAVE) {\n+        gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(chooser), chooser_filename);\n+        gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER (chooser), TRUE);\n+    }\n+\n+    gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(chooser), (JNI_TRUE == multiple));\n+    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser), chooser_folder);\n+    GSList* filters = setup_GtkFileFilters(GTK_FILE_CHOOSER(chooser), env, jFilters, default_filter_index);\n+\n+    if (gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT) {\n+        GSList* fnames_gslist = gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(chooser));\n+        guint fnames_list_len = g_slist_length(fnames_gslist);\n+        LOG1(\"FileChooser selected files: %d\\n\", fnames_list_len)\n+\n+        if (fnames_list_len > 0) {\n+            jFileNames = env->NewObjectArray((jsize)fnames_list_len, jStringCls, NULL);\n+            EXCEPTION_OCCURED(env);\n+            for (guint i = 0; i < fnames_list_len; i++) {\n+                filename = (char*)g_slist_nth(fnames_gslist, i)->data;\n+                LOG1(\"Add [%s] into returned filenames\\n\", filename)\n+                jfilename = env->NewStringUTF(filename);\n+                EXCEPTION_OCCURED(env);\n+                env->SetObjectArrayElement(jFileNames, (jsize)i, jfilename);\n+                EXCEPTION_OCCURED(env);\n+            }\n+            g_slist_foreach(fnames_gslist, (GFunc) free_fname, NULL);\n+            g_slist_free(fnames_gslist);\n+        }\n+    }\n+\n+    if (!jFileNames) {\n+        jFileNames = env->NewObjectArray(0, jStringCls, NULL);\n+        EXCEPTION_OCCURED(env);\n+    }\n+\n+    int index = g_slist_index(filters, gtk_file_chooser_get_filter(GTK_FILE_CHOOSER(chooser)));\n+\n+    jclass jCommonDialogs = (jclass) env->FindClass(\"com\/sun\/glass\/ui\/CommonDialogs\");\n+    EXCEPTION_OCCURED(env);\n+    jmethodID jCreateFileChooserResult = env->GetStaticMethodID(jCommonDialogs,\n+            \"createFileChooserResult\",\n+            \"([Ljava\/lang\/String;[Lcom\/sun\/glass\/ui\/CommonDialogs$ExtensionFilter;I)Lcom\/sun\/glass\/ui\/CommonDialogs$FileChooserResult;\");\n+\n+    EXCEPTION_OCCURED(env);\n+\n+    jobject result =\n+            env->CallStaticObjectMethod(jCommonDialogs, jCreateFileChooserResult, jFileNames, jFilters, index);\n+    LOG_EXCEPTION(env)\n+\n+    g_slist_free(filters);\n+    gtk_widget_destroy(chooser);\n+\n+    jstring_to_utf_release(env, folder, chooser_folder);\n+    jstring_to_utf_release(env, title, chooser_title);\n+    jstring_to_utf_release(env, name, chooser_filename);\n+\n+    LOG_STRING_ARRAY(env, jFileNames);\n+    return result;\n+}\n+\n+JNIEXPORT jstring JNICALL Java_com_sun_glass_ui_gtk_GtkCommonDialogs__1showFolderChooser\n+  (JNIEnv *env, jclass clazz, jlong parent, jstring folder, jstring title) {\n+    (void)clazz;\n+\n+    jstring jfilename = NULL;\n+    const char *chooser_folder;\n+    const char *chooser_title;\n+\n+    if (!jstring_to_utf_get(env, folder, &chooser_folder)) {\n+        return NULL;\n+    }\n+\n+    if (!jstring_to_utf_get(env, title, &chooser_title)) {\n+        jstring_to_utf_release(env, folder, chooser_folder);\n+        return NULL;\n+    }\n+\n+    GtkWidget* chooser = gtk_file_chooser_dialog_new(\n+            chooser_title,\n+            gdk_window_handle_to_gtk(parent),\n+            GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,\n+            \"_Cancel\",\n+            GTK_RESPONSE_CANCEL,\n+            \"_Open\",\n+            GTK_RESPONSE_ACCEPT,\n+            NULL);\n+\n+    if (chooser_folder != NULL) {\n+        gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser),\n+                                            chooser_folder);\n+    }\n+\n+    if (gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT) {\n+        gchar* filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser));\n+        jfilename = env->NewStringUTF(filename);\n+        LOG1(\"Selected folder: %s\\n\", filename);\n+        g_free(filename);\n+    }\n+\n+    jstring_to_utf_release(env, folder, chooser_folder);\n+    jstring_to_utf_release(env, title, chooser_title);\n+\n+    gtk_widget_destroy(chooser);\n+    return jfilename;\n+}\n+\n+} \/\/ extern \"C\"\n+\n+\/**\n+ *\n+ * @param env\n+ * @param extFilters ExtensionFilter[]\n+ * @return\n+ *\/\n+static GSList* setup_GtkFileFilters(GtkFileChooser* chooser, JNIEnv* env, jobjectArray extFilters, int default_filter_index) {\n+    int i;\n+    LOG0(\"Setup filters\\n\")\n+    \/\/setup methodIDs\n+    jclass jcls = env->FindClass(\"com\/sun\/glass\/ui\/CommonDialogs$ExtensionFilter\");\n+    if (EXCEPTION_OCCURED(env)) return NULL;\n+    jmethodID jgetDescription = env->GetMethodID(jcls,\n+                                         \"getDescription\", \"()Ljava\/lang\/String;\");\n+    if (EXCEPTION_OCCURED(env)) return NULL;\n+    jmethodID jextensionsToArray = env->GetMethodID(jcls,\n+                                         \"extensionsToArray\", \"()[Ljava\/lang\/String;\");\n+    if (EXCEPTION_OCCURED(env)) return NULL;\n+\n+    jsize jfilters_size = env->GetArrayLength(extFilters);\n+    LOG1(\"Filters: %d\\n\", jfilters_size)\n+    if (jfilters_size == 0) return NULL;\n+\n+    GSList* filter_list = NULL;\n+\n+    for(i = 0; i<jfilters_size; i++) {\n+        GtkFileFilter* ffilter = gtk_file_filter_new();\n+        jobject jfilter = env->GetObjectArrayElement(extFilters, i);\n+        EXCEPTION_OCCURED(env);\n+\n+        \/\/setup description\n+        jstring jdesc = (jstring)env->CallObjectMethod(jfilter, jgetDescription);\n+        const char * description = env->GetStringUTFChars(jdesc, NULL);\n+        LOG2(\"description[%d]: %s\\n\", i, description)\n+        gtk_file_filter_set_name(ffilter, (gchar*)const_cast<char*>(description));\n+        env->ReleaseStringUTFChars(jdesc, description);\n+\n+        \/\/add patterns\n+        jobjectArray jextensions = (jobjectArray)env->CallObjectMethod(jfilter, jextensionsToArray);\n+        jsize jextarray_size = env->GetArrayLength(jextensions);\n+        LOG1(\"Patterns: %d\\n\", jextarray_size)\n+        int ext_idx;\n+        for(ext_idx = 0; ext_idx < jextarray_size; ext_idx++) {\n+            jstring jext = (jstring)env->GetObjectArrayElement(jextensions, ext_idx);\n+            EXCEPTION_OCCURED(env);\n+            const char * ext = env->GetStringUTFChars(jext, NULL);\n+            LOG2(\"pattern[%d]: %s\\n\", ext_idx, ext)\n+            gtk_file_filter_add_pattern(ffilter, (gchar*)const_cast<char*>(ext));\n+            env->ReleaseStringUTFChars(jext, ext);\n+        }\n+        LOG0(\"Filter ready\\n\")\n+        gtk_file_chooser_add_filter(chooser, ffilter);\n+\n+        if (default_filter_index == i) {\n+            gtk_file_chooser_set_filter(chooser, ffilter);\n+        }\n+\n+        filter_list = g_slist_append(filter_list, ffilter);\n+    }\n+    return filter_list;\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/GlassCommonDialogs.cpp","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <com_sun_glass_ui_gtk_GtkCursor.h>\n+\n+#include <gdk\/gdk.h>\n+#include <stdlib.h>\n+#include <jni.h>\n+\n+#include \"com_sun_glass_ui_Cursor.h\"\n+#include \"glass_general.h\"\n+\n+#ifndef GLASS_GTK3\n+static GdkCursor* find_best_cursor(const gchar* options, GdkCursorType type) {\n+    gchar **opts = g_strsplit(options, \",\", -1);\n+    gint size = g_strv_length(opts);\n+\n+    GdkCursor *cursor = NULL;\n+\n+    for (int i = 0; i < size; i++) {\n+        cursor = gdk_cursor_new_from_name(gdk_display_get_default(), opts[i]);\n+\n+        if (cursor != NULL) {\n+            break;\n+        }\n+    }\n+\n+    g_strfreev(opts);\n+\n+    if (cursor != NULL) {\n+        return cursor;\n+    }\n+\n+    return gdk_cursor_new_for_display(gdk_display_get_default(), type);\n+}\n+\n+GdkCursor* get_native_cursor(int type)\n+{\n+    GdkCursor *cursor = NULL;\n+    switch (type) {\n+        case com_sun_glass_ui_Cursor_CURSOR_DEFAULT:\n+            cursor = find_best_cursor(\"default\", GDK_LEFT_PTR);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_TEXT:\n+            cursor = find_best_cursor(\"text\", GDK_XTERM);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_CROSSHAIR:\n+            cursor = find_best_cursor(\"cross,crosshair\", GDK_CROSSHAIR);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_CLOSED_HAND:\n+            cursor = find_best_cursor(\"closedhand\", GDK_HAND2);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_OPEN_HAND:\n+            cursor = find_best_cursor(\"openhand\", GDK_HAND2);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_POINTING_HAND:\n+            cursor = gdk_cursor_new(GDK_HAND2);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_UP:\n+            cursor = find_best_cursor(\"n-resize,ns-resize,size_ver\", GDK_TOP_SIDE);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_DOWN:\n+            cursor = find_best_cursor(\"s-resize,ns-resize,size_ver\", GDK_BOTTOM_SIDE);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_UPDOWN:\n+            cursor = find_best_cursor(\"ns-resize,ew-resize,size_ver\", GDK_SB_V_DOUBLE_ARROW);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_LEFT:\n+            cursor = find_best_cursor(\"w-resize,ew-resize,size_hor\", GDK_LEFT_SIDE);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_RIGHT:\n+            cursor = find_best_cursor(\"e-resize,ew-resize,size_hor\", GDK_RIGHT_SIDE);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_LEFTRIGHT:\n+            cursor = find_best_cursor(\"ew-resize,size_hor\", GDK_SB_H_DOUBLE_ARROW);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_SOUTHWEST:\n+            cursor = find_best_cursor(\"sw-resize,nesw-resize,size_bdiag\", GDK_BOTTOM_LEFT_CORNER);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_NORTHEAST:\n+            cursor = find_best_cursor(\"ne-resize,nesw-resize,size_bdiag\", GDK_TOP_RIGHT_CORNER);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_SOUTHEAST:\n+            cursor = find_best_cursor(\"se-resize,nwse-resize,size_fdiag\", GDK_BOTTOM_RIGHT_CORNER);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_NORTHWEST:\n+            cursor = find_best_cursor(\"nw-resize,nwse-resize,size_fdiag\", GDK_TOP_LEFT_CORNER);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_MOVE:\n+            cursor = find_best_cursor(\"fleur,move,alt-scroll\", GDK_SIZING);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_WAIT:\n+            cursor = find_best_cursor(\"wait\", GDK_WATCH);\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_DISAPPEAR:\n+        case com_sun_glass_ui_Cursor_CURSOR_NONE:\n+            cursor = find_best_cursor(\"none\", GDK_BLANK_CURSOR);\n+            break;\n+        default:\n+            cursor = find_best_cursor(\"default\", GDK_LEFT_PTR);\n+            break;\n+    }\n+\n+    if (cursor == NULL) {\n+        cursor = find_best_cursor(\"default\", GDK_LEFT_PTR);\n+    }\n+\n+    return cursor;\n+}\n+#else\n+GdkCursor* get_native_cursor(int type)\n+{\n+    gchar* cursor_name = NULL;\n+\n+    switch (type) {\n+        case com_sun_glass_ui_Cursor_CURSOR_DEFAULT:\n+            cursor_name = g_strdup(\"default\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_TEXT:\n+            cursor_name = g_strdup(\"text\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_CROSSHAIR:\n+            cursor_name = g_strdup(\"crosshair\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_CLOSED_HAND:\n+            cursor_name = g_strdup(\"grabbing\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_OPEN_HAND:\n+            cursor_name = g_strdup(\"grab\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_POINTING_HAND:\n+            cursor_name = g_strdup(\"pointer\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_UP:\n+            cursor_name = g_strdup(\"n-resize\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_DOWN:\n+            cursor_name = g_strdup(\"s-resize\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_UPDOWN:\n+            cursor_name = g_strdup(\"ns-resize\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_LEFT:\n+            cursor_name = g_strdup(\"w-resize\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_RIGHT:\n+            cursor_name = g_strdup(\"e-resize\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_LEFTRIGHT:\n+            cursor_name = g_strdup(\"ew-resize\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_SOUTHWEST:\n+            cursor_name = g_strdup(\"sw-resize\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_NORTHEAST:\n+            cursor_name = g_strdup(\"ne-resize\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_SOUTHEAST:\n+            cursor_name = g_strdup(\"se-resize\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_NORTHWEST:\n+            cursor_name = g_strdup(\"nw-resize\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_MOVE:\n+            cursor_name = g_strdup(\"move\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_WAIT:\n+            cursor_name = g_strdup(\"wait\");\n+            break;\n+        case com_sun_glass_ui_Cursor_CURSOR_DISAPPEAR:\n+        case com_sun_glass_ui_Cursor_CURSOR_NONE:\n+            cursor_name = g_strdup(\"none\");\n+            break;\n+        default:\n+            cursor_name = g_strdup(\"default\");\n+            break;\n+    }\n+\n+    GdkCursor* cursor = gdk_cursor_new_from_name(gdk_display_get_default(), cursor_name);\n+\n+    if (cursor == NULL) {\n+        cursor = gdk_cursor_new_from_name(gdk_display_get_default(), \"default\");\n+    }\n+\n+    g_free(cursor_name);\n+\n+    return cursor;\n+}\n+#endif\n+\n+extern \"C\" {\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkCursor\n+ * Method:    _createCursor\n+ * Signature: (IILcom\/sun\/glass\/ui\/Pixels;)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_gtk_GtkCursor__1createCursor\n+  (JNIEnv * env, jobject obj, jint x, jint y, jobject pixels)\n+{\n+    (void)obj;\n+\n+    GdkPixbuf *pixbuf = NULL;\n+    GdkCursor *cursor = NULL;\n+    env->CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&pixbuf));\n+    if (!EXCEPTION_OCCURED(env)) {\n+        cursor = gdk_cursor_new_from_pixbuf(gdk_display_get_default(), pixbuf, x, y);\n+    }\n+    g_object_unref(pixbuf);\n+\n+    return PTR_TO_JLONG(cursor);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkCursor\n+ * Method:    _getBestSize\n+ * Signature: (II)Lcom.sun.glass.ui.Size\n+ *\/\n+JNIEXPORT jobject JNICALL Java_com_sun_glass_ui_gtk_GtkCursor__1getBestSize\n+        (JNIEnv *env, jclass jCursorClass, jint width, jint height)\n+{\n+    (void)jCursorClass;\n+    (void)width;\n+    (void)height;\n+\n+    int size = gdk_display_get_default_cursor_size(gdk_display_get_default());\n+\n+    jclass jc = env->FindClass(\"com\/sun\/glass\/ui\/Size\");\n+    if (env->ExceptionCheck()) return NULL;\n+    jobject jo =  env->NewObject(\n+            jc,\n+            jSizeInit,\n+            size,\n+            size);\n+    EXCEPTION_OCCURED(env);\n+    return jo;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/GlassCursor.cpp","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/GlassDnDClipboard.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassDnDClipboard.cpp","status":"copied"},{"patch":"","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/GlassPixels.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassPixels.cpp","status":"copied"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <X11\/Xlib.h>\n+#include <X11\/Xutil.h>\n+#include <X11\/extensions\/XTest.h>\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <math.h>\n+#include <gdk\/gdk.h>\n+#include <gdk\/gdkx.h>\n+\n+#include <com_sun_glass_ui_GlassRobot.h>\n+#include <com_sun_glass_ui_gtk_GtkRobot.h>\n+#include <com_sun_glass_events_MouseEvent.h>\n+#include \"glass_general.h\"\n+#include \"glass_key.h\"\n+#include \"glass_screen.h\"\n+\n+#define MOUSE_BACK_BTN 8\n+#define MOUSE_FORWARD_BTN 9\n+\n+static void checkXTest(JNIEnv* env) {\n+    int32_t major_opcode, first_event, first_error;\n+    int32_t  event_basep, error_basep, majorp, minorp;\n+    static int32_t isXTestAvailable;\n+    static gboolean checkDone = FALSE;\n+    if (!checkDone) {\n+        \/* check if XTest is available *\/\n+        isXTestAvailable = XQueryExtension(gdk_x11_get_default_xdisplay(), XTestExtensionName, &major_opcode, &first_event, &first_error);\n+        if (isXTestAvailable) {\n+            \/* check if XTest version is OK *\/\n+            XTestQueryExtension(gdk_x11_get_default_xdisplay(), &event_basep, &error_basep, &majorp, &minorp);\n+            if (majorp < 2 || (majorp == 2 && minorp < 2)) {\n+                    isXTestAvailable = False;\n+            } else {\n+                XTestGrabControl(gdk_x11_get_default_xdisplay(), True);\n+            }\n+        }\n+        checkDone = TRUE;\n+    }\n+    if (!isXTestAvailable) {\n+        jclass cls = env->FindClass(\"java\/lang\/UnsupportedOperationException\");\n+        if (env->ExceptionCheck()) return;\n+        env->ThrowNew(cls, \"Glass Robot needs XTest extension to work\");\n+    }\n+}\n+\n+static void keyButton(jint code, gboolean press)\n+{\n+    Display *xdisplay = gdk_x11_get_default_xdisplay();\n+    gint gdk_keyval = find_gdk_keyval_for_glass_keycode(code);\n+    GdkKeymapKey *keys;\n+    gint n_keys;\n+    if (gdk_keyval == -1) {\n+        return;\n+    }\n+    gdk_keymap_get_entries_for_keyval(gdk_keymap_get_for_display(gdk_x11_lookup_xdisplay(xdisplay)),\n+            gdk_keyval, &keys, &n_keys);\n+    if (n_keys < 1) {\n+        return;\n+    }\n+\n+    XTestFakeKeyEvent(xdisplay,\n+                      keys[0].keycode,\n+                      press ? True : False,\n+                      CurrentTime);\n+    g_free(keys);\n+    XSync(xdisplay, False);\n+}\n+\n+extern \"C\" {\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkRobot\n+ * Method:    _keyPress\n+ * Signature: (I)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkRobot__1keyPress\n+  (JNIEnv *env, jobject obj, jint code)\n+{\n+    (void)obj;\n+\n+    checkXTest(env);\n+    keyButton(code, TRUE);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkRobot\n+ * Method:    _keyRelease\n+ * Signature: (I)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkRobot__1keyRelease\n+  (JNIEnv *env, jobject obj, jint code)\n+{\n+    (void)obj;\n+\n+    checkXTest(env);\n+    keyButton(code, FALSE);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkRobot\n+ * Method:    _mouseMove\n+ * Signature: (II)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkRobot__1mouseMove\n+  (JNIEnv *env, jobject obj, jint x, jint y)\n+{\n+    (void)obj;\n+\n+    Display *xdisplay = gdk_x11_get_default_xdisplay();\n+    checkXTest(env);\n+    jfloat uiScale = getUIScale();\n+    x = rint(x * uiScale);\n+    y = rint(y * uiScale);\n+\n+    \/\/-1 means current is current screen\n+    XTestFakeMotionEvent(xdisplay, -1, x, y, CurrentTime);\n+    XSync(xdisplay, False);\n+}\n+\n+static void mouseButtons(jint buttons, gboolean press)\n+{\n+    Display *xdisplay = gdk_x11_get_default_xdisplay();\n+    if (buttons & com_sun_glass_ui_GlassRobot_MOUSE_LEFT_BTN) {\n+        XTestFakeButtonEvent(xdisplay, 1, press, CurrentTime);\n+    }\n+    if (buttons & com_sun_glass_ui_GlassRobot_MOUSE_MIDDLE_BTN) {\n+        XTestFakeButtonEvent(xdisplay, 2, press, CurrentTime);\n+    }\n+    if (buttons & com_sun_glass_ui_GlassRobot_MOUSE_RIGHT_BTN) {\n+        XTestFakeButtonEvent(xdisplay, 3, press, CurrentTime);\n+    }\n+    if (buttons & com_sun_glass_ui_GlassRobot_MOUSE_BACK_BTN) {\n+        XTestFakeButtonEvent(xdisplay, MOUSE_BACK_BTN, press, CurrentTime);\n+    }\n+    if (buttons & com_sun_glass_ui_GlassRobot_MOUSE_FORWARD_BTN) {\n+        XTestFakeButtonEvent(xdisplay, MOUSE_FORWARD_BTN, press, CurrentTime);\n+    }\n+\n+    XSync(xdisplay, False);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkRobot\n+ * Method:    _mousePress\n+ * Signature: (I)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkRobot__1mousePress\n+  (JNIEnv *env, jobject obj, jint buttons)\n+{\n+    (void)obj;\n+\n+    checkXTest(env);\n+    mouseButtons(buttons, TRUE);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkRobot\n+ * Method:    _mouseRelease\n+ * Signature: (I)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkRobot__1mouseRelease\n+  (JNIEnv *env, jobject obj, jint buttons)\n+{\n+    (void)obj;\n+\n+    checkXTest(env);\n+    mouseButtons(buttons, FALSE);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkRobot\n+ * Method:    _mouseWheel\n+ * Signature: (I)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkRobot__1mouseWheel\n+  (JNIEnv *env, jobject obj, jint amt)\n+{\n+    (void)obj;\n+\n+    Display *xdisplay = gdk_x11_get_default_xdisplay();\n+    int repeat = abs(amt);\n+    int button = amt < 0 ? 4 : 5;\n+    int i;\n+\n+    checkXTest(env);\n+    for (i = 0; i < repeat; i++) {\n+        XTestFakeButtonEvent(xdisplay, button, True, CurrentTime);\n+        XTestFakeButtonEvent(xdisplay, button, False, CurrentTime);\n+    }\n+    XSync(xdisplay, False);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkRobot\n+ * Method:    _getMouseX\n+ * Signature: ()I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkRobot__1getMouseX\n+  (JNIEnv *env, jobject obj)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    jint x;\n+    glass_gdk_display_get_pointer(gdk_display_get_default(), &x, NULL);\n+    x = rint(x \/ getUIScale());\n+    return x;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkRobot\n+ * Method:    _getMouseY\n+ * Signature: ()I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkRobot__1getMouseY\n+  (JNIEnv *env, jobject obj)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    jint y;\n+    glass_gdk_display_get_pointer(gdk_display_get_default(), NULL, &y);\n+    y = rint(y \/ getUIScale());\n+    return y;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkRobot\n+ * Method:    _getScreenCapture\n+ * Signature: (IIII[I)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkRobot__1getScreenCapture\n+  (JNIEnv * env, jobject obj, jint x, jint y, jint width, jint height, jintArray data)\n+{\n+    (void)obj;\n+\n+    GdkPixbuf *screenshot, *tmp;\n+    GdkWindow *root_window = gdk_get_default_root_window();\n+\n+    tmp = glass_pixbuf_from_window(root_window, x, y, width, height);\n+    screenshot = gdk_pixbuf_add_alpha(tmp, FALSE, 0, 0, 0);\n+    g_object_unref(tmp);\n+\n+    jint *pixels = (jint *)convert_BGRA_to_RGBA((int*)gdk_pixbuf_get_pixels(screenshot), width * 4, height);\n+    env->SetIntArrayRegion(data, 0, height * width, pixels);\n+    g_free(pixels);\n+\n+    g_object_unref(screenshot);\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/GlassRobot.cpp","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"},{"patch":"","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/GlassSystemClipboard.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassSystemClipboard.cpp","status":"copied"},{"patch":"","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/GlassTimer.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassTimer.cpp","status":"copied"},{"patch":"@@ -0,0 +1,285 @@\n+\/*\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <com_sun_glass_ui_gtk_GtkView.h>\n+#include <com_sun_glass_events_ViewEvent.h>\n+\n+#include <cstdlib>\n+#include <cstring>\n+#include <cassert>\n+\n+#include \"glass_general.h\"\n+#include \"glass_view.h\"\n+#include \"glass_window.h\"\n+\n+#define JLONG_TO_GLASSVIEW(value) ((GlassView *) JLONG_TO_PTR(value))\n+\n+extern \"C\" {\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkView\n+ * Method:    _enableInputMethodEvents\n+ * Signature: (JZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkView_enableInputMethodEventsImpl\n+  (JNIEnv * env, jobject obj, jlong ptr, jboolean enable)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    GlassView* view = JLONG_TO_GLASSVIEW(ptr);\n+    if (view->current_window) {\n+        if (enable) {\n+            view->current_window->enableOrResetIME();\n+        } else {\n+            view->current_window->disableIME();\n+        }\n+    }\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkView\n+ * Method:    _create\n+ * Signature: (Ljava\/util\/Map;)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_gtk_GtkView__1create\n+  (JNIEnv * env, jobject obj, jobject caps)\n+{\n+    (void)env;\n+    (void)obj;\n+    (void)caps;\n+\n+    GlassView *view = new GlassView();\n+    return PTR_TO_JLONG(view);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkView\n+ * Method:    _getNativeView\n+ * Signature: (J)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_gtk_GtkView__1getNativeView\n+  (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    (void)env;\n+    (void)obj;\n+    (void)ptr;\n+\n+    return 0;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkView\n+ * Method:    _getX\n+ * Signature: (J)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkView__1getX\n+  (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    GlassView* view = JLONG_TO_GLASSVIEW(ptr);\n+    if (view && view->current_window) {\n+        return view->current_window->get_geometry().view_x;\n+    }\n+    return 0;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkView\n+ * Method:    _getY\n+ * Signature: (J)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkView__1getY\n+  (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    GlassView* view = JLONG_TO_GLASSVIEW(ptr);\n+    if (view && view->current_window) {\n+        return view->current_window->get_geometry().view_y;\n+    }\n+    return 0;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkView\n+ * Method:    _setParent\n+ * Signature: (JJ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkView__1setParent\n+  (JNIEnv * env, jobject obj, jlong ptr, jlong parent)\n+{\n+    GlassView* view = JLONG_TO_GLASSVIEW(ptr);\n+    bool is_removing = view->current_window && !parent;\n+\n+    view->current_window = (WindowContext*)JLONG_TO_PTR(parent);\n+\n+    if (is_removing) {\n+        env->CallVoidMethod(obj, jViewNotifyView, com_sun_glass_events_ViewEvent_REMOVE);\n+    } else {\n+        env->CallVoidMethod(obj, jViewNotifyView, com_sun_glass_events_ViewEvent_ADD);\n+    }\n+    CHECK_JNI_EXCEPTION(env);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkView\n+ * Method:    _close\n+ * Signature: (J)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkView__1close\n+  (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    delete JLONG_TO_GLASSVIEW(ptr);\n+    return JNI_TRUE;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkView\n+ * Method:    _scheduleRepaint\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkView__1scheduleRepaint\n+  (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    \/\/ Seems to be unused\n+    (void)env;\n+    (void)obj;\n+    (void)ptr;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkView\n+ * Method:    _uploadPixelsDirect\n+ * Signature: (JLjava\/nio\/Buffer;II)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkView__1uploadPixelsDirect\n+(JNIEnv *env, jobject jView, jlong ptr, jobject buffer, jint width, jint height)\n+{\n+    (void)jView;\n+\n+    GlassView* view = JLONG_TO_GLASSVIEW(ptr);\n+    if (view->current_window) {\n+        void *data = env->GetDirectBufferAddress(buffer);\n+\n+        view->current_window->paint(data, width, height);\n+    }\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkView\n+ * Method:    _uploadPixelsIntArray\n+ * Signature:  (J[IIII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkView__1uploadPixelsIntArray\n+  (JNIEnv * env, jobject obj, jlong ptr, jintArray array, jint offset, jint width, jint height)\n+{\n+    (void)obj;\n+\n+    GlassView* view = JLONG_TO_GLASSVIEW(ptr);\n+    if (view->current_window) {\n+        int *data = NULL;\n+        assert((width*height + offset) == env->GetArrayLength(array));\n+        data = (int*)env->GetPrimitiveArrayCritical(array, 0);\n+\n+        view->current_window->paint(data + offset, width, height);\n+\n+        env->ReleasePrimitiveArrayCritical(array, data, JNI_ABORT);\n+    }\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkView\n+ * Method:    _uploadPixelsByteArray\n+ * Signature:  (J[BIII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkView__1uploadPixelsByteArray\n+  (JNIEnv * env, jobject obj, jlong ptr, jbyteArray array, jint offset, jint width, jint height)\n+{\n+    (void)obj;\n+\n+    GlassView* view = JLONG_TO_GLASSVIEW(ptr);\n+    if (view->current_window) {\n+        unsigned char *data = NULL;\n+\n+        assert((4*width*height + offset) == env->GetArrayLength(array));\n+        data = (unsigned char*)env->GetPrimitiveArrayCritical(array, 0);\n+\n+        view->current_window->paint(data + offset, width, height);\n+\n+        env->ReleasePrimitiveArrayCritical(array, data, JNI_ABORT);\n+    }\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkView\n+ * Method:    _enterFullscreen\n+ * Signature: (JZZZ)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkView__1enterFullscreen\n+  (JNIEnv * env, jobject obj, jlong ptr, jboolean animate, jboolean keepRation, jboolean hideCursor)\n+{\n+    (void)animate;\n+    (void)keepRation;\n+    (void)hideCursor;\n+\n+    GlassView* view = JLONG_TO_GLASSVIEW(ptr);\n+    if (view->current_window) {\n+        view->current_window->enter_fullscreen();\n+        env->CallVoidMethod(obj, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER);\n+        CHECK_JNI_EXCEPTION_RET(env, JNI_FALSE)\n+    }\n+    return JNI_TRUE;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkView\n+ * Method:    _exitFullscreen\n+ * Signature: (JZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkView__1exitFullscreen\n+  (JNIEnv * env, jobject obj, jlong ptr, jboolean animate)\n+{\n+    (void)animate;\n+\n+    GlassView* view = JLONG_TO_GLASSVIEW(ptr);\n+    if (view->current_window) {\n+        if (view->embedded_window) {\n+            view->embedded_window->exit_fullscreen();\n+        } else {\n+            view->current_window->exit_fullscreen();\n+        }\n+        env->CallVoidMethod(obj, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT);\n+        CHECK_JNI_EXCEPTION(env)\n+    }\n+\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/GlassView.cpp","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"},{"patch":"@@ -0,0 +1,617 @@\n+\/*\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <com_sun_glass_ui_gtk_GtkWindow.h>\n+#include <com_sun_glass_events_WindowEvent.h>\n+#include <com_sun_glass_events_ViewEvent.h>\n+\n+#include <cstdlib>\n+#include <cstring>\n+#include \"glass_general.h\"\n+#include \"glass_evloop.h\"\n+#include \"glass_window.h\"\n+\n+#define JLONG_TO_WINDOW_CTX(ptr) ((WindowContext*)JLONG_TO_PTR(ptr))\n+\n+static WindowFrameType glass_mask_to_window_frame_type(jint mask) {\n+    if (mask & com_sun_glass_ui_gtk_GtkWindow_TRANSPARENT) {\n+        return TRANSPARENT;\n+    }\n+    if (mask & com_sun_glass_ui_gtk_GtkWindow_TITLED) {\n+        return TITLED;\n+    }\n+    return UNTITLED;\n+}\n+\n+static WindowType glass_mask_to_window_type(jint mask) {\n+    if (mask & com_sun_glass_ui_gtk_GtkWindow_POPUP) {\n+        return POPUP;\n+    }\n+    if (mask & com_sun_glass_ui_gtk_GtkWindow_UTILITY) {\n+        return UTILITY;\n+    }\n+    return NORMAL;\n+}\n+\n+static GdkWMFunction glass_mask_to_wm_function(jint mask) {\n+    int func = GDK_FUNC_RESIZE | GDK_FUNC_MOVE;\n+\n+    if (mask & com_sun_glass_ui_gtk_GtkWindow_CLOSABLE) {\n+        func |= GDK_FUNC_CLOSE;\n+    }\n+    if (mask & com_sun_glass_ui_gtk_GtkWindow_MAXIMIZABLE) {\n+        func |= GDK_FUNC_MAXIMIZE;\n+    }\n+    if (mask & com_sun_glass_ui_gtk_GtkWindow_MINIMIZABLE) {\n+        func |= GDK_FUNC_MINIMIZE;\n+    }\n+\n+    return (GdkWMFunction) func;\n+}\n+\n+extern \"C\" {\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _createWindow\n+ * Signature: (JJI)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1createWindow\n+  (JNIEnv * env, jobject obj, jlong owner, jlong screen, jint mask)\n+{\n+    (void)env;\n+\n+    WindowContext* parent = JLONG_TO_WINDOW_CTX(owner);\n+\n+    WindowContext* ctx = new WindowContext(obj,\n+            parent,\n+            screen,\n+            glass_mask_to_window_frame_type(mask),\n+            glass_mask_to_window_type(mask),\n+            glass_mask_to_wm_function(mask)\n+            );\n+\n+    return PTR_TO_JLONG(ctx);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _createChildWindow\n+ * Signature: (J)J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1createChildWindow\n+  (JNIEnv * env, jobject obj , jlong owner)\n+{\n+    (void)env;\n+\n+    return 0;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _close\n+ * Signature: (J)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1close\n+  (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    destroy_and_delete_ctx(ctx);\n+    return JNI_TRUE; \/\/ return value not used\n+}\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setView\n+ * Signature: (JLcom\/sun\/glass\/ui\/View;)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setView\n+  (JNIEnv * env, jobject obj, jlong ptr, jobject view)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    return (ctx->set_view(view)) ? JNI_TRUE : JNI_FALSE;\n+}\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _showOrHideChildren\n+ * Signature: (JZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1showOrHideChildren\n+  (JNIEnv *env, jobject obj, jlong ptr, jboolean show)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->show_or_hide_children(show);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    minimizeImpl\n+ * Signature: (JZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow_minimizeImpl\n+  (JNIEnv * env, jobject obj, jlong ptr, jboolean minimize)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_minimized(minimize);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    maximizeImpl\n+ * Signature: (JZZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow_maximizeImpl\n+  (JNIEnv * env, jobject obj, jlong ptr, jboolean maximize, jboolean wasMaximized)\n+{\n+    (void)env;\n+    (void)obj;\n+    (void)wasMaximized;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_maximized(maximize);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    setBoundsImpl\n+ * Signature: (JIIZZIIII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow_setBoundsImpl\n+  (JNIEnv * env, jobject obj, jlong ptr, jint x, jint y, jboolean xSet, jboolean ySet, jint w, jint h, jint cw, jint ch)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_bounds(x, y, xSet, ySet, w, h, cw, ch);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    setVisibleImpl\n+ * Signature: (JZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow_setVisibleImpl\n+    (JNIEnv * env, jobject obj, jlong ptr, jboolean visible)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_visible(visible);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setResizable\n+ * Signature: (JZ)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setResizable\n+  (JNIEnv * env, jobject obj, jlong ptr, jboolean resizable)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_resizable(resizable);\n+    return JNI_TRUE;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _requestFocus\n+ * Signature: (JI)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1requestFocus\n+  (JNIEnv * env, jobject obj, jlong ptr, jint focus)\n+{\n+    (void)env;\n+    (void)obj;\n+    (void)focus;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->request_focus();\n+    return JNI_TRUE; \/\/not used\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setFocusable\n+ * Signature: (JZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setFocusable\n+  (JNIEnv * env, jobject obj, jlong ptr, jboolean focusable)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_focusable(focusable);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _grabFocus\n+ * Signature: (J)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1grabFocus\n+  (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    return ctx->grab_focus();\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _ungrabFocus\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1ungrabFocus\n+  (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->ungrab_focus();\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setTitle\n+ * Signature: (JLjava\/lang\/String;)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setTitle\n+  (JNIEnv * env, jobject obj, jlong ptr, jstring title)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    const char* ctitle = mainEnv->GetStringUTFChars(title, NULL);\n+    ctx->set_title(ctitle);\n+    mainEnv->ReleaseStringUTFChars(title, ctitle);\n+\n+    return JNI_TRUE;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setLevel\n+ * Signature: (JI)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setLevel\n+  (JNIEnv * env, jobject obj, jlong ptr, jint level)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_level(level);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setAlpha\n+ * Signature: (JF)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setAlpha\n+  (JNIEnv * env, jobject obj, jlong ptr, jfloat alpha)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_alpha(alpha);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setBackground\n+ * Signature: (JFFF)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setBackground\n+  (JNIEnv * env, jobject obj, jlong ptr, jfloat r, jfloat g, jfloat b)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_background(r, g, b);\n+    return JNI_TRUE;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setEnabled\n+ * Signature: (JZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setEnabled\n+  (JNIEnv * env, jobject obj, jlong ptr, jboolean enabled)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_enabled(enabled);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setMinimumSize\n+ * Signature: (JII)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setMinimumSize\n+  (JNIEnv * env, jobject obj, jlong ptr, jint w, jint h)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    if (w < 0 || h < 0) return JNI_FALSE;\n+    ctx->set_minimum_size(w, h);\n+    return JNI_TRUE;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setMaximumSize\n+ * Signature: (JII)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setMaximumSize\n+  (JNIEnv * env, jobject obj, jlong ptr, jint w, jint h)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    if (w == 0 || h == 0) return JNI_FALSE;\n+\n+    ctx->set_maximum_size(w, h);\n+    return JNI_TRUE;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setIcon\n+ * Signature: (JLcom\/sun\/glass\/ui\/Pixels;)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setIcon\n+  (JNIEnv * env, jobject obj, jlong ptr, jobject pixels)\n+{\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    GdkPixbuf *pixbuf = NULL;\n+    if (pixels != NULL) {\n+        env->CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&pixbuf));\n+    }\n+    if (!EXCEPTION_OCCURED(env)) {\n+        ctx->set_icon(pixbuf);\n+    }\n+    if (pixbuf != NULL) g_object_unref(pixbuf);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _toFront\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1toFront\n+  (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->restack(true);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _toBack\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1toBack\n+  (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->restack(false);\n+\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _enterModal\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1enterModal\n+  (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_modal(true);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _enterModalWithWindow\n+ * Signature: (JJ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1enterModalWithWindow\n+  (JNIEnv * env, jobject obj, jlong ptrDialog, jlong ptrWindow)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptrDialog);\n+    WindowContext* parent_ctx = JLONG_TO_WINDOW_CTX(ptrWindow);\n+    ctx->set_modal(true, parent_ctx);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _exitModal\n+ * Signature: (J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1exitModal\n+  (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_modal(false);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkCursor\n+ * Method:    _setCursorType\n+ * Signature: (JI)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setCursorType\n+  (JNIEnv * env, jobject obj, jlong ptr, jint type)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    GdkCursor *cursor = get_native_cursor(type);\n+    ctx->set_cursor(cursor);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkCursor\n+ * Method:    _setCustomCursor\n+ * Signature: (JLcom\/sun\/glass\/ui\/Cursor;)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setCustomCursor\n+  (JNIEnv * env, jobject obj, jlong ptr, jobject jCursor)\n+{\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    GdkCursor *cursor = (GdkCursor*)JLONG_TO_PTR(env->GetLongField(jCursor, jCursorPtr));\n+\n+    ctx->set_cursor(cursor);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    isVisible\n+ * Signature: (J)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkWindow_isVisible\n+    (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    return ctx->is_visible() ? JNI_TRUE : JNI_FALSE;\n+}\n+JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1getNativeWindowImpl\n+    (JNIEnv * env, jobject obj, jlong ptr)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    return GDK_WINDOW_XID(ctx->get_gdk_window());\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setGravity\n+ * Signature: (JFF)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setGravity\n+    (JNIEnv * env, jobject obj, jlong ptr, jfloat xGravity, jfloat yGravity)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_gravity(xGravity, yGravity);\n+\n+}\n+\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _getEmbeddedX\n+ * Signature: (J)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1getEmbeddedX\n+  (JNIEnv *env, jobject obj, jlong ptr) {\n+    (void)env;\n+    (void)obj;\n+\n+    return 0;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _getEmbeddedY\n+ * Signature: (J)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1getEmbeddedY\n+  (JNIEnv *env, jobject obj, jlong ptr) {\n+    (void)env;\n+    (void)obj;\n+\n+    return 0;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    getFrameExtents\n+ * Signature: (J[I)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow_getFrameExtents\n+    (JNIEnv * env, jobject obj, jlong ptr, jintArray extarr)\n+{\n+    (void)obj;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/GlassWindow.cpp","additions":617,"deletions":0,"binary":false,"changes":617,"status":"added"},{"patch":"@@ -0,0 +1,953 @@\n+\/*\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"glass_dnd.h\"\n+#include \"glass_general.h\"\n+#include \"glass_evloop.h\"\n+\n+#include \"com_sun_glass_events_DndEvent.h\"\n+#include \"com_sun_glass_ui_gtk_GtkDnDClipboard.h\"\n+\n+#include <jni.h>\n+#include <cstring>\n+\n+#include <gtk\/gtk.h>\n+#include <gdk\/gdkx.h>\n+#include <gdk\/gdkkeysyms.h>\n+\n+\/************************* COMMON *********************************************\/\n+static jint translate_gdk_action_to_glass(GdkDragAction action) {\n+    jint result = 0;\n+    result |= (action & GDK_ACTION_COPY) ? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY : 0;\n+    result |= (action & GDK_ACTION_MOVE) ? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE : 0;\n+    result |= (action & GDK_ACTION_LINK) ? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE : 0;\n+    return result;\n+}\n+\n+static GdkDragAction translate_glass_action_to_gdk(jint action) {\n+    int result = 0;\n+    result |= (action & com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY) ? GDK_ACTION_COPY : 0;\n+    result |= (action & com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE) ? GDK_ACTION_MOVE : 0;\n+    result |= (action & com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE) ? GDK_ACTION_LINK : 0;\n+    return static_cast<GdkDragAction>(result);\n+}\n+\n+static void clear_global_ref(gpointer data) {\n+    mainEnv->DeleteGlobalRef((jobject) data);\n+}\n+\n+static void dnd_set_performed_action(jint performed_action);\n+\n+static jint dnd_get_performed_action();\n+\n+enum {\n+    TARGET_TEXT,\n+    TARGET_IMAGE,\n+    TARGET_URI,\n+    TARGET_RAW\n+};\n+\n+\/************************* TARGET *********************************************\/\n+\n+static struct {\n+    GdkDragContext *ctx;\n+    GtkSelectionData *data;\n+    gboolean just_entered;\n+    jobjectArray mimes;\n+} target_ctx = {NULL, NULL, FALSE, NULL};\n+\n+gboolean is_dnd_owner = FALSE;\n+GtkWidget *drag_widget = NULL;\n+\n+gboolean is_in_drag() {\n+    return drag_widget != NULL;\n+}\n+\n+static void reset_target_ctx() {\n+    if (target_ctx.mimes != NULL) {\n+        mainEnv->DeleteGlobalRef(target_ctx.mimes);\n+    }\n+\n+    memset(&target_ctx, 0, sizeof(target_ctx));\n+}\n+\n+static gboolean dnd_drag_motion_callback(GtkWidget *widget,\n+                                         GdkDragContext *context,\n+                                         gint x,\n+                                         gint y,\n+                                         guint time,\n+                                         gpointer user_data) {\n+\n+    WindowContext *ctx = (WindowContext *) user_data;\n+\n+    if (target_ctx.ctx == NULL || (target_ctx.ctx != context && !target_ctx.just_entered)) {\n+        reset_target_ctx();\n+        is_dnd_owner = is_in_drag();\n+        target_ctx.ctx = context;\n+        target_ctx.just_entered = TRUE;\n+    }\n+\n+    gint x_abs, y_abs;\n+    gdk_window_get_origin(gdk_drag_context_get_dest_window(context), &x_abs, &y_abs);\n+\n+    jmethodID method = target_ctx.just_entered ? jViewNotifyDragEnter : jViewNotifyDragOver;\n+\n+    GdkDragAction suggested = gdk_drag_context_get_suggested_action(context);\n+    GdkDragAction result = translate_glass_action_to_gdk(mainEnv->CallIntMethod(ctx->get_jview(), method,\n+                                                                                (jint) x, (jint) y,\n+                                                                                (jint) x_abs, (jint) y_abs,\n+                                                                                translate_gdk_action_to_glass(\n+                                                                                        suggested)));\n+    CHECK_JNI_EXCEPTION_RET(mainEnv, FALSE)\n+\n+    if (target_ctx.just_entered) {\n+        target_ctx.just_entered = FALSE;\n+    }\n+\n+    gdk_drag_status(context, result, GDK_CURRENT_TIME);\n+\n+    return (gboolean) result;\n+}\n+\n+static gboolean dnd_drag_drop_callback(GtkWidget *widget,\n+                                       GdkDragContext *context,\n+                                       gint x,\n+                                       gint y,\n+                                       guint time,\n+                                       gpointer user_data) {\n+    if (target_ctx.ctx == NULL || target_ctx.just_entered) {\n+        return FALSE; \/\/ Do not process drop events if no enter event and subsequent motion event were received\n+    }\n+\n+    GdkAtom target = gtk_drag_dest_find_target(widget, context, NULL);\n+\n+    if (target == GDK_NONE) {\n+        \/\/ used for RAW\n+        target = gdk_atom_intern_static_string(\"\");\n+    }\n+\n+    gtk_drag_get_data(widget, context, target, GDK_CURRENT_TIME);\n+\n+    return TRUE;\n+}\n+\n+static void dnd_on_drag_data_received_callback(GtkWidget *widget,\n+                                               GdkDragContext *context,\n+                                               gint x,\n+                                               gint y,\n+                                               GtkSelectionData *data,\n+                                               guint info,\n+                                               guint time,\n+                                               gpointer user_data) {\n+    WindowContext *ctx = (WindowContext *) user_data;\n+\n+    if (gtk_selection_data_get_length(data) == 0) {\n+        gtk_drag_finish(context, FALSE, FALSE, GDK_CURRENT_TIME);\n+        reset_target_ctx();\n+        return;\n+    }\n+\n+    gint x_abs, y_abs;\n+    gdk_window_get_origin(gdk_drag_context_get_dest_window(context), &x_abs, &y_abs);\n+    GdkDragAction selected = gdk_drag_context_get_selected_action(context);\n+    target_ctx.data = data;\n+\n+    \/\/ Delay the notify for when we have the data\n+    mainEnv->CallIntMethod(ctx->get_jview(), jViewNotifyDragDrop,\n+                           (jint) x, (jint) y,\n+                           (jint) x_abs, (jint) y_abs,\n+                           translate_gdk_action_to_glass(selected));\n+    LOG_EXCEPTION(mainEnv)\n+\n+    gtk_drag_finish(context, selected, selected == GDK_ACTION_MOVE, GDK_CURRENT_TIME);\n+}\n+\n+void dnd_drag_leave_callback(WindowContext *ctx) {\n+    mainEnv->CallVoidMethod(ctx->get_jview(), jViewNotifyDragLeave, NULL);\n+    CHECK_JNI_EXCEPTION(mainEnv)\n+\n+    reset_target_ctx();\n+}\n+\n+void glass_dnd_attach_context(WindowContext *ctx) {\n+    gtk_drag_dest_set(ctx->get_gtk_widget(), (GtkDestDefaults) 0, NULL, 0,\n+                      (GdkDragAction)(GDK_ACTION_COPY | GDK_ACTION_MOVE | GDK_ACTION_LINK));\n+\n+    GtkTargetList *target_list = gtk_target_list_new(NULL, 0);\n+    gtk_target_list_add_image_targets(target_list, TARGET_IMAGE, TRUE);\n+    gtk_target_list_add_uri_targets(target_list, TARGET_URI);\n+    gtk_target_list_add_text_targets(target_list, TARGET_TEXT);\n+    gtk_target_list_add(target_list, gdk_atom_intern_static_string(\"\"), 0, TARGET_RAW);\n+\n+    gtk_drag_dest_set_target_list(ctx->get_gtk_widget(), target_list);\n+\n+    g_signal_connect(ctx->get_gtk_widget(), \"drag-motion\", G_CALLBACK(dnd_drag_motion_callback), ctx);\n+    g_signal_connect(ctx->get_gtk_widget(), \"drag-drop\", G_CALLBACK(dnd_drag_drop_callback), ctx);\n+    g_signal_connect(ctx->get_gtk_widget(), \"drag-data-received\", G_CALLBACK(dnd_on_drag_data_received_callback), ctx);\n+}\n+\n+static gboolean check_state_in_drag(JNIEnv *env) {\n+    if (!target_ctx.ctx) {\n+        jclass jc = env->FindClass(\"java\/lang\/IllegalStateException\");\n+        if (!env->ExceptionCheck()) {\n+            env->ThrowNew(jc,\n+                          \"Cannot get supported actions. Drag pointer haven't entered the application window\");\n+        }\n+        return TRUE;\n+    }\n+    return FALSE;\n+}\n+\n+static GdkAtom *get_target_ctx_target_atoms(gint *size) {\n+    GList *targets = gdk_drag_context_list_targets(target_ctx.ctx);\n+    gint s = (gint) g_list_length(targets);\n+    GdkAtom *atoms = (GdkAtom *) g_try_malloc0(sizeof(GdkAtom) * s);\n+\n+    int i = 0;\n+    for (; targets != NULL; targets = targets->next) {\n+        atoms[i++] = (GdkAtom) targets->data;\n+    }\n+\n+    *size = s;\n+\n+    g_list_free(targets);\n+    return atoms;\n+}\n+\n+jobjectArray dnd_target_get_mimes(JNIEnv *env) {\n+    if (check_state_in_drag(env)) {\n+        return NULL;\n+    }\n+\n+    if (!target_ctx.mimes) {\n+        jobject set = env->NewObject(jHashSetCls, jHashSetInit, NULL);\n+        EXCEPTION_OCCURED(env);\n+\n+        gboolean was_set = FALSE;\n+        gint size;\n+        GdkAtom *targets = get_target_ctx_target_atoms(&size);\n+\n+        if (gtk_targets_include_image(targets, size, TRUE)) {\n+            jstring jStr = env->NewStringUTF(\"application\/x-java-rawimage\");\n+            EXCEPTION_OCCURED(env);\n+            env->CallBooleanMethod(set, jSetAdd, jStr, NULL);\n+            EXCEPTION_OCCURED(env);\n+            was_set = TRUE;\n+        }\n+        if (gtk_targets_include_uri(targets, size)) {\n+            \/\/ it's a possibility\n+            jstring jStr = env->NewStringUTF(\"application\/x-java-file-list\");\n+            EXCEPTION_OCCURED(env);\n+            env->CallBooleanMethod(set, jSetAdd, jStr, NULL);\n+            EXCEPTION_OCCURED(env);\n+\n+            jstring jStr2 = env->NewStringUTF(\"text\/uri-list\");\n+            EXCEPTION_OCCURED(env);\n+            env->CallBooleanMethod(set, jSetAdd, jStr2, NULL);\n+            EXCEPTION_OCCURED(env);\n+            was_set = TRUE;\n+        } else if (gtk_targets_include_text(targets, size)) {\n+            jstring jStr = env->NewStringUTF(\"text\/plain\");\n+            EXCEPTION_OCCURED(env);\n+            env->CallBooleanMethod(set, jSetAdd, jStr, NULL);\n+            EXCEPTION_OCCURED(env);\n+            was_set = TRUE;\n+        }\n+\n+        g_free(targets);\n+\n+        if (!was_set) {\n+            GdkAtom target = gtk_selection_data_get_target(target_ctx.data);\n+            gchar *name = gdk_atom_name(target);\n+\n+            jstring jStr = env->NewStringUTF(name);\n+            EXCEPTION_OCCURED(env);\n+            env->CallBooleanMethod(set, jSetAdd, jStr, NULL);\n+            EXCEPTION_OCCURED(env);\n+            g_free(name);\n+        }\n+\n+        target_ctx.mimes = env->NewObjectArray(env->CallIntMethod(set, jSetSize, NULL),\n+                                               jStringCls, NULL);\n+        EXCEPTION_OCCURED(env);\n+        target_ctx.mimes = (jobjectArray) env->CallObjectMethod(set, jSetToArray, target_ctx.mimes, NULL);\n+        target_ctx.mimes = (jobjectArray) env->NewGlobalRef(target_ctx.mimes);\n+    }\n+\n+    return target_ctx.mimes;\n+}\n+\n+jint dnd_target_get_supported_actions(JNIEnv *env) {\n+    if (check_state_in_drag(env)) {\n+        return 0;\n+    }\n+    return translate_gdk_action_to_glass(gdk_drag_context_get_actions(target_ctx.ctx));\n+}\n+\n+static jobject dnd_target_get_string(JNIEnv *env) {\n+    jobject result = NULL;\n+\n+    GdkAtom atom = gtk_selection_data_get_data_type(target_ctx.data);\n+    guchar *data = gtk_selection_data_get_text(target_ctx.data);\n+\n+    if (data) {\n+        result = env->NewStringUTF((char *) data);\n+        EXCEPTION_OCCURED(env);\n+\n+        g_free(data);\n+    }\n+\n+    return result;\n+}\n+\n+static jobject dnd_target_get_list(JNIEnv *env, gboolean files) {\n+    jobject result = NULL;\n+    GdkAtom atom = gtk_selection_data_get_selection(target_ctx.data);\n+    gchar **data = gtk_selection_data_get_uris(target_ctx.data);\n+\n+    if (data) {\n+        result = uris_to_java(env, data, files);\n+        \/\/ uris_to_java frees it\n+        \/\/g_strfreev(data);\n+    }\n+\n+    return result;\n+}\n+\n+static jobject dnd_target_get_image(JNIEnv *env) {\n+    jobject result = NULL;\n+\n+    GdkAtom atom = gtk_selection_data_get_selection(target_ctx.data);\n+    GdkPixbuf *buf = gtk_selection_data_get_pixbuf(target_ctx.data);\n+\n+    if (buf == NULL) {\n+        return NULL;\n+    }\n+\n+    gint length = gtk_selection_data_get_length(target_ctx.data);\n+\n+    if (!gdk_pixbuf_get_has_alpha(buf)) {\n+        GdkPixbuf *tmp_buf = gdk_pixbuf_add_alpha(buf, FALSE, 0, 0, 0);\n+        g_object_unref(buf);\n+        buf = tmp_buf;\n+    }\n+\n+    gint w, h, stride;\n+    guchar *cdata;\n+    jbyteArray data_array;\n+    jobject buffer;\n+\n+    w = gdk_pixbuf_get_width(buf);\n+    h = gdk_pixbuf_get_height(buf);\n+    stride = gdk_pixbuf_get_rowstride(buf);\n+\n+    cdata = gdk_pixbuf_get_pixels(buf);\n+\n+    \/\/Actually, we are converting RGBA to BGRA, but that's the same operation\n+    cdata = (guchar *) convert_BGRA_to_RGBA((int *) cdata, stride, h);\n+    data_array = env->NewByteArray(stride * h);\n+    EXCEPTION_OCCURED(env);\n+    env->SetByteArrayRegion(data_array, 0, stride * h, (jbyte *) cdata);\n+    EXCEPTION_OCCURED(env);\n+\n+    buffer = env->CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, data_array);\n+    EXCEPTION_OCCURED(env);\n+    result = env->NewObject(jGtkPixelsCls, jGtkPixelsInit, w, h, buffer);\n+    EXCEPTION_OCCURED(env);\n+\n+    g_object_unref(buf);\n+    g_free(cdata);\n+\n+    return result;\n+}\n+\n+static jobject dnd_target_get_raw(JNIEnv *env, GdkAtom target, gboolean string_data) {\n+    jobject result = NULL;\n+    GdkAtom atom = gtk_selection_data_get_selection(target_ctx.data);\n+    const guchar *data = gtk_selection_data_get_data(target_ctx.data);\n+\n+    if (string_data) {\n+        result = env->NewStringUTF((char *) data);\n+        EXCEPTION_OCCURED(env);\n+    } else {\n+        gint length = gtk_selection_data_get_length(target_ctx.data);\n+\n+        jbyteArray array = env->NewByteArray((jsize) length);\n+        EXCEPTION_OCCURED(env);\n+        env->SetByteArrayRegion(array, 0, length, (const jbyte *) data);\n+        EXCEPTION_OCCURED(env);\n+        result = env->CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, array);\n+        EXCEPTION_OCCURED(env);\n+    }\n+\n+    return result;\n+}\n+\n+jobject dnd_target_get_data(JNIEnv *env, jstring mime) {\n+    jobject ret = NULL;\n+\n+    if (check_state_in_drag(env)) {\n+        return NULL;\n+    }\n+\n+    const char *cmime = env->GetStringUTFChars(mime, NULL);\n+\n+    if (g_strcmp0(cmime, \"text\/plain\") == 0) {\n+        ret = dnd_target_get_string(env);\n+    } else if (g_strcmp0(cmime, \"text\/uri-list\") == 0) {\n+        ret = dnd_target_get_list(env, FALSE);\n+    } else if (g_str_has_prefix(cmime, \"text\/\")) {\n+        ret = dnd_target_get_raw(env, gdk_atom_intern(cmime, FALSE), TRUE);\n+    } else if (g_strcmp0(cmime, \"application\/x-java-file-list\") == 0) {\n+        ret = dnd_target_get_list(env, TRUE);\n+    } else if (g_strcmp0(cmime, \"application\/x-java-rawimage\") == 0) {\n+        ret = dnd_target_get_image(env);\n+    } else {\n+        ret = dnd_target_get_raw(env, gdk_atom_intern(cmime, FALSE), FALSE);\n+    }\n+\n+    LOG_EXCEPTION(env)\n+    env->ReleaseStringUTFChars(mime, cmime);\n+\n+    return ret;\n+}\n+\n+\/************************* SOURCE *********************************************\/\n+\n+static jint dnd_performed_action;\n+\n+const char *const SOURCE_DND_DATA = \"fx-dnd-data\";\n+\n+static void dnd_set_performed_action(jint performed_action) {\n+    dnd_performed_action = performed_action;\n+}\n+\n+static jint dnd_get_performed_action() {\n+    return dnd_performed_action;\n+}\n+\n+static void pixbufDestroyNotifyFunc(guchar *pixels, gpointer) {\n+    if (pixels != NULL) {\n+        g_free(pixels);\n+    }\n+}\n+\n+static jobject dnd_source_get_data(GtkWidget *widget, const char *key) {\n+    jobject data = (jobject) g_object_get_data(G_OBJECT(widget), SOURCE_DND_DATA);\n+    jstring string = mainEnv->NewStringUTF(key);\n+    EXCEPTION_OCCURED(mainEnv);\n+    jobject result = mainEnv->CallObjectMethod(data, jMapGet, string, NULL);\n+\n+    return (EXCEPTION_OCCURED(mainEnv)) ? NULL : result;\n+}\n+\n+static void add_gtk_target_from_jstring(JNIEnv *env, GtkTargetList **list, jstring string, guint flags) {\n+    const char *gstring = env->GetStringUTFChars(string, NULL);\n+\n+    if (g_strcmp0(gstring, \"text\/plain\") == 0) {\n+        gtk_target_list_add_text_targets(*list, TARGET_TEXT);\n+    } else if (g_strcmp0(gstring, \"application\/x-java-rawimage\") == 0) {\n+        gtk_target_list_add_image_targets(*list, TARGET_IMAGE, TRUE);\n+    } else if (g_strcmp0(gstring, \"application\/x-java-file-list\") == 0) {\n+        gtk_target_list_add_uri_targets(*list, TARGET_URI);\n+    } else if (g_strcmp0(gstring, \"application\/x-java-drag-image\") == 0\n+               || g_strcmp0(gstring, \"application\/x-java-drag-image-offset\") == 0) {\n+        \/\/ do nothing - those are DragView information\n+    } else {\n+        GdkAtom atom = gdk_atom_intern(gstring, FALSE);\n+        gtk_target_list_add(*list, atom, flags, TARGET_RAW);\n+    }\n+\n+    env->ReleaseStringUTFChars(string, gstring);\n+}\n+\n+static GtkTargetList *data_to_gtk_target_list(JNIEnv *env, jobject data) {\n+    guint flags = GTK_TARGET_OTHER_APP | GTK_TARGET_SAME_APP;\n+\n+    jobject keys;\n+    jobject keysIterator;\n+    jstring next;\n+\n+    GtkTargetList *tlist = gtk_target_list_new(NULL, 0);\n+\n+    gint added_count = 0;\n+\n+    keys = env->CallObjectMethod(data, jMapKeySet, NULL);\n+    JNI_EXCEPTION_TO_CPP(env)\n+    keysIterator = env->CallObjectMethod(keys, jIterableIterator, NULL);\n+    JNI_EXCEPTION_TO_CPP(env)\n+    while (env->CallBooleanMethod(keysIterator, jIteratorHasNext) == JNI_TRUE) {\n+        next = (jstring) env->CallObjectMethod(keysIterator, jIteratorNext, NULL);\n+        JNI_EXCEPTION_TO_CPP(env)\n+        add_gtk_target_from_jstring(env, &tlist, next, flags);\n+    }\n+\n+    return tlist;\n+}\n+\n+static gboolean dnd_source_set_string(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom) {\n+    gboolean is_data_set;\n+\n+    jstring string = (jstring) dnd_source_get_data(widget, \"text\/plain\");\n+    if (!string) {\n+        return FALSE;\n+    }\n+\n+    const char *cstring = mainEnv->GetStringUTFChars(string, NULL);\n+    gint size = strlen(cstring);\n+    is_data_set = gtk_selection_data_set_text(data, (gchar *) cstring, size);\n+\n+    mainEnv->ReleaseStringUTFChars(string, cstring);\n+\n+    return is_data_set;\n+}\n+\n+static gboolean dnd_source_set_image(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom) {\n+    jobject pixels = dnd_source_get_data(widget, \"application\/x-java-rawimage\");\n+    if (!pixels) {\n+        g_warning(\"DND source failed to set image\\n\");\n+        return FALSE;\n+    }\n+\n+    gchar *buffer;\n+    gsize size;\n+    const char *type;\n+    GdkPixbuf *pixbuf = NULL;\n+    gboolean is_data_set;\n+\n+    mainEnv->CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&pixbuf));\n+\n+    if (!EXCEPTION_OCCURED(mainEnv)) {\n+        is_data_set = gtk_selection_data_set_pixbuf(data, pixbuf);\n+    }\n+\n+    g_object_unref(pixbuf);\n+\n+    return is_data_set;\n+}\n+\n+static gboolean dnd_source_set_uri(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom) {\n+    const gchar *url = NULL;\n+    jstring jurl = NULL;\n+\n+    jobjectArray files_array = NULL;\n+    gsize files_cnt = 0;\n+\n+    if (jurl = (jstring) dnd_source_get_data(widget, \"text\/uri-list\")) {\n+        url = mainEnv->GetStringUTFChars(jurl, NULL);\n+    }\n+\n+    if (files_array = (jobjectArray) dnd_source_get_data(widget, \"application\/x-java-file-list\")) {\n+        files_cnt = mainEnv->GetArrayLength(files_array);\n+    }\n+\n+    if (!url && !files_cnt) {\n+        return FALSE;\n+    }\n+\n+    gboolean is_data_set;\n+    GString *res = g_string_new(NULL); \/\/http:\/\/www.ietf.org\/rfc\/rfc2483.txt\n+\n+    if (files_cnt > 0) {\n+        for (gsize i = 0; i < files_cnt; ++i) {\n+            jstring string = (jstring) mainEnv->GetObjectArrayElement(files_array, i);\n+            EXCEPTION_OCCURED(mainEnv);\n+            const gchar *file = mainEnv->GetStringUTFChars(string, NULL);\n+            gchar *uri = g_filename_to_uri(file, NULL, NULL);\n+\n+            g_string_append(res, uri);\n+            g_string_append(res, URI_LIST_LINE_BREAK);\n+\n+            g_free(uri);\n+            mainEnv->ReleaseStringUTFChars(string, file);\n+        }\n+    }\n+    if (url) {\n+        g_string_append(res, url);\n+        g_string_append(res, URI_LIST_LINE_BREAK);\n+        mainEnv->ReleaseStringUTFChars(jurl, url);\n+    }\n+\n+    gchar *uri[2];\n+    uri[0] = g_string_free(res, FALSE);\n+    uri[1] = NULL;\n+\n+    is_data_set = gtk_selection_data_set_uris(data, uri);\n+\n+    g_free(uri[0]);\n+\n+    return is_data_set;\n+}\n+\n+static gboolean dnd_source_set_raw(GtkWidget *widget, GtkSelectionData *sel_data, GdkAtom atom) {\n+    gchar *target_name = gdk_atom_name(atom);\n+    jobject data = dnd_source_get_data(widget, target_name);\n+    gboolean is_data_set = FALSE;\n+    if (data) {\n+        if (mainEnv->IsInstanceOf(data, jStringCls)) {\n+            const char *cstring = mainEnv->GetStringUTFChars((jstring) data, NULL);\n+            if (cstring) {\n+                is_data_set = gtk_selection_data_set_text(sel_data, (gchar *) cstring, strlen(cstring));\n+                mainEnv->ReleaseStringUTFChars((jstring) data, cstring);\n+            }\n+        } else if (mainEnv->IsInstanceOf(data, jByteBufferCls)) {\n+            jbyteArray byteArray = (jbyteArray) mainEnv->CallObjectMethod(data, jByteBufferArray);\n+            if (!EXCEPTION_OCCURED(mainEnv)) {\n+                jbyte *raw = mainEnv->GetByteArrayElements(byteArray, NULL);\n+                if (raw) {\n+                    jsize nraw = mainEnv->GetArrayLength(byteArray);\n+                    gtk_selection_data_set(sel_data, atom, 8, (guchar *) raw, nraw);\n+                    mainEnv->ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);\n+                    is_data_set = TRUE;\n+                }\n+            }\n+        }\n+    }\n+\n+    g_free(target_name);\n+    return is_data_set;\n+}\n+\n+static gboolean dnd_destroy_drag_widget_callback(gpointer) {\n+    if (drag_widget) {\n+        gtk_widget_destroy(drag_widget);\n+        drag_widget = NULL;\n+    }\n+\n+    return FALSE;\n+}\n+\n+static void dnd_end_callback(GtkWidget *widget,\n+                             GdkDragContext *context,\n+                             gpointer user_data) {\n+    if (drag_widget) {\n+        GdkDragAction action = gdk_drag_context_get_selected_action(context);\n+        dnd_set_performed_action(translate_gdk_action_to_glass(action));\n+    }\n+    gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);\n+}\n+\n+static gboolean dnd_drag_failed_callback(GtkWidget *widget,\n+                                         GdkDragContext *context,\n+                                         GtkDragResult result,\n+                                         gpointer user_data) {\n+    dnd_set_performed_action(com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_NONE);\n+    gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);\n+\n+    return FALSE;\n+}\n+\n+static void dnd_data_get_callback(GtkWidget *widget,\n+                                  GdkDragContext *context,\n+                                  GtkSelectionData *data,\n+                                  guint info,\n+                                  guint time,\n+                                  gpointer user_data) {\n+    GdkAtom atom = gtk_selection_data_get_target(data);\n+\n+    switch (info) {\n+        case TARGET_TEXT:\n+            dnd_source_set_string(widget, data, atom);\n+            break;\n+        case TARGET_IMAGE:\n+            dnd_source_set_image(widget, data, atom);\n+            break;\n+        case TARGET_URI:\n+            dnd_source_set_uri(widget, data, atom);\n+            break;\n+        default:\n+            dnd_source_set_raw(widget, data, atom);\n+    }\n+}\n+\n+static void dnd_drag_begin_callback(GtkWidget *widget,\n+                                    GdkDragContext *context,\n+                                    gpointer user_data) {\n+    DragView::set_drag_view(widget, context);\n+}\n+\n+static void dnd_source_push_data(JNIEnv *env, jobject data, jint supported) {\n+    if (supported == 0) {\n+        return; \/\/ No supported actions, do nothing\n+    }\n+\n+    data = env->NewGlobalRef(data);\n+\n+    GdkDragAction actions = translate_glass_action_to_gdk(supported);\n+\n+    \/\/ this widget is used only to pass events and will\n+    \/\/ be destroyed on drag end\n+    drag_widget = gtk_invisible_new();\n+    gtk_widget_show(drag_widget);\n+\n+    g_object_set_data_full(G_OBJECT(drag_widget), SOURCE_DND_DATA, data, clear_global_ref);\n+\n+    g_signal_connect(drag_widget, \"drag-begin\",\n+                     G_CALLBACK(dnd_drag_begin_callback), NULL);\n+\n+    g_signal_connect(drag_widget, \"drag-failed\",\n+                     G_CALLBACK(dnd_drag_failed_callback), NULL);\n+\n+    g_signal_connect(drag_widget, \"drag-data-get\",\n+                     G_CALLBACK(dnd_data_get_callback), NULL);\n+\n+    g_signal_connect(drag_widget, \"drag-end\",\n+                     G_CALLBACK(dnd_end_callback), NULL);\n+\n+    GtkTargetList *tlist = data_to_gtk_target_list(env, data);\n+\n+    GdkDragContext *context;\n+\n+    gint x, y;\n+    glass_gdk_master_pointer_get_position(&x, &y);\n+\n+    is_dnd_owner = TRUE;\n+\n+    context = gtk_drag_begin(drag_widget, tlist, actions, 1, NULL);\n+\n+    gtk_target_list_unref(tlist);\n+}\n+\n+jint execute_dnd(JNIEnv *env, jobject data, jint supported) {\n+    try {\n+        dnd_source_push_data(env, data, supported);\n+    } catch (jni_exception &) {\n+        gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);\n+        return com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_NONE;\n+    }\n+\n+    while (is_in_drag()) {\n+        gtk_main_iteration();\n+    }\n+\n+    return dnd_get_performed_action();\n+}\n+\n+\/******************** DRAG VIEW ***************************\/\n+DragView::View *DragView::view = NULL;\n+\n+gboolean DragView::get_drag_image_offset(GtkWidget *widget, int *x, int *y) {\n+    gboolean offset_set = FALSE;\n+    jobject bb = dnd_source_get_data(widget, \"application\/x-java-drag-image-offset\");\n+    if (bb) {\n+        jbyteArray byteArray = (jbyteArray) mainEnv->CallObjectMethod(bb, jByteBufferArray);\n+        if (!EXCEPTION_OCCURED(mainEnv)) {\n+            jbyte *raw = mainEnv->GetByteArrayElements(byteArray, NULL);\n+            jsize nraw = mainEnv->GetArrayLength(byteArray);\n+\n+            if ((size_t) nraw >= sizeof(jint) * 2) {\n+                jint *r = (jint *) raw;\n+                *x = BSWAP_32(r[0]);\n+                *y = BSWAP_32(r[1]);\n+                offset_set = TRUE;\n+            }\n+\n+            mainEnv->ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);\n+        }\n+    }\n+    return offset_set;\n+}\n+\n+GdkPixbuf *DragView::get_drag_image(GtkWidget *widget, gboolean *is_raw_image, gint *width, gint *height) {\n+    GdkPixbuf *pixbuf = NULL;\n+    gboolean is_raw = FALSE;\n+\n+    jobject drag_image = dnd_source_get_data(widget, \"application\/x-java-drag-image\");\n+\n+    if (drag_image) {\n+        jbyteArray byteArray = (jbyteArray) mainEnv->CallObjectMethod(drag_image, jByteBufferArray);\n+        if (!EXCEPTION_OCCURED(mainEnv)) {\n+\n+            jbyte *raw = mainEnv->GetByteArrayElements(byteArray, NULL);\n+            jsize nraw = mainEnv->GetArrayLength(byteArray);\n+\n+            int w = 0, h = 0;\n+            int whsz = sizeof(jint) * 2; \/\/ Pixels are stored right after two ints\n+            \/\/ in this byteArray: width and height\n+            if (nraw > whsz) {\n+                jint *int_raw = (jint *) raw;\n+                w = BSWAP_32(int_raw[0]);\n+                h = BSWAP_32(int_raw[1]);\n+\n+                \/\/ We should have enough pixels for requested width and height\n+                if ((nraw - whsz) \/ 4 - w * h >= 0) {\n+                    guchar *data = (guchar *) g_try_malloc0(nraw - whsz);\n+                    if (data) {\n+                        memcpy(data, (raw + whsz), nraw - whsz);\n+                        pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,\n+                                                          w, h, w * 4, pixbufDestroyNotifyFunc, NULL);\n+                    }\n+                }\n+            }\n+            mainEnv->ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);\n+        }\n+    }\n+\n+    if (!GDK_IS_PIXBUF(pixbuf)) {\n+        jobject pixels = dnd_source_get_data(widget, \"application\/x-java-rawimage\");\n+        if (pixels) {\n+            is_raw = TRUE;\n+            mainEnv->CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&pixbuf));\n+            CHECK_JNI_EXCEPTION_RET(mainEnv, NULL)\n+        }\n+    }\n+\n+    if (!GDK_IS_PIXBUF(pixbuf)) {\n+        return NULL;\n+    }\n+\n+    int w = gdk_pixbuf_get_width(pixbuf);\n+    int h = gdk_pixbuf_get_height(pixbuf);\n+\n+    if (w > DRAG_IMAGE_MAX_WIDTH || h > DRAG_IMAGE_MAX_HEIGH) {\n+        double rw = DRAG_IMAGE_MAX_WIDTH \/ (double) w;\n+        double rh = DRAG_IMAGE_MAX_HEIGH \/ (double) h;\n+        double r = MIN(rw, rh);\n+\n+        int new_w = w * r;\n+        int new_h = h * r;\n+\n+        w = new_w;\n+        h = new_h;\n+\n+        GdkPixbuf *tmp_pixbuf = gdk_pixbuf_scale_simple(pixbuf, new_w, new_h, GDK_INTERP_TILES);\n+        g_object_unref(pixbuf);\n+        if (!GDK_IS_PIXBUF(tmp_pixbuf)) {\n+            return NULL;\n+        }\n+        pixbuf = tmp_pixbuf;\n+    }\n+\n+    *is_raw_image = is_raw;\n+    *width = w;\n+    *height = h;\n+\n+    return pixbuf;\n+}\n+\n+void DragView::set_drag_view(GtkWidget *widget, GdkDragContext *context) {\n+    gboolean is_raw_image = FALSE;\n+    gint w = 0, h = 0;\n+    GdkPixbuf *pixbuf = get_drag_image(widget, &is_raw_image, &w, &h);\n+\n+    if (GDK_IS_PIXBUF(pixbuf)) {\n+        gint offset_x = w \/ 2;\n+        gint offset_y = h \/ 2;\n+\n+        gboolean is_offset_set = get_drag_image_offset(widget, &offset_x, &offset_y);\n+\n+        DragView::view = new DragView::View(context, pixbuf, w, h, is_raw_image,\n+                                            is_offset_set, offset_x, offset_y);\n+    }\n+}\n+\n+static void on_screen_changed(GtkWidget *widget, GdkScreen *previous_screen, gpointer view) {\n+    (void) widget;\n+    (void) previous_screen;\n+\n+    ((DragView::View *) view)->screen_changed();\n+}\n+\n+static gboolean on_expose(GtkWidget *widget, GdkEventExpose *event, gpointer view) {\n+    (void) widget;\n+    (void) event;\n+\n+    ((DragView::View *) view)->expose();\n+    return FALSE;\n+}\n+\n+DragView::View::View(GdkDragContext *_context, GdkPixbuf *_pixbuf, gint _width, gint _height,\n+                     gboolean _is_raw_image, gboolean _is_offset_set, gint _offset_x, gint _offset_y) :\n+        context(_context),\n+        pixbuf(_pixbuf),\n+        width(_width),\n+        height(_height),\n+        is_raw_image(_is_raw_image),\n+        is_offset_set(_is_offset_set),\n+        offset_x(_offset_x),\n+        offset_y(_offset_y) {\n+#ifdef GLASS_GTK3\n+    gtk_drag_set_icon_pixbuf(context, pixbuf, offset_x, offset_y);\n+#else\n+    widget = gtk_window_new(GTK_WINDOW_POPUP);\n+    gtk_window_set_type_hint(GTK_WINDOW(widget), GDK_WINDOW_TYPE_HINT_DND);\n+    gtk_widget_set_events(widget, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK);\n+\n+    screen_changed();\n+\n+    gtk_widget_realize(widget);\n+\n+    gtk_widget_set_app_paintable(widget, TRUE);\n+    g_signal_connect(G_OBJECT(widget), \"expose-event\", G_CALLBACK(on_expose), this);\n+    g_signal_connect(G_OBJECT(widget), \"screen-changed\", G_CALLBACK(on_screen_changed), this);\n+    gtk_widget_set_size_request(widget, width, height);\n+    gtk_window_set_decorated(GTK_WINDOW(widget), FALSE);\n+\n+    gtk_widget_show_all(widget);\n+    gtk_drag_set_icon_widget(context, widget, offset_x, offset_y);\n+#endif\n+}\n+\n+void DragView::View::screen_changed() {\n+    GdkScreen *screen = gtk_widget_get_screen(widget);\n+\n+    glass_configure_window_transparency(widget, true);\n+\n+    if (!gdk_screen_is_composited(screen)) {\n+        if (!is_offset_set) {\n+            offset_x = 1;\n+            offset_y = 1;\n+        }\n+    }\n+}\n+\n+void DragView::View::expose() {\n+#ifdef GLASS_GTK2\n+    cairo_t *context = gdk_cairo_create(gtk_widget_get_window(widget));\n+\n+    cairo_surface_t *cairo_surface;\n+\n+    guchar *pixels = is_raw_image\n+                     ? (guchar *) convert_BGRA_to_RGBA((const int *) gdk_pixbuf_get_pixels(pixbuf),\n+                                                       gdk_pixbuf_get_rowstride(pixbuf),\n+                                                       height)\n+                     : gdk_pixbuf_get_pixels(pixbuf);\n+\n+    cairo_surface = cairo_image_surface_create_for_data(\n+            pixels,\n+            CAIRO_FORMAT_ARGB32,\n+            width, height, width * 4);\n+\n+    cairo_set_source_surface(context, cairo_surface, 0, 0);\n+    cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);\n+    cairo_paint(context);\n+\n+    if (is_raw_image) {\n+        g_free(pixels);\n+    }\n+    cairo_destroy(context);\n+    cairo_surface_destroy(cairo_surface);\n+#endif\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_dnd.cpp","additions":953,"deletions":0,"binary":false,"changes":953,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef GLASS_DND_H\n+#define        GLASS_DND_H\n+\n+#include \"glass_general.h\"\n+#include \"glass_window.h\"\n+#include <jni.h>\n+\n+#include <gtk\/gtk.h>\n+\n+void process_dnd_target(WindowContext *, GdkEventDND *);\n+void glass_dnd_attach_context(WindowContext *ctx);\n+void dnd_drag_leave_callback(WindowContext *ctx);\n+jint dnd_target_get_supported_actions(JNIEnv *);\n+jobjectArray dnd_target_get_mimes(JNIEnv *);\n+jobject dnd_target_get_data(JNIEnv *, jstring);\n+\n+void process_dnd_source(GdkWindow *, GdkEvent *);\n+jint execute_dnd(JNIEnv *, jobject, jint);\n+\n+gboolean is_in_drag();\n+\n+#define DRAG_IMAGE_MAX_WIDTH 320\n+#define DRAG_IMAGE_MAX_HEIGH 240\n+\n+#define BSWAP_32(x) (((uint)(x) << 24)  | \\\n+          (((uint)(x) << 8) & 0xff0000) | \\\n+          (((uint)(x) >> 8) & 0xff00)   | \\\n+          ((uint)(x)  >> 24))\n+\n+class DragView {\n+public:\n+    class View {\n+        GdkDragContext* context;\n+        GtkWidget* widget;\n+        GdkPixbuf* pixbuf;\n+        gint width, height;\n+        gboolean is_raw_image;\n+        gboolean is_offset_set;\n+        gint offset_x, offset_y;\n+    public:\n+        View(GdkDragContext* context, GdkPixbuf* pixbuf, gint width, gint height,\n+                gboolean is_raw_image, gboolean is_offset_set, gint offset_x, gint offset_y);\n+        void screen_changed();\n+        void expose();\n+        void move(gint x, gint y);\n+        ~View();\n+    private:\n+        View(View&);\n+        View& operator=(const View&);\n+    };\n+\n+    static void reset_drag_view();\n+    static void set_drag_view(GtkWidget* widget, GdkDragContext* context);\n+    static void move(gint x, gint y);\n+\n+private:\n+    static View* view;\n+    static gboolean get_drag_image_offset(GtkWidget *widget, int* x, int* y);\n+    static GdkPixbuf* get_drag_image(GtkWidget* widget, gboolean* is_raw_image, gint* width, gint* height);\n+\n+    DragView() {}\n+    DragView(DragView&);\n+    DragView& operator=(const DragView&);\n+};\n+\n+#endif        \/* GLASS_DND_H *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_dnd.h","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_evloop.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_evloop.cpp","status":"copied"},{"patch":"","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_evloop.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_evloop.h","status":"copied"},{"patch":"@@ -0,0 +1,787 @@\n+\/*\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include \"glass_general.h\"\n+\n+#include <jni.h>\n+#include <gtk\/gtk.h>\n+\n+char const * const GDK_WINDOW_DATA_CONTEXT = \"glass_window_context\";\n+\n+jclass jStringCls;\n+jclass jByteBufferCls;\n+jmethodID jByteBufferArray;\n+jmethodID jByteBufferWrap;\n+\n+jclass jRunnableCls;\n+jmethodID jRunnableRun;\n+\n+jclass jArrayListCls;\n+jmethodID jArrayListInit;\n+jmethodID jArrayListAdd;\n+jmethodID jArrayListGetIdx;\n+\n+jmethodID jPixelsAttachData;\n+\n+jclass jGtkPixelsCls;\n+jmethodID jGtkPixelsInit;\n+\n+jclass jScreenCls;\n+jmethodID jScreenInit;\n+jmethodID jScreenNotifySettingsChanged;\n+\n+jmethodID jViewNotifyResize;\n+jmethodID jViewNotifyMouse;\n+jmethodID jViewNotifyRepaint;\n+jmethodID jViewNotifyKey;\n+jmethodID jViewNotifyView;\n+jmethodID jViewNotifyDragEnter;\n+jmethodID jViewNotifyDragOver;\n+jmethodID jViewNotifyDragDrop;\n+jmethodID jViewNotifyDragLeave;\n+jmethodID jViewNotifyScroll;\n+jmethodID jViewNotifyInputMethod;\n+jmethodID jViewNotifyInputMethodDraw;\n+jmethodID jViewNotifyInputMethodCaret;\n+jmethodID jViewNotifyPreeditMode;\n+jmethodID jViewNotifyMenu;\n+jfieldID  jViewPtr;\n+\n+jmethodID jWindowNotifyResize;\n+jmethodID jWindowNotifyMove;\n+jmethodID jWindowNotifyDestroy;\n+jmethodID jWindowNotifyClose;\n+jmethodID jWindowNotifyFocus;\n+jmethodID jWindowNotifyFocusDisabled;\n+jmethodID jWindowNotifyFocusUngrab;\n+jmethodID jWindowNotifyMoveToAnotherScreen;\n+jmethodID jWindowNotifyLevelChanged;\n+jmethodID jWindowIsEnabled;\n+jmethodID jWindowNotifyDelegatePtr;\n+jfieldID jWindowPtr;\n+jfieldID jCursorPtr;\n+\n+jmethodID jGtkWindowNotifyStateChanged;\n+\n+jmethodID jClipboardContentChanged;\n+\n+jmethodID jSizeInit;\n+\n+jmethodID jMapGet;\n+jmethodID jMapKeySet;\n+jmethodID jMapContainsKey;\n+\n+jclass jHashSetCls;\n+jmethodID jHashSetInit;\n+\n+jmethodID jSetAdd;\n+jmethodID jSetSize;\n+jmethodID jSetToArray;\n+\n+jmethodID jIterableIterator;\n+jmethodID jIteratorHasNext;\n+jmethodID jIteratorNext;\n+\n+jclass jApplicationCls;\n+jfieldID jApplicationDisplay;\n+jfieldID jApplicationScreen;\n+jfieldID jApplicationVisualID;\n+jmethodID jApplicationReportException;\n+jmethodID jApplicationGetApplication;\n+jmethodID jApplicationGetName;\n+\n+static jboolean displayValid = JNI_FALSE;\n+\n+jboolean\n+is_display_valid() {\n+    return displayValid;\n+}\n+\n+JavaVM* javaVM;\n+\n+#ifdef STATIC_BUILD\n+extern \"C\" {\n+#endif\n+JNIEXPORT jint JNICALL\n+#ifdef STATIC_BUILD\n+JNI_OnLoad_glassgtk3(JavaVM *jvm, void *reserved)\n+#else\n+JNI_OnLoad(JavaVM *jvm, void *reserved)\n+#endif\n+{\n+    (void)reserved;\n+\n+    JNIEnv *env;\n+    jclass clazz;\n+    Display* display;\n+\n+    javaVM = jvm;\n+    if (jvm->GetEnv((void **)&env, JNI_VERSION_1_6)) {\n+         return JNI_ERR; \/* JNI version not supported *\/\n+    }\n+\n+    clazz = env->FindClass(\"java\/lang\/String\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jStringCls = (jclass) env->NewGlobalRef(clazz);\n+\n+    clazz = env->FindClass(\"java\/nio\/ByteBuffer\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jByteBufferCls = (jclass) env->NewGlobalRef(clazz);\n+    jByteBufferArray = env->GetMethodID(jByteBufferCls, \"array\", \"()[B\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jByteBufferWrap = env->GetStaticMethodID(jByteBufferCls, \"wrap\", \"([B)Ljava\/nio\/ByteBuffer;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"java\/lang\/Runnable\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    jRunnableRun = env->GetMethodID(clazz, \"run\", \"()V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"java\/util\/ArrayList\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jArrayListCls = (jclass) env->NewGlobalRef(clazz);\n+    jArrayListInit = env->GetMethodID(jArrayListCls, \"<init>\", \"()V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jArrayListAdd = env->GetMethodID(jArrayListCls, \"add\", \"(Ljava\/lang\/Object;)Z\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jArrayListGetIdx = env->GetMethodID(jArrayListCls, \"get\", \"(I)Ljava\/lang\/Object;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    clazz = env->FindClass(\"com\/sun\/glass\/ui\/Pixels\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jPixelsAttachData = env->GetMethodID(clazz, \"attachData\", \"(J)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"com\/sun\/glass\/ui\/gtk\/GtkPixels\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    jGtkPixelsCls = (jclass) env->NewGlobalRef(clazz);\n+    jGtkPixelsInit = env->GetMethodID(jGtkPixelsCls, \"<init>\", \"(IILjava\/nio\/ByteBuffer;)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"com\/sun\/glass\/ui\/Screen\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jScreenCls = (jclass) env->NewGlobalRef(clazz);\n+    jScreenInit = env->GetMethodID(jScreenCls, \"<init>\", \"(JIIIIIIIIIIIIIIIFFFF)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jScreenNotifySettingsChanged = env->GetStaticMethodID(jScreenCls, \"notifySettingsChanged\", \"()V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"com\/sun\/glass\/ui\/View\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyResize = env->GetMethodID(clazz, \"notifyResize\", \"(II)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyMouse = env->GetMethodID(clazz, \"notifyMouse\", \"(IIIIIIIZZ)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyRepaint = env->GetMethodID(clazz, \"notifyRepaint\", \"(IIII)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyKey = env->GetMethodID(clazz, \"notifyKey\", \"(II[CI)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyView = env->GetMethodID(clazz, \"notifyView\", \"(I)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyDragEnter = env->GetMethodID(clazz, \"notifyDragEnter\", \"(IIIII)I\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyDragOver = env->GetMethodID(clazz, \"notifyDragOver\", \"(IIIII)I\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyDragDrop = env->GetMethodID(clazz, \"notifyDragDrop\", \"(IIIII)I\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyDragLeave = env->GetMethodID(clazz, \"notifyDragLeave\", \"()V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyScroll = env->GetMethodID(clazz, \"notifyScroll\", \"(IIIIDDIIIIIDD)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyInputMethod = env->GetMethodID(clazz, \"notifyInputMethod\", \"(Ljava\/lang\/String;[I[I[BIII)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyMenu = env->GetMethodID(clazz, \"notifyMenu\", \"(IIIIZ)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewPtr = env->GetFieldID(clazz, \"ptr\", \"J\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"com\/sun\/glass\/ui\/gtk\/GtkView\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyInputMethodDraw = env->GetMethodID(clazz, \"notifyInputMethodDraw\", \"(Ljava\/lang\/String;III[B)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyInputMethodCaret = env->GetMethodID(clazz, \"notifyInputMethodCaret\", \"(III)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jViewNotifyPreeditMode = env->GetMethodID(clazz, \"notifyPreeditMode\", \"(Z)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"com\/sun\/glass\/ui\/Window\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jWindowNotifyResize = env->GetMethodID(clazz, \"notifyResize\", \"(III)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jWindowNotifyMove = env->GetMethodID(clazz, \"notifyMove\", \"(II)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jWindowNotifyDestroy = env->GetMethodID(clazz, \"notifyDestroy\", \"()V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jWindowNotifyClose = env->GetMethodID(clazz, \"notifyClose\", \"()V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jWindowNotifyFocus = env->GetMethodID(clazz, \"notifyFocus\", \"(I)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jWindowNotifyFocusDisabled = env->GetMethodID(clazz, \"notifyFocusDisabled\", \"()V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jWindowNotifyFocusUngrab = env->GetMethodID(clazz, \"notifyFocusUngrab\", \"()V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jWindowNotifyMoveToAnotherScreen = env->GetMethodID(clazz, \"notifyMoveToAnotherScreen\", \"(Lcom\/sun\/glass\/ui\/Screen;)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jWindowNotifyLevelChanged = env->GetMethodID(clazz, \"notifyLevelChanged\", \"(I)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jWindowIsEnabled = env->GetMethodID(clazz, \"isEnabled\", \"()Z\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jWindowNotifyDelegatePtr = env->GetMethodID(clazz, \"notifyDelegatePtr\", \"(J)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jWindowPtr = env->GetFieldID(clazz, \"ptr\", \"J\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"com\/sun\/glass\/ui\/gtk\/GtkWindow\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jGtkWindowNotifyStateChanged =\n+            env->GetMethodID(clazz, \"notifyStateChanged\", \"(I)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"com\/sun\/glass\/ui\/Clipboard\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jClipboardContentChanged = env->GetMethodID(clazz, \"contentChanged\", \"()V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"com\/sun\/glass\/ui\/Cursor\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jCursorPtr = env->GetFieldID(clazz, \"ptr\", \"J\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"com\/sun\/glass\/ui\/Size\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jSizeInit = env->GetMethodID(clazz, \"<init>\", \"(II)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"java\/util\/Map\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jMapGet = env->GetMethodID(clazz, \"get\", \"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jMapKeySet = env->GetMethodID(clazz, \"keySet\", \"()Ljava\/util\/Set;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jMapContainsKey = env->GetMethodID(clazz, \"containsKey\", \"(Ljava\/lang\/Object;)Z\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"java\/util\/HashSet\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jHashSetCls = (jclass) env->NewGlobalRef(clazz);\n+    jHashSetInit = env->GetMethodID(jHashSetCls, \"<init>\", \"()V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"java\/util\/Set\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jSetAdd = env->GetMethodID(clazz, \"add\", \"(Ljava\/lang\/Object;)Z\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jSetSize = env->GetMethodID(clazz, \"size\", \"()I\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jSetToArray = env->GetMethodID(clazz, \"toArray\", \"([Ljava\/lang\/Object;)[Ljava\/lang\/Object;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"java\/lang\/Iterable\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jIterableIterator = env->GetMethodID(clazz, \"iterator\", \"()Ljava\/util\/Iterator;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"java\/util\/Iterator\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jIteratorHasNext = env->GetMethodID(clazz, \"hasNext\", \"()Z\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jIteratorNext = env->GetMethodID(clazz, \"next\", \"()Ljava\/lang\/Object;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"com\/sun\/glass\/ui\/gtk\/GtkApplication\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jApplicationCls = (jclass) env->NewGlobalRef(clazz);\n+    jApplicationDisplay = env->GetStaticFieldID(jApplicationCls, \"display\", \"J\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jApplicationScreen = env->GetStaticFieldID(jApplicationCls, \"screen\", \"I\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jApplicationVisualID = env->GetStaticFieldID(jApplicationCls, \"visualID\", \"J\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jApplicationReportException = env->GetStaticMethodID(\n+        jApplicationCls, \"reportException\", \"(Ljava\/lang\/Throwable;)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jApplicationGetApplication = env->GetStaticMethodID(\n+        jApplicationCls, \"GetApplication\", \"()Lcom\/sun\/glass\/ui\/Application;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jApplicationGetName = env->GetMethodID(jApplicationCls, \"getName\", \"()Ljava\/lang\/String;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    return JNI_VERSION_1_6;\n+}\n+\n+#ifdef STATIC_BUILD\n+}\n+#endif\n+\n+void\n+glass_throw_exception(JNIEnv * env,\n+                      const char * exceptionClass,\n+                      const char * exceptionMessage) {\n+    jclass throwableClass = env->FindClass(exceptionClass);\n+    if (check_and_clear_exception(env)) return;\n+    env->ThrowNew(throwableClass, exceptionMessage);\n+    check_and_clear_exception(env);\n+}\n+\n+int\n+glass_throw_oom(JNIEnv * env, const char * message) {\n+    glass_throw_exception(env, \"java\/lang\/OutOfMemoryError\", message);\n+    \/\/ must return a non-zero value, see HANDLE_MEM_ALLOC_ERROR\n+    return 1;\n+}\n+\n+\n+guint8* convert_BGRA_to_RGBA(const int* pixels, int stride, int height) {\n+  guint8* new_pixels = (guint8*) g_malloc(height * stride);\n+  int i = 0;\n+\n+  for (i = 0; i < height * stride; i += 4) {\n+      new_pixels[i] = (guint8)(*pixels >> 16);\n+      new_pixels[i + 1] = (guint8)(*pixels >> 8);\n+      new_pixels[i + 2] = (guint8)(*pixels);\n+      new_pixels[i + 3] = (guint8)(*pixels >> 24);\n+      pixels++;\n+  }\n+\n+  return new_pixels;\n+}\n+\n+\n+void dump_jstring_array(JNIEnv* env, jobjectArray arr) {\n+    if (arr == NULL) {\n+        LOG0(\"dump: Array is null\\n\")\n+        return;\n+    }\n+    jsize len = env->GetArrayLength(arr);\n+    LOG1(\"dump: length = %d\\n\", len)\n+    int i = 0;\n+    jboolean isCopy;\n+    for(i = 0; i < len; i++) {\n+        jstring jstr = (jstring) env->GetObjectArrayElement(arr, i);\n+        check_and_clear_exception(env);\n+        const char* str = env->GetStringUTFChars(jstr, &isCopy);\n+        LOG2(\"dump: s[%d]: %s\\n\", i, str)\n+    }\n+}\n+\n+gboolean check_and_clear_exception(JNIEnv *env) {\n+    jthrowable t = env->ExceptionOccurred();\n+    if (t) {\n+        env->ExceptionClear();\n+        env->CallStaticVoidMethod(jApplicationCls, jApplicationReportException, t);\n+        \/\/Clear in case our reporting upcall failed too!\n+        env->ExceptionClear();\n+        return TRUE;\n+    }\n+    return FALSE;\n+}\n+\n+\/\/ The returned string should be freed with g_free().\n+gchar* get_application_name() {\n+    gchar* ret = NULL;\n+\n+    jobject japp = mainEnv->CallStaticObjectMethod(jApplicationCls, jApplicationGetApplication);\n+    CHECK_JNI_EXCEPTION_RET(mainEnv, NULL);\n+    jstring jname = (jstring) mainEnv->CallObjectMethod(japp, jApplicationGetName);\n+    CHECK_JNI_EXCEPTION_RET(mainEnv, NULL);\n+    if (const gchar *name = mainEnv->GetStringUTFChars(jname, NULL)) {\n+        ret = g_strdup(name);\n+        mainEnv->ReleaseStringUTFChars(jname, name);\n+    }\n+    return ret;\n+}\n+\n+gpointer glass_try_malloc_n(gsize m, gsize n,\n+        gboolean zer0 \/* initialized to 0 if true*\/) {\n+    if (n > 0 && m > G_MAXSIZE \/ n) {\n+        return NULL;\n+    }\n+    return (zer0)\n+            ? g_try_malloc0(m * n)\n+            : g_try_malloc(m * n);\n+}\n+\n+\/*\n+ * Since we support glib 2.18 we can't use g_try_malloc_n and g_try_malloc0_n\n+ * which was introduced in 2.24.\n+ * glass_try_malloc_n and glass_try_malloc0_n is replacement for those functions\n+ *\/\n+gpointer glass_try_malloc0_n(gsize m, gsize n) {\n+    return glass_try_malloc_n(m, n, TRUE);\n+}\n+\n+gpointer glass_try_malloc_n(gsize m, gsize n) {\n+    return glass_try_malloc_n(m, n, FALSE);\n+}\n+\n+gsize get_files_count(gchar **uris) {\n+    if (!uris) {\n+        return 0;\n+    }\n+\n+    guint size = g_strv_length(uris);\n+    guint files_cnt = 0;\n+\n+    for (guint i = 0; i < size; ++i) {\n+        if (g_str_has_prefix(uris[i], FILE_PREFIX)) {\n+            files_cnt++;\n+        }\n+    }\n+    return files_cnt;\n+}\n+\n+\/\/ Note: passed uris will be freed by this function\n+jobject uris_to_java(JNIEnv *env, gchar **uris, gboolean files) {\n+    if (uris == NULL) {\n+        return NULL;\n+    }\n+\n+    jobject result = NULL;\n+\n+    guint size = g_strv_length(uris);\n+    guint files_cnt = get_files_count(uris);\n+\n+    if (files) {\n+        if (files_cnt) {\n+            result = env->NewObjectArray(files_cnt, jStringCls, NULL);\n+            check_and_clear_exception(env);\n+\n+            for (gsize i = 0; i < size; ++i) {\n+                if (g_str_has_prefix(uris[i], FILE_PREFIX)) {\n+                    gchar* path = g_filename_from_uri(uris[i], NULL, NULL);\n+                    jstring str = env->NewStringUTF(path);\n+                    check_and_clear_exception(env);\n+                    env->SetObjectArrayElement((jobjectArray) result, i, str);\n+                    check_and_clear_exception(env);\n+                    g_free(path);\n+                }\n+            }\n+        }\n+    } else if (size - files_cnt) {\n+        GString* str = g_string_new(NULL); \/\/http:\/\/www.ietf.org\/rfc\/rfc2483.txt\n+\n+        for (guint i = 0; i < size; ++i) {\n+            if (!g_str_has_prefix(uris[i], FILE_PREFIX)\n+                    && !g_str_has_prefix(uris[i], URI_LIST_COMMENT_PREFIX)) {\n+                g_string_append(str, uris[i]);\n+                g_string_append(str, URI_LIST_LINE_BREAK);\n+            }\n+        }\n+\n+        if (str->len > 2) {\n+            g_string_erase(str, str->len - 2, 2);\n+        }\n+\n+        result = env->NewStringUTF(str->str);\n+        check_and_clear_exception(env);\n+\n+        g_string_free(str, TRUE);\n+    }\n+    g_strfreev(uris);\n+    return result;\n+}\n+\n+\/\/***************************************************************************\n+\n+\n+gboolean disableGrab = FALSE;\n+static gboolean configure_transparent_window(GtkWidget *window);\n+static void configure_opaque_window(GtkWidget *window);\n+\n+gboolean is_grab_disabled() {\n+    return disableGrab;\n+}\n+\n+gint glass_gdk_visual_get_depth (GdkVisual * visual)\n+{\n+    \/\/ gdk_visual_get_depth is GTK 2.2 +\n+    return gdk_visual_get_depth(visual);\n+}\n+\n+GdkScreen * glass_gdk_window_get_screen(GdkWindow * gdkWindow)\n+{\n+#ifdef GLASS_GTK3\n+        GdkVisual * gdkVisual = gdk_window_get_visual(gdkWindow);\n+        return gdk_visual_get_screen(gdkVisual);\n+#else\n+        return gdk_window_get_screen(gdkWindow);\n+#endif\n+}\n+\n+void\n+glass_gdk_master_pointer_get_position(gint *x, gint *y) {\n+#ifdef GLASS_GTK3\n+        gdk_device_get_position(\n+            gdk_device_manager_get_client_pointer(\n+                gdk_display_get_device_manager(gdk_display_get_default())), NULL , x, y);\n+#else\n+        gdk_display_get_pointer(gdk_display_get_default(), NULL, x, y, NULL);\n+#endif\n+}\n+\n+gboolean\n+glass_gdk_device_is_grabbed(GdkDevice *device) {\n+#ifdef GLASS_GTK3\n+        return gdk_display_device_is_grabbed(gdk_display_get_default(), device);\n+#else\n+        (void) device;\n+        return gdk_display_pointer_is_grabbed(gdk_display_get_default());\n+#endif\n+}\n+\n+GdkWindow *\n+glass_gdk_device_get_window_at_position(GdkDevice *device, gint *x, gint *y) {\n+#ifdef GLASS_GTK3\n+        return gdk_device_get_window_at_position(device, x, y);\n+#else\n+        (void) device;\n+        return gdk_display_get_window_at_pointer(gdk_display_get_default(), x, y);\n+#endif\n+}\n+\n+void\n+glass_gtk_configure_transparency_and_realize(GtkWidget *window,\n+                                             gboolean transparent) {\n+        gboolean isTransparent = glass_configure_window_transparency(window, transparent);\n+        gtk_widget_realize(window);\n+}\n+\n+void\n+glass_gtk_window_configure_from_visual(GtkWidget *widget, GdkVisual *visual) {\n+    glass_widget_set_visual(widget, visual);\n+}\n+\n+static gboolean\n+configure_transparent_window(GtkWidget *window) {\n+    GdkScreen *default_screen = gdk_screen_get_default();\n+\n+#ifdef GLASS_GTK3\n+    GdkVisual *visual = gdk_screen_get_rgba_visual(default_screen);\n+    \/\/ visual will be NULL if rgba not supported\n+    if (visual) {\n+        glass_widget_set_visual(window, visual);\n+        return TRUE;\n+    }\n+#else\n+    GdkDisplay *default_display = gdk_display_get_default();\n+    GdkColormap *colormap = gdk_screen_get_rgba_colormap(default_screen);\n+    if (colormap\n+            && gdk_display_supports_composite(default_display)\n+            && gdk_screen_is_composited(default_screen)) {\n+        gtk_widget_set_colormap(window, colormap);\n+        return TRUE;\n+    }\n+#endif\n+\n+    return FALSE;\n+}\n+\n+void\n+glass_gdk_window_get_size(GdkWindow *window, gint *w, gint *h) {\n+    *w = gdk_window_get_width(window);\n+    *h = gdk_window_get_height(window);\n+}\n+\n+void\n+glass_gdk_display_get_pointer(GdkDisplay* display, gint* x, gint *y) {\n+#ifdef GLASS_GTK3\n+        gdk_device_get_position(\n+            gdk_device_manager_get_client_pointer(\n+                gdk_display_get_device_manager(display)), NULL , x, y);\n+#else\n+        gdk_display_get_pointer(display, NULL, x, y, NULL);\n+#endif\n+}\n+\n+\n+const guchar*\n+glass_gtk_selection_data_get_data_with_length(\n+        GtkSelectionData * selectionData,\n+        gint * length) {\n+    if (selectionData == NULL) {\n+        return NULL;\n+    }\n+\n+    *length = gtk_selection_data_get_length(selectionData);\n+    return gtk_selection_data_get_data(selectionData);\n+}\n+\n+static void\n+configure_opaque_window(GtkWidget *window) {\n+    (void) window;\n+\/* We need to pick a visual that really is glx compatible\n+ * instead of using the default visual\n+ *\/\n+ \/* see: JDK-8087516 for why this is commented out\n+    glass_widget_set_visual(window,\n+                          gdk_screen_get_system_visual(\n+                              gdk_screen_get_default()));\n+  *\/\n+}\n+\n+gboolean\n+glass_configure_window_transparency(GtkWidget *window, gboolean transparent) {\n+    if (transparent) {\n+        if (configure_transparent_window(window)) {\n+            return TRUE;\n+        }\n+\n+        fprintf(stderr,\"Can't create transparent stage, because your screen doesn't\"\n+               \" support alpha channel.\"\n+               \" You need to enable XComposite extension.\\n\");\n+        fflush(stderr);\n+    }\n+\n+    configure_opaque_window(window);\n+    return FALSE;\n+}\n+\n+GdkPixbuf *\n+glass_pixbuf_from_window(GdkWindow *window,\n+    gint srcx, gint srcy,\n+    gint width, gint height)\n+{\n+    GdkPixbuf * ret = NULL;\n+\n+#ifdef GLASS_GTK3\n+        ret = gdk_pixbuf_get_from_window (window, srcx, srcy, width, height);\n+#else\n+        ret = gdk_pixbuf_get_from_drawable (NULL,\n+            window,\n+            NULL,\n+            srcx, srcy,\n+            0, 0,\n+            width, height);\n+#endif\n+    return ret;\n+}\n+\n+void\n+glass_window_apply_shape_mask(GdkWindow *window,\n+    void* data, uint width, uint height)\n+{\n+#ifdef GLASS_GTK3\n+    (void) window;\n+    (void) data;\n+    (void) width;\n+    (void) height;\n+#else\n+        GdkPixbuf* pixbuf = gdk_pixbuf_new_from_data((guchar *) data,\n+                GDK_COLORSPACE_RGB, TRUE, 8, width, height, width * 4, NULL, NULL);\n+\n+        if (GDK_IS_PIXBUF(pixbuf)) {\n+            GdkBitmap* mask = NULL;\n+            gdk_pixbuf_render_pixmap_and_mask(pixbuf, NULL, &mask, 128);\n+\n+            gdk_window_input_shape_combine_mask(window, mask, 0, 0);\n+\n+            g_object_unref(pixbuf);\n+            if (mask) {\n+                g_object_unref(mask);\n+            }\n+        }\n+#endif\n+}\n+\n+void\n+glass_window_reset_input_shape_mask(GdkWindow *window)\n+{\n+#ifdef GLASS_GTK3\n+        gdk_window_input_shape_combine_region(window, NULL, 0, 0);\n+#else\n+        gdk_window_input_shape_combine_mask(window, NULL, 0, 0);\n+#endif\n+}\n+\n+GdkWindow *\n+glass_gdk_drag_context_get_dest_window (GdkDragContext * context)\n+{\n+    return ((context != NULL) ? gdk_drag_context_get_dest_window(context) : NULL);\n+}\n+\n+\n+void glass_gdk_x11_display_set_window_scale (GdkDisplay *display,\n+                          gint scale)\n+{\n+#ifdef GLASS_GTK3\n+    \/\/ Optional call, if it does not exist then GTK3 is not yet\n+    \/\/ doing automatic scaling of coordinates so we do not need\n+    \/\/ to override it.\n+    wrapped_gdk_x11_display_set_window_scale(display, scale);\n+#else\n+    (void) display;\n+    (void) scale;\n+#endif\n+}\n+\n+\/\/-------- Glass utility ----------------------------------------\n+\n+void\n+glass_widget_set_visual(GtkWidget *widget, GdkVisual *visual)\n+{\n+#ifdef GLASS_GTK3\n+        gtk_widget_set_visual (widget, visual);\n+#else\n+        GdkColormap *colormap = gdk_colormap_new(visual, TRUE);\n+        gtk_widget_set_colormap (widget, colormap);\n+#endif\n+}\n+\n+guint glass_settings_get_guint_opt (const gchar *schema_name,\n+                    const gchar *key_name,\n+                    int defval)\n+{\n+    GSettingsSchemaSource *default_schema_source =\n+            wrapped_g_settings_schema_source_get_default();\n+    if (default_schema_source == NULL) {\n+        if (gtk_verbose) {\n+            fprintf(stderr, \"No schema source dir found!\\n\");\n+        }\n+        return defval;\n+    }\n+    GSettingsSchema *the_schema =\n+            wrapped_g_settings_schema_source_lookup(default_schema_source, schema_name, TRUE);\n+    if (the_schema == NULL) {\n+        if (gtk_verbose) {\n+            fprintf(stderr, \"schema '%s' not found!\\n\", schema_name);\n+        }\n+        return defval;\n+    }\n+    if (!wrapped_g_settings_schema_has_key(the_schema, key_name)) {\n+        if (gtk_verbose) {\n+            fprintf(stderr, \"key '%s' not found in schema '%s'!\\n\", key_name, schema_name);\n+        }\n+        return defval;\n+    }\n+    if (gtk_verbose) {\n+        fprintf(stderr, \"found schema '%s' and key '%s'\\n\", schema_name, key_name);\n+    }\n+\n+    GSettings *gset = g_settings_new(schema_name);\n+\n+    wrapped_g_settings_schema_unref(the_schema);\n+\n+    return g_settings_get_uint(gset, key_name);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_general.cpp","additions":787,"deletions":0,"binary":false,"changes":787,"status":"added"},{"patch":"@@ -0,0 +1,337 @@\n+\/*\n+ * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef GLASS_GENERAL_H\n+#define        GLASS_GENERAL_H\n+\n+#include <jni.h>\n+\n+#include <stdint.h>\n+#include <X11\/Xlib.h>\n+#include <gdk\/gdk.h>\n+#include <gdk\/gdkx.h>\n+#include <gtk\/gtk.h>\n+\n+#include \"wrapped.h\"\n+\n+#if GTK_CHECK_VERSION(3, 0, 0)\n+#if ! GTK_CHECK_VERSION(3, 8, 0)\n+#error GTK development version is not the minimum 3.8\n+#endif\n+#define GLASS_GTK3\n+#endif\n+\n+#define JLONG_TO_PTR(value) ((void*)(intptr_t)(value))\n+#define PTR_TO_JLONG(value) ((jlong)(intptr_t)(value))\n+\n+#define FILE_PREFIX \"file:\/\/\"\n+#define URI_LIST_COMMENT_PREFIX \"#\"\n+#define URI_LIST_LINE_BREAK \"\\r\\n\"\n+\n+extern JNIEnv* mainEnv; \/\/ Use only with main loop thread!!!\n+extern JavaVM* javaVM;\n+\n+#define GLASS_GDK_KEY_CONSTANT(key) (GDK_KEY_ ## key)\n+\n+#include <exception>\n+\n+struct jni_exception: public std::exception {\n+    jni_exception(jthrowable _th): throwable(_th), message() {\n+            jclass jc = mainEnv->FindClass(\"java\/lang\/Throwable\");\n+            if (mainEnv->ExceptionOccurred()) {\n+                mainEnv->ExceptionDescribe();\n+                mainEnv->ExceptionClear();\n+            }\n+            jmethodID jmid = mainEnv->GetMethodID(jc, \"getMessage\", \"()Ljava\/lang\/String;\");\n+            if (mainEnv->ExceptionOccurred()) {\n+                mainEnv->ExceptionDescribe();\n+                mainEnv->ExceptionClear();\n+            }\n+            jmessage = (jstring)mainEnv->CallObjectMethod(throwable, jmid);\n+            message = jmessage == NULL ? \"\" : mainEnv->GetStringUTFChars(jmessage, NULL);\n+    }\n+    const char *what() const throw()\n+    {\n+        return message;\n+    }\n+    ~jni_exception() throw(){\n+        if (jmessage && message) {\n+            mainEnv->ReleaseStringUTFChars(jmessage, message);\n+        }\n+    }\n+private:\n+    jthrowable throwable;\n+    const char *message;\n+    jstring jmessage;\n+};\n+\n+#define EXCEPTION_OCCURED(env) (check_and_clear_exception(env))\n+\n+#define CHECK_JNI_EXCEPTION(env) \\\n+        if (env->ExceptionCheck()) {\\\n+            check_and_clear_exception(env);\\\n+            return;\\\n+        }\n+\n+#define CHECK_JNI_EXCEPTION_RET(env, ret) \\\n+        if (env->ExceptionCheck()) {\\\n+            check_and_clear_exception(env);\\\n+            return ret;\\\n+        }\n+\n+#define JNI_EXCEPTION_TO_CPP(env) \\\n+        if (env->ExceptionCheck()) {\\\n+            check_and_clear_exception(env);\\\n+            throw jni_exception(env->ExceptionOccurred());\\\n+        }\n+\n+#define HANDLE_MEM_ALLOC_ERROR(env, nativePtr, message) \\\n+        ((nativePtr == NULL) && glass_throw_oom(env, message))\n+\n+    gpointer glass_try_malloc0_n(gsize m, gsize n);\n+\n+    gpointer glass_try_malloc_n(gsize m, gsize n);\n+\n+    typedef struct {\n+        jobject runnable;\n+        int flag;\n+    } RunnableContext;\n+\n+    extern char const * const GDK_WINDOW_DATA_CONTEXT;\n+\n+    GdkCursor* get_native_cursor(int type);\n+    gboolean is_grab_disabled();\n+\n+    \/\/ JNI global references\n+    extern jclass jStringCls; \/\/ java.lang.String\n+\n+    extern jclass jByteBufferCls; \/\/java.nio.ByteBuffer\n+    extern jmethodID jByteBufferArray; \/\/java.nio.ByteBuffer#array()[B\n+    extern jmethodID jByteBufferWrap; \/\/java.nio.ByteBuffer#wrap([B)Ljava\/nio\/ByteBuffer;\n+\n+    extern jclass jRunnableCls; \/\/ java.lang.Runnable\n+    extern jmethodID jRunnableRun; \/\/ java.lang.Runnable#run ()V\n+\n+    extern jclass jArrayListCls; \/\/ java.util.ArrayList\n+    extern jmethodID jArrayListInit; \/\/ java.util.ArrayList#<init> ()V\n+    extern jmethodID jArrayListAdd; \/\/ java.util.ArrayList#add (Ljava\/lang\/Object;)Z\n+    extern jmethodID jArrayListGetIdx; \/\/java.util.ArryList#get (I)Ljava\/lang\/Object;\n+\n+    extern jmethodID jPixelsAttachData; \/\/ com.sun.class.ui.Pixels#attachData (J)V\n+    extern jclass jGtkPixelsCls; \/\/ com.sun.class.ui.gtk.GtkPixels\n+    extern jmethodID jGtkPixelsInit; \/\/ com.sun.class.ui.gtk.GtkPixels#<init> (IILjava\/nio\/ByteBuffer;)V\n+\n+    extern jclass jScreenCls;   \/\/ com.sun.glass.ui.Screen\n+    extern jmethodID jScreenInit; \/\/ com.sun.glass.ui.Screen#<init> ()V\n+    extern jmethodID jScreenNotifySettingsChanged; \/\/ com.sun.glass.ui.Screen#notifySettingsChanged ()V\n+    extern jmethodID jScreenGetScreenForLocation; \/\/com.sun.glass.ui.Screen#getScreenForLocation(JJ)Lcom.sun.glass.ui.Screen;\n+    extern jmethodID jScreenGetNativeScreen; \/\/com.sun.glass.ui.Screen#getNativeScreen()J\n+\n+    extern jmethodID jViewNotifyResize; \/\/ com.sun.glass.ui.View#notifyResize (II)V\n+    extern jmethodID jViewNotifyMouse; \/\/ com.sun.glass.ui.View#notifyMouse (IIIIIIIZZ)V\n+    extern jmethodID jViewNotifyRepaint; \/\/ com.sun.glass.ui.View#notifyRepaint (IIII)V\n+    extern jmethodID jViewNotifyKey; \/\/ com.sun.glass.ui.View#notifyKey (II[CI)V\n+    extern jmethodID jViewNotifyView; \/\/com.sun.glass.ui.View#notifyView (I)V\n+    extern jmethodID jViewNotifyDragEnter; \/\/com.sun.glass.ui.View#notifyDragEnter (IIIII)I\n+    extern jmethodID jViewNotifyDragOver; \/\/com.sun.glass.ui.View#notifyDragOver (IIIII)I\n+    extern jmethodID jViewNotifyDragDrop; \/\/com.sun.glass.ui.View#notifyDragDrop (IIIII)I\n+    extern jmethodID jViewNotifyDragLeave; \/\/com.sun.glass.ui.View#notifyDragLeave ()V\n+    extern jmethodID jViewNotifyScroll; \/\/com.sun.glass.ui.View#notifyScroll (IIIIDDIIIIIDD)V\n+    extern jmethodID jViewNotifyInputMethod; \/\/com.sun.glass.ui.View#notifyInputMethod (Ljava\/lang\/String;[I[I[BIII)V\n+    extern jmethodID jViewNotifyInputMethodDraw; \/\/com.sun.glass.ui.gtk.GtkView#notifyInputMethodDraw (Ljava\/lang\/String;III[B)V\n+    extern jmethodID jViewNotifyInputMethodCaret; \/\/com.sun.glass.ui.gtk.GtkView#notifyInputMethodCaret (III)V\n+    extern jmethodID jViewNotifyPreeditMode; \/\/com.sun.glass.ui.gtk.GtkView#notifyPreeditMode (Z)V\n+    extern jmethodID jViewNotifyMenu; \/\/com.sun.glass.ui.View#notifyMenu (IIIIZ)V\n+    extern jfieldID  jViewPtr; \/\/com.sun.glass.ui.View.ptr\n+\n+    extern jmethodID jWindowNotifyResize; \/\/ com.sun.glass.ui.Window#notifyResize (III)V\n+    extern jmethodID jWindowNotifyMove; \/\/ com.sun.glass.ui.Window#notifyMove (II)V\n+    extern jmethodID jWindowNotifyDestroy; \/\/ com.sun.glass.ui.Window#notifyDestroy ()V\n+    extern jmethodID jWindowNotifyClose; \/\/ com.sun.glass.ui.Window#notifyClose ()V\n+    extern jmethodID jWindowNotifyFocus; \/\/ com.sun.glass.ui.Window#notifyFocus (I)V\n+    extern jmethodID jWindowNotifyFocusDisabled; \/\/ com.sun.glass.ui.Window#notifyFocusDisabled ()V\n+    extern jmethodID jWindowNotifyFocusUngrab; \/\/ com.sun.glass.ui.Window#notifyFocusUngrab ()V\n+    extern jmethodID jWindowNotifyMoveToAnotherScreen; \/\/ com.sun.glass.ui.Window#notifyMoveToAnotherScreen (Lcom\/sun\/glass\/ui\/Screen;)V\n+    extern jmethodID jWindowNotifyDelegatePtr; \/\/com.sun.glass.ui.Window#notifyDelegatePtr (J)V\n+    extern jmethodID jWindowNotifyLevelChanged; \/\/com.sun.glass.ui.Window#notifyLevelChanged (I)V\n+\n+    extern jmethodID jWindowIsEnabled; \/\/ com.sun.glass.ui.Window#isEnabled ()Z\n+    extern jfieldID jWindowPtr; \/\/ com.sun.glass.ui.Window#ptr\n+    extern jfieldID jCursorPtr; \/\/ com.sun.glass.ui.Cursor#ptr\n+\n+    extern jmethodID jGtkWindowNotifyStateChanged; \/\/ com.sun.glass.ui.GtkWindow#notifyStateChanged (I)V\n+\n+    extern jmethodID jClipboardContentChanged; \/\/ com.sun.glass.ui.Clipboard#contentChanged ()V\n+\n+    extern jmethodID jSizeInit; \/\/ com.sun.class.ui.Size#<init> ()V\n+\n+    extern jmethodID jMapGet; \/\/ java.util.Map#get(Ljava\/lang\/Object;)Ljava\/lang\/Object;\n+    extern jmethodID jMapKeySet; \/\/ java.util.Map#keySet()Ljava\/util\/Set;\n+    extern jmethodID jMapContainsKey; \/\/ java.util.Map#containsKey(Ljava\/lang\/Object;)Z\n+\n+    extern jclass jHashSetCls; \/\/ java.util.HashSet\n+    extern jmethodID jHashSetInit; \/\/ java.util.HashSet#<init> ()V\n+\n+    extern jmethodID jSetAdd; \/\/java.util.Set#add (Ljava\/lang\/Object;)Z\n+    extern jmethodID jSetSize; \/\/java.util.Set#size ()I\n+    extern jmethodID jSetToArray; \/\/java.util.Set#toArray ([Ljava\/lang\/Object;)[Ljava\/lang\/Object;\n+\n+    extern jmethodID jIterableIterator; \/\/ java.lang.Iterable#iterator()Ljava\/util\/Iterator;\n+    extern jmethodID jIteratorHasNext; \/\/ java.util.Iterator#hasNext()Z;\n+    extern jmethodID jIteratorNext; \/\/ java.util.Iterator#next()Ljava\/lang\/Object;\n+\n+    extern jclass jApplicationCls; \/\/com.sun.glass.ui.gtk.GtkApplication\n+    extern jfieldID jApplicationDisplay; \/\/com.sun.glass.ui.gtk.GtkApplication#display\n+    extern jfieldID jApplicationScreen; \/\/com.sun.glass.ui.gtk.GtkApplication#screen\n+    extern jfieldID jApplicationVisualID; \/\/com.sun.glass.ui.gtk.GtkApplication#visualID\n+    extern jmethodID jApplicationReportException; \/\/ reportException(Ljava\/lang\/Throwable;)V\n+    extern jmethodID jApplicationGetApplication; \/\/ GetApplication()()Lcom\/sun\/glass\/ui\/Application;\n+    extern jmethodID jApplicationGetName; \/\/ getName()Ljava\/lang\/String;\n+\n+#ifdef VERBOSE\n+#define LOG0(msg) {printf(msg);fflush(stdout);}\n+#define LOG1(msg, param) {printf(msg, param);fflush(stdout);}\n+#define LOG2(msg, param1, param2) {printf(msg, param1, param2);fflush(stdout);}\n+#define LOG3(msg, param1, param2, param3) {printf(msg, param1, param2, param3);fflush(stdout);}\n+#define LOG4(msg, param1, param2, param3, param4) {printf(msg, param1, param2, param3, param4);fflush(stdout);}\n+#define LOG5(msg, param1, param2, param3, param4, param5) {printf(msg, param1, param2, param3, param4, param5);fflush(stdout);}\n+\n+#define LOG_STRING_ARRAY(env, array) dump_jstring_array(env, array);\n+\n+#define ERROR0(msg) {fprintf(stderr, msg);fflush(stderr);}\n+#define ERROR1(msg, param) {fprintf(stderr, msg, param);fflush(stderr);}\n+#define ERROR2(msg, param1, param2) {fprintf(stderr, msg, param1, param2);fflush(stderr);}\n+#define ERROR3(msg, param1, param2, param3) {fprintf(stderr, msg, param1, param2, param3);fflush(stderr);}\n+#define ERROR4(msg, param1, param2, param3, param4) {fprintf(stderr, msg, param1, param2, param3, param4);fflush(stderr);}\n+#else\n+#define LOG0(msg)\n+#define LOG1(msg, param)\n+#define LOG2(msg, param1, param2)\n+#define LOG3(msg, param1, param2, param3)\n+#define LOG4(msg, param1, param2, param3, param4)\n+#define LOG5(msg, param1, param2, param3, param4, param5)\n+\n+#define LOG_STRING_ARRAY(env, array)\n+\n+#define ERROR0(msg)\n+#define ERROR1(msg, param)\n+#define ERROR2(msg, param1, param2)\n+#define ERROR3(msg, param1, param2, param3)\n+#define ERROR4(msg, param1, param2, param3, param4)\n+#endif\n+\n+#define LOG_EXCEPTION(env) check_and_clear_exception(env);\n+\n+    gchar* get_application_name();\n+    void glass_throw_exception(JNIEnv * env,\n+            const char * exceptionClass,\n+            const char * exceptionMessage);\n+    int glass_throw_oom(JNIEnv * env, const char * exceptionMessage);\n+    void dump_jstring_array(JNIEnv*, jobjectArray);\n+\n+    guint8* convert_BGRA_to_RGBA(const int* pixels, int stride, int height);\n+\n+    gboolean check_and_clear_exception(JNIEnv *env);\n+\n+    jboolean is_display_valid();\n+\n+    gsize get_files_count(gchar **uris);\n+\n+    jobject uris_to_java(JNIEnv *env, gchar **uris, gboolean files);\n+\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+extern jboolean gtk_verbose;\n+\n+void\n+glass_widget_set_visual (GtkWidget *widget, GdkVisual *visual);\n+\n+gint\n+glass_gdk_visual_get_depth (GdkVisual * visual);\n+\n+GdkScreen *\n+glass_gdk_window_get_screen(GdkWindow * gdkWindow);\n+\n+void\n+glass_gdk_master_pointer_get_position(gint *x, gint *y);\n+\n+gboolean\n+glass_gdk_device_is_grabbed(GdkDevice *device);\n+\n+GdkWindow *\n+glass_gdk_device_get_window_at_position(\n+               GdkDevice *device, gint *x, gint *y);\n+\n+void\n+glass_gtk_configure_transparency_and_realize(GtkWidget *window,\n+                                                  gboolean transparent);\n+\n+const guchar *\n+glass_gtk_selection_data_get_data_with_length(\n+        GtkSelectionData * selectionData,\n+        gint * length);\n+\n+void\n+glass_gtk_window_configure_from_visual(GtkWidget *widget, GdkVisual *visual);\n+\n+void\n+glass_gdk_window_get_size(GdkWindow *window, gint *w, gint *h);\n+\n+void\n+glass_gdk_display_get_pointer(GdkDisplay* display, gint* x, gint *y);\n+\n+void\n+glass_gdk_x11_display_set_window_scale(GdkDisplay *display, gint scale);\n+\n+gboolean\n+glass_configure_window_transparency(GtkWidget *window, gboolean transparent);\n+\n+GdkPixbuf *\n+glass_pixbuf_from_window(GdkWindow *window,\n+    gint srcx, gint srcy,\n+    gint width, gint height);\n+\n+void\n+glass_window_apply_shape_mask(GdkWindow *window,\n+    void* data, uint width, uint height);\n+\n+void\n+glass_window_reset_input_shape_mask(GdkWindow *window);\n+\n+GdkWindow *\n+glass_gdk_drag_context_get_dest_window (GdkDragContext * context);\n+\n+guint\n+glass_settings_get_guint_opt (const gchar *schema_name,\n+                    const gchar *key_name,\n+                    int defval);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif        \/* GLASS_GENERAL_H *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_general.h","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -0,0 +1,348 @@\n+\/*\n+ * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include \"glass_key.h\"\n+#include <com_sun_glass_events_KeyEvent.h>\n+#include <com_sun_glass_ui_gtk_GtkApplication.h>\n+\n+#include <glib.h>\n+#include \"glass_general.h\"\n+#include <gdk\/gdkkeysyms.h>\n+\n+static gboolean key_initialized = FALSE;\n+static GHashTable *keymap;\n+\n+static void glass_g_hash_table_insert_int(GHashTable *table, gint key, gint value)\n+{\n+    g_hash_table_insert(table, GINT_TO_POINTER(key), GINT_TO_POINTER(value));\n+}\n+\n+static void initialize_key()\n+{\n+    keymap = g_hash_table_new(g_direct_hash, g_direct_equal);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Return), com_sun_glass_events_KeyEvent_VK_ENTER);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(BackSpace), com_sun_glass_events_KeyEvent_VK_BACKSPACE);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Tab), com_sun_glass_events_KeyEvent_VK_TAB);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Clear), com_sun_glass_events_KeyEvent_VK_CLEAR); \/\/XXX what is this?\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Pause), com_sun_glass_events_KeyEvent_VK_PAUSE);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Escape), com_sun_glass_events_KeyEvent_VK_ESCAPE);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(space), com_sun_glass_events_KeyEvent_VK_SPACE);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Delete), com_sun_glass_events_KeyEvent_VK_DELETE);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Print), com_sun_glass_events_KeyEvent_VK_PRINTSCREEN); \/\/XXX is correct?\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Insert), com_sun_glass_events_KeyEvent_VK_INSERT);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Help), com_sun_glass_events_KeyEvent_VK_HELP); \/\/XXX what is this?\n+\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Shift_L), com_sun_glass_events_KeyEvent_VK_SHIFT);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Shift_R), com_sun_glass_events_KeyEvent_VK_SHIFT); \/\/XXX is this correct?\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Control_L), com_sun_glass_events_KeyEvent_VK_CONTROL);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Control_R), com_sun_glass_events_KeyEvent_VK_CONTROL);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Alt_L), com_sun_glass_events_KeyEvent_VK_ALT);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Alt_R), com_sun_glass_events_KeyEvent_VK_ALT_GRAPH);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Super_L), com_sun_glass_events_KeyEvent_VK_WINDOWS);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Super_R), com_sun_glass_events_KeyEvent_VK_WINDOWS);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Menu), com_sun_glass_events_KeyEvent_VK_CONTEXT_MENU);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Meta_L), com_sun_glass_events_KeyEvent_VK_WINDOWS);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Meta_R), com_sun_glass_events_KeyEvent_VK_CONTEXT_MENU);\/\/XXX is this correct?\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Caps_Lock), com_sun_glass_events_KeyEvent_VK_CAPS_LOCK);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Num_Lock), com_sun_glass_events_KeyEvent_VK_NUM_LOCK);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Scroll_Lock), com_sun_glass_events_KeyEvent_VK_SCROLL_LOCK);\n+\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Page_Up), com_sun_glass_events_KeyEvent_VK_PAGE_UP);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Prior), com_sun_glass_events_KeyEvent_VK_PAGE_UP);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Page_Down), com_sun_glass_events_KeyEvent_VK_PAGE_DOWN);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Next), com_sun_glass_events_KeyEvent_VK_PAGE_DOWN);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(End), com_sun_glass_events_KeyEvent_VK_END);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Home), com_sun_glass_events_KeyEvent_VK_HOME);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Left), com_sun_glass_events_KeyEvent_VK_LEFT);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Right), com_sun_glass_events_KeyEvent_VK_RIGHT);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Up), com_sun_glass_events_KeyEvent_VK_UP);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Down), com_sun_glass_events_KeyEvent_VK_DOWN);\n+\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(comma), com_sun_glass_events_KeyEvent_VK_COMMA);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(minus), com_sun_glass_events_KeyEvent_VK_MINUS);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(period), com_sun_glass_events_KeyEvent_VK_PERIOD);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(slash), com_sun_glass_events_KeyEvent_VK_SLASH);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(semicolon), com_sun_glass_events_KeyEvent_VK_SEMICOLON);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(equal), com_sun_glass_events_KeyEvent_VK_EQUALS);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(bracketleft), com_sun_glass_events_KeyEvent_VK_OPEN_BRACKET);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(bracketright), com_sun_glass_events_KeyEvent_VK_CLOSE_BRACKET);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(backslash), com_sun_glass_events_KeyEvent_VK_BACK_SLASH);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(bar), com_sun_glass_events_KeyEvent_VK_BACK_SLASH);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Multiply), com_sun_glass_events_KeyEvent_VK_MULTIPLY);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Add), com_sun_glass_events_KeyEvent_VK_ADD);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Separator), com_sun_glass_events_KeyEvent_VK_SEPARATOR);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Subtract), com_sun_glass_events_KeyEvent_VK_SUBTRACT);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Decimal), com_sun_glass_events_KeyEvent_VK_DECIMAL);\n+\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(apostrophe), com_sun_glass_events_KeyEvent_VK_QUOTE);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(grave), com_sun_glass_events_KeyEvent_VK_BACK_QUOTE);\n+\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(ampersand), com_sun_glass_events_KeyEvent_VK_AMPERSAND);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(asterisk), com_sun_glass_events_KeyEvent_VK_ASTERISK);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(quotedbl), com_sun_glass_events_KeyEvent_VK_DOUBLE_QUOTE);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(less), com_sun_glass_events_KeyEvent_VK_LESS);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(greater), com_sun_glass_events_KeyEvent_VK_GREATER);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(braceleft), com_sun_glass_events_KeyEvent_VK_BRACELEFT);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(braceright), com_sun_glass_events_KeyEvent_VK_BRACERIGHT);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(at), com_sun_glass_events_KeyEvent_VK_AT);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(colon), com_sun_glass_events_KeyEvent_VK_COLON);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(asciicircum), com_sun_glass_events_KeyEvent_VK_CIRCUMFLEX);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(dollar), com_sun_glass_events_KeyEvent_VK_DOLLAR);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(EuroSign), com_sun_glass_events_KeyEvent_VK_EURO_SIGN);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(exclam), com_sun_glass_events_KeyEvent_VK_EXCLAMATION);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(exclamdown), com_sun_glass_events_KeyEvent_VK_INV_EXCLAMATION);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(parenleft), com_sun_glass_events_KeyEvent_VK_LEFT_PARENTHESIS);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(numbersign), com_sun_glass_events_KeyEvent_VK_NUMBER_SIGN);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(plus), com_sun_glass_events_KeyEvent_VK_PLUS);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(parenright), com_sun_glass_events_KeyEvent_VK_RIGHT_PARENTHESIS);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(underscore), com_sun_glass_events_KeyEvent_VK_UNDERSCORE);\n+\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(0), com_sun_glass_events_KeyEvent_VK_0);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(1), com_sun_glass_events_KeyEvent_VK_1);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(2), com_sun_glass_events_KeyEvent_VK_2);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(3), com_sun_glass_events_KeyEvent_VK_3);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(4), com_sun_glass_events_KeyEvent_VK_4);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(5), com_sun_glass_events_KeyEvent_VK_5);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(6), com_sun_glass_events_KeyEvent_VK_6);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(7), com_sun_glass_events_KeyEvent_VK_7);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(8), com_sun_glass_events_KeyEvent_VK_8);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(9), com_sun_glass_events_KeyEvent_VK_9);\n+\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(a), com_sun_glass_events_KeyEvent_VK_A);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(b), com_sun_glass_events_KeyEvent_VK_B);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(c), com_sun_glass_events_KeyEvent_VK_C);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(d), com_sun_glass_events_KeyEvent_VK_D);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(e), com_sun_glass_events_KeyEvent_VK_E);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(f), com_sun_glass_events_KeyEvent_VK_F);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(g), com_sun_glass_events_KeyEvent_VK_G);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(h), com_sun_glass_events_KeyEvent_VK_H);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(i), com_sun_glass_events_KeyEvent_VK_I);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(j), com_sun_glass_events_KeyEvent_VK_J);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(k), com_sun_glass_events_KeyEvent_VK_K);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(l), com_sun_glass_events_KeyEvent_VK_L);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(m), com_sun_glass_events_KeyEvent_VK_M);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(n), com_sun_glass_events_KeyEvent_VK_N);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(o), com_sun_glass_events_KeyEvent_VK_O);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(p), com_sun_glass_events_KeyEvent_VK_P);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(q), com_sun_glass_events_KeyEvent_VK_Q);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(r), com_sun_glass_events_KeyEvent_VK_R);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(s), com_sun_glass_events_KeyEvent_VK_S);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(t), com_sun_glass_events_KeyEvent_VK_T);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(u), com_sun_glass_events_KeyEvent_VK_U);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(v), com_sun_glass_events_KeyEvent_VK_V);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(w), com_sun_glass_events_KeyEvent_VK_W);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(x), com_sun_glass_events_KeyEvent_VK_X);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(y), com_sun_glass_events_KeyEvent_VK_Y);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(z), com_sun_glass_events_KeyEvent_VK_Z);\n+\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(A), com_sun_glass_events_KeyEvent_VK_A);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(B), com_sun_glass_events_KeyEvent_VK_B);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(C), com_sun_glass_events_KeyEvent_VK_C);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(D), com_sun_glass_events_KeyEvent_VK_D);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(E), com_sun_glass_events_KeyEvent_VK_E);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(F), com_sun_glass_events_KeyEvent_VK_F);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(G), com_sun_glass_events_KeyEvent_VK_G);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(H), com_sun_glass_events_KeyEvent_VK_H);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(I), com_sun_glass_events_KeyEvent_VK_I);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(J), com_sun_glass_events_KeyEvent_VK_J);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(K), com_sun_glass_events_KeyEvent_VK_K);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(L), com_sun_glass_events_KeyEvent_VK_L);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(M), com_sun_glass_events_KeyEvent_VK_M);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(N), com_sun_glass_events_KeyEvent_VK_N);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(O), com_sun_glass_events_KeyEvent_VK_O);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(P), com_sun_glass_events_KeyEvent_VK_P);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Q), com_sun_glass_events_KeyEvent_VK_Q);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(R), com_sun_glass_events_KeyEvent_VK_R);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(S), com_sun_glass_events_KeyEvent_VK_S);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(T), com_sun_glass_events_KeyEvent_VK_T);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(U), com_sun_glass_events_KeyEvent_VK_U);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(V), com_sun_glass_events_KeyEvent_VK_V);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(W), com_sun_glass_events_KeyEvent_VK_W);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(X), com_sun_glass_events_KeyEvent_VK_X);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Y), com_sun_glass_events_KeyEvent_VK_Y);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(Z), com_sun_glass_events_KeyEvent_VK_Z);\n+\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_0), com_sun_glass_events_KeyEvent_VK_NUMPAD0);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_1), com_sun_glass_events_KeyEvent_VK_NUMPAD1);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_2), com_sun_glass_events_KeyEvent_VK_NUMPAD2);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_3), com_sun_glass_events_KeyEvent_VK_NUMPAD3);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_4), com_sun_glass_events_KeyEvent_VK_NUMPAD4);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_5), com_sun_glass_events_KeyEvent_VK_NUMPAD5);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_6), com_sun_glass_events_KeyEvent_VK_NUMPAD6);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_7), com_sun_glass_events_KeyEvent_VK_NUMPAD7);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_8), com_sun_glass_events_KeyEvent_VK_NUMPAD8);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_9), com_sun_glass_events_KeyEvent_VK_NUMPAD9);\n+\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Enter), com_sun_glass_events_KeyEvent_VK_ENTER);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Home), com_sun_glass_events_KeyEvent_VK_HOME);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Left), com_sun_glass_events_KeyEvent_VK_LEFT);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Up), com_sun_glass_events_KeyEvent_VK_UP);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Right), com_sun_glass_events_KeyEvent_VK_RIGHT);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Down), com_sun_glass_events_KeyEvent_VK_DOWN);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Prior), com_sun_glass_events_KeyEvent_VK_PAGE_UP);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Page_Up), com_sun_glass_events_KeyEvent_VK_PAGE_UP);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Next), com_sun_glass_events_KeyEvent_VK_PAGE_DOWN);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Page_Down), com_sun_glass_events_KeyEvent_VK_PAGE_DOWN);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_End), com_sun_glass_events_KeyEvent_VK_END);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Insert), com_sun_glass_events_KeyEvent_VK_INSERT);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Delete), com_sun_glass_events_KeyEvent_VK_DELETE);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Divide), com_sun_glass_events_KeyEvent_VK_DIVIDE);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Begin),\n+            com_sun_glass_events_KeyEvent_VK_CLEAR); \/\/ 5 key on keypad with Num Lock turned off\n+\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(F1), com_sun_glass_events_KeyEvent_VK_F1);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(F2), com_sun_glass_events_KeyEvent_VK_F2);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(F3), com_sun_glass_events_KeyEvent_VK_F3);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(F4), com_sun_glass_events_KeyEvent_VK_F4);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(F5), com_sun_glass_events_KeyEvent_VK_F5);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(F6), com_sun_glass_events_KeyEvent_VK_F6);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(F7), com_sun_glass_events_KeyEvent_VK_F7);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(F8), com_sun_glass_events_KeyEvent_VK_F8);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(F9), com_sun_glass_events_KeyEvent_VK_F9);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(F10), com_sun_glass_events_KeyEvent_VK_F10);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(F11), com_sun_glass_events_KeyEvent_VK_F11);\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(F12), com_sun_glass_events_KeyEvent_VK_F12);\n+}\n+\n+static void init_keymap() {\n+    if (!key_initialized) {\n+        initialize_key();\n+        key_initialized = TRUE;\n+    }\n+}\n+\n+jint gdk_keyval_to_glass(guint keyval)\n+{\n+    init_keymap();\n+    return GPOINTER_TO_INT(g_hash_table_lookup(keymap, GINT_TO_POINTER(keyval)));\n+}\n+\n+jint get_glass_key(GdkEventKey* e) {\n+    init_keymap();\n+\n+    guint keyValue;\n+    guint state = e->state & GDK_MOD2_MASK; \/\/NumLock test\n+\n+    gdk_keymap_translate_keyboard_state(gdk_keymap_get_for_display(gdk_display_get_default()),\n+            e->hardware_keycode, static_cast<GdkModifierType>(state), e->group,\n+            &keyValue, NULL, NULL, NULL);\n+\n+    jint key = GPOINTER_TO_INT(g_hash_table_lookup(keymap,\n+            GINT_TO_POINTER(keyValue)));\n+\n+    if (!key) {\n+        \/\/ We failed to find a keyval in our keymap, this may happen with\n+        \/\/ non-latin layouts(e.g. Cyrillic). So here we try to find a keyval\n+        \/\/ from a default layout(we assume that it is a US-like one).\n+        GdkKeymapKey kk;\n+        kk.keycode = e->hardware_keycode;\n+        kk.group = kk.level = 0;\n+\n+        keyValue = gdk_keymap_lookup_key(gdk_keymap_get_for_display(gdk_display_get_default()), &kk);\n+\n+        key = GPOINTER_TO_INT(g_hash_table_lookup(keymap,\n+                GINT_TO_POINTER(keyValue)));\n+    }\n+\n+    return key;\n+}\n+\n+gint find_gdk_keyval_for_glass_keycode(jint code) {\n+    gint result = -1;\n+    GHashTableIter iter;\n+    gpointer key, value;\n+    init_keymap();\n+    g_hash_table_iter_init(&iter, keymap);\n+    while (g_hash_table_iter_next(&iter, &key, &value)) {\n+        if (code == GPOINTER_TO_INT(value)) {\n+            result = GPOINTER_TO_INT(key);\n+            break;\n+        }\n+    }\n+    return result;\n+}\n+\n+jint gdk_modifier_mask_to_glass(guint mask)\n+{\n+    jint glass_mask = 0;\n+    glass_mask |= (mask & GDK_SHIFT_MASK) ? com_sun_glass_events_KeyEvent_MODIFIER_SHIFT : 0;\n+    glass_mask |= (mask & GDK_CONTROL_MASK) ? com_sun_glass_events_KeyEvent_MODIFIER_CONTROL : 0;\n+    glass_mask |= (mask & GDK_MOD1_MASK) ? com_sun_glass_events_KeyEvent_MODIFIER_ALT : 0;\n+    glass_mask |= (mask & GDK_META_MASK) ? com_sun_glass_events_KeyEvent_MODIFIER_ALT : 0; \/\/ XXX: is this OK?\n+    glass_mask |= (mask & GDK_BUTTON1_MASK) ? com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_PRIMARY : 0;\n+    glass_mask |= (mask & GDK_BUTTON2_MASK) ? com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_MIDDLE : 0;\n+    glass_mask |= (mask & GDK_BUTTON3_MASK) ? com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_SECONDARY : 0;\n+    glass_mask |= (mask & GDK_BUTTON4_MASK) ? com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_BACK : 0;\n+    glass_mask |= (mask & GDK_BUTTON5_MASK) ? com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_FORWARD : 0;\n+    glass_mask |= (mask & GDK_SUPER_MASK) ? com_sun_glass_events_KeyEvent_MODIFIER_WINDOWS : 0; \/\/ XXX: is this OK?\n+\n+    return glass_mask;\n+}\n+\n+jint glass_key_to_modifier(jint glassKey) {\n+    switch (glassKey) {\n+        case com_sun_glass_events_KeyEvent_VK_SHIFT:\n+            return com_sun_glass_events_KeyEvent_MODIFIER_SHIFT;\n+        case com_sun_glass_events_KeyEvent_VK_ALT:\n+        case com_sun_glass_events_KeyEvent_VK_ALT_GRAPH:\n+            return com_sun_glass_events_KeyEvent_MODIFIER_ALT;\n+        case com_sun_glass_events_KeyEvent_VK_CONTROL:\n+            return com_sun_glass_events_KeyEvent_MODIFIER_CONTROL;\n+        case com_sun_glass_events_KeyEvent_VK_WINDOWS:\n+            return com_sun_glass_events_KeyEvent_MODIFIER_WINDOWS;\n+        default:\n+            return 0;\n+    }\n+}\n+extern \"C\" {\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    _getKeyCodeForChar\n+ * Signature: (C)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkApplication__1getKeyCodeForChar\n+  (JNIEnv *env, jobject jApplication, jchar character)\n+{\n+    (void)env;\n+    (void)jApplication;\n+\n+    gunichar *ucs_char = g_utf16_to_ucs4(&character, 1, NULL, NULL, NULL);\n+    if (ucs_char == NULL) {\n+        return com_sun_glass_events_KeyEvent_VK_UNDEFINED;\n+    }\n+\n+    guint keyval = gdk_unicode_to_keyval(*ucs_char);\n+\n+    if (keyval == (*ucs_char | 0x01000000)) {\n+        g_free(ucs_char);\n+        return com_sun_glass_events_KeyEvent_VK_UNDEFINED;\n+    }\n+\n+    g_free(ucs_char);\n+\n+    return gdk_keyval_to_glass(keyval);\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_key.cpp","additions":348,"deletions":0,"binary":false,"changes":348,"status":"added"},{"patch":"","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_key.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_key.h","status":"copied"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+\n+#include \"glass_screen.h\"\n+#include \"glass_general.h\"\n+\n+#include <X11\/Xatom.h>\n+#include <gdk\/gdk.h>\n+#include <gdk\/gdkx.h>\n+\n+jfloat OverrideUIScale = -1.0f;\n+\n+static guint get_current_desktop(GdkScreen *screen) {\n+    Display* display = gdk_x11_display_get_xdisplay(gdk_display_get_default());\n+    Atom currentDesktopAtom = XInternAtom(display, \"_NET_CURRENT_DESKTOP\", True);\n+    guint ret = 0;\n+\n+    Atom type;\n+    int format;\n+    gulong num, left;\n+    unsigned long *data = NULL;\n+\n+    if (currentDesktopAtom == None) {\n+        return 0;\n+    }\n+\n+    int result = XGetWindowProperty(display,\n+                                    GDK_WINDOW_XID(gdk_screen_get_root_window(screen)),\n+                                    currentDesktopAtom, 0, G_MAXLONG, False, XA_CARDINAL,\n+                                    &type, &format, &num, &left, (unsigned char **)&data);\n+\n+    if ((result == Success) && (data != NULL)) {\n+        if (type == XA_CARDINAL && format == 32) {\n+            ret = data[0];\n+        }\n+\n+        XFree(data);\n+    }\n+\n+    return ret;\n+\n+}\n+\n+static GdkRectangle get_screen_workarea(GdkScreen *screen) {\n+    GdkDisplay * gdk_display = gdk_screen_get_display(screen);\n+    Display* display = gdk_x11_display_get_xdisplay(gdk_display);\n+\n+    int w = gdk_screen_get_width(screen);\n+    int h = gdk_screen_get_height(screen);\n+\n+    GdkRectangle ret = { 0, 0, w, h };\n+\n+    Atom workareaAtom = XInternAtom(display, \"_NET_WORKAREA\", True);\n+\n+    Atom type;\n+    int format;\n+    gulong num, left;\n+    unsigned long *data = NULL;\n+\n+    if (workareaAtom == None) {\n+        return ret;\n+    }\n+\n+    int result = XGetWindowProperty(display,\n+                                    GDK_WINDOW_XID(gdk_screen_get_root_window(screen)),\n+                                    workareaAtom, 0, G_MAXLONG, False, AnyPropertyType,\n+                                    &type, &format, &num, &left, (unsigned char **)&data);\n+\n+    if ((result == Success) && (data != NULL)) {\n+        if (type != None && format == 32) {\n+            guint current_desktop = get_current_desktop(screen);\n+            if (current_desktop < num \/ 4) {\n+                ret.x = data[current_desktop * 4];\n+                ret.y = data[current_desktop * 4 + 1];\n+                ret.width = data[current_desktop * 4 + 2];\n+                ret.height = data[current_desktop * 4 + 3];\n+            }\n+        }\n+\n+        XFree(data);\n+    }\n+\n+    return ret;\n+\n+}\n+\n+jfloat getUIScale() {\n+    jfloat uiScale;\n+    if (OverrideUIScale > 0.0f) {\n+        uiScale = OverrideUIScale;\n+    } else {\n+        char *scale_str = getenv(\"GDK_SCALE\");\n+        int gdk_scale = (scale_str == NULL) ? -1 : atoi(scale_str);\n+        if (gdk_scale > 0) {\n+            uiScale = (jfloat) gdk_scale;\n+        } else {\n+            uiScale = (jfloat) glass_settings_get_guint_opt(\"org.gnome.desktop.interface\",\n+                                                            \"scaling-factor\", 0);\n+            if (uiScale < 1) {\n+                uiScale = 1;\n+            }\n+        }\n+    }\n+    return uiScale;\n+}\n+\n+static jobject createJavaScreen(JNIEnv* env, GdkScreen* screen, gint monitor_idx)\n+{\n+    GdkRectangle workArea = get_screen_workarea(screen);\n+    LOG4(\"Work Area: x:%d, y:%d, w:%d, h:%d\\n\", workArea.x, workArea.y, workArea.width, workArea.height);\n+\n+    GdkRectangle monitor_geometry;\n+    gdk_screen_get_monitor_geometry(screen, monitor_idx, &monitor_geometry);\n+\n+    LOG1(\"convert monitor[%d] -> glass Screen\\n\", monitor_idx)\n+    LOG4(\"[x: %d y: %d w: %d h: %d]\\n\",\n+         monitor_geometry.x, monitor_geometry.y,\n+         monitor_geometry.width, monitor_geometry.height)\n+\n+    GdkVisual* visual = gdk_screen_get_system_visual(screen);\n+\n+    GdkRectangle working_monitor_geometry;\n+    gdk_rectangle_intersect(&workArea, &monitor_geometry, &working_monitor_geometry);\n+\n+    jfloat uiScale = getUIScale();\n+\n+    jint mx = monitor_geometry.x \/ uiScale;\n+    jint my = monitor_geometry.y \/ uiScale;\n+    jint mw = monitor_geometry.width \/ uiScale;\n+    jint mh = monitor_geometry.height \/ uiScale;\n+    jint wx = working_monitor_geometry.x \/ uiScale;\n+    jint wy = working_monitor_geometry.y \/ uiScale;\n+    jint ww = working_monitor_geometry.width \/ uiScale;\n+    jint wh = working_monitor_geometry.height \/ uiScale;\n+\n+    gint mmW = gdk_screen_get_monitor_width_mm(screen, monitor_idx);\n+    gint mmH = gdk_screen_get_monitor_height_mm(screen, monitor_idx);\n+\n+    if (mmW <= 0 || mmH <= 0) {\n+        if (gdk_screen_get_n_monitors(screen) == 1) {\n+            mmW = gdk_screen_get_width_mm(screen);\n+            mmH = gdk_screen_get_height_mm(screen);\n+        }\n+    }\n+    jint dpiX, dpiY;\n+    if (mmW <= 0 || mmH <= 0) {\n+        dpiX = dpiY = 96;\n+    } else {\n+        dpiX = (mw * 254) \/ (mmW * 10);\n+        dpiY = (mh * 254) \/ (mmH * 10);\n+    }\n+\n+    jobject jScreen = env->NewObject(jScreenCls, jScreenInit,\n+                                     (jlong)monitor_idx,\n+\n+                                     (visual ? glass_gdk_visual_get_depth(visual) : 0),\n+\n+                                     mx, my, mw, mh,\n+\n+                                     monitor_geometry.x,\n+                                     monitor_geometry.y,\n+                                     monitor_geometry.width,\n+                                     monitor_geometry.height,\n+\n+                                     wx, wy, ww, wh,\n+\n+                                     dpiX, dpiY,\n+                                     uiScale, uiScale, uiScale, uiScale);\n+\n+    JNI_EXCEPTION_TO_CPP(env);\n+    return jScreen;\n+}\n+\n+jobject createJavaScreen(JNIEnv* env, gint monitor_idx) {\n+    GdkScreen *default_gdk_screen = gdk_screen_get_default();\n+    try {\n+        return createJavaScreen(env, default_gdk_screen, monitor_idx);\n+    } catch (jni_exception&) {\n+        return NULL;\n+    }\n+}\n+\n+jobjectArray rebuild_screens(JNIEnv* env) {\n+    GdkScreen *default_gdk_screen = gdk_screen_get_default();\n+\n+    gint n_monitors = gdk_screen_get_n_monitors(default_gdk_screen);\n+\n+    jobjectArray jscreens = env->NewObjectArray(n_monitors, jScreenCls, NULL);\n+    JNI_EXCEPTION_TO_CPP(env)\n+    LOG1(\"Available monitors: %d\\n\", n_monitors)\n+\n+    int i;\n+    for (i=0; i < n_monitors; i++) {\n+        env->SetObjectArrayElement(jscreens, i, createJavaScreen(env, default_gdk_screen, i));\n+        JNI_EXCEPTION_TO_CPP(env)\n+    }\n+\n+    return jscreens;\n+}\n+\n+\n+glong getScreenPtrForLocation(gint x, gint y) {\n+    \/\/Note: we are relying on the fact that javafx_screen_id == gdk_monitor_id\n+    return gdk_screen_get_monitor_at_point(gdk_screen_get_default(), x, y);\n+}\n+\n+void screen_settings_changed(GdkScreen* screen, gpointer user_data) {\n+    (void)screen;\n+    (void)user_data;\n+\n+    mainEnv->CallStaticVoidMethod(jScreenCls, jScreenNotifySettingsChanged);\n+    LOG_EXCEPTION(mainEnv);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_screen.cpp","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_screen.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_screen.h","status":"copied"},{"patch":"","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_view.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_view.h","status":"copied"},{"patch":"@@ -0,0 +1,1492 @@\n+\/*\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include \"glass_window.h\"\n+#include \"glass_key.h\"\n+#include \"glass_screen.h\"\n+#include \"glass_dnd.h\"\n+\n+#include <com_sun_glass_events_WindowEvent.h>\n+#include <com_sun_glass_events_ViewEvent.h>\n+#include <com_sun_glass_events_MouseEvent.h>\n+#include <com_sun_glass_events_KeyEvent.h>\n+\n+#include <com_sun_glass_ui_Window_Level.h>\n+\n+#include <X11\/extensions\/shape.h>\n+#include <cairo.h>\n+#include <cairo-xlib.h>\n+#include <gdk\/gdkx.h>\n+#include <gdk\/gdk.h>\n+\n+#ifdef GLASS_GTK3\n+#include <gtk\/gtkx.h>\n+#endif\n+\n+#include <string.h>\n+\n+#include <algorithm>\n+\n+#define MOUSE_BACK_BTN 8\n+#define MOUSE_FORWARD_BTN 9\n+\n+static gboolean ctx_configure_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {\n+    ((WindowContext *) user_data)->process_configure();\n+    return FALSE;\n+}\n+\n+static gboolean ctx_property_notify_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {\n+    ((WindowContext *) user_data)->process_property_notify(&event->property);\n+    return TRUE;\n+}\n+\n+static gboolean ctx_focus_change_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {\n+    ((WindowContext *) user_data)->process_focus(&event->focus_change);\n+    return TRUE;\n+}\n+\n+static gboolean ctx_delete_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {\n+    ((WindowContext *) user_data)->process_delete();\n+    return TRUE;\n+}\n+\n+static gboolean ctx_window_state_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {\n+    ((WindowContext *) user_data)->process_state(&event->window_state);\n+    return FALSE;\n+}\n+\n+static gboolean ctx_device_button_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {\n+    ((WindowContext *) user_data)->process_mouse_button(&event->button);\n+    return TRUE;\n+}\n+\n+static gboolean ctx_device_motion_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {\n+    ((WindowContext *) user_data)->process_mouse_motion(&event->motion);\n+    return TRUE;\n+}\n+\n+static gboolean ctx_device_scroll_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {\n+    ((WindowContext *) user_data)->process_mouse_scroll(&event->scroll);\n+    return TRUE;\n+}\n+\n+static gboolean ctx_enter_or_leave_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {\n+    ((WindowContext *) user_data)->process_mouse_cross(&event->crossing);\n+    return TRUE;\n+}\n+\n+static gboolean ctx_key_press_or_release_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {\n+    ((WindowContext *) user_data)->process_key(&event->key);\n+    return TRUE;\n+}\n+\n+static gboolean ctx_map_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {\n+    ((WindowContext *) user_data)->process_map();\n+    return TRUE;\n+}\n+\n+static void ctx_screen_changed_callback(GtkWidget *widget,\n+                                        GdkScreen *previous_screen,\n+                                        gpointer user_data) {\n+    ((WindowContext *) user_data)->process_screen_changed();\n+}\n+\n+static void connect_signals(GtkWidget *gtk_widget, WindowContext *ctx) {\n+    g_signal_connect(gtk_widget, \"configure-event\", G_CALLBACK(ctx_configure_callback), ctx);\n+    g_signal_connect(gtk_widget, \"property-notify-event\", G_CALLBACK(ctx_property_notify_callback), ctx);\n+    g_signal_connect(gtk_widget, \"focus-in-event\", G_CALLBACK(ctx_focus_change_callback), ctx);\n+    g_signal_connect(gtk_widget, \"focus-out-event\", G_CALLBACK(ctx_focus_change_callback), ctx);\n+    g_signal_connect(gtk_widget, \"delete-event\", G_CALLBACK(ctx_delete_callback), ctx);\n+    g_signal_connect(gtk_widget, \"window-state-event\", G_CALLBACK(ctx_window_state_callback), ctx);\n+    g_signal_connect(gtk_widget, \"button-press-event\", G_CALLBACK(ctx_device_button_callback), ctx);\n+    g_signal_connect(gtk_widget, \"button-release-event\", G_CALLBACK(ctx_device_button_callback), ctx);\n+    g_signal_connect(gtk_widget, \"motion-notify-event\", G_CALLBACK(ctx_device_motion_callback), ctx);\n+    g_signal_connect(gtk_widget, \"scroll-event\", G_CALLBACK(ctx_device_scroll_callback), ctx);\n+    g_signal_connect(gtk_widget, \"enter-notify-event\", G_CALLBACK(ctx_enter_or_leave_callback), ctx);\n+    g_signal_connect(gtk_widget, \"leave-notify-event\", G_CALLBACK(ctx_enter_or_leave_callback), ctx);\n+    g_signal_connect(gtk_widget, \"key-press-event\", G_CALLBACK(ctx_key_press_or_release_callback), ctx);\n+    g_signal_connect(gtk_widget, \"key-release-event\", G_CALLBACK(ctx_key_press_or_release_callback), ctx);\n+    g_signal_connect(gtk_widget, \"map-event\", G_CALLBACK(ctx_map_callback), ctx);\n+    g_signal_connect(gtk_widget, \"screen-changed\", G_CALLBACK(ctx_screen_changed_callback), ctx);\n+}\n+\n+\n+void destroy_and_delete_ctx(WindowContext *ctx) {\n+    if (ctx) {\n+        ctx->process_destroy();\n+\n+        if (!ctx->get_events_count()) {\n+            delete ctx;\n+        }\n+        \/\/ else: ctx will be deleted in EventsCounterHelper after completing\n+        \/\/ an event processing\n+    }\n+}\n+\n+static inline jint gtk_button_number_to_mouse_button(guint button) {\n+    switch (button) {\n+        case 1:\n+            return com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n+        case 2:\n+            return com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n+        case 3:\n+            return com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n+        case MOUSE_BACK_BTN:\n+            return com_sun_glass_events_MouseEvent_BUTTON_BACK;\n+        case MOUSE_FORWARD_BTN:\n+            return com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n+        default:\n+            \/\/ Other buttons are not supported by quantum and are not reported by other platforms\n+            return com_sun_glass_events_MouseEvent_BUTTON_NONE;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ WindowContext \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string(\"_NET_WM_STATE\");\n+static GdkAtom atom_net_wm_frame_extents = gdk_atom_intern_static_string(\"_NET_FRAME_EXTENTS\");\n+\n+WindowContext * WindowContext::sm_mouse_drag_window = NULL;\n+WindowContext * WindowContext::sm_grab_window = NULL;\n+\n+WindowContext::WindowContext(jobject _jwindow, WindowContext *_owner, long _screen,\n+                                   WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :\n+        screen(_screen),\n+        frame_type(_frame_type),\n+        window_type(type),\n+        owner(_owner),\n+        jview(NULL),\n+        map_received(false),\n+        visible_received(false),\n+        on_top(false),\n+        is_fullscreen(false),\n+        is_iconified(false),\n+        is_maximized(false),\n+        is_mouse_entered(false),\n+        can_be_deleted(false),\n+        events_processing_cnt(0),\n+        grab_pointer(NULL) {\n+\n+    jwindow = mainEnv->NewGlobalRef(_jwindow);\n+\n+    gtk_widget = gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);\n+\n+    \/\/ This allows to group Windows (based on WM_CLASS). Use the fully qualified\n+    \/\/ JavaFX Application class as StartupWMClass on the .desktop launcher\n+    if (gchar * app_name = get_application_name()) {\n+        gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);\n+        g_free(app_name);\n+    }\n+\n+    if (owner) {\n+        owner->add_child(this);\n+        if (on_top_inherited()) {\n+            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n+        }\n+    }\n+\n+    if (type == UTILITY) {\n+        gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);\n+    }\n+\n+    glong xvisualID = (glong) mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);\n+\n+    if (xvisualID != 0) {\n+        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);\n+        glass_gtk_window_configure_from_visual(gtk_widget, visual);\n+    }\n+\n+    gtk_widget_set_events(gtk_widget, GDK_ALL_EVENTS_MASK);\n+    gtk_widget_set_app_paintable(gtk_widget, TRUE);\n+\n+    glass_gtk_configure_transparency_and_realize(gtk_widget, frame_type == TRANSPARENT);\n+    gtk_window_set_title(GTK_WINDOW(gtk_widget), \"\");\n+\n+    gdk_window = gtk_widget_get_window(gtk_widget);\n+    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);\n+\n+    glass_dnd_attach_context(this);\n+\n+    gdk_windowManagerFunctions = wmf;\n+    if (wmf) {\n+        gdk_window_set_functions(gdk_window, wmf);\n+    }\n+\n+    if (frame_type != TITLED) {\n+        gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);\n+    }\n+\n+    connect_signals(gtk_widget, this);\n+}\n+\n+void WindowContext::paint(void *data, jint width, jint height) {\n+#ifdef GLASS_GTK3\n+    cairo_region_t *region = gdk_window_get_clip_region(gdk_window);\n+    gdk_window_begin_paint_region(gdk_window, region);\n+    cairo_t* context = gdk_cairo_create(gdk_window);\n+#else\n+    cairo_t *context = gdk_cairo_create(gdk_window);\n+#endif\n+\n+    if (bg_color.is_set) {\n+        cairo_set_source_rgba(context, bg_color.red, bg_color.green, bg_color.blue,\n+                                (frame_type == TRANSPARENT) ? 0 : 1);\n+        cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);\n+        cairo_paint(context);\n+    }\n+\n+    cairo_surface_t *cairo_surface;\n+    cairo_surface = cairo_image_surface_create_for_data(\n+            (unsigned char *) data,\n+            CAIRO_FORMAT_ARGB32,\n+            width, height, width * 4);\n+\n+    cairo_set_source_surface(context, cairo_surface, 0, 0);\n+\n+    applyShapeMask(data, width, height);\n+    cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);\n+    cairo_paint(context);\n+\n+#ifdef GLASS_GTK3\n+    gdk_window_end_paint(gdk_window);\n+    cairo_region_destroy(region);\n+    cairo_destroy(context);\n+#else\n+    cairo_destroy(context);\n+#endif\n+\n+    cairo_surface_destroy(cairo_surface);\n+}\n+\n+bool WindowContext::isEnabled() {\n+    if (jwindow) {\n+        bool result = (JNI_TRUE == mainEnv->CallBooleanMethod(jwindow, jWindowIsEnabled));\n+        LOG_EXCEPTION(mainEnv)\n+        return result;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+GdkWindow *WindowContext::get_gdk_window() {\n+    return gdk_window;\n+}\n+\n+GtkWidget *WindowContext::get_gtk_widget() {\n+    return gtk_widget;\n+}\n+\n+GtkWindow *WindowContext::get_gtk_window() {\n+    return GTK_WINDOW(gtk_widget);\n+}\n+\n+WindowGeometry WindowContext::get_geometry() {\n+    return geometry;\n+}\n+\n+jobject WindowContext::get_jwindow() {\n+    return jwindow;\n+}\n+\n+jobject WindowContext::get_jview() {\n+    return jview;\n+}\n+\n+void WindowContext::process_map() {\n+    map_received = true;\n+    calculate_adjustments();\n+    apply_geometry();\n+}\n+\n+void WindowContext::process_focus(GdkEventFocus *event) {\n+    if (!event->in && WindowContext::sm_mouse_drag_window == this) {\n+        ungrab_mouse_drag_focus();\n+    }\n+\n+    if (!event->in && WindowContext::sm_grab_window == this) {\n+        ungrab_focus();\n+    }\n+\n+    if (xim.enabled && xim.ic) {\n+        if (event->in) {\n+            XSetICFocus(xim.ic);\n+        } else {\n+            XUnsetICFocus(xim.ic);\n+        }\n+    }\n+\n+    if (jwindow) {\n+        if (!event->in || isEnabled()) {\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus,\n+                                    event->in ? com_sun_glass_events_WindowEvent_FOCUS_GAINED\n+                                              : com_sun_glass_events_WindowEvent_FOCUS_LOST);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        } else {\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusDisabled);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+    }\n+}\n+\n+void WindowContext::process_property_notify(GdkEventProperty *event) {\n+    if (event->window == gdk_window) {\n+        \/\/ This work-around is only necessary for Unity\n+        if (event->atom == atom_net_wm_state) {\n+            process_net_wm_property();\n+        } else if (event->atom == atom_net_wm_frame_extents) {\n+            if (frame_type != TITLED) {\n+                return;\n+            }\n+\n+            int top, left, bottom, right;\n+\n+            if (get_frame_extents_property(&top, &left, &bottom, &right)) {\n+                if (top + left + bottom + right > 0) {\n+                    geometry.frame_extents_received = true;\n+                    geometry.adjust_w = left + right;\n+                    geometry.adjust_h = top + bottom;\n+                    geometry.view_x = left;\n+                    geometry.view_y = top;\n+\n+                    \/\/ set bounds again to set to correct window size that must\n+                    \/\/ be the total width and height accounting extents\n+                    \/\/ this is ignored if size is \"content size\" instead of \"window size\"\n+                    if (geometry.needs_ajustment) {\n+                        set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);\n+                    }\n+\n+                    \/\/ force position notify so java will know about view_y and view_x\n+                    size_position_notify(false, true);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void WindowContext::process_configure() {\n+    gint x, y, w, h, gtk_w, gtk_h;\n+\n+    gtk_window_get_position(GTK_WINDOW(gtk_widget), &x, &y);\n+    gtk_window_get_size(GTK_WINDOW(gtk_widget), &gtk_w, &gtk_h);\n+\n+    w = gtk_w + geometry.adjust_w;\n+    h = gtk_h + geometry.adjust_h;\n+\n+    gboolean pos_changed = geometry.current_x != x || geometry.current_y != y;\n+    gboolean size_changed = geometry.current_w != w || geometry.current_h != h\n+                            || geometry.current_cw != gtk_w || geometry.current_ch != gtk_h;\n+\n+    geometry.current_x = x;\n+    geometry.current_y = y;\n+    geometry.current_w = w;\n+    geometry.current_h = h;\n+    geometry.current_cw = gtk_w;\n+    geometry.current_ch = gtk_h;\n+\n+    if (!is_fullscreen && !is_maximized) {\n+        geometry.last_cw = gtk_w;\n+        geometry.last_ch = gtk_h;\n+    }\n+\n+    size_position_notify(size_changed, pos_changed);\n+}\n+\n+void WindowContext::process_destroy() {\n+    if (owner) {\n+        owner->remove_child(this);\n+    }\n+\n+    if (WindowContext::sm_mouse_drag_window == this) {\n+        ungrab_mouse_drag_focus();\n+    }\n+\n+    if (WindowContext::sm_grab_window == this) {\n+        ungrab_focus();\n+    }\n+\n+    std::set<WindowContext *>::iterator it;\n+    for (it = children.begin(); it != children.end(); ++it) {\n+        \/\/ FIX JDK-8226537: this method calls set_owner(NULL) which prevents\n+        \/\/ WindowContext::process_destroy() to call remove_child() (because children\n+        \/\/ is being iterated here) but also prevents gtk_window_set_transient_for from\n+        \/\/ being called - this causes the crash on gnome.\n+        gtk_window_set_transient_for((*it)->get_gtk_window(), NULL);\n+        (*it)->set_owner(NULL);\n+        destroy_and_delete_ctx(*it);\n+    }\n+    children.clear();\n+\n+    if (jwindow) {\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyDestroy);\n+        EXCEPTION_OCCURED(mainEnv);\n+    }\n+\n+    if (jview) {\n+        mainEnv->DeleteGlobalRef(jview);\n+        jview = NULL;\n+    }\n+\n+    if (jwindow) {\n+        mainEnv->DeleteGlobalRef(jwindow);\n+        jwindow = NULL;\n+    }\n+\n+    can_be_deleted = true;\n+}\n+\n+void WindowContext::process_delete() {\n+    if (jwindow && isEnabled()) {\n+        gtk_widget_hide_on_delete(gtk_widget);\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyClose);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n+\n+void WindowContext::process_expose(GdkEventExpose *event) {\n+    if (jview && is_visible()) {\n+        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, event->area.x, event->area.y,\n+                                event->area.width, event->area.height);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n+\n+void WindowContext::process_mouse_button(GdkEventButton *event) {\n+    \/\/ there are other events like GDK_2BUTTON_PRESS\n+    if (event->type != GDK_BUTTON_PRESS && event->type != GDK_BUTTON_RELEASE) {\n+        return;\n+    }\n+\n+    bool press = event->type == GDK_BUTTON_PRESS;\n+\n+    guint state = event->state;\n+    guint mask = 0;\n+\n+    \/\/ We need to add\/remove current mouse button from the modifier flags\n+    \/\/ as X lib state represents the state just prior to the event and\n+    \/\/ glass needs the state just after the event\n+    switch (event->button) {\n+        case 1:\n+            mask = GDK_BUTTON1_MASK;\n+            break;\n+        case 2:\n+            mask = GDK_BUTTON2_MASK;\n+            break;\n+        case 3:\n+            mask = GDK_BUTTON3_MASK;\n+            break;\n+        case MOUSE_BACK_BTN:\n+            mask = GDK_BUTTON4_MASK;\n+            break;\n+        case MOUSE_FORWARD_BTN:\n+            mask = GDK_BUTTON5_MASK;\n+            break;\n+    }\n+\n+    if (press) {\n+        state |= mask;\n+    } else {\n+        state &= ~mask;\n+    }\n+\n+    if (press) {\n+        GdkDevice* device = event->device;\n+\n+        if (glass_gdk_device_is_grabbed(device)\n+                && (glass_gdk_device_get_window_at_position(device, NULL, NULL)\n+                == NULL)) {\n+            ungrab_focus();\n+            return;\n+        }\n+\n+        \/\/ Upper layers expects from us Windows behavior:\n+        \/\/ all mouse events should be delivered to window where drag begins\n+        \/\/ and no exit\/enter event should be reported during this drag.\n+        \/\/ We can grab mouse pointer for these needs.\n+        grab_mouse_drag_focus(gdk_window, (GdkEvent *) event, NULL, true);\n+    } else {\n+        if ((event->state & MOUSE_BUTTONS_MASK)\n+            && !(state & MOUSE_BUTTONS_MASK)) { \/\/ all buttons released\n+            ungrab_mouse_drag_focus();\n+        } else if (event->button == 8 || event->button == 9) {\n+            \/\/ GDK X backend interprets button press events for buttons 4-7 as\n+            \/\/ scroll events so GDK_BUTTON4_MASK and GDK_BUTTON5_MASK will never\n+            \/\/ be set on the event->state from GDK. Thus we cannot check if all\n+            \/\/ buttons have been released in the usual way (as above).\n+            ungrab_mouse_drag_focus();\n+        }\n+    }\n+\n+    bool is_popup_trigger = (event->button == 3);\n+    jint button = gtk_button_number_to_mouse_button(event->button);\n+\n+    if (jview && button != com_sun_glass_events_MouseEvent_BUTTON_NONE) {\n+        mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+                                press ? com_sun_glass_events_MouseEvent_DOWN : com_sun_glass_events_MouseEvent_UP,\n+                                button,\n+                                (jint) event->x, (jint) event->y,\n+                                (jint) event->x_root, (jint) event->y_root,\n+                                gdk_modifier_mask_to_glass(state),\n+                                (is_popup_trigger) ? JNI_TRUE : JNI_FALSE,\n+                                JNI_FALSE);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+\n+        if (jview && is_popup_trigger) {\n+            mainEnv->CallVoidMethod(jview, jViewNotifyMenu,\n+                                    (jint) event->x, (jint) event->y,\n+                                    (jint) event->x_root, (jint) event->y_root,\n+                                    JNI_FALSE);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+    }\n+}\n+\n+void WindowContext::process_mouse_motion(GdkEventMotion *event) {\n+    jint glass_modifier = gdk_modifier_mask_to_glass(event->state);\n+    jint isDrag = glass_modifier & (\n+            com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_PRIMARY |\n+            com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_MIDDLE |\n+            com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_SECONDARY |\n+            com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_BACK |\n+            com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_FORWARD);\n+    jint button = com_sun_glass_events_MouseEvent_BUTTON_NONE;\n+\n+    if (glass_modifier & com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_PRIMARY) {\n+        button = com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n+    } else if (glass_modifier & com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_MIDDLE) {\n+        button = com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n+    } else if (glass_modifier & com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_SECONDARY) {\n+        button = com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n+    } else if (glass_modifier & com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_BACK) {\n+        button = com_sun_glass_events_MouseEvent_BUTTON_BACK;\n+    } else if (glass_modifier & com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_FORWARD) {\n+        button = com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n+    }\n+\n+    if (jview) {\n+        mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+                                isDrag ? com_sun_glass_events_MouseEvent_DRAG : com_sun_glass_events_MouseEvent_MOVE,\n+                                button,\n+                                (jint) event->x, (jint) event->y,\n+                                (jint) event->x_root, (jint) event->y_root,\n+                                glass_modifier,\n+                                JNI_FALSE,\n+                                JNI_FALSE);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+\n+    gdk_event_request_motions(event);\n+}\n+\n+void WindowContext::process_mouse_scroll(GdkEventScroll *event) {\n+    jdouble dx = 0, dy = 0;\n+\n+    \/\/ converting direction to change in pixels\n+    switch (event->direction) {\n+        case GDK_SCROLL_UP:\n+            dy = 1;\n+            break;\n+        case GDK_SCROLL_DOWN:\n+            dy = -1;\n+            break;\n+        case GDK_SCROLL_LEFT:\n+            dx = 1;\n+            break;\n+        case GDK_SCROLL_RIGHT:\n+            dx = -1;\n+            break;\n+        default:\n+            break;\n+    }\n+    if (event->state & GDK_SHIFT_MASK) {\n+        jdouble t = dy;\n+        dy = dx;\n+        dx = t;\n+    }\n+    if (jview) {\n+        mainEnv->CallVoidMethod(jview, jViewNotifyScroll,\n+                                (jint) event->x, (jint) event->y,\n+                                (jint) event->x_root, (jint) event->y_root,\n+                                dx, dy,\n+                                gdk_modifier_mask_to_glass(event->state),\n+                                (jint) 0, (jint) 0,\n+                                (jint) 0, (jint) 0,\n+                                (jdouble) 40.0, (jdouble) 40.0);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n+\n+void WindowContext::process_mouse_cross(GdkEventCrossing *event) {\n+    bool enter = event->type == GDK_ENTER_NOTIFY;\n+\n+    if (jview) {\n+        guint state = event->state;\n+        if (enter) { \/\/ workaround for RT-21590\n+            state &= ~MOUSE_BUTTONS_MASK;\n+        }\n+\n+        if (enter != is_mouse_entered) {\n+            is_mouse_entered = enter;\n+            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+                                    enter ? com_sun_glass_events_MouseEvent_ENTER\n+                                          : com_sun_glass_events_MouseEvent_EXIT,\n+                                    com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+                                    (jint) event->x, (jint) event->y,\n+                                    (jint) event->x_root, (jint) event->y_root,\n+                                    gdk_modifier_mask_to_glass(state),\n+                                    JNI_FALSE,\n+                                    JNI_FALSE);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+    }\n+}\n+\n+void WindowContext::process_key(GdkEventKey *event) {\n+    bool press = event->type == GDK_KEY_PRESS;\n+    jint glassKey = get_glass_key(event);\n+    jint glassModifier = gdk_modifier_mask_to_glass(event->state);\n+    if (press) {\n+        glassModifier |= glass_key_to_modifier(glassKey);\n+    } else {\n+        glassModifier &= ~glass_key_to_modifier(glassKey);\n+    }\n+    jcharArray jChars = NULL;\n+    jchar key = gdk_keyval_to_unicode(event->keyval);\n+    if (key >= 'a' && key <= 'z' && (event->state & GDK_CONTROL_MASK)) {\n+        key = key - 'a' + 1; \/\/ map 'a' to ctrl-a, and so on.\n+    } else {\n+#ifdef GLASS_GTK2\n+        if (key == 0) {\n+            \/\/ Work around \"bug\" fixed in gtk-3.0:\n+            \/\/ http:\/\/mail.gnome.org\/archives\/commits-list\/2011-March\/msg06832.html\n+            switch (event->keyval) {\n+            case 0xFF08 \/* Backspace *\/: key =  '\\b';\n+            case 0xFF09 \/* Tab       *\/: key =  '\\t';\n+            case 0xFF0A \/* Linefeed  *\/: key =  '\\n';\n+            case 0xFF0B \/* Vert. Tab *\/: key =  '\\v';\n+            case 0xFF0D \/* Return    *\/: key =  '\\r';\n+            case 0xFF1B \/* Escape    *\/: key =  '\\033';\n+            case 0xFFFF \/* Delete    *\/: key =  '\\177';\n+            }\n+        }\n+#endif\n+    }\n+\n+    if (key > 0) {\n+        jChars = mainEnv->NewCharArray(1);\n+        if (jChars) {\n+            mainEnv->SetCharArrayRegion(jChars, 0, 1, &key);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+    } else {\n+        jChars = mainEnv->NewCharArray(0);\n+    }\n+    if (jview) {\n+        if (press) {\n+            mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n+                                    com_sun_glass_events_KeyEvent_PRESS,\n+                                    glassKey,\n+                                    jChars,\n+                                    glassModifier);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+\n+            if (jview && key > 0) { \/\/ TYPED events should only be sent for printable characters.\n+                mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n+                                        com_sun_glass_events_KeyEvent_TYPED,\n+                                        com_sun_glass_events_KeyEvent_VK_UNDEFINED,\n+                                        jChars,\n+                                        glassModifier);\n+                CHECK_JNI_EXCEPTION(mainEnv)\n+            }\n+        } else {\n+            mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n+                                    com_sun_glass_events_KeyEvent_RELEASE,\n+                                    glassKey,\n+                                    jChars,\n+                                    glassModifier);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+    }\n+}\n+\n+void WindowContext::process_state(GdkEventWindowState *event) {\n+    if (event->changed_mask &\n+        (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_MAXIMIZED)) {\n+\n+        if (event->changed_mask & GDK_WINDOW_STATE_ICONIFIED) {\n+            is_iconified = event->new_window_state & GDK_WINDOW_STATE_ICONIFIED;\n+        }\n+        if (event->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) {\n+            is_maximized = event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED;\n+        }\n+\n+        jint stateChangeEvent;\n+\n+        if (is_iconified) {\n+            stateChangeEvent = com_sun_glass_events_WindowEvent_MINIMIZE;\n+        } else if (is_maximized) {\n+            stateChangeEvent = com_sun_glass_events_WindowEvent_MAXIMIZE;\n+        } else {\n+            stateChangeEvent = com_sun_glass_events_WindowEvent_RESTORE;\n+            if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0) {\n+                \/\/ in this case - the window manager will not support the programatic\n+                \/\/ request to iconify - so we need to restore it now.\n+                gdk_window_set_functions(gdk_window, gdk_windowManagerFunctions);\n+            }\n+        }\n+\n+        notify_state(stateChangeEvent);\n+    } else if (event->changed_mask & GDK_WINDOW_STATE_ABOVE) {\n+        notify_on_top(event->new_window_state & GDK_WINDOW_STATE_ABOVE);\n+    }\n+}\n+\n+void WindowContext::process_net_wm_property() {\n+    \/\/ Workaround for https:\/\/bugs.launchpad.net\/unity\/+bug\/998073\n+\n+    \/\/ This is a Unity bug\n+    if (!g_strcmp0(\"Unity\", gdk_x11_screen_get_window_manager_name(gdk_screen_get_default()))) {\n+        return;\n+    }\n+\n+    static GdkAtom atom_atom = gdk_atom_intern_static_string(\"ATOM\");\n+    static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string(\"_NET_WM_STATE\");\n+    static GdkAtom atom_net_wm_state_hidden = gdk_atom_intern_static_string(\"_NET_WM_STATE_HIDDEN\");\n+    static GdkAtom atom_net_wm_state_above = gdk_atom_intern_static_string(\"_NET_WM_STATE_ABOVE\");\n+\n+    gint length;\n+    glong *atoms = NULL;\n+\n+    if (gdk_property_get(gdk_window, atom_net_wm_state, atom_atom,\n+                         0, G_MAXLONG, FALSE, NULL, NULL, &length, (guchar * *) & atoms)) {\n+\n+        bool is_hidden = false;\n+        bool is_above = false;\n+        for (gint i = 0; i < (gint)(length \/ sizeof(glong)); i++) {\n+            if (atom_net_wm_state_hidden == (GdkAtom) atoms[i]) {\n+                is_hidden = true;\n+            } else if (atom_net_wm_state_above == (GdkAtom) atoms[i]) {\n+                is_above = true;\n+            }\n+        }\n+\n+        g_free(atoms);\n+\n+        if (is_iconified != is_hidden) {\n+            is_iconified = is_hidden;\n+\n+            notify_state((is_hidden)\n+                         ? com_sun_glass_events_WindowEvent_MINIMIZE\n+                         : com_sun_glass_events_WindowEvent_RESTORE);\n+        }\n+\n+        notify_on_top(is_above);\n+    }\n+}\n+\n+void WindowContext::process_screen_changed() {\n+    glong to_screen = getScreenPtrForLocation(geometry.current_x, geometry.current_y);\n+    if (to_screen != -1) {\n+        if (to_screen != screen) {\n+            if (jwindow) {\n+                \/\/notify screen changed\n+                jobject jScreen = createJavaScreen(mainEnv, to_screen);\n+                mainEnv->CallVoidMethod(jwindow, jWindowNotifyMoveToAnotherScreen, jScreen);\n+                CHECK_JNI_EXCEPTION(mainEnv)\n+            }\n+            screen = to_screen;\n+        }\n+    }\n+}\n+\n+void WindowContext::notify_on_top(bool top) {\n+    \/\/ Do not report effective (i.e. native) values to the FX, only if the user sets it manually\n+    if (top != effective_on_top() && jwindow) {\n+        if (on_top_inherited() && !top) {\n+            \/\/ Disallow user's \"on top\" handling on windows that inherited the property\n+            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n+        } else {\n+            on_top = top;\n+            update_ontop_tree(top);\n+            mainEnv->CallVoidMethod(jwindow,\n+                                    jWindowNotifyLevelChanged,\n+                                    top ? com_sun_glass_ui_Window_Level_FLOATING\n+                                        : com_sun_glass_ui_Window_Level_NORMAL);\n+            CHECK_JNI_EXCEPTION(mainEnv);\n+        }\n+    }\n+}\n+\n+void WindowContext::notify_repaint() {\n+    int w, h;\n+    glass_gdk_window_get_size(gdk_window, &w, &h);\n+    if (jview) {\n+        mainEnv->CallVoidMethod(jview,\n+                                jViewNotifyRepaint,\n+                                0, 0, w, h);\n+        CHECK_JNI_EXCEPTION(mainEnv);\n+    }\n+}\n+\n+void WindowContext::notify_state(jint glass_state) {\n+    if (glass_state == com_sun_glass_events_WindowEvent_RESTORE) {\n+        if (is_maximized) {\n+            glass_state = com_sun_glass_events_WindowEvent_MAXIMIZE;\n+        }\n+\n+        notify_repaint();\n+    }\n+\n+    if (jwindow) {\n+        mainEnv->CallVoidMethod(jwindow,\n+                                jGtkWindowNotifyStateChanged,\n+                                glass_state);\n+        CHECK_JNI_EXCEPTION(mainEnv);\n+    }\n+}\n+\n+bool WindowContext::set_view(jobject view) {\n+    if (jview) {\n+        mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+                                com_sun_glass_events_MouseEvent_EXIT,\n+                                com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+                                0, 0,\n+                                0, 0,\n+                                0,\n+                                JNI_FALSE,\n+                                JNI_FALSE);\n+        mainEnv->DeleteGlobalRef(jview);\n+    }\n+\n+    if (view) {\n+        jview = mainEnv->NewGlobalRef(view);\n+    } else {\n+        jview = NULL;\n+    }\n+    return TRUE;\n+}\n+\n+void WindowContext::set_visible(bool visible) {\n+    if (visible) {\n+        gtk_widget_show_all(gtk_widget);\n+    } else {\n+        gtk_widget_hide(gtk_widget);\n+        if (jview && is_mouse_entered) {\n+            is_mouse_entered = false;\n+            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+                                    com_sun_glass_events_MouseEvent_EXIT,\n+                                    com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+                                    0, 0,\n+                                    0, 0,\n+                                    0,\n+                                    JNI_FALSE,\n+                                    JNI_FALSE);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+    }\n+\n+    if (visible) {\n+        visible_received = TRUE;\n+    }\n+\n+    \/\/JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order\n+    if (visible && jwindow && isEnabled()) {\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);\n+        CHECK_JNI_EXCEPTION(mainEnv);\n+    }\n+}\n+\n+void WindowContext::set_cursor(GdkCursor *cursor) {\n+\/\/ This seems to have no no effect on either Gtk+2 or Gtk+3\n+\/\/    if (!is_in_drag()) {\n+\/\/        if (WindowContext::sm_mouse_drag_window) {\n+\/\/            grab_mouse_drag_focus(WindowContext::sm_mouse_drag_window->get_gdk_window(), NULL, cursor, false);\n+\/\/        } else if (WindowContext::sm_grab_window) {\n+\/\/            grab_mouse_drag_focus(WindowContext::sm_grab_window->get_gdk_window(), NULL, cursor, true);\n+\/\/        }\n+\/\/    }\n+\n+    gdk_window_set_cursor(gdk_window, cursor);\n+}\n+\n+void WindowContext::set_level(int level) {\n+    if (level == com_sun_glass_ui_Window_Level_NORMAL) {\n+        on_top = false;\n+    } else if (level == com_sun_glass_ui_Window_Level_FLOATING\n+               || level == com_sun_glass_ui_Window_Level_TOPMOST) {\n+        on_top = true;\n+    }\n+    \/\/ We need to emulate always on top behaviour on child windows\n+\n+    if (!on_top_inherited()) {\n+        update_ontop_tree(on_top);\n+    }\n+}\n+\n+void WindowContext::set_background(float r, float g, float b) {\n+    bg_color.red = r;\n+    bg_color.green = g;\n+    bg_color.blue = b;\n+    bg_color.is_set = true;\n+    notify_repaint();\n+}\n+\n+void WindowContext::set_minimized(bool minimize) {\n+    is_iconified = minimize;\n+    if (minimize) {\n+        if (frame_type == TRANSPARENT) {\n+            \/\/ https:\/\/bugs.launchpad.net\/ubuntu\/+source\/unity\/+bug\/1245571\n+            glass_window_reset_input_shape_mask(gtk_widget_get_window(gtk_widget));\n+        }\n+\n+        if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0) {\n+            \/\/ in this case - the window manager will not support the programatic\n+            \/\/ request to iconify - so we need to disable this until we are restored.\n+            GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MINIMIZE);\n+            gdk_window_set_functions(gdk_window, wmf);\n+        }\n+        gtk_window_iconify(GTK_WINDOW(gtk_widget));\n+    } else {\n+        gtk_window_deiconify(GTK_WINDOW(gtk_widget));\n+        activate_window();\n+    }\n+}\n+\n+void WindowContext::set_maximized(bool maximize) {\n+    is_maximized = maximize;\n+\n+    if (maximize) {\n+        \/\/ enable the functionality\n+        GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);\n+        gdk_window_set_functions(gdk_window, wmf);\n+\n+        ensure_window_size();\n+        gtk_window_maximize(GTK_WINDOW(gtk_widget));\n+    } else {\n+        gtk_window_unmaximize(GTK_WINDOW(gtk_widget));\n+    }\n+}\n+\n+void WindowContext::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {\n+    \/\/ this will tell if adjustments are needed - that's because GTK does not have full window size\n+    \/\/ values, just content values. Frame extents (window decorations) are handled by the window manager.\n+    geometry.needs_ajustment = (w > 0 || h > 0) || geometry.needs_ajustment;\n+\n+    \/\/ newW \/ newH always content sizes compatible with GTK+\n+    \/\/ if window has no decoration, adjustments will be ZERO\n+    int newW, newH;\n+    newW = (w > 0) ? w - geometry.adjust_w : cw;\n+    newH = (h > 0) ? h - geometry.adjust_h : ch;\n+\n+    geometry.current_w = newW;\n+    geometry.current_h = newH;\n+\n+    gboolean size_changed = FALSE;\n+    gboolean pos_changed = FALSE;\n+\n+    if (newW > 0 && newH > 0) {\n+        size_changed = TRUE;\n+\n+        \/\/ content size\n+        geometry.current_cw = newW;\n+        geometry.current_ch = newH;\n+        geometry.last_cw = newW;\n+        geometry.last_ch = newH;\n+\n+        if (visible_received) {\n+            \/\/ call apply_geometry() to let gtk_window_resize succeed, because it's bound to\n+            \/\/ geometry constraints\n+            apply_geometry();\n+            gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);\n+        } else {\n+            gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);\n+        }\n+    }\n+\n+    if (xSet || ySet) {\n+        int newX = (xSet) ? x : geometry.current_x;\n+        int newY = (ySet) ? y : geometry.current_y;\n+\n+        if (newX != geometry.current_x || newY != geometry.current_y) {\n+            pos_changed = TRUE;\n+            geometry.current_x = newX;\n+            geometry.current_y = newY;\n+\n+            gtk_window_move(GTK_WINDOW(gtk_widget), newX, newY);\n+        }\n+    }\n+\n+    size_position_notify(size_changed, pos_changed);\n+}\n+\n+void WindowContext::set_resizable(bool res) {\n+    if (res != geometry.resizable) {\n+        geometry.resizable = res;\n+        apply_geometry();\n+    }\n+}\n+\n+void WindowContext::set_focusable(bool focusable) {\n+    gtk_window_set_accept_focus(GTK_WINDOW(gtk_widget), focusable ? TRUE : FALSE);\n+}\n+\n+void WindowContext::set_title(const char *title) {\n+    gtk_window_set_title(GTK_WINDOW(gtk_widget), title);\n+}\n+\n+void WindowContext::set_alpha(double alpha) {\n+#ifdef GLASS_GTK3\n+    gtk_widget_set_opacity(gtk_widget, (gdouble)alpha);\n+#else\n+    gtk_window_set_opacity(GTK_WINDOW(gtk_widget), (gdouble)alpha);\n+#endif\n+}\n+\n+void WindowContext::set_enabled(bool enabled) {\n+    if (enabled != geometry.enabled) {\n+        gtk_widget_set_sensitive(gtk_widget, enabled);\n+        geometry.enabled = enabled;\n+        apply_geometry();\n+    }\n+}\n+\n+void WindowContext::set_minimum_size(int w, int h) {\n+    gboolean changed = geometry.minw != w || geometry.minh != h;\n+\n+    if (!changed) {\n+        return;\n+    }\n+\n+    geometry.minw = w;\n+    geometry.minh = h;\n+\n+    apply_geometry();\n+}\n+\n+void WindowContext::set_maximum_size(int w, int h) {\n+    gboolean changed = geometry.maxw != w || geometry.maxh != h;\n+\n+    if (!changed) {\n+        return;\n+    }\n+\n+    geometry.maxw = w;\n+    geometry.maxh = h;\n+\n+    apply_geometry();\n+}\n+\n+void WindowContext::set_icon(GdkPixbuf *pixbuf) {\n+    gtk_window_set_icon(GTK_WINDOW(gtk_widget), pixbuf);\n+}\n+\n+void WindowContext::set_modal(bool modal, WindowContext *parent) {\n+    if (modal) {\n+        \/\/gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_DIALOG);\n+        if (parent) {\n+            gtk_window_set_transient_for(GTK_WINDOW(gtk_widget), parent->get_gtk_window());\n+        }\n+    }\n+    gtk_window_set_modal(GTK_WINDOW(gtk_widget), modal ? TRUE : FALSE);\n+}\n+\n+void WindowContext::set_gravity(float x, float y) {\n+    geometry.gravity_x = x;\n+    geometry.gravity_y = y;\n+}\n+\n+void WindowContext::set_owner(WindowContext *owner_ctx) {\n+    owner = owner_ctx;\n+}\n+\n+void WindowContext::add_child(WindowContext *child) {\n+    children.insert(child);\n+    gtk_window_set_transient_for(child->get_gtk_window(), this->get_gtk_window());\n+}\n+\n+void WindowContext::remove_child(WindowContext *child) {\n+    children.erase(child);\n+    gtk_window_set_transient_for(child->get_gtk_window(), NULL);\n+}\n+\n+void WindowContext::show_or_hide_children(bool show) {\n+    std::set<WindowContext *>::iterator it;\n+    for (it = children.begin(); it != children.end(); ++it) {\n+        (*it)->set_minimized(!show);\n+        (*it)->show_or_hide_children(show);\n+    }\n+}\n+\n+bool WindowContext::is_visible() {\n+    return gtk_widget_get_visible(gtk_widget);\n+}\n+\n+bool WindowContext::is_dead() {\n+    return can_be_deleted;\n+}\n+\n+bool WindowContext::grab_focus() {\n+    if (WindowContext::sm_mouse_drag_window\n+            || grab_mouse_drag_focus(gdk_window, NULL, NULL, true)) {\n+        WindowContext::sm_grab_window = this;\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+void WindowContext::ungrab_focus() {\n+    if (!WindowContext::sm_mouse_drag_window) {\n+        ungrab_mouse_drag_focus();\n+    }\n+\n+    WindowContext::sm_grab_window = NULL;\n+\n+    if (jwindow) {\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusUngrab);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n+\n+void WindowContext::restack(bool restack) {\n+    gdk_window_restack(gdk_window, NULL, restack ? TRUE : FALSE);\n+}\n+\n+void WindowContext::request_focus() {\n+    \/\/JDK-8212060: Window show and then move glitch.\n+    \/\/The WindowContext::set_visible will take care of showing the window.\n+    \/\/The below code will only handle later request_focus.\n+    if (is_visible()) {\n+        gtk_window_present(GTK_WINDOW(gtk_widget));\n+    }\n+}\n+\n+void WindowContext::enter_fullscreen() {\n+    is_fullscreen = TRUE;\n+\n+    ensure_window_size();\n+    gtk_window_fullscreen(GTK_WINDOW(gtk_widget));\n+}\n+\n+void WindowContext::exit_fullscreen() {\n+    is_fullscreen = FALSE;\n+    gtk_window_unfullscreen(GTK_WINDOW(gtk_widget));\n+}\n+\n+\/\/ Applied to a temporary full screen window to prevent sending events to Java\n+void WindowContext::detach_from_java() {\n+    if (jview) {\n+        mainEnv->DeleteGlobalRef(jview);\n+        jview = NULL;\n+    }\n+    if (jwindow) {\n+        mainEnv->DeleteGlobalRef(jwindow);\n+        jwindow = NULL;\n+    }\n+}\n+\n+void WindowContext::increment_events_counter() {\n+    ++events_processing_cnt;\n+}\n+\n+void WindowContext::decrement_events_counter() {\n+    --events_processing_cnt;\n+}\n+\n+size_t WindowContext::get_events_count() {\n+    return events_processing_cnt;\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ PROTECTED\n+\n+void WindowContext::applyShapeMask(void *data, uint width, uint height) {\n+    if (frame_type != TRANSPARENT) {\n+        return;\n+    }\n+\n+    glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ PRIVATE\n+\n+\/\/ this is to work-around past gtk+ bug\n+void WindowContext::ensure_window_size() {\n+    gint w, h;\n+#ifdef GLASS_GTK3\n+    gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h);\n+#else\n+    gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h, NULL);\n+#endif\n+    if ((geometry.last_cw > 0 && geometry.last_ch > 0)\n+        && (geometry.last_cw != w || geometry.last_ch != h)) {\n+        gdk_window_resize(gdk_window, geometry.last_cw, geometry.last_ch);\n+    }\n+}\n+\n+\/\/ This function calculate the deltas between window and window + decoration (titlebar, borders).\n+\/\/ It's used when the window manager does not support the _NET_FRAME_EXTENTS extension or when\n+\/\/ it's not received on time.\n+void WindowContext::calculate_adjustments() {\n+    if (frame_type != TITLED || geometry.frame_extents_received) {\n+        return;\n+    }\n+\n+    gint x, y, rx, ry;\n+    gdk_window_get_origin(gdk_window, &x, &y);\n+    gdk_window_get_root_origin(gdk_window, &rx, &ry);\n+\n+    if (rx != x || ry != y) {\n+        \/\/ the left extends are correct - the right one is guessed to be the same\n+        geometry.adjust_w = (x - rx) * 2;\n+        \/\/ guess that bottom size is the same as left and right\n+        geometry.adjust_h = (y - ry) + (x - rx);\n+\n+        \/\/ those will be correct\n+        geometry.view_x = (x - rx);\n+        geometry.view_y = (y - ry);\n+\n+        if (geometry.needs_ajustment) {\n+            set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);\n+        }\n+\n+        \/\/ force position notify so java will know about view_y and view_x\n+        size_position_notify(false, true);\n+    }\n+}\n+\n+void WindowContext::apply_geometry() {\n+    if (!map_received) {\n+        return;\n+    }\n+\n+    GdkGeometry gdk_geometry;\n+    gdk_geometry.win_gravity = GDK_GRAVITY_NORTH_WEST;\n+\n+    if ((!geometry.resizable || !geometry.enabled) && !(is_maximized || is_fullscreen)) {\n+        \/\/ not resizeable\n+        int w = geometry.current_cw > 0\n+                ? geometry.current_cw\n+                : geometry.current_w - geometry.adjust_w;\n+\n+        int h = geometry.current_ch > 0\n+                ? geometry.current_ch\n+                : geometry.current_h - geometry.adjust_h;\n+\n+        gdk_geometry.min_width = gdk_geometry.max_width = w;\n+        gdk_geometry.min_height = gdk_geometry.max_height = h;\n+    } else {\n+        \/\/min\/max width\/height always whole window size (with decors)\n+        gdk_geometry.min_width = (geometry.minw - geometry.adjust_w) > 0\n+                                 ? geometry.minw - geometry.adjust_w : 1;\n+        gdk_geometry.min_height = (geometry.minh - geometry.adjust_h) > 0\n+                                  ? geometry.minh - geometry.adjust_h : 1;\n+\n+        gdk_geometry.max_width = (geometry.maxw - geometry.adjust_w > 0)\n+                                 ? geometry.maxw - geometry.adjust_w : G_MAXINT;\n+        gdk_geometry.max_height = (geometry.maxh - geometry.adjust_h > 0)\n+                                  ? geometry.maxh - geometry.adjust_h : G_MAXINT;\n+    }\n+\n+    gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &gdk_geometry,\n+                                  (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE | GDK_HINT_WIN_GRAVITY));\n+}\n+\n+bool WindowContext::get_frame_extents_property(int *top, int *left,\n+                                               int *bottom, int *right) {\n+    unsigned long *extents;\n+\n+    if (gdk_property_get(gdk_window,\n+                         atom_net_wm_frame_extents,\n+                         gdk_atom_intern(\"CARDINAL\", FALSE),\n+                         0,\n+                         sizeof(unsigned long) * 4,\n+                         FALSE,\n+                         NULL,\n+                         NULL,\n+                         NULL,\n+                         (guchar * *) & extents)) {\n+        *left = extents[0];\n+        *right = extents[1];\n+        *top = extents[2];\n+        *bottom = extents[3];\n+\n+        g_free(extents);\n+        return true;\n+    }\n+\n+    return false;\n+}\n+\n+void WindowContext::activate_window() {\n+    Display *display = GDK_DISPLAY_XDISPLAY(gdk_window_get_display(gdk_window));\n+    Atom navAtom = XInternAtom(display, \"_NET_ACTIVE_WINDOW\", True);\n+    if (navAtom != None) {\n+        XClientMessageEvent clientMessage;\n+        memset(&clientMessage, 0, sizeof(clientMessage));\n+\n+        clientMessage.type = ClientMessage;\n+        clientMessage.window = GDK_WINDOW_XID(gdk_window);\n+        clientMessage.message_type = navAtom;\n+        clientMessage.format = 32;\n+        clientMessage.data.l[0] = 1;\n+        clientMessage.data.l[1] = gdk_x11_get_server_time(gdk_window);\n+        clientMessage.data.l[2] = 0;\n+\n+        XSendEvent(display, XDefaultRootWindow(display), False,\n+                   SubstructureRedirectMask | SubstructureNotifyMask,\n+                   (XEvent * ) & clientMessage);\n+        XFlush(display);\n+    }\n+}\n+\n+void WindowContext::size_position_notify(bool size_changed, bool pos_changed) {\n+\n+    if (jview) {\n+        if (size_changed) {\n+            mainEnv->CallVoidMethod(jview, jViewNotifyResize, geometry.current_cw, geometry.current_ch);\n+            CHECK_JNI_EXCEPTION(mainEnv);\n+        }\n+\n+        if (pos_changed) {\n+            mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_MOVE);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+    }\n+\n+    if (jwindow) {\n+        if (size_changed || is_maximized) {\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,\n+                                    (is_maximized)\n+                                    ? com_sun_glass_events_WindowEvent_MAXIMIZE\n+                                    : com_sun_glass_events_WindowEvent_RESIZE,\n+                                    geometry.current_w, geometry.current_h);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+\n+        if (pos_changed) {\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove, geometry.current_x, geometry.current_y);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+    }\n+}\n+\n+void WindowContext::update_ontop_tree(bool on_top) {\n+    bool effective_on_top = on_top || this->on_top;\n+    gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), effective_on_top ? TRUE : FALSE);\n+    for (std::set<WindowContext *>::iterator it = children.begin(); it != children.end(); ++it) {\n+        (*it)->update_ontop_tree(effective_on_top);\n+    }\n+}\n+\n+bool WindowContext::on_top_inherited() {\n+    WindowContext *o = owner;\n+    while (o) {\n+        WindowContext *topO = dynamic_cast<WindowContext *>(o);\n+        if (!topO) break;\n+        if (topO->on_top) {\n+            return true;\n+        }\n+        o = topO->owner;\n+    }\n+    return false;\n+}\n+\n+bool WindowContext::effective_on_top() {\n+    if (owner) {\n+        WindowContext *topO = dynamic_cast<WindowContext *>(owner);\n+        return (topO && topO->effective_on_top()) || on_top;\n+    }\n+    return on_top;\n+}\n+\n+bool WindowContext::grab_mouse_drag_focus(GdkWindow * gdk_w, GdkEvent * event, GdkCursor * cursor, bool owner_events) {\n+    if (is_grab_disabled()) {\n+        return true;\n+    }\n+\n+    ungrab_mouse_drag_focus();\n+\n+#ifdef GLASS_GTK3\n+    if (event != NULL) {\n+        grab_pointer = gdk_event_get_device (event);\n+    } else {\n+        grab_pointer = gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gtk_widget_get_display(gtk_widget)));\n+    }\n+\n+    GdkGrabStatus status = gdk_device_grab((GdkDevice *) grab_pointer, gdk_w, GDK_OWNERSHIP_WINDOW, owner_events,\n+                                                (GdkEventMask)\n+                                                      (GDK_POINTER_MOTION_MASK\n+                                                          | GDK_POINTER_MOTION_HINT_MASK\n+                                                          | GDK_BUTTON_MOTION_MASK\n+                                                          | GDK_BUTTON1_MOTION_MASK\n+                                                          | GDK_BUTTON2_MOTION_MASK\n+                                                          | GDK_BUTTON3_MOTION_MASK\n+                                                          | GDK_BUTTON_PRESS_MASK\n+                                                          | GDK_BUTTON_RELEASE_MASK), cursor, GDK_CURRENT_TIME);\n+#else\n+    GdkGrabStatus status = gdk_pointer_grab(gdk_w, owner_events,\n+                                                (GdkEventMask)\n+                                                      (GDK_POINTER_MOTION_MASK\n+                                                          | GDK_POINTER_MOTION_HINT_MASK\n+                                                          | GDK_BUTTON_MOTION_MASK\n+                                                          | GDK_BUTTON1_MOTION_MASK\n+                                                          | GDK_BUTTON2_MOTION_MASK\n+                                                          | GDK_BUTTON3_MOTION_MASK\n+                                                          | GDK_BUTTON_PRESS_MASK\n+                                                          | GDK_BUTTON_RELEASE_MASK), NULL, cursor, GDK_CURRENT_TIME);\n+#endif\n+    WindowContext::sm_mouse_drag_window = this;\n+\n+    return (status == GDK_GRAB_SUCCESS) ? true : false;\n+}\n+\n+void WindowContext::ungrab_mouse_drag_focus() {\n+    if (!grab_pointer) {\n+        return;\n+    }\n+\n+#ifdef GLASS_GTK3\n+    gdk_device_ungrab((GdkDevice *) grab_pointer, GDK_CURRENT_TIME);\n+#else\n+    gdk_pointer_ungrab(GDK_CURRENT_TIME);\n+#endif\n+    grab_pointer = NULL;\n+    WindowContext::sm_mouse_drag_window = NULL;\n+\n+    if (WindowContext::sm_grab_window) {\n+        WindowContext::sm_grab_window->grab_focus();\n+    }\n+}\n+\n+WindowContext::~WindowContext() {\n+    if (xim.ic) {\n+        XDestroyIC(xim.ic);\n+        xim.ic = NULL;\n+    }\n+    if (xim.im) {\n+        XCloseIM(xim.im);\n+        xim.im = NULL;\n+    }\n+\n+    gtk_widget_destroy(gtk_widget);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_window.cpp","additions":1492,"deletions":0,"binary":false,"changes":1492,"status":"added"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef GLASS_WINDOW_H\n+#define        GLASS_WINDOW_H\n+\n+#include <gtk\/gtk.h>\n+#include <X11\/Xlib.h>\n+\n+#include <jni.h>\n+#include <set>\n+#include <vector>\n+\n+#include \"glass_view.h\"\n+#include \"glass_general.h\"\n+\n+enum WindowFrameType {\n+    TITLED,\n+    UNTITLED,\n+    TRANSPARENT\n+};\n+\n+enum WindowType {\n+    NORMAL,\n+    UTILITY,\n+    POPUP\n+};\n+\n+enum request_type {\n+    REQUEST_NONE,\n+    REQUEST_RESIZABLE,\n+    REQUEST_NOT_RESIZABLE\n+};\n+\n+static const guint MOUSE_BUTTONS_MASK = (guint)(GDK_BUTTON1_MASK | GDK_BUTTON2_MASK | GDK_BUTTON3_MASK);\n+\n+struct BgColor {\n+    BgColor() : red(0), green(0), blue(0), is_set(FALSE) {}\n+\n+    float red;\n+    float green;\n+    float blue;\n+    bool is_set;\n+};\n+\n+struct WindowGeometry {\n+    WindowGeometry() : current_x(0),\n+                       current_y(0),\n+                       current_w(0),\n+                       current_h(0),\n+                       current_cw(0),\n+                       current_ch(0),\n+                       last_cw(0),\n+                       last_ch(0),\n+                       adjust_w(0),\n+                       adjust_h(0),\n+                       view_x(0),\n+                       view_y(0),\n+                       frame_extents_received(false),\n+                       gravity_x(1.00),\n+                       gravity_y(1.00),\n+                       enabled(true),\n+                       resizable(true),\n+                       minw(-1),\n+                       minh(-1),\n+                       maxw(-1),\n+                       maxh(-1),\n+                       needs_ajustment(false) {}\n+\n+    int current_x; \/\/ current position X\n+    int current_y; \/\/ current position Y\n+    int current_w; \/\/ current window width, adjusted\n+    int current_h; \/\/ current window height, adjusted\n+    int current_cw; \/\/ current content (view) width\n+    int current_ch; \/\/ current content (view) height\n+    int last_cw; \/\/ not subjected to fullscreen \/ maximize\n+    int last_ch;\n+\n+    \/\/ Used to ajust window sizes because gtk doest not account frame extents as part\n+    \/\/ of the window size and JavaFx does.\n+    int adjust_w;\n+    int adjust_h;\n+\n+    \/\/ The position of the view relative to the window\n+    int view_x;\n+    int view_y;\n+\n+    \/\/ If WM supports _NET_REQUEST_FRAME_EXTENTS and it was received\n+    bool frame_extents_received;\n+\n+    \/\/ Currently not used\n+    float gravity_x;\n+    float gravity_y;\n+\n+    bool enabled;\n+    bool resizable;\n+\n+    int minw;\n+    int minh;\n+\n+    int maxw;\n+    int maxh;\n+\n+    \/\/ if the window size was set (instead of content size) - this is used to\n+    \/\/ \"fix\" the window size accouting extents.\n+    bool needs_ajustment;\n+};\n+\n+class WindowContext {\n+private:\n+    jlong screen;\n+    WindowFrameType frame_type;\n+    WindowType window_type;\n+    struct WindowContext *owner;\n+    jobject jwindow;\n+    jobject jview;\n+\n+    bool map_received;\n+    bool visible_received;\n+    bool on_top;\n+    bool is_fullscreen;\n+    bool is_iconified;\n+    bool is_maximized;\n+    bool is_mouse_entered;\n+    bool can_be_deleted;\n+\n+    struct _XIM {\n+    _XIM() : im(NULL), ic(NULL), enabled(FALSE) {}\n+        XIM im;\n+        XIC ic;\n+        bool enabled;\n+    } xim;\n+\n+    size_t events_processing_cnt;\n+\n+    WindowGeometry geometry;\n+    std::set<WindowContext *> children;\n+    GdkWMFunction gdk_windowManagerFunctions;\n+    GtkWidget *gtk_widget;\n+    GdkWindow *gdk_window;\n+    BgColor bg_color;\n+    void *grab_pointer;\n+\n+    static WindowContext* sm_mouse_drag_window;\n+    static WindowContext* sm_grab_window;\n+public:\n+    WindowContext(jobject, WindowContext *, long, WindowFrameType, WindowType, GdkWMFunction);\n+\n+    bool hasIME();\n+    bool filterIME(GdkEvent *);\n+    void enableOrResetIME();\n+    void disableIME();\n+\n+    void paint(void*, jint, jint);\n+    bool isEnabled();\n+\n+    GdkWindow *get_gdk_window();\n+    GtkWidget *get_gtk_widget();\n+    GtkWindow *get_gtk_window();\n+    WindowGeometry get_geometry();\n+    jobject get_jwindow();\n+    jobject get_jview();\n+\n+    void process_map();\n+    void process_focus(GdkEventFocus*);\n+    void process_property_notify(GdkEventProperty *);\n+    void process_configure();\n+    void process_destroy();\n+    void process_delete();\n+    void process_expose(GdkEventExpose*);\n+    void process_mouse_button(GdkEventButton*);\n+    void process_mouse_motion(GdkEventMotion*);\n+    void process_mouse_scroll(GdkEventScroll*);\n+    void process_mouse_cross(GdkEventCrossing*);\n+    void process_key(GdkEventKey*);\n+    void process_state(GdkEventWindowState*);\n+    void process_net_wm_property();\n+    void process_screen_changed();\n+\n+    void notify_on_top(bool);\n+    void notify_repaint();\n+    void notify_state(jint);\n+\n+    bool set_view(jobject);\n+    void set_visible(bool);\n+    void set_cursor(GdkCursor*);\n+    void set_level(int);\n+    void set_background(float, float, float);\n+    void set_minimized(bool);\n+    void set_maximized(bool);\n+    void set_bounds(int, int, bool, bool, int, int, int, int);\n+    void set_resizable(bool);\n+    void set_focusable(bool);\n+    void set_title(const char *);\n+    void set_alpha(double);\n+    void set_enabled(bool);\n+    void set_minimum_size(int, int);\n+    void set_maximum_size(int, int);\n+    void set_icon(GdkPixbuf *);\n+    void set_modal(bool, WindowContext *parent = NULL);\n+    void set_gravity(float, float);\n+    void set_owner(WindowContext *);\n+    void add_child(WindowContext *);\n+    void remove_child(WindowContext *);\n+    void show_or_hide_children(bool);\n+    bool is_visible();\n+    bool is_dead();\n+    bool grab_focus();\n+    void ungrab_focus();\n+    void restack(bool);\n+    void request_focus();\n+    void enter_fullscreen();\n+    void exit_fullscreen();\n+    void detach_from_java();\n+    void increment_events_counter();\n+    void decrement_events_counter();\n+    size_t get_events_count();\n+    ~WindowContext();\n+\n+protected:\n+    void applyShapeMask(void *, uint width, uint height);\n+\n+private:\n+    bool im_filter_keypress(GdkEventKey*);\n+    void ensure_window_size();\n+    void calculate_adjustments();\n+    void apply_geometry();\n+    bool get_frame_extents_property(int *, int *, int *, int *);\n+    void activate_window();\n+    void size_position_notify(bool, bool);\n+    void update_ontop_tree(bool);\n+    bool on_top_inherited();\n+    bool effective_on_top();\n+    bool grab_mouse_drag_focus(GdkWindow *, GdkEvent *, GdkCursor *, bool);\n+    void ungrab_mouse_drag_focus();\n+};\n+\n+void destroy_and_delete_ctx(WindowContext *ctx);\n+\n+class EventsCounterHelper {\n+private:\n+    WindowContext *ctx;\n+public:\n+    explicit EventsCounterHelper(WindowContext *context) {\n+        ctx = context;\n+        ctx->increment_events_counter();\n+    }\n+\n+    ~EventsCounterHelper() {\n+        ctx->decrement_events_counter();\n+        if (ctx->is_dead() && ctx->get_events_count() == 0) {\n+            delete ctx;\n+        }\n+        ctx = NULL;\n+    }\n+};\n+\n+#endif        \/* GLASS_WINDOW_H *\/\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_window.h","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"com_sun_glass_ui_View.h\"\n+#include \"glass_window.h\"\n+#include \"glass_general.h\"\n+\n+#include <cstring>\n+#include <cstdlib>\n+\n+bool WindowContext::hasIME() {\n+    return xim.enabled;\n+}\n+\n+static XKeyPressedEvent convert_event(GdkEventKey *event) {\n+    XKeyPressedEvent result;\n+    memset(&result, 0, sizeof (result));\n+\n+    result.type = (event->type == GDK_KEY_PRESS) ? KeyPress : KeyRelease;\n+    result.send_event = event->send_event;\n+    result.display = gdk_x11_display_get_xdisplay(gdk_window_get_display(event->window));\n+    result.window = result.subwindow = GDK_WINDOW_XID(event->window);\n+    result.root = GDK_WINDOW_XID(gdk_screen_get_root_window(glass_gdk_window_get_screen(event->window)));\n+    result.time = event->time;\n+    result.state = event->state;\n+    result.keycode = event->hardware_keycode;\n+    result.same_screen = True;\n+\n+    return result;\n+}\n+\n+bool WindowContext::im_filter_keypress(GdkEventKey* event) {\n+    static size_t buf_len = 12;\n+    static char *buffer = NULL;\n+\n+    if (buffer == NULL) {\n+        buffer = (char*)malloc(buf_len * sizeof (char));\n+    }\n+\n+    KeySym keysym;\n+    Status status;\n+    XKeyPressedEvent xevent = convert_event(event);\n+    if (XFilterEvent((XEvent*) & xevent, GDK_WINDOW_XID(gdk_window))) {\n+        return TRUE;\n+    }\n+\n+    if (event->type == GDK_KEY_RELEASE) {\n+        process_key(event);\n+        return TRUE;\n+    }\n+\n+    int len = Xutf8LookupString(xim.ic, &xevent, buffer, buf_len - 1, &keysym, &status);\n+    if (status == XBufferOverflow) {\n+        buf_len = len + 1;\n+        buffer = (char*)realloc(buffer, buf_len * sizeof (char));\n+        len = Xutf8LookupString(xim.ic, &xevent, buffer, buf_len - 1,\n+                &keysym, &status);\n+    }\n+    switch (status) {\n+        case XLookupKeySym:\n+        case XLookupBoth:\n+            if (xevent.keycode) {\n+                \/\/process it as a normal key\n+                process_key(event);\n+                break;\n+            }\n+            \/\/ fall-through\n+        case XLookupChars:\n+            buffer[len] = 0;\n+            jstring str = mainEnv->NewStringUTF(buffer);\n+            EXCEPTION_OCCURED(mainEnv);\n+            jsize slen = mainEnv->GetStringLength(str);\n+            mainEnv->CallVoidMethod(jview,\n+                    jViewNotifyInputMethod,\n+                    str,\n+                    NULL, NULL, NULL,\n+                    slen,\n+                    slen,\n+                    0);\n+            LOG_EXCEPTION(mainEnv)\n+\n+            break;\n+    }\n+\n+    return TRUE;\n+}\n+\n+bool WindowContext::filterIME(GdkEvent * event) {\n+    if (!hasIME()) {\n+        return false;\n+    }\n+\n+    switch (event->type) {\n+        case GDK_KEY_PRESS:\n+        case GDK_KEY_RELEASE:\n+            return im_filter_keypress(reinterpret_cast<GdkEventKey*> (event));\n+        default:\n+            return FALSE;\n+    }\n+}\n+\n+\/\/Note: this function must return int, despite the fact it doesn't conform to XIMProc type.\n+\/\/ This is required in documentation of XIM\n+static int im_preedit_start(XIM im_xim, XPointer client, XPointer call) {\n+    (void)im_xim;\n+    (void)call;\n+\n+    mainEnv->CallVoidMethod((jobject) client, jViewNotifyPreeditMode, JNI_TRUE);\n+    CHECK_JNI_EXCEPTION_RET(mainEnv, -1);\n+    return -1; \/\/ No restrictions\n+}\n+\n+static void im_preedit_done(XIM im_xim, XPointer client, XPointer call) {\n+    (void)im_xim;\n+    (void)call;\n+\n+    mainEnv->CallVoidMethod((jobject) client, jViewNotifyPreeditMode, JNI_FALSE);\n+    CHECK_JNI_EXCEPTION(mainEnv);\n+}\n+\n+static void im_preedit_draw(XIM im_xim, XPointer client, XPointer call) {\n+    (void)im_xim;\n+    (void)call;\n+\n+    XIMPreeditDrawCallbackStruct *data = (XIMPreeditDrawCallbackStruct*) call;\n+    jstring text = NULL;\n+    jbyteArray attr = NULL;\n+\n+    if (data->text != NULL) {\n+        if (data->text->string.multi_byte) {\n+            if (data->text->encoding_is_wchar) {\n+                size_t csize = wcstombs(NULL, data->text->string.wide_char, 0);\n+                char *ctext = new char[csize + 1];\n+                wcstombs(ctext, data->text->string.wide_char, csize + 1);\n+                text = mainEnv->NewStringUTF(ctext);\n+                delete[] ctext;\n+                CHECK_JNI_EXCEPTION(mainEnv);\n+            } else {\n+                text = mainEnv->NewStringUTF(data->text->string.multi_byte);\n+                CHECK_JNI_EXCEPTION(mainEnv);\n+            }\n+        }\n+\n+        if (XIMFeedback* fb = data->text->feedback) {\n+            attr = mainEnv->NewByteArray(data->text->length);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+            jbyte v[data->text->length];\n+            for (int i = 0; i < data->text->length; i++) {\n+                if (fb[i] & XIMReverse) {\n+                    v[i] = com_sun_glass_ui_View_IME_ATTR_TARGET_NOTCONVERTED;\n+                } else if (fb[i] & XIMHighlight) {\n+                    v[i] = com_sun_glass_ui_View_IME_ATTR_TARGET_CONVERTED;\n+                } else if (fb[i] & XIMUnderline) {\n+                    v[i] = com_sun_glass_ui_View_IME_ATTR_CONVERTED;\n+                } else {\n+                    v[i] = com_sun_glass_ui_View_IME_ATTR_INPUT;\n+                }\n+            }\n+            mainEnv->SetByteArrayRegion(attr, 0, data->text->length, v);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+    }\n+\n+    mainEnv->CallVoidMethod((jobject)client, jViewNotifyInputMethodDraw,\n+            text, data->chg_first, data->chg_length, data->caret, attr);\n+    CHECK_JNI_EXCEPTION(mainEnv)\n+}\n+\n+static void im_preedit_caret(XIM im_xim, XPointer client, XPointer call) {\n+    (void)im_xim;\n+\n+    XIMPreeditCaretCallbackStruct *data = (XIMPreeditCaretCallbackStruct*) call;\n+    mainEnv->CallVoidMethod((jobject)client, jViewNotifyInputMethodCaret,\n+            data->position, data->direction, data->style);\n+    CHECK_JNI_EXCEPTION(mainEnv)\n+}\n+\n+static XIMStyle get_best_supported_style(XIM im_xim)\n+{\n+    XIMStyles* styles;\n+    int i;\n+    XIMStyle result = 0;\n+\n+    if (XGetIMValues(im_xim, XNQueryInputStyle, &styles, NULL) != NULL) { \/\/ NULL means it's OK\n+        return 0;\n+    }\n+\n+    for (i = 0; i < styles->count_styles; ++i) {\n+        if (styles->supported_styles[i] == (XIMPreeditCallbacks | XIMStatusNothing)\n+                || styles->supported_styles[i] == (XIMPreeditNothing | XIMStatusNothing)) {\n+            result = styles->supported_styles[i];\n+            break;\n+        }\n+    }\n+\n+    XFree(styles);\n+\n+    return result;\n+}\n+\n+void WindowContext::enableOrResetIME() {\n+    Display *display = gdk_x11_display_get_xdisplay(gdk_window_get_display(gdk_window));\n+    if (xim.im == NULL || xim.ic == NULL) {\n+        xim.im = XOpenIM(display, NULL, NULL, NULL);\n+        if (xim.im == NULL) {\n+            return;\n+        }\n+\n+        XIMStyle styles = get_best_supported_style(xim.im);\n+        if (styles == 0) {\n+            return;\n+        }\n+\n+        XIMCallback startCallback = {(XPointer) jview, (XIMProc) (void *) im_preedit_start};\n+        XIMCallback doneCallback = {(XPointer) jview, im_preedit_done};\n+        XIMCallback drawCallback = {(XPointer) jview, im_preedit_draw};\n+        XIMCallback caretCallback = {(XPointer) jview, im_preedit_caret};\n+\n+        XVaNestedList list = XVaCreateNestedList(0,\n+                XNPreeditStartCallback, &startCallback,\n+                XNPreeditDoneCallback, &doneCallback,\n+                XNPreeditDrawCallback, &drawCallback,\n+                XNPreeditCaretCallback, &caretCallback,\n+                NULL);\n+\n+        xim.ic = XCreateIC(xim.im,\n+                XNInputStyle, styles,\n+                XNClientWindow, GDK_WINDOW_XID(gdk_window),\n+                XNPreeditAttributes, list,\n+                NULL);\n+\n+        XFree(list);\n+\n+        if (xim.ic == NULL) {\n+            return;\n+        }\n+    }\n+\n+    if (xim.enabled) { \/\/called when changed focus to different input\n+        XmbResetIC(xim.ic);\n+    }\n+\n+\n+    XSetICFocus(xim.ic);\n+\n+    xim.enabled = TRUE;\n+}\n+\n+void WindowContext::disableIME() {\n+    if (xim.ic != NULL) {\n+        XUnsetICFocus(xim.ic);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/glass_window_ime.cpp","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"},{"patch":"","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/wrapped.c","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/wrapped.c","status":"copied"},{"patch":"","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk_experimental\/wrapped.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/wrapped.h","status":"copied"}]}