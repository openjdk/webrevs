{"files":[{"patch":"@@ -0,0 +1,110 @@\n+package com.sun.javafx.scene.paint;\n+\n+\/\/ When the public API is ready, move to the exported javafx.scene.paint\n+\/**\n+ * Contains texture properties for a {@code Material}'s textures (maps).\n+ * <p>\n+ * Since {@code TextureData} does not depend on a {@code Material}, the same instance can be reused in multiple textures\n+ * (in the same or in different materials). This is useful because many times a {@link javafx.scene.shape.Shape3D} will\n+ * have all its textures use the same properties, or the same texture data will be used across the whole application.\n+ *\/\n+\/\/ Here we can support mipmaps, wrapping modes (which exists internally and can be pulled out), addressing modes etc.\n+public class TextureData {\n+\n+    \/**\n+     * Filtering methods for sampling a magnified or minified texture. When a texture is used to color a surface that is\n+     * larger or smaller than the texture size, the texture needs to be magnified or minified. Different algorithms\n+     * exist for sampling the texture elements (texels) used to color the surface.\n+     *\/\n+    public enum MinMagFilterType {\n+\n+        \/**\n+         * Uses the texel closest to the sampling point. This sampling method is the fastest, but the results can be\n+         * pixelated.\n+         *\/\n+        NEAREST_POINT,\n+\n+        \/**\n+         * Uses a weighted average of the 4 texels closest to the sampling point. This sampling method is slightly\n+         * slower than {@code NEAREST_POINT}, but results in a smoother image.\n+         *\/\n+        BILINEAR;\n+    }\n+\n+    \/**\n+     * Filtering methods for sampling between mipmaps. When a surface is at a distance that does not match a single\n+     * mipmap different algorithms exist for interpolating between the closest mipmap levels. Mipmapping is only valid\n+     * for minification since the base texture is the largest size image.\n+     *\/\n+    public enum MipmapFilterType {\n+\n+        \/**\n+         * No mimaping is used.\n+         *\/\n+        NONE,\n+        \/**\n+         * Chooses the nearest mipmap level. This is a cheap method, but can result in abrupt changes when the mipmap\n+         * level is switched.\n+         *\/\n+        NEAREST,\n+        \/**\n+         * Linearly interpolates between the 2 closest mipmap levels. This method is slightly slower than\n+         * {@code NEAREST}, but the result is a smooth transition between mipmap levels.\n+         *\/\n+        LINEAR;\n+    }\n+\n+    private final MinMagFilterType minFilterType;\n+    private final MinMagFilterType magFilterType;\n+    private final MipmapFilterType mipmapFilterType;\n+\n+    private TextureData(MinMagFilterType minFilterType, MinMagFilterType magFilterType, MipmapFilterType mipmapFilterType) {\n+        this.minFilterType = minFilterType;\n+        this.magFilterType = magFilterType;\n+        this.mipmapFilterType = mipmapFilterType;\n+    }\n+\n+    public MinMagFilterType minFilterType() { return minFilterType; }\n+    public MinMagFilterType magFilterType() { return magFilterType; }\n+    public MipmapFilterType mipmapFilterType() { return mipmapFilterType; }\n+\n+    public static class Builder {\n+\n+        private MinMagFilterType minFilterType = MinMagFilterType.BILINEAR;\n+        private MinMagFilterType magFilterType = MinMagFilterType.BILINEAR;\n+        private MipmapFilterType mipmapFilterType = MipmapFilterType.NONE;\n+\n+        public Builder() {}\n+\n+        public Builder minFilterType(MinMagFilterType minFilterType) {\n+            this.minFilterType = minFilterType;\n+            return this;\n+        }\n+\n+        public Builder magFilterType(MinMagFilterType magFilterType) {\n+            this.magFilterType = magFilterType;\n+            return this;\n+        }\n+\n+        public Builder mipmapFilterType(MipmapFilterType mipmapFilterType) {\n+            this.mipmapFilterType = mipmapFilterType;\n+            return this;\n+        }\n+\n+        public TextureData build() {\n+            return new TextureData(minFilterType, magFilterType, mipmapFilterType);\n+        }\n+    }\n+\n+    \/**\n+     * Mipmap images to be used when mipmapping is enabled. The images in this list must each be a power-of-2 smaller size\n+     * than the previous one. The image used as the main texture (level 0) should not be included.\n+     * To enable mipmapping, set {@link MipmapFilterType} to a value other than {@link MipmapFilterType#NONE NONE}.\n+     *\/\n+\/\/    private ObservableList<Image> mipmaps;\n+\/\/\n+\/\/    private int mipmapLevels;\n+\n+\/\/    enum WrapMode { \/\/ see com.sun.prism.Texture.WrapMode\n+\/\/    }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/paint\/TextureData.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -28,0 +28,3 @@\n+import java.util.Objects;\n+\n+import com.sun.javafx.scene.paint.TextureData;\n@@ -41,0 +44,6 @@\n+\n+    \/**\n+     * A default TextureData to be used instead of null. It allows access to the default values of TextureData.\n+     *\/\n+    private static final TextureData DEFAULT = new TextureData.Builder().build();\n+\n@@ -58,1 +67,0 @@\n-\n@@ -67,1 +75,1 @@\n-        validate(f);\n+        validate();\n@@ -84,2 +92,1 @@\n-    private void validate(ResourceFactory f) {\n-\n+    private void validate() {\n@@ -98,3 +105,2 @@\n-            if (diffuseMap.getImage() == null) {\n-                diffuseMap.setImage(WHITE_1X1);\n-            }\n+            diffuseMap.setImage(Objects.requireNonNullElse(diffuseMap.getImage(), WHITE_1X1));\n+            diffuseMap.setTextureData(Objects.requireNonNullElse(diffuseMap.getTextureData(), DEFAULT));\n@@ -105,0 +111,1 @@\n+            bumpMap.setTextureData(Objects.requireNonNullElse(bumpMap.getTextureData(), DEFAULT));\n@@ -108,0 +115,1 @@\n+            selfIllumMap.setTextureData(Objects.requireNonNullElse(selfIllumMap.getTextureData(), DEFAULT));\n@@ -111,0 +119,1 @@\n+            specularMap.setTextureData(Objects.requireNonNullElse(specularMap.getTextureData(), DEFAULT));\n@@ -150,0 +159,5 @@\n+    public void setDiffuseTextureData(TextureData textureData) {\n+        this.diffuseMap.setTextureData(textureData);\n+        this.diffuseMap.setDirty(true);\n+    }\n+\n@@ -155,0 +169,5 @@\n+    public void setSpecularTextureData(TextureData textureData) {\n+        this.specularMap.setTextureData(textureData);\n+        this.specularMap.setDirty(true);\n+    }\n+\n@@ -160,0 +179,5 @@\n+    public void setBumpTextureData(TextureData textureData) {\n+        this.bumpMap.setTextureData(textureData);\n+        this.bumpMap.setDirty(true);\n+    }\n+\n@@ -165,0 +189,5 @@\n+    public void setSelfIllumTextureData(TextureData textureData) {\n+        this.selfIllumMap.setTextureData(textureData);\n+        this.selfIllumMap.setDirty(true);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGPhongMaterial.java","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.javafx.scene.paint.TextureData;\n+\n@@ -35,0 +37,6 @@\n+    private TextureData textureData;\n+    \/**\n+     * The texture resource is requested from the resource manager with the image (and maybe later textureData) as\n+     * arguments. It's not taken from the material like image, textureData, and type are. We could consider some\n+     * refactoring in the texture area (texture could be removed from this class, or the whole class might be removed).\n+     *\/\n@@ -62,0 +70,8 @@\n+    public TextureData getTextureData() {\n+        return textureData;\n+    }\n+\n+    public void setTextureData(TextureData textureData) {\n+        this.textureData = textureData;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/TextureMap.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.javafx.scene.paint.TextureData;\n@@ -465,1 +466,1 @@\n-            int mapType, long texID);\n+            int mapType, int minFilter, int magFilter, int mipFilter, long nativeTexture);\n@@ -575,2 +576,3 @@\n-    void setMap(long nativePhongMaterial, int mapType, long nativeTexture) {\n-        nSetMap(pContext, nativePhongMaterial, mapType, nativeTexture);\n+    void setMap(long nativePhongMaterial, int mapType, TextureData textureData, long nativeTexture) {\n+        nSetMap(pContext, nativePhongMaterial, mapType, textureData.minFilterType().ordinal(),\n+                textureData.magFilterType().ordinal(), textureData.mipmapFilterType().ordinal(), nativeTexture);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/d3d\/D3DContext.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import com.sun.javafx.scene.paint.TextureData;\n@@ -80,0 +81,1 @@\n+        TextureData textureData = map.getTextureData();\n@@ -84,1 +86,1 @@\n-        context.setMap(nativeHandle, map.getType().ordinal(), hTexture);\n+        context.setMap(nativeHandle, map.getType().ordinal(), textureData, hTexture);\n@@ -98,1 +100,2 @@\n-            \/\/ Enable mipmap if map is diffuse or self illum.\n+            \/\/ Enable mipmap if map is diffuse or self illum. In D3DResourceManager::CreateTexture the mipmap level\n+            \/\/ is set to 1, so the useMipmap flag has no effect until that is changed\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/d3d\/D3DPhongMaterial.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -355,0 +355,4 @@\n+\n+enum minmagFilterType { nearest_point, bilinear };\n+enum mipmapFilterType { none, nearest, linear };\n+\n@@ -362,1 +366,1 @@\n-        jint mapType, jlong nativeTexture)\n+        jint mapType, jint minFilter, jint magFilter, jint mipFilter, jlong nativeTexture)\n@@ -364,0 +368,3 @@\n+    static const D3DTEXTUREFILTERTYPE minMagEnumMap[2] = { D3DTEXF_POINT, D3DTEXF_LINEAR };\n+    static const D3DTEXTUREFILTERTYPE mipmapEnumMap[3] = { D3DTEXF_NONE, D3DTEXF_POINT, D3DTEXF_LINEAR };\n+\n@@ -366,1 +373,1 @@\n-    IDirect3DBaseTexture9 *texMap = (IDirect3DBaseTexture9 *)  jlong_to_ptr(nativeTexture);\n+    IDirect3DBaseTexture9 *texMap = (IDirect3DBaseTexture9 *) jlong_to_ptr(nativeTexture);\n@@ -369,1 +376,2 @@\n-    phongMaterial->setMap(mapType, texMap);\n+    phongMaterial->setMap(static_cast<map_type>(mapType), texMap,\n+            minMagEnumMap[minFilter], minMagEnumMap[magFilter], mipmapEnumMap[mipFilter]);\n@@ -621,1 +629,0 @@\n-        \/\/ TODO: 3D - RT-34415: [D3D 3D] Need a robust 3D states management for texture\n@@ -623,0 +630,1 @@\n+        \/\/ TODO: Consider giving these the same treatment as setting the filters in D3DContext::nSetMap\n@@ -624,4 +632,1 @@\n-        SUCCEEDED(res = pd3dDevice->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP)) &&\n-        \/\/ Set texture filter to bilinear for 3D rendering\n-        SUCCEEDED(res = pd3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR)) &&\n-        SUCCEEDED(res = pd3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR));\n+        SUCCEEDED(res = pd3dDevice->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP));\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DContext.cc","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -292,4 +292,8 @@\n-    SUCCEEDED(device->SetTexture(SR_DIFFUSE_MAP, material->getMap(DIFFUSE)));\n-    SUCCEEDED(device->SetTexture(SR_SPECULAR_MAP, material->getMap(SPECULAR)));\n-    SUCCEEDED(device->SetTexture(SR_BUMPHEIGHT_MAP, material->getMap(BUMP)));\n-    SUCCEEDED(device->SetTexture(SR_SELFILLUM_MAP, material->getMap(SELFILLUMINATION)));\n+    \/\/ Set the textures and their filters in their corresponding samplers\n+    for (int i = 0; i < map_type::num_map_types; i++) {\n+        map_type type = static_cast<map_type>(i);\n+        SUCCEEDED(device->SetTexture(type, material->getMap(type)));\n+        SUCCEEDED(device->SetSamplerState(type, D3DSAMP_MINFILTER, material->getMinFilterType(type)));\n+        SUCCEEDED(device->SetSamplerState(type, D3DSAMP_MAGFILTER, material->getMagFilterType(type)));\n+        SUCCEEDED(device->SetSamplerState(type, D3DSAMP_MIPFILTER, material->getMipFilterType(type)));\n+    }\n@@ -303,2 +307,1 @@\n-        SUCCEEDED(device->SetRenderState(D3DRS_FILLMODE,\n-                wireframe ? D3DFILL_WIREFRAME : D3DFILL_SOLID));\n+        SUCCEEDED(device->SetRenderState(D3DRS_FILLMODE, wireframe ? D3DFILL_WIREFRAME : D3DFILL_SOLID));\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DMeshView.cc","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,4 +37,3 @@\n-    map[DIFFUSE] = NULL;\n-    map[SPECULAR] = NULL;\n-    map[BUMP] = NULL;\n-    map[SELFILLUMINATION] = NULL;\n+    for (int i = 0; i < map_type::num_map_types; i++) {\n+        map[i] = NULL;\n+    }\n@@ -71,1 +70,1 @@\n-    return map[BUMP] ? true : false;\n+    return map[map_type::bump] ? true : false;\n@@ -75,1 +74,1 @@\n-    return map[SPECULAR] ? true : false;\n+    return map[map_type::specular] ? true : false;\n@@ -79,1 +78,1 @@\n-    return map[SELFILLUMINATION] ? true : false;\n+    return map[map_type::self_illumination] ? true : false;\n@@ -86,7 +85,2 @@\n-IDirect3DBaseTexture9 * D3DPhongMaterial::getMap(int type) {\n-    \/\/ Within the range of DIFFUSE, SPECULAR, BUMP, SELFILLUMINATION\n-    if (type >= 0 && type <= 3) {\n-        return map[type];\n-    }\n-    cerr << \"D3DPhongMaterial::getMap -- type is out of range - type = \" << type << endl;\n-    return NULL;\n+IDirect3DBaseTexture9 * D3DPhongMaterial::getMap(map_type type) {\n+    return map[type];\n@@ -95,7 +89,18 @@\n-void D3DPhongMaterial::setMap(int mapID, IDirect3DBaseTexture9 *texMap) {\n-    \/\/ Within the range of DIFFUSE, SPECULAR, BUMP, SELFILLUMINATION\n-    if (mapID >= 0 && mapID <= 3) {\n-        map[mapID] = texMap;\n-    } else {\n-        cerr << \"D3DPhongMaterial::getMap -- mapID is out of range - mapID = \" << mapID << endl;\n-    }\n+D3DTEXTUREFILTERTYPE D3DPhongMaterial::getMinFilterType(map_type type) {\n+    return minFilter[type];\n+}\n+\n+D3DTEXTUREFILTERTYPE D3DPhongMaterial::getMagFilterType(map_type type) {\n+    return magFilter[type];\n+}\n+\n+D3DTEXTUREFILTERTYPE D3DPhongMaterial::getMipFilterType(map_type type) {\n+    return mipFilter[type];\n+}\n+\n+void D3DPhongMaterial::setMap(map_type type, IDirect3DBaseTexture9 *texMap, D3DTEXTUREFILTERTYPE min,\n+        D3DTEXTUREFILTERTYPE mag, D3DTEXTUREFILTERTYPE mip) {\n+    map[type] = texMap;\n+    minFilter[type] = min;\n+    magFilter[type] = mag;\n+    mipFilter[type] = mip;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DPhongMaterial.cc","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -33,4 +33,9 @@\n-#define DIFFUSE 0\n-#define SPECULAR 1\n-#define BUMP 2\n-#define SELFILLUMINATION 3\n+\/\/ Map type numbered sequence used for sampling registers (we have 4 sampling registers for vs 3.0).\n+\/\/ Order is defined by com.sun.prism.PhongMaterial's MapType enum\n+enum map_type : unsigned int {\n+    diffuse,\n+    specular,\n+    bump,\n+    self_illumination,\n+    num_map_types\n+};\n@@ -46,1 +51,2 @@\n-    void setMap(int mapID, IDirect3DBaseTexture9 *texMap);\n+    void setMap(map_type mapID, IDirect3DBaseTexture9 *texMap, D3DTEXTUREFILTERTYPE min,\n+            D3DTEXTUREFILTERTYPE mag, D3DTEXTUREFILTERTYPE mip);\n@@ -51,1 +57,4 @@\n-    IDirect3DBaseTexture9 * getMap(int type);\n+    IDirect3DBaseTexture9 * getMap(map_type type);\n+    D3DTEXTUREFILTERTYPE getMinFilterType(map_type type);\n+    D3DTEXTUREFILTERTYPE getMagFilterType(map_type type);\n+    D3DTEXTUREFILTERTYPE getMipFilterType(map_type type);\n@@ -57,1 +66,0 @@\n-    IDirect3DBaseTexture9 *map[4] = {NULL};\n@@ -59,0 +67,4 @@\n+    IDirect3DBaseTexture9 *map[map_type::num_map_types] = {NULL};\n+    D3DTEXTUREFILTERTYPE minFilter[map_type::num_map_types] = {NULL};\n+    D3DTEXTUREFILTERTYPE magFilter[map_type::num_map_types] = {NULL};\n+    D3DTEXTUREFILTERTYPE mipFilter[map_type::num_map_types] = {NULL};\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DPhongMaterial.h","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -68,6 +68,0 @@\n-\/\/ SR implies Sampler Registers\n-#define SR_DIFFUSE_MAP 0\n-#define SR_SPECULAR_MAP 1\n-#define SR_BUMPHEIGHT_MAP 2\n-#define SR_SELFILLUM_MAP 3\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DPhongShader.h","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}