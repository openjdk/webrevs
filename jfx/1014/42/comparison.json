{"files":[{"patch":"@@ -33,1 +33,1 @@\n-\t\t\t<attribute name=\"add-exports\" value=\"javafx.base\/com.sun.javafx.property=javafx.graphics:javafx.base\/test.util.memory=javafx.graphics\"\/>\n+\t\t\t<attribute name=\"add-exports\" value=\"javafx.base\/com.sun.javafx.property=javafx.graphics:javafx.base\/test.javafx.collections=javafx.graphics:javafx.base\/test.util.memory=javafx.graphics\"\/>\n","filename":"modules\/javafx.graphics\/.classpath","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,2 +87,1 @@\n-        public boolean handleThemeChanged(String themeName) {\n-            return false;\n+        public void handlePreferencesChanged(Map<String, Object> preferences) {\n@@ -262,1 +261,1 @@\n-    protected boolean notifyThemeChanged(String themeName) {\n+    protected void notifyPreferencesChanged(Map<String, Object> preferences) {\n@@ -265,1 +264,1 @@\n-            return handler.handleThemeChanged(themeName);\n+            handler.handlePreferencesChanged(preferences);\n@@ -267,1 +266,0 @@\n-        return false;\n@@ -678,13 +676,0 @@\n-    public String getHighContrastScheme(String themeName) {\n-        return themeName;\n-    }\n-\n-    \/**\n-     * Gets the Name of the currently active high contrast theme.\n-     * If null, then high contrast is not enabled.\n-     *\/\n-    public String getHighContrastTheme() {\n-        checkEventThread();\n-        return null;\n-    }\n-\n@@ -771,0 +756,47 @@\n+\n+    \/**\n+     * Returns the current set of platform properties as a map of platform-specific keys to\n+     * arbitrary values. This is a snapshot, and won't be updated. There are no guarantees on\n+     * the implementation type, modifiability or serializability of the returned {@code Map}.\n+     *\n+     * @return the current set of platform preferences\n+     *\/\n+    public Map<String, Object> getPlatformPreferences() {\n+        return Map.of();\n+    }\n+\n+    \/**\n+     * Returns a map of platform-specific keys to platform-independent keys defined by JavaFX.\n+     * <p>\n+     * For example, the platform-specific key \"Windows.UIColor.Foreground\" is mapped to the key \"foregroundColor\",\n+     * which makes it easier to write shared code without depending on platform-specific details.\n+     * <p>\n+     * The following platform-independent keys are currently supported, which correspond to the names of color\n+     * properties on the {@link com.sun.javafx.application.preferences.PreferenceProperties} class:\n+     * <ul>\n+     *     <li>foregroundColor\n+     *     <li>backgroundColor\n+     *     <li>accentColor\n+     * <\/ul>\n+     *\n+     * @return a map of platform-specific keys to well-known keys\n+     *\/\n+    public Map<String, String> getPlatformKeyMappings() {\n+        return Map.of();\n+    }\n+\n+    \/**\n+     * Returns a mapping of platform-specific keys to the types of their values.\n+     * Polymorphic types are supported by specifying the common base type; for example, a key can\n+     * be mapped to {@code Paint.class} to support any type of paint.\n+     * <p>\n+     * Implementors must keep this map in sync with the mappings reported by the native Glass toolkit.\n+     * If a native toolkit reports mappings for keys that are not contained in this map, the typed getters\n+     * in {@link javafx.application.Platform.Preferences} might not throw {@code IllegalArgumentException}\n+     * as specified.\n+     *\n+     * @return a map of platform-specific keys to types\n+     *\/\n+    public Map<String, Class<?>> getPlatformKeys() {\n+        return Map.of();\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/Application.java","additions":51,"deletions":19,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import javafx.scene.paint.Color;\n@@ -470,0 +471,36 @@\n+    @Override\n+    public native Map<String, Object> getPlatformPreferences();\n+\n+    @Override\n+    public Map<String, String> getPlatformKeyMappings() {\n+        return Map.of(\n+            \"GTK.theme_fg_color\", \"foregroundColor\",\n+            \"GTK.theme_bg_color\", \"backgroundColor\"\n+        );\n+    }\n+\n+    \/\/ This list needs to be kept in sync with PlatformSupport.cpp in the Glass toolkit for GTK.\n+    @Override\n+    public Map<String, Class<?>> getPlatformKeys() {\n+        return Map.ofEntries(\n+            Map.entry(\"GTK.theme_name\", String.class),\n+            Map.entry(\"GTK.theme_fg_color\", Color.class),\n+            Map.entry(\"GTK.theme_bg_color\", Color.class),\n+            Map.entry(\"GTK.theme_base_color\", Color.class),\n+            Map.entry(\"GTK.theme_selected_bg_color\", Color.class),\n+            Map.entry(\"GTK.theme_selected_fg_color\", Color.class),\n+            Map.entry(\"GTK.theme_unfocused_fg_color\", Color.class),\n+            Map.entry(\"GTK.theme_unfocused_bg_color\", Color.class),\n+            Map.entry(\"GTK.theme_unfocused_base_color\", Color.class),\n+            Map.entry(\"GTK.theme_unfocused_selected_bg_color\", Color.class),\n+            Map.entry(\"GTK.theme_unfocused_selected_fg_color\", Color.class),\n+            Map.entry(\"GTK.insensitive_bg_color\", Color.class),\n+            Map.entry(\"GTK.insensitive_fg_color\", Color.class),\n+            Map.entry(\"GTK.insensitive_base_color\", Color.class),\n+            Map.entry(\"GTK.borders\", Color.class),\n+            Map.entry(\"GTK.unfocused_borders\", Color.class),\n+            Map.entry(\"GTK.warning_color\", Color.class),\n+            Map.entry(\"GTK.error_color\", Color.class),\n+            Map.entry(\"GTK.success_color\", Color.class)\n+        );\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkApplication.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import javafx.scene.paint.Color;\n@@ -39,0 +40,1 @@\n+import java.util.Map;\n@@ -391,0 +393,65 @@\n+\n+    @Override\n+    public native Map<String, Object> getPlatformPreferences();\n+\n+    @Override\n+    public Map<String, String> getPlatformKeyMappings() {\n+        return Map.of(\n+            \"macOS.NSColor.textColor\", \"foregroundColor\",\n+            \"macOS.NSColor.textBackgroundColor\", \"backgroundColor\",\n+            \"macOS.NSColor.controlAccentColor\", \"accentColor\"\n+        );\n+    }\n+\n+    \/\/ This list needs to be kept in sync with PlatformSupport.m in the Glass toolkit for macOS.\n+    @Override\n+    public Map<String, Class<?>> getPlatformKeys() {\n+        return Map.ofEntries(\n+            Map.entry(\"macOS.NSColor.labelColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.secondaryLabelColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.tertiaryLabelColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.quaternaryLabelColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.textColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.placeholderTextColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.selectedTextColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.textBackgroundColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.selectedTextBackgroundColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.keyboardFocusIndicatorColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.unemphasizedSelectedTextColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.unemphasizedSelectedTextBackgroundColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.linkColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.separatorColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.selectedContentBackgroundColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.unemphasizedSelectedContentBackgroundColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.selectedMenuItemTextColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.gridColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.headerTextColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.alternatingContentBackgroundColors\", Color[].class),\n+            Map.entry(\"macOS.NSColor.controlAccentColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.controlColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.controlBackgroundColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.controlTextColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.disabledControlTextColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.selectedControlColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.selectedControlTextColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.alternateSelectedControlTextColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.currentControlTint\", String.class),\n+            Map.entry(\"macOS.NSColor.windowBackgroundColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.windowFrameTextColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.underPageBackgroundColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.findHighlightColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.highlightColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.shadowColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.systemBlueColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.systemBrownColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.systemGrayColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.systemGreenColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.systemIndigoColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.systemOrangeColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.systemPinkColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.systemPurpleColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.systemRedColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.systemTealColor\", Color.class),\n+            Map.entry(\"macOS.NSColor.systemYellowColor\", Color.class)\n+        );\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/mac\/MacApplication.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import com.sun.javafx.application.PlatformImpl;\n@@ -33,0 +32,1 @@\n+import javafx.scene.paint.Color;\n@@ -39,1 +39,1 @@\n-import java.util.ResourceBundle;\n+import java.util.Map;\n@@ -44,1 +44,0 @@\n-    private static final String BASE_NAME = \"com\/sun\/glass\/ui\/win\/themes\";\n@@ -344,11 +343,0 @@\n-    @Override\n-    public String getHighContrastScheme(String themeName) {\n-        return PlatformImpl.HighContrastScheme.fromThemeName(ResourceBundle.getBundle(BASE_NAME)::getString, themeName);\n-    }\n-\n-    private native String _getHighContrastTheme();\n-    @Override public String getHighContrastTheme() {\n-        checkEventThread();\n-        return getHighContrastScheme(_getHighContrastTheme());\n-    }\n-\n@@ -383,0 +371,38 @@\n+\n+    @Override\n+    public native Map<String, Object> getPlatformPreferences();\n+\n+    @Override\n+    public Map<String, String> getPlatformKeyMappings() {\n+        return Map.of(\n+            \"Windows.UIColor.ForegroundColor\", \"foregroundColor\",\n+            \"Windows.UIColor.BackgroundColor\", \"backgroundColor\",\n+            \"Windows.UIColor.AccentColor\", \"accentColor\"\n+        );\n+    }\n+\n+    \/\/ This list needs to be kept in sync with PlatformSupport.cpp in the Glass toolkit for Windows.\n+    @Override\n+    public Map<String, Class<?>> getPlatformKeys() {\n+        return Map.ofEntries(\n+            Map.entry(\"Windows.SPI.HighContrast\", Boolean.class),\n+            Map.entry(\"Windows.SPI.HighContrastColorScheme\", String.class),\n+            Map.entry(\"Windows.SysColor.COLOR_3DFACE\", Color.class),\n+            Map.entry(\"Windows.SysColor.COLOR_BTNTEXT\", Color.class),\n+            Map.entry(\"Windows.SysColor.COLOR_GRAYTEXT\", Color.class),\n+            Map.entry(\"Windows.SysColor.COLOR_HIGHLIGHT\", Color.class),\n+            Map.entry(\"Windows.SysColor.COLOR_HIGHLIGHTTEXT\", Color.class),\n+            Map.entry(\"Windows.SysColor.COLOR_HOTLIGHT\", Color.class),\n+            Map.entry(\"Windows.SysColor.COLOR_WINDOW\", Color.class),\n+            Map.entry(\"Windows.SysColor.COLOR_WINDOWTEXT\", Color.class),\n+            Map.entry(\"Windows.UIColor.Background\", Color.class),\n+            Map.entry(\"Windows.UIColor.Foreground\", Color.class),\n+            Map.entry(\"Windows.UIColor.AccentDark3\", Color.class),\n+            Map.entry(\"Windows.UIColor.AccentDark2\", Color.class),\n+            Map.entry(\"Windows.UIColor.AccentDark1\", Color.class),\n+            Map.entry(\"Windows.UIColor.Accent\", Color.class),\n+            Map.entry(\"Windows.UIColor.AccentLight1\", Color.class),\n+            Map.entry(\"Windows.UIColor.AccentLight2\", Color.class),\n+            Map.entry(\"Windows.UIColor.AccentLight3\", Color.class)\n+        );\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinApplication.java","additions":40,"deletions":14,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import com.sun.javafx.application.preferences.PlatformPreferences;\n@@ -1047,0 +1048,55 @@\n+\n+    private static PlatformPreferences platformPreferences;\n+\n+    public static PlatformPreferences getPlatformPreferences() {\n+        if (platformPreferences == null) {\n+            throw new IllegalStateException(\"Toolkit not initialized\");\n+        }\n+\n+        return platformPreferences;\n+    }\n+\n+    \/**\n+     * Called by Glass when the toolkit is initialized.\n+     *\n+     * @param platformKeyMappings a map of platform-specific keys to well-known keys\n+     * @param preferences the initial set of platform preferences\n+     *\/\n+    public static void initPreferences(Map<String, Class<?>> platformKeys,\n+                                       Map<String, String> platformKeyMappings,\n+                                       Map<String, Object> preferences) {\n+        platformPreferences = new PlatformPreferences(platformKeys, platformKeyMappings);\n+        platformPreferences.update(preferences);\n+    }\n+\n+    \/**\n+     * Called by Glass when one or several platform preferences have changed.\n+     * <p>\n+     * This method can be called on any thread. The supplied {@code preferences} map may\n+     * include all platform preferences, or only the changed preferences. If a preference\n+     * was removed, the corresponding key is mapped to {@code null}.\n+     *\n+     * @param preferences a map that includes the changed preferences\n+     *\/\n+    public static void updatePreferences(Map<String, Object> preferences) {\n+        if (isFxApplicationThread()) {\n+            checkHighContrastThemeChanged(preferences);\n+            platformPreferences.update(preferences);\n+        } else {\n+            \/\/ Make a defensive copy in case the caller of this method decides to re-use or\n+            \/\/ modify its preferences map after the method returns. Don't use Map.copyOf\n+            \/\/ because the preferences map may contain null values.\n+            Map<String, Object> preferencesCopy = new HashMap<>(preferences);\n+            runLater(() -> updatePreferences(preferencesCopy));\n+        }\n+    }\n+\n+    \/\/ This method will be removed when StyleThemes are added.\n+    private static void checkHighContrastThemeChanged(Map<String, Object> preferences) {\n+        if (Boolean.TRUE.equals(preferences.get(\"Windows.SPI.HighContrastOn\"))) {\n+            setAccessibilityTheme(preferences.get(\"Windows.SPI.HighContrastColorScheme\") instanceof String s ? s : null);\n+        } else {\n+            setAccessibilityTheme(null);\n+        }\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/application\/PlatformImpl.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.application.preferences;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+\/**\n+ * Contains information about a changed value.\n+ *\n+ * @param oldValue the old mappings\n+ * @param newValue the new mappings\n+ *\/\n+public record ChangedValue(Object oldValue, Object newValue) {\n+\n+    \/**\n+     * Returns a map that contains the new or changed mappings of {@code current} compared to {@code old}.\n+     * A value has changed if {@link Objects#equals(Object, Object)} or {@link Arrays#equals(Object[], Object[])}\n+     * returns {@code false} when invoked with the old and new value.\n+     *\n+     * @param old the old mappings\n+     * @param current the current mappings\n+     * @return a mapping of keys to changed values\n+     *\/\n+    public static Map<String, ChangedValue> getEffectiveChanges(Map<String, Object> old, Map<String, Object> current) {\n+        Map<String, ChangedValue> changed = null;\n+\n+        for (Map.Entry<String, Object> entry : current.entrySet()) {\n+            Object newValue = entry.getValue();\n+            Object oldValue = old.get(entry.getKey());\n+\n+            if (!Objects.deepEquals(oldValue, newValue)) {\n+                if (changed == null) {\n+                    changed = new HashMap<>();\n+                }\n+\n+                changed.put(entry.getKey(), new ChangedValue(oldValue, newValue));\n+            }\n+        }\n+\n+        return changed != null ? changed : Map.of();\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/application\/preferences\/ChangedValue.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,380 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.application.preferences;\n+\n+import com.sun.javafx.binding.MapExpressionHelper;\n+import javafx.application.ColorScheme;\n+import javafx.application.Platform;\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.property.ReadOnlyObjectProperty;\n+import javafx.collections.MapChangeListener;\n+import javafx.scene.paint.Color;\n+import java.io.Serializable;\n+import java.lang.reflect.Modifier;\n+import java.util.AbstractMap;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+\/**\n+ * Contains the implementation of a read-only map of platform preferences.\n+ * <p>\n+ * When the operating system signals that a preference has changed, the mappings are updated\n+ * by calling the {@link #update(Map)} method.\n+ *\/\n+public class PlatformPreferences extends AbstractMap<String, Object> implements Platform.Preferences {\n+\n+    \/**\n+     * Contains mappings from platform-specific keys to their types. This information is\n+     * used to catch misuse of typed getters even if the preferences map doesn't contain\n+     * the preference mapping at runtime.\n+     *\/\n+    private final Map<String, Class<?>> platformKeys;\n+\n+    \/**\n+     * Contains mappings from platform-specific keys to well-known keys, which are used\n+     * in the implementation of the property-based API in {@link PreferenceProperties}.\n+     *\/\n+    private final Map<String, String> platformKeyMappings;\n+\n+    \/**\n+     * Contains the current set of effective preferences, i.e. the set of preferences that\n+     * we know to be the current state of the world, and are exposed to users of this map.\n+     *\/\n+    private final Map<String, Object> effectivePreferences = new HashMap<>();\n+    private final Map<String, Object> unmodifiableEffectivePreferences = Collections.unmodifiableMap(effectivePreferences);\n+\n+    \/** Contains the implementation of the property-based API. *\/\n+    private final PreferenceProperties properties = new PreferenceProperties(this);\n+\n+    private final List<InvalidationListener> invalidationListeners = new CopyOnWriteArrayList<>();\n+    private final List<MapChangeListener<? super String, Object>> mapChangeListeners = new CopyOnWriteArrayList<>();\n+\n+    \/**\n+     * Initializes a new {@code PlatformPreferences} instance with the given platform-specific keys and key mappings.\n+     *\n+     * @param platformKeys the platform-specific keys and the types of their values\n+     * @param platformKeyMappings the platform-specific key mappings\n+     * @throws NullPointerException if {@code platformKeys} or {@code platformKeyMappings} is {@code null} or\n+     *                              contains {@code null} keys or values\n+     *\/\n+    public PlatformPreferences(Map<String, Class<?>> platformKeys, Map<String, String> platformKeyMappings) {\n+        this.platformKeys = Map.copyOf(platformKeys);\n+        this.platformKeyMappings = Map.copyOf(platformKeyMappings);\n+    }\n+\n+    @Override\n+    public Set<Entry<String, Object>> entrySet() {\n+        return unmodifiableEffectivePreferences.entrySet();\n+    }\n+\n+    @Override\n+    public Object remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void addListener(InvalidationListener listener) {\n+        invalidationListeners.add(listener);\n+    }\n+\n+    @Override\n+    public void removeListener(InvalidationListener listener) {\n+        invalidationListeners.remove(listener);\n+    }\n+\n+    @Override\n+    public void addListener(MapChangeListener<? super String, ? super Object> listener) {\n+        mapChangeListeners.add(listener);\n+    }\n+\n+    @Override\n+    public void removeListener(MapChangeListener<? super String, ? super Object> listener) {\n+        mapChangeListeners.remove(listener);\n+    }\n+\n+    @Override\n+    public <T> Optional<T> getValue(String key, Class<T> type) {\n+        Objects.requireNonNull(key, \"key cannot be null\");\n+        Objects.requireNonNull(type, \"type cannot be null\");\n+        Class<?> platformType = platformKeys.get(key);\n+        Object value = effectivePreferences.get(key);\n+\n+        if (platformType == null) {\n+            \/\/ Well-behaved toolkits shouldn't report values for keys that are not listed in the\n+            \/\/ platform key-type map. However, if they do, we need to respect the invariant that\n+            \/\/ Map.getValue(key, type) should only return an empty value if Map.get(key) would\n+            \/\/ return null. In all other cases we need to return the value if the cast succeeds.\n+            if (value != null) {\n+                if (type.isInstance(value)) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    T v = (T)value;\n+                    return Optional.of(v);\n+                }\n+\n+                throw new IllegalArgumentException(\n+                    \"Incompatible types: requested = \" + type.getName() +\n+                    \", actual = \" + value.getClass().getName());\n+            }\n+\n+            return Optional.empty();\n+        }\n+\n+        \/\/ Check whether the declared platform type is convertible to the requested type.\n+        \/\/ This check validates that a casting conversion exists at all, even if we don't have a\n+        \/\/ value that we would need in order to use Class.isInstance to check if the conversion\n+        \/\/ succeeds at runtime.\n+        if (!isConvertible(platformType, type)) {\n+            throw new IllegalArgumentException(\n+                \"Incompatible types: requested = \" + type.getName() +\n+                \", actual = \" + platformType.getName());\n+        }\n+\n+        if (value == null) {\n+            return Optional.empty();\n+        }\n+\n+        \/\/ The runtime type of the value might be a subtype of the platform type, which necessitates\n+        \/\/ checking whether the actual type is convertible to the requested type.\n+        if (!type.isInstance(value)) {\n+            throw new IllegalArgumentException(\n+                \"Incompatible types: requested = \" + type.getName() +\n+                \", actual = \" + value.getClass().getName());\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T v = (T)value;\n+        return Optional.of(v);\n+    }\n+\n+\n+    @Override\n+    public Optional<Integer> getInteger(String key) {\n+        return getValue(key, Integer.class);\n+    }\n+\n+    @Override\n+    public Optional<Double> getDouble(String key) {\n+        return getValue(key, Double.class);\n+    }\n+\n+    @Override\n+    public Optional<Boolean> getBoolean(String key) {\n+        return getValue(key, Boolean.class);\n+    }\n+\n+    @Override\n+    public Optional<String> getString(String key) {\n+        return getValue(key, String.class);\n+    }\n+\n+    @Override\n+    public Optional<Color> getColor(String key) {\n+        return getValue(key, Color.class);\n+    }\n+\n+    @Override\n+    public ReadOnlyObjectProperty<ColorScheme> colorSchemeProperty() {\n+        return properties.colorSchemeProperty();\n+    }\n+\n+    @Override\n+    public ColorScheme getColorScheme() {\n+        return properties.getColorScheme();\n+    }\n+\n+    @Override\n+    public ReadOnlyObjectProperty<Color> backgroundColorProperty() {\n+        return properties.backgroundColorProperty();\n+    }\n+\n+    @Override\n+    public Color getBackgroundColor() {\n+        return properties.getBackgroundColor();\n+    }\n+\n+    @Override\n+    public ReadOnlyObjectProperty<Color> foregroundColorProperty() {\n+        return properties.foregroundColorProperty();\n+    }\n+\n+    @Override\n+    public Color getForegroundColor() {\n+        return properties.getForegroundColor();\n+    }\n+\n+    @Override\n+    public ReadOnlyObjectProperty<Color> accentColorProperty() {\n+        return properties.accentColorProperty();\n+    }\n+\n+    @Override\n+    public Color getAccentColor() {\n+        return properties.getAccentColor();\n+    }\n+\n+    \/**\n+     * Updates this map of preferences with a new set of platform preferences.\n+     * The specified preferences may include all available preferences, or only the changed preferences.\n+     * The absence of a mapping in the specified preferences does not indicate that it should be removed;\n+     * instead, a key must be explicitly mapped to {@code null} to remove the mapping. Consequently, this\n+     * map will never contain {@code null} values.\n+     *\n+     * @param preferences the new preference mappings\n+     * @throws NullPointerException if {@code preferences} is {@code null}\n+     *\/\n+    public void update(Map<String, Object> preferences) {\n+        Map<String, Object> currentPreferences = Map.copyOf(effectivePreferences);\n+        effectivePreferences.putAll(preferences);\n+\n+        \/\/ Only fire change notifications if any preference has effectively changed.\n+        Map<String, ChangedValue> effectivelyChangedPreferences =\n+            ChangedValue.getEffectiveChanges(currentPreferences, effectivePreferences);\n+\n+        \/\/ The new mappings may contain null values, which indicates that a mapping was removed.\n+        effectivePreferences.entrySet().removeIf(entry -> entry.getValue() == null);\n+\n+        if (!effectivelyChangedPreferences.isEmpty()) {\n+            properties.update(effectivelyChangedPreferences, platformKeyMappings);\n+            fireValueChangedEvent(effectivelyChangedPreferences);\n+        }\n+    }\n+\n+    private void fireValueChangedEvent(Map<String, ChangedValue> changedEntries) {\n+        invalidationListeners.forEach(listener -> listener.invalidated(this));\n+        var change = new MapExpressionHelper.SimpleChange<>(this);\n+\n+        for (Map.Entry<String, ChangedValue> entry : changedEntries.entrySet()) {\n+            Object oldValue = entry.getValue().oldValue();\n+            Object newValue = entry.getValue().newValue();\n+\n+            if (oldValue == null && newValue != null) {\n+                change.setAdded(entry.getKey(), newValue);\n+            } else if (oldValue != null && newValue == null) {\n+                change.setRemoved(entry.getKey(), oldValue);\n+            } else {\n+                change.setPut(entry.getKey(), oldValue, newValue);\n+            }\n+\n+            for (var listener : mapChangeListeners) {\n+                listener.onChanged(change);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Determines whether a compile-time casting conversion exists from {@code source} to {@code target}.\n+     * This is an implementation of JLS 5.5.1 (Reference Type Casting).\n+     *\n+     * @param source the source type\n+     * @param target the target type\n+     * @return {@code true} if a casting conversion exists, {@code false} otherwise\n+     *\/\n+    private boolean isConvertible(Class<?> source, Class<?> target) {\n+        if (source.isArray()) {\n+            return isArrayConvertible(source, target);\n+        }\n+\n+        if (source.isInterface()) {\n+            return isInterfaceConvertible(source, target);\n+        }\n+\n+        return isClassConvertible(source, target);\n+    }\n+\n+    \/\/ Assuming S is a class type:\n+    private boolean isClassConvertible(Class<?> source, Class<?> target) {\n+        \/\/ If T is an interface type:\n+        \/\/   1. If S is final, then S must implement T.\n+        \/\/   2. If S is not final, the cast is always legal (because even if S does not\n+        \/\/      implement T, a subclass of S might).\n+        if (target.isInterface()) {\n+            return !Modifier.isFinal(source.getModifiers()) || target.isAssignableFrom(source);\n+        }\n+\n+        \/\/ If T is an array type, then S must be the class Object.\n+        if (target.isArray()) {\n+            return source == Object.class;\n+        }\n+\n+        \/\/ If T is a class type, then either S<:T, or T<:S.\n+        return target.isAssignableFrom(source) || source.isAssignableFrom(target);\n+    }\n+\n+    \/\/ Assuming S is an interface type:\n+    private boolean isInterfaceConvertible(Class<?> source, Class<?> target) {\n+        \/\/ If T is an array type, then S must be the type Serializable or Cloneable.\n+        if (target.isArray()) {\n+            return source == Serializable.class || source == Cloneable.class;\n+        }\n+\n+        \/\/ If T is not final, the cast is always legal (because even if S does not\n+        \/\/ implement T, a subclass of S might).\n+        if (!Modifier.isFinal(target.getModifiers())) {\n+            return true;\n+        }\n+\n+        \/\/ If T is a class type that is final, then T must implement S.\n+        return source.isAssignableFrom(target);\n+    }\n+\n+    \/\/ Assuming S is an array type SC[], that is, an array of components of type SC:\n+    private boolean isArrayConvertible(Class<?> source, Class<?> target) {\n+        \/\/ If T is an interface type, then it must be the type Serializable or Cloneable,\n+        \/\/ which are the only interfaces implemented by arrays.\n+        if (target.isInterface()) {\n+            return target == Serializable.class || target == Cloneable.class;\n+        }\n+\n+        \/\/ If T is an array type TC[], that is, an array of components of type TC,\n+        \/\/ then one of the following must be true:\n+        \/\/   1. TC and SC are the same primitive type\n+        \/\/   2. TC and SC are reference types and type SC can undergo casting conversion to TC\n+        if (target.isArray()) {\n+            Class<?> sourceComponentType = source.getComponentType();\n+            Class<?> targetComponentType = target.getComponentType();\n+\n+            if (sourceComponentType.isPrimitive() && targetComponentType.isPrimitive()) {\n+                return sourceComponentType == targetComponentType;\n+            }\n+\n+            if (!sourceComponentType.isPrimitive() && !targetComponentType.isPrimitive()) {\n+                return isConvertible(sourceComponentType, targetComponentType);\n+            }\n+\n+            return false;\n+        }\n+\n+        \/\/ If T is a class type, then T must be Object because Object is the only\n+        \/\/ class type to which arrays can be assigned.\n+        return target == Object.class;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/application\/preferences\/PlatformPreferences.java","additions":380,"deletions":0,"binary":false,"changes":380,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.application.preferences;\n+\n+import com.sun.javafx.util.Logging;\n+import com.sun.javafx.util.Utils;\n+import javafx.application.ColorScheme;\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.property.Property;\n+import javafx.beans.property.ReadOnlyObjectProperty;\n+import javafx.beans.property.ReadOnlyObjectPropertyBase;\n+import javafx.beans.property.ReadOnlyObjectWrapper;\n+import javafx.scene.paint.Color;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+\/**\n+ * Contains {@link Property}-based preference implementations.\n+ *\/\n+final class PreferenceProperties {\n+\n+    private final ColorProperty backgroundColor = new ColorProperty(\"backgroundColor\", Color.WHITE);\n+    private final ColorProperty foregroundColor = new ColorProperty(\"foregroundColor\", Color.BLACK);\n+    private final ColorProperty accentColor = new ColorProperty(\"accentColor\", Color.rgb(21, 126, 251));\n+    private final List<ColorProperty> allColors = List.of(backgroundColor, foregroundColor, accentColor);\n+    private final ColorSchemeProperty colorScheme = new ColorSchemeProperty();\n+    private final Object bean;\n+\n+    PreferenceProperties(Object bean) {\n+        this.bean = bean;\n+    }\n+\n+    public ReadOnlyObjectProperty<ColorScheme> colorSchemeProperty() {\n+        return colorScheme.getReadOnlyProperty();\n+    }\n+\n+    public ColorScheme getColorScheme() {\n+        return colorScheme.get();\n+    }\n+\n+    public void setColorScheme(ColorScheme value) {\n+        colorScheme.setValueOverride(value);\n+    }\n+\n+    public ReadOnlyObjectProperty<Color> backgroundColorProperty() {\n+        return backgroundColor;\n+    }\n+\n+    public Color getBackgroundColor() {\n+        return backgroundColor.get();\n+    }\n+\n+    public void setBackgroundColor(Color color) {\n+        backgroundColor.setValueOverride(color);\n+    }\n+\n+    public ReadOnlyObjectProperty<Color> foregroundColorProperty() {\n+        return foregroundColor;\n+    }\n+\n+    public Color getForegroundColor() {\n+        return foregroundColor.get();\n+    }\n+\n+    public void setForegroundColor(Color color) {\n+        foregroundColor.setValueOverride(color);\n+    }\n+\n+    public ReadOnlyObjectProperty<Color> accentColorProperty() {\n+        return accentColor;\n+    }\n+\n+    public Color getAccentColor() {\n+        return accentColor.get();\n+    }\n+\n+    public void setAccentColor(Color color) {\n+        accentColor.setValueOverride(color);\n+    }\n+\n+    public void update(Map<String, ChangedValue> changedPreferences, Map<String, String> platformKeyMappings) {\n+        for (Map.Entry<String, ChangedValue> entry : changedPreferences.entrySet()) {\n+            String key = platformKeyMappings.get(entry.getKey());\n+            if (key != null) {\n+                for (ColorProperty colorProperty : allColors) {\n+                    if (colorProperty.getName().equals(key)) {\n+                        updateColorProperty(colorProperty, entry.getValue().newValue());\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        fireValueChangedIfNecessary();\n+    }\n+\n+    private void updateColorProperty(ColorProperty property, Object value) {\n+        if (value instanceof Color color) {\n+            property.setValue(color);\n+        } else {\n+            if (value != null) {\n+                Logging.getJavaFXLogger().warning(\n+                    \"Unexpected value of \" + property.getName() + \" platform preference, \" +\n+                    \"using default value instead (expected = \" + Color.class.getName() +\n+                    \", actual = \" + value.getClass().getName() + \")\");\n+            }\n+\n+            \/\/ Setting a ColorProperty to 'null' restores its platform value or default value.\n+            property.setValue(null);\n+        }\n+    }\n+\n+    private void fireValueChangedIfNecessary() {\n+        for (ColorProperty colorProperty : allColors) {\n+            colorProperty.fireValueChangedIfNecessary();\n+        }\n+    }\n+\n+    \/**\n+     * ColorProperty implements a deferred notification mechanism, where change notifications\n+     * are only fired after changes of all color properties have been applied.\n+     * This ensures that observers will never see a transient state where two color properties\n+     * are inconsistent (for example, both foreground and background could be the same color\n+     * when going from light to dark mode).\n+     *\/\n+    private final class ColorProperty extends ReadOnlyObjectPropertyBase<Color> {\n+        private final String name;\n+        private final Color defaultValue;\n+        private Color overrideValue;\n+        private Color platformValue;\n+        private Color effectiveValue;\n+        private Color lastEffectiveValue;\n+\n+        ColorProperty(String name, Color initialValue) {\n+            this.name = name;\n+            this.defaultValue = initialValue;\n+            this.platformValue = initialValue;\n+            this.effectiveValue = initialValue;\n+            this.lastEffectiveValue = initialValue;\n+        }\n+\n+        @Override\n+        public Object getBean() {\n+            return bean;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public Color get() {\n+            return effectiveValue;\n+        }\n+\n+        \/**\n+         * Only called by {@link #updateColorProperty}, this method doesn't fire a change notification.\n+         * Change notifications are fired after the new values of all color properties have been set.\n+         *\/\n+        public void setValue(Color value) {\n+            this.platformValue = value;\n+            updateEffectiveValue();\n+        }\n+\n+        public void setValueOverride(Color value) {\n+            this.overrideValue = value;\n+            updateEffectiveValue();\n+            fireValueChangedEvent();\n+        }\n+\n+        private void updateEffectiveValue() {\n+            \/\/ Choose the first non-null value in this order: overrideValue, platformValue, defaultValue.\n+            effectiveValue = Objects.requireNonNullElse(\n+                overrideValue != null ? overrideValue : platformValue,\n+                defaultValue);\n+        }\n+\n+        void fireValueChangedIfNecessary() {\n+            if (!Objects.equals(lastEffectiveValue, effectiveValue)) {\n+                lastEffectiveValue = effectiveValue;\n+                fireValueChangedEvent();\n+            }\n+        }\n+    }\n+\n+    private class ColorSchemeProperty extends ReadOnlyObjectWrapper<ColorScheme> {\n+        private ColorScheme colorSchemeOverride;\n+\n+        ColorSchemeProperty() {\n+            super(bean, \"colorScheme\");\n+            InvalidationListener listener = observable -> update();\n+            backgroundColor.addListener(listener);\n+            foregroundColor.addListener(listener);\n+            update();\n+        }\n+\n+        public void setValueOverride(ColorScheme colorScheme) {\n+            colorSchemeOverride = colorScheme;\n+            update();\n+        }\n+\n+        private void update() {\n+            if (colorSchemeOverride != null) {\n+                set(colorSchemeOverride);\n+            } else {\n+                Color background = backgroundColor.get();\n+                Color foreground = foregroundColor.get();\n+                boolean isDark = Utils.calculateBrightness(background) < Utils.calculateBrightness(foreground);\n+                set(isDark ? ColorScheme.DARK : ColorScheme.LIGHT);\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/application\/preferences\/PreferenceProperties.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -362,0 +362,6 @@\n+            \/\/ Initialize the platform preferences\n+            PlatformImpl.initPreferences(\n+                Application.GetApplication().getPlatformKeys(),\n+                Application.GetApplication().getPlatformKeyMappings(),\n+                Application.GetApplication().getPlatformPreferences());\n+\n@@ -367,3 +373,3 @@\n-                @Override public boolean handleThemeChanged(String themeName) {\n-                    String highContrastSchemeName = Application.GetApplication().getHighContrastScheme(themeName);\n-                    return PlatformImpl.setAccessibilityTheme(highContrastSchemeName);\n+                @Override\n+                public void handlePreferencesChanged(Map<String, Object> preferences) {\n+                    PlatformImpl.updatePreferences(preferences);\n@@ -1810,5 +1816,0 @@\n-    @Override\n-    public String getThemeName() {\n-        return Application.GetApplication().getHighContrastTheme();\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/QuantumToolkit.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.application;\n+\n+\/**\n+ * Defines the color scheme of the user interface, which specifies whether applications\n+ * should prefer light text on dark backgrounds, or dark text on light backgrounds.\n+ *\n+ * @see javafx.application.Platform.Preferences#colorSchemeProperty()\n+ * @since 22\n+ *\/\n+public enum ColorScheme {\n+    \/**\n+     * A light color scheme uses bright backgrounds and dark text.\n+     *\/\n+    LIGHT,\n+\n+    \/**\n+     * A dark color scheme uses dark backgrounds and bright text.\n+     *\/\n+    DARK\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/application\/ColorScheme.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -33,0 +33,2 @@\n+import javafx.beans.property.ReadOnlyObjectProperty;\n+import javafx.collections.ObservableMap;\n@@ -34,0 +36,2 @@\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.Paint;\n@@ -435,0 +439,246 @@\n+\n+    \/**\n+     * Gets the preferences of the current platform.\n+     * <p>\n+     * The map returned from this method is unmodifiable, which means that keys and values cannot\n+     * be added, removed, or updated. Calling any mutator method on the map will always cause\n+     * {@code UnsupportedOperationException} to be thrown. However, the mappings will be updated\n+     * by JavaFX when the operating system reports that a platform preference has changed.\n+     *\n+     * @return the {@code Preferences} instance\n+     * @see <a href=\"Platform.Preferences.html#preferences-table\">List of platform preferences<\/a>\n+     * @since 22\n+     *\/\n+    public static Preferences getPreferences() {\n+        return PlatformImpl.getPlatformPreferences();\n+    }\n+\n+    \/**\n+     * Contains UI preferences of the current platform.\n+     * <p>\n+     * {@code Preferences} extends {@link ObservableMap} to expose platform preferences as key-value pairs.\n+     * The map is unmodifiable, which means that keys and values cannot be added, removed, or updated.\n+     * Calling any mutator method on the map will always cause {@code UnsupportedOperationException} to be thrown.\n+     * However, the mappings will be updated by JavaFX when the operating system reports that a platform\n+     * preference has changed.\n+     * <p>\n+     * For convenience, {@link #getInteger}, {@link #getDouble}, {@link #getBoolean}, {@link #getString},\n+     * {@link #getColor}, and {@link #getValue} are provided as typed alternatives to the untyped\n+     * {@link #get} method.\n+     * <p>\n+     * The preferences that are reported by the platform may be dependent on the operating system version\n+     * and its current configuration, so applications should not assume that a particular preference is\n+     * always available.\n+     * <p>\n+     * The following preferences are potentially available on the specified platforms:\n+     * <table id=\"preferences-table\">\n+     *     <caption>List of platform preferences<\/caption>\n+     *     <tbody>\n+     *         <tr><th colspan=\"2\" scope=\"colgroup\">Windows<\/th><\/tr>\n+     *         <tr><td>{@code Windows.SPI.HighContrast}<\/td><td>{@link Boolean}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.SPI.HighContrastColorScheme}<\/td><td>{@link String}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.SysColor.COLOR_3DFACE}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.SysColor.COLOR_BTNTEXT}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.SysColor.COLOR_GRAYTEXT}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.SysColor.COLOR_HIGHLIGHT}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.SysColor.COLOR_HIGHLIGHTTEXT}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.SysColor.COLOR_HOTLIGHT}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.SysColor.COLOR_WINDOW}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.SysColor.COLOR_WINDOWTEXT}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.UIColor.Background}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.UIColor.Foreground}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.UIColor.AccentDark3}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.UIColor.AccentDark2}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.UIColor.AccentDark1}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.UIColor.Accent}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.UIColor.AccentLight1}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.UIColor.AccentLight2}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code Windows.UIColor.AccentLight3}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><\/tr>\n+     *         <tr><th colspan=\"2\" scope=\"colgroup\">macOS<\/th><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.labelColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.secondaryLabelColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.tertiaryLabelColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.quaternaryLabelColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.textColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.placeholderTextColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.selectedTextColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.textBackgroundColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.selectedTextBackgroundColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.keyboardFocusIndicatorColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.unemphasizedSelectedTextColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.unemphasizedSelectedTextBackgroundColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.linkColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.separatorColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.selectedContentBackgroundColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.unemphasizedSelectedContentBackgroundColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.selectedMenuItemTextColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.gridColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.headerTextColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.alternatingContentBackgroundColors}<\/td><td>{@link Color}{@code []}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.controlAccentColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.controlColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.controlBackgroundColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.controlTextColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.disabledControlTextColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.selectedControlColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.selectedControlTextColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.alternateSelectedControlTextColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.currentControlTint}<\/td><td>{@link String}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.windowBackgroundColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.windowFrameTextColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.underPageBackgroundColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.findHighlightColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.highlightColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.shadowColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.systemBlueColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.systemBrownColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.systemGrayColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.systemGreenColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.systemIndigoColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.systemOrangeColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.systemPinkColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.systemPurpleColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.systemRedColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.systemTealColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code macOS.NSColor.systemYellowColor}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><\/tr>\n+     *         <tr><th colspan=\"2\" scope=\"colgroup\">Linux<\/th><\/tr>\n+     *         <tr><td>{@code GTK.theme_name}<\/td><td>{@link String}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.theme_fg_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.theme_bg_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.theme_base_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.theme_selected_bg_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.theme_selected_fg_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.theme_unfocused_fg_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.theme_unfocused_bg_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.theme_unfocused_base_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.theme_unfocused_selected_bg_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.theme_unfocused_selected_fg_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.insensitive_bg_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.insensitive_fg_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.insensitive_base_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.borders}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.unfocused_borders}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.warning_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.error_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><td>{@code GTK.success_color}<\/td><td>{@link Color}<\/td><\/tr>\n+     *         <tr><\/tr>\n+     *     <\/tbody>\n+     * <\/table>\n+     *\n+     * @since 22\n+     *\/\n+    public interface Preferences extends ObservableMap<String, Object> {\n+\n+        \/**\n+         * The platform color scheme, which specifies whether applications should prefer light text on\n+         * dark backgrounds, or dark text on light backgrounds. The value of this property defaults to\n+         * {@link ColorScheme#LIGHT} if the platform does not report color preferences.\n+         *\n+         * @return the {@code colorScheme} property\n+         * @defaultValue {@link ColorScheme#LIGHT}\n+         *\/\n+        ReadOnlyObjectProperty<ColorScheme> colorSchemeProperty();\n+\n+        ColorScheme getColorScheme();\n+\n+        \/**\n+         * The color used for background regions.\n+         * <p>\n+         * If the platform does not report a background color, this property defaults to {@code Color.WHITE}.\n+         *\n+         * @return the {@code backgroundColor} property\n+         * @defaultValue {@link Color#WHITE}\n+         *\/\n+        ReadOnlyObjectProperty<Color> backgroundColorProperty();\n+\n+        Color getBackgroundColor();\n+\n+        \/**\n+         * The color used for foreground elements like text.\n+         * <p>\n+         * If the platform does not report a foreground color, this property defaults to {@code Color.BLACK}.\n+         *\n+         * @return the {@code foregroundColor} property\n+         * @defaultValue {@code Color.BLACK}\n+         *\/\n+        ReadOnlyObjectProperty<Color> foregroundColorProperty();\n+\n+        Color getForegroundColor();\n+\n+        \/**\n+         * The accent color.\n+         * <p>\n+         * If the platform does not report an accent color, this property defaults to vivid blue\n+         * (corresponding to the hex color value {@code #157EFB}).\n+         *\n+         * @return the {@code accentColor} property\n+         * @defaultValue {@code #157EFB}\n+         *\/\n+        ReadOnlyObjectProperty<Color> accentColorProperty();\n+\n+        Color getAccentColor();\n+\n+        \/**\n+         * Returns an optional {@code Integer} to which the specified key is mapped.\n+         *\n+         * @param key the key\n+         * @throws NullPointerException if {@code key} is null\n+         * @throws IllegalArgumentException if the key is not mappable to an {@code Integer}\n+         * @return the optional {@code Integer} to which the key is mapped\n+         *\/\n+        Optional<Integer> getInteger(String key);\n+\n+        \/**\n+         * Returns an optional {@code Double} to which the specified key is mapped.\n+         *\n+         * @param key the key\n+         * @throws NullPointerException if {@code key} is null\n+         * @throws IllegalArgumentException if the key is not mappable to a {@code Double}\n+         * @return the optional {@code Double} to which the key is mapped\n+         *\/\n+        Optional<Double> getDouble(String key);\n+\n+        \/**\n+         * Returns an optional {@code Boolean} to which the specified key is mapped.\n+         *\n+         * @param key the key\n+         * @throws NullPointerException if {@code key} is null\n+         * @throws IllegalArgumentException if the key is not mappable to a {@code Boolean}\n+         * @return the optional {@code Boolean} to which the key is mapped\n+         *\/\n+        Optional<Boolean> getBoolean(String key);\n+\n+        \/**\n+         * Returns an optional {@code String} to which the specified key is mapped.\n+         *\n+         * @param key the key\n+         * @throws NullPointerException if {@code key} is null\n+         * @throws IllegalArgumentException if the key is not mappable to a {@code String}\n+         * @return the optional {@code String} to which the key is mapped\n+         *\/\n+        Optional<String> getString(String key);\n+\n+        \/**\n+         * Returns an optional {@code Color} to which the specified key is mapped.\n+         *\n+         * @param key the key\n+         * @throws NullPointerException if {@code key} is null\n+         * @throws IllegalArgumentException if the key is not mappable to a {@code Color}\n+         * @return the optional {@code Color} instance to which the key is mapped\n+         *\/\n+        Optional<Color> getColor(String key);\n+\n+        \/**\n+         * Returns an optional value to which the specified key is mapped.\n+         *\n+         * @param <T> the type of the value\n+         * @param key the key\n+         * @param type the type of the value\n+         * @throws NullPointerException if {@code key} or {@code type} is null\n+         * @throws IllegalArgumentException if the key is not mappable to a value of type {@code T}\n+         * @return the optional value to which the key is mapped\n+         *\/\n+        <T> Optional<T> getValue(String key, Class<T> type);\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/application\/Platform.java","additions":250,"deletions":0,"binary":false,"changes":250,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"PlatformSupport.h\"\n@@ -50,0 +51,1 @@\n+PlatformSupport* platformSupport = NULL;\n@@ -75,0 +77,7 @@\n+static void call_update_preferences()\n+{\n+    if (platformSupport) {\n+        platformSupport->updatePreferences();\n+    }\n+}\n+\n@@ -189,0 +198,8 @@\n+\n+    platformSupport = new PlatformSupport(env, obj);\n+\n+    GtkSettings* settings = gtk_settings_get_default();\n+    if (settings != NULL) {\n+        g_signal_connect(G_OBJECT(settings), \"notify::gtk-theme-name\",\n+                         G_CALLBACK(call_update_preferences), NULL);\n+    }\n@@ -252,0 +269,5 @@\n+\n+    if (platformSupport) {\n+        delete platformSupport;\n+        platformSupport = NULL;\n+    }\n@@ -409,0 +431,11 @@\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkApplication\n+ * Method:    getPlatformPreferences\n+ * Signature: ()Ljava\/util\/Map;\n+ *\/\n+JNIEXPORT jobject JNICALL Java_com_sun_glass_ui_gtk_GtkApplication_getPlatformPreferences\n+  (JNIEnv *env, jobject self)\n+{\n+    return platformSupport ? platformSupport->collectPreferences() : NULL;\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassApplication.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"PlatformSupport.h\"\n+#include \"glass_general.h\"\n+#include <gtk\/gtk.h>\n+\n+namespace\n+{\n+    void putColor(JNIEnv* env, jobject prefs, GtkStyle* style, const char* lookupColorName, const char* prefColorName) {\n+        GdkColor color;\n+        if (!gtk_style_lookup_color(style, lookupColorName, &color)) {\n+            return;\n+        }\n+\n+        jobject prefKey = env->NewStringUTF(prefColorName);\n+        if (EXCEPTION_OCCURED(env) || prefKey == NULL) return;\n+\n+        jobject prefValue = env->CallStaticObjectMethod(\n+            jColorCls, jColorRgb,\n+            (int)(CLAMP((double)color.red \/ 65535.0, 0.0, 1.0) * 255.0),\n+            (int)(CLAMP((double)color.green \/ 65535.0, 0.0, 1.0) * 255.0),\n+            (int)(CLAMP((double)color.blue \/ 65535.0, 0.0, 1.0) * 255.0),\n+            1.0);\n+        CHECK_JNI_EXCEPTION(env);\n+\n+        env->CallObjectMethod(prefs, jMapPut, prefKey, prefValue);\n+        CHECK_JNI_EXCEPTION(env);\n+    }\n+\n+    void putString(JNIEnv* env, jobject preferences, const char* name, const char* value) {\n+        jobject prefKey = env->NewStringUTF(name);\n+        if (EXCEPTION_OCCURED(env) || prefKey == NULL) return;\n+\n+        jobject prefValue = env->NewStringUTF(value);\n+        if (EXCEPTION_OCCURED(env) || prefValue == NULL) return;\n+\n+        env->CallObjectMethod(preferences, jMapPut, prefKey, prefValue);\n+        CHECK_JNI_EXCEPTION(env);\n+    }\n+}\n+\n+PlatformSupport::PlatformSupport(JNIEnv* env, jobject application)\n+    : env(env), application(env->NewGlobalRef(application)), preferences(NULL) {}\n+\n+PlatformSupport::~PlatformSupport() {\n+    env->DeleteGlobalRef(application);\n+\n+    if (preferences) {\n+        env->DeleteGlobalRef(preferences);\n+    }\n+}\n+\n+jobject PlatformSupport::collectPreferences() const {\n+    jobject prefs = env->NewObject(jHashMapCls, jHashMapInit);\n+    if (EXCEPTION_OCCURED(env) || prefs == NULL) return NULL;\n+\n+    GtkStyle* style = gtk_style_new();\n+    if (style == NULL) return NULL;\n+\n+    putColor(env, prefs, style, \"theme_fg_color\", \"GTK.theme_fg_color\");\n+    putColor(env, prefs, style, \"theme_bg_color\", \"GTK.theme_bg_color\");\n+    putColor(env, prefs, style, \"theme_base_color\", \"GTK.theme_base_color\");\n+    putColor(env, prefs, style, \"theme_selected_bg_color\", \"GTK.theme_selected_bg_color\");\n+    putColor(env, prefs, style, \"theme_selected_fg_color\", \"GTK.theme_selected_fg_color\");\n+    putColor(env, prefs, style, \"insensitive_bg_color\", \"GTK.insensitive_bg_color\");\n+    putColor(env, prefs, style, \"insensitive_fg_color\", \"GTK.insensitive_fg_color\");\n+    putColor(env, prefs, style, \"insensitive_base_color\", \"GTK.insensitive_base_color\");\n+    putColor(env, prefs, style, \"theme_unfocused_fg_color\", \"GTK.theme_unfocused_fg_color\");\n+    putColor(env, prefs, style, \"theme_unfocused_bg_color\", \"GTK.theme_unfocused_bg_color\");\n+    putColor(env, prefs, style, \"theme_unfocused_base_color\", \"GTK.theme_unfocused_base_color\");\n+    putColor(env, prefs, style, \"theme_unfocused_selected_bg_color\", \"GTK.theme_unfocused_selected_bg_color\");\n+    putColor(env, prefs, style, \"theme_unfocused_selected_fg_color\", \"GTK.theme_unfocused_selected_fg_color\");\n+    putColor(env, prefs, style, \"borders\", \"GTK.borders\");\n+    putColor(env, prefs, style, \"unfocused_borders\", \"GTK.unfocused_borders\");\n+    putColor(env, prefs, style, \"warning_color\", \"GTK.warning_color\");\n+    putColor(env, prefs, style, \"error_color\", \"GTK.error_color\");\n+    putColor(env, prefs, style, \"success_color\", \"GTK.success_color\");\n+    g_object_unref(style);\n+\n+    GtkSettings* settings = gtk_settings_get_default();\n+    if (settings != NULL) {\n+        gchar* themeName;\n+        g_object_get(settings, \"gtk-theme-name\", &themeName, NULL);\n+        putString(env, prefs, \"GTK.theme_name\", themeName);\n+    }\n+\n+    return prefs;\n+}\n+\n+void PlatformSupport::updatePreferences() const {\n+    jobject newPreferences = collectPreferences();\n+\n+    jboolean preferencesChanged =\n+        newPreferences != NULL &&\n+        !env->CallBooleanMethod(newPreferences, jObjectEquals, preferences);\n+\n+    if (!EXCEPTION_OCCURED(env) && preferencesChanged) {\n+        if (preferences) {\n+            env->DeleteGlobalRef(preferences);\n+        }\n+\n+        preferences = env->NewGlobalRef(newPreferences);\n+\n+        jobject unmodifiablePreferences = env->CallStaticObjectMethod(\n+            jCollectionsCls, jCollectionsUnmodifiableMap, newPreferences);\n+\n+        if (!EXCEPTION_OCCURED(env)) {\n+            env->CallVoidMethod(application, jApplicationNotifyPreferencesChanged, unmodifiablePreferences);\n+            EXCEPTION_OCCURED(env);\n+\n+            env->DeleteLocalRef(unmodifiablePreferences);\n+        }\n+    }\n+\n+    env->DeleteLocalRef(newPreferences);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/PlatformSupport.cpp","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma once\n+\n+#include <jni.h>\n+\n+class PlatformSupport final\n+{\n+public:\n+    PlatformSupport(JNIEnv*, jobject);\n+    ~PlatformSupport();\n+    PlatformSupport(PlatformSupport const&) = delete;\n+    PlatformSupport& operator=(PlatformSupport const&) = delete;\n+\n+    \/**\n+     * Collect all platform preferences and return them as a new java\/util\/Map.\n+     *\/\n+    jobject collectPreferences() const;\n+\n+    \/**\n+     * Collect all platform preferences and notify the JavaFX application when a preference has changed.\n+     * The change notification includes all preferences, not only the changed preferences.\n+     *\/\n+    void updatePreferences() const;\n+\n+private:\n+    JNIEnv* env;\n+    jobject application;\n+    mutable jobject preferences;\n+};\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/PlatformSupport.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,1 @@\n+jclass jMapCls;\n@@ -92,0 +93,1 @@\n+jmethodID jMapPut;\n@@ -95,0 +97,3 @@\n+jclass jHashMapCls;\n+jmethodID jHashMapInit;\n+\n@@ -113,0 +118,14 @@\n+jmethodID jApplicationNotifyPreferencesChanged;\n+\n+jclass jObjectCls;\n+jmethodID jObjectEquals;\n+\n+jclass jBooleanCls;\n+jfieldID jBooleanTRUE;\n+jfieldID jBooleanFALSE;\n+\n+jclass jCollectionsCls;\n+jmethodID jCollectionsUnmodifiableMap;\n+\n+jclass jColorCls;\n+jmethodID jColorRgb;\n@@ -279,0 +298,1 @@\n+    jMapCls = (jclass)env->NewGlobalRef(clazz);\n@@ -281,0 +301,2 @@\n+    jMapPut = env->GetMethodID(clazz, \"put\", \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n@@ -286,0 +308,6 @@\n+    clazz = env->FindClass(\"java\/util\/HashMap\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jHashMapCls = (jclass) env->NewGlobalRef(clazz);\n+    jHashMapInit = env->GetMethodID(jHashMapCls, \"<init>\", \"()V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n@@ -330,0 +358,28 @@\n+    jApplicationNotifyPreferencesChanged = env->GetMethodID(jApplicationCls, \"notifyPreferencesChanged\", \"(Ljava\/util\/Map;)V\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"java\/lang\/Object\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jObjectCls = (jclass)env->NewGlobalRef(clazz);\n+    jObjectEquals = env->GetMethodID(jObjectCls, \"equals\", \"(Ljava\/lang\/Object;)Z\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"java\/lang\/Boolean\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jBooleanCls = (jclass)env->NewGlobalRef(clazz);\n+    jBooleanTRUE = env->GetStaticFieldID(jBooleanCls, \"TRUE\", \"Ljava\/lang\/Boolean;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jBooleanFALSE = env->GetStaticFieldID(jBooleanCls, \"FALSE\", \"Ljava\/lang\/Boolean;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"java\/util\/Collections\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jCollectionsCls = (jclass)env->NewGlobalRef(clazz);\n+    jCollectionsUnmodifiableMap = env->GetStaticMethodID(jCollectionsCls, \"unmodifiableMap\", \"(Ljava\/util\/Map;)Ljava\/util\/Map;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+\n+    clazz = env->FindClass(\"javafx\/scene\/paint\/Color\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n+    jColorCls = (jclass)env->NewGlobalRef(clazz);\n+    jColorRgb = env->GetStaticMethodID(jColorCls, \"rgb\", \"(IIID)Ljavafx\/scene\/paint\/Color;\");\n+    if (env->ExceptionCheck()) return JNI_ERR;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.cpp","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -204,0 +204,1 @@\n+    extern jclass jMapCls; \/\/ java.util.Map\n@@ -205,0 +206,1 @@\n+    extern jmethodID jMapPut; \/\/ java.util.Map#put(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/Object;\n@@ -208,0 +210,3 @@\n+    extern jclass jHashMapCls; \/\/ java.util.HashMap\n+    extern jmethodID jHashMapInit; \/\/ java.util.HashMap#<init> ()V\n+\n@@ -226,0 +231,14 @@\n+    extern jmethodID jApplicationNotifyPreferencesChanged; \/\/ notifyPreferencesChanged(Ljava\/util\/Map;)V\n+\n+    extern jclass jObjectCls; \/\/ java.lang.Object\n+    extern jmethodID jObjectEquals; \/\/ java.lang.Object#equals(Ljava\/lang\/Object;)Z\n+\n+    extern jclass jBooleanCls; \/\/ java.lang.Boolean\n+    extern jfieldID jBooleanTRUE; \/\/ java.lang.Boolean#TRUE\n+    extern jfieldID jBooleanFALSE; \/\/ java.lang.Boolean#FALSE\n+\n+    extern jclass jCollectionsCls; \/\/ java.util.Collections;\n+    extern jmethodID jCollectionsUnmodifiableMap; \/\/ java.util.Collections#unmodifiableMap(Ljava\/util\/Map;)Ljava\/util\/Map;\n+\n+    extern jclass jColorCls; \/\/ javafx.scene.paint.Color\n+    extern jmethodID jColorRgb; \/\/ javafx.scene.paint.Color#rgb(IIID)Ljavafx\/scene\/paint\/Color;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.h","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#import \"PlatformSupport.h\"\n@@ -157,0 +158,19 @@\n+- (void)platformPreferencesDidChange {\n+    \/\/ Some dynamic colors like NSColor.controlAccentColor don't seem to be reliably updated\n+    \/\/ at the exact moment AppleColorPreferencesChangedNotification is received.\n+    \/\/ As a workaround, we wait for a short period of time (one second seems sufficient) before\n+    \/\/ we query the updated platform preferences.\n+\n+    [NSObject cancelPreviousPerformRequestsWithTarget:self\n+              selector:@selector(updatePlatformPreferences)\n+              object:nil];\n+\n+    [self performSelector:@selector(updatePlatformPreferences)\n+          withObject:nil\n+          afterDelay:1.0];\n+}\n+\n+- (void)updatePlatformPreferences {\n+    [PlatformSupport updatePreferences:self->jApplication];\n+}\n+\n@@ -196,0 +216,10 @@\n+                        [[NSDistributedNotificationCenter defaultCenter] addObserver:self\n+                                                                         selector:@selector(platformPreferencesDidChange)\n+                                                                         name:@\"AppleInterfaceThemeChangedNotification\"\n+                                                                         object:nil];\n+\n+                        [[NSDistributedNotificationCenter defaultCenter] addObserver:self\n+                                                                         selector:@selector(platformPreferencesDidChange)\n+                                                                         name:@\"AppleColorPreferencesChangedNotification\"\n+                                                                         object:nil];\n+\n@@ -852,0 +882,4 @@\n+    javaIDs.MacApplication.notifyPreferencesChanged = (*env)->GetMethodID(\n+            env, jClass, \"notifyPreferencesChanged\", \"(Ljava\/util\/Map;)V\");\n+    if ((*env)->ExceptionCheck(env)) return;\n+\n@@ -859,0 +893,2 @@\n+\n+    [PlatformSupport initIDs:env];\n@@ -1157,0 +1193,11 @@\n+\n+\/*\n+ * Class:     com_sun_glass_ui_mac_MacApplication\n+ * Method:    getPreferences\n+ * Signature: ()Ljava\/util\/Map;\n+ *\/\n+JNIEXPORT jobject JNICALL Java_com_sun_glass_ui_mac_MacApplication_getPlatformPreferences\n+(JNIEnv *env, jobject self)\n+{\n+    return [PlatformSupport collectPreferences];\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassApplication.m","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -164,0 +164,17 @@\n+\/\/ assert there is no outstanding java exception pending, return otherwise\n+#define GLASS_CHECK_EXCEPTION_RETURN(ENV)                                          \\\n+do {                                                                               \\\n+    jthrowable t = (*ENV)->ExceptionOccurred(ENV);                                 \\\n+    if (t) {                                                                       \\\n+        (*ENV)->ExceptionClear(ENV);                                               \\\n+        (*ENV)->CallStaticVoidMethod(                                              \\\n+            ENV, jApplicationClass, javaIDs.Application.reportException, t);       \\\n+        (*ENV)->ExceptionClear(ENV);                                               \\\n+        return;                                                                    \\\n+    };                                                                             \\\n+} while (0)\n+\n+#define GLASS_CHECK_NONNULL_EXCEPTION_RETURN(ENV, EXPR)                            \\\n+    GLASS_CHECK_EXCEPTION_RETURN(ENV);                                             \\\n+    if ((EXPR) == nil) return;\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassMacros.h","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,12 @@\n+extern jclass jObjectClass;\n+extern jclass jCollectionsClass;\n+extern jclass jColorClass;\n+extern jclass jHashMapClass;\n+extern jfieldID jBooleanTRUE;\n+extern jfieldID jBooleanFALSE;\n+extern jmethodID jColorRgbMethod;\n+extern jmethodID jHashMapInitMethod;\n+extern jmethodID jMapPutMethod;\n+extern jmethodID jObjectEqualsMethod;\n+extern jmethodID jCollectionsUnmodifiableMapMethod;\n+\n@@ -119,0 +131,1 @@\n+        jmethodID notifyPreferencesChanged;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassStatics.h","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,12 @@\n+jclass jObjectClass = NULL;\n+jclass jCollectionsClass = NULL;\n+jclass jColorClass = NULL;\n+jclass jHashMapClass = NULL;\n+jfieldID jBooleanTRUE = NULL;\n+jfieldID jBooleanFALSE = NULL;\n+jmethodID jColorRgbMethod = NULL;\n+jmethodID jHashMapInitMethod = NULL;\n+jmethodID jMapPutMethod = NULL;\n+jmethodID jObjectEqualsMethod = NULL;\n+jmethodID jCollectionsUnmodifiableMapMethod = NULL;\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassStatics.m","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma once\n+\n+#import <Cocoa\/Cocoa.h>\n+#import <jni.h>\n+\n+@interface PlatformSupport : NSObject\n+\n++ (void)initIDs:(JNIEnv*)env;\n+\n+\/**\n+ * Collect all platform preferences and return them as a new java\/util\/Map.\n+ *\/\n++ (jobject)collectPreferences;\n+\n+\/**\n+ * Collect all platform preferences and notify the JavaFX application when a preference has changed.\n+ * The change notification includes all preferences, not only the changed preferences.\n+ *\/\n++ (void)updatePreferences:(jobject)application;\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/PlatformSupport.h","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"PlatformSupport.h\"\n+#import \"GlassMacros.h\"\n+\n+#define INIT_CLASS(CLS, NAME)\\\n+    if (CLS == nil) {\\\n+        jclass cls = (*env)->FindClass(env, NAME);\\\n+        if ((*env)->ExceptionCheck(env)) {\\\n+            GLASS_CHECK_EXCEPTION(env);\\\n+            return;\\\n+        }\\\n+        CLS = (*env)->NewGlobalRef(env, cls);\\\n+    }\n+\n+#define INIT_METHOD(CLS, METHOD, NAME, SIG)\\\n+    if (METHOD == nil) {\\\n+        METHOD = (*env)->GetMethodID(env, CLS, NAME, SIG);\\\n+        if ((*env)->ExceptionCheck(env)) {\\\n+            GLASS_CHECK_EXCEPTION(env);\\\n+            return;\\\n+        }\\\n+    }\n+\n+#define INIT_STATIC_METHOD(CLS, METHOD, NAME, SIG)\\\n+    if (METHOD == nil) {\\\n+        METHOD = (*env)->GetStaticMethodID(env, CLS, NAME, SIG);\\\n+        if ((*env)->ExceptionCheck(env)) {\\\n+            GLASS_CHECK_EXCEPTION(env);\\\n+            return;\\\n+        }\\\n+    }\n+\n+#define INIT_STATIC_FIELD(CLS, FIELD, NAME, SIG)\\\n+    if (FIELD == nil) {\\\n+        FIELD = (*env)->GetStaticFieldID(env, CLS, NAME, SIG);\\\n+        if ((*env)->ExceptionCheck(env)) {\\\n+            GLASS_CHECK_EXCEPTION(env);\\\n+            return;\\\n+        }\\\n+    }\n+\n+static jobject currentPreferences = nil;\n+\n+@implementation PlatformSupport\n+\n++ (void)initIDs:(JNIEnv*)env {\n+    INIT_CLASS(jMapClass, \"java\/util\/Map\");\n+    INIT_METHOD(jMapClass, jMapPutMethod, \"put\", \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n+\n+    INIT_CLASS(jHashMapClass, \"java\/util\/HashMap\");\n+    INIT_METHOD(jHashMapClass, jHashMapInitMethod, \"<init>\", \"()V\");\n+\n+    INIT_CLASS(jBooleanClass, \"java\/lang\/Boolean\");\n+    INIT_STATIC_FIELD(jBooleanClass, jBooleanTRUE, \"TRUE\", \"Ljava\/lang\/Boolean;\");\n+    INIT_STATIC_FIELD(jBooleanClass, jBooleanFALSE, \"FALSE\", \"Ljava\/lang\/Boolean;\");\n+\n+    INIT_CLASS(jCollectionsClass, \"java\/util\/Collections\");\n+    INIT_STATIC_METHOD(jCollectionsClass, jCollectionsUnmodifiableMapMethod, \"unmodifiableMap\", \"(Ljava\/util\/Map;)Ljava\/util\/Map;\");\n+\n+    INIT_CLASS(jObjectClass, \"java\/lang\/Object\");\n+    INIT_METHOD(jObjectClass, jObjectEqualsMethod, \"equals\", \"(Ljava\/lang\/Object;)Z\");\n+\n+    INIT_CLASS(jColorClass, \"javafx\/scene\/paint\/Color\");\n+    INIT_STATIC_METHOD(jColorClass, jColorRgbMethod, \"rgb\", \"(IIID)Ljavafx\/scene\/paint\/Color;\");\n+}\n+\n++ (jobject)collectPreferences {\n+    GET_MAIN_JENV;\n+\n+    jobject preferences = (*env)->NewObject(env, jHashMapClass, jHashMapInitMethod);\n+    GLASS_CHECK_EXCEPTION(env);\n+    if (preferences == nil) {\n+        return nil;\n+    }\n+\n+    \/\/ The current appearance is set to the system appearance when the application is started.\n+    \/\/ Since the system appearance can change while the application is running, we need to set\n+    \/\/ the current appearance to the application's effective appearance before querying system\n+    \/\/ colors.\n+    NSAppearance* lastAppearance = [NSAppearance currentAppearance];\n+    [NSAppearance setCurrentAppearance:[NSApp effectiveAppearance]];\n+    [PlatformSupport queryNSColors:preferences];\n+    [NSAppearance setCurrentAppearance:lastAppearance];\n+\n+    return preferences;\n+}\n+\n++ (void)queryNSColors:(jobject)preferences {\n+    \/\/ Label colors\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.labelColor\" value:[NSColor labelColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.secondaryLabelColor\" value:[NSColor secondaryLabelColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.tertiaryLabelColor\" value:[NSColor tertiaryLabelColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.quaternaryLabelColor\" value:[NSColor quaternaryLabelColor]];\n+\n+    \/\/ Text colors\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.textColor\" value:[NSColor textColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.placeholderTextColor\" value:[NSColor placeholderTextColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.selectedTextColor\" value:[NSColor selectedTextColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.textBackgroundColor\" value:[NSColor textBackgroundColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.selectedTextBackgroundColor\" value:[NSColor selectedTextBackgroundColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.keyboardFocusIndicatorColor\" value:[NSColor keyboardFocusIndicatorColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.unemphasizedSelectedTextColor\" value:[NSColor unemphasizedSelectedTextColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.unemphasizedSelectedTextBackgroundColor\" value:[NSColor unemphasizedSelectedTextBackgroundColor]];\n+\n+    \/\/ Content colors\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.linkColor\" value:[NSColor linkColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.separatorColor\" value:[NSColor separatorColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.selectedContentBackgroundColor\" value:[NSColor selectedContentBackgroundColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.unemphasizedSelectedContentBackgroundColor\" value:[NSColor unemphasizedSelectedContentBackgroundColor]];\n+\n+    \/\/ Menu colors\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.selectedMenuItemTextColor\" value:[NSColor selectedMenuItemTextColor]];\n+\n+    \/\/ Table colors\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.gridColor\" value:[NSColor gridColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.headerTextColor\" value:[NSColor headerTextColor]];\n+    [PlatformSupport putColors:preferences key:\"macOS.NSColor.alternatingContentBackgroundColors\" value:[NSColor alternatingContentBackgroundColors]];\n+\n+    \/\/ Control colors\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.controlAccentColor\" value:[NSColor controlAccentColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.controlColor\" value:[NSColor controlColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.controlBackgroundColor\" value:[NSColor controlBackgroundColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.controlTextColor\" value:[NSColor controlTextColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.disabledControlTextColor\" value:[NSColor disabledControlTextColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.selectedControlColor\" value:[NSColor selectedControlColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.selectedControlTextColor\" value:[NSColor selectedControlTextColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.alternateSelectedControlTextColor\" value:[NSColor alternateSelectedControlTextColor]];\n+\n+    const char* controlTint = nil;\n+    switch ([NSColor currentControlTint]) {\n+        case NSDefaultControlTint: controlTint = \"NSDefaultControlTint\"; break;\n+        case NSGraphiteControlTint: controlTint = \"NSGraphiteControlTint\"; break;\n+        case NSBlueControlTint: controlTint = \"NSBlueControlTint\"; break;\n+        case NSClearControlTint: controlTint = \"NSClearControlTint\"; break;\n+    }\n+    if (controlTint != nil) {\n+        [PlatformSupport putString:preferences key:\"macOS.NSColor.currentControlTint\" value:controlTint];\n+    }\n+\n+    \/\/ Window colors\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.windowBackgroundColor\" value:[NSColor windowBackgroundColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.windowFrameTextColor\" value:[NSColor windowFrameTextColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.underPageBackgroundColor\" value:[NSColor underPageBackgroundColor]];\n+\n+    \/\/ Highlights and shadows\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.findHighlightColor\" value:[NSColor findHighlightColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.highlightColor\" value:[NSColor highlightColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.shadowColor\" value:[NSColor shadowColor]];\n+\n+    \/\/ Adaptable system colors\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.systemBlueColor\" value:[NSColor systemBlueColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.systemBrownColor\" value:[NSColor systemBrownColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.systemGrayColor\" value:[NSColor systemGrayColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.systemGreenColor\" value:[NSColor systemGreenColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.systemIndigoColor\" value:[NSColor systemIndigoColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.systemOrangeColor\" value:[NSColor systemOrangeColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.systemPinkColor\" value:[NSColor systemPinkColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.systemPurpleColor\" value:[NSColor systemPurpleColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.systemRedColor\" value:[NSColor systemRedColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.systemTealColor\" value:[NSColor systemTealColor]];\n+    [PlatformSupport putColor:preferences key:\"macOS.NSColor.systemYellowColor\" value:[NSColor systemYellowColor]];\n+}\n+\n++ (void)updatePreferences:(jobject)application {\n+    GET_MAIN_JENV;\n+\n+    jobject newPreferences = [self collectPreferences];\n+    if (newPreferences == nil) {\n+        return;\n+    }\n+\n+    jboolean preferencesChanged = !(*env)->CallBooleanMethod(\n+        env, newPreferences, jObjectEqualsMethod, currentPreferences);\n+    GLASS_CHECK_EXCEPTION(env);\n+\n+    if (preferencesChanged) {\n+        if (currentPreferences != nil) {\n+            (*env)->DeleteGlobalRef(env, currentPreferences);\n+        }\n+\n+        currentPreferences = (*env)->NewGlobalRef(env, newPreferences);\n+\n+        jobject unmodifiablePreferences = (*env)->CallStaticObjectMethod(\n+            env, jCollectionsClass, jCollectionsUnmodifiableMapMethod, newPreferences);\n+        GLASS_CHECK_EXCEPTION(env);\n+\n+        if (unmodifiablePreferences != nil) {\n+            (*env)->CallVoidMethod(\n+                env, application,\n+                javaIDs.MacApplication.notifyPreferencesChanged,\n+                unmodifiablePreferences);\n+            GLASS_CHECK_EXCEPTION(env);\n+\n+            (*env)->DeleteLocalRef(env, unmodifiablePreferences);\n+        }\n+    }\n+\n+    (*env)->DeleteLocalRef(env, newPreferences);\n+}\n+\n++ (void)putString:(jobject)preferences key:(const char*)key value:(const char*)value {\n+    GET_MAIN_JENV;\n+\n+    jobject prefKey = (*env)->NewStringUTF(env, key);\n+    GLASS_CHECK_NONNULL_EXCEPTION_RETURN(env, prefKey);\n+\n+    jobject prefValue = nil;\n+    if (value != nil) {\n+        prefValue = (*env)->NewStringUTF(env, value);\n+        GLASS_CHECK_NONNULL_EXCEPTION_RETURN(env, prefValue);\n+    }\n+\n+    (*env)->CallObjectMethod(env, preferences, jMapPutMethod, prefKey, prefValue);\n+    GLASS_CHECK_EXCEPTION(env);\n+}\n+\n++ (void)putColor:(jobject)preferences key:(const char*)colorName value:(NSColor*)color {\n+    GET_MAIN_JENV;\n+\n+    jobject prefKey = (*env)->NewStringUTF(env, colorName);\n+    GLASS_CHECK_NONNULL_EXCEPTION_RETURN(env, prefKey);\n+\n+    NSColor* c = [color colorUsingColorSpace:[NSColorSpace deviceRGBColorSpace]];\n+    jobject prefValue = (*env)->CallStaticObjectMethod(\n+        env, jColorClass, jColorRgbMethod,\n+        (int)([c redComponent] * 255.0f),\n+        (int)([c greenComponent] * 255.0f),\n+        (int)([c blueComponent] * 255.0f),\n+        (double)[c alphaComponent]);\n+    GLASS_CHECK_EXCEPTION_RETURN(env);\n+\n+    (*env)->CallObjectMethod(env, preferences, jMapPutMethod, prefKey, prefValue);\n+    GLASS_CHECK_EXCEPTION(env);\n+}\n+\n++ (void)putColors:(jobject)preferences key:(const char*)colorName value:(NSArray*)colors {\n+    GET_MAIN_JENV;\n+\n+    jobject prefKey = (*env)->NewStringUTF(env, colorName);\n+    GLASS_CHECK_NONNULL_EXCEPTION_RETURN(env, prefKey);\n+\n+    int count = [colors count];\n+    jobjectArray prefValue = (*env)->NewObjectArray(env, count, jColorClass, nil);\n+    GLASS_CHECK_NONNULL_EXCEPTION_RETURN(env, prefValue);\n+\n+    for (int i = 0; i < count; ++i) {\n+        NSColor* c = [colors[i] colorUsingColorSpace:[NSColorSpace deviceRGBColorSpace]];\n+        jobject fxcolor = (*env)->CallStaticObjectMethod(\n+            env, jColorClass, jColorRgbMethod,\n+            (int)([c redComponent] * 255.0f),\n+            (int)([c greenComponent] * 255.0f),\n+            (int)([c blueComponent] * 255.0f),\n+            (double)[c alphaComponent]);\n+        GLASS_CHECK_EXCEPTION_RETURN(env);\n+\n+        (*env)->SetObjectArrayElement(env, prefValue, i, fxcolor);\n+        GLASS_CHECK_EXCEPTION_RETURN(env);\n+    }\n+\n+    (*env)->CallObjectMethod(env, preferences, jMapPutMethod, prefKey, prefValue);\n+    GLASS_CHECK_EXCEPTION(env);\n+}\n+\n+@end\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/PlatformSupport.m","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"RoActivationSupport.h\"\n@@ -101,1 +102,1 @@\n-GlassApplication::GlassApplication(jobject jrefThis) : BaseWnd()\n+GlassApplication::GlassApplication(jobject jrefThis) : BaseWnd(), m_platformSupport(GetEnv())\n@@ -126,14 +127,0 @@\n-jstring GlassApplication::GetThemeName(JNIEnv* env)\n-{\n-    HIGHCONTRAST contrastInfo;\n-    contrastInfo.cbSize = sizeof(HIGHCONTRAST);\n-    ::SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRAST), &contrastInfo, 0);\n-    if (contrastInfo.dwFlags & HCF_HIGHCONTRASTON) {\n-        jsize length = (jsize) wcslen(contrastInfo.lpszDefaultScheme);\n-        jstring jstr = env->NewString((jchar*) contrastInfo.lpszDefaultScheme, length);\n-        if (CheckAndClearException(env)) return NULL;\n-        return jstr;\n-    }\n-    return NULL;\n-}\n-\n@@ -184,0 +171,5 @@\n+            if (((UINT)wParam == SPI_GETHIGHCONTRAST ||\n+                    lParam != NULL && wcscmp(LPCWSTR(lParam), L\"ImmersiveColorSet\") == 0) &&\n+                    m_platformSupport.updatePreferences(m_grefThis)) {\n+                return 0;\n+            }\n@@ -191,7 +183,7 @@\n-        case WM_THEMECHANGED: {\n-            JNIEnv* env = GetEnv();\n-            jstring themeName = GlassApplication::GetThemeName(env);\n-            jboolean result = env->CallBooleanMethod(m_grefThis, javaIDs.Application.notifyThemeChangedMID, themeName);\n-            if (CheckAndClearException(env)) return 1;\n-            return !result;\n-        }\n+        case WM_THEMECHANGED:\n+        case WM_SYSCOLORCHANGE:\n+        case WM_DWMCOLORIZATIONCOLORCHANGED:\n+            if (m_platformSupport.updatePreferences(m_grefThis)) {\n+                return 0;\n+            }\n+            break;\n@@ -316,0 +308,3 @@\n+        tryInitializeRoActivationSupport();\n+    } else if (dwReason == DLL_PROCESS_DETACH) {\n+        uninitializeRoActivationSupport();\n@@ -341,3 +336,3 @@\n-    javaIDs.Application.notifyThemeChangedMID =\n-        env->GetMethodID(cls, \"notifyThemeChanged\", \"(Ljava\/lang\/String;)Z\");\n-    ASSERT(javaIDs.Application.notifyThemeChangedMID);\n+    javaIDs.Application.notifyPreferencesChangedMID =\n+        env->GetMethodID(cls, \"notifyPreferencesChanged\", \"(Ljava\/util\/Map;)V\");\n+    ASSERT(javaIDs.Application.notifyPreferencesChangedMID);\n@@ -454,11 +449,0 @@\n-\/*\n- * Class:     com_sun_glass_ui_win_WinApplication\n- * Method:    _getHighContrastTheme\n- * Signature: ()Ljava\/lang\/String;\n- *\/\n-JNIEXPORT jstring JNICALL Java_com_sun_glass_ui_win_WinApplication__1getHighContrastTheme\n-  (JNIEnv * env, jobject self)\n-{\n-    return GlassApplication::GetThemeName(env);\n-}\n-\n@@ -538,0 +522,11 @@\n+\/*\n+ * Class:     com_sun_glass_ui_win_WinApplication\n+ * Method:    getPlatformPreferences\n+ * Signature: ()Ljava\/util\/Map;\n+ *\/\n+JNIEXPORT jobject JNICALL Java_com_sun_glass_ui_win_WinApplication_getPlatformPreferences\n+    (JNIEnv * env, jobject self)\n+{\n+    return GlassApplication::GetPlatformPreferences();\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassApplication.cpp","additions":32,"deletions":37,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-\n+#include \"PlatformSupport.h\"\n@@ -84,1 +84,4 @@\n-    static jstring GetThemeName(JNIEnv* env);\n+\n+    static jobject GetPlatformPreferences() {\n+        return pInstance ? pInstance->m_platformSupport.collectPreferences() : NULL;\n+    }\n@@ -128,0 +131,1 @@\n+    PlatformSupport m_platformSupport;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassApplication.h","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"PlatformSupport.h\"\n+#include \"RoActivationSupport.h\"\n+#include <windows.ui.viewmanagement.h>\n+#include <tuple>\n+\n+using namespace Microsoft::WRL;\n+using namespace ABI::Windows::UI;\n+using namespace ABI::Windows::UI::ViewManagement;\n+\n+PlatformSupport::PlatformSupport(JNIEnv* env) : env(env), initialized(false), preferences(NULL)\n+{\n+    javaClasses.Object = (jclass)env->FindClass(\"java\/lang\/Object\");\n+    if (CheckAndClearException(env)) return;\n+\n+    javaIDs.Object.equals = env->GetMethodID(javaClasses.Object, \"equals\", \"(Ljava\/lang\/Object;)Z\");\n+    if (CheckAndClearException(env)) return;\n+\n+    javaClasses.Collections = (jclass)env->FindClass(\"java\/util\/Collections\");\n+    if (CheckAndClearException(env)) return;\n+\n+    javaIDs.Collections.unmodifiableMap = env->GetStaticMethodID(\n+        javaClasses.Collections, \"unmodifiableMap\", \"(Ljava\/util\/Map;)Ljava\/util\/Map;\");\n+    if (CheckAndClearException(env)) return;\n+\n+    javaClasses.Map = (jclass)env->FindClass(\"java\/util\/Map\");\n+    if (CheckAndClearException(env)) return;\n+\n+    javaIDs.Map.put = env->GetMethodID(\n+        javaClasses.Map, \"put\", \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n+    if (CheckAndClearException(env)) return;\n+\n+    javaClasses.HashMap = (jclass)env->FindClass(\"java\/util\/HashMap\");\n+    if (CheckAndClearException(env)) return;\n+\n+    javaIDs.HashMap.init = env->GetMethodID(javaClasses.HashMap, \"<init>\", \"()V\");\n+    if (CheckAndClearException(env)) return;\n+\n+    javaClasses.Color = (jclass)env->FindClass(\"javafx\/scene\/paint\/Color\");\n+    if (CheckAndClearException(env)) return;\n+\n+    javaIDs.Color.rgb = env->GetStaticMethodID(javaClasses.Color, \"rgb\", \"(IIID)Ljavafx\/scene\/paint\/Color;\");\n+    if (CheckAndClearException(env)) return;\n+\n+    javaClasses.Boolean = (jclass)env->FindClass(\"java\/lang\/Boolean\");\n+    if (CheckAndClearException(env)) return;\n+\n+    javaIDs.Boolean.trueID = env->GetStaticFieldID(javaClasses.Boolean, \"TRUE\", \"Ljava\/lang\/Boolean;\");\n+    if (CheckAndClearException(env)) return;\n+\n+    javaIDs.Boolean.falseID = env->GetStaticFieldID(javaClasses.Boolean, \"FALSE\", \"Ljava\/lang\/Boolean;\");\n+    if (CheckAndClearException(env)) return;\n+\n+    initialized = true;\n+}\n+\n+jobject PlatformSupport::collectPreferences() const\n+{\n+    if (!initialized) {\n+        return NULL;\n+    }\n+\n+    jobject prefs = env->NewObject(javaClasses.HashMap, javaIDs.HashMap.init);\n+    if (CheckAndClearException(env)) return NULL;\n+\n+    queryHighContrastScheme(prefs);\n+    querySystemColors(prefs);\n+    queryUIColors(prefs);\n+    return prefs;\n+}\n+\n+bool PlatformSupport::updatePreferences(jobject application) const\n+{\n+    if (!initialized || application == NULL) {\n+        return false;\n+    }\n+\n+    jobject newPreferences = collectPreferences();\n+\n+    jboolean preferencesChanged =\n+        newPreferences != NULL &&\n+        !env->CallBooleanMethod(newPreferences, javaIDs.Object.equals, preferences);\n+\n+    if (!CheckAndClearException(env) && preferencesChanged) {\n+        preferences = newPreferences;\n+        jobject unmodifiablePreferences = env->CallStaticObjectMethod(\n+            javaClasses.Collections, javaIDs.Collections.unmodifiableMap, newPreferences);\n+\n+        if (!CheckAndClearException(env)) {\n+            env->CallVoidMethod(application, javaIDs.Application.notifyPreferencesChangedMID, unmodifiablePreferences);\n+            env->DeleteLocalRef(unmodifiablePreferences);\n+            env->DeleteLocalRef(newPreferences);\n+            CheckAndClearException(env);\n+            return true;\n+        }\n+    }\n+\n+    env->DeleteLocalRef(newPreferences);\n+    CheckAndClearException(env);\n+    return false;\n+}\n+\n+void PlatformSupport::queryHighContrastScheme(jobject properties) const\n+{\n+    HIGHCONTRAST contrastInfo;\n+    contrastInfo.cbSize = sizeof(HIGHCONTRAST);\n+    ::SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRAST), &contrastInfo, 0);\n+    if (contrastInfo.dwFlags & HCF_HIGHCONTRASTON) {\n+        putBoolean(properties, \"Windows.SPI.HighContrastOn\", true);\n+        putString(properties, \"Windows.SPI.HighContrastColorScheme\", contrastInfo.lpszDefaultScheme);\n+    } else {\n+        putBoolean(properties, \"Windows.SPI.HighContrastOn\", false);\n+        putString(properties, \"Windows.SPI.HighContrastColorScheme\", (const char*)NULL);\n+    }\n+}\n+\n+void PlatformSupport::querySystemColors(jobject properties) const\n+{\n+    putColor(properties, \"Windows.SysColor.COLOR_3DFACE\", GetSysColor(COLOR_3DFACE));\n+    putColor(properties, \"Windows.SysColor.COLOR_BTNTEXT\", GetSysColor(COLOR_BTNTEXT));\n+    putColor(properties, \"Windows.SysColor.COLOR_GRAYTEXT\", GetSysColor(COLOR_GRAYTEXT));\n+    putColor(properties, \"Windows.SysColor.COLOR_HIGHLIGHT\", GetSysColor(COLOR_HIGHLIGHT));\n+    putColor(properties, \"Windows.SysColor.COLOR_HIGHLIGHTTEXT\", GetSysColor(COLOR_HIGHLIGHTTEXT));\n+    putColor(properties, \"Windows.SysColor.COLOR_HOTLIGHT\", GetSysColor(COLOR_HOTLIGHT));\n+    putColor(properties, \"Windows.SysColor.COLOR_WINDOW\", GetSysColor(COLOR_WINDOW));\n+    putColor(properties, \"Windows.SysColor.COLOR_WINDOWTEXT\", GetSysColor(COLOR_WINDOWTEXT));\n+}\n+\n+void PlatformSupport::queryUIColors(jobject properties) const\n+{\n+    if (!isRoActivationSupported()) {\n+        return;\n+    }\n+\n+    try {\n+        ComPtr<IUISettings> settings;\n+        RO_CHECKED(\"RoActivateInstance\",\n+                   RoActivateInstance(hstring(\"Windows.UI.ViewManagement.UISettings\"), (IInspectable**)&settings));\n+\n+        ComPtr<IUISettings3> settings3;\n+        RO_CHECKED(\"IUISettings::QueryInterface<IUISettings3>\",\n+                   settings->QueryInterface<IUISettings3>(&settings3));\n+\n+        Color background, foreground, accentDark3, accentDark2, accentDark1, accent,\n+              accentLight1, accentLight2, accentLight3;\n+\n+        settings3->GetColorValue(UIColorType::UIColorType_Background, &background);\n+        settings3->GetColorValue(UIColorType::UIColorType_Foreground, &foreground);\n+        settings3->GetColorValue(UIColorType::UIColorType_AccentDark3, &accentDark3);\n+        settings3->GetColorValue(UIColorType::UIColorType_AccentDark2, &accentDark2);\n+        settings3->GetColorValue(UIColorType::UIColorType_AccentDark1, &accentDark1);\n+        settings3->GetColorValue(UIColorType::UIColorType_Accent, &accent);\n+        settings3->GetColorValue(UIColorType::UIColorType_AccentLight1, &accentLight1);\n+        settings3->GetColorValue(UIColorType::UIColorType_AccentLight2, &accentLight2);\n+        settings3->GetColorValue(UIColorType::UIColorType_AccentLight3, &accentLight3);\n+\n+        putColor(properties, \"Windows.UIColor.Background\", background);\n+        putColor(properties, \"Windows.UIColor.Foreground\", foreground);\n+        putColor(properties, \"Windows.UIColor.AccentDark3\", accentDark3);\n+        putColor(properties, \"Windows.UIColor.AccentDark2\", accentDark2);\n+        putColor(properties, \"Windows.UIColor.AccentDark1\", accentDark1);\n+        putColor(properties, \"Windows.UIColor.Accent\", accent);\n+        putColor(properties, \"Windows.UIColor.AccentLight1\", accentLight1);\n+        putColor(properties, \"Windows.UIColor.AccentLight2\", accentLight2);\n+        putColor(properties, \"Windows.UIColor.AccentLight3\", accentLight3);\n+    } catch (RoException const&) {\n+        \/\/ If an activation exception occurs, it probably means that we're on a Windows system\n+        \/\/ that doesn't support the UISettings API. This is not a problem, it simply means that\n+        \/\/ we don't report the UISettings properties back to the JavaFX application.\n+        return;\n+    }\n+}\n+\n+void PlatformSupport::putString(jobject properties, const char* key, const char* value) const\n+{\n+    jobject prefKey = env->NewStringUTF(key);\n+    if (CheckAndClearException(env)) return;\n+\n+    jobject prefValue = NULL;\n+    if (value != NULL) {\n+        prefValue = env->NewStringUTF(value);\n+        if (CheckAndClearException(env)) return;\n+    }\n+\n+    env->CallObjectMethod(properties, javaIDs.Map.put, prefKey, prefValue);\n+    CheckAndClearException(env);\n+}\n+\n+void PlatformSupport::putString(jobject properties, const char* key, const wchar_t* value) const\n+{\n+    jobject prefKey = env->NewStringUTF(key);\n+    if (CheckAndClearException(env)) return;\n+\n+    jobject prefValue = NULL;\n+    if (value != NULL) {\n+        prefValue = env->NewString((jchar*)value, wcslen(value));\n+        if (CheckAndClearException(env)) return;\n+    }\n+\n+    env->CallObjectMethod(properties, javaIDs.Map.put, prefKey, prefValue);\n+    CheckAndClearException(env);\n+}\n+\n+void PlatformSupport::putBoolean(jobject properties, const char* key, const bool value) const\n+{\n+    jobject prefKey = env->NewStringUTF(key);\n+    if (CheckAndClearException(env)) return;\n+\n+    jobject prefValue = value ?\n+        env->GetStaticObjectField(javaClasses.Boolean, javaIDs.Boolean.trueID) :\n+        env->GetStaticObjectField(javaClasses.Boolean, javaIDs.Boolean.falseID);\n+    if (CheckAndClearException(env)) return;\n+\n+    env->CallObjectMethod(properties, javaIDs.Map.put, prefKey, prefValue);\n+    CheckAndClearException(env);\n+}\n+\n+void PlatformSupport::putColor(jobject properties, const char* colorName, int colorValue) const\n+{\n+    jobject prefKey = env->NewStringUTF(colorName);\n+    if (CheckAndClearException(env)) return;\n+\n+    jobject prefValue = env->CallStaticObjectMethod(\n+        javaClasses.Color, javaIDs.Color.rgb,\n+        GetRValue(colorValue), GetGValue(colorValue), GetBValue(colorValue), 1.0);\n+    if (CheckAndClearException(env)) return;\n+\n+    env->CallObjectMethod(properties, javaIDs.Map.put, prefKey, prefValue);\n+    CheckAndClearException(env);\n+}\n+\n+void PlatformSupport::putColor(jobject properties, const char* colorName, Color colorValue) const\n+{\n+    jobject prefKey = env->NewStringUTF(colorName);\n+    if (CheckAndClearException(env)) return;\n+\n+    jobject prefValue = env->CallStaticObjectMethod(\n+        javaClasses.Color, javaIDs.Color.rgb,\n+        colorValue.R, colorValue.G, colorValue.B, (double)colorValue.A \/ 255.0);\n+    if (CheckAndClearException(env)) return;\n+\n+    env->CallObjectMethod(properties, javaIDs.Map.put, prefKey, prefValue);\n+    CheckAndClearException(env);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/PlatformSupport.cpp","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma once\n+\n+#include <common.h>\n+\n+namespace ABI { namespace Windows { namespace UI { struct Color; } } }\n+\n+class PlatformSupport final\n+{\n+public:\n+    PlatformSupport(JNIEnv*);\n+    ~PlatformSupport() = default;\n+    PlatformSupport(PlatformSupport const&) = delete;\n+    PlatformSupport& operator=(PlatformSupport const&) = delete;\n+\n+    \/**\n+     * Collect all platform preferences and return them as a new java\/util\/Map.\n+     *\/\n+    jobject collectPreferences() const;\n+\n+    \/**\n+     * Collect all platform preferences and notify the JavaFX application when a preference has changed.\n+     * The change notification includes all preferences, not only the changed preferences.\n+     *\/\n+    bool updatePreferences(jobject application) const;\n+\n+private:\n+    JNIEnv* env;\n+    bool initialized;\n+    mutable JGlobalRef<jobject> preferences;\n+\n+    struct {\n+        JGlobalRef<jclass> Boolean;\n+        JGlobalRef<jclass> Object;\n+        JGlobalRef<jclass> Collections;\n+        JGlobalRef<jclass> Map;\n+        JGlobalRef<jclass> HashMap;\n+        JGlobalRef<jclass> Color;\n+    } javaClasses;\n+\n+    void querySystemColors(jobject properties) const;\n+    void queryHighContrastScheme(jobject properties) const;\n+    void queryUIColors(jobject properties) const;\n+\n+    void putString(jobject properties, const char* key, const char* value) const;\n+    void putString(jobject properties, const char* key, const wchar_t* value) const;\n+    void putBoolean(jobject properties, const char* key, const bool value) const;\n+    void putColor(jobject properties, const char* colorName, int colorValue) const;\n+    void putColor(jobject properties, const char* colorName, ABI::Windows::UI::Color colorValue) const;\n+};\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/PlatformSupport.h","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"RoActivationSupport.h\"\n+#include <utility>\n+#include <comdef.h>\n+#include <winstring.h>\n+#include <jni.h>\n+\n+namespace\n+{\n+    typedef HRESULT WINAPI FnRoInitialize(RO_INIT_TYPE initType);\n+    typedef void WINAPI FnRoUninitialize();\n+    typedef HRESULT WINAPI FnRoActivateInstance(HSTRING activatableClassId, IInspectable** instance);\n+    typedef HRESULT WINAPI FnWindowsCreateString(PCNZWCH sourceString, UINT32 length, HSTRING* string);\n+    typedef HRESULT WINAPI FnWindowsDeleteString(HSTRING string);\n+\n+    bool initialized = false;\n+    const char* moduleNotFoundMessage = \"WinRT: %s not found\\n\";\n+    HMODULE hLibComBase = NULL;\n+    FnRoInitialize* pRoInitialize = NULL;\n+    FnRoUninitialize* pRoUninitialize = NULL;\n+    FnRoActivateInstance* pRoActivateInstance = NULL;\n+    FnWindowsCreateString* pWindowsCreateString = NULL;\n+    FnWindowsDeleteString* pWindowsDeleteString = NULL;\n+\n+    template<class T>\n+    bool loadFunction(HMODULE lib, T*& fnptr, const char* name)\n+    {\n+        fnptr = reinterpret_cast<T*>(GetProcAddress(lib, name));\n+        if (fnptr == NULL) {\n+            fprintf(stderr, \"GetProcAddress: %s not loaded\\n\", name);\n+            initialized = false;\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+}\n+\n+void tryInitializeRoActivationSupport()\n+{\n+    if (initialized) {\n+        return;\n+    }\n+\n+    wchar_t path[MAX_PATH];\n+    wchar_t file[MAX_PATH];\n+\n+    if (GetSystemDirectory(path, sizeof(path) \/ sizeof(wchar_t)) == 0) {\n+        return;\n+    }\n+\n+    memcpy_s(file, sizeof(file), path, sizeof(path));\n+    wcscat_s(file, MAX_PATH-1, L\"\\\\combase.dll\");\n+    hLibComBase = LoadLibraryW(file);\n+    if (!hLibComBase) {\n+        fprintf(stderr, moduleNotFoundMessage, \"combase.dll\");\n+        return;\n+    }\n+\n+    bool loaded =\n+        loadFunction(hLibComBase, pRoInitialize, \"RoInitialize\") &&\n+        loadFunction(hLibComBase, pRoUninitialize, \"RoUninitialize\") &&\n+        loadFunction(hLibComBase, pRoActivateInstance, \"RoActivateInstance\") &&\n+        loadFunction(hLibComBase, pWindowsCreateString, \"WindowsCreateString\") &&\n+        loadFunction(hLibComBase, pWindowsDeleteString, \"WindowsDeleteString\");\n+\n+    if (!loaded) {\n+        uninitializeRoActivationSupport();\n+    } else {\n+        HRESULT res = RoInitialize(RO_INIT_SINGLETHREADED);\n+        if (FAILED(res)) {\n+            fprintf(stderr, RoException(\"RoInitialize failed: \", res).message());\n+            uninitializeRoActivationSupport();\n+        } else {\n+            initialized = true;\n+        }\n+    }\n+}\n+\n+void uninitializeRoActivationSupport()\n+{\n+    if (initialized) {\n+        RoUninitialize();\n+    }\n+\n+    initialized = false;\n+\n+    if (hLibComBase) {\n+        FreeLibrary(hLibComBase);\n+        hLibComBase = NULL;\n+        pRoInitialize = NULL;\n+        pRoUninitialize = NULL;\n+        pRoActivateInstance = NULL;\n+        pWindowsCreateString = NULL;\n+        pWindowsDeleteString = NULL;\n+    }\n+}\n+\n+bool isRoActivationSupported()\n+{\n+    return initialized;\n+}\n+\n+HRESULT WINAPI RoInitialize(RO_INIT_TYPE initType)\n+{\n+    return pRoInitialize(initType);\n+}\n+\n+void WINAPI RoUninitialize()\n+{\n+    pRoUninitialize();\n+}\n+\n+HRESULT WINAPI RoActivateInstance(HSTRING activatableClassId, IInspectable** instance)\n+{\n+    return pRoActivateInstance(activatableClassId, instance);\n+}\n+\n+HRESULT WINAPI WindowsCreateString(PCNZWCH sourceString, UINT32 length, HSTRING* string)\n+{\n+    return pWindowsCreateString(sourceString, length, string);\n+}\n+\n+HRESULT WINAPI WindowsDeleteString(HSTRING string)\n+{\n+    return pWindowsDeleteString(string);\n+}\n+\n+hstring::hstring(const char* str) : hstr_(NULL)\n+{\n+    int wstr_len = MultiByteToWideChar(CP_UTF8, 0, str, -1, NULL, 0);\n+    if (wstr_len == 0) return;\n+\n+    WCHAR* wstr = new WCHAR[wstr_len];\n+    if (wstr == NULL) return;\n+\n+    memset(wstr, 0, wstr_len * sizeof(WCHAR));\n+    if (MultiByteToWideChar(CP_UTF8, 0, str, -1, wstr, wstr_len) > 0) {\n+        WindowsCreateString(wstr, wstr_len - 1, &hstr_);\n+    }\n+\n+    delete[] wstr;\n+}\n+\n+hstring::~hstring()\n+{\n+    if (hstr_ != NULL) {\n+        WindowsDeleteString(hstr_);\n+    }\n+}\n+\n+hstring::operator HSTRING()\n+{\n+    return hstr_;\n+}\n+\n+RoException::RoException(const char* message) : message_(NULL)\n+{\n+    if (message == NULL) {\n+        message = \"\";\n+    }\n+\n+    size_t len = strlen(message);\n+    if (len == 0) return;\n+\n+    char* msg = new char[len + 1];\n+    if (msg == NULL) return;\n+\n+    strcpy_s(msg, len + 1, message);\n+    message_ = msg;\n+}\n+\n+RoException::RoException(const char* message, HRESULT res) : message_(NULL)\n+{\n+    if (message == NULL) {\n+        message = \"\";\n+    }\n+\n+    const wchar_t* error = _com_error(res).ErrorMessage();\n+    if (error == NULL) return;\n+\n+    int error_length = WideCharToMultiByte(CP_ACP, 0, error, -1, NULL, 0, NULL, FALSE);\n+    if (error_length == 0) return;\n+\n+    int message_length = int(strlen(message));\n+    char* result = new char[message_length + error_length];\n+    if (result == NULL) return;\n+\n+    \/\/ Concatenate the \"message\" and \"error\" strings.\n+    WideCharToMultiByte(CP_ACP, 0, error, -1, result + message_length, error_length, NULL, FALSE);\n+    memcpy_s(result, message_length, message, message_length);\n+    message_ = result;\n+}\n+\n+RoException::RoException(const RoException& source) :\n+    RoException(source.message()) {}\n+\n+RoException::~RoException()\n+{\n+    if (message_ != NULL) {\n+        delete[] message_;\n+    }\n+}\n+\n+RoException& RoException::operator=(RoException source)\n+{\n+    std::swap(message_, source.message_);\n+    return *this;\n+}\n+\n+const char* RoException::message() const\n+{\n+    return message_ != NULL ? message_ : \"\";\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/RoActivationSupport.cpp","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma once\n+\n+\/*\n+ * This flag gives us function prototypes without the __declspec(dllimport) storage class specifier.\n+ * We're using GetProcAddress to load the functions at runtime.\n+ *\/\n+#define _ROAPI_\n+\n+#include <roapi.h>\n+#include <wrl.h>\n+#include <hstring.h>\n+\n+#define RO_CHECKED(NAME, FUNC) \\\n+    { HRESULT res = FUNC; if (FAILED(res)) throw RoException(NAME ## \" failed: \", res); }\n+\n+void tryInitializeRoActivationSupport();\n+void uninitializeRoActivationSupport();\n+bool isRoActivationSupported();\n+\n+\/*\n+ * Facilitates interop between C-style strings and WinRT HSTRINGs.\n+ * A hstring can be constructed from a C-style string, and it can be implicitly converted to a HSTRING.\n+ * The lifetime of the HSTRING corresponds to the lifetime of the hstring instance.\n+ *\/\n+struct hstring\n+{\n+    hstring(const char* str);\n+    hstring(const hstring&) = delete;\n+    ~hstring();\n+\n+    operator HSTRING();\n+    hstring& operator=(hstring) = delete;\n+\n+private:\n+    HSTRING hstr_;\n+};\n+\n+\/*\n+ * The exception thrown by the RO_CHECKED macro, indicating that a Windows Runtime API call has failed.\n+ * The exception message contains the system message text for the failed HRESULT.\n+ *\/\n+class RoException\n+{\n+public:\n+    RoException(const char* message);\n+    RoException(const char* message, HRESULT);\n+    RoException(const RoException&);\n+    ~RoException();\n+\n+    RoException& operator=(RoException);\n+    const char* message() const;\n+\n+private:\n+    const char* message_;\n+};\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/RoActivationSupport.h","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -291,3 +291,3 @@\n-    operator T() { return m_localJRef; }\n-    operator bool() { return NULL!=m_localJRef; }\n-    bool operator !() { return NULL==m_localJRef; }\n+    operator T() const { return m_localJRef; }\n+    operator bool() const { return NULL!=m_localJRef; }\n+    bool operator !() const { return NULL==m_localJRef; }\n@@ -329,3 +329,3 @@\n-    operator T() { return m_globalJRef; }\n-    operator bool() { return NULL!=m_globalJRef; }\n-    bool operator !() { return NULL==m_globalJRef; }\n+    operator T() const { return m_globalJRef; }\n+    operator bool() const { return NULL!=m_globalJRef; }\n+    bool operator !() const { return NULL==m_globalJRef; }\n@@ -506,1 +506,1 @@\n-        jmethodID notifyThemeChangedMID;\n+        jmethodID notifyPreferencesChangedMID;\n@@ -508,0 +508,19 @@\n+    struct {\n+        jmethodID rgb;\n+    } Color;\n+    struct {\n+        jfieldID trueID;\n+        jfieldID falseID;\n+    } Boolean;\n+    struct {\n+        jmethodID equals;\n+    } Object;\n+    struct {\n+        jmethodID unmodifiableMap;\n+    } Collections;\n+    struct {\n+        jmethodID put;\n+    } Map;\n+    struct {\n+        jmethodID init;\n+    } HashMap;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/Utils.h","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -10,0 +10,1 @@\n+--add-exports javafx.graphics\/com.sun.javafx.application.preferences=ALL-UNNAMED\n","filename":"modules\/javafx.graphics\/src\/test\/addExports","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.application.preferences;\n+\n+import com.sun.javafx.application.preferences.ChangedValue;\n+import org.junit.jupiter.api.Test;\n+import java.util.Map;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ChangedValueTest {\n+\n+    @Test\n+    public void testSingleChangedValue() {\n+        var changes = ChangedValue.getEffectiveChanges(Map.of(\"k1\", 1, \"k2\", \"foo\"), Map.of(\"k1\", 2, \"k2\", \"foo\"));\n+        assertEquals(1, changes.size());\n+        assertEquals(1, changes.get(\"k1\").oldValue());\n+        assertEquals(2, changes.get(\"k1\").newValue());\n+    }\n+\n+    @Test\n+    public void testMultipleChangedValues() {\n+        var changes = ChangedValue.getEffectiveChanges(Map.of(\"k1\", 1, \"k2\", \"foo\"), Map.of(\"k1\", 2, \"k2\", \"bar\"));\n+        assertEquals(2, changes.size());\n+        assertEquals(1, changes.get(\"k1\").oldValue());\n+        assertEquals(2, changes.get(\"k1\").newValue());\n+        assertEquals(\"foo\", changes.get(\"k2\").oldValue());\n+        assertEquals(\"bar\", changes.get(\"k2\").newValue());\n+    }\n+\n+    @Test\n+    public void testSingleChangedArrayValue() {\n+        var changes = ChangedValue.getEffectiveChanges(\n+            Map.of(\"k1\", new String[] {\"foo\"}, \"k2\", new String[] {\"bar\"}),\n+            Map.of(\"k1\", new String[] {\"foo\"}, \"k2\", new String[] {\"baz\"}));\n+        assertEquals(1, changes.size());\n+        assertArrayEquals(new String[] {\"bar\"}, (String[])changes.get(\"k2\").oldValue());\n+        assertArrayEquals(new String[] {\"baz\"}, (String[])changes.get(\"k2\").newValue());\n+    }\n+\n+    @Test\n+    public void testMultipleChangedArrayValues() {\n+        var changes = ChangedValue.getEffectiveChanges(\n+            Map.of(\"k1\", new String[] {\"foo\"}, \"k2\", new String[] {\"qux\"}),\n+            Map.of(\"k1\", new String[] {\"bar\"}, \"k2\", new String[] {\"quz\"}));\n+        assertEquals(2, changes.size());\n+        assertArrayEquals(new String[] {\"foo\"}, (String[])changes.get(\"k1\").oldValue());\n+        assertArrayEquals(new String[] {\"bar\"}, (String[])changes.get(\"k1\").newValue());\n+        assertArrayEquals(new String[] {\"qux\"}, (String[])changes.get(\"k2\").oldValue());\n+        assertArrayEquals(new String[] {\"quz\"}, (String[])changes.get(\"k2\").newValue());\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/application\/preferences\/ChangedValueTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,330 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.application.preferences;\n+\n+import com.sun.javafx.application.preferences.PlatformPreferences;\n+import javafx.animation.Interpolatable;\n+import javafx.scene.paint.CycleMethod;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.Paint;\n+import test.javafx.collections.MockMapObserver;\n+import javafx.beans.InvalidationListener;\n+import javafx.collections.MapChangeListener;\n+import javafx.scene.paint.Color;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static test.javafx.collections.MockMapObserver.Tuple.tup;\n+\n+public class PlatformPreferencesTest {\n+\n+    PlatformPreferences prefs;\n+\n+    @BeforeEach\n+    void setup() {\n+        prefs = new PlatformPreferences(\n+            \/\/ Well-known platform keys and their associated type\n+            Map.of(\n+                \"test.anInt\", Integer.class,\n+                \"test.aDouble\", Double.class,\n+                \"test.aBoolean\", Boolean.class,\n+                \"test.aString\", String.class,\n+                \"test.aColor\", Color.class,\n+                \"test.aPaint\", Paint.class,\n+                \"test.aPaintArray\", Paint[].class\n+            ),\n+            \/\/ Platform-specific key mappings\n+            Map.of(\n+                \"test.foregroundColor\", \"foregroundColor\",\n+                \"test.backgroundColor\", \"backgroundColor\",\n+                \"test.accentColor\", \"accentColor\"\n+            ));\n+    }\n+\n+    @Test\n+    void testWellKnownKeyThrowsExceptionWithWrongGetter() {\n+        assertThrows(IllegalArgumentException.class, () -> prefs.getDouble(\"test.anInt\"));\n+        assertThrows(IllegalArgumentException.class, () -> prefs.getInteger(\"test.aDouble\"));\n+        assertThrows(IllegalArgumentException.class, () -> prefs.getString(\"test.aBoolean\"));\n+        assertThrows(IllegalArgumentException.class, () -> prefs.getColor(\"test.aString\"));\n+        assertThrows(IllegalArgumentException.class, () -> prefs.getInteger(\"test.aColor\"));\n+        assertThrows(IllegalArgumentException.class, () -> prefs.getString(\"test.aPaint\"));\n+    }\n+\n+    @Test\n+    void testWellKnownKeyReturnsEmptyValueWhenMappingNotPresent() {\n+        assertEquals(Optional.empty(), prefs.getInteger(\"test.anInt\"));\n+        assertEquals(Optional.empty(), prefs.getDouble(\"test.aDouble\"));\n+        assertEquals(Optional.empty(), prefs.getBoolean(\"test.aBoolean\"));\n+        assertEquals(Optional.empty(), prefs.getString(\"test.aString\"));\n+        assertEquals(Optional.empty(), prefs.getColor(\"test.aColor\"));\n+        assertEquals(Optional.empty(), prefs.getValue(\"test.aColor\", Color.class));\n+        assertEquals(Optional.empty(), prefs.getValue(\"test.aPaint\", Paint.class));\n+        assertEquals(Optional.empty(), prefs.getValue(\"test.aPaint\", Color.class));\n+    }\n+\n+    @Test\n+    void testPolymorphicValues() {\n+        prefs.update(Map.of(\"test.aPaint\", Color.RED));\n+        assertEquals(Color.RED, prefs.getColor(\"test.aPaint\").orElseThrow());\n+        assertEquals(Color.RED, prefs.getValue(\"test.aPaint\", Paint.class).orElseThrow());\n+        assertEquals(Color.RED, prefs.getValue(\"test.aPaint\", Object.class).orElseThrow());\n+        assertEquals(Color.RED, prefs.getValue(\"test.aPaint\", Interpolatable.class).orElseThrow());\n+        assertThrows(IllegalArgumentException.class, () -> prefs.getValue(\"test.aPaint\", LinearGradient.class));\n+\n+        var gradient = new LinearGradient(0, 0, 1, 1, true, CycleMethod.NO_CYCLE);\n+        prefs.update(Map.of(\"test.aPaint\", gradient));\n+        assertEquals(gradient, prefs.getValue(\"test.aPaint\", Paint.class).orElseThrow());\n+        assertEquals(gradient, prefs.getValue(\"test.aPaint\", LinearGradient.class).orElseThrow());\n+        assertEquals(gradient, prefs.getValue(\"test.aPaint\", Object.class).orElseThrow());\n+        assertThrows(IllegalArgumentException.class, () -> prefs.getColor(\"test.aPaint\").orElseThrow());\n+    }\n+\n+    @Test\n+    void testPolymorphicArrayValues() {\n+        var colors = new Color[] {Color.RED, Color.GREEN, Color.BLUE};\n+        prefs.update(Map.of(\"test.aPaintArray\", colors));\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Object[].class).orElseThrow());\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Color[].class).orElseThrow());\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Paint[].class).orElseThrow());\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Interpolatable[].class).orElseThrow());\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Object.class).orElseThrow());\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Cloneable.class).orElseThrow());\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Serializable.class).orElseThrow());\n+        assertThrows(IllegalArgumentException.class, () -> prefs.getValue(\"test.aPaintArray\", Paint.class));\n+        assertThrows(IllegalArgumentException.class, () -> prefs.getValue(\"test.aPaintArray\", LinearGradient[].class));\n+    }\n+\n+    @Test\n+    void testMapIsImmutable() {\n+        prefs.update(Map.of(\"k1\", 5, \"k2\", 7.5));\n+        assertThrows(UnsupportedOperationException.class, () -> prefs.put(\"k1\", 4));\n+        assertThrows(UnsupportedOperationException.class, () -> prefs.remove(\"k1\"));\n+        assertThrows(UnsupportedOperationException.class, () -> prefs.clear());\n+        assertThrows(UnsupportedOperationException.class, () -> prefs.entrySet().remove(prefs.entrySet().iterator().next()));\n+        assertThrows(UnsupportedOperationException.class, () -> prefs.entrySet().clear());\n+        assertThrows(UnsupportedOperationException.class, () -> prefs.keySet().remove(prefs.keySet().iterator().next()));\n+        assertThrows(UnsupportedOperationException.class, () -> prefs.keySet().clear());\n+    }\n+\n+    @Test\n+    void testUnknownKeyReturnsEmptyValue() {\n+        assertEquals(Optional.empty(), prefs.getInteger(\"does_not_exist\"));\n+        assertEquals(Optional.empty(), prefs.getDouble(\"does_not_exist\"));\n+        assertEquals(Optional.empty(), prefs.getBoolean(\"does_not_exist\"));\n+        assertEquals(Optional.empty(), prefs.getString(\"does_not_exist\"));\n+        assertEquals(Optional.empty(), prefs.getColor(\"does_not_exist\"));\n+        assertEquals(Optional.empty(), prefs.getValue(\"does_not_exist\", String.class));\n+    }\n+\n+    @Test\n+    void testGetValueWithWrongTypeFails() {\n+        prefs.update(Map.of(\"k\", 5));\n+        assertThrows(IllegalArgumentException.class, () -> prefs.getValue(\"k\", Double.class));\n+    }\n+\n+    @Test\n+    void testOptionalKeys() {\n+        prefs.update(Map.of(\n+            \"k1\", 5,\n+            \"k2\", 7.5,\n+            \"k3\", true,\n+            \"k4\", \"foo\",\n+            \"k5\", Color.RED));\n+\n+        assertEquals(5, prefs.getInteger(\"k1\").orElseThrow());\n+        assertEquals(7.5, prefs.getDouble(\"k2\").orElseThrow(), 0.001);\n+        assertEquals(true, prefs.getBoolean(\"k3\").orElseThrow());\n+        assertEquals(\"foo\", prefs.getString(\"k4\").orElseThrow());\n+        assertEquals(Color.RED, prefs.getColor(\"k5\").orElseThrow());\n+    }\n+\n+    @Test\n+    void testUpdatePreferencesWithNewContent() {\n+        var content = Map.of(\n+            \"red\", Color.RED,\n+            \"blue\", Color.BLUE,\n+            \"str\", \"foo\",\n+            \"bool\", true);\n+        prefs.update(content);\n+        assertEquals(content, prefs);\n+    }\n+\n+    @Test\n+    void testUpdatePreferencesWithSameContent() {\n+        var content = Map.of(\n+            \"red\", Color.RED,\n+            \"blue\", Color.BLUE,\n+            \"str\", \"foo\",\n+            \"bool\", true);\n+        prefs.update(content);\n+        prefs.update(content);\n+        assertEquals(content, prefs);\n+    }\n+\n+    @Test\n+    void testUpdatePreferencesWithNullValueRemovesMapping() {\n+        var content = Map.of(\n+            \"red\", Color.RED,\n+            \"blue\", Color.BLUE,\n+            \"str\", \"foo\",\n+            \"bool\", true);\n+        prefs.update(content);\n+        assertEquals(content, prefs);\n+\n+        prefs.update(new HashMap<>() {{ put(\"red\", null); }});\n+        assertEquals(\n+            Map.of(\n+                \"blue\", Color.BLUE,\n+                \"str\", \"foo\",\n+                \"bool\", true),\n+            prefs);\n+    }\n+\n+    @Test\n+    void testPlatformPreferencesInvalidationListener() {\n+        int[] count = new int[1];\n+        InvalidationListener listener = observable -> count[0]++;\n+        prefs.addListener(listener);\n+\n+        prefs.update(Map.of(\"foo\", \"bar\"));\n+        assertEquals(1, count[0]);\n+\n+        prefs.update(Map.of(\"qux\", \"quux\", \"quz\", \"quuz\"));\n+        assertEquals(2, count[0]);\n+\n+        prefs.update(Map.of(\"qux\", \"quux\", \"quz\", \"quuz\", \"abc\", \"def\"));\n+        assertEquals(3, count[0]);\n+    }\n+\n+    @Test\n+    void testPlatformPreferencesChangeListener() {\n+        var observer = new MockMapObserver<String, Object>();\n+        prefs.addListener(observer);\n+\n+        \/\/ Two added keys are included in the change notification\n+        prefs.update(Map.of(\"foo\", \"bar\", \"baz\", \"qux\"));\n+        assertEquals(2, observer.getCallsNumber());\n+        observer.assertAdded(0, tup(\"foo\", \"bar\"));\n+        observer.assertAdded(1, tup(\"baz\", \"qux\"));\n+        observer.clear();\n+\n+        \/\/ Mappings that haven't changed are not included in the change notification (baz=qux)\n+        prefs.update(Map.of(\"foo\", \"bar2\", \"baz\", \"qux\"));\n+        assertEquals(1, observer.getCallsNumber());\n+        observer.assertRemoved(0, tup(\"foo\", \"bar\"));\n+        observer.assertAdded(0, tup(\"foo\", \"bar2\"));\n+        observer.clear();\n+\n+        \/\/ Change the second mapping\n+        prefs.update(Map.of(\"baz\", \"qux2\"));\n+        assertEquals(1, observer.getCallsNumber());\n+        observer.assertRemoved(0, tup(\"baz\", \"qux\"));\n+        observer.assertAdded(0, tup(\"baz\", \"qux2\"));\n+        observer.clear();\n+\n+        \/\/ If no mapping was changed, no change notification is fired\n+        prefs.update(Map.of(\"foo\", \"bar2\", \"baz\", \"qux2\"));\n+        observer.check0();\n+        observer.clear();\n+\n+        \/\/ If a key is mapped to null, the mapping is removed\n+        prefs.update(new HashMap<>() {{ put(\"foo\", null); }});\n+        assertEquals(1, observer.getCallsNumber());\n+        observer.assertRemoved(0, tup(\"foo\", \"bar2\"));\n+        observer.clear();\n+    }\n+\n+    @Test\n+    void testColorPropertyChangesAreAtomicWhenMapIsObserved() {\n+        var trace = new ArrayList<Color[]>();\n+\n+        prefs.addListener((MapChangeListener<? super String, ? super Object>) change ->\n+            trace.add(new Color[] {prefs.getForegroundColor(), prefs.getBackgroundColor(), prefs.getAccentColor()}));\n+\n+        testColorPropertyChangesAreAtomic(trace, 3);\n+    }\n+\n+    @Test\n+    void testColorPropertyChangesAreAtomicWhenColorPropertiesAreObserved() {\n+        var trace = new ArrayList<Color[]>();\n+\n+        InvalidationListener listener = observable -> trace.add(\n+            new Color[] { prefs.getForegroundColor(), prefs.getBackgroundColor(), prefs.getAccentColor() });\n+        prefs.foregroundColorProperty().addListener(listener);\n+        prefs.backgroundColorProperty().addListener(listener);\n+        prefs.accentColorProperty().addListener(listener);\n+\n+        testColorPropertyChangesAreAtomic(trace, 3);\n+    }\n+\n+    @Test\n+    void testColorPropertyChangesAreAtomicWhenColorSchemePropertyIsObserved() {\n+        var trace = new ArrayList<Color[]>();\n+\n+        prefs.colorSchemeProperty().addListener((observable, oldValue, newValue) -> trace.add(\n+            new Color[] { prefs.getForegroundColor(), prefs.getBackgroundColor(), prefs.getAccentColor() }));\n+\n+        testColorPropertyChangesAreAtomic(trace, 1);\n+    }\n+\n+    \/**\n+     * Asserts that color properties are never observed in a transient state: change notifications\n+     * are only received after all properties have been set to their new values.\n+     *\/\n+    private void testColorPropertyChangesAreAtomic(List<Color[]> trace, int listenerInvocations) {\n+        Color[] expectedColors;\n+        int i = 0;\n+\n+        prefs.update(Map.of(\n+            \"test.foregroundColor\", Color.RED,\n+            \"test.backgroundColor\", Color.GREEN,\n+            \"test.accentColor\", Color.BLUE));\n+        assertEquals(listenerInvocations, trace.size());\n+        expectedColors = new Color[] { Color.RED, Color.GREEN, Color.BLUE };\n+        while (i < listenerInvocations) {\n+            assertArrayEquals(expectedColors, trace.get(i++));\n+        }\n+\n+        prefs.update(Map.of(\n+            \"test.foregroundColor\", Color.BLUE,\n+            \"test.backgroundColor\", Color.YELLOW,\n+            \"test.accentColor\", Color.PURPLE));\n+        assertEquals(listenerInvocations * 2, trace.size());\n+        expectedColors = new Color[] { Color.BLUE, Color.YELLOW, Color.PURPLE };\n+        while (i < listenerInvocations * 2) {\n+            assertArrayEquals(expectedColors, trace.get(i++));\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/application\/preferences\/PlatformPreferencesTest.java","additions":330,"deletions":0,"binary":false,"changes":330,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.beans.InvalidationListener;\n+import javafx.geometry.Insets;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.VBox;\n+import javafx.stage.Stage;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n+\n+public class PlatformPreferencesChangedTest extends Application {\n+\n+    private Map<String, Object> cachedPreferences;\n+\n+    @Override\n+    public void start(Stage stage) {\n+        var passButton = new Button(\"Pass\");\n+        passButton.setOnAction(e -> Platform.exit());\n+\n+        var failButton = new Button(\"Fail\");\n+        failButton.setOnAction(e -> {\n+            Platform.exit();\n+            throw new AssertionError(\"Platform preferences were not correctly reported\");\n+        });\n+\n+        var textArea = new TextArea();\n+        textArea.setEditable(false);\n+\n+        var clearButton = new Button(\"Clear Log\");\n+        clearButton.setOnAction(e -> textArea.setText(\"\"));\n+\n+        var box = new VBox();\n+        box.setSpacing(20);\n+        box.getChildren().add(new VBox(10,\n+            new VBox(\n+                new Label(\"1. On a supported platform, change any of the platform preferences.\"),\n+                new Label(\"    See javafx.application.Platform.Preferences for a list of supported platforms.\")),\n+            new Label(\"2. Observe whether the changed preferences are reported in the log below.\"),\n+            new Label(\"3. Click \\\"Pass\\\" if the changes were correctly reported, otherwise click \\\"Fail\\\".\"),\n+            new HBox(5, passButton, failButton, clearButton)\n+        ));\n+\n+        var root = new BorderPane();\n+        root.setPadding(new Insets(20));\n+        root.setTop(box);\n+        root.setCenter(textArea);\n+        BorderPane.setMargin(textArea, new Insets(20, 0, 0, 0));\n+\n+        cachedPreferences = new HashMap<>(Platform.getPreferences());\n+        textArea.setText(\"preferences = \" + formatPrefs(cachedPreferences.entrySet()));\n+\n+        Platform.getPreferences().addListener(\n+            (InvalidationListener)observable -> {\n+                Set<Map.Entry<String, Object>> changed = Platform.getPreferences().entrySet().stream()\n+                        .filter(entry -> !Objects.equals(entry.getValue(), cachedPreferences.get(entry.getKey())))\n+                        .collect(Collectors.toSet());\n+\n+                double scrollTop = textArea.getScrollTop();\n+                textArea.setText(textArea.getText() + \"changed = \" + formatPrefs(changed));\n+                textArea.setScrollTop(scrollTop);\n+\n+                cachedPreferences = new HashMap<>(Platform.getPreferences());\n+            });\n+\n+        stage.setScene(new Scene(root));\n+        stage.show();\n+    }\n+\n+    public static void main(String[] args) {\n+        Application.launch(args);\n+    }\n+\n+    private static String formatPrefs(Set<Map.Entry<String, Object>> prefs) {\n+        String entries = prefs.stream()\n+                .sorted(Map.Entry.comparingByKey())\n+                .map(entry -> {\n+                    if (entry.getValue() instanceof Object[] array) {\n+                        return entry.getKey() + \"=\" + Arrays.toString(array);\n+                    }\n+                    return entry.getKey() + \"=\" + entry.getValue();\n+                })\n+                .collect(Collectors.joining(\"\\r\\n\\t\"));\n+\n+        return \"{\\r\\n\\t\" + entries + \"\\r\\n}\\r\\n\";\n+    }\n+}\n","filename":"tests\/manual\/events\/PlatformPreferencesChangedTest.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"}]}