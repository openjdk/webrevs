{"files":[{"patch":"@@ -35,1 +35,2 @@\n-import javafx.scene.paint.Paint;\n+import java.io.Serializable;\n+import java.lang.reflect.Modifier;\n@@ -150,1 +151,5 @@\n-        if (!platformType.isAssignableFrom(type)) {\n+        \/\/ Check whether the declared platform type is convertible to the requested type.\n+        \/\/ This check validates that a casting conversion exists at all, even if we don't have a\n+        \/\/ value that we would need in order to use Class.isInstance to check if the conversion\n+        \/\/ succeeds at runtime.\n+        if (!isConvertible(platformType, type)) {\n@@ -160,4 +165,6 @@\n-        if (type.isInstance(value)) {\n-            @SuppressWarnings(\"unchecked\")\n-            T v = (T)value;\n-            return Optional.of(v);\n+        \/\/ The runtime type of the value might be a subtype of the platform type, which necessitates\n+        \/\/ checking whether the actual type is convertible to the requested type.\n+        if (!type.isInstance(value)) {\n+            throw new IllegalArgumentException(\n+                \"Incompatible types: requested = \" + type.getName() +\n+                \", actual = \" + value.getClass().getName());\n@@ -166,3 +173,3 @@\n-        throw new IllegalArgumentException(\n-            \"Incompatible types: requested = \" + type.getName() +\n-            \", actual = \" + value.getClass().getName());\n+        @SuppressWarnings(\"unchecked\")\n+        T v = (T)value;\n+        return Optional.of(v);\n@@ -171,0 +178,1 @@\n+\n@@ -284,0 +292,88 @@\n+\n+    \/**\n+     * Determines whether a compile-time casting conversion exists from {@code source} to {@code target}.\n+     * This is an implementation of JLS 5.5.1 (Reference Type Casting).\n+     *\n+     * @param source the source type\n+     * @param target the target type\n+     * @return {@code true} if a casting conversion exists, {@code false} otherwise\n+     *\/\n+    private boolean isConvertible(Class<?> source, Class<?> target) {\n+        if (source.isArray()) {\n+            return isArrayConvertible(source, target);\n+        }\n+\n+        if (source.isInterface()) {\n+            return isInterfaceConvertible(source, target);\n+        }\n+\n+        return isClassConvertible(source, target);\n+    }\n+\n+    \/\/ Assuming S is a class type:\n+    private boolean isClassConvertible(Class<?> S, Class<?> T) {\n+        \/\/ If T is an interface type:\n+        \/\/   1. If S is final, then S must implement T.\n+        \/\/   2. If S is not final, the cast is always legal (because even if S does not\n+        \/\/      implement T, a subclass of S might).\n+        if (T.isInterface()) {\n+            return !Modifier.isFinal(S.getModifiers()) || S.isAssignableFrom(T);\n+        }\n+\n+        \/\/ If T is an array type, then S must be the class Object.\n+        if (T.isArray()) {\n+            return S == Object.class;\n+        }\n+\n+        \/\/ If T is a class type, then either S<:T, or T<:S.\n+        return S.isAssignableFrom(T) || T.isAssignableFrom(S);\n+    }\n+\n+    \/\/ Assuming S is an interface type:\n+    private boolean isInterfaceConvertible(Class<?> S, Class<?> T) {\n+        \/\/ If T is an array type, then S must be the type Serializable or Cloneable.\n+        if (T.isArray()) {\n+            return S == Serializable.class || S == Cloneable.class;\n+        }\n+\n+        \/\/ If T is not final, the cast is always legal (because even if S does not\n+        \/\/ implement T, a subclass of S might).\n+        if (!Modifier.isFinal(T.getModifiers())) {\n+            return true;\n+        }\n+\n+        \/\/ If T is a class type that is final, then T must implement S.\n+        return S.isAssignableFrom(T);\n+    }\n+\n+    \/\/ Assuming S is an array type SC[], that is, an array of components of type SC:\n+    private boolean isArrayConvertible(Class<?> S, Class<?> T) {\n+        \/\/ If T is an interface type, then it must be the type Serializable or Cloneable,\n+        \/\/ which are the only interfaces implemented by arrays.\n+        if (T.isInterface()) {\n+            return T == Serializable.class || T == Cloneable.class;\n+        }\n+\n+        \/\/ If T is an array type TC[], that is, an array of components of type TC,\n+        \/\/ then one of the following must be true:\n+        \/\/   1. TC and SC are the same primitive type\n+        \/\/   2. TC and SC are reference types and type SC can undergo casting conversion to TC\n+        if (T.isArray()) {\n+            Class<?> SC = S.getComponentType();\n+            Class<?> TC = T.getComponentType();\n+\n+            if (SC.isPrimitive() && TC.isPrimitive()) {\n+                return SC == TC;\n+            }\n+\n+            if (!SC.isPrimitive() && !TC.isPrimitive()) {\n+                return isConvertible(SC, TC);\n+            }\n+\n+            return false;\n+        }\n+\n+        \/\/ If T is a class type, then if T must be Object because Object is the only\n+        \/\/ class type to which arrays can be assigned.\n+        return T == Object.class;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/application\/preferences\/PlatformPreferences.java","additions":105,"deletions":9,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import javafx.animation.Interpolatable;\n@@ -36,0 +37,1 @@\n+import java.io.Serializable;\n@@ -61,1 +63,2 @@\n-                \"test.aPaint\", Paint.class\n+                \"test.aPaint\", Paint.class,\n+                \"test.aPaintArray\", Paint[].class\n@@ -98,0 +101,2 @@\n+        assertEquals(Color.RED, prefs.getValue(\"test.aPaint\", Object.class).orElseThrow());\n+        assertEquals(Color.RED, prefs.getValue(\"test.aPaint\", Interpolatable.class).orElseThrow());\n@@ -104,0 +109,1 @@\n+        assertEquals(gradient, prefs.getValue(\"test.aPaint\", Object.class).orElseThrow());\n@@ -107,0 +113,15 @@\n+    @Test\n+    void testPolymorphicArrayValues() {\n+        var colors = new Color[] {Color.RED, Color.GREEN, Color.BLUE};\n+        prefs.update(Map.of(\"test.aPaintArray\", colors));\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Object[].class).orElseThrow());\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Color[].class).orElseThrow());\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Paint[].class).orElseThrow());\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Interpolatable[].class).orElseThrow());\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Object.class).orElseThrow());\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Cloneable.class).orElseThrow());\n+        assertSame(colors, prefs.getValue(\"test.aPaintArray\", Serializable.class).orElseThrow());\n+        assertThrows(IllegalArgumentException.class, () -> prefs.getValue(\"test.aPaintArray\", Paint.class));\n+        assertThrows(IllegalArgumentException.class, () -> prefs.getValue(\"test.aPaintArray\", LinearGradient[].class));\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/application\/preferences\/PlatformPreferencesTest.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"}]}