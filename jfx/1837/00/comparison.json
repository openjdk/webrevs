{"files":[{"patch":"@@ -486,0 +486,2 @@\n+            [GlassApplication registerKeyEvent:theEvent];\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassView3D.m","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -41,0 +42,1 @@\n+import javafx.scene.input.KeyCombination;\n@@ -533,4 +535,3 @@\n-     * KeyCharacterCombinations should really work on the numeric keypad but\n-     * currently don't on Windows and Linux. The tests can exclude combinations\n-     * entirely, exclude just the numeric keypad, or cover both the main\n-     * keyboard and the keypad.\n+     * A test run can exclude KeyCharacterCombinations entirely, process only\n+     * those on the main keyboard (excluding the numeric keypad), or cover\n+     * the entire layout.\n@@ -626,2 +627,0 @@\n-            log.clear();\n-\n@@ -811,0 +810,99 @@\n+    \/\/ Here we try to find one case where a shortcut references a symbol that\n+    \/\/ is normally generated using Shift. In particular we're testing whether\n+    \/\/ Cmd + \"+\" works as expected on the US English layout on the Mac. The\n+    \/\/ OS special-cases this combination and so does JavaFX. In any case\n+    \/\/ Shortcut + \"+\" is a very common shortcut and deserves a test.\n+    private void testShiftedShortcut(Layout layout, Node focusNode, Logging log) {\n+        KeyData testCase = null;\n+\n+        \/\/ Find a test case, favoring \"+\".\n+        for (KeyData d : layout.getKeys()) {\n+            if (!d.code.isKeypadKey()) {\n+                if (d.comboChar == \"+\") {\n+                    testCase = d;\n+                    break;\n+                }\n+                else if (d.comboChar == \">\") {\n+                    testCase = d;\n+                }\n+            }\n+        }\n+\n+        if (testCase != null) {\n+            final var data = testCase;\n+\n+            focusNode.requestFocus();\n+\n+            Object eventLoop = new Object();\n+            Object success = new Object();\n+            Object nomatch = new Object();\n+            Object timeout = new Object();\n+\n+            var modifierKeyCode = onMac ? KeyCode.COMMAND : KeyCode.CONTROL;\n+            var acceleratorKeyCode = data.code;\n+            var combination = new KeyCharacterCombination(data.comboChar, KeyCombination.SHORTCUT_DOWN);\n+\n+            var testResult = new AtomicReference<Object>(nomatch);\n+\n+            \/\/ We will send two key press events, one for the modifier and the\n+            \/\/ second for the accelerator.\n+\n+            \/\/ If we never see the modifier released something has gone wrong.\n+            var timeoutTask = new TimerTask() {\n+                @Override\n+                public void run() {\n+                    Platform.runLater(() -> {\n+                        Platform.exitNestedEventLoop(eventLoop, timeout);\n+                    });\n+                }\n+            };\n+\n+            \/\/ Here we test if the character key press matches our combination.\n+            final EventHandler<KeyEvent> pressedHandler = (e -> {\n+                if (e.getCode() == acceleratorKeyCode) {\n+                    if (combination.match(e)) {\n+                        testResult.set(success);\n+                    }\n+                }\n+            });\n+\n+            \/\/ The test is over when the modifier is released.\n+            final EventHandler<KeyEvent> releasedHandler = (e -> {\n+                if (e.getCode() == modifierKeyCode) {\n+                    timeoutTask.cancel();\n+                    Platform.runLater(() -> {\n+                        Platform.exitNestedEventLoop(eventLoop, testResult.get());\n+                    });\n+                }\n+            });\n+\n+            focusNode.addEventFilter(KeyEvent.KEY_PRESSED, pressedHandler);\n+            focusNode.addEventFilter(KeyEvent.KEY_RELEASED, releasedHandler);\n+\n+            final var timer = new Timer();\n+            timer.schedule(timeoutTask, 100);\n+\n+            final Robot robot = new Robot();\n+            robot.keyPress(modifierKeyCode);\n+            robot.keyPress(acceleratorKeyCode);\n+            robot.keyRelease(acceleratorKeyCode);\n+            robot.keyRelease(modifierKeyCode);\n+\n+            \/\/ Wait for the final event to arrive or the timout to fire\n+            Object result = Platform.enterNestedEventLoop(eventLoop);\n+\n+            focusNode.removeEventFilter(KeyEvent.KEY_PRESSED, pressedHandler);\n+            focusNode.removeEventFilter(KeyEvent.KEY_RELEASED, releasedHandler);\n+\n+            timeoutTask.cancel();\n+            timer.cancel();\n+\n+            if (result.equals(nomatch)) {\n+                log.addLine(\"Failed: Shortcut + \" + data.comboChar + \" did not match event\");\n+            }\n+            else if (result.equals(timeout)) {\n+                log.addLine(\"Failed: Timeout waiting for shortcut test to finish\");\n+            }\n+        }\n+    }\n+\n@@ -841,1 +939,1 @@\n-        combinationChoice.setValue(CombinationScope.NONE);\n+        combinationChoice.setValue(CombinationScope.ALL);\n@@ -846,0 +944,1 @@\n+            logger.clear();\n@@ -848,0 +947,6 @@\n+            \/\/ Some platforms learn the layout as events are received. We\n+            \/\/ perform this test first before the system learns the layout\n+            \/\/ from all the events the TestRunner throws at it.\n+            if (comboScope != CombinationScope.NONE) {\n+                testShiftedShortcut(layout, logArea, logger);\n+            }\n","filename":"tests\/manual\/events\/KeyboardTest.java","additions":112,"deletions":7,"binary":false,"changes":119,"status":"modified"}]}