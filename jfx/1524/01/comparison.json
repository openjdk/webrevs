{"files":[{"patch":"@@ -2810,0 +2810,175 @@\n+project(\":incubator.input\") {\n+    project.ext.buildModule = true\n+    project.ext.includeSources = true\n+    project.ext.moduleRuntime = true\n+    project.ext.moduleName = \"jfx.incubator.input\"\n+    project.ext.incubating = true\n+\n+    sourceSets {\n+        main\n+        shims {\n+            java {\n+                compileClasspath += sourceSets.main.output\n+                runtimeClasspath += sourceSets.main.output\n+            }\n+        }\n+        test {\n+            java {\n+                compileClasspath += sourceSets.shims.output\n+                runtimeClasspath += sourceSets.shims.output\n+            }\n+        }\n+    }\n+\n+    project.ext.moduleSourcePath = defaultModuleSourcePath\n+    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim\n+\n+    commonModuleSetup(project, [\n+        'base',\n+        'graphics',\n+        'controls',\n+        'incubator.input'\n+    ])\n+\n+    dependencies {\n+        testImplementation project(\":base\").sourceSets.test.output\n+        testImplementation project(\":graphics\").sourceSets.test.output\n+        testImplementation project(\":controls\").sourceSets.test.output\n+        implementation project(':base')\n+        implementation project(':graphics')\n+        implementation project(':controls')\n+    }\n+\n+    test {\n+        jvmArgs \"-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit\"\n+    }\n+\n+    def modulePath = \"${project.sourceSets.main.java.getDestinationDirectory().get().getAsFile()}\"\n+    modulePath += File.pathSeparator + \"${rootProject.projectDir}\/modules\/javafx.controls\/build\/classes\/java\/main\"\n+    modulePath += File.pathSeparator + \"${rootProject.projectDir}\/modules\/javafx.graphics\/build\/classes\/java\/main\"\n+    modulePath += File.pathSeparator + \"${rootProject.projectDir}\/modules\/javafx.base\/build\/classes\/java\/main\"\n+\n+    \/\/ FIXME: KCR\n+\/\/    processResources {\n+\/\/      doLast {\n+\/\/        def cssFiles = fileTree(dir: \"$moduleDir\/com\/sun\/javafx\/scene\/control\/skin\")\n+\/\/        cssFiles.include \"**\/*.css\"\n+\/\/        cssFiles.each { css ->\n+\/\/            logger.info(\"converting CSS to BSS ${css}\");\n+\/\/\n+\/\/            javaexec {\n+\/\/                executable = JAVA\n+\/\/                workingDir = project.projectDir\n+\/\/                jvmArgs += patchModuleArgs\n+\/\/                jvmArgs += \"--module-path=$modulePath\"\n+\/\/                jvmArgs += \"--add-modules=javafx.graphics\"\n+\/\/                mainClass = \"com.sun.javafx.css.parser.Css2Bin\"\n+\/\/                args css\n+\/\/            }\n+\/\/        }\n+\/\/      }\n+\/\/    }\n+\/\/\n+\/\/    def copyShimBssTask = project.task(\"copyShimBss\", type: Copy,\n+\/\/                            dependsOn: [project.tasks.getByName(\"compileJava\"),\n+\/\/                                        project.tasks.getByName(\"processResources\")]) {\n+\/\/        from project.moduleDir\n+\/\/        into project.moduleShimsDir\n+\/\/        include \"**\/*.bss\"\n+\/\/    }\n+\/\/    processShimsResources.dependsOn(copyShimBssTask)\n+\n+    addMavenPublication(project, [ 'graphics' , 'controls'])\n+\n+    addValidateSourceSets(project, sourceSets)\n+}\n+\n+project(\":incubator.richtext\") {\n+    project.ext.buildModule = true\n+    project.ext.includeSources = true\n+    project.ext.moduleRuntime = true\n+    project.ext.moduleName = \"jfx.incubator.richtext\"\n+    project.ext.incubating = true\n+\n+    sourceSets {\n+        main\n+        shims {\n+            java {\n+                compileClasspath += sourceSets.main.output\n+                runtimeClasspath += sourceSets.main.output\n+            }\n+        }\n+        test {\n+            java {\n+                compileClasspath += sourceSets.shims.output\n+                runtimeClasspath += sourceSets.shims.output\n+            }\n+        }\n+    }\n+\n+    project.ext.moduleSourcePath = defaultModuleSourcePath\n+    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim\n+\n+    commonModuleSetup(project, [\n+        'base',\n+        'graphics',\n+        'controls',\n+        'incubator.input',\n+        'incubator.richtext'\n+    ])\n+\n+    dependencies {\n+        testImplementation project(\":base\").sourceSets.test.output\n+        testImplementation project(\":graphics\").sourceSets.test.output\n+        testImplementation project(\":controls\").sourceSets.test.output\n+        testImplementation project(\":incubator.input\").sourceSets.test.output\n+        implementation project(':base')\n+        implementation project(':graphics')\n+        implementation project(':controls')\n+        implementation project(':incubator.input')\n+    }\n+\n+    test {\n+        jvmArgs \"-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit\"\n+    }\n+\n+    def modulePath = \"${project.sourceSets.main.java.getDestinationDirectory().get().getAsFile()}\"\n+    modulePath += File.pathSeparator + \"${rootProject.projectDir}\/modules\/javafx.controls\/build\/classes\/java\/main\"\n+    modulePath += File.pathSeparator + \"${rootProject.projectDir}\/modules\/javafx.graphics\/build\/classes\/java\/main\"\n+    modulePath += File.pathSeparator + \"${rootProject.projectDir}\/modules\/javafx.base\/build\/classes\/java\/main\"\n+\n+    \/\/ FIXME: KCR\n+\/\/    processResources {\n+\/\/      doLast {\n+\/\/        def cssFiles = fileTree(dir: \"$moduleDir\/com\/sun\/javafx\/scene\/control\/skin\")\n+\/\/        cssFiles.include \"**\/*.css\"\n+\/\/        cssFiles.each { css ->\n+\/\/            logger.info(\"converting CSS to BSS ${css}\");\n+\/\/\n+\/\/            javaexec {\n+\/\/                executable = JAVA\n+\/\/                workingDir = project.projectDir\n+\/\/                jvmArgs += patchModuleArgs\n+\/\/                jvmArgs += \"--module-path=$modulePath\"\n+\/\/                jvmArgs += \"--add-modules=javafx.graphics\"\n+\/\/                mainClass = \"com.sun.javafx.css.parser.Css2Bin\"\n+\/\/                args css\n+\/\/            }\n+\/\/        }\n+\/\/      }\n+\/\/    }\n+\/\/\n+\/\/    def copyShimBssTask = project.task(\"copyShimBss\", type: Copy,\n+\/\/                            dependsOn: [project.tasks.getByName(\"compileJava\"),\n+\/\/                                        project.tasks.getByName(\"processResources\")]) {\n+\/\/        from project.moduleDir\n+\/\/        into project.moduleShimsDir\n+\/\/        include \"**\/*.bss\"\n+\/\/    }\n+\/\/    processShimsResources.dependsOn(copyShimBssTask)\n+\n+    addMavenPublication(project, [ 'graphics' , 'controls'])\n+\n+    addValidateSourceSets(project, sourceSets)\n+}\n+\n@@ -3926,1 +4101,11 @@\n-    def dependentProjects = [ 'base', 'graphics', 'controls', 'media', 'web', 'swing', 'fxml' ]\n+    def dependentProjects = [\n+        'base',\n+        'graphics',\n+        'controls',\n+        'incubator.input',\n+        'incubator.richtext',\n+        'media',\n+        'web',\n+        'swing',\n+        'fxml'\n+    ]\n@@ -4366,1 +4551,4 @@\n-            project(\":base\"), project(\":graphics\"), project(\":controls\"), project(\":media\"),\n+            project(\":base\"), project(\":graphics\"), project(\":controls\"),\n+            project(\":incubator.input\"),\n+            project(\":incubator.richtext\"),\n+            project(\":media\"),\n@@ -5690,0 +5878,1 @@\n+                        def incubating = project.hasProperty(\"incubating\") && project.ext.incubating\n@@ -5701,10 +5890,12 @@\n-                        String themod = dir.toURI()\n-                        testJavaPolicyFile <<  \"grant codeBase \\\"${themod}\\\" {\\n\" +\n-                        \"    permission java.security.AllPermission;\\n\" +\n-                        \"};\\n\"\n-\n-                        dir = new File(rootProject.buildDir, \"sdk\/lib\/${project.ext.moduleName}.jar\")\n-                        themod = dir.toURI()\n-                        runJavaPolicyFile <<  \"grant codeBase \\\"${themod}\\\" {\\n\" +\n-                        \"    permission java.security.AllPermission;\\n\" +\n-                        \"};\\n\"\n+                        if (!incubating) {\n+                            String themod = dir.toURI()\n+                            testJavaPolicyFile <<  \"grant codeBase \\\"${themod}\\\" {\\n\" +\n+                            \"    permission java.security.AllPermission;\\n\" +\n+                            \"};\\n\"\n+\n+                            dir = new File(rootProject.buildDir, \"sdk\/lib\/${project.ext.moduleName}.jar\")\n+                            themod = dir.toURI()\n+                            runJavaPolicyFile <<  \"grant codeBase \\\"${themod}\\\" {\\n\" +\n+                            \"    permission java.security.AllPermission;\\n\" +\n+                            \"};\\n\"\n+                        }\n@@ -5756,0 +5947,2 @@\n+            def incubating = project.hasProperty(\"incubating\") && project.ext.incubating\n+\n@@ -5797,0 +5990,4 @@\n+                        if (incubating) {\n+                            args(\"--do-not-resolve-by-default\")\n+                            args(\"--warn-if-resolved=incubating\")\n+                        }\n","filename":"build.gradle","additions":209,"deletions":12,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+# RichTextArea Behavior\n+\n+## Function Tags\n+\n+|Function Tag              |Description                                                                  |\n+|:-------------------------|:----------------------------------------------------------------------------|\n+|BACKSPACE                 |Deletes the symbol before the caret\n+|COPY                      |Copies selected text to the clipboard\n+|CUT                       |Cuts selected text and places it to the clipboard\n+|DELETE                    |Deletes the symbol at the caret\n+|DELETE_PARAGRAPH          |Deletes paragraph at the caret, or selected paragraphs\n+|DELETE_PARAGRAPH_START    |Deletes text from the caret to paragraph start, ignoring selection\n+|DELETE_WORD_NEXT_END      |Deletes empty paragraph or text to the end of the next word\n+|DELETE_WORD_NEXT_START    |Deletes empty paragraph or text to the start of the next word\n+|DELETE_WORD_PREVIOUS      |Deletes (multiple) empty paragraphs or text to the beginning of the previous word\n+|DESELECT                  |Clears any existing selection by moving anchor to the caret position\n+|FOCUS_NEXT                |Transfer focus to the next focusable node\n+|FOCUS_PREVIOUS            |Transfer focus to the previous focusable node\n+|INSERT_LINE_BREAK         |Inserts a line break at the caret\n+|INSERT_TAB                |Inserts a tab symbol at the caret (editable), or transfer focus to the next focusable node\n+|MOVE_DOWN                 |Moves the caret one visual line down\n+|MOVE_LEFT                 |Moves the caret one symbol to the left\n+|MOVE_PARAGRAPH_DOWN       |Moves the caret to the end of the current paragraph, or, if already there, to the end of the next paragraph\n+|MOVE_PARAGRAPH_UP         |Moves the caret to the start of the current paragraph, or, if already there, to the start of the previous paragraph\n+|MOVE_RIGHT                |Moves the caret one symbol to the right\n+|MOVE_TO_DOCUMENT_END      |Moves the caret to after the last character of the text\n+|MOVE_TO_DOCUMENT_START    |Moves the caret to before the first character of the text\n+|MOVE_TO_PARAGRAPH_END     |Moves the caret to the end of the paragraph at caret\n+|MOVE_TO_PARAGRAPH_START   |Moves the caret to the beginning of the paragraph at caret\n+|MOVE_UP                   |Moves the caret one visual text line up\n+|MOVE_WORD_LEFT            |Moves the caret one word left (previous word if LTR, next word if RTL)\n+|MOVE_WORD_NEXT_END        |Moves the caret to the end of the next word\n+|MOVE_WORD_NEXT_START      |Moves the caret to the start of the next word, or next paragraph if at the start of an empty paragraph\n+|MOVE_WORD_PREVIOUS        |Moves the caret to the beginning of previous word\n+|MOVE_WORD_RIGHT           |Moves the caret one word right (next word if LTR, previous word if RTL)\n+|PAGE_DOWN                 |Moves the caret one visual page down\n+|PAGE_UP                   |Moves the caret one visual page up\n+|PASTE                     |Pastes the clipboard content\n+|PASTE_PLAIN_TEXT          |Pastes the plain text clipboard content\n+|REDO                      |If possible, redoes the last undone modification\n+|SELECT_ALL                |Selects all text in the document\n+|SELECT_DOWN               |Extends selection one visual text line down\n+|SELECT_LEFT               |Extends selection one symbol to the left\n+|SELECT_PAGE_DOWN          |Extends selection one visible page down\n+|SELECT_PAGE_UP            |Extends selection one visible page up\n+|SELECT_PARAGRAPH          |Selects the current paragraph\n+|SELECT_PARAGRAPH_DOWN     |Extends selection to the end of the current paragraph, or, if already there, to the end of the next paragraph\n+|SELECT_PARAGRAPH_END      |Extends selection to the paragraph end\n+|SELECT_PARAGRAPH_START    |Extends selection to the paragraph start\n+|SELECT_PARAGRAPH_UP       |Extends selection to the start of the current paragraph, or, if already there, to the start of the previous paragraph\n+|SELECT_RIGHT              |Extends selection one symbol to the right\n+|SELECT_TO_DOCUMENT_END    |Extends selection to the end of the document\n+|SELECT_TO_DOCUMENT_START  |Extends selection to the start of the document\n+|SELECT_UP                 |Extends selection one visual text line up\n+|SELECT_WORD               |Selects a word at the caret position\n+|SELECT_WORD_LEFT          |Extends selection to the previous word (LTR) or next word (RTL)\n+|SELECT_WORD_NEXT          |Extends selection to the beginning of next word\n+|SELECT_WORD_NEXT_END      |Extends selection to the end of next word\n+|SELECT_WORD_PREVIOUS      |Extends selection to the previous word\n+|SELECT_WORD_RIGHT         |Extends selection to the next word (LTR) or previous word (RTL)\n+|UNDO                      |If possible, undoes the last modification\n+\n+\n+\n+## Key Bindings\n+\n+|Key Combination       |Platform   |Tag                       |Notes             |\n+|:---------------------|:----------|:-------------------------|:-----------------|\n+|shortcut-A            |           |SELECT_ALL                |\n+|ctrl-BACK_SLASH       |linux, win |DESELECT                  |\n+|BACKSPACE             |           |BACKSPACE                 |7\n+|ctrl-BACKSPACE        |linux, win |DELETE_WORD_NEXT_START    |\n+|option-BACKSPACE      |mac        |DELETE_WORD_NEXT_START    |7\n+|shift-BACKSPACE       |           |BACKSPACE                 |7\n+|shortcut-BACKSPACE    |mac        |DELETE_PARAGRAPH_START    |7, mac only\n+|shortcut-C            |           |COPY                      |\n+|COPY                  |           |COPY                      |\n+|CUT                   |           |CUT                       |\n+|shortcut-D            |           |DELETE_PARAGRAPH          |\n+|DELETE                |           |DELETE                    |8\n+|option-DELETE         |mac        |DELETE_WORD_NEXT_END      |8, option-fn-delete\n+|ctrl-DELETE           |linux, win |DELETE_WORD_NEXT_START    |\n+|DOWN                  |           |MOVE_DOWN                 |\n+|ctrl-DOWN             |linux, win |MOVE_PARAGRAPH_DOWN       |\n+|ctrl-shift-DOWN       |linux, win |SELECT_PARAGRAPH_DOWN     |\n+|option-DOWN           |mac        |MOVE_PARAGRAPH_DOWN       |\n+|option-shift-DOWN     |mac        |SELECT_PARAGRAPH_DOWN     |\n+|shift-DOWN            |           |SELECT_DOWN               |\n+|shift-shortcut-DOWN   |mac        |SELECT_TO_DOCUMENT_END    |\n+|shortcut-DOWN         |mac        |MOVE_TO_DOCUMENT_END      |\n+|END                   |           |MOVE_TO_PARAGRAPH_END     |4\n+|ctrl-END              |linux, win |MOVE_TO_DOCUMENT_END      |\n+|ctrl-shift-END        |linux, win |SELECT_TO_DOCUMENT_END    |\n+|shift-END             |linux, win |SELECT_PARAGRAPH_END      |\n+|ENTER                 |           |INSERT_LINE_BREAK         |\n+|ctrl-H                |linux, win |BACKSPACE                 |\n+|HOME                  |           |MOVE_TO_PARAGRAPH_START   |3\n+|ctrl-HOME             |linux, win |MOVE_TO_DOCUMENT_START    |\n+|ctrl-shift-HOME       |linux, win |SELECT_TO_DOCUMENT_START  |\n+|shift-HOME            |linux, win |SELECT_PARAGRAPH_START    |\n+|LEFT                  |           |MOVE_LEFT                 |\n+|ctrl-LEFT             |linux, win |MOVE_WORD_LEFT            |\n+|ctrl-shift-LEFT       |linux, win |SELECT_WORD_LEFT          |\n+|option-LEFT           |mac        |MOVE_WORD_LEFT            |\n+|option-shift-LEFT     |mac        |SELECT_WORD_LEFT          |\n+|shift-LEFT            |           |SELECT_LEFT               |\n+|shift-shortcut-LEFT   |mac        |SELECT_PARAGRAPH_START    |\n+|shortcut-LEFT         |mac        |MOVE_TO_PARAGRAPH_START   |\n+|PAGE_DOWN             |           |PAGE_DOWN                 |6\n+|shift-PAGE_DOWN       |           |SELECT_PAGE_DOWN          |6\n+|PAGE_UP               |           |PAGE_UP                   |5\n+|shift-PAGE_UP         |           |SELECT_PAGE_UP            |5\n+|PASTE                 |           |PASTE                     |\n+|RIGHT                 |           |MOVE_RIGHT                |\n+|ctrl-RIGHT            |linux, win |MOVE_WORD_RIGHT           |\n+|ctrl-shift-RIGHT      |linux, win |SELECT_WORD_RIGHT         |\n+|option-RIGHT          |mac        |MOVE_WORD_RIGHT           |\n+|option-shift-RIGHT    |mac        |SELECT_WORD_RIGHT         |\n+|shift-RIGHT           |           |SELECT_RIGHT              |\n+|shift-shortcut-RIGHT  |mac        |SELECT_PARAGRAPH_END      |\n+|shortcut-RIGHT        |mac        |MOVE_TO_PARAGRAPH_END     |\n+|TAB                   |           |TAB                       |\n+|alt-ctrl-shift-TAB    |linux, win |FOCUS_NEXT                |\n+|ctrl-TAB              |           |FOCUS_NEXT                |\n+|ctrl-shift-TAB        |           |FOCUS_PREVIOUS            |\n+|ctrl-option-shift-TAB |mac        |FOCUS_NEXT                |\n+|shift-TAB             |           |FOCUS_PREVIOUS            |\n+|UP                    |           |MOVE_UP                   |\n+|ctrl-UP               |linux, win |MOVE_PARAGRAPH_UP         |\n+|ctrl-shift-UP         |linux, win |SELECT_PARAGRAPH_UP       |\n+|option-UP             |mac        |MOVE_PARAGRAPH_UP         |\n+|option-shift-UP       |mac        |SELECT_PARAGRAPH_UP       |\n+|shift-UP              |           |SELECT_UP                 |\n+|shift-shortcut-UP     |           |SELECT_TO_DOCUMENT_START  |\n+|shortcut-UP           |mac        |MOVE_TO_DOCUMENT_START    |\n+|shortcut-V            |           |PASTE                     |\n+|shift-shortcut-V      |           |PASTE_PLAIN_TEXT          |\n+|shortcut-X            |           |CUT                       |\n+|ctrl-Y                |win        |REDO                      |\n+|command-shift-Z       |mac        |REDO                      |\n+|ctrl-shift-Z          |linux      |REDO                      |\n+|shortcut-Z            |           |UNDO                      |\n+\n+\n+### Other Mappings\n+\n+The following functions currently have no mapping:\n+MOVE_WORD_NEXT_END, MOVE_WORD_NEXT_START, MOVE_WORD_PREVIOUS, SELECT_WORD_NEXT, SELECT_WORD_NEXT_END, SELECT_WORD_PREVIOUS\n+\n+The following functions are mapped to the mouse events:\n+SELECT_PARAGRAPH, SELECT_WORD\n+\n+\n+\n+### Notes:\n+\n+1. On macOS, `alt` is represented by the `option` key\n+2. On macOS, `shortcut` is represented by the `command` key\n+3. On macOS, Home = `command` left arrow key\n+4. On macOS, End = `command` right arrow key\n+5. On macOS, PgUp = `fn` + `up arrow` key\n+6. On macOS, PgDn = `fn` + `down arrow` key\n+7. On macOS, BACKSPACE = `delete` key\n+8. On macOS, DELETE = `fn` + `delete` key\n","filename":"doc-files\/behavior\/RichTextAreaBehavior.md","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.javafx;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+\/**\n+ * Module utilities.\n+ *\/\n+public class ModuleUtil {\n+\n+    private static final Set<Module> warnedModules = new HashSet<>();\n+    private static final Set<Package> warnedPackages = new HashSet<>();\n+\n+    private static final Module MODULE_JAVA_BASE = Module.class.getModule();\n+\n+    @SuppressWarnings(\"removal\")\n+    public static void incubatorWarning() {\n+        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n+            var stackWalker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+            var callerClass = stackWalker.walk(s ->\n+                s.dropWhile(f -> {\n+                    var clazz = f.getDeclaringClass();\n+                    return ModuleUtil.class.equals(clazz) || MODULE_JAVA_BASE.equals(clazz.getModule());\n+                })\n+                .map(StackWalker.StackFrame::getDeclaringClass)\n+                .findFirst()\n+                .orElseThrow(IllegalStateException::new));\n+            var callerModule = callerClass.getModule();\n+\n+            \/\/ If we are using incubating API from the unnamed module, issue\n+            \/\/ a warning one time for each package. This is not a supported\n+            \/\/ mode, but can happen if the module is placed on the classpath.\n+            if (!callerModule.isNamed()) {\n+                var callerPackage = callerClass.getPackage();\n+                if (!warnedPackages.contains(callerPackage)) {\n+                    System.err.println(\"WARNING: Using incubating API from an unnamed module: \" + callerPackage);\n+                    warnedPackages.add(callerPackage);\n+                }\n+                return null;\n+            }\n+\n+            \/\/ TODO: Check whether this module is jlinked into the runtime and\n+            \/\/ thus has already printed a warning.\n+            \/\/ Issue warning one time for this module\n+            if (!warnedModules.contains(callerModule)) {\n+                System.err.println(\"WARNING: Using incubator modules: \" + callerModule.getName());\n+                warnedModules.add(callerModule);\n+            }\n+\n+            return null;\n+        });\n+    }\n+\n+    \/\/ Prevent instantiation\n+    private ModuleUtil() {\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/ModuleUtil.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -50,0 +50,2 @@\n+        jfx.incubator.input,\n+        jfx.incubator.richtext,\n","filename":"modules\/javafx.base\/src\/main\/java\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3441,0 +3441,72 @@\n+\n+\/*******************************************************************************\n+ *                                                                             *\n+ * Rich Text Area                                                              *\n+ *                                                                             *\n+ ******************************************************************************\/\n+\n+.rich-text-area {\n+    -fx-text-fill: -fx-text-inner-color;\n+    -fx-highlight-fill: derive(-fx-control-inner-background,-20%);\n+    -fx-highlight-text-fill: -fx-text-inner-color;\n+    -fx-prompt-text-fill: derive(-fx-control-inner-background,-30%);\n+    -fx-background-color:\n+        linear-gradient(to bottom, derive(-fx-text-box-border, -10%), -fx-text-box-border),\n+        linear-gradient(from 0px 0px to 0px 5px, derive(-fx-control-inner-background, -9%), -fx-control-inner-background);\n+    -fx-background-insets: 0, 1;\n+    -fx-background-radius: 3, 2;\n+    -fx-cursor: text;\n+    -fx-padding: 0;\n+    -fx-content-padding: 4 8 4 8;\n+}\n+\n+.rich-text-area:disabled {\n+    -fx-opacity: 0.4;\n+}\n+\n+.rich-text-area:focused {\n+    -fx-highlight-fill: -fx-accent;\n+    -fx-highlight-text-fill: white;\n+    -fx-background-color:\n+        -fx-focus-color,\n+        -fx-control-inner-background,\n+        -fx-faint-focus-color,\n+        linear-gradient(from 0px 0px to 0px 5px, derive(-fx-control-inner-background, -9%), -fx-control-inner-background);\n+    -fx-background-insets: -0.2, 1, -1.4, 3;\n+    -fx-background-radius: 3, 2, 4, 0;\n+    -fx-prompt-text-fill: transparent;\n+}\n+\n+.rich-text-area .caret {\n+    -fx-stroke: black;\n+}\n+\n+.rich-text-area .caret-line {\n+    -fx-stroke: null;\n+    -fx-fill: derive(-fx-accent,115%);\n+}\n+\n+.rich-text-area .selection-highlight {\n+    -fx-stroke: null;\n+    -fx-fill: derive(-fx-accent,70%);\n+}\n+\n+.rich-text-area .left-side {\n+    -fx-background-color: rgba(127,127,127,0.1);\n+}\n+\n+.rich-text-area .right-side {\n+    -fx-background-color: rgba(127,127,127,0.1);\n+}\n+\n+.rich-text-area .line-number-decorator {\n+    -fx-font-family: Monospace;\n+    -fx-font-size: 90%;\n+    -fx-min-height:1;\n+    -fx-pref-height:1;\n+    -fx-padding: 0 1 0 1;\n+}\n+\n+.line-number-decorator .text {\n+    -fx-bounds-type: visual;\n+}\n","filename":"modules\/javafx.controls\/src\/main\/resources\/com\/sun\/javafx\/scene\/control\/skin\/modena\/modena.css","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -449,0 +449,10 @@\n+      <li><a href=\"#incubator-modules\">Incubator Modules<\/a>\n+        <ul>\n+          <li>jfx.incubator.scene.control.richtext\n+            <ul>\n+              <li><a href=\"#codearea\">CodeArea<\/a><\/li>\n+              <li><a href=\"#richtextarea\">RichTextArea<\/a><\/li>\n+            <\/ul>\n+          <\/li>\n+        <\/ul>\n+      <\/li>\n@@ -6375,0 +6385,185 @@\n+\n+    <!-- Incubator Modules -->\n+    <h2><a id=\"incubator-modules\">Incubator Modules<\/a><\/h2>\n+    <table class=\"package\" width=\"100%\">\n+      <tbody>\n+        <tr>\n+          <td>jfx.incubator.scene.control.richtext<\/td>\n+        <\/tr>\n+      <\/tbody>\n+    <\/table>\n+\n+    <h4><a id=\"richtextarea\">RichTextArea<\/a><\/h4>\n+    <p class=\"styleclass\">Style class: rich-text-area<\/p>\n+      <table class=\"csspropertytable\">\n+        <caption>Available CSS Properties<\/caption>\n+        <thead>\n+          <tr>\n+            <th class=\"propertyname\" scope=\"col\">CSS Property<\/th>\n+            <th class=\"value\" scope=\"col\">Values<\/th>\n+            <th scope=\"col\">Default<\/th>\n+            <th scope=\"col\">Comments<\/th>\n+          <\/tr>\n+        <\/thead>   \n+        <tbody>\n+          <tr>\n+            <th class=\"propertyname\" scope=\"row\">-fx-caret-blink-period<\/th>\n+            <td class=\"value\"><a href=\"#typeduration\" class=\"typelink\">&lt;duration&gt;<\/a><\/td>\n+            <td>1000 ms<\/td>\n+            <td>Determines the caret blink period.<\/td>\n+          <\/tr>\n+          <tr>\n+            <th class=\"propertyname\" scope=\"row\">-fx-content-padding<\/th>\n+\t\t\t<td class=\"value\"><a href=\"#typesize\" class=\"typelink\">&lt;size&gt;<\/a>\n+\t\t\t  | <a href=\"#typesize\" class=\"typelink\">&lt;size&gt;<\/a> <a href=\"#typesize\"\n+\t\t\t    class=\"typelink\">&lt;size&gt;<\/a>\n+\t\t\t  <a href=\"#typesize\" class=\"typelink\">&lt;size&gt;<\/a> <a href=\"#typesize\"\n+\t\t\t    class=\"typelink\">&lt;size&gt;<\/a>\n+\t\t\t<\/td>\n+            <td>0 0 0 0<\/td>\n+            <td>Amount of padding in the content area.<\/td>\n+          <\/tr>\n+          <tr>\n+            <th class=\"propertyname\" scope=\"row\">-fx-display-caret<\/th>\n+            <td class=\"value\"><a href=\"#typeboolean\" class=\"typelink\">&lt;boolean&gt;<\/a><\/td>\n+            <td>true<\/td>\n+            <td>Determines whether the caret is displayed.<\/td>\n+          <\/tr>\n+          <tr>\n+            <th class=\"propertyname\" scope=\"row\">-fx-highlight-current-paragraph<\/th>\n+            <td class=\"value\"><a href=\"#typeboolean\" class=\"typelink\">&lt;boolean&gt;<\/a><\/td>\n+            <td>false<\/td>\n+            <td>Determines whether the current paragraph is highlighted.<\/td>\n+          <\/tr>\n+          <tr>\n+            <th class=\"propertyname\" scope=\"row\">-fx-use-content-height<\/th>\n+            <td class=\"value\"><a href=\"#typeboolean\" class=\"typelink\">&lt;boolean&gt;<\/a><\/td>\n+            <td>false<\/td>\n+            <td>Determines whether the preferred height is the same as the content height.<\/td>\n+          <\/tr>\n+          <tr>\n+            <th class=\"propertyname\" scope=\"row\">-fx-use-content-width<\/th>\n+            <td class=\"value\"><a href=\"#typeboolean\" class=\"typelink\">&lt;boolean&gt;<\/a><\/td>\n+            <td>false<\/td>\n+            <td>Determines whether the preferred width is the same as the content width.<\/td>\n+          <\/tr>\n+          <tr>\n+            <th class=\"propertyname\" scope=\"row\">-fx-wrap-text<\/th>\n+            <td class=\"value\"><a href=\"#typeboolean\" class=\"typelink\">&lt;boolean&gt;<\/a><\/td>\n+            <td>false<\/td>\n+            <td>Determines whether text should be wrapped.<\/td>\n+          <\/tr>\n+          <tr>\n+           <th colspan=\"4\" class=\"parents\" scope=\"row\">Also has all properties of <a href=\"#control\">Control<\/a><\/th>\n+          <\/tr>\n+        <\/tbody>\n+      <\/table>\n+    <h4>Pseudo-classes<\/h4>\n+    <table class=\"csspropertytable\">\n+      <caption>Available CSS Pseudo-classes<\/caption>\n+      <thead>\n+        <tr>\n+        <th class=\"propertyname\" scope=\"col\">CSS Pseudo-class<\/th>\n+        <th scope=\"col\">Comments<\/th>\n+      <\/tr>\n+      <\/thead>\n+      <tbody>\n+        <!--\n+        <tr>\n+        <th class=\"propertyname\" scope=\"row\">horizontal<\/th>\n+            <td>applies if this Slider is horizontal<\/td>\n+        <\/tr>\n+        <tr>\n+        <th class=\"propertyname\" scope=\"row\">vertical<\/th>\n+            <td>applies if this Slider is vertical<\/td>\n+        <\/tr>\n+        -->\n+        <tr>\n+          <th colspan=\"2\" class=\"parents\" scope=\"row\">Also has all pseudo&#8209;classes of <a href=\"#control\">Control<\/a><\/th>\n+        <\/tr>\n+        <\/tbody>\n+    <\/table>\n+    <h4>Substructure<\/h4>\n+    <ul>\n+      <li>main-pane &mdash; Pane<\/li>\n+        <ul>\n+          <li>vflow &mdash; Pane<\/li>\n+          <ul>\n+            <li>content &mdash; Pane<\/li>\n+            <ul>\n+              <li>caret-line &mdash; Path<\/li>\n+              <li>selection-highlight &mdash; Path<\/li>\n+              <li>flow &mdash; Pane<\/li>\n+              <li>caret &mdash; Path<\/li>\n+            <\/ul>\n+            <li>left-side &mdash; Pane<\/li>\n+            <li>right-side &mdash; Pane<\/li>\n+          <\/ul>\n+          <li>scroll-bar:vertical &mdash; ScrollBar<\/li>\n+          <li>scroll-bar:horizontal &mdash; ScrollBar<\/li>\n+        <\/ul>\n+    <\/ul>\n+\n+    <h4><a id=\"codearea\">CodeArea<\/a><\/h4>\n+    <p>The CodeArea control has all the properties of <a href=\"#richtextarea\">RichTextArea<\/a><\/p>\n+    <p class=\"styleclass\">Style class: code-area<\/p>\n+      <table class=\"csspropertytable\">\n+        <caption>Available CSS Properties<\/caption>\n+        <thead>\n+          <tr>\n+            <th class=\"propertyname\" scope=\"col\">CSS Property<\/th>\n+            <th class=\"value\" scope=\"col\">Values<\/th>\n+            <th scope=\"col\">Default<\/th>\n+            <th scope=\"col\">Comments<\/th>\n+          <\/tr>\n+        <\/thead>   \n+        <tbody>\n+          <tr>\n+            <th class=\"propertyname\" scope=\"row\">-fx-font<\/th>\n+            <td class=\"value\"><a href=\"#typefont\" class=\"typelink\">&lt;font&gt;<\/a><\/td>\n+            <td>Monospaced 12px<\/td>\n+            <td>Determines the font to use for text.<\/td>\n+          <\/tr>\n+          <tr>\n+            <th class=\"propertyname\" scope=\"row\">-fx-line-spacing<\/th>\n+            <td class=\"value\"><a href=\"#typenumber\" class=\"typelink\">&lt;number&gt;<\/a><\/td>\n+            <td>0<\/td>\n+            <td>&nbsp;<\/td>\n+          <\/tr>\n+          <tr>\n+            <th class=\"propertyname\" scope=\"row\">-fx-tab-size<\/th>\n+            <td class=\"value\"><a href=\"#typenumber\" class=\"typelink\">&lt;integer&gt;<\/a><\/td>\n+            <td>8<\/td>\n+            <td>&nbsp;<\/td>\n+          <\/tr>\n+          <tr>\n+           <th colspan=\"4\" class=\"parents\" scope=\"row\">Also has all properties of <a href=\"#richtextarea\">RichTextArea<\/a><\/th>\n+          <\/tr>\n+        <\/tbody>\n+      <\/table>\n+    <h4>Pseudo-classes<\/h4>\n+    <table class=\"csspropertytable\">\n+      <caption>Available CSS Pseudo-classes<\/caption>\n+      <thead>\n+        <tr>\n+        <th class=\"propertyname\" scope=\"col\">CSS Pseudo-class<\/th>\n+        <th scope=\"col\">Comments<\/th>\n+      <\/tr>\n+      <\/thead>\n+      <tbody>\n+        <!--\n+        <tr>\n+        <th class=\"propertyname\" scope=\"row\">horizontal<\/th>\n+            <td>applies if this Slider is horizontal<\/td>\n+        <\/tr>\n+        <tr>\n+        <th class=\"propertyname\" scope=\"row\">vertical<\/th>\n+            <td>applies if this Slider is vertical<\/td>\n+        <\/tr>\n+        -->\n+        <tr>\n+          <th colspan=\"2\" class=\"parents\" scope=\"row\">Also has all pseudo&#8209;classes of <a href=\"#richtextarea\">RichTextArea<\/a><\/th>\n+        <\/tr>\n+        <\/tbody>\n+    <\/table>\n+\n","filename":"modules\/javafx.graphics\/src\/main\/docs\/javafx\/scene\/doc-files\/cssref.html","additions":195,"deletions":0,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene.text;\n+\n+import javafx.scene.text.TextFlow;\n+import com.sun.javafx.util.Utils;\n+\n+\/**\n+ * Used to access internal methods of TextFlow.\n+ *\/\n+public class TextFlowHelper {\n+    public interface Accessor {\n+        public TextLayout getTextLayout(TextFlow f);\n+    }\n+\n+    private static Accessor accessor;\n+\n+    static {\n+        Utils.forceInit(TextFlow.class);\n+    }\n+\n+    public static void setAccessor(Accessor a) {\n+        if (accessor != null) {\n+            throw new IllegalStateException();\n+        }\n+\n+        accessor = a;\n+    }\n+\n+    public static TextLayout getTextLayout(TextFlow f) {\n+        return accessor.getTextLayout(f);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/text\/TextFlowHelper.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import javafx.beans.property.IntegerProperty;\n@@ -33,0 +34,8 @@\n+import javafx.css.CssMetaData;\n+import javafx.css.Styleable;\n+import javafx.css.StyleableDoubleProperty;\n+import javafx.css.StyleableIntegerProperty;\n+import javafx.css.StyleableObjectProperty;\n+import javafx.css.StyleableProperty;\n+import javafx.css.converter.EnumConverter;\n+import javafx.css.converter.SizeConverter;\n@@ -43,5 +52,0 @@\n-import javafx.css.StyleableDoubleProperty;\n-import javafx.css.StyleableObjectProperty;\n-import javafx.css.CssMetaData;\n-import javafx.css.converter.EnumConverter;\n-import javafx.css.converter.SizeConverter;\n@@ -52,0 +56,1 @@\n+import com.sun.javafx.scene.text.TextFlowHelper;\n@@ -56,4 +61,0 @@\n-import javafx.beans.property.IntegerProperty;\n-import javafx.css.Styleable;\n-import javafx.css.StyleableIntegerProperty;\n-import javafx.css.StyleableProperty;\n@@ -160,0 +161,1 @@\n+    static { initAccessor(); }\n@@ -690,0 +692,9 @@\n+\n+    private static void initAccessor() {\n+        TextFlowHelper.setAccessor(new TextFlowHelper.Accessor() {\n+            @Override\n+            public TextLayout getTextLayout(TextFlow f) {\n+                return f.getTextLayout();\n+            }\n+        });\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/TextFlow.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,0 +105,2 @@\n+        jfx.incubator.input,\n+        jfx.incubator.richtext,\n@@ -117,0 +119,1 @@\n+        jfx.incubator.richtext,\n@@ -120,0 +123,2 @@\n+        jfx.incubator.input,\n+        jfx.incubator.richtext,\n@@ -138,0 +143,2 @@\n+        jfx.incubator.input,\n+        jfx.incubator.richtext,\n","filename":"modules\/javafx.graphics\/src\/main\/java\/module-info.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<classpath>\n+\t<classpathentry kind=\"src\" path=\"src\/main\/java\"\/>\n+\t<classpathentry kind=\"src\" path=\"src\/main\/resources\"\/>\n+\t<classpathentry kind=\"src\" output=\"testbin\" path=\"src\/shims\/java\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"test\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"src\" output=\"testbin\" path=\"src\/test\/java\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"test\" value=\"true\"\/>\n+\t\t\t<attribute name=\"optional\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"src\" output=\"testbin\" path=\"src\/test\/resources\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"test\" value=\"true\"\/>\n+\t\t\t<attribute name=\"optional\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"src\" path=\"\/controls\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"src\" path=\"\/graphics\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/base\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/swing\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.junit.JUNIT_CONTAINER\/5\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"test\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"output\" path=\"bin\"\/>\n+<\/classpath>\n","filename":"modules\/jfx.incubator.input\/.classpath","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<projectDescription>\n+\t<name>incubator.input<\/name>\n+\t<comment><\/comment>\n+\t<projects>\n+\t<\/projects>\n+\t<buildSpec>\n+\t\t<buildCommand>\n+\t\t\t<name>org.eclipse.jdt.core.javabuilder<\/name>\n+\t\t\t<arguments>\n+\t\t\t<\/arguments>\n+\t\t<\/buildCommand>\n+\t<\/buildSpec>\n+\t<natures>\n+\t\t<nature>org.eclipse.jdt.core.javanature<\/nature>\n+\t<\/natures>\n+<\/projectDescription>\n","filename":"modules\/jfx.incubator.input\/.project","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"","filename":"modules\/jfx.incubator.input\/.settings\/org.eclipse.core.resources.prefs","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":".settings\/org.eclipse.core.resources.prefs","status":"copied"},{"patch":"@@ -0,0 +1,6 @@\n+# Incubator\n+\n+This project incubates\n+[InputMap](src\/main\/java\/javafx\/incubator\/scene\/control\/rich\/RichTextArea.java)\n+\n+Please refer to this [README](\/tests\/manual\/RichTextAreaDemo\/README.md).\n","filename":"modules\/jfx.incubator.input\/README.md","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.jfx.incubator.scene.control.input;\n+\n+import java.util.Set;\n+\n+\/**\n+ * Codifies priority of event handler invocation.\n+ *\/\n+public enum EventHandlerPriority {\n+    USER_HIGH(6000),\n+    USER_KB(5000),\n+    SKIN_KB(4000),\n+    SKIN_HIGH(3000),\n+    SKIN_LOW(2000),\n+    USER_LOW(1000);\n+\n+    \/** set of priorities associated with a {@code Skin} *\/\n+    public static final Set<EventHandlerPriority> ALL_SKIN = Set.of(\n+        SKIN_KB,\n+        SKIN_HIGH,\n+        SKIN_LOW\n+    );\n+\n+    final int priority;\n+\n+    private EventHandlerPriority(int priority) {\n+        this.priority = priority;\n+    }\n+}\n","filename":"modules\/jfx.incubator.input\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/input\/EventHandlerPriority.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.input;\n+\n+import com.sun.javafx.util.Utils;\n+import jfx.incubator.scene.control.input.FunctionTag;\n+import jfx.incubator.scene.control.input.InputMap;\n+\n+\/**\n+ * Hides execute() methods in InputMap from the public.\n+ *\/\n+public class InputMapHelper {\n+    public interface Accessor {\n+        public void execute(Object source, InputMap inputMap, FunctionTag tag);\n+        public void executeDefault(Object source, InputMap inputMap, FunctionTag tag);\n+    }\n+\n+    static {\n+        Utils.forceInit(InputMap.class);\n+    }\n+\n+    private static Accessor accessor;\n+\n+    public static void setAccessor(Accessor a) {\n+        if (accessor != null) {\n+            throw new IllegalStateException();\n+        }\n+        accessor = a;\n+    }\n+\n+    public static void execute(Object source, InputMap inputMap, FunctionTag tag) {\n+        accessor.execute(source, inputMap, tag);\n+    }\n+\n+    public static void executeDefault(Object source, InputMap inputMap, FunctionTag tag) {\n+        accessor.executeDefault(source, inputMap, tag);\n+    }\n+}\n","filename":"modules\/jfx.incubator.input\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/input\/InputMapHelper.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.jfx.incubator.scene.control.input;\n+\n+import javafx.event.EventType;\n+import javafx.scene.input.KeyEvent;\n+import jfx.incubator.scene.control.input.KeyBinding;\n+\n+\/**\n+ * Contains logic for mapping KeyBinding to a specific KeyEvent.\n+ *\/\n+public class KeyEventMapper {\n+    private static final int PRESSED = 0x01;\n+    private static final int RELEASED = 0x02;\n+    private static final int TYPED = 0x04;\n+\n+    private int types;\n+\n+    public KeyEventMapper() {\n+    }\n+\n+    public EventType<KeyEvent> addType(KeyBinding k) {\n+        if (k.isKeyPressed()) {\n+            types |= PRESSED;\n+            return KeyEvent.KEY_PRESSED;\n+        } else if (k.isKeyReleased()) {\n+            types |= RELEASED;\n+            return KeyEvent.KEY_RELEASED;\n+        } else {\n+            types |= TYPED;\n+            return KeyEvent.KEY_TYPED;\n+        }\n+    }\n+\n+    public boolean hasKeyPressed() {\n+        return (types & PRESSED) != 0;\n+    }\n+\n+    public boolean hasKeyReleased() {\n+        return (types & RELEASED) != 0;\n+    }\n+\n+    public boolean hasKeyTyped() {\n+        return (types & TYPED) != 0;\n+    }\n+}\n","filename":"modules\/jfx.incubator.input\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/input\/KeyEventMapper.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.jfx.incubator.scene.control.input;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+\n+\/**\n+ * Priority Handler List.\n+ * Arranges event handlers according to their EventHandlerPriority.\n+ *\/\n+public class PHList {\n+    \/**\n+     * {@code items} is a list of {@code EventHandler}s ordered from high priority to low,\n+     * with each block of same priority prefixed with the priority value.\n+     * Also, USER_KB and SKIN_KB require no handler pointer, so none is added.<p>\n+     * Example:\n+     * [ USER_HIGH, handler1, handler2, SKIN_KB, SKIN_LOW, handler3 ]\n+     *\/\n+    private final ArrayList<Object> items = new ArrayList(4);\n+\n+    public PHList() {\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"PHList\" + items;\n+    }\n+\n+    \/**\n+     * Adds an event handler under the given priority.\n+     * A newly added handler will be inserted after previously added handlers with the same priority.\n+     * @param priority the priority\n+     * @param handler the handler to add\n+     *\/\n+    public void add(EventHandlerPriority priority, EventHandler<?> handler) {\n+        \/\/ positive: simply insert the handler there\n+        \/\/ negative: insert priority and the handler if it's not null\n+        int ix = findInsertionIndex(priority);\n+        if (ix < 0) {\n+            ix = -ix - 1;\n+            insert(ix, priority);\n+            \/\/ do not store the null handler\n+            if (handler != null) {\n+                insert(++ix, handler);\n+            }\n+        } else {\n+            insert(ix, handler);\n+        }\n+    }\n+\n+    private void insert(int ix, Object item) {\n+        if (ix < items.size()) {\n+            items.add(ix, item);\n+        } else {\n+            items.add(item);\n+        }\n+    }\n+\n+    \/**\n+     * Removes all the instances of the specified handler.  Returns true if the list becomes empty as a result.\n+     * Returns true if the list becomes empty as a result of the removal.\n+     *\n+     * @param <T> the event type\n+     * @param handler the handler to remove\n+     * @return true when the list becomes empty as a result\n+     *\/\n+    public <T extends Event> boolean remove(EventHandler<T> handler) {\n+        for (int i = 0; i < items.size(); i++) {\n+            Object x = items.get(i);\n+            if (x == handler) {\n+                items.remove(i);\n+                if (isNullOrPriority(i) && isNullOrPriority(i - 1)) {\n+                    \/\/ remove priority\n+                    --i;\n+                    items.remove(i);\n+                }\n+            }\n+        }\n+        return items.size() == 0;\n+    }\n+\n+    private boolean isNullOrPriority(int ix) {\n+        if ((ix >= 0) && (ix < items.size())) {\n+            Object x = items.get(ix);\n+            return (x instanceof EventHandlerPriority);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns the index into {@code items}.\n+     * When the list contains no elements of the given priority, the return value is\n+     * negative, equals to {@code -(insertionIndex + 1)},\n+     * and the caller must insert the priority value in addition to the handler.\n+     *\n+     * @param priority the priority\n+     * @return the insertion index (positive), or -(insertionIndex + 1) (negative)\n+     *\/\n+    private int findInsertionIndex(EventHandlerPriority priority) {\n+        \/\/ don't expect many handlers, so linear search is ok\n+        int sz = items.size();\n+        boolean found = false;\n+        for (int i = 0; i < sz; i++) {\n+            Object x = items.get(i);\n+            if (x instanceof EventHandlerPriority p) {\n+                if (p.priority == priority.priority) {\n+                    found = true;\n+                    continue;\n+                } else if (p.priority < priority.priority) {\n+                    return found ? i : -(i + 1);\n+                }\n+            }\n+        }\n+        return found ? sz : -(sz + 1);\n+    }\n+\n+    \/**\n+     * A client interface for the {@link #forEach(Client)} method.\n+     * @param <T> the event type\n+     *\/\n+    @FunctionalInterface\n+    public static interface Client<T extends Event> {\n+        \/**\n+         * This method gets called for each handler in the order of priority.\n+         * The client may signal to stop iterating by returning false from this method.\n+         *\n+         * @param pri the priority\n+         * @param h the handler (can be null)\n+         * @return true to continue the process, false to stop\n+         *\/\n+        public boolean accept(EventHandlerPriority pri, EventHandler<T> h);\n+    }\n+\n+    \/**\n+     * Invokes the {@code client} for each handler in the order of priority.\n+     * @param <T> the event type\n+     * @param client the client reference\n+     *\/\n+    public <T extends Event> void forEach(Client<T> client) {\n+        EventHandlerPriority pri = null;\n+        boolean stop;\n+        int sz = items.size();\n+        for (int i = 0; i < sz; i++) {\n+            Object x = items.get(i);\n+            if (x instanceof EventHandlerPriority p) {\n+                pri = p;\n+                if (isNullOrPriority(i + 1)) {\n+                    stop = !client.accept(pri, null);\n+                } else {\n+                    continue;\n+                }\n+            } else {\n+                \/\/ it's a handler, cannot be null\n+                stop = !client.accept(pri, (EventHandler<T>)x);\n+            }\n+            if (stop) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Removes all the entries with the specified priorities.\n+     * @return true if list is empty as a result\n+     *\/\n+    public boolean removeHandlers(Set<EventHandlerPriority> priorities) {\n+        boolean remove = false;\n+        for (int i = 0; i < items.size();) {\n+            Object x = items.get(i);\n+            if (x instanceof EventHandlerPriority p) {\n+                if (priorities.contains(p)) {\n+                    remove = true;\n+                    items.remove(i);\n+                } else {\n+                    remove = false;\n+                    i++;\n+                }\n+            } else {\n+                if (remove) {\n+                    items.remove(i);\n+                } else {\n+                    i++;\n+                }\n+            }\n+        }\n+        return items.size() == 0;\n+    }\n+\n+    \/**\n+     * An internal testing method.\n+     * @param expected the expected internal structure\n+     *\/\n+    public void validateInternalState(Object... expected) {\n+        if (!Arrays.equals(expected, items.toArray())) {\n+            throw new RuntimeException(\"internal mismatch:\\nitems=\" + items + \"\\nexpected=\" + List.of(expected));\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.input\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/input\/PHList.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -0,0 +1,307 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jfx.incubator.scene.control.input;\n+\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.event.EventType;\n+import javafx.scene.control.Control;\n+import javafx.scene.input.KeyCode;\n+import com.sun.javafx.PlatformUtil;\n+import com.sun.javafx.scene.NodeHelper;\n+import com.sun.javafx.scene.traversal.Direction;\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n+\n+\/**\n+ * Class provides a convenient foundation for the stateful behaviors.\n+ * <p>\n+ * A concrete behavior implementation should do the following:\n+ * <ol>\n+ * <li> provide default behavior methods (one for each function tag)\n+ * <li> implement {@link #populateSkinInputMap()} method, in which map control's function tags to\n+ *      the behavior methods, map key bindings to the function tags, add additional event handlers, using\n+ *      {@link #registerFunction(FunctionTag, Runnable)},\n+ *      {@link #registerKey(KeyBinding, FunctionTag)},\n+ *      {@link #registerKey(KeyCode, FunctionTag)},\n+ *      and\n+ *      {@code addHandler()} methods correspondingly.\n+ * <li> in the corresponding skin's {code Skin.install()}, set the skin input map to the control's input map.\n+ * <\/ol>\n+ * Example (in the actual skin class):\n+ * <pre>{@code\n+ *     @Override\n+ *     public void install() {\n+ *         super.install();\n+ *         setSkinInputMap(behavior.getSkinInputMap());\n+ *   }\n+ * }<\/pre>\n+ *\n+ * @param <C> the type of the control\n+ * @since 999 TODO\n+ *\/\n+public abstract class BehaviorBase<C extends Control> {\n+    private final C control;\n+    private SkinInputMap.Stateful skinInputMap;\n+\n+    \/**\n+     * The constructor.\n+     * @param c the owner Control instance\n+     *\/\n+    public BehaviorBase(C c) {\n+        this.control = c;\n+    }\n+\n+    \/**\n+     * In this method, which is called by {@link javafx.scene.control.Skin#install()},\n+     * the child class populates the {@code SkinInputMap}\n+     * by registering key mappings and event handlers.\n+     * <p>\n+     * If a subclass overrides this method, it is important to call the superclass implementation.\n+     *\/\n+    protected abstract void populateSkinInputMap();\n+\n+    \/**\n+     * Returns the associated Control instance.\n+     * @return the owner\n+     *\/\n+    protected final C getControl() {\n+        return control;\n+    }\n+\n+    \/**\n+     * Returns the skin input map associated with this behavior.\n+     * @return the input map\n+     *\/\n+    public final SkinInputMap.Stateful getSkinInputMap() {\n+        if (skinInputMap == null) {\n+            this.skinInputMap = SkinInputMap.create();\n+            populateSkinInputMap();\n+        }\n+        return skinInputMap;\n+    }\n+\n+    \/**\n+     * Maps a function to the specified function tag.\n+     *\n+     * @param tag the function tag\n+     * @param function the function\n+     *\/\n+    protected final void registerFunction(FunctionTag tag, Runnable function) {\n+        getSkinInputMap().registerFunction(tag, function);\n+    }\n+\n+    \/**\n+     * Maps a key binding to the specified function tag.\n+     * A null key binding will result in no change to this input map.\n+     * This method will not override a user mapping.\n+     *\n+     * @param k the key binding\n+     * @param tag the function tag\n+     *\/\n+    protected final void registerKey(KeyBinding k, FunctionTag tag) {\n+        getSkinInputMap().registerKey(k, tag);\n+    }\n+\n+    \/**\n+     * Maps a key binding to the specified function tag.\n+     * This method will not override a user mapping added by {@link #registerKey(KeyBinding,FunctionTag)}.\n+     *\n+     * @param code the key code to construct a {@link KeyBinding}\n+     * @param tag the function tag\n+     *\/\n+    protected final void registerKey(KeyCode code, FunctionTag tag) {\n+        getSkinInputMap().registerKey(code, tag);\n+    }\n+\n+    \/**\n+     * This convenience method maps the function tag to the specified function, and at the same time\n+     * maps the specified key binding to that function tag.\n+     * @param tag the function tag\n+     * @param k the key binding\n+     * @param func the function\n+     *\/\n+    protected final void register(FunctionTag tag, KeyBinding k, Runnable func) {\n+        getSkinInputMap().registerFunction(tag, func);\n+        getSkinInputMap().registerKey(k, tag);\n+    }\n+\n+    \/**\n+     * This convenience method maps the function tag to the specified function, and at the same time\n+     * maps the specified key binding to that function tag.\n+     * @param tag the function tag\n+     * @param code the key code\n+     * @param func the function\n+     *\/\n+    protected final void register(FunctionTag tag, KeyCode code, Runnable func) {\n+        getSkinInputMap().registerFunction(tag, func);\n+        getSkinInputMap().registerKey(KeyBinding.of(code), tag);\n+    }\n+\n+    \/**\n+     * This convenience method registers a copy of the behavior-specific mappings from one key binding to another.\n+     * The method does nothing if no behavior specific mapping can be found.\n+     * @param existing the existing key binding\n+     * @param newk the new key binding\n+     *\/\n+    protected final void duplicateMapping(KeyBinding existing, KeyBinding newk) {\n+        getSkinInputMap().duplicateMapping(existing, newk);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specified event type, in the context of this Behavior.\n+     *\n+     * @param <T> the actual event type\n+     * @param type the event type\n+     * @param consume determines whether the matching event is consumed or not\n+     * @param handler the event handler\n+     *\/\n+    protected final <T extends Event> void addHandler(EventType<T> type, boolean consume, EventHandler<T> handler) {\n+        getSkinInputMap().addHandler(type, consume, handler);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specified event type, in the context of this Behavior.\n+     * This event handler will get invoked after all handlers added via map() methods.\n+     *\n+     * @param <T> the actual event type\n+     * @param type the event type\n+     * @param consume determines whether the matching event is consumed or not\n+     * @param handler the event handler\n+     *\/\n+    protected final <T extends Event> void addHandlerLast(EventType<T> type, boolean consume, EventHandler<T> handler) {\n+        getSkinInputMap().addHandler(type, consume, handler);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specific event criteria, in the context of this Behavior.\n+     * This is a more specific version of {@link #addHandler(EventType,boolean,EventHandler)} method.\n+     *\n+     * @param <T> the actual event type\n+     * @param criteria the matching criteria\n+     * @param consume determines whether the matching event is consumed or not\n+     * @param handler the event handler\n+     *\/\n+    protected final <T extends Event> void addHandler(EventCriteria<T> criteria, boolean consume, EventHandler<T> handler) {\n+        getSkinInputMap().addHandler(criteria, consume, handler);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specific event criteria, in the context of this Behavior.\n+     * This event handler will get invoked after all handlers added via map() methods.\n+     *\n+     * @param <T> the actual event type\n+     * @param criteria the matching criteria\n+     * @param consume determines whether the matching event is consumed or not\n+     * @param h the event handler\n+     *\/\n+    protected final <T extends Event> void addHandlerLast(EventCriteria<T> criteria, boolean consume, EventHandler<T> h) {\n+        getSkinInputMap().addHandler(criteria, consume, h);\n+    }\n+\n+    \/**\n+     * Returns true if this method is invoked on a Linux platform.\n+     * @return true on a Linux platform\n+     *\/\n+    protected final boolean isLinux() {\n+        return PlatformUtil.isLinux();\n+    }\n+\n+    \/**\n+     * Returns true if this method is invoked on a Mac OS platform.\n+     * @return true on a Mac OS platform\n+     *\/\n+    protected final boolean isMac() {\n+        return PlatformUtil.isMac();\n+    }\n+\n+    \/**\n+     * Returns true if this method is invoked on a Windows platform.\n+     * @return true on a Windows platform\n+     *\/\n+    protected final boolean isWindows() {\n+        return PlatformUtil.isWindows();\n+    }\n+\n+    \/**\n+     * Called by any of the BehaviorBase traverse methods to actually effect a\n+     * traversal of the focus. The default behavior of this method is to simply\n+     * traverse on the given node, passing the given direction. A\n+     * subclass may override this method.\n+     *\n+     * @param dir The direction to traverse\n+     *\/\n+    \/\/ NOTE: there should be a proper public focus management API\n+    private void traverse(Direction dir) {\n+        NodeHelper.traverse(control, dir, TraversalMethod.KEY);\n+    }\n+\n+    \/**\n+     * Calls the focus traversal engine and indicates that traversal should\n+     * go the next focusTraversable Node above the current one.\n+     *\/\n+    protected final void traverseUp() {\n+        traverse(Direction.UP);\n+    }\n+\n+    \/**\n+     * Calls the focus traversal engine and indicates that traversal should\n+     * go the next focusTraversable Node below the current one.\n+     *\/\n+    protected final void traverseDown() {\n+        traverse(Direction.DOWN);\n+    }\n+\n+    \/**\n+     * Calls the focus traversal engine and indicates that traversal should\n+     * go the next focusTraversable Node left of the current one.\n+     *\/\n+    protected final void traverseLeft() {\n+        traverse(Direction.LEFT);\n+    }\n+\n+    \/**\n+     * Calls the focus traversal engine and indicates that traversal should\n+     * go the next focusTraversable Node right of the current one.\n+     *\/\n+    protected final void traverseRight() {\n+        traverse(Direction.RIGHT);\n+    }\n+\n+    \/**\n+     * Calls the focus traversal engine and indicates that traversal should\n+     * go the next focusTraversable Node in the focus traversal cycle.\n+     *\/\n+    protected final void traverseNext() {\n+        traverse(Direction.NEXT);\n+    }\n+\n+    \/**\n+     * Calls the focus traversal engine and indicates that traversal should\n+     * go the previous focusTraversable Node in the focus traversal cycle.\n+     *\/\n+    protected final void traversePrevious() {\n+        traverse(Direction.PREVIOUS);\n+    }\n+}\n","filename":"modules\/jfx.incubator.input\/src\/main\/java\/jfx\/incubator\/scene\/control\/input\/BehaviorBase.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jfx.incubator.scene.control.input;\n+\n+import javafx.event.Event;\n+import javafx.event.EventType;\n+\n+\/**\n+ * Determines whether an event passes certain criteria.\n+ *\n+ * @param <T> the type of the event\n+ * @since 999 TODO\n+ *\/\n+public interface EventCriteria<T extends Event> {\n+    \/**\n+     * Returns the event type for which this criteria are valid.\n+     * @return the event type\n+     *\/\n+    public EventType<T> getEventType();\n+\n+    \/**\n+     * Returns true if the specified event matches this criteria.\n+     * @param ev the event\n+     * @return true if match occurs\n+     *\/\n+    public boolean isEventAcceptable(T ev);\n+}\n","filename":"modules\/jfx.incubator.input\/src\/main\/java\/jfx\/incubator\/scene\/control\/input\/EventCriteria.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jfx.incubator.scene.control.input;\n+\n+\/**\n+ * A functional interface which denotes code associated with a {@code FunctionTag} or a key binding.\n+ * This handler allows for controlling whether the matching event\n+ * will be consumed or not.\n+ *\n+ * @since 999 TODO\n+ *\/\n+@FunctionalInterface\n+public interface FunctionHandler {\n+    \/**\n+     * Handles the event associated with a function tag or a key binding.\n+     * @return true to consume the key event, false otherwise\n+     *\/\n+    public boolean handleFunction();\n+}\n","filename":"modules\/jfx.incubator.input\/src\/main\/java\/jfx\/incubator\/scene\/control\/input\/FunctionHandler.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.input;\n+\n+import com.sun.javafx.ModuleUtil;\n+\n+\/**\n+ * A function tag is a public identifier of a method that can be mapped to a key binding by the\n+ * control's {@link InputMap}.\n+ * <h2>Example<\/h2>\n+ * The following example is taken from the {@code TabPane} class:\n+ * <pre>    public class TabPane extends Control {\n+ *      \/\/ Identifiers for methods available for customization via the InputMap.\n+ *      public static final class Tag {\n+ *          \/\/ Selects the first tab.\n+ *          public static final FunctionTag SELECT_FIRST_TAB = new FunctionTag();\n+ *          \/\/ Selects the last tab.\n+ *          public static final FunctionTag SELECT_LAST_TAB = new FunctionTag();\n+ *          \/\/ Selects the left tab: previous in LTR mode, next in RTL mode.\n+ *          public static final FunctionTag SELECT_LEFT_TAB = new FunctionTag();\n+ *          ...\n+ * <\/pre>\n+ *\n+ * @since 999 TODO\n+ *\/\n+public final class FunctionTag {\n+    \/** Constructs the function tag. *\/\n+    public FunctionTag() {\n+    }\n+\n+    static { ModuleUtil.incubatorWarning(); }\n+}\n","filename":"modules\/jfx.incubator.input\/src\/main\/java\/jfx\/incubator\/scene\/control\/input\/FunctionTag.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,453 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jfx.incubator.scene.control.input;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.event.EventType;\n+import javafx.scene.control.Control;\n+import javafx.scene.control.Skinnable;\n+import javafx.scene.input.KeyEvent;\n+import com.sun.javafx.ModuleUtil;\n+import com.sun.jfx.incubator.scene.control.input.EventHandlerPriority;\n+import com.sun.jfx.incubator.scene.control.input.InputMapHelper;\n+import com.sun.jfx.incubator.scene.control.input.KeyEventMapper;\n+import com.sun.jfx.incubator.scene.control.input.PHList;\n+\n+\/**\n+ * InputMap is a property of the {@link Control} class which enables customization\n+ * by allowing for custom key mappings and event handlers.\n+ * <p>\n+ * The {@code InputMap} serves as an integration point between the Control and its Skin.\n+ * The {@code InputMap} The InputMap provides an ordered repository of event handlers,\n+ * working together with {@link SkinInputMap} supplied by the skin, which\n+ * guarantees the order in which handers are invoked.\n+ * It also stores key mappings with a similar guarantee that the application mappings\n+ * always take precedence over mappings created by the skin,\n+ * regardless of when the skin was created or replaced.\n+ * <p>\n+ * The class supports the following scenarios:\n+ * <ul>\n+ * <li>map a key binding to a function, provided either by the application or the skin\n+ * <li>un-map a key binding\n+ * <li>map a new function to an existing key binding\n+ * <li>obtain the default function\n+ * <li>add an event handler at specific priority (applies to application-defined and skin-defined handlers)\n+ * <li>ensure that the application key mappings take priority over mappings created by the skin\n+ * <\/ul>\n+ * For key mappings, the {@code InputMap} utilizes a two-stage lookup.\n+ * First, the key event is matched to a {@link FunctionTag} which identifies a function provided either by the skin\n+ * or the associated behavior (the \"default\" function), or by the application.\n+ * When such a mapping exists, the found function tag is matched to a function registered either by\n+ * the application or by the skin.\n+ * This mechanism allows for customizing the key mappings and the underlying functions independently and separately.\n+ *\n+ * @since 999 TODO\n+ *\/\n+public final class InputMap {\n+    private static final Object NULL = new Object();\n+    private final Control control;\n+    \/**\n+     * <pre> KeyBinding -> FunctionTag or Runnable\n+     * FunctionTag -> Runnable\n+     * EventType -> PHList<\/pre>\n+     *\/\n+    private final HashMap<Object, Object> map = new HashMap<>();\n+    private SkinInputMap skinInputMap;\n+    private final KeyEventMapper kmapper = new KeyEventMapper();\n+    private final EventHandler<Event> eventHandler = this::handleEvent;\n+\n+    static {\n+        ModuleUtil.incubatorWarning();\n+        initAccessor();\n+    }\n+\n+    \/**\n+     * The constructor.\n+     * @param control the owner control\n+     *\/\n+    public InputMap(Control control) {\n+        this.control = control;\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specified event type, at the control level.\n+     * This mapping always consumes the matching event.\n+     *\n+     * @param <T> the actual event type\n+     * @param type the event type\n+     * @param handler the event handler\n+     *\/\n+    public <T extends Event> void addHandler(EventType<T> type, EventHandler<T> handler) {\n+        extendHandler(type, handler, EventHandlerPriority.USER_HIGH);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specified event type, at the control level.\n+     * This event handler will get invoked after all handlers added via map() methods.\n+     * This mapping always consumes the matching event.\n+     *\n+     * @param <T> the actual event type\n+     * @param type the event type\n+     * @param handler the event handler\n+     *\/\n+    public <T extends Event> void addHandlerLast(EventType<T> type, EventHandler<T> handler) {\n+        extendHandler(type, handler, EventHandlerPriority.USER_LOW);\n+    }\n+\n+    \/**\n+     * Removes the specified handler.\n+     *\n+     * @param <T> the event class\n+     * @param type the event type\n+     * @param handler the handler to remove\n+     *\/\n+    public <T extends Event> void removeHandler(EventType<T> type, EventHandler<T> handler) {\n+        Object x = map.get(type);\n+        if (x instanceof PHList hs) {\n+            if (hs.remove(handler)) {\n+                map.remove(type);\n+                control.removeEventHandler(type, eventHandler);\n+            }\n+        }\n+    }\n+\n+    private <T extends Event> void removeHandler(EventType<T> type, EventHandlerPriority pri) {\n+        Object x = map.get(type);\n+        if (x instanceof PHList hs) {\n+            if (hs.removeHandlers(Set.of(pri))) {\n+                map.remove(type);\n+                control.removeEventHandler(type, eventHandler);\n+            }\n+        }\n+    }\n+\n+    private <T extends Event> void extendHandler(EventType<T> t, EventHandler<T> handler, EventHandlerPriority pri) {\n+        Object x = map.get(t);\n+        PHList hs;\n+        if (x instanceof PHList h) {\n+            hs = h;\n+        } else {\n+            \/\/ first entry for this event type\n+            hs = new PHList();\n+            map.put(t, hs);\n+            control.addEventHandler(t, eventHandler);\n+        }\n+\n+        hs.add(pri, handler);\n+    }\n+\n+    private void handleEvent(Event ev) {\n+        \/\/ probably unnecessary\n+        if (ev == null || ev.isConsumed()) {\n+            return;\n+        }\n+\n+        EventType<?> t = ev.getEventType();\n+        Object x = map.get(t);\n+        if (x instanceof PHList hs) {\n+            hs.forEach((pri, h) -> {\n+                if (h == null) {\n+                    handleKeyBindingEvent(ev);\n+                } else {\n+                    h.handle(ev);\n+                }\n+                return !ev.isConsumed();\n+            });\n+        }\n+    }\n+\n+    private void handleKeyBindingEvent(Event ev) {\n+        \/\/ probably unnecessary\n+        if (ev == null || ev.isConsumed()) {\n+            return;\n+        }\n+\n+        KeyBinding k = KeyBinding.from((KeyEvent)ev);\n+        if (k != null) {\n+            boolean consume = execute(ev.getSource(), k);\n+            if (consume) {\n+                ev.consume();\n+            }\n+        }\n+    }\n+\n+    private boolean execute(Object source, KeyBinding k) {\n+        Object x = resolve(k);\n+        if (x instanceof FunctionTag tag) {\n+            return execute(source, tag);\n+        } else if (x instanceof FunctionHandler h) {\n+            return h.handleFunction();\n+        } else if (x instanceof Runnable r) {\n+            r.run();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    \/\/ package protected to prevent unauthorized code to supply wrong instance of control (source)\n+    boolean execute(Object source, FunctionTag tag) {\n+        Object x = map.get(tag);\n+        if (x instanceof Runnable r) {\n+            r.run();\n+            return true;\n+        }\n+\n+        return executeDefault(source, tag);\n+    }\n+\n+    \/\/ package protected to prevent unauthorized code to supply wrong instance of control (source)\n+    boolean executeDefault(Object source, FunctionTag tag) {\n+        if (skinInputMap != null) {\n+            return skinInputMap.execute(source, tag);\n+        }\n+        return false;\n+    }\n+\n+    private Object resolve(KeyBinding k) {\n+        Object x = map.get(k);\n+        if (x != null) {\n+            return x;\n+        }\n+        if (skinInputMap != null) {\n+            return skinInputMap.resolve(k);\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Registers a function for the given key binding.  This mapping will  take precedence\n+     * over any such mapping set by the skin.\n+     *\n+     * @param k the key binding\n+     * @param function the function\n+     *\/\n+    public void register(KeyBinding k, Runnable function) {\n+        Objects.requireNonNull(k, \"key binding must not be null\");\n+        Objects.requireNonNull(function, \"function must not be null\");\n+        map.put(k, function);\n+    }\n+\n+    \/**\n+     * Adds (or overrides) a user-specified function under the given function tag.\n+     * This function will take precedence over any function set by the skin.\n+     *\n+     * @param tag the function tag\n+     * @param function the function\n+     *\/\n+    public void registerFunction(FunctionTag tag, Runnable function) {\n+        Objects.requireNonNull(tag, \"function tag must not be null\");\n+        Objects.requireNonNull(function, \"function must not be null\");\n+        map.put(tag, function);\n+    }\n+\n+    \/**\n+     * Link a key binding to the specified function tag.\n+     * When the key binding matches the input event, the function is executed, the event is consumed,\n+     * and the process of dispatching is stopped.\n+     * <p>\n+     * This method will take precedence over any function set by the skin.\n+     *\n+     * @param k the key binding\n+     * @param tag the function tag\n+     *\/\n+    public void registerKey(KeyBinding k, FunctionTag tag) {\n+        Objects.requireNonNull(k, \"KeyBinding must not be null\");\n+        Objects.requireNonNull(tag, \"function tag must not be null\");\n+        map.put(k, tag);\n+\n+        EventType<KeyEvent> t = kmapper.addType(k);\n+        extendHandler(t, null, EventHandlerPriority.USER_KB);\n+    }\n+\n+    \/**\n+     * Unbinds the specified key binding.\n+     *\n+     * @param k the key binding\n+     *\/\n+    public void unbind(KeyBinding k) {\n+        map.put(k, NULL);\n+    }\n+\n+    \/**\n+     * Reverts all the key bindings set by user.\n+     * This method restores key bindings set by the skin which were overwritten by the user.\n+     *\/\n+    public void resetKeyBindings() {\n+        Iterator<Map.Entry<Object, Object>> it = map.entrySet().iterator();\n+        while (it.hasNext()) {\n+            Map.Entry<Object, Object> me = it.next();\n+            if (me.getKey() instanceof KeyBinding) {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Restores the specified key binding to the value set by the behavior, if any.\n+     *\n+     * @param k the key binding\n+     *\/\n+    public void restoreDefaultKeyBinding(KeyBinding k) {\n+        Object x = map.get(k);\n+        if (x != null) {\n+            map.remove(k);\n+        }\n+    }\n+\n+    \/**\n+     * Restores the specified function tag to the value set by the behavior, if any.\n+     *\n+     * @param tag the function tag\n+     *\/\n+    public void restoreDefaultFunction(FunctionTag tag) {\n+        Objects.requireNonNull(tag, \"function tag must not be null\");\n+        map.remove(tag);\n+    }\n+\n+    \/**\n+     * Collects all mapped key bindings (set either by the user or the behavior).\n+     * @return the set of key bindings\n+     *\/\n+    public Set<KeyBinding> getKeyBindings() {\n+        return collectKeyBindings(null);\n+    }\n+\n+    \/**\n+     * Returns the set of key bindings mapped to the specified function tag.\n+     * @param tag the function tag\n+     * @return the set of KeyBindings, non-null\n+     *\/\n+    public Set<KeyBinding> getKeyBindingsFor(FunctionTag tag) {\n+        return collectKeyBindings(tag);\n+    }\n+\n+    \/\/ null tag collects all bindings\n+    private Set<KeyBinding> collectKeyBindings(FunctionTag tag) {\n+        HashSet<KeyBinding> bindings = new HashSet<>();\n+        for (Map.Entry<Object, Object> en : map.entrySet()) {\n+            if (en.getKey() instanceof KeyBinding k) {\n+                if ((tag == null) || (tag == en.getValue())) {\n+                    bindings.add(k);\n+                }\n+            }\n+        }\n+\n+        if (skinInputMap != null) {\n+            skinInputMap.collectKeyBindings(bindings, tag);\n+        }\n+        return bindings;\n+    }\n+\n+    \/**\n+     * Removes all the key bindings mapped to the specified function tag, either by the application or by the skin.\n+     * This is an irreversible operation.\n+     * @param tag the function tag\n+     *\/\n+    \/\/ TODO this should not affect the skin input map, but perhaps place NULL for each found KeyBinding\n+    public void unbind(FunctionTag tag) {\n+        if (skinInputMap != null) {\n+            skinInputMap.unbind(tag);\n+        }\n+        Iterator<Map.Entry<Object, Object>> it = map.entrySet().iterator();\n+        while (it.hasNext()) {\n+            Map.Entry<Object, Object> en = it.next();\n+            if (tag == en.getValue()) {\n+                \/\/ the entry must be KeyBinding -> FunctionTag\n+                if (en.getKey() instanceof KeyBinding) {\n+                    it.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Sets the skin input map, adding necessary event handlers to the control instance when required.\n+     * This method must be called by the skin only from its\n+     * {@link javafx.scene.control.Skin#install() Skin.install()}\n+     * method.\n+     * <p>\n+     * This method removes all the mappings from the previous skin input map, if any.\n+     * @param m the skin input map\n+     *\/\n+    public void setSkinInputMap(SkinInputMap m) {\n+        if (skinInputMap != null) {\n+            \/\/ uninstall all handlers with SKIN_* priority\n+            Iterator<Map.Entry<Object, Object>> it = map.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry<Object, Object> en = it.next();\n+                if (en.getKey() instanceof EventType t) {\n+                    PHList hs = (PHList)en.getValue();\n+                    if (hs.removeHandlers(EventHandlerPriority.ALL_SKIN)) {\n+                        it.remove();\n+                        control.removeEventHandler(t, eventHandler);\n+                    }\n+                }\n+            }\n+        }\n+\n+        skinInputMap = m;\n+\n+        if (skinInputMap != null) {\n+            \/\/ install skin handlers with their priority\n+            skinInputMap.forEach((type, pri, h) -> {\n+                extendHandler(type, h, pri);\n+            });\n+\n+            \/\/ add key bindings listeners if needed\n+            if (!kmapper.hasKeyPressed() && skinInputMap.kmapper.hasKeyPressed()) {\n+                extendHandler(KeyEvent.KEY_PRESSED, null, EventHandlerPriority.SKIN_KB);\n+            }\n+            if (!kmapper.hasKeyReleased() && skinInputMap.kmapper.hasKeyReleased()) {\n+                extendHandler(KeyEvent.KEY_RELEASED, null, EventHandlerPriority.SKIN_KB);\n+            }\n+            if (!kmapper.hasKeyTyped() && skinInputMap.kmapper.hasKeyTyped()) {\n+                extendHandler(KeyEvent.KEY_TYPED, null, EventHandlerPriority.SKIN_KB);\n+            }\n+        }\n+    }\n+\n+    private static void initAccessor() {\n+        InputMapHelper.setAccessor(new InputMapHelper.Accessor() {\n+            \/\/ will be unnecessary after JDK-8314968\n+            @Override\n+            public void executeDefault(Object source, InputMap inputMap, FunctionTag tag) {\n+                inputMap.executeDefault(source, tag);\n+            }\n+\n+            \/\/ will be unnecessary after JDK-8314968\n+            @Override\n+            public void execute(Object source, InputMap inputMap, FunctionTag tag) {\n+                inputMap.execute(source, tag);\n+            }\n+        });\n+    }\n+}\n","filename":"modules\/jfx.incubator.input\/src\/main\/java\/jfx\/incubator\/scene\/control\/input\/InputMap.java","additions":453,"deletions":0,"binary":false,"changes":453,"status":"added"},{"patch":"@@ -0,0 +1,753 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.input;\n+\n+import java.util.EnumSet;\n+import java.util.Objects;\n+import javafx.event.EventType;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyEvent;\n+import com.sun.javafx.PlatformUtil;\n+\n+\/**\n+ * Key binding provides a way to map key event to a hash table key for easy matching.\n+ *\n+ * @since 999 TODO\n+ *\/\n+public class KeyBinding implements EventCriteria<KeyEvent> {\n+    \/**\n+     * Condition used to build input key mappings.\n+     * <p>\n+     * The KCondition values are used as keys in a hash table, so when the platform sends a key event with multiple\n+     * modifiers, some modifiers are dropped in order to make the final key binding to function lookup unambiguous.\n+     * <p>\n+     * The mapping is as follows:\n+     * <pre>\n+     * KCondition    Mac         Windows\/Linux\n+     * ALT           OPTION      ALT\n+     * COMMAND       COMMAND     (ignored)\n+     * CTRL          CTRL        CTRL\n+     * META          COMMAND     META\n+     * OPTION        OPTION      (ignored)\n+     * SHIFT         SHIFT       SHIFT\n+     * SHORTCUT      COMMAND     CTRL\n+     * WINDOWS       (ignored)   META\n+     * <\/pre>\n+     *\/\n+    private enum KCondition {\n+        \/\/ modifier keys\n+        \/** ALT modifier, mapped to OPTION on Mac, ALT on Windows\/Linux *\/\n+        ALT,\n+        \/** COMMAND modifier, mapped to COMMAND on Mac only *\/\n+        COMMAND,\n+        \/** CTRL modifier *\/\n+        CTRL,\n+        \/** META modifier, mapped to COMMAND on Mac, META on Windows\/Linux *\/\n+        META,\n+        \/** OPTION modifier, mapped to OPTION on Mac only *\/\n+        OPTION,\n+        \/** SHIFT modifier *\/\n+        SHIFT,\n+        \/** SHORTCUT modifier, mapped to COMMAND on Mac, CTRL on Windows\/Linux *\/\n+        SHORTCUT,\n+        \/** Windows key modifier (⊞), mapped to WINDOWS on Windows only *\/\n+        WINDOWS,\n+\n+        \/\/ event types\n+        \/** a key pressed event *\/\n+        KEY_PRESSED,\n+        \/** a key released event *\/\n+        KEY_RELEASED,\n+        \/** a key typed event *\/\n+        KEY_TYPED,\n+    }\n+\n+    private final Object key; \/\/ KeyCode or String\n+    private final EnumSet<KCondition> modifiers;\n+\n+    private KeyBinding(Object key, EnumSet<KCondition> modifiers) {\n+        this.key = key;\n+        this.modifiers = modifiers;\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a key press.\n+     *\n+     * @param code the key code\n+     * @return the KeyBinding\n+     *\/\n+    public static KeyBinding of(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESSED);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a command-code key press.\n+     *\n+     * @param code the key code\n+     * @return the KeyBinding\n+     *\/\n+    public static KeyBinding command(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESSED, KCondition.COMMAND);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a alt-code key press.\n+     *\n+     * @param code the key code\n+     * @return the KeyBinding\n+     *\/\n+    public static KeyBinding alt(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESSED, KCondition.ALT);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a ctrl-code key press.\n+     *\n+     * @param code the key code\n+     * @return the KeyBinding\n+     *\/\n+    public static KeyBinding ctrl(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESSED, KCondition.CTRL);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a ctrl-shift-code key press.\n+     *\n+     * @param code the key code\n+     * @return the KeyBinding\n+     *\/\n+    public static KeyBinding ctrlShift(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESSED, KCondition.CTRL, KCondition.SHIFT);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to an option-code key press.\n+     *\n+     * @param code the key code\n+     * @return the KeyBinding\n+     *\/\n+    public static KeyBinding option(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESSED, KCondition.OPTION);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a shift-code key press.\n+     *\n+     * @param code the key code\n+     * @return the KeyBinding\n+     *\/\n+    public static KeyBinding shift(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESSED, KCondition.SHIFT);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a shortcut-code key press.\n+     *\n+     * @param code the key code\n+     * @return the KeyBinding\n+     *\/\n+    public static KeyBinding shortcut(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESSED, KCondition.SHORTCUT);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a shift-option-code key press.\n+     *\n+     * @param code the key code\n+     * @return the KeyBinding\n+     *\/\n+    public static KeyBinding shiftOption(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESSED, KCondition.SHIFT, KCondition.OPTION);\n+    }\n+\n+    \/**\n+     * Utility method creates a KeyBinding corresponding to a shift-shortcut-code key press.\n+     *\n+     * @param code the key code\n+     * @return the KeyBinding\n+     *\/\n+    public static KeyBinding shiftShortcut(KeyCode code) {\n+        return create(code, KCondition.KEY_PRESSED, KCondition.SHIFT, KCondition.SHORTCUT);\n+    }\n+\n+    private static KeyBinding create(Object key, KCondition... mods) {\n+        return new Builder(key).init(mods).build();\n+    }\n+\n+    \/**\n+     * Determines whether this key binding if for the key pressed event.\n+     * @return true if this key binding if for the key press event\n+     *\/\n+    public boolean isKeyPressed() {\n+        return modifiers.contains(KCondition.KEY_PRESSED);\n+    }\n+\n+    \/**\n+     * Determines whether this key binding if for the key released event.\n+     * @return true if this key binding if for the key release event\n+     *\/\n+    public boolean isKeyReleased() {\n+        return modifiers.contains(KCondition.KEY_RELEASED);\n+    }\n+\n+    \/**\n+     * Determines whether this key binding if for the key typed event.\n+     * @return true if this key binding if for the key typed event\n+     *\/\n+    public boolean isKeyTyped() {\n+        return modifiers.contains(KCondition.KEY_TYPED);\n+    }\n+\n+    \/**\n+     * Determines whether {@code shortcut} key is down in this key binding.\n+     * @return true if {@code shortcut} key is down in this key binding\n+     *\/\n+    public boolean isShortcut() {\n+        if (PlatformUtil.isMac()) {\n+            return modifiers.contains(KCondition.COMMAND);\n+        }\n+        return modifiers.contains(KCondition.CTRL);\n+    }\n+\n+    \/**\n+     * Determines whether {@code alt} key is down in this key binding.\n+     * @return true if {@code alt} key is down in this key binding\n+     *\/\n+    public boolean isAlt() {\n+        return modifiers.contains(KCondition.ALT);\n+    }\n+\n+    \/**\n+     * Determines whether {@code control} key is down in this key binding.\n+     * @return true if {@code control} key is down in this key binding\n+     *\/\n+    public boolean isCtrl() {\n+        return modifiers.contains(KCondition.CTRL);\n+    }\n+\n+    \/**\n+     * Determines whether {@code control} key is down in this key binding.\n+     * Applies to macOS platform only.\n+     * @return true if {@code control} key is down in this key binding\n+     *\/\n+    public boolean isCommand() {\n+        return modifiers.contains(KCondition.COMMAND);\n+    }\n+\n+    \/**\n+     * Determines whether {@code meta} key is down in this key binding.\n+     * @return true if {@code meta} key is down in this key binding\n+     *\/\n+    public boolean isMeta() {\n+        return modifiers.contains(KCondition.META);\n+    }\n+\n+    \/**\n+     * Determines whether {@code option} key is down in this key binding.\n+     * Applies to macOS only.\n+     * @return true if {@code option} key is down in this key binding\n+     *\/\n+    public boolean isOption() {\n+        return modifiers.contains(KCondition.OPTION);\n+    }\n+\n+    \/**\n+     * Determines whether {@code shift} key is down in this key binding.\n+     * @return true if {@code shift} key is down in this key binding\n+     *\/\n+    public boolean isShift() {\n+        return modifiers.contains(KCondition.SHIFT);\n+    }\n+\n+    \/**\n+     * Returns a {@link KeyCode} or null if the key binding is not for a key code.\n+     * @return key code\n+     *\/\n+    public KeyCode getKeyCode() {\n+        if (key instanceof KeyCode c) {\n+            return c;\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Creates a {@link Builder} with the specified KeyCode.\n+     * @param code the key code\n+     * @return the Builder instance\n+     *\/\n+    public static Builder builder(KeyCode code) {\n+        return new Builder(code);\n+    }\n+\n+    \/**\n+     * Creates a {@link Builder} with the specified KeyCode.\n+     * @param character the character\n+     * @return the Builder instance\n+     *\/\n+    public static Builder builder(String character) {\n+        return new Builder(character);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int h = KeyBinding.class.hashCode();\n+        h = 31 * h + key.hashCode();\n+        h = 31 * h + modifiers.hashCode();\n+        return h;\n+    }\n+\n+    @Override\n+    public boolean equals(Object x) {\n+        if (x == this) {\n+            return true;\n+        } else if (x instanceof KeyBinding k) {\n+            return\n+                Objects.equals(key, k.key) &&\n+                modifiers.equals(k.modifiers);\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Creates a Builder with a key pressed event.\n+     * @param c key code\n+     * @return Builder instance\n+     *\/\n+    public static Builder with(KeyCode c) {\n+        return builder(c);\n+    }\n+\n+    \/**\n+     * Creates a Builder with a key pressed event.\n+     * @param c character pressed\n+     * @return Builder instance\n+     *\/\n+    public static Builder with(String c) {\n+        return new Builder(c);\n+    }\n+\n+    \/**\n+     * Creates a KeyBinding from a KeyEvent, or a null if the event does not correspond to a valid KeyBinding.\n+     * @param ev the key event\n+     * @return the key binding, or null\n+     *\/\n+    static KeyBinding from(KeyEvent ev) {\n+        Object key;\n+        EnumSet<KCondition> m = EnumSet.noneOf(KCondition.class);\n+        EventType<KeyEvent> t = ev.getEventType();\n+        if(t == KeyEvent.KEY_PRESSED) {\n+            m.add(KCondition.KEY_PRESSED);\n+            key = ev.getCode();\n+        } else if(t == KeyEvent.KEY_RELEASED) {\n+            m.add(KCondition.KEY_RELEASED);\n+            key = ev.getCode();\n+        } else if(t == KeyEvent.KEY_TYPED) {\n+            m.add(KCondition.KEY_TYPED);\n+            key = ev.getCharacter();\n+        } else {\n+            return null;\n+        }\n+\n+        boolean alt = ev.isAltDown();\n+        boolean ctrl = ev.isControlDown();\n+        boolean meta = ev.isMetaDown();\n+        boolean shortcut = ev.isShortcutDown();\n+        boolean option = false;\n+        boolean command = false;\n+\n+        boolean mac = PlatformUtil.isMac();\n+        boolean win = PlatformUtil.isWindows();\n+\n+        \/\/ drop multiple modifiers, translating when necessary\n+\n+        if (mac) {\n+            if (alt) {\n+                alt = false;\n+                option = true;\n+            }\n+            if (shortcut) {\n+                meta = false;\n+                command = true;\n+            }\n+        } else {\n+            if (ctrl) {\n+                shortcut = false;\n+            }\n+        }\n+\n+        if (alt) {\n+            m.add(KCondition.ALT);\n+        }\n+\n+        if (command) {\n+            m.add(KCondition.COMMAND);\n+        }\n+\n+        if (ctrl) {\n+            m.add(KCondition.CTRL);\n+        }\n+\n+        if (meta) {\n+            m.add(KCondition.META);\n+        }\n+\n+        if (option) {\n+            m.add(KCondition.OPTION);\n+        }\n+\n+        if (ev.isShiftDown()) {\n+            m.add(KCondition.SHIFT);\n+        }\n+\n+        KeyBinding keyBinding = new KeyBinding(key, m);\n+        \/\/System.err.println(\"kb=\" + keyBinding + \" ev=\" + toString(ev)); \/\/ FIX\n+        return keyBinding;\n+    }\n+\n+    \/\/ FIX remove, debug\n+\/\/    private static String toString(KeyEvent ev) {\n+\/\/        StringBuilder sb = new StringBuilder(\"KeyEvent{\");\n+\/\/        sb.append(\"type=\").append(ev.getEventType());\n+\/\/        sb.append(\", char=\").append(ev.getCharacter());\n+\/\/\n+\/\/        String ch = ev.getCharacter();\n+\/\/        int sz = ch.length();\n+\/\/        if (sz > 0) {\n+\/\/            sb.append(\"(\");\n+\/\/            for (int i = 0; i < ch.length(); i++) {\n+\/\/                sb.append(String.format(\"%02X\", (int)ch.charAt(i)));\n+\/\/            }\n+\/\/            sb.append(\")\");\n+\/\/        }\n+\/\/\n+\/\/        sb.append(\", code=\").append(ev.getCode());\n+\/\/\n+\/\/        if (ev.isShiftDown()) {\n+\/\/            sb.append(\", shift\");\n+\/\/        }\n+\/\/        if (ev.isControlDown()) {\n+\/\/            sb.append(\", control\");\n+\/\/        }\n+\/\/        if (ev.isAltDown()) {\n+\/\/            sb.append(\", alt\");\n+\/\/        }\n+\/\/        if (ev.isMetaDown()) {\n+\/\/            sb.append(\", meta\");\n+\/\/        }\n+\/\/        if (ev.isShortcutDown()) {\n+\/\/            sb.append(\", shortcut\");\n+\/\/        }\n+\/\/\n+\/\/        return sb.append(\"}\").toString();\n+\/\/    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"KeyBinding{key=\");\n+        sb.append(key);\n+        sb.append(\", modifiers=\");\n+        sb.append(modifiers);\n+        sb.append(\"}\");\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Returns the event type for this key binding.\n+     * @return KeyEvent\n+     *\/\n+    @Override\n+    public EventType<KeyEvent> getEventType() {\n+        if (isKeyPressed()) {\n+            return KeyEvent.KEY_PRESSED;\n+        } else if (isKeyReleased()) {\n+            return KeyEvent.KEY_RELEASED;\n+        } else {\n+            return KeyEvent.KEY_TYPED;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isEventAcceptable(KeyEvent ev) {\n+        return equals(KeyBinding.from(ev));\n+    }\n+\n+    \/** Key bindings builder *\/\n+    public static class Builder {\n+        private final Object key; \/\/ KeyCode or String\n+        private final EnumSet<KCondition> m = EnumSet.noneOf(KCondition.class);\n+\n+        \/** Constructs a Builder *\/\n+        Builder(Object key) {\n+            this.key = key;\n+        }\n+\n+        \/**\n+         * Sets on KEY_RELEASED condition.\n+         * @return the Builder instance\n+         *\/\n+        public Builder onKeyReleased() {\n+            m.remove(KCondition.KEY_PRESSED);\n+            m.remove(KCondition.KEY_TYPED);\n+            m.add(KCondition.KEY_RELEASED);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets on KEY_TYPED condition.\n+         * @return the Builder instance\n+         *\/\n+        public Builder onKeyTyped() {\n+            m.remove(KCondition.KEY_PRESSED);\n+            m.add(KCondition.KEY_TYPED);\n+            m.remove(KCondition.KEY_RELEASED);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the {@code alt} key down condition (the {@code Option} key on macOS).\n+         * @return this Builder\n+         *\/\n+        public Builder alt() {\n+            m.add(KCondition.ALT);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the {@code alt} key down condition (the {@code Option} key on macOS).\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder alt(boolean on) {\n+            if (on) {\n+                m.add(KCondition.ALT);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code command} key down condition.\n+         * @return this Builder\n+         *\/\n+        public Builder command() {\n+            m.add(KCondition.COMMAND);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code command} key down condition.\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder command(boolean on) {\n+            if (on) {\n+                m.add(KCondition.COMMAND);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code control} key down condition.\n+         * @return this Builder\n+         *\/\n+        public Builder ctrl() {\n+            m.add(KCondition.CTRL);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code control} key down condition.\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder ctrl(boolean on) {\n+            if (on) {\n+                m.add(KCondition.CTRL);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code meta} key down condition.\n+         * @return this Builder\n+         *\/\n+        public Builder meta() {\n+            m.add(KCondition.META);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code meta} key down condition.\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder meta(boolean on) {\n+            if (on) {\n+                m.add(KCondition.META);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code option} key down condition.\n+         * @return this Builder\n+         *\/\n+        public Builder option() {\n+            m.add(KCondition.OPTION);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code option} key down condition.\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder option(boolean on) {\n+            if (on) {\n+                m.add(KCondition.OPTION);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code shift} key down condition.\n+         * @return this Builder\n+         *\/\n+        public Builder shift() {\n+            m.add(KCondition.SHIFT);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code shift} key down condition.\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder shift(boolean on) {\n+            if (on) {\n+                m.add(KCondition.SHIFT);\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code shortcut} key down condition.\n+         * @return this Builder\n+         *\/\n+        public Builder shortcut() {\n+            m.add(KCondition.SHORTCUT);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets {@code shortcut} key down condition.\n+         * @param on condition\n+         * @return this Builder\n+         *\/\n+        public Builder shortcut(boolean on) {\n+            if (on) {\n+                m.add(KCondition.SHORTCUT);\n+            }\n+            return this;\n+        }\n+\n+        private Builder init(KCondition... mods) {\n+            for (KCondition c : mods) {\n+                m.add(c);\n+            }\n+            return this;\n+        }\n+\n+        private void replace(KCondition c, KCondition replaceWith) {\n+            if (m.contains(c)) {\n+                m.remove(c);\n+                m.add(replaceWith);\n+            }\n+        }\n+\n+        \/**\n+         * Creates a new {@link KeyBinding} instance.\n+         * @return a new key binding instance.\n+         *\/\n+        public KeyBinding build() {\n+            boolean mac = PlatformUtil.isMac();\n+            boolean win = PlatformUtil.isWindows();\n+            boolean linux = PlatformUtil.isLinux();\n+\n+            if (mac) {\n+                replace(KCondition.ALT, KCondition.OPTION);\n+                replace(KCondition.META, KCondition.COMMAND);\n+                replace(KCondition.SHORTCUT, KCondition.COMMAND);\n+            } else if (win) {\n+                replace(KCondition.SHORTCUT, KCondition.CTRL);\n+            } else if (linux) {\n+                replace(KCondition.SHORTCUT, KCondition.CTRL);\n+            }\n+\n+            if (!mac) {\n+                if (m.contains(KCondition.COMMAND)) {\n+                    return null;\n+                } else if (m.contains(KCondition.OPTION)) {\n+                    return null;\n+                }\n+\n+                replace(KCondition.WINDOWS, KCondition.META);\n+            }\n+\n+            boolean pressed = m.contains(KCondition.KEY_PRESSED);\n+            boolean released = m.contains(KCondition.KEY_RELEASED);\n+            boolean typed = m.contains(KCondition.KEY_TYPED);\n+\n+            int ct = 0;\n+            KCondition t = null;\n+            if (pressed) {\n+                ct++;\n+                t = KCondition.KEY_PRESSED;\n+            }\n+            if (released) {\n+                ct++;\n+                t = KCondition.KEY_RELEASED;\n+            }\n+            if (typed) {\n+                ct++;\n+                t = KCondition.KEY_TYPED;\n+            }\n+\n+            \/\/ validate event type\n+            if (ct > 1) {\n+                throw new IllegalArgumentException(\"more than one key event type is specified\");\n+            }\n+\n+            if (t == null) {\n+                t = KCondition.KEY_PRESSED;\n+            }\n+            m.add(t);\n+\n+            \/\/ TODO validate: shortcut and !(other shortcut modifier)\n+            return new KeyBinding(key, m);\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.input\/src\/main\/java\/jfx\/incubator\/scene\/control\/input\/KeyBinding.java","additions":753,"deletions":0,"binary":false,"changes":753,"status":"added"},{"patch":"@@ -0,0 +1,438 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jfx.incubator.scene.control.input;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.event.EventType;\n+import javafx.scene.control.Control;\n+import javafx.scene.input.KeyCode;\n+import com.sun.jfx.incubator.scene.control.input.EventHandlerPriority;\n+import com.sun.jfx.incubator.scene.control.input.KeyEventMapper;\n+import com.sun.jfx.incubator.scene.control.input.PHList;\n+\n+\/**\n+ * The Input Map for use by the Skin.\n+ * <p>\n+ * Skins whose behavior encapsulates state information must use a Stateful variant obtained with\n+ * the {@link #create()} factory method.\n+ * <p>\n+ * Skins whose behavior requires no state, or when state is fully encapsulated by the Control itself,\n+ * could use a Stateless variant obtained with the {@link #createStateless()} method.\n+ *\n+ * @since 999 TODO\n+ *\/\n+public abstract sealed class SkinInputMap permits SkinInputMap.Stateful, SkinInputMap.Stateless {\n+    \/**\n+     * <pre> KeyBinding -> FunctionTag\n+     * FunctionTag -> Runnable or FunctionHandler\n+     * EventType -> PHList<\/pre>\n+     *\/\n+    final HashMap<Object, Object> map = new HashMap<>();\n+    final KeyEventMapper kmapper = new KeyEventMapper();\n+\n+    \/**\n+     * Creates a skin input map.\n+     *\/\n+    public SkinInputMap() {\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specified event type, in the context of this skin.\n+     *\n+     * @param <T> the actual event type\n+     * @param type the event type\n+     * @param consume determines whether the matching event is consumed or not\n+     * @param handler the event handler\n+     *\/\n+    public final <T extends Event> void addHandler(EventType<T> type, boolean consume, EventHandler<T> handler) {\n+        addHandler(type, consume, EventHandlerPriority.SKIN_HIGH, handler);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specified event type, in the context of this skin.\n+     * This event handler will get invoked after all handlers added via map() methods.\n+     *\n+     * @param <T> the actual event type\n+     * @param type the event type\n+     * @param consume determines whether the matching event is consumed or not\n+     * @param handler the event handler\n+     *\/\n+    public final <T extends Event> void addHandlerLast(EventType<T> type, boolean consume, EventHandler<T> handler) {\n+        addHandler(type, consume, EventHandlerPriority.SKIN_LOW, handler);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specific event criteria, in the context of this skin.\n+     * This is a more specific version of {@link #addHandler(EventType,boolean,EventHandler)} method.\n+     *\n+     * @param <T> the actual event type\n+     * @param criteria the matching criteria\n+     * @param consume determines whether the matching event is consumed or not\n+     * @param handler the event handler\n+     *\/\n+    public final <T extends Event> void addHandler(EventCriteria<T> criteria, boolean consume, EventHandler<T> handler) {\n+        addHandler(criteria, consume, EventHandlerPriority.SKIN_HIGH, handler);\n+    }\n+\n+    \/**\n+     * Adds an event handler for the specific event criteria, in the context of this skin.\n+     * This event handler will get invoked after all handlers added via map() methods.\n+     *\n+     * @param <T> the actual event type\n+     * @param criteria the matching criteria\n+     * @param consume determines whether the matching event is consumed or not\n+     * @param h the event handler\n+     *\/\n+    public final <T extends Event> void addHandlerLast(EventCriteria<T> criteria, boolean consume, EventHandler<T> h) {\n+        addHandler(criteria, consume, EventHandlerPriority.SKIN_LOW, h);\n+    }\n+\n+    private <T extends Event> void addHandler(\n+        EventType<T> type,\n+        boolean consume,\n+        EventHandlerPriority pri,\n+        EventHandler<T> handler)\n+    {\n+        if (consume) {\n+            putHandler(type, pri, new EventHandler<T>() {\n+                @Override\n+                public void handle(T ev) {\n+                    handler.handle(ev);\n+                    ev.consume();\n+                }\n+            });\n+        } else {\n+            putHandler(type, pri, handler);\n+        }\n+    }\n+\n+    private <T extends Event> void addHandler(\n+        EventCriteria<T> criteria,\n+        boolean consume,\n+        EventHandlerPriority pri,\n+        EventHandler<T> handler)\n+    {\n+        EventType<T> type = criteria.getEventType();\n+        putHandler(type, pri, new EventHandler<T>() {\n+            @Override\n+            public void handle(T ev) {\n+                if (criteria.isEventAcceptable(ev)) {\n+                    handler.handle(ev);\n+                    if (consume) {\n+                        ev.consume();\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    \/\/ adds the specified handler to input map with the given priority\n+    \/\/ and event type.\n+    private <T extends Event> void putHandler(EventType<T> type, EventHandlerPriority pri, EventHandler<T> handler) {\n+        Object x = map.get(type);\n+        PHList hs;\n+        if (x instanceof PHList h) {\n+            hs = h;\n+        } else {\n+            hs = new PHList();\n+            map.put(type, hs);\n+        }\n+        hs.add(pri, handler);\n+    }\n+\n+    \/**\n+     * Maps a key binding to the specified function tag.\n+     *\n+     * @param k the key binding\n+     * @param tag the function tag\n+     *\/\n+    public final void registerKey(KeyBinding k, FunctionTag tag) {\n+        map.put(k, tag);\n+        kmapper.addType(k);\n+    }\n+\n+    \/**\n+     * Maps a key binding to the specified function tag.\n+     *\n+     * @param code the key code to construct a {@link KeyBinding}\n+     * @param tag the function tag\n+     *\/\n+    public final void registerKey(KeyCode code, FunctionTag tag) {\n+        registerKey(KeyBinding.of(code), tag);\n+    }\n+\n+    Object resolve(KeyBinding k) {\n+        return map.get(k);\n+    }\n+\n+    \/**\n+     * Collects the key bindings mapped by the skin.\n+     *\n+     * @return a Set of key bindings\n+     *\/\n+    public final Set<KeyBinding> getKeyBindings() {\n+        return collectKeyBindings(null, null);\n+    }\n+\n+    \/**\n+     * Returns the set of key bindings mapped to the specified function tag.\n+     * @param tag the function tag\n+     * @return the set of KeyBindings\n+     *\/\n+    public final Set<KeyBinding> getKeyBindingsFor(FunctionTag tag) {\n+        return collectKeyBindings(null, tag);\n+    }\n+\n+    Set<KeyBinding> collectKeyBindings(Set<KeyBinding> bindings, FunctionTag tag) {\n+        if (bindings == null) {\n+            bindings = new HashSet<>();\n+        }\n+        for (Map.Entry<Object, Object> en : map.entrySet()) {\n+            if (en.getKey() instanceof KeyBinding k) {\n+                if ((tag == null) || (tag == en.getValue())) {\n+                    bindings.add(k);\n+                }\n+            }\n+        }\n+        return bindings;\n+    }\n+\n+    \/**\n+     * This convenience method registers a copy of the behavior-specific mappings from one key binding to another.\n+     * The method does nothing if no behavior specific mapping can be found.\n+     * @param existing the existing key binding\n+     * @param newk the new key binding\n+     *\/\n+    public final void duplicateMapping(KeyBinding existing, KeyBinding newk) {\n+        Object x = map.get(existing);\n+        if (x != null) {\n+            map.put(newk, x);\n+        }\n+    }\n+\n+    final boolean execute(Object source, FunctionTag tag) {\n+        Object x = map.get(tag);\n+        if (x instanceof Runnable r) {\n+            r.run();\n+            return true;\n+        } else if (x instanceof FunctionHandler f) {\n+            return f.handleFunction();\n+        } else if (x instanceof Stateless.FHandler h) {\n+            h.handleFunction(source);\n+            return true;\n+        } else if (x instanceof Stateless.FHandlerConditional h) {\n+            return h.handleFunction(source);\n+        }\n+        return false;\n+    }\n+\n+    void unbind(FunctionTag tag) {\n+        Iterator<Map.Entry<Object, Object>> it = map.entrySet().iterator();\n+        while (it.hasNext()) {\n+            Map.Entry<Object, Object> en = it.next();\n+            if (tag == en.getValue()) {\n+                \/\/ the entry must be KeyBinding -> FunctionTag\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    void forEach(TriConsumer client) {\n+        for (Map.Entry<Object, Object> en : map.entrySet()) {\n+            if (en.getKey() instanceof EventType type) {\n+                PHList hs = (PHList)en.getValue();\n+                hs.forEach((pri, h) -> {\n+                    client.accept(type, pri, h);\n+                    return true;\n+                });\n+            }\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    static interface TriConsumer<T extends Event> {\n+        public void accept(EventType<T> type, EventHandlerPriority pri, EventHandler<T> h);\n+    }\n+\n+    \/**\n+     * Creates the stateful SkinInputMap.\n+     * @return the stateful SkinInputMap\n+     *\/\n+    public static SkinInputMap.Stateful create() {\n+        return new Stateful();\n+    }\n+\n+    \/**\n+     * Creates the stateless SkinInputMap.\n+     * @param <C> the type of Control\n+     * @return the stateless SkinInputMap\n+     *\/\n+    public static <C extends Control> SkinInputMap.Stateless<C> createStateless() {\n+        return new Stateless<C>();\n+    }\n+\n+    \/** SkinInputMap for skins that maintain stateful behaviors *\/\n+    public static final class Stateful extends SkinInputMap {\n+        Stateful() {\n+        }\n+\n+        \/**\n+         * Maps a function to the specified function tag.\n+         *\n+         * @param tag the function tag\n+         * @param function the function\n+         *\/\n+        public final void registerFunction(FunctionTag tag, Runnable function) {\n+            map.put(tag, function);\n+        }\n+\n+        \/**\n+         * Maps a function to the specified function tag.\n+         * This method allows for controlling whether the matching event will be consumed or not.\n+         *\n+         * @param tag the function tag\n+         * @param function the function\n+         *\/\n+        public final void registerFunction(FunctionTag tag, FunctionHandler function) {\n+            map.put(tag, function);\n+        }\n+\n+        \/**\n+         * This convenience method maps the function tag to the specified function, and at the same time\n+         * maps the specified key binding to that function tag.\n+         * @param tag the function tag\n+         * @param k the key binding\n+         * @param func the function\n+         *\/\n+        public final void register(FunctionTag tag, KeyBinding k, Runnable func) {\n+            registerFunction(tag, func);\n+            registerKey(k, tag);\n+        }\n+\n+        \/**\n+         * This convenience method maps the function tag to the specified function, and at the same time\n+         * maps the specified key binding to that function tag.\n+         * @param tag the function tag\n+         * @param code the key code\n+         * @param func the function\n+         *\/\n+        public final void register(FunctionTag tag, KeyCode code, Runnable func) {\n+            registerFunction(tag, func);\n+            registerKey(KeyBinding.of(code), tag);\n+        }\n+    }\n+\n+    \/**\n+     * SkinInputMap for skins that either encapsulate the state fully in their Controls,\n+     * or don't require a state at all.\n+     *\n+     * @param <C> the type of Control\n+     *\/\n+    \/\/ NOTE: The stateless skin input map adds significant complexity to the API surface while providing\n+    \/\/ limited (some say non-existent) savings in terms of memory.  There aren't many Controls that\n+    \/\/ have a stateless behavior, which further reduces the usefulness of this class.\n+    \/\/ I'd rather remove this feature altogether.\n+    public static final class Stateless<C extends Control> extends SkinInputMap {\n+        \/**\n+         * The function handler that always consumes the corresponding event.\n+         * @param <C> the type of Control\n+         *\/\n+        public interface FHandler<C> {\n+            \/**\n+             * The function mapped to a key binding.\n+             * @param control the instance of Control\n+             *\/\n+            public void handleFunction(C control);\n+        }\n+\n+        \/**\n+         * The function handler that allows to control whether the corresponding event will get consumed.\n+         * @param <C> the type of Control\n+         *\/\n+        public interface FHandlerConditional<C> {\n+            \/**\n+             * The function mapped to a key binding.  The return value instructs the owning InputMap\n+             * to consume the triggering event or not.\n+             * @param control the instance of Control\n+             * @return true to consume the event, false otherwise\n+             *\/\n+            public boolean handleFunction(C control);\n+        }\n+\n+        Stateless() {\n+        }\n+\n+        \/**\n+         * Maps a function to the specified function tag.\n+         *\n+         * @param tag the function tag\n+         * @param function the function\n+         *\/\n+        public final void registerFunction(FunctionTag tag, FHandler<C> function) {\n+            map.put(tag, function);\n+        }\n+\n+        \/**\n+         * Maps a function to the specified function tag.\n+         * This method allows for controlling whether the matching event will be consumed or not.\n+         *\n+         * @param tag the function tag\n+         * @param function the function\n+         *\/\n+        public final void registerFunction(FunctionTag tag, FHandlerConditional<C> function) {\n+            map.put(tag, function);\n+        }\n+\n+        \/**\n+         * This convenience method maps the function tag to the specified function, and at the same time\n+         * maps the specified key binding to that function tag.\n+         * @param tag the function tag\n+         * @param k the key binding\n+         * @param func the function\n+         *\/\n+        public final void register(FunctionTag tag, KeyBinding k, FHandler<C> func) {\n+            registerFunction(tag, func);\n+            registerKey(k, tag);\n+        }\n+\n+        \/**\n+         * This convenience method maps the function tag to the specified function, and at the same time\n+         * maps the specified key binding to that function tag.\n+         * @param tag the function tag\n+         * @param code the key code\n+         * @param func the function\n+         *\/\n+        public final void register(FunctionTag tag, KeyCode code, FHandler<C> func) {\n+            registerFunction(tag, func);\n+            registerKey(KeyBinding.of(code), tag);\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.input\/src\/main\/java\/jfx\/incubator\/scene\/control\/input\/SkinInputMap.java","additions":438,"deletions":0,"binary":false,"changes":438,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * <p>Incubates a customization mechanism for the JavaFX Controls utilizing the\n+ * {@link jfx.incubator.scene.control.input.InputMap InputMap}.\n+ * <p>\n+ * The {@code InputMap}\n+ * <ul>\n+ * <li>allows for customization of a control behavior by changing the existing or adding new key mappings\n+ * <li>supports dynamic modification of the key mappings\n+ * <li>allows for accessing the default functionality even when it was overwritten by the application\n+ * <li>allows for reverting customization to the default implementation\n+ * <li>guarantees priorities between the application and the skin event handlers and key mappings\n+ * <li>allows for gradual migration of the existing controls to use the InputMap\n+ * <li>supports stateful and stateless (fully static) behavior implementations\n+ * <\/ul>\n+ * See\n+ * <a href=\"https:\/\/github.com\/andy-goryachev-oracle\/Test\/blob\/main\/doc\/InputMap\/InputMapV3.md\">Public InputMap Proposal (v3)<\/a>\n+ * for more info.\n+ * <p>\n+ * <b><a href=\"https:\/\/openjdk.org\/jeps\/11\">Incubating Feature.<\/a>\n+ * Will be removed in a future release.<\/b>\n+ * @since 999 TODO\n+ *\/\n+package jfx.incubator.scene.control.input;\n","filename":"modules\/jfx.incubator.input\/src\/main\/java\/jfx\/incubator\/scene\/control\/input\/package-info.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Incubates the mechanism for customization of JavaFX controls using the\n+ * {@link jfx.incubator.scene.control.input.InputMap InputMap}.\n+ * <p>\n+ * <b><a href=\"https:\/\/openjdk.org\/jeps\/11\">Incubating Feature.<\/a>\n+ * Will be removed in a future release.<\/b>\n+ *\n+ * @moduleGraph\n+ * @since 999\n+ *\/\n+module jfx.incubator.input {\n+    requires transitive javafx.base;\n+    requires transitive javafx.graphics;\n+    requires transitive javafx.controls;\n+\n+    exports jfx.incubator.scene.control.input;\n+\n+    \/\/ becomes unnecessary once InputMap is moved to Control JDK-8314968\n+    exports com.sun.jfx.incubator.scene.control.input to jfx.incubator.richtext;\n+}\n","filename":"modules\/jfx.incubator.input\/src\/main\/java\/module-info.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+--add-exports javafx.base\/com.sun.javafx=ALL-UNNAMED\n+#\n+--add-exports javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.geom=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.perf=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.scene.text=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.scene=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.stage=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.tk=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.util=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.prism=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.scenario.animation=ALL-UNNAMED\n+#\n+--add-exports javafx.controls\/com.sun.javafx.scene.control.behavior=ALL-UNNAMED\n+--add-exports javafx.controls\/com.sun.javafx.scene.control.inputmap=ALL-UNNAMED\n+--add-exports javafx.controls\/com.sun.javafx.scene.control.skin=ALL-UNNAMED\n+--add-exports javafx.controls\/com.sun.javafx.scene.control=ALL-UNNAMED\n+#\n+--add-exports jfx.incubator.richtext\/com.sun.jfx.incubator.scene.control.dummy=ALL-UNNAMED\n+--add-exports jfx.incubator.richtext\/com.sun.jfx.incubator.scene.control.richtext=ALL-UNNAMED\n","filename":"modules\/jfx.incubator.input\/src\/test\/addExports","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<classpath>\n+\t<classpathentry kind=\"src\" path=\"src\/main\/java\"\/>\n+\t<classpathentry kind=\"src\" path=\"src\/main\/resources\"\/>\n+\t<classpathentry kind=\"src\" output=\"testbin\" path=\"src\/shims\/java\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"test\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"src\" output=\"testbin\" path=\"src\/test\/java\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"test\" value=\"true\"\/>\n+\t\t\t<attribute name=\"optional\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"src\" output=\"testbin\" path=\"src\/test\/resources\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"test\" value=\"true\"\/>\n+\t\t\t<attribute name=\"optional\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.junit.JUNIT_CONTAINER\/5\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"test\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/swing\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/base\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"src\" path=\"\/graphics\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"src\" path=\"\/controls\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/incubator.input\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"output\" path=\"bin\"\/>\n+<\/classpath>\n","filename":"modules\/jfx.incubator.richtext\/.classpath","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<projectDescription>\n+\t<name>incubator.richtext<\/name>\n+\t<comment><\/comment>\n+\t<projects>\n+\t<\/projects>\n+\t<buildSpec>\n+\t\t<buildCommand>\n+\t\t\t<name>org.eclipse.jdt.core.javabuilder<\/name>\n+\t\t\t<arguments>\n+\t\t\t<\/arguments>\n+\t\t<\/buildCommand>\n+\t<\/buildSpec>\n+\t<natures>\n+\t\t<nature>org.eclipse.jdt.core.javanature<\/nature>\n+\t<\/natures>\n+<\/projectDescription>\n","filename":"modules\/jfx.incubator.richtext\/.project","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"","filename":"modules\/jfx.incubator.richtext\/.settings\/org.eclipse.core.resources.prefs","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":".settings\/org.eclipse.core.resources.prefs","status":"copied"},{"patch":"@@ -0,0 +1,12 @@\n+# Incubator\n+\n+This project incubates\n+[RichTextArea](src\/main\/java\/javafx\/incubator\/scene\/control\/rich\/RichTextArea.java)\n+and\n+[CodeArea](src\/main\/java\/javafx\/incubator\/scene\/control\/rich\/code\/CodeArea.java)\n+controls.\n+\n+\n+## Demo Projects\n+\n+Please refer to this [README](\/tests\/manual\/RichTextAreaDemo\/README.md).\n","filename":"modules\/jfx.incubator.richtext\/README.md","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"filename":"modules\/jfx.incubator.richtext\/src\/main\/docs\/jfx\/incubator\/scene\/control\/rich\/doc-files\/CodeArea.png","binary":true,"status":"added"},{"filename":"modules\/jfx.incubator.richtext\/src\/main\/docs\/jfx\/incubator\/scene\/control\/rich\/doc-files\/RichTextArea.png","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.util.HashMap;\n+import javafx.scene.Node;\n+import javafx.scene.image.WritableImage;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * Caching StyleResolver caches conversion results to avoid re-querying for the same information.\n+ *\/\n+public class CachingStyleResolver implements StyleResolver {\n+    private final StyleResolver resolver;\n+    private final HashMap<CssStyles, StyleAttributeMap> cache = new HashMap<>();\n+\n+    public CachingStyleResolver(StyleResolver r) {\n+        this.resolver = r;\n+    }\n+\n+    @Override\n+    public StyleAttributeMap resolveStyles(StyleAttributeMap attrs) {\n+        CssStyles css = attrs.get(CssStyles.CSS);\n+        if (css == null) {\n+            \/\/ no conversion is needed\n+            return attrs;\n+        }\n+\n+        StyleAttributeMap a = cache.get(css);\n+        if (a == null) {\n+            a = resolver.resolveStyles(attrs);\n+            cache.put(css, a);\n+        }\n+        return a;\n+    }\n+\n+    @Override\n+    public WritableImage snapshot(Node node) {\n+        return resolver.snapshot(node);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/CachingStyleResolver.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.util.Objects;\n+import javafx.scene.shape.LineTo;\n+import javafx.scene.shape.MoveTo;\n+import javafx.scene.shape.PathElement;\n+\n+\/**\n+ * Captures the caret position and bounds in the {@code VFlow.content} coordinates.\n+ *\/\n+public final class CaretInfo {\n+    private final double xmin;\n+    private final double xmax;\n+    private final double ymin;\n+    private final double ymax;\n+    private final double lineSpacing;\n+    private final PathElement[] path;\n+\n+    private CaretInfo(double xmin, double xmax, double ymin, double ymax, double lineSpacing, PathElement[] path) {\n+        this.xmin = xmin;\n+        this.xmax = xmax;\n+        this.ymin = ymin;\n+        this.ymax = ymax;\n+        this.lineSpacing = lineSpacing;\n+        this.path = path;\n+    }\n+\n+    \/**\n+     * Creates an instance of CaretInfo given the path and translation offsets required to\n+     * convert path coordinates (which come in the frame of reference of its {@code TextFlow}) to the view port\n+     * coordinates.\n+     *\n+     * @param lineSpacing the line spacing\n+     * @param path the caret path\n+     * @return the CaretInfo instance\n+     *\/\n+    public static CaretInfo create(double lineSpacing, PathElement[] path) {\n+        Objects.requireNonNull(path);\n+        if (path.length == 0) {\n+            throw new IllegalArgumentException(\"non-empty path is required\");\n+        }\n+\n+        double xmin = Double.POSITIVE_INFINITY;\n+        double xmax = Double.NEGATIVE_INFINITY;\n+        double ymin = Double.POSITIVE_INFINITY;\n+        double ymax = Double.NEGATIVE_INFINITY;\n+\n+        int sz = path.length;\n+        for (int i = 0; i < sz; i++) {\n+            PathElement em = path[i];\n+            if (em instanceof LineTo lineto) {\n+                double x = lineto.getX();\n+                double y = lineto.getY();\n+\n+                x = halfPixel(x);\n+                if (x < xmin) {\n+                    xmin = x;\n+                } else if (x > xmax) {\n+                    xmax = x;\n+                }\n+\n+                y = halfPixel(y);\n+                if (y < ymin) {\n+                    ymin = y;\n+                } else if (y > ymax) {\n+                    ymax = y;\n+                }\n+            } else if (em instanceof MoveTo moveto) {\n+                double x = moveto.getX();\n+                double y = moveto.getY();\n+\n+                x = halfPixel(x);\n+                if (x < xmin) {\n+                    xmin = x;\n+                } else if (x > xmax) {\n+                    xmax = x;\n+                }\n+\n+                y = halfPixel(y);\n+                if (y < ymin) {\n+                    ymin = y;\n+                } else if (y > ymax) {\n+                    ymax = y;\n+                }\n+            } else {\n+                throw new IllegalArgumentException(\"Unexpected PathElement: \" + em);\n+            }\n+        }\n+\n+        return new CaretInfo(xmin, xmax, ymin, ymax, lineSpacing, path);\n+    }\n+\n+    \/**\n+     * Returns the smallest x coordinate of the caret shape bounding box.\n+     * @return minimum x coordinate\n+     *\/\n+    public final double getMinX() {\n+        return xmin;\n+    }\n+\n+    \/**\n+     * Returns the largest x coordinate of the caret shape bounding box.\n+     * @return maximum x coordinate\n+     *\/\n+    public final double getMaxX() {\n+        return xmax;\n+    }\n+\n+    \/**\n+     * Returns the smallest y coordinate of the caret shape bounding box.\n+     * @return minimum y coordinate\n+     *\/\n+    public final double getMinY() {\n+        return ymin;\n+    }\n+\n+    \/**\n+     * Returns the largest y coordinate of the caret shape bounding box.\n+     * @return maximum y coordinate\n+     *\/\n+    public final double getMaxY() {\n+        return ymax;\n+    }\n+\n+    \/**\n+     * Returns the line spacing at the caret position.\n+     * @return the line spacing\n+     *\/\n+    public final double getLineSpacing() {\n+        return lineSpacing;\n+    }\n+\n+    \/**\n+     * Returns the caret path.\n+     * @return the non-null array of path elements\n+     *\/\n+    public final PathElement[] path() {\n+        return path;\n+    }\n+\n+    \/**\n+     * Returns true if the specified y coordinate is between the smallest and largest y coordinate of the\n+     * caret bounding box.\n+     *\n+     * @param y the Y coordinate\n+     * @return true if the coordinate is within the caret bounding box\n+     *\/\n+    public final boolean containsY(double y) {\n+        return (y >= ymin) && (y < ymax);\n+    }\n+\n+    private static double halfPixel(double coord) {\n+        return Math.round(coord + 0.5) - 0.5;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CaretInfo{xmin=\" + xmin + \", xmax=\" + xmax + \", ymin=\" + ymin + \", ymax=\" + ymax + \"}\";\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/CaretInfo.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.util.ArrayList;\n+import javafx.collections.ObservableList;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Point2D;\n+import javafx.scene.Node;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.layout.Region;\n+import javafx.scene.shape.PathElement;\n+import javafx.scene.text.HitInfo;\n+import javafx.scene.text.TextFlow;\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * Manages TextCells in a sliding window, comprised of the visible area and some number of screenfuls\n+ * before and after the visible area, for the purposes of layout.\n+ * The purpose is to estimating the average paragraph height, and to support relative navigation.\n+ *\/\n+public class CellArrangement {\n+    private final ArrayList<TextCell> cells = new ArrayList<>(32);\n+    private final double flowWidth;\n+    private final double flowHeight;\n+    private final int lineCount;\n+    private final Insets contentPadding;\n+    private final Origin origin;\n+    private int visibleCount;\n+    private int bottomCount;\n+    private double unwrappedWidth;\n+    private double topHeight;\n+    private double bottomHeight;\n+    private Node[] left;\n+    private Node[] right;\n+\n+    public CellArrangement(VFlow f) {\n+        this.flowWidth = f.getWidth();\n+        this.flowHeight = f.getViewPortHeight();\n+        this.origin = f.getOrigin();\n+        this.lineCount = f.getParagraphCount();\n+        this.contentPadding = f.contentPadding();\n+    }\n+\n+    \/\/ TODO not called right now, use it to skip reflow when not necessary\n+    public boolean isValid(VFlow f) {\n+        return\n+            (f.getWidth() == flowWidth) &&\n+            (f.getHeight() == flowHeight) &&\n+            (f.topCellIndex() == origin.index()) &&\n+            (RichUtils.equals(f.contentPadding(), contentPadding));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return\n+            \"CellArrangement{\" +\n+            origin +\n+            \", topCount=\" + topCount() +\n+            \", visible=\" + getVisibleCellCount() +\n+            \", bottomCount=\" + bottomCount +\n+            \", topHeight=\" + topHeight +\n+            \", bottomHeight=\" + bottomHeight +\n+            \", lineCount=\" + lineCount +\n+            \", average=\" + averageHeight() +\n+            \", estMax=\" + estimatedMax() +\n+            \", unwrapped=\" + getUnwrappedWidth() +\n+            \"}\";\n+    }\n+\n+    public void addCell(TextCell cell) {\n+        cells.add(cell);\n+    }\n+\n+    public void setUnwrappedWidth(double w) {\n+        unwrappedWidth = w;\n+    }\n+\n+    \/** returns snapped(ceil) size *\/\n+    public double getUnwrappedWidth() {\n+        return unwrappedWidth;\n+    }\n+\n+    public int getVisibleCellCount() {\n+        return visibleCount;\n+    }\n+\n+    public void setVisibleCellCount(int n) {\n+        visibleCount = n;\n+    }\n+\n+    \/** finds text position inside the sliding window, in cell coordinates *\/\n+    public TextPos getTextPos(double cellX, double cellY) {\n+        if (lineCount == 0) {\n+            return TextPos.ZERO;\n+        }\n+\n+        int topIx = topIndex();\n+        int btmIx = bottomIndex();\n+\n+        int ix = binarySearch(cellY, topIx, btmIx - 1);\n+        TextCell cell = getCell(ix);\n+        if (cell != null) {\n+            Region r = cell.getContent();\n+            Insets pad = r.getPadding();\n+            double y = cellY - cell.getY() - pad.getTop();\n+            if (y < 0) {\n+                return new TextPos(cell.getIndex(), 0, 0, true);\n+            } else if (y < cell.getCellHeight()) {\n+                if (r instanceof TextFlow t) {\n+                    double x = cellX - pad.getLeft();\n+                    Point2D p = new Point2D(x - r.getLayoutX(), y - r.getLayoutY());\n+                    HitInfo h = t.hitTest(p);\n+                    int ii = h.getInsertionIndex();\n+                    int ci = h.getCharIndex();\n+                    boolean leading = h.isLeading();\n+                    \/\/System.out.println(\"CellArrangmenet.getTextPos ix=\" + ii + \" ci=\" + ci + \" leading=\" + leading); \/\/ FIX\n+                    return new TextPos(cell.getIndex(), ii, ci, leading);\n+                } else {\n+                    return new TextPos(cell.getIndex(), 0, 0, true);\n+                }\n+            }\n+\n+            int cix = 0;\n+            if (r instanceof TextFlow f) {\n+                cix = RichUtils.getTextLength(f);\n+            }\n+            return new TextPos(cell.getIndex(), cix, cix, true);\n+        }\n+\n+        return TextPos.ZERO;\n+    }\n+\n+    \/** returns the cell contained in this layout, or null *\/\n+    public TextCell getCell(int modelIndex) {\n+        int ix = modelIndex - origin.index();\n+        if (ix < 0) {\n+            if ((ix + topCount()) >= 0) {\n+                \/\/ cells in the top part come after bottom part, and in reverse order\n+                return cells.get(bottomCount - ix - 1);\n+            }\n+        } else if (ix < bottomCount) {\n+            \/\/ cells in the normal (bottom) part\n+            return cells.get(ix);\n+        }\n+        return null;\n+    }\n+\n+    \/** returns a visible cell, or null *\/\n+    public TextCell getVisibleCell(int modelIndex) {\n+        int ix = modelIndex - origin.index();\n+        if ((ix >= 0) && (ix < visibleCount)) {\n+            return cells.get(ix);\n+        }\n+        return null;\n+    }\n+\n+    \/** returns a TextCell from the visible or bottom margin parts, or null *\/\n+    public TextCell getCellAt(int ix) {\n+        if (ix < visibleCount) {\n+            return cells.get(ix);\n+        }\n+        return null;\n+    }\n+\n+    public CaretInfo getCaretInfo(Region target, TextPos p) {\n+        if (p != null) {\n+            int ix = p.index();\n+            TextCell cell = getCell(ix);\n+            if (cell != null) {\n+                int charIndex = p.charIndex();\n+                boolean leading = p.isLeading();\n+                double dx = -contentPadding.getLeft();\n+                PathElement[] path = cell.getCaretShape(target, charIndex, leading, dx, 0.0);\n+                if (path == null) {\n+                    return null;\n+                }\n+\n+                double lineSpacing = cell.getLineSpacing();\n+                double top = cell.getContent().snappedTopInset();\n+                double bottom = cell.getContent().snappedBottomInset();\n+                return CaretInfo.create(lineSpacing, path);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public void removeNodesFrom(Pane p) {\n+        ObservableList<Node> cs = p.getChildren();\n+        for (int i = getVisibleCellCount() - 1; i >= 0; --i) {\n+            TextCell cell = cells.get(i);\n+            cs.remove(cell);\n+        }\n+    }\n+\n+    public void setBottomCount(int ix) {\n+        bottomCount = ix;\n+    }\n+\n+    public int bottomCount() {\n+        return bottomCount;\n+    }\n+\n+    public void setBottomHeight(double h) {\n+        bottomHeight = h;\n+    }\n+\n+    public double bottomHeight() {\n+        return bottomHeight;\n+    }\n+\n+    public int topCount() {\n+        return cells.size() - bottomCount;\n+    }\n+\n+    public void setTopHeight(double h) {\n+        topHeight = h;\n+    }\n+\n+    public double topHeight() {\n+        return topHeight;\n+    }\n+\n+    public double averageHeight() {\n+        return (topHeight + bottomHeight) \/ (topCount() + bottomCount);\n+    }\n+\n+    public double estimatedMax() {\n+        return (lineCount - topCount() - bottomCount) * averageHeight() + topHeight + bottomHeight;\n+    }\n+\n+    \/**\n+     * finds a model index of a cell that contains the given localY.\n+     * (in vflow frame of reference).\n+     * Should not be called with localY outside of this layout sliding window.\n+     *\/\n+    private int binarySearch(double localY, int low, int high) {\n+        \/\/System.err.println(\"    binarySearch off=\" + off + \", high=\" + high + \", low=\" + low); \/\/ FIX\n+        while (low <= high) {\n+            \/\/ TODO might be a problem for 2B-rows models\n+            int mid = (low + high) >>> 1;\n+            TextCell cell = getCell(mid);\n+            int cmp = compare(cell, localY);\n+            if (cmp < 0) {\n+                low = mid + 1;\n+            } else if (cmp > 0) {\n+                high = mid - 1;\n+            } else {\n+                return mid;\n+            }\n+        }\n+        return low;\n+    }\n+\n+    private int compare(TextCell cell, double localY) {\n+        double y = cell.getY();\n+        if (localY < y) {\n+            return 1;\n+        } else if (localY >= y + cell.getCellHeight()) {\n+            if (cell.getIndex() == (lineCount - 1)) {\n+                return 0;\n+            }\n+            return -1;\n+        }\n+        return 0;\n+    }\n+\n+    \/** returns a model index of the first cell in the sliding window top margin *\/\n+    public int topIndex() {\n+        return origin.index() - topCount();\n+    }\n+\n+    \/** returns a model index of the last cell in the sliding window bottom margin + 1 *\/\n+    public int bottomIndex() {\n+        return origin.index() + bottomCount;\n+    }\n+\n+    \/** creates a new Origin from the absolute position [0.0 ... (1.0-normalized.visible.amount)] *\/\n+    public Origin fromAbsolutePosition(double pos) {\n+        int topIx = topIndex();\n+        int btmIx = bottomIndex();\n+        int ix = (int)(pos * lineCount);\n+        if ((ix >= topIx) && (ix < btmIx)) {\n+            \/\/ inside the layout\n+            double top = topIx \/ (double)lineCount;\n+            double btm = btmIx \/ (double)lineCount;\n+            double f = (pos - top) \/ (btm - top); \/\/ TODO check for dvi0\/infinity\/NaN\n+            double localY = f * (topHeight + bottomHeight) - topHeight;\n+\n+            ix = binarySearch(localY, topIx, btmIx - 1);\n+            TextCell cell = getCell(ix);\n+            return new Origin(cell.getIndex(), localY - cell.getY());\n+        }\n+        return new Origin(ix, 0.0);\n+    }\n+\n+    public Origin computeOrigin(double delta) {\n+        int topIx = topIndex();\n+        int btmIx = bottomIndex();\n+        double y = delta;\n+\n+        if (delta < 0) {\n+            \/\/ do not scroll above the top edge\n+            double top = -origin.offset() - topHeight;\n+            if (y < top) {\n+                if (topIx == 0) {\n+                    double topPadding = contentPadding.getTop();\n+                    y = Math.max(y, -topPadding);\n+                    return new Origin(0, y);\n+                }\n+                return new Origin(topIx, 0.0);\n+            }\n+        } else {\n+            \/\/ do not scroll past (bottom edge - visible area)\n+            double max = bottomHeight - flowHeight;\n+            if (max < 0) {\n+                return null;\n+            }\n+            if (y > max) {\n+                y = max;\n+            }\n+        }\n+\n+        int ix = binarySearch(y, topIx, btmIx - 1);\n+        TextCell cell = getCell(ix);\n+        double off = y - cell.getY();\n+        return new Origin(cell.getIndex(), off);\n+    }\n+\n+    public void addLeftNode(int index, Node n) {\n+        if (left == null) {\n+            left = new Node[visibleCount];\n+        }\n+        left[index] = n;\n+    }\n+\n+    public void addRightNode(int index, Node n) {\n+        if (right == null) {\n+            right = new Node[visibleCount];\n+        }\n+        right[index] = n;\n+    }\n+\n+    public Node getLeftNodeAt(int index) {\n+        return left[index];\n+    }\n+\n+    public Node getRightNodeAt(int index) {\n+        return right[index];\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/CellArrangement.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import javafx.scene.layout.Pane;\n+import javafx.scene.shape.Rectangle;\n+\n+\/**\n+ * Pane that allows for container\/controller to lay out its children,\n+ * clipping its content to its bounds.\n+ *\/\n+public class ClippedPane extends Pane {\n+    private final Rectangle clip;\n+\n+    public ClippedPane(String cssName) {\n+        getStyleClass().add(cssName);\n+\n+        clip = new Rectangle();\n+        clip.setSmooth(false);\n+        clip.widthProperty().bind(widthProperty());\n+        clip.heightProperty().bind(heightProperty());\n+\n+        setClip(clip);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/ClippedPane.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * Compound Key\n+ *\/\n+public class CompoundKey {\n+    private final Object[] keys;\n+\n+    public CompoundKey(Object... keys) {\n+        this.keys = keys;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int h = CompoundKey.class.hashCode();\n+        return 31 * h + Arrays.hashCode(keys);\n+    }\n+\n+    @Override\n+    public boolean equals(Object x) {\n+        if (x == this) {\n+            return true;\n+        } else if (x instanceof CompoundKey c) {\n+            return Arrays.equals(keys, c.keys);\n+        } else {\n+            return false;\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/CompoundKey.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import javafx.scene.paint.Color;\n+import javafx.scene.text.TextAlignment;\n+import javafx.util.StringConverter;\n+import jfx.incubator.scene.control.richtext.model.ParagraphDirection;\n+\n+\/**\n+ * Converters used to serialize\/deserialize text attributes.\n+ *\/\n+public class Converters {\n+    public static StringConverter<Boolean> booleanConverter() {\n+        return new StringConverter<Boolean>() {\n+            @Override\n+            public String toString(Boolean v) {\n+                \/\/ do not output value of a boolean attribute\n+                return null;\n+            }\n+\n+            @Override\n+            public Boolean fromString(String s) {\n+                \/\/ attribute present means it's value is TRUE\n+                return Boolean.TRUE;\n+            }\n+        };\n+    }\n+\n+    public static StringConverter<Color> colorConverter() {\n+        return new StringConverter<Color>() {\n+            @Override\n+            public String toString(Color c) {\n+                return toHexColor(c);\n+            }\n+\n+            @Override\n+            public Color fromString(String s) {\n+                return parseHexColor(s);\n+            }\n+        };\n+    }\n+\n+    public static StringConverter<ParagraphDirection> paragraphDirectionConverter() {\n+        return new StringConverter<ParagraphDirection>() {\n+            @Override\n+            public String toString(ParagraphDirection d) {\n+                return fromParagraphDirection(d);\n+            }\n+\n+            @Override\n+            public ParagraphDirection fromString(String s) {\n+                return toParagraphDirection(s);\n+            }\n+        };\n+    }\n+\n+    public static StringConverter<TextAlignment> textAlignmentConverter() {\n+        return new StringConverter<TextAlignment>() {\n+            @Override\n+            public String toString(TextAlignment v) {\n+                return fromTextAlignment(v);\n+            }\n+\n+            @Override\n+            public TextAlignment fromString(String s) {\n+                return toTextAlignment(s);\n+            }\n+        };\n+    }\n+\n+    public static StringConverter<String> stringConverter() {\n+        return new StringConverter<String>() {\n+            @Override\n+            public String toString(String x) {\n+                return x;\n+            }\n+\n+            @Override\n+            public String fromString(String s) {\n+                return s;\n+            }\n+        };\n+    }\n+\n+    private static Color parseHexColor(String s) {\n+        double alpha;\n+        switch(s.length()) {\n+        case 8:\n+            \/\/ rrggbbaa\n+            alpha = parseByte(s, 6) \/ 255.0;\n+            break;\n+        case 6:\n+            \/\/ rrggbb\n+            alpha = 1.0;\n+            break;\n+        default:\n+            throw new IllegalArgumentException(\"unable to parse color: \" + s);\n+        }\n+\n+        int r = parseByte(s, 0);\n+        int g = parseByte(s, 2);\n+        int b = parseByte(s, 4);\n+        return Color.rgb(r, g, b, alpha);\n+    }\n+\n+    protected static String toHexColor(Color c) {\n+        return\n+            toHex8(c.getRed()) +\n+            toHex8(c.getGreen()) +\n+            toHex8(c.getBlue()) +\n+            ((c.getOpacity() == 1.0) ? \"\" : toHex8(c.getOpacity()));\n+    }\n+\n+    private static String toHex8(double x) {\n+        int v = (int)Math.round(255.0 * x);\n+        if (v < 0) {\n+            v = 0;\n+        } else if (v > 255) {\n+            v = 255;\n+        }\n+        return String.format(\"%02X\", v);\n+    }\n+\n+    protected static int parseByte(String text, int start) {\n+        int v = parseHexChar(text.charAt(start)) << 4;\n+        v += parseHexChar(text.charAt(start + 1));\n+        return v;\n+    }\n+\n+    private static int parseHexChar(int ch) {\n+        int c = ch - '0'; \/\/ 0...9\n+        if ((c >= 0) && (c <= 9)) {\n+            return c;\n+        }\n+        c = ch - 55; \/\/ handle A...F\n+        if ((c >= 10) && (c <= 15)) {\n+            return c;\n+        }\n+        c = ch - 97; \/\/ handle a...f\n+        if ((c >= 10) && (c <= 15)) {\n+            return c;\n+        }\n+        throw new IllegalArgumentException(\"not a hex char:\" + ch);\n+    }\n+\n+    private static String fromTextAlignment(TextAlignment a) {\n+        switch (a) {\n+        case CENTER:\n+            return \"C\";\n+        case JUSTIFY:\n+            return \"J\";\n+        case RIGHT:\n+            return \"R\";\n+        case LEFT:\n+        default:\n+            return \"L\";\n+        }\n+    }\n+\n+    private static TextAlignment toTextAlignment(String s) {\n+        switch (s) {\n+        case \"C\":\n+            return TextAlignment.CENTER;\n+        case \"J\":\n+            return TextAlignment.JUSTIFY;\n+        case \"L\":\n+            return TextAlignment.LEFT;\n+        case \"R\":\n+            return TextAlignment.RIGHT;\n+        default:\n+            throw new IllegalArgumentException(\"bad text alignment: \" + s);\n+        }\n+    }\n+\n+    private static String fromParagraphDirection(ParagraphDirection d) {\n+        switch(d) {\n+        case RIGHT_TO_LEFT:\n+            return \"R\";\n+        case LEFT_TO_RIGHT:\n+        default:\n+            return \"L\";\n+        }\n+    }\n+\n+    private static ParagraphDirection toParagraphDirection(String s) {\n+        switch(s) {\n+        case \"R\":\n+            return ParagraphDirection.RIGHT_TO_LEFT;\n+        case \"L\":\n+        default:\n+            return ParagraphDirection.LEFT_TO_RIGHT;\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/Converters.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+\n+\/**\n+ * Attribute represents CSS styles: a combination of a direct style (-fx-...)\n+ * and a number of style names.\n+ *\/\n+public final record CssStyles(String style, String[] names) {\n+    \/** This special attribute contains CSS direct style and style names for text segments only *\/\n+    public static final StyleAttribute<CssStyles> CSS = new StyleAttribute<>(\"CSS\", CssStyles.class, false);\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/CssStyles.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Random;\n+\n+\/**\n+ * A simple cache implementation which provides a cheap invalidation via {@link #clear()}\n+ * and a cheap random eviction via {@link #evict()}.\n+ * This object must be accessed from the FX application thread, although it does not check.\n+ *\/\n+public class FastCache<T> {\n+    private static record Entry<V>(int index, V cell) { }\n+\n+    private int size;\n+    private final Entry<T>[] linear;\n+    private final HashMap<Integer, T> data;\n+    private final static Random random = new Random();\n+\n+    public FastCache(int capacity) {\n+        linear = new Entry[capacity];\n+        data = new HashMap<>(capacity);\n+    }\n+\n+    public T get(int row) {\n+        return data.get(row);\n+    }\n+\n+    \/**\n+     * Adds a new cell to the cache. When the cache is full, this method evicts a\n+     * random cell from the cache first. NOTE: this method does not check whether\n+     * another cell for the given row is present, so this call must be preceded by a\n+     * {@link #get(int)}.\n+     *\/\n+    public void add(int index, T cell) {\n+        int ix;\n+        if (size >= capacity()) {\n+            ix = evict();\n+        } else {\n+            ix = size++;\n+        }\n+\n+        data.put(index, cell);\n+        linear[ix] = new Entry<>(index, cell);\n+    }\n+\n+    \/** returns an index in the linear array of the cell that has been evicted *\/\n+    protected int evict() {\n+        int ix = random.nextInt(size);\n+        \/\/ does not clear the slot because it will get overwritten by the caller\n+        Entry<T> en = linear[ix];\n+        int index = en.index();\n+        data.remove(index);\n+        return ix;\n+    }\n+\n+    public int size() {\n+        return size;\n+    }\n+\n+    public int capacity() {\n+        return linear.length;\n+    }\n+\n+    public void clear() {\n+        size = 0;\n+        Arrays.fill(linear, null);\n+        data.clear();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/FastCache.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import javafx.scene.paint.Color;\n+import javafx.scene.shape.Rectangle;\n+\n+\/**\n+ * A spacer node used to emulate the first line indent.\n+ *\n+ * FIX problems:\n+ * - selection: TextFlow thinks there is a separate node (click on left side, move to right side of this node)\n+ *\/\n+public class FirstLineIndentSpacer extends Rectangle {\n+    public FirstLineIndentSpacer(double width) {\n+        super(width, 1);\n+        setFill(Color.rgb(0, 0, 0, 0.0));\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/FirstLineIndentSpacer.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javafx.scene.shape.LineTo;\n+import javafx.scene.shape.MoveTo;\n+import javafx.scene.shape.PathElement;\n+\n+\/**\n+ * Conventient utility for building javafx {@link Path}\n+ *\/\n+public class FxPathBuilder {\n+    private final ArrayList<PathElement> elements = new ArrayList<>();\n+\n+    public FxPathBuilder() {\n+    }\n+\n+    public void add(PathElement em) {\n+        elements.add(em);\n+    }\n+\n+    public void addAll(PathElement... es) {\n+        for (PathElement em : es) {\n+            elements.add(em);\n+        }\n+    }\n+\n+    public void moveto(double x, double y) {\n+        add(new MoveTo(x, y));\n+    }\n+\n+    public void lineto(double x, double y) {\n+        add(new LineTo(x, y));\n+    }\n+\n+    public List<PathElement> getPathElements() {\n+        return elements;\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/FxPathBuilder.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javafx.scene.Node;\n+import javafx.scene.layout.Region;\n+import javafx.scene.paint.Color;\n+import javafx.scene.shape.LineTo;\n+import javafx.scene.shape.MoveTo;\n+import javafx.scene.shape.Path;\n+import javafx.scene.shape.PathElement;\n+import javafx.scene.text.Text;\n+import javafx.scene.text.TextFlow;\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n+\n+\/**\n+ * This component gets added to TextFlow to provide various types of highlight:\n+ * <ol>\n+ * <li>text highlight<\/li>\n+ * <li>squiggly line<\/li>\n+ * <li>underline<\/li>\n+ * <\/ol>\n+ *\/\n+public class HighlightShape extends Path {\n+    public enum Type {\n+        HIGHLIGHT,\n+        SQUIGGLY,\n+    }\n+\n+    private final Type type;\n+    private final int start;\n+    private final int end;\n+\n+    public HighlightShape(Type t, int start, int end) {\n+        this.type = t;\n+        this.start = start;\n+        this.end = end;\n+    }\n+\n+    private PathElement[] createPath(TextFlow f) {\n+        switch (type) {\n+        case HIGHLIGHT:\n+            return f.rangeShape(start, end);\n+        case SQUIGGLY:\n+            PathElement[] pe = f.underlineShape(start, end);\n+            return generateSquiggly(pe);\n+        default:\n+            return f.underlineShape(start, end);\n+        }\n+    }\n+\n+    \/\/ underlineShape returns a series of rectangular shapes (MLLLL,MLLLL,...)\n+    \/\/ first we convert each rectangle to a line at its vertical midpoint,\n+    \/\/ then generate squiggly line (saw tooth, actually, for now)\n+    private PathElement[] generateSquiggly(PathElement[] in) {\n+        ArrayList<PathElement> list = new ArrayList<>(in.length * 8);\n+        double x0 = Integer.MAX_VALUE;\n+        double x1 = Integer.MIN_VALUE;\n+        double y0 = Integer.MAX_VALUE;\n+        double y1 = Integer.MIN_VALUE;\n+        int sz = in.length + 1;\n+\n+        for (int i = 0; i < sz; i++) {\n+            PathElement p = i < in.length ? in[i] : null;\n+\n+            if ((p == null) || (p instanceof MoveTo)) {\n+                if (x0 < x1) {\n+                    generateSquiggly(list, x0, x1, (y0 + y1) \/ 2.0, 1.0);\n+                }\n+\n+                if (p == null) {\n+                    break;\n+                }\n+\n+                x0 = Integer.MAX_VALUE;\n+                x1 = Integer.MIN_VALUE;\n+                y0 = Integer.MAX_VALUE;\n+                y1 = Integer.MIN_VALUE;\n+            }\n+\n+            if (p instanceof MoveTo mt) {\n+                double x = mt.getX();\n+                if (x < x0) {\n+                    x0 = x;\n+                }\n+                if (x > x1) {\n+                    x1 = x;\n+                }\n+                double y = mt.getY();\n+                if (y < y0) {\n+                    y0 = y;\n+                }\n+                if (y > y1) {\n+                    y1 = y;\n+                }\n+            } else if (p instanceof LineTo lt) {\n+                double x = lt.getX();\n+                if (x < x0) {\n+                    x0 = x;\n+                }\n+                if (x > x1) {\n+                    x1 = x;\n+                }\n+                double y = lt.getY();\n+                if (y < y0) {\n+                    y0 = y;\n+                }\n+                if (y > y1) {\n+                    y1 = y;\n+                }\n+            }\n+        }\n+\n+        return list.toArray(new PathElement[list.size()]);\n+    }\n+\n+    private void generateSquiggly(List<PathElement> list, double xmin, double xmax, double ycenter, double sz) {\n+        double x = xmin;\n+        double y = ycenter;\n+        double y0 = ycenter - sz;\n+        double y1 = ycenter + sz;\n+        boolean up = true;\n+        boolean run = true;\n+\n+        list.add(new MoveTo(x, y));\n+\n+        while (run) {\n+            double delta = up ? (y - y0) : (y1 - y);\n+            if (x + delta > xmax) {\n+                delta = xmax - x;\n+                run = false;\n+            }\n+\n+            x += delta;\n+            if (up) {\n+                y -= delta;\n+            } else {\n+                y += delta;\n+            }\n+            up = !up;\n+\n+            list.add(new LineTo(x, y));\n+        }\n+    }\n+\n+    private void updatePath(TextFlow f) {\n+        PathElement[] pe = createPath(f);\n+        getElements().setAll(pe);\n+    }\n+\n+    public static void addTo(Region r, Type t, int start, int end, Color c) {\n+        if (r instanceof TextFlow f) {\n+            String style = createStyle(t, c);\n+            addHighlight(f, t, start, end, style, null);\n+        }\n+    }\n+\n+    public static void addTo(Region r, Type t, int start, int end, String... styles) {\n+        if (r instanceof TextFlow f) {\n+            addHighlight(f, t, start, end, null, styles);\n+        }\n+    }\n+\n+    private static String createStyle(Type t, Color c) {\n+        switch (t) {\n+        case HIGHLIGHT:\n+            \/\/ filled shape\n+            return \"-fx-fill: \" + RichUtils.toCssColor(c) + \"; -fx-stroke-width:0;\";\n+        default:\n+            \/\/ stroke\n+            return \"-fx-stroke: \" + RichUtils.toCssColor(c) + \"; -fx-stroke-width:1;\";\n+        }\n+    }\n+\n+    private static void addHighlight(TextFlow f, Type t, int start, int end, String directStyle, String[] styles) {\n+        HighlightShape p = new HighlightShape(t, start, end);\n+        p.setStyle(directStyle);\n+        if (styles != null) {\n+            p.getStyleClass().addAll(styles);\n+        }\n+\n+        f.widthProperty().addListener((x) -> p.updatePath(f));\n+        p.updatePath(f);\n+        p.setManaged(false);\n+\n+        \/\/ highlights must be added before any Text nodes\n+        List<Node> children = f.getChildren();\n+        int sz = children.size();\n+        int ix = -1;\n+        for (int i = 0; i < sz; i++) {\n+            if (children.get(i) instanceof Text) {\n+                ix = i;\n+                break;\n+            }\n+        }\n+        if (ix < 0) {\n+            children.add(p);\n+        } else {\n+            children.add(ix, p);\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/HighlightShape.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,368 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import javafx.scene.Node;\n+import javafx.scene.image.WritableImage;\n+import javafx.scene.layout.Region;\n+import javafx.scene.paint.Color;\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledOutput;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+\n+\/**\n+ * A {@link StyledOutput} which generates HTML output.\n+ *\/\n+\/\/ TODO should 'monospaced' paragraphs use <pre> ?\n+\/\/ TODO should we size down font on windows?\n+public class HtmlStyledOutput implements StyledOutput {\n+    \/\/ a synthetic attribute used only in Key\n+    private static final StyleAttribute<Key> SS_AND_UNDERLINE = new StyleAttribute<>(\"SS_AND_UNDERLINE\", Key.class, false);\n+    private final StyleResolver resolver;\n+    private final Writer wr;\n+    private final boolean inlineStyles;\n+    private record Key(StyleAttribute attr, Object value) { }\n+    private final HashMap<Key,Val> styles = new HashMap<>();\n+\n+    public HtmlStyledOutput(StyleResolver resolver, Writer wr, boolean inlineStyles) {\n+        this.resolver = resolver;\n+        this.wr = wr;\n+        this.inlineStyles = inlineStyles;\n+    }\n+\n+    @Override\n+    public void consume(StyledSegment seg) throws IOException {\n+        switch (seg.getType()) {\n+        case INLINE_NODE:\n+            Node n = seg.getInlineNodeGenerator().get();\n+            writeInlineNode(n);\n+            break;\n+        case LINE_BREAK:\n+            \/\/ TODO perhaps use a boolean flag to emit separate p and \/p tags\n+            wr.write(\"<p\/>\\n\");\n+            break;\n+        case TEXT:\n+            StyleAttributeMap a = seg.getStyleAttributeMap(resolver);\n+            boolean div = ((a != null) && (!a.isEmpty()));\n+            if (div) {\n+                wr.write(\"<span style='\");\n+                writeAttributes(a);\n+                wr.write(\"'>\");\n+            }\n+            String text = seg.getText();\n+            String encoded = encode(text);\n+            wr.write(encoded);\n+            if (div) {\n+                wr.write(\"<\/span>\");\n+            }\n+            break;\n+        case REGION:\n+            Region r = seg.getParagraphNodeGenerator().get();\n+            writeParagraph(r);\n+            break;\n+        }\n+    }\n+\n+    private void writeAttributes(StyleAttributeMap attrs) throws IOException {\n+        boolean sp = false;\n+        for (StyleAttribute a : attrs.getAttributes()) {\n+            Object v = attrs.get(a);\n+            if (v != null) {\n+                Key k = createKey(attrs, a, v);\n+                if (k != null) {\n+                    if (sp) {\n+                        wr.write(' ');\n+                    } else {\n+                        sp = true;\n+                    }\n+\n+                    Val val = styles.get(k);\n+                    if (inlineStyles) {\n+                        wr.write(val.css);\n+                    } else {\n+                        wr.write(val.name);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Special handing is required since STRIKE_THROUGH and UNDERLINE are mapped to\n+     * the same text-decoration CSS property.\n+     * @returns the new key or null if this attribute must be skipped.\n+     *\/\n+    private static Key createKey(StyleAttributeMap attrs, StyleAttribute a, Object v) {\n+        if (a == StyleAttributeMap.STRIKE_THROUGH) {\n+            if (attrs.isStrikeThrough() && attrs.isUnderline()) {\n+                a = SS_AND_UNDERLINE;\n+            }\n+        } else if (a == StyleAttributeMap.UNDERLINE) {\n+            if (attrs.isStrikeThrough() && attrs.isUnderline()) {\n+                return null;\n+            }\n+        }\n+        return new Key(a, v);\n+    }\n+\n+    private void writeParagraph(Region n) throws IOException {\n+        WritableImage im = resolver.snapshot(n);\n+        int w = (int)im.getWidth();\n+        int h = (int)im.getHeight();\n+        byte[] b = RichUtils.writePNG(im);\n+        String base64 = Base64.getEncoder().encodeToString(b);\n+        wr.write(\"<p><img src=\\\"data:image\/png;base64,\");\n+        wr.write(base64);\n+        wr.write(\"\\\" width=\");\n+        wr.write(String.valueOf(w));\n+        wr.write(\" height=\");\n+        wr.write(String.valueOf(h));\n+        wr.write(\"><\/p>\");\n+    }\n+\n+    private void writeInlineNode(Node n) throws IOException {\n+        WritableImage im = resolver.snapshot(n);\n+        int w = (int)im.getWidth();\n+        int h = (int)im.getHeight();\n+        byte[] b = RichUtils.writePNG(im);\n+        String base64 = Base64.getEncoder().encodeToString(b);\n+        wr.write(\"<img src=\\\"data:image\/png;base64,\");\n+        wr.write(base64);\n+        wr.write(\"\\\" width=\");\n+        wr.write(String.valueOf(w));\n+        wr.write(\" height=\");\n+        wr.write(String.valueOf(h));\n+        wr.write(\">\");\n+    }\n+\n+    \/\/ TODO unit test!\n+    private static String encode(String text) {\n+        if (text == null) {\n+            return \"\";\n+        }\n+\n+        int ix = indexOfSpecialChar(text);\n+        if (ix < 0) {\n+            return text;\n+        }\n+\n+        int len = text.length();\n+        StringBuilder sb = new StringBuilder(len + 32);\n+        sb.append(text, 0, ix);\n+\n+        for (int i = ix; i < len; i++) {\n+            char c = text.charAt(i);\n+            if (c < 0x20) {\n+                switch (c) {\n+                case '\\t':\n+                    sb.append(\"<pre>\\t<\/pre>\");\n+                    break;\n+                default:\n+                    sb.append(\"&#\");\n+                    sb.append(nibbleChar(c >> 4));\n+                    sb.append(nibbleChar(c));\n+                    sb.append(';');\n+                }\n+            } else {\n+                switch (c) {\n+                case '<':\n+                    sb.append(\"&lt;\");\n+                    break;\n+                case '>':\n+                    sb.append(\"&gt;\");\n+                    break;\n+                case '\"':\n+                    sb.append(\"&#34;\");\n+                    break;\n+                case '\\'':\n+                    sb.append(\"&#39;\");\n+                    break;\n+                case '&':\n+                    sb.append(\"&amp;\");\n+                    break;\n+                default:\n+                    sb.append(c);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    private static int indexOfSpecialChar(String text) {\n+        int len = text.length();\n+        for (int i = 0; i < len; i++) {\n+            char c = text.charAt(i);\n+            if (c < 0x20) {\n+                return i;\n+            } else {\n+                switch (c) {\n+                case '<':\n+                case '>':\n+                case '\"':\n+                case '\\'':\n+                case '&':\n+                    return i;\n+                default:\n+                    continue;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private static char nibbleChar(int x) {\n+        return \"0123456789abcdef\".charAt(x & 0x0f);\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        wr.flush();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        wr.close();\n+    }\n+\n+    private static class Val {\n+        public final String name;\n+        public final String css;\n+\n+        public Val(String name, String css) {\n+            this.name = name;\n+            this.css = css;\n+        }\n+    }\n+\n+    public StyledOutput firstPassBuilder() {\n+        return new StyledOutput() {\n+            @Override\n+            public void consume(StyledSegment seg) throws IOException {\n+                switch (seg.getType()) {\n+                case TEXT:\n+                    StyleAttributeMap attrs = seg.getStyleAttributeMap(resolver);\n+                    if ((attrs != null) && (!attrs.isEmpty())) {\n+                        for (StyleAttribute a : attrs.getAttributes()) {\n+                            Object v = attrs.get(a);\n+                            if (v != null) {\n+                                Key k = createKey(attrs, a, v);\n+                                if (k != null) {\n+                                    if (!styles.containsKey(k)) {\n+                                        String css = createCss(k.attr, v);\n+                                        if (css != null) {\n+                                            String name = \".S\" + styles.size();\n+                                            Val val = new Val(name, css);\n+                                            styles.put(k, val);\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                    break;\n+                case PARAGRAPH_ATTRIBUTES:\n+                    \/\/ TODO\n+                    break;\n+                }\n+            }\n+\n+            @Override\n+            public void flush() throws IOException {\n+            }\n+\n+            @Override\n+            public void close() throws IOException {\n+            }\n+        };\n+    }\n+\n+    private static String createCss(StyleAttribute a, Object v) {\n+        if (a == StyleAttributeMap.BOLD) {\n+            return \"font-weight: bold;\";\n+        } else if (a == StyleAttributeMap.FONT_FAMILY) {\n+            return \"font-family: \\\"\" + encodeFontFamily(v.toString()) + \"\\\";\";\n+        } else if (a == StyleAttributeMap.FONT_SIZE) {\n+            return \"font-size: \" + v + \"pt;\";\n+        } else if (a == StyleAttributeMap.ITALIC) {\n+            return \"font-style: italic;\";\n+        } else if (a == StyleAttributeMap.STRIKE_THROUGH) {\n+            return \"text-decoration: line-through;\";\n+        } else if (a == StyleAttributeMap.TEXT_COLOR) {\n+            return \"color: \" + RichUtils.toWebColor((Color)v) + \";\";\n+        } else if (a == StyleAttributeMap.UNDERLINE) {\n+            return \"text-decoration: underline;\";\n+        } else if (a == SS_AND_UNDERLINE) {\n+            return \"text-decoration: line-through underline;\";\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static String encodeFontFamily(String name) {\n+        switch (name.toLowerCase()) {\n+        case \"monospaced\":\n+            return \"monospace\";\n+        case \"system\":\n+        case \"sans-serif\":\n+            return \"sans-serif\";\n+        case \"serif\":\n+            return \"serif\";\n+        case \"cursive\":\n+            return \"cursive\";\n+        case \"fantasy\":\n+            return \"fantasy\";\n+        }\n+        return encode(name);\n+    }\n+\n+    public void writePrologue() throws IOException {\n+        wr.write(\"<html>\");\n+        if (!inlineStyles) {\n+            wr.write(\"<head><style>\\n\");\n+            for (Val v : styles.values()) {\n+                wr.write(v.name);\n+                wr.write(\" { \");\n+                wr.write(v.css);\n+                wr.write(\" }\\n\");\n+            }\n+            wr.write(\"<\/style><\/head>\\n\");\n+        }\n+        wr.write(\"<body>\\n\");\n+    }\n+\n+    public void writeEpilogue() throws IOException {\n+        wr.write(\"\\n<\/body><\/html>\\n\");\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/HtmlStyledOutput.java","additions":368,"deletions":0,"binary":false,"changes":368,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n+import javafx.geometry.VPos;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+import javafx.scene.layout.Pane;\n+\n+\/**\n+ * Content pane for RichParagraph that shows a single image.\n+ * The image gets resized if it cannot fit into available width.\n+ *\/\n+public class ImageCellPane extends Pane {\n+    private final Image image;\n+    private final ImageView imageView;\n+    private static final Insets PADDING = new Insets(1, 1, 1, 1);\n+\n+    \/**\n+     * The constructor.\n+     * @param image the image\n+     *\/\n+    public ImageCellPane(Image image) {\n+        this.image = image;\n+\n+        imageView = new ImageView(image);\n+        imageView.setSmooth(true);\n+        imageView.setPreserveRatio(true);\n+        getChildren().add(imageView);\n+\n+        setPadding(PADDING);\n+        getStyleClass().add(\"image-cell-pane\");\n+    }\n+\n+    @Override\n+    protected void layoutChildren() {\n+        double width = getWidth();\n+        double sc;\n+        if (width < image.getWidth()) {\n+            sc = width \/ image.getWidth();\n+        } else {\n+            sc = 1.0;\n+        }\n+        imageView.setScaleX(sc);\n+        imageView.setScaleY(sc);\n+\n+        double x0 = snappedLeftInset();\n+        double y0 = snappedTopInset();\n+        layoutInArea(\n+            imageView,\n+            x0,\n+            y0,\n+            image.getWidth() * sc,\n+            image.getHeight() * sc,\n+            0,\n+            PADDING,\n+            true,\n+            false,\n+            HPos.CENTER,\n+            VPos.CENTER\n+        );\n+    }\n+\n+    @Override\n+    protected double computePrefHeight(double w) {\n+        double pad = snappedTopInset() + snappedBottomInset();\n+        if (w != -1) {\n+            if (w < image.getWidth()) {\n+                return pad + (image.getHeight() * w \/ image.getWidth());\n+            }\n+        }\n+        return pad + (image.getHeight());\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/ImageCellPane.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import com.sun.javafx.util.Utils;\n+import jfx.incubator.scene.control.richtext.Marker;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * Manages Marker Accessor.\n+ *\/\n+public class MarkerHelper {\n+    public interface Accessor {\n+        public Marker createMarker(TextPos p);\n+        public void setMarkerPos(Marker m, TextPos p);\n+    }\n+\n+    static {\n+        Utils.forceInit(Marker.class);\n+    }\n+\n+    private static MarkerHelper.Accessor accessor;\n+\n+    public static void setAccessor(MarkerHelper.Accessor a) {\n+        if (accessor != null) {\n+            throw new IllegalStateException();\n+        }\n+        accessor = a;\n+    }\n+\n+    public static void setMarkerPos(Marker m, TextPos p) {\n+        accessor.setMarkerPos(m, p);\n+    }\n+\n+    public static Marker createMarker(TextPos p) {\n+        return accessor.createMarker(p);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/MarkerHelper.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import jfx.incubator.scene.control.richtext.Marker;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * Manages Markers.\n+ *\/\n+public class Markers {\n+    private HashMap<TextPos,List<WeakReference<Marker>>> markers;\n+\n+    public Markers() {\n+        markers = new HashMap<>();\n+    }\n+\n+    public Marker getMarker(TextPos pos) {\n+        List<WeakReference<Marker>> refs = markers.get(pos);\n+        if (refs != null) {\n+            for (int i = 0; i < refs.size(); i++) {\n+                WeakReference<Marker> ref = refs.get(i);\n+                Marker m = ref.get();\n+                if (m != null) {\n+                    return m;\n+                }\n+            }\n+        }\n+\n+        Marker m = MarkerHelper.createMarker(pos);\n+        if (refs == null) {\n+            refs = new ArrayList<>(2);\n+        }\n+        refs.add(new WeakReference<>(m));\n+        markers.put(pos, refs);\n+        return m;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        ArrayList<TextPos> list = new ArrayList<>(markers.keySet());\n+        Collections.sort(list);\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        boolean sep = false;\n+        int sz = list.size();\n+        for (int i = 0; i < sz; i++) {\n+            TextPos p = list.get(i);\n+            if (sep) {\n+                sb.append(',');\n+            } else {\n+                sep = true;\n+            }\n+            sb.append('{');\n+            sb.append(p.index());\n+            sb.append(',');\n+            sb.append(p.offset());\n+            sb.append('}');\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+\n+    \/\/ TODO unit test\n+    \/\/ TODO do we need (leading\/trailing) bias in TextPos?\n+    public void update(TextPos start, TextPos end, int charsTop, int linesAdded, int charsBottom) {\n+\/\/        System.out.println(\n+\/\/            \"start=\" + start +\n+\/\/            \" end=\" + end +\n+\/\/            \" top=\" + charsTop +\n+\/\/            \" lines=\" + linesAdded +\n+\/\/            \" btm=\" + charsBottom\n+\/\/        ); \/\/ FIX\n+        if (start.compareTo(end) > 0) {\n+            TextPos p = start;\n+            start = end;\n+            end = p;\n+        }\n+\n+        HashMap<TextPos, List<WeakReference<Marker>>> m2 = new HashMap<>(markers.size());\n+\n+        for (TextPos pos : markers.keySet()) {\n+            List<WeakReference<Marker>> refs = markers.get(pos);\n+            TextPos p;\n+            if (pos.compareTo(start) <= 0) {\n+                \/\/ position before the change: keep unchanged\n+                p = pos;\n+            } else if (pos.compareTo(end) < 0) {\n+                \/\/ position inside the change: section removed, move marker to start\n+                p = start;\n+            } else {\n+                \/\/ position after the change: shift\n+                int ix = pos.index();\n+                int off;\n+                if (ix == end.index()) {\n+                    if ((linesAdded == 0) && (start.index() == end.index())) {\n+                        \/\/ all on the same line\n+                        off = pos.offset() - (end.offset() - start.offset()) + charsTop + charsBottom;\n+                    } else {\n+                        off = pos.offset() - end.offset() + charsBottom;\n+                    }\n+                } else {\n+                    \/\/ edit happened earlier, offset is unchanged\n+                    off = pos.offset();\n+                }\n+\n+                ix += (linesAdded - end.index() + start.index());\n+                p = new TextPos(ix, off);\n+            }\n+\n+            \/\/ update markers with the new position, removing gc'ed\n+            for (int i = refs.size() - 1; i >= 0; i--) {\n+                Marker m = refs.get(i).get();\n+                if (m == null) {\n+                    refs.remove(i);\n+                } else {\n+                    MarkerHelper.setMarkerPos(m, p);\n+                }\n+            }\n+\n+            if (refs.size() > 0) {\n+                m2.put(p, refs);\n+            }\n+        }\n+\n+        markers = m2;\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/Markers.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+\/**\n+ * View origin: model index of the top paragraph index + offset in pixels from the upper edge of the top cell to\n+ * the upper edge of the view area.\n+ *\n+ * @param index the model index of a paragraph at the top of visible area\n+ * @param offset the distance in pixels from the top of the visible area to the top of the topmost paragraph\n+ *\/\n+public record Origin(int index, double offset) {\n+    \/** beginning of the document *\/\n+    public static final Origin ZERO = new Origin(0, 0.0);\n+\n+    @Override\n+    public String toString() {\n+        return \"Origin{index=\" + index + \", offset=\" + offset + \"}\";\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/Origin.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import javafx.geometry.Insets;\n+import javafx.util.Duration;\n+\n+\/**\n+ * Various constants.\n+ *\/\n+public class Params {\n+    \/** number of paragraph for accessibility window *\/\n+    public static final int ACCESSIBILITY_WINDOW_SIZE = 64;\n+\n+    \/** autoscroll animation period, milliseconds. *\/\n+    public static final int AUTO_SCROLL_PERIOD = 100;\n+\n+    \/** autoscroll switches to fast mode when mouse is moved further out of the view, pixels. *\/\n+    public static final double AUTO_SCROLL_FAST_THRESHOLD = 100;\n+\n+    \/** \"fast\" autoscroll step, in pixels. *\/\n+    public static final double AUTO_SCROLL_STEP_FAST = 200;\n+\n+    \/** \"slow\" autoscroll step, in pixels. *\/\n+    public static final double AUTO_SCROLL_STEP_SLOW = 20;\n+\n+    \/** cell cache size. *\/\n+    public static final int CELL_CACHE_SIZE = 512;\n+\n+    \/** default caret blink period. *\/\n+    public static final Duration DEFAULT_CARET_BLINK_PERIOD = Duration.millis(1000);\n+\n+    \/** default value for {@code displayCaret} property *\/\n+    public static final boolean DEFAULT_DISPLAY_CARET = true;\n+\n+    \/** default value for {@code highlightCurrentParagraph} property *\/\n+    public static final boolean DEFAULT_HIGHLIGHT_CURRENT_PARAGRAPH = false;\n+\n+    \/** default value for {@code useContentHeight} property *\/\n+    public static final boolean DEFAULT_USE_CONTENT_HEIGHT = false;\n+\n+    \/** default tab size in the CodeArea *\/\n+    public static final int DEFAULT_TAB_SIZE = 8;\n+\n+    \/** default value for {@code useContentWidth} property *\/\n+    public static final boolean DEFAULT_USE_CONTENT_WIDTH = false;\n+\n+    \/** default value for {@code wrapText} property *\/\n+    public static final boolean DEFAULT_WRAP_TEXT = false;\n+\n+    \/** ensures the caret is always visible when reaching the edge of screen in unwrapped mode, in pixels. *\/\n+    public static final double HORIZONTAL_GUARD = 0; \/\/10; FIX restore\n+\n+    \/** focus background outline size *\/\n+    public static final double LAYOUT_FOCUS_BORDER = 1;\n+\n+    \/** min height of the content area when use content width = true and empty model *\/\n+    public static final double LAYOUT_MIN_HEIGHT = 10;\n+\n+    \/** min width of the content area when use content width = true and empty model *\/\n+    public static final double LAYOUT_MIN_WIDTH = 20;\n+\n+    \/** prevents lockup when useContentHeight is enabled with a large model *\/\n+    public static final double MAX_HEIGHT_SAFEGUARD = 10_000;\n+\n+    \/** maximum width for unwrapped TextFlow layout. Neither Double.MAX_VALUE nor 1e20 work, probably bc float *\/\n+    public static final double MAX_WIDTH_FOR_LAYOUT = 1_000_000_000.0;\n+\n+    \/** default minimum height *\/\n+    public static final double MIN_HEIGHT = 10;\n+\n+    \/** default minimum width *\/\n+    public static final double MIN_WIDTH = 10;\n+\n+    \/** minimum viewport width prevents extra tall text flows *\/\n+    public static final double MIN_VIEWPORT_WIDTH = 10;\n+\n+    \/** default preferred height *\/\n+    public static final double PREF_HEIGHT = 100;\n+\n+    \/** default preferred width *\/\n+    public static final double PREF_WIDTH = 200;\n+\n+    \/** scroll bars block increment, fraction of view width\/height (between 0.0 and 1.0). *\/\n+    public static final double SCROLL_BARS_BLOCK_INCREMENT = 0.05;\n+\n+    \/** scroll bars unit increment, fraction of view width\/height (between 0.0 and 1.0). *\/\n+    public static final double SCROLL_BARS_UNIT_INCREMENT = 0.01;\n+\n+    \/** horizontal mouse wheel scroll block size as a fraction of window width. *\/\n+    public static final double SCROLL_SHEEL_BLOCK_SIZE_HORIZONTAL = 0.1;\n+\n+    \/** vertical mouse wheel scroll block size as a fraction of window height. *\/\n+    public static final double SCROLL_WHEEL_BLOCK_SIZE_VERTICAL = 0.1;\n+\n+    \/**\n+     * VFlow TextLayout sliding window extent before and after the visible area.\n+     * Must be > 1.0f for the relative navigation to work.\n+     *\/\n+    public static final float SLIDING_WINDOW_EXTENT = 3.0f;\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/Params.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.SelectionSegment;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * The purpose of this class is to maintain a small String segment\n+ * around the RichTextArea caret to use with the accessibility API.\n+ * <p>\n+ * These APIs generally accept a single String and integer offsets for caret position\n+ * and selection, which is totally impossible to implement in the context of a large\n+ * virtualized text model, as it a) uses TextPos for encapsulating the text position\n+ * instead of an int, and it may not be possible to represent selected text as a\n+ * String for large models.\n+ *\/\n+public class RTAccessibilityHelper {\n+    private final RichTextArea control;\n+    private TextPos start;\n+    private TextPos end;\n+\n+    public RTAccessibilityHelper(RichTextArea t) {\n+        this.control = t;\n+    }\n+\n+    \/\/ FIX remove\n+    private void p(String fmt, Object... args) {\n+        if (false) {\n+            System.out.println(String.format(fmt, args));\n+        }\n+    }\n+\n+    \/** clear a11y cache *\/\n+    public void handleModelChange() {\n+        p(\"handleModelChange\");\n+        start = null;\n+        end = null;\n+    }\n+\n+    \/** returns true if update is within the a11y window *\/\n+    public boolean handleTextUpdate(TextPos p0, TextPos p1) {\n+        p(\"handleTextUpdate %s %s\", start, end);\n+\n+        if ((start != null) && (end != null)) {\n+            if (p0.compareTo(end) >= 0) {\n+                return false;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Handles selection changes.\n+     * @return true if a11y window has shifted and TEXT attribute needs to be sent to the platform\n+     *\/\n+    public boolean handleSelectionChange(SelectionSegment sel) {\n+        if (sel == null) {\n+            return false;\n+        }\n+\n+        \/\/ no start\/end: create window, return true\n+        \/\/ selection outside of the window: change window, return true\n+        if((start == null) || (end == null) || isOutside(sel.getMin(), sel.getMax())) {\n+            createWindow();\n+            return true;\n+        }\n+\n+        \/\/ selection within the window: no-op, return false\n+        return false;\n+    }\n+\n+    private boolean isOutside(TextPos p0, TextPos p1) {\n+        if ((start.compareTo(p1) >= 0) || (end.compareTo(p0) <= 0)) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private void createWindow() {\n+        \/\/ selection is small: create window around selection\n+        \/\/ selection is large: create window around the caret\n+        SelectionSegment sel = control.getSelection();\n+        TextPos cp = sel.getCaret();\n+        int ix0 = Math.max(0, cp.index() - (Params.ACCESSIBILITY_WINDOW_SIZE \/ 2));\n+        int ix1 = Math.min(control.getParagraphCount() - 1, ix0 + Params.ACCESSIBILITY_WINDOW_SIZE);\n+\n+        start = new TextPos(ix0, 0);\n+        end = control.getParagraphEnd(ix1);\n+    }\n+\n+    public String getText() {\n+        if ((start == null) && (end == null)) {\n+            return null;\n+        }\n+\n+        \/\/ alternative: use model.export()\n+        StringBuilder sb = new StringBuilder();\n+        int mx = end.index();\n+        for (int ix = start.index(); ix <= mx; ix++) {\n+            String s = control.getPlainText(ix);\n+            sb.append(s).append(\"\\n\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    public Integer selectionStart() {\n+        SelectionSegment sel = control.getSelection();\n+        if (sel == null) {\n+            return null;\n+        }\n+        return computeOffset(sel.getMin());\n+    }\n+\n+    public Integer selectionEnd() {\n+        SelectionSegment sel = control.getSelection();\n+        if (sel == null) {\n+            return null;\n+        }\n+        return computeOffset(sel.getMax());\n+    }\n+\n+    public Integer caretOffset() {\n+        SelectionSegment sel = control.getSelection();\n+        if (sel == null) {\n+            return null;\n+        }\n+        return computeOffset(sel.getCaret());\n+    }\n+\n+    private Integer computeOffset(TextPos p) {\n+        if (\n+            (start == null) ||\n+            (end == null) ||\n+            (p.compareTo(start) < 0) ||\n+            (p.compareTo(end) > 0)\n+        ) {\n+            return null;\n+        }\n+\n+        int off = 0;\n+        int index = start.index();\n+        while (index < p.index()) {\n+            String s = control.getPlainText(index);\n+            off += (s.length() + 1); \/\/ plus newline character\n+            index++;\n+        }\n+        return off + p.offset();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/RTAccessibilityHelper.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+import com.sun.javafx.util.Utils;\n+import jfx.incubator.scene.control.richtext.model.RichParagraph;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+\n+\/**\n+ * Provides access to internal methods in RichParagraph.\n+ *\/\n+public class RichParagraphHelper {\n+    public interface Accessor {\n+        public List<Consumer<TextCell>> getHighlights(RichParagraph p);\n+\n+        public List<StyledSegment> getSegments(RichParagraph p);\n+    }\n+\n+    static {\n+        Utils.forceInit(RichParagraph.class);\n+    }\n+\n+    private static Accessor accessor;\n+\n+    public static void setAccessor(Accessor a) {\n+        if (accessor != null) {\n+            throw new IllegalStateException();\n+        }\n+        accessor = a;\n+    }\n+\n+    public static List<Consumer<TextCell>> getHighlights(RichParagraph p) {\n+        return accessor.getHighlights(p);\n+    }\n+\n+    public static List<StyledSegment> getSegments(RichParagraph p) {\n+        return accessor.getSegments(p);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/RichParagraphHelper.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,1542 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.io.IOException;\n+import java.text.Bidi;\n+import java.text.BreakIterator;\n+import java.util.function.BiFunction;\n+import javafx.animation.KeyFrame;\n+import javafx.animation.Timeline;\n+import javafx.collections.ObservableList;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.SeparatorMenuItem;\n+import javafx.scene.input.Clipboard;\n+import javafx.scene.input.ClipboardContent;\n+import javafx.scene.input.ContextMenuEvent;\n+import javafx.scene.input.DataFormat;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyEvent;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.input.ScrollEvent;\n+import javafx.scene.layout.Pane;\n+import javafx.stage.Screen;\n+import javafx.util.Duration;\n+import com.sun.javafx.PlatformUtil;\n+import com.sun.javafx.util.Utils;\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n+import jfx.incubator.scene.control.input.BehaviorBase;\n+import jfx.incubator.scene.control.input.KeyBinding;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.DataFormatHandler;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledInput;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+\n+\/**\n+ * This class provides the RichTextArea behavior by registering input mappings and\n+ * implementing various event handlers.\n+ *\/\n+public class RichTextAreaBehavior extends BehaviorBase<RichTextArea> {\n+    private VFlow vflow;\n+    private final Timeline autoScrollTimer;\n+    private boolean autoScrollUp;\n+    private boolean fastAutoScroll;\n+    private boolean scrollStarted;\n+    private double phantomX = -1.0;\n+    private final Duration autoScrollPeriod;\n+    private ContextMenu contextMenu = new ContextMenu();\n+\n+    public RichTextAreaBehavior(RichTextArea control) {\n+        super(control);\n+\n+        autoScrollPeriod = Duration.millis(Params.AUTO_SCROLL_PERIOD);\n+\n+        autoScrollTimer = new Timeline(new KeyFrame(autoScrollPeriod, (ev) -> {\n+            autoScroll();\n+        }));\n+        autoScrollTimer.setCycleCount(Timeline.INDEFINITE);\n+    }\n+\n+    @Override\n+    protected void populateSkinInputMap() {\n+        vflow = RichTextAreaSkinHelper.getVFlow(getControl());\n+\n+        \/\/ functions\n+        registerFunction(RichTextArea.Tags.BACKSPACE, this::backspace);\n+        registerFunction(RichTextArea.Tags.COPY, this::copy);\n+        registerFunction(RichTextArea.Tags.CUT, this::cut);\n+        registerFunction(RichTextArea.Tags.DELETE, this::delete);\n+        registerFunction(RichTextArea.Tags.DELETE_PARAGRAPH, this::deleteParagraph);\n+        registerFunction(RichTextArea.Tags.DELETE_PARAGRAPH_START, this::deleteParagraphStart);\n+        registerFunction(RichTextArea.Tags.DELETE_WORD_NEXT_END, this::deleteWordNextEnd);\n+        registerFunction(RichTextArea.Tags.DELETE_WORD_NEXT_START, this::deleteWordNextBeg);\n+        registerFunction(RichTextArea.Tags.DELETE_WORD_PREVIOUS, this::deleteWordPrevious);\n+        registerFunction(RichTextArea.Tags.DESELECT, this::deselect);\n+        registerFunction(RichTextArea.Tags.FOCUS_NEXT, this::traverseNext);\n+        registerFunction(RichTextArea.Tags.FOCUS_PREVIOUS, this::traversePrevious);\n+        registerFunction(RichTextArea.Tags.INSERT_LINE_BREAK, this::insertLineBreak);\n+        registerFunction(RichTextArea.Tags.INSERT_TAB, this::insertTab);\n+        registerFunction(RichTextArea.Tags.MOVE_DOWN, this::moveDown);\n+        registerFunction(RichTextArea.Tags.MOVE_LEFT, this::moveLeft);\n+        registerFunction(RichTextArea.Tags.MOVE_PARAGRAPH_DOWN, this::moveParagraphDown);\n+        registerFunction(RichTextArea.Tags.MOVE_PARAGRAPH_UP, this::moveParagraphUp);\n+        registerFunction(RichTextArea.Tags.MOVE_RIGHT, this::moveRight);\n+        registerFunction(RichTextArea.Tags.MOVE_TO_DOCUMENT_END, this::moveDocumentEnd);\n+        registerFunction(RichTextArea.Tags.MOVE_TO_DOCUMENT_START, this::moveDocumentStart);\n+        registerFunction(RichTextArea.Tags.MOVE_TO_PARAGRAPH_END, this::moveParagraphEnd);\n+        registerFunction(RichTextArea.Tags.MOVE_TO_PARAGRAPH_START, this::moveParagraphStart);\n+        registerFunction(RichTextArea.Tags.MOVE_UP, this::moveUp);\n+        registerFunction(RichTextArea.Tags.MOVE_WORD_NEXT_END, this::nextWordEnd);\n+        registerFunction(RichTextArea.Tags.MOVE_WORD_NEXT_START, this::nextWord);\n+        registerFunction(RichTextArea.Tags.MOVE_WORD_LEFT, this::leftWord);\n+        registerFunction(RichTextArea.Tags.MOVE_WORD_PREVIOUS, this::previousWord);\n+        registerFunction(RichTextArea.Tags.MOVE_WORD_RIGHT, this::rightWord);\n+        registerFunction(RichTextArea.Tags.PAGE_DOWN, this::pageDown);\n+        registerFunction(RichTextArea.Tags.PAGE_UP, this::pageUp);\n+        registerFunction(RichTextArea.Tags.PASTE, this::paste);\n+        registerFunction(RichTextArea.Tags.PASTE_PLAIN_TEXT, this::pastePlainText);\n+        registerFunction(RichTextArea.Tags.REDO, this::redo);\n+        registerFunction(RichTextArea.Tags.SELECT_ALL, this::selectAll);\n+        registerFunction(RichTextArea.Tags.SELECT_DOWN, this::selectDown);\n+        registerFunction(RichTextArea.Tags.SELECT_LEFT, this::selectLeft);\n+        registerFunction(RichTextArea.Tags.SELECT_PAGE_DOWN, this::selectPageDown);\n+        registerFunction(RichTextArea.Tags.SELECT_PAGE_UP, this::selectPageUp);\n+        registerFunction(RichTextArea.Tags.SELECT_PARAGRAPH, this::selectParagraph);\n+        registerFunction(RichTextArea.Tags.SELECT_PARAGRAPH_DOWN, this::selectParagraphDown);\n+        registerFunction(RichTextArea.Tags.SELECT_PARAGRAPH_END, this::selectParagraphEnd);\n+        registerFunction(RichTextArea.Tags.SELECT_PARAGRAPH_START, this::selectParagraphStart);\n+        registerFunction(RichTextArea.Tags.SELECT_PARAGRAPH_UP, this::selectParagraphUp);\n+        registerFunction(RichTextArea.Tags.SELECT_RIGHT, this::selectRight);\n+        registerFunction(RichTextArea.Tags.SELECT_TO_DOCUMENT_END, this::selectDocumentEnd);\n+        registerFunction(RichTextArea.Tags.SELECT_TO_DOCUMENT_START, this::selectDocumentStart);\n+        registerFunction(RichTextArea.Tags.SELECT_UP, this::selectUp);\n+        registerFunction(RichTextArea.Tags.SELECT_WORD, this::selectWord);\n+        registerFunction(RichTextArea.Tags.SELECT_WORD_LEFT, this::selectWordLeft);\n+        registerFunction(RichTextArea.Tags.SELECT_WORD_NEXT, this::selectWordNext);\n+        registerFunction(RichTextArea.Tags.SELECT_WORD_NEXT_END, this::selectNextWordEnd);\n+        registerFunction(RichTextArea.Tags.SELECT_WORD_PREVIOUS, this::selectWordPrevious);\n+        registerFunction(RichTextArea.Tags.SELECT_WORD_RIGHT, this::selectWordRight);\n+        registerFunction(RichTextArea.Tags.UNDO, this::undo);\n+\n+        \/\/ key mappings\n+        registerKey(KeyBinding.shortcut(KeyCode.A), RichTextArea.Tags.SELECT_ALL);\n+        registerKey(KeyCode.BACK_SPACE, RichTextArea.Tags.BACKSPACE);\n+        registerKey(KeyBinding.shift(KeyCode.BACK_SPACE), RichTextArea.Tags.BACKSPACE);\n+        registerKey(KeyBinding.shortcut(KeyCode.C), RichTextArea.Tags.COPY);\n+        registerKey(KeyCode.COPY, RichTextArea.Tags.COPY);\n+        registerKey(KeyBinding.shortcut(KeyCode.D), RichTextArea.Tags.DELETE_PARAGRAPH);\n+        registerKey(KeyCode.DELETE, RichTextArea.Tags.DELETE);\n+        registerKey(KeyCode.DOWN, RichTextArea.Tags.MOVE_DOWN);\n+        registerKey(KeyBinding.shift(KeyCode.DOWN), RichTextArea.Tags.SELECT_DOWN);\n+        registerKey(KeyCode.END, RichTextArea.Tags.MOVE_TO_PARAGRAPH_END);\n+        registerKey(KeyBinding.shift(KeyCode.END), RichTextArea.Tags.SELECT_PARAGRAPH_END);\n+        registerKey(KeyCode.ENTER, RichTextArea.Tags.INSERT_LINE_BREAK);\n+        registerKey(KeyCode.HOME, RichTextArea.Tags.MOVE_TO_PARAGRAPH_START);\n+        registerKey(KeyBinding.shift(KeyCode.HOME), RichTextArea.Tags.SELECT_PARAGRAPH_START);\n+        registerKey(KeyBinding.shift(KeyCode.INSERT), RichTextArea.Tags.PASTE);\n+        registerKey(KeyBinding.shortcut(KeyCode.INSERT), RichTextArea.Tags.COPY);\n+        registerKey(KeyCode.LEFT, RichTextArea.Tags.MOVE_LEFT);\n+        registerKey(KeyBinding.shift(KeyCode.LEFT), RichTextArea.Tags.SELECT_LEFT);\n+        registerKey(KeyCode.PAGE_DOWN, RichTextArea.Tags.PAGE_DOWN);\n+        registerKey(KeyBinding.shift(KeyCode.PAGE_DOWN), RichTextArea.Tags.SELECT_PAGE_DOWN);\n+        registerKey(KeyCode.PAGE_UP, RichTextArea.Tags.PAGE_UP);\n+        registerKey(KeyBinding.shift(KeyCode.PAGE_UP), RichTextArea.Tags.SELECT_PAGE_UP);\n+        registerKey(KeyCode.PASTE, RichTextArea.Tags.PASTE);\n+        registerKey(KeyCode.RIGHT, RichTextArea.Tags.MOVE_RIGHT);\n+        registerKey(KeyBinding.shift(KeyCode.RIGHT), RichTextArea.Tags.SELECT_RIGHT);\n+        registerKey(KeyCode.TAB, RichTextArea.Tags.INSERT_TAB);\n+        registerKey(KeyBinding.ctrl(KeyCode.TAB), RichTextArea.Tags.FOCUS_NEXT);\n+        registerKey(KeyBinding.ctrlShift(KeyCode.TAB), RichTextArea.Tags.FOCUS_PREVIOUS);\n+        registerKey(KeyBinding.shift(KeyCode.TAB), RichTextArea.Tags.FOCUS_PREVIOUS);\n+        registerKey(KeyCode.UP, RichTextArea.Tags.MOVE_UP);\n+        registerKey(KeyBinding.shift(KeyCode.UP), RichTextArea.Tags.SELECT_UP);\n+        registerKey(KeyBinding.shortcut(KeyCode.V), RichTextArea.Tags.PASTE);\n+        registerKey(KeyBinding.shiftShortcut(KeyCode.V), RichTextArea.Tags.PASTE_PLAIN_TEXT);\n+        registerKey(KeyBinding.shortcut(KeyCode.X), RichTextArea.Tags.CUT);\n+        registerKey(KeyCode.CUT, RichTextArea.Tags.CUT);\n+        registerKey(KeyBinding.shortcut(KeyCode.Z), RichTextArea.Tags.UNDO);\n+\n+        if (isMac()) {\n+            registerKey(KeyBinding.option(KeyCode.BACK_SPACE), RichTextArea.Tags.DELETE_WORD_PREVIOUS);\n+            registerKey(KeyBinding.shortcut(KeyCode.BACK_SPACE), RichTextArea.Tags.DELETE_PARAGRAPH_START);\n+            registerKey(KeyBinding.option(KeyCode.DELETE), RichTextArea.Tags.DELETE_WORD_NEXT_END);\n+            registerKey(KeyBinding.option(KeyCode.DOWN), RichTextArea.Tags.MOVE_PARAGRAPH_DOWN);\n+            registerKey(KeyBinding.shiftOption(KeyCode.DOWN), RichTextArea.Tags.SELECT_PARAGRAPH_DOWN);\n+            registerKey(KeyBinding.shiftShortcut(KeyCode.DOWN), RichTextArea.Tags.SELECT_TO_DOCUMENT_END);\n+            registerKey(KeyBinding.shortcut(KeyCode.DOWN), RichTextArea.Tags.MOVE_TO_DOCUMENT_END);\n+            registerKey(KeyBinding.option(KeyCode.LEFT), RichTextArea.Tags.MOVE_WORD_LEFT);\n+            registerKey(KeyBinding.shiftOption(KeyCode.LEFT), RichTextArea.Tags.SELECT_WORD_LEFT);\n+            registerKey(KeyBinding.shiftShortcut(KeyCode.LEFT), RichTextArea.Tags.SELECT_PARAGRAPH_START);\n+            registerKey(KeyBinding.shortcut(KeyCode.LEFT), RichTextArea.Tags.MOVE_TO_PARAGRAPH_START);\n+            registerKey(KeyBinding.option(KeyCode.RIGHT), RichTextArea.Tags.MOVE_WORD_RIGHT);\n+            registerKey(KeyBinding.shiftOption(KeyCode.RIGHT), RichTextArea.Tags.SELECT_WORD_RIGHT);\n+            registerKey(KeyBinding.shiftShortcut(KeyCode.RIGHT), RichTextArea.Tags.SELECT_PARAGRAPH_END);\n+            registerKey(KeyBinding.shortcut(KeyCode.RIGHT), RichTextArea.Tags.MOVE_TO_PARAGRAPH_END);\n+            registerKey(KeyBinding.builder(KeyCode.TAB).ctrl().option().shift().build(), RichTextArea.Tags.FOCUS_NEXT);\n+            registerKey(KeyBinding.option(KeyCode.UP), RichTextArea.Tags.MOVE_PARAGRAPH_UP);\n+            registerKey(KeyBinding.shiftOption(KeyCode.UP), RichTextArea.Tags.SELECT_PARAGRAPH_UP);\n+            registerKey(KeyBinding.shiftShortcut(KeyCode.UP), RichTextArea.Tags.SELECT_TO_DOCUMENT_START);\n+            registerKey(KeyBinding.shortcut(KeyCode.UP), RichTextArea.Tags.MOVE_TO_DOCUMENT_START);\n+            registerKey(KeyBinding.with(KeyCode.Z).shift().command().build(), RichTextArea.Tags.REDO);\n+        } else {\n+            registerKey(KeyBinding.ctrl(KeyCode.BACK_SLASH), RichTextArea.Tags.DESELECT);\n+            registerKey(KeyBinding.ctrl(KeyCode.BACK_SPACE), RichTextArea.Tags.DELETE_WORD_PREVIOUS);\n+            registerKey(KeyBinding.ctrl(KeyCode.DELETE), RichTextArea.Tags.DELETE_WORD_NEXT_START);\n+            registerKey(KeyBinding.ctrl(KeyCode.DOWN), RichTextArea.Tags.MOVE_PARAGRAPH_DOWN);\n+            registerKey(KeyBinding.ctrlShift(KeyCode.DOWN), RichTextArea.Tags.SELECT_PARAGRAPH_DOWN);\n+            registerKey(KeyBinding.ctrl(KeyCode.H), RichTextArea.Tags.BACKSPACE);\n+            registerKey(KeyBinding.ctrl(KeyCode.HOME), RichTextArea.Tags.MOVE_TO_DOCUMENT_START);\n+            registerKey(KeyBinding.ctrlShift(KeyCode.HOME), RichTextArea.Tags.SELECT_TO_DOCUMENT_START);\n+            registerKey(KeyBinding.shift(KeyCode.HOME), RichTextArea.Tags.SELECT_PARAGRAPH_START);\n+            registerKey(KeyBinding.ctrl(KeyCode.END), RichTextArea.Tags.MOVE_TO_DOCUMENT_END);\n+            registerKey(KeyBinding.ctrlShift(KeyCode.END), RichTextArea.Tags.SELECT_TO_DOCUMENT_END);\n+            registerKey(KeyBinding.shift(KeyCode.END), RichTextArea.Tags.SELECT_PARAGRAPH_END);\n+            registerKey(KeyBinding.ctrl(KeyCode.LEFT), RichTextArea.Tags.MOVE_WORD_LEFT);\n+            registerKey(KeyBinding.ctrlShift(KeyCode.LEFT), RichTextArea.Tags.SELECT_WORD_LEFT);\n+            registerKey(KeyBinding.ctrl(KeyCode.RIGHT), RichTextArea.Tags.MOVE_WORD_RIGHT);\n+            registerKey(KeyBinding.ctrlShift(KeyCode.RIGHT), RichTextArea.Tags.SELECT_WORD_RIGHT);\n+            registerKey(KeyBinding.ctrl(KeyCode.UP), RichTextArea.Tags.MOVE_PARAGRAPH_UP);\n+            registerKey(KeyBinding.ctrlShift(KeyCode.UP), RichTextArea.Tags.SELECT_PARAGRAPH_UP);\n+\n+            if (isWindows()) {\n+                registerKey(KeyBinding.ctrl(KeyCode.Y), RichTextArea.Tags.REDO);\n+            } else {\n+                registerKey(KeyBinding.ctrlShift(KeyCode.Z), RichTextArea.Tags.REDO);\n+            }\n+        }\n+\n+        Pane cp = vflow.getContentPane();\n+        cp.addEventFilter(MouseEvent.MOUSE_CLICKED, this::handleMouseClicked);\n+        cp.addEventFilter(MouseEvent.MOUSE_PRESSED, this::handleMousePressed);\n+        cp.addEventFilter(MouseEvent.MOUSE_RELEASED, this::handleMouseReleased);\n+        cp.addEventFilter(MouseEvent.MOUSE_DRAGGED, this::handleMouseDragged);\n+        cp.addEventFilter(ScrollEvent.SCROLL_STARTED, this::handleScrollEventStarted);\n+        cp.addEventHandler(ScrollEvent.SCROLL_FINISHED, this::handleScrollEventFinished);\n+        cp.addEventHandler(ScrollEvent.SCROLL, this::handleScrollEvent);\n+\n+        addHandler(KeyEvent.KEY_TYPED, true, this::handleKeyTyped);\n+        addHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, true, this::contextMenuRequested);\n+    }\n+\n+    protected boolean isRTL() {\n+        return (getControl().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT);\n+    }\n+\n+    protected String getPlainText(int modelIndex) {\n+        StyledTextModel m = getControl().getModel();\n+        return (m == null) ? \"\" : m.getPlainText(modelIndex);\n+    }\n+\n+    protected void handleKeyTyped(KeyEvent ev) {\n+        if (ev == null || ev.isConsumed()) {\n+            return;\n+        }\n+\n+        \/\/ TODO something about consuming all key presses (yes) and key releases (not really)\n+        \/\/ in TextInputControlBehavior:194\n+\n+        String character = getValidKeyTyped(ev);\n+        if (character != null) {\n+            vflow.setSuppressBlink(true);\n+            boolean consume = handleTypedChar(character);\n+            if (consume) {\n+                ev.consume();\n+            }\n+            vflow.setSuppressBlink(false);\n+        }\n+    }\n+\n+    protected boolean handleTypedChar(String typed) {\n+        if (canEdit()) {\n+            RichTextArea control = getControl();\n+            StyledTextModel m = control.getModel();\n+            TextPos start = control.getCaretPosition();\n+            if (start != null) {\n+                TextPos end = control.getAnchorPosition();\n+                if (end == null) {\n+                    end = start;\n+                }\n+\n+                TextPos p = m.replace(vflow, start, end, typed, true);\n+                moveCaret(p, false);\n+\n+                clearPhantomX();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected String getValidKeyTyped(KeyEvent ev) {\n+        if (ev.getEventType() == KeyEvent.KEY_TYPED) {\n+            String ch = ev.getCharacter();\n+            if (ch.length() > 0) {\n+                \/\/ see TextInputControlBehavior:395\n+                \/\/ Filter out control keys except control+Alt on PC or Alt on Mac\n+                if (ev.isControlDown() || ev.isAltDown() || (PlatformUtil.isMac() && ev.isMetaDown())) {\n+                    if (!((ev.isControlDown() || PlatformUtil.isMac()) && ev.isAltDown())) {\n+                        return null;\n+                    }\n+                }\n+\n+                \/\/ Ignore characters in the control range and the ASCII delete\n+                \/\/ character as well as meta key presses\n+                if (ch.charAt(0) > 0x1F && ch.charAt(0) != 0x7F && !ev.isMetaDown()) {\n+                    \/\/ Not sure about this one (original comment, not sure about it either)\n+                    return ch;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/** returns true if both control and model are editable *\/\n+    protected boolean canEdit() {\n+        RichTextArea control = getControl();\n+        if (control.isEditable()) {\n+            StyledTextModel m = control.getModel();\n+            if (m != null) {\n+                return m.isUserEditable();\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void insertTab() {\n+        if (canEdit()) {\n+            handleTypedChar(\"\\t\");\n+        } else {\n+            traverseNext();\n+        }\n+    }\n+\n+    public void insertLineBreak() {\n+        if (canEdit()) {\n+            RichTextArea control = getControl();\n+            StyledTextModel m = control.getModel();\n+            TextPos start = control.getCaretPosition();\n+            if (start == null) {\n+                return;\n+            }\n+            TextPos end = control.getAnchorPosition();\n+            if (end == null) {\n+                return;\n+            }\n+\n+            TextPos pos = m.replace(vflow, start, end, StyledInput.of(\"\\n\"), true);\n+            moveCaret(pos, false);\n+            clearPhantomX();\n+        }\n+    }\n+\n+    protected void handleMouseClicked(MouseEvent ev) {\n+        if (ev.getButton() == MouseButton.PRIMARY) {\n+            int clicks = ev.getClickCount();\n+            switch (clicks) {\n+            case 2:\n+                getControl().selectWord();\n+                break;\n+            case 3:\n+                getControl().selectParagraph();\n+                break;\n+            }\n+        }\n+    }\n+\n+    protected void handleMousePressed(MouseEvent ev) {\n+        if (ev.isPopupTrigger() || (ev.getButton() != MouseButton.PRIMARY)) {\n+            return;\n+        }\n+\n+        TextPos pos = getTextPosition(ev);\n+        if (pos == null) {\n+            return;\n+        }\n+\n+        vflow.setSuppressBlink(true);\n+\n+        RichTextArea control = getControl();\n+        if (ev.isShiftDown()) {\n+            \/\/ expand selection from the anchor point to the current position\n+            \/\/ clearing existing selection\n+            control.extendSelection(pos);\n+        } else {\n+            control.select(pos, pos);\n+        }\n+\n+        if (contextMenu.isShowing()) {\n+            contextMenu.hide();\n+        }\n+\n+        control.requestFocus();\n+    }\n+\n+    protected void handleMouseReleased(MouseEvent ev) {\n+        stopAutoScroll();\n+        \/\/vflow.scrollCaretToVisible();\n+        vflow.setSuppressBlink(false);\n+        clearPhantomX();\n+    }\n+\n+    protected void handleMouseDragged(MouseEvent ev) {\n+        if (!(ev.getButton() == MouseButton.PRIMARY)) {\n+            return;\n+        }\n+\n+        double y = ev.getY();\n+        if (y < 0.0) {\n+            \/\/ above visible area\n+            autoScroll(y);\n+            return;\n+        } else if (y > vflow.getViewPortHeight()) {\n+            \/\/ below visible area\n+            autoScroll(y - vflow.getViewPortHeight());\n+            return;\n+        } else {\n+            stopAutoScroll();\n+        }\n+\n+        TextPos pos = getTextPosition(ev);\n+        getControl().extendSelection(pos);\n+    }\n+\n+    private void handleScrollEventStarted(ScrollEvent ev) {\n+        scrollStarted = true;\n+    }\n+\n+    private void handleScrollEventFinished(ScrollEvent ev) {\n+        scrollStarted = false;\n+    }\n+\n+    private void handleScrollEvent(ScrollEvent ev) {\n+        RichTextArea control = getControl();\n+        double dx = ev.getDeltaX();\n+        if (dx != 0.0) {\n+            \/\/ horizontal\n+            if (!control.isWrapText() && !control.isUseContentWidth()) {\n+                if(scrollStarted) {\n+                    \/\/ trackpad\n+                    vflow.scrollHorizontalPixels(-ev.getDeltaX());\n+                } else {\n+                    \/\/ mouse\n+                    double f = Params.SCROLL_SHEEL_BLOCK_SIZE_HORIZONTAL;\n+                    if (dx >= 0) {\n+                        f = -f;\n+                    }\n+                    vflow.scrollHorizontalFraction(f);\n+                }\n+                ev.consume();\n+            }\n+        }\n+\n+        double dy = ev.getDeltaY();\n+        if (dy != 0.0) {\n+            \/\/ vertical\n+            if (!control.isUseContentHeight()) {\n+                if(scrollStarted) {\n+                    \/\/ trackpad\n+                    vflow.scrollVerticalPixels(-dy);\n+                } else {\n+                    \/\/ mouse\n+                    if (ev.isShortcutDown()) {\n+                        \/\/ page up \/ page down\n+                        if (dy >= 0) {\n+                            vflow.pageUp();\n+                        } else {\n+                            vflow.pageDown();\n+                        }\n+                    } else {\n+                        \/\/ block scroll\n+                        double f = Params.SCROLL_WHEEL_BLOCK_SIZE_VERTICAL;\n+                        if (dy >= 0) {\n+                            f = -f;\n+                        }\n+                        vflow.scrollVerticalFraction(f);\n+                    }\n+                }\n+                ev.consume();\n+            }\n+        }\n+    }\n+\n+    protected TextPos getTextPosition(MouseEvent ev) {\n+        double x = ev.getScreenX();\n+        double y = ev.getScreenY();\n+        return getControl().getTextPosition(x, y);\n+    }\n+\n+    protected void stopAutoScroll() {\n+        autoScrollTimer.stop();\n+    }\n+\n+    protected void autoScroll(double delta) {\n+        autoScrollUp = (delta < 0.0);\n+        fastAutoScroll = Math.abs(delta) > Params.AUTO_SCROLL_FAST_THRESHOLD;\n+        autoScrollTimer.play();\n+    }\n+\n+    protected void autoScroll() {\n+        RichTextArea control = getControl();\n+        if (control.isUseContentHeight()) {\n+            return;\n+        }\n+        double delta = fastAutoScroll ? Params.AUTO_SCROLL_STEP_FAST : Params.AUTO_SCROLL_STEP_SLOW;\n+        if (autoScrollUp) {\n+            delta = -delta;\n+        }\n+        vflow.scrollVerticalPixels(delta, true);\n+\n+        double x = Math.max(0.0, phantomX + vflow.getOffsetX());\n+        double y = autoScrollUp ? 0.0 : vflow.getViewPortHeight();\n+\n+        vflow.scrollToVisible(x, y);\n+\n+        TextPos p = vflow.getTextPosLocal(x, y);\n+        control.extendSelection(p);\n+    }\n+\n+    public void pageDown() {\n+        moveLine(vflow.getViewPortHeight(), false);\n+    }\n+\n+    public void pageUp() {\n+        moveLine(-vflow.getViewPortHeight(), false);\n+    }\n+\n+    public void moveRight() {\n+        moveCharacter(true, false);\n+    }\n+\n+    public void moveLeft() {\n+        moveCharacter(false, false);\n+    }\n+\n+    public void moveParagraphStart() {\n+        moveCaret(false, this::paragraphStart);\n+    }\n+\n+    public void moveParagraphEnd() {\n+        moveCaret(false, this::paragraphEnd);\n+    }\n+\n+    public void selectParagraphStart() {\n+        moveCaret(true, this::paragraphStart);\n+    }\n+\n+    public void selectParagraphEnd() {\n+        moveCaret(true, this::paragraphEnd);\n+    }\n+\n+    public void moveParagraphDown() {\n+        moveCaret(false, this::paragraphDown);\n+    }\n+\n+    public void selectParagraphDown() {\n+        moveCaret(true, this::paragraphDown);\n+    }\n+\n+    public void moveParagraphUp() {\n+        moveCaret(false, this::paragraphUp);\n+    }\n+\n+    public void selectParagraphUp() {\n+        moveCaret(true, this::paragraphUp);\n+    }\n+\n+    private TextPos paragraphDown(RichTextArea control, TextPos caret) {\n+        int ix = caret.index();\n+        TextPos end = control.getParagraphEnd(ix);\n+        if (caret.isSameInsertionIndex(end)) {\n+            ix++;\n+            if (ix >= control.getParagraphCount()) {\n+                return null;\n+            }\n+            return control.getParagraphEnd(ix);\n+        }\n+        return end;\n+    }\n+\n+    public TextPos paragraphUp(RichTextArea control, TextPos caret) {\n+        int ix = caret.index();\n+        TextPos p = new TextPos(ix, 0);\n+        if (caret.isSameInsertionIndex(p)) {\n+            --ix;\n+            if (ix < 0) {\n+                return null;\n+            }\n+            p = new TextPos(ix, 0);\n+        }\n+        return p;\n+    }\n+\n+    private TextPos paragraphEnd(RichTextArea control, TextPos caret) {\n+        int ix = caret.index();\n+        return control.getParagraphEnd(ix);\n+    }\n+\n+    private void moveCaret(boolean extSelection, BiFunction<RichTextArea, TextPos, TextPos> h) {\n+        RichTextArea control = getControl();\n+        TextPos caret = control.getCaretPosition();\n+        if (caret != null) {\n+            TextPos p = h.apply(control, caret);\n+            if (p != null) {\n+                clearPhantomX();\n+                moveCaret(p, extSelection);\n+            }\n+        }\n+    }\n+\n+    private TextPos paragraphStart(RichTextArea control, TextPos caret) {\n+        return new TextPos(caret.index(), 0);\n+    }\n+\n+    public void moveUp() {\n+        moveLine(-1.0, false);\n+    }\n+\n+    public void moveDown() {\n+        moveLine(1.0, false);\n+    }\n+\n+    \/**\n+     * Moves the caret to before the first character of the text, also clearing the selection.\n+     *\/\n+    public void moveDocumentStart() {\n+        RichTextArea control = getControl();\n+        control.select(TextPos.ZERO);\n+    }\n+\n+    \/**\n+     * Moves the caret to after the last character of the text, also clearing the selection.\n+     *\/\n+    public void moveDocumentEnd() {\n+        RichTextArea control = getControl();\n+        TextPos pos = control.getDocumentEnd();\n+        control.select(pos);\n+    }\n+\n+    protected void moveLine(double deltaPixels, boolean extendSelection) {\n+        CaretInfo c = vflow.getCaretInfo();\n+        if (c == null) {\n+            return;\n+        }\n+\n+        double sp = c.getLineSpacing();\n+        \/\/ TODO split caret?\n+        double x = (c.getMinX() + c.getMaxX()) \/ 2.0;\n+        if (phantomX < 0) {\n+            \/\/ phantomX is unclear in the case of split caret\n+            phantomX = x;\n+        } else {\n+            x = phantomX;\n+        }\n+\n+        boolean up = (deltaPixels < 0);\n+        double y0 = up ? c.getMinY() : c.getMaxY();\n+        double y = up ?\n+            c.getMinY() + deltaPixels - sp - 0.5:\n+            c.getMaxY() + deltaPixels + sp + 0.5;\n+\n+        \/\/ TODO\n+        \/\/ check whether the new caret y position changed, unless it's TextPos.ZERO when going up, or EOF if going down\n+\n+        TextPos p = vflow.getTextPosLocal(x, y);\n+        if (p != null) {\n+            moveCaret(p, extendSelection);\n+        }\n+    }\n+\n+    protected void moveCharacter(boolean moveRight, boolean extendSelection) {\n+        \/\/ TODO bidi\n+        RichTextArea control = getControl();\n+        TextPos caret = control.getCaretPosition();\n+        if (caret == null) {\n+            return;\n+        }\n+\n+        clearPhantomX();\n+\n+        if (!extendSelection) {\n+            TextPos ca = control.getCaretPosition();\n+            TextPos an = control.getAnchorPosition();\n+            int d = ca.compareTo(an);\n+            \/\/ jump over selection if it exists\n+            if (d < 0) {\n+                moveCaret(moveRight ? an : ca, extendSelection);\n+                return;\n+            } else if (d > 0) {\n+                moveCaret(moveRight ? ca : an, extendSelection);\n+                return;\n+            }\n+        }\n+\n+        TextPos p = nextCharacterVisually(caret, moveRight);\n+        if (p != null) {\n+            moveCaret(p, extendSelection);\n+        }\n+    }\n+\n+    protected TextPos nextCharacterVisually(TextPos start, boolean moveRight) {\n+        if (isRTL()) {\n+            moveRight = !moveRight;\n+        }\n+\n+        RichTextArea control = getControl();\n+        TextCell cell = vflow.getCell(start.index());\n+        int cix = start.offset();\n+        if (moveRight) {\n+            cix++;\n+            if (cix > cell.getTextLength()) {\n+                int ix = cell.getIndex() + 1;\n+                TextPos p;\n+                if (ix < control.getParagraphCount()) {\n+                    \/\/ next line\n+                    p = new TextPos(ix, 0);\n+                } else {\n+                    \/\/ end of last paragraph w\/o newline\n+                    p = new TextPos(cell.getIndex(), cell.getTextLength());\n+                }\n+                return p;\n+            }\n+        } else {\n+            if (start.offset() == 0) {\n+                int ix = cell.getIndex() - 1;\n+                if (ix >= 0) {\n+                    \/\/ end of prev line\n+                    return control.getParagraphEnd(ix);\n+                }\n+                return null;\n+            }\n+        }\n+\n+        \/\/ using default locale, same as TextInputControl.backward() for example\n+        BreakIterator br = BreakIterator.getCharacterInstance();\n+        String text = getPlainText(cell.getIndex());\n+        br.setText(text);\n+        int off = start.offset();\n+        try {\n+            int ix = moveRight ? br.following(off) : br.preceding(off);\n+            if (ix == BreakIterator.DONE) {\n+                System.err.println(\" --- SHOULD NOT HAPPEN: BreakIterator.DONE off=\" + off); \/\/ FIX\n+                return null;\n+            }\n+            return new TextPos(start.index(), ix);\n+        } catch(Exception e) {\n+            \/\/ TODO need to use a logger!\n+            System.err.println(\"offset=\" + off + \" text=[\" + text + \"]\"); \/\/ FIX\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Moves the caret and anchor to the new position, unless {@code extendSelection} is true, in which case\n+     * extend selection from the existing anchor to the newly set caret position.\n+     * @param p text position\n+     * @param extendSelection specifies whether to clear (false) or extend (true) any existing selection\n+     *\/\n+    protected void moveCaret(TextPos p, boolean extendSelection) {\n+        RichTextArea control = getControl();\n+        if (extendSelection) {\n+            control.extendSelection(p);\n+        } else {\n+            control.select(p, p);\n+        }\n+    }\n+\n+    public void clearPhantomX() {\n+        phantomX = -1.0;\n+    }\n+\n+    public void selectLeft() {\n+        moveCharacter(false, true);\n+    }\n+\n+    public void selectRight() {\n+        moveCharacter(true, true);\n+    }\n+\n+    public void selectUp() {\n+        moveLine(-1.0, true);\n+    }\n+\n+    public void selectDown() {\n+        moveLine(1.0, true);\n+    }\n+\n+    public void selectPageDown() {\n+        moveLine(vflow.getViewPortHeight(), true);\n+    }\n+\n+    public void selectPageUp() {\n+        moveLine(-vflow.getViewPortHeight(), true);\n+    }\n+\n+    public void selectAll() {\n+        RichTextArea control = getControl();\n+        TextPos end = control.getDocumentEnd();\n+        control.select(TextPos.ZERO, end);\n+        clearPhantomX();\n+    }\n+\n+    \/** selects from the anchor position to the document start *\/\n+    public void selectDocumentStart() {\n+        getControl().extendSelection(TextPos.ZERO);\n+    }\n+\n+    \/** selects from the anchor position to the document end *\/\n+    public void selectDocumentEnd() {\n+        RichTextArea control = getControl();\n+        TextPos pos = control.getDocumentEnd();\n+        control.extendSelection(pos);\n+    }\n+\n+    public void selectWord() {\n+        RichTextArea control = getControl();\n+        TextPos caret = control.getCaretPosition();\n+        if (caret == null) {\n+            return;\n+        }\n+\n+        int index = caret.index();\n+        String text = getPlainText(index);\n+\n+        \/\/ using default locale, same as TextInputControl.backward() for example\n+        BreakIterator br = BreakIterator.getWordInstance();\n+        br.setText(text);\n+        int off = caret.offset();\n+        try {\n+            int off0 = br.preceding(off);\n+            if (off0 == BreakIterator.DONE) {\n+                \/\/System.err.println(\" --- no previous word off=\" + off); \/\/ FIX\n+                return;\n+            }\n+\n+            int off1 = br.following(off);\n+            if (off1 == BreakIterator.DONE) {\n+                \/\/System.err.println(\" --- no following word off=\" + off); \/\/ FIX\n+                return;\n+            }\n+\n+            TextPos p0 = new TextPos(index, off0);\n+            TextPos p1 = new TextPos(index, off1);\n+            control.select(p0, p1);\n+        } catch (Exception e) {\n+            \/\/ TODO need to use a logger!\n+            System.err.println(\"offset=\" + off + \" text=[\" + text + \"]\");\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void selectParagraph() {\n+        RichTextArea control = getControl();\n+        TextPos p = control.getCaretPosition();\n+        if (p != null) {\n+            int ix = p.index();\n+            TextPos an = new TextPos(ix, 0);\n+            TextPos ca = control.getParagraphEnd(ix);\n+            control.select(an, ca);\n+        }\n+    }\n+\n+    public void backspace() {\n+        if (canEdit()) {\n+            RichTextArea control = getControl();\n+            if (control.hasNonEmptySelection()) {\n+                deleteSelection();\n+            } else {\n+                TextPos p = control.getCaretPosition();\n+                if (p == null) {\n+                    return;\n+                }\n+\n+                int ix = p.index();\n+\n+                TextPos start;\n+                if (p.offset() == 0) {\n+                    if (ix == 0) {\n+                        return;\n+                    }\n+                    int off = getPlainText(ix - 1).length();\n+                    start = new TextPos(ix - 1, off);\n+                } else {\n+                    String text = getPlainText(p.index());\n+                    \/\/ Do not use charIterator here, because we do want to\n+                    \/\/ break up clusters when deleting backwards.\n+                    int off = Character.offsetByCodePoints(text, p.offset(), -1);\n+                    start = new TextPos(ix, off);\n+                }\n+\n+                control.getModel().replace(vflow, start, p, StyledInput.EMPTY, true);\n+                moveCaret(start, false);\n+                clearPhantomX();\n+            }\n+        }\n+    }\n+\n+    public void delete() {\n+        if (canEdit()) {\n+            RichTextArea control = getControl();\n+            if (control.hasNonEmptySelection()) {\n+                deleteSelection();\n+            } else {\n+                TextPos start = control.getCaretPosition();\n+                TextPos end = nextCharacterVisually(start, true);\n+                if (end != null) {\n+                    control.getModel().replace(vflow, start, end, StyledInput.EMPTY, true);\n+                    moveCaret(start, false);\n+                    clearPhantomX();\n+                }\n+            }\n+        }\n+    }\n+\n+    private SelInfo sel() {\n+        return SelInfo.get(getControl());\n+    }\n+\n+    private TextPos clamp(TextPos p) {\n+        return getControl().getModel().clamp(p);\n+    }\n+\n+    public void deleteParagraph() {\n+        if (canEdit()) {\n+            SelInfo sel = sel();\n+            if (sel != null) {\n+                int ix0 = sel.getMin().index();\n+                int ix1 = sel.getMax().index();\n+\n+                TextPos p0 = new TextPos(ix0, 0);\n+                TextPos p1 = clamp(new TextPos(ix1 + 1, 0));\n+                RichTextArea control = getControl();\n+                control.getModel().replace(vflow, p0, p1, StyledInput.EMPTY, true);\n+                clearPhantomX();\n+                moveCaret(p0, false);\n+            }\n+        }\n+    }\n+\n+    public void deleteParagraphStart() {\n+        deleteIgnoreSelection(this::paragraphStart);\n+    }\n+\n+    protected void deleteSelection() {\n+        SelInfo sel = sel();\n+        if (sel != null) {\n+            TextPos start = sel.getMin();\n+            TextPos end = sel.getMax();\n+            RichTextArea control = getControl();\n+            control.getModel().replace(vflow, start, end, StyledInput.EMPTY, true);\n+            clearPhantomX();\n+            moveCaret(start, false);\n+        }\n+    }\n+\n+    protected void deselect() {\n+        RichTextArea control = getControl();\n+        TextPos p = control.getCaretPosition();\n+        if (p != null) {\n+            clearPhantomX();\n+            moveCaret(p, false);\n+        }\n+    }\n+\n+    \/\/ see TextAreaBehavior:338\n+    public void contextMenuRequested(ContextMenuEvent ev) {\n+        RichTextArea control = getControl();\n+        if (contextMenu.isShowing()) {\n+            contextMenu.hide();\n+        } else if (control.getContextMenu() == null && control.getOnContextMenuRequested() == null) {\n+            double screenX = ev.getScreenX();\n+            double screenY = ev.getScreenY();\n+            double sceneX = ev.getSceneX();\n+\n+            \/* TODO\n+            if (NewAPI.isTouchSupported()) {\n+                 Point2D menuPos;\n+                if (control.getSelection().getLength() == 0) {\n+                    skin.positionCaret(skin.getIndex(ev.getX(), ev.getY()), false);\n+                    menuPos = skin.getMenuPosition();\n+                } else {\n+                    menuPos = skin.getMenuPosition();\n+                    if (menuPos != null && (menuPos.getX() <= 0 || menuPos.getY() <= 0)) {\n+                        skin.positionCaret(skin.getIndex(ev.getX(), ev.getY()), false);\n+                        menuPos = skin.getMenuPosition();\n+                    }\n+                }\n+\n+                if (menuPos != null) {\n+                    Point2D p = control.localToScene(menuPos);\n+                    Scene scene = control.getScene();\n+                    Window window = scene.getWindow();\n+                    Point2D location = new Point2D(window.getX() + scene.getX() + p.getX(),\n+                        window.getY() + scene.getY() + p.getY());\n+                    screenX = location.getX();\n+                    sceneX = p.getX();\n+                    screenY = location.getY();\n+                }\n+            }\n+            *\/\n+\n+            populateContextMenu();\n+\n+            double menuWidth = contextMenu.prefWidth(-1);\n+            double menuX = screenX - (RichUtils.isTouchSupported() ? (menuWidth \/ 2) : 0);\n+            Screen currentScreen = Utils.getScreenForPoint(screenX, 0);\n+            Rectangle2D bounds = currentScreen.getBounds();\n+\n+            \/\/ what is this??\n+            if (menuX < bounds.getMinX()) {\n+                control.getProperties().put(\"CONTEXT_MENU_SCREEN_X\", screenX);\n+                control.getProperties().put(\"CONTEXT_MENU_SCENE_X\", sceneX);\n+                contextMenu.show(control, bounds.getMinX(), screenY);\n+            } else if (screenX + menuWidth > bounds.getMaxX()) {\n+                double leftOver = menuWidth - (bounds.getMaxX() - screenX);\n+                control.getProperties().put(\"CONTEXT_MENU_SCREEN_X\", screenX);\n+                control.getProperties().put(\"CONTEXT_MENU_SCENE_X\", sceneX);\n+                contextMenu.show(control, screenX - leftOver, screenY);\n+            } else {\n+                control.getProperties().put(\"CONTEXT_MENU_SCREEN_X\", 0);\n+                control.getProperties().put(\"CONTEXT_MENU_SCENE_X\", 0);\n+                contextMenu.show(control, menuX, screenY);\n+            }\n+        }\n+\n+        ev.consume();\n+    }\n+\n+    \/\/ TODO this might belong to the control!\n+    protected void populateContextMenu() {\n+        RichTextArea control = getControl();\n+        boolean sel = control.hasNonEmptySelection();\n+        boolean paste = (findFormatForPaste() != null);\n+        boolean editable = control.canEdit();\n+\n+        ObservableList<MenuItem> items = contextMenu.getItems();\n+        items.clear();\n+\n+        MenuItem m;\n+        items.add(m = new MenuItem(\"Undo\"));\n+        m.setOnAction((ev) -> control.undo());\n+        m.setDisable(!control.isUndoable());\n+\n+        items.add(m = new MenuItem(\"Redo\"));\n+        m.setOnAction((ev) -> control.redo());\n+        m.setDisable(!control.isRedoable());\n+\n+        items.add(new SeparatorMenuItem());\n+\n+        items.add(m = new MenuItem(\"Cut\"));\n+        m.setOnAction((ev) -> control.cut());\n+        m.setDisable(!sel || !editable);\n+\n+        items.add(m = new MenuItem(\"Copy\"));\n+        m.setOnAction((ev) -> control.copy());\n+        m.setDisable(!sel);\n+\n+        items.add(m = new MenuItem(\"Paste\"));\n+        m.setOnAction((ev) -> control.paste());\n+        m.setDisable(!paste || !editable);\n+\n+        items.add(new SeparatorMenuItem());\n+\n+        items.add(m = new MenuItem(\"Select All\"));\n+        m.setOnAction((ev) -> control.selectAll());\n+    }\n+\n+    public void copy() {\n+        copy(false);\n+    }\n+\n+    public void cut() {\n+        copy(true);\n+    }\n+\n+    public void paste() {\n+        if (canEdit()) {\n+            DataFormat f = findFormatForPaste();\n+            if (f != null) {\n+                pasteLocal(f);\n+            }\n+        }\n+    }\n+\n+    public void paste(DataFormat f) {\n+        if (canEdit()) {\n+            Clipboard c = Clipboard.getSystemClipboard();\n+            if (c.hasContent(f)) {\n+                pasteLocal(f);\n+            }\n+        }\n+    }\n+\n+    public void pastePlainText() {\n+        paste(DataFormat.PLAIN_TEXT);\n+    }\n+\n+    \/**\n+     * returns a format that can be imported by a model, based on the clipboard content and model being editable.\n+     *\/\n+    protected DataFormat findFormatForPaste() {\n+        if (canEdit()) {\n+            StyledTextModel m = getControl().getModel();\n+            DataFormat[] fs = m.getSupportedDataFormats(false);\n+            if (fs.length > 0) {\n+                for (DataFormat f : fs) {\n+                    if (Clipboard.getSystemClipboard().hasContent(f)) {\n+                        return f;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private void pasteLocal(DataFormat f) {\n+        SelInfo sel = sel();\n+        if (sel != null) {\n+            RichTextArea control = getControl();\n+            TextPos start = sel.getMin();\n+            TextPos end = sel.getMax();\n+\n+            StyledTextModel m = control.getModel();\n+            DataFormatHandler h = m.getDataFormatHandler(f, false);\n+            Object x = Clipboard.getSystemClipboard().getContent(f);\n+            String text;\n+            if (x instanceof String s) {\n+                text = s;\n+            } else {\n+                return;\n+            }\n+\n+            StyleAttributeMap a = control.getActiveStyleAttributeMap();\n+            try (StyledInput in = h.createStyledInput(text, a)) {\n+                TextPos p = m.replace(vflow, start, end, in, true);\n+                moveCaret(p, false);\n+            } catch (IOException e) {\n+                RichUtils.provideErrorFeedback(control, e);\n+            }\n+        }\n+    }\n+\n+    protected void copy(boolean cut) {\n+        RichTextArea control = getControl();\n+        if (control.hasNonEmptySelection()) {\n+            StyledTextModel m = control.getModel(); \/\/ non null at this point\n+            DataFormat[] fs = m.getSupportedDataFormats(true);\n+            if (fs.length > 0) {\n+                SelInfo sel = sel();\n+                if (sel == null) {\n+                    return;\n+                }\n+\n+                TextPos start = sel.getMin();\n+                TextPos end = sel.getMax();\n+\n+                try {\n+                    ClipboardContent c = new ClipboardContent();\n+                    for (DataFormat f : fs) {\n+                        DataFormatHandler h = m.getDataFormatHandler(f, true);\n+                        Object v = h.copy(m, vflow, start, end);\n+                        if (v != null) {\n+                            c.put(f, v);\n+                        }\n+                    }\n+                    Clipboard.getSystemClipboard().setContent(c);\n+\n+                    if (canEdit() && cut) {\n+                        deleteSelection();\n+                    }\n+                } catch(Exception | OutOfMemoryError e) {\n+                    RichUtils.provideErrorFeedback(control, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void copy(DataFormat f) {\n+        RichTextArea control = getControl();\n+        try {\n+            if (control.hasNonEmptySelection()) {\n+                StyledTextModel m = control.getModel(); \/\/ not null at this point\n+                DataFormatHandler h = m.getDataFormatHandler(f, true);\n+                if (h != null) {\n+                    SelInfo sel = sel();\n+                    if (sel == null) {\n+                        return;\n+                    }\n+\n+                    TextPos start = sel.getMin();\n+                    TextPos end = sel.getMax();\n+\n+                    Object v = h.copy(m, vflow, start, end);\n+                    ClipboardContent c = new ClipboardContent();\n+                    c.put(f, v);\n+                    Clipboard.getSystemClipboard().setContent(c);\n+                }\n+            }\n+        } catch(Exception | OutOfMemoryError e) {\n+            RichUtils.provideErrorFeedback(control, e);\n+        }\n+    }\n+\n+    \/**\n+     * Moves the caret to the beginning of previous word. This function\n+     * also has the effect of clearing the selection.\n+     *\/\n+    public void previousWord() {\n+        moveCaret(false, this::previousWord);\n+    }\n+\n+    \/** moves the caret to the beginning of the previos word (LTR) or next word (RTL) *\/\n+    public void leftWord() {\n+        leftWord(false);\n+    }\n+\n+    \/** moves the caret to the beginning of the next word (LTR) or previous word (RTL) *\/\n+    public void rightWord() {\n+        rightWord(false);\n+    }\n+\n+    \/**\n+     * Moves the caret to the beginning of next word. This function\n+     * also has the effect of clearing the selection.\n+     *\/\n+    public void nextWord() {\n+        moveCaret(false, this::nextWordBeg);\n+    }\n+\n+    \/**\n+     * Moves the caret to the end of the next word. This function\n+     * also has the effect of clearing the selection.\n+     *\/\n+    public void nextWordEnd() {\n+        moveCaret(false, this::nextWordEnd);\n+    }\n+\n+    \/**\n+     * Moves the caret to the beginning of previous word. This does not cause\n+     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is\n+     * moved to the beginning of previous word.\n+     *\/\n+    public void selectWordPrevious() {\n+        moveCaret(true, this::previousWord);\n+    }\n+\n+    \/**\n+     * Moves the caret to the beginning of next word. This does not cause\n+     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is\n+     * moved to the beginning of next word.\n+     *\/\n+    public void selectWordNext() {\n+        moveCaret(true, this::nextWordBeg);\n+    }\n+\n+    \/**\n+     * Moves the caret to the end of the next word. This does not cause\n+     * the selection to be cleared.\n+     *\/\n+    public void selectNextWordEnd() {\n+        moveCaret(true, this::nextWordEnd);\n+    }\n+\n+    \/**\n+     * Moves the caret to the beginning of previous word (LTR) or next word (LTR).\n+     * This does not cause\n+     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is\n+     * moved to the beginning of previous word.\n+     *\/\n+    public void selectWordLeft() {\n+        leftWord(true);\n+    }\n+\n+    \/**\n+     * Moves the caret to the beginning of next word (LTR) or previous word (RTL).\n+     * This does not cause\n+     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is\n+     * moved to the beginning of next word.\n+     *\/\n+    public void selectWordRight() {\n+        rightWord(true);\n+    }\n+\n+    protected void leftWord(boolean extendSelection) {\n+        if (isRTLText()) {\n+            if (isWindows()) {\n+                moveCaret(extendSelection, this::nextWordBeg);\n+            } else {\n+                moveCaret(extendSelection, this::nextWordEnd);\n+            }\n+        } else {\n+            moveCaret(extendSelection, this::previousWord);\n+        }\n+    }\n+\n+    protected void rightWord(boolean extendSelection) {\n+        if (isRTLText()) {\n+            moveCaret(extendSelection, this::previousWord);\n+        } else {\n+            if (isWindows()) {\n+                moveCaret(extendSelection, this::nextWordBeg);\n+            } else {\n+                moveCaret(extendSelection, this::nextWordEnd);\n+            }\n+        }\n+    }\n+\n+    protected TextPos previousWord(RichTextArea control, TextPos pos) {\n+        int index = pos.index();\n+        int offset = pos.offset();\n+        BreakIterator br = null;\n+\n+        for (;;) {\n+            if ((index == 0) && (offset <= 0)) {\n+                return TextPos.ZERO;\n+            }\n+\n+            String text = getPlainText(index);\n+            if (text.length() == 0) {\n+                index--;\n+                offset = Integer.MAX_VALUE;\n+                continue;\n+            }\n+\n+            if (br == null) {\n+                br = BreakIterator.getWordInstance();\n+            }\n+            br.setText(text);\n+\n+            int len = text.length();\n+            int off = br.preceding(Utils.clamp(0, offset, len));\n+\n+            while (off != BreakIterator.DONE && !RichUtils.isLetterOrDigit(text, off)) {\n+                off = br.preceding(Utils.clamp(0, off, len));\n+            }\n+\n+            if (off < 0) {\n+                index--;\n+                offset = Integer.MAX_VALUE;\n+                continue;\n+            }\n+            return new TextPos(index, off);\n+        }\n+    }\n+\n+    \/\/ skips empty paragraphs\n+    protected TextPos nextWordBeg(RichTextArea control, TextPos pos) {\n+        int index = pos.index();\n+        int offset = pos.offset();\n+        boolean skipEmpty = true;\n+\n+        for (;;) {\n+            TextPos end = control.getDocumentEnd();\n+            \/\/ this could be a isSameOrAfter(index, off) method in TextPos\n+            if ((index == end.index()) && (offset >= end.offset())) {\n+                return end;\n+            } else if (index > end.index()) {\n+                return end;\n+            }\n+\n+            String text = getPlainText(index);\n+            if (text.length() == 0) {\n+                if (skipEmpty) {\n+                    index++;\n+                }\n+                return new TextPos(index, 0);\n+            }\n+\n+            BreakIterator br = BreakIterator.getWordInstance();\n+            br.setText(text);\n+\n+            int len = text.length();\n+            if (offset == len) {\n+                return new TextPos(++index, 0);\n+            }\n+\n+            int next = br.following(Utils.clamp(0, offset, len));\n+            if ((next == BreakIterator.DONE) || (next == len)) {\n+                return new TextPos(index, len);\n+            } else {\n+                while (next != BreakIterator.DONE) {\n+                    boolean inWord = RichUtils.isLetterOrDigit(text, next);\n+                    if (inWord) {\n+                        return new TextPos(index, next);\n+                    }\n+                    next = br.next();\n+                }\n+            }\n+\n+            index++;\n+            offset = 0;\n+            skipEmpty = false;\n+        }\n+    }\n+\n+    \/\/ skips empty paragraphs\n+    protected TextPos nextWordEnd(RichTextArea control, TextPos pos) {\n+        int index = pos.index();\n+        int offset = pos.offset();\n+        boolean skipEmpty = true;\n+\n+        for (;;) {\n+            TextPos end = control.getDocumentEnd();\n+            \/\/ this could be a isSameOrAfter(index, off) method in TextPos\n+            if ((index == end.index()) && (offset >= end.offset())) {\n+                return end;\n+            } else if (index > end.index()) {\n+                return end;\n+            }\n+\n+            String text = getPlainText(index);\n+            if (text.length() == 0) {\n+                if (skipEmpty) {\n+                    index++;\n+                }\n+                return new TextPos(index, 0);\n+            }\n+\n+            BreakIterator br = BreakIterator.getWordInstance();\n+            br.setText(text);\n+\n+            boolean inWord = RichUtils.isLetterOrDigit(text, offset);\n+            int len = text.length();\n+            int next = br.following(Utils.clamp(0, offset, len));\n+            if (next == BreakIterator.DONE) {\n+                if (inWord) {\n+                    \/\/ when starting in the middle of a word\n+                    return new TextPos(index, len);\n+                }\n+            } else {\n+                if (inWord) {\n+                    return new TextPos(index, next);\n+                }\n+\n+                while (next != BreakIterator.DONE) {\n+                    offset = next;\n+                    next = br.next();\n+                    inWord = RichUtils.isLetterOrDigit(text, offset);\n+                    if (inWord) {\n+                        return new TextPos(index, next);\n+                    }\n+                }\n+            }\n+\n+            index++;\n+            offset = 0;\n+            skipEmpty = false;\n+        }\n+    }\n+\n+    public void redo() {\n+        RichTextArea control = getControl();\n+        StyledTextModel m = control.getModel();\n+        if (m != null) {\n+            TextPos[] sel = m.redo(vflow);\n+            if (sel != null) {\n+                control.select(sel[0], sel[1]);\n+            }\n+        }\n+    }\n+\n+    public void undo() {\n+        RichTextArea control = getControl();\n+        StyledTextModel m = control.getModel();\n+        if (m != null) {\n+            TextPos[] sel = m.undo(vflow);\n+            if (sel != null) {\n+                control.select(sel[0], sel[1]);\n+            }\n+        }\n+    }\n+\n+    private Bidi getBidi() {\n+        String paragraph = getTextAtCaret();\n+        int flags = (getControl().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) ?\n+            Bidi.DIRECTION_RIGHT_TO_LEFT :\n+            Bidi.DIRECTION_LEFT_TO_RIGHT;\n+        return new Bidi(paragraph, flags);\n+    }\n+\n+    private String getTextAtCaret() {\n+        RichTextArea control = getControl();\n+        TextPos p = control.getCaretPosition();\n+        if (p != null) {\n+            String s = control.getPlainText(p.index());\n+            if (s != null) {\n+                return s;\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    private boolean isMixed() {\n+        return getBidi().isMixed();\n+    }\n+\n+    private boolean isRTLText() {\n+        Bidi bidi = getBidi();\n+        return (\n+            bidi.isRightToLeft() ||\n+            (isMixed() && getControl().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT)\n+        );\n+    }\n+\n+    public void deleteWordNextBeg() {\n+        deleteIgnoreSelection(this::nextWordBeg);\n+    }\n+\n+    public void deleteWordNextEnd() {\n+        deleteIgnoreSelection(this::nextWordEnd);\n+    }\n+\n+    public void deleteWordPrevious() {\n+        deleteIgnoreSelection(this::previousWord);\n+    }\n+\n+    private void deleteIgnoreSelection(BiFunction<RichTextArea, TextPos, TextPos> getter) {\n+        RichTextArea control = getControl();\n+        if (control.canEdit()) {\n+            TextPos caret = control.getCaretPosition();\n+            if (caret != null) {\n+                TextPos p = getter.apply(control, caret);\n+                if (p != null) {\n+                    control.clearSelection();\n+                    clearPhantomX();\n+                    p = control.replaceText(caret, p, \"\", true);\n+                    control.select(p);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/RichTextAreaBehavior.java","additions":1542,"deletions":0,"binary":false,"changes":1542,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import javafx.scene.control.Skin;\n+import com.sun.javafx.util.Utils;\n+import com.sun.jfx.incubator.scene.control.richtext.util.ListenerHelper;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.skin.RichTextAreaSkin;\n+\n+\/**\n+ * Manages RichTextAreaSkin Accessor.\n+ *\/\n+public class RichTextAreaSkinHelper {\n+    public interface Accessor {\n+        public VFlow getVFlow(Skin<?> skin);\n+        public ListenerHelper getListenerHelper(Skin<?> skin);\n+    }\n+\n+    static {\n+        Utils.forceInit(RichTextAreaSkin.class);\n+    }\n+\n+    private static Accessor accessor;\n+\n+    public static void setAccessor(Accessor a) {\n+        if (accessor != null) {\n+            throw new IllegalStateException();\n+        }\n+        accessor = a;\n+    }\n+\n+    public static VFlow getVFlow(RichTextArea t) {\n+        var skin = t.getSkin();\n+        return accessor.getVFlow(skin);\n+    }\n+\n+    public static ListenerHelper getListenerHelper(RichTextAreaSkin skin) {\n+        return accessor.getListenerHelper(skin);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/RichTextAreaSkinHelper.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.io.Writer;\n+import com.sun.javafx.util.Utils;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.model.RichTextFormatHandler;\n+import jfx.incubator.scene.control.richtext.model.StyledOutput;\n+\n+public class RichTextFormatHandlerHelper {\n+    public interface Accessor {\n+        public StyledOutput createStyledOutput(RichTextFormatHandler h, StyleResolver r, Writer wr);\n+    }\n+\n+    static {\n+        Utils.forceInit(RichTextFormatHandler.class);\n+    }\n+\n+    private static Accessor accessor;\n+\n+    public static void setAccessor(Accessor a) {\n+        if (accessor != null) {\n+            throw new IllegalStateException();\n+        }\n+        accessor = a;\n+    }\n+\n+    public static StyledOutput createStyledOutput(RichTextFormatHandler h, StyleResolver r, Writer wr) {\n+        return accessor.createStyledOutput(h, r, wr);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/RichTextFormatHandlerHelper.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,556 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This implementation is borrowed from\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxTextEditor\/blob\/master\/src\/goryachev\/fxtexteditor\/internal\/rtf\/RtfWriter.java\n+\/\/ with permission from the author.\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import javafx.scene.Node;\n+import javafx.scene.image.WritableImage;\n+import javafx.scene.paint.Color;\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledOutput;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+\n+\/**\n+ * StyledOutput which generates RTF.\n+ *\n+ * RTF 1.5 Spec:\n+ * https:\/\/www.biblioscape.com\/rtf15_spec.htm\n+ *\/\n+public class RtfStyledOutput implements StyledOutput {\n+    private final LookupTable<Color> colorTable = new LookupTable<>(Color.BLACK);\n+    private final LookupTable<String> fontTable = new LookupTable<>(\"system\");\n+    private final StyleResolver resolver;\n+    private final Writer writer;\n+    private boolean startOfLine = true;\n+    private StyleAttributeMap prevStyle;\n+    private Color color;\n+    private Color background;\n+    private boolean bold;\n+    private boolean italic;\n+    private boolean under;\n+    private boolean strike;\n+    private String fontFamily;\n+    private Double fontSize;\n+\n+    public RtfStyledOutput(StyleResolver r, Writer wr) {\n+        this.resolver = new CachingStyleResolver(r);\n+        this.writer = wr;\n+    }\n+\n+    public StyledOutput firstPassBuilder() {\n+        return new StyledOutput() {\n+            @Override\n+            public void consume(StyledSegment seg) throws IOException {\n+                switch (seg.getType()) {\n+                case PARAGRAPH_ATTRIBUTES:\n+                    \/\/ TODO\n+                    break;\n+                case TEXT:\n+                    StyleAttributeMap a = seg.getStyleAttributeMap(resolver);\n+                    if (a != null) {\n+                        \/\/ colors\n+                        Color c = getTextColor(a);\n+                        colorTable.add(c);\n+\n+                        \/\/ TODO background color\n+                        \/\/                    c = mixBackground(st.getBackgroundColor());\n+                        \/\/                    if (c != null) {\n+                        \/\/                        colorTable.add(c);\n+                        \/\/                    }\n+\n+                        \/\/ TODO font table\n+                        String family = a.getFontFamily();\n+                        if (family != null) {\n+                            fontTable.add(family);\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            @Override\n+            public void flush() throws IOException {\n+            }\n+\n+            @Override\n+            public void close() throws IOException {\n+            }\n+        };\n+    }\n+\n+    \/\/    \\fnil   Unknown or default fonts (the default)\n+    \/\/    \\froman Roman, proportionally spaced serif fonts    Times New Roman, Palatino\n+    \/\/    \\fswiss Swiss, proportionally spaced sans serif fonts   Arial\n+    \/\/    \\fmodern    Fixed-pitch serif and sans serif fonts  Courier New, Pica\n+    \/\/    \\fscript    Script fonts    Cursive\n+    \/\/    \\fdecor Decorative fonts    Old English, ITC Zapf Chancery\n+    \/\/    \\ftech  Technical, symbol, and mathematical fonts   Symbol\n+    \/\/    \\fbidi  Arabic, Hebrew, or other bidirectional font Miriam\n+    private String lookupFontFamily(String name) {\n+        try {\n+            switch (name.toLowerCase()) {\n+            case \"monospaced\":\n+                return \"\\\\fmodern Courier New\";\n+            case \"system\":\n+            case \"sans-serif\":\n+                return \"\\\\fswiss Helvetica\";\n+            case \"serif\":\n+                return \"\\\\froman Times New Roman\";\n+            case \"cursive\":\n+                return \"\\\\fscript Brush Script\";\n+            case \"fantasy\":\n+                return \"\\\\fdecor ITC Zapf Chancery\";\n+            }\n+        } catch (Exception e) {\n+        }\n+        return null;\n+    }\n+\n+    public void writePrologue() throws IOException {\n+        \/\/ preamble\n+        write(\"{\\\\rtf1\\\\ansi\\\\ansicpg1252\\\\uc1\\\\sl0\\\\sb0\\\\sa0\\\\deff0\");\n+\n+        \/\/ font table\n+        write(\"{\\\\fonttbl\");\n+        int ix = 0;\n+        for (String name : fontTable.getItems()) {\n+            String fam = lookupFontFamily(name);\n+\n+            write(\"\\\\f\");\n+            write(String.valueOf(ix++));\n+            if (fam == null) {\n+                write(\"\\\\fnil\");\n+                write(\" \");\n+                write(name);\n+            } else {\n+                write(fam);\n+            }\n+            write(\";\");\n+        }\n+        write(\"}\\r\\n\");\n+\n+        \/\/ color table\n+        write(\"{\\\\colortbl ;\");\n+        for (Color c : colorTable.getItems()) {\n+            write(\"\\\\red\");\n+            write(toInt255(c.getRed()));\n+            write(\"\\\\green\");\n+            write(toInt255(c.getGreen()));\n+            write(\"\\\\blue\");\n+            write(toInt255(c.getBlue()));\n+            write(\";\");\n+        }\n+        write(\"}\\r\\n\");\n+\n+        \/\/ TODO \\deftab720 Default tab width in twips (the default is 720).  a twip is one-twentieth of a point\n+    }\n+\n+    @Override\n+    public void consume(StyledSegment seg) throws IOException {\n+        switch (seg.getType()) {\n+        case LINE_BREAK:\n+            writeEndOfLine();\n+            writeNewLine();\n+            break;\n+        case PARAGRAPH_ATTRIBUTES:\n+            \/\/ TODO\n+            break;\n+        case REGION:\n+            Node n = seg.getParagraphNodeGenerator().get();\n+            writeParagraph(n);\n+            writeNewLine();\n+            break;\n+        case TEXT:\n+            writeTextSegment(seg);\n+            break;\n+        }\n+    }\n+\n+    public void writeEpilogue() throws IOException {\n+        writeEndOfLine();\n+        write(\"\\r\\n}\\r\\n\");\n+    }\n+\n+    private void writeEndOfLine() throws IOException {\n+        if (color != null) {\n+            write(\"\\\\cf0 \");\n+            color = null;\n+        }\n+\n+        if (background != null) {\n+            write(\"\\\\highlight0 \");\n+            background = null;\n+        }\n+\n+        if (bold) {\n+            write(\"\\\\b0 \");\n+            bold = false;\n+        }\n+\n+        if (italic) {\n+            write(\"\\\\i0 \");\n+            italic = false;\n+        }\n+\n+        if (under) {\n+            write(\"\\\\ul0 \");\n+            under = false;\n+        }\n+\n+        if (strike) {\n+            write(\"\\\\strike0 \");\n+            strike = false;\n+        }\n+    }\n+\n+    private void writeNewLine() throws IOException {\n+        write(\"\\\\par\\r\\n\");\n+        startOfLine = true;\n+    }\n+\n+    @SuppressWarnings(\"null\") \/\/ see L280\n+    private void writeTextSegment(StyledSegment seg) throws IOException {\n+        checkCancelled();\n+\n+        if (startOfLine) {\n+            \/\/ first line indent 0, left aligned\n+            write(\"\\\\fi0\\\\ql \");\n+            prevStyle = null;\n+\n+            startOfLine = false;\n+        }\n+\n+        StyleAttributeMap a = seg.getStyleAttributeMap(resolver);\n+\n+        if (RichUtils.notEquals(a, prevStyle) || RichUtils.notEquals(getTextColor(a), getTextColor(prevStyle))) {\n+            Color col;\n+            Color bg;\n+            boolean bld;\n+            boolean ita;\n+            boolean und;\n+            boolean str;\n+            String fam;\n+            Double fsize;\n+\n+            if (a == null) {\n+                col = null;\n+                bg = null;\n+                bld = false;\n+                ita = false;\n+                und = false;\n+                str = false;\n+                fam = null;\n+                fsize = null;\n+            } else {\n+                col = getTextColor(a);\n+                bg = null; \/\/ TODO mixBackground(st.getBackgroundColor());\n+                bld = a.isBold();\n+                ita = a.isItalic();\n+                und = a.isUnderline();\n+                str = a.isStrikeThrough();\n+                fam = a.getFontFamily();\n+                fsize = a.getFontSize();\n+            }\n+\n+            prevStyle = a;\n+\n+            \/\/ emit changes\n+\n+            if (RichUtils.notEquals(fontFamily, fam)) {\n+                int ix = fontTable.getIndexFor(fam);\n+                write(\"\\\\f\");\n+                write(String.valueOf(ix));\n+\n+                fontFamily = fam;\n+            }\n+\n+            if (RichUtils.notEquals(fontSize, fsize)) {\n+                write(\"\\\\fs\");\n+                \/\/ twice the points\n+                double fs = (fsize == null) ? 24.0 : (fsize * 2.0);\n+                write(String.valueOf((int)Math.round(fs)));\n+                fontSize = fsize;\n+            }\n+\n+            if (RichUtils.notEquals(col, color)) {\n+                if (col == null) {\n+                    write(\"\\\\cf0 \");\n+                } else {\n+                    int ix = colorTable.getIndexFor(col);\n+                    if (ix > 0) {\n+                        ix++;\n+                    }\n+\n+                    write(\"\\\\cf\");\n+                    write(String.valueOf(ix));\n+                    write(\" \");\n+                }\n+\n+                color = col;\n+            }\n+\n+            if (RichUtils.notEquals(bg, background)) {\n+                if (bg == null) {\n+                    write(\"\\\\highlight0 \");\n+                } else {\n+                    int ix = colorTable.getIndexFor(bg);\n+                    if (ix > 0) {\n+                        ix++;\n+                    }\n+                    write(\"\\\\highlight\");\n+                    write(String.valueOf(ix));\n+                    write(\" \");\n+                }\n+\n+                background = bg;\n+            }\n+\n+            if (bld != bold) {\n+                write(bld ? \"\\\\b \" : \"\\\\b0 \");\n+                bold = bld;\n+            }\n+\n+            if (ita != italic) {\n+                write(ita ? \"\\\\i \" : \"\\\\i0 \");\n+                italic = ita;\n+            }\n+\n+            if (und != under) {\n+                write(und ? \"\\\\ul \" : \"\\\\ul0 \");\n+                under = und;\n+            }\n+\n+            if (str != strike) {\n+                write(str ? \"\\\\strike \" : \"\\\\strike0 \");\n+                strike = str;\n+            }\n+        }\n+\n+        String text = seg.getText();\n+        String encoded = encode(text);\n+        write(encoded);\n+    }\n+\n+    \/\/ TODO does not seem to work on Mac\n+    private void writeParagraph(Node n) throws IOException {\n+        WritableImage im = resolver.snapshot(n);\n+        byte[] bytes = RichUtils.writePNG(im);\n+        int w = (int)im.getWidth();\n+        int h = (int)im.getHeight();\n+\n+        write(\"{\\\\*\\\\shppict {\\\\pict \\\\pngblip\");\n+        write(\"\\\\picscalex100\\\\picscaley100\\\\piccropl10\\\\piccropr0\\\\piccropt0\\\\piccropb0\");\n+        write(\"\\\\picw\");\n+        write(String.valueOf(w));\n+        write(\"\\\\pich\");\n+        write(String.valueOf(h));\n+        write(\"\\\\picwgoal\");\n+        \/\/ let's try to default to 6\".  72 * 6 * 2 = 864\n+        int wgoal = 864;\n+        write(String.valueOf(wgoal));\n+        int hgoal = h * wgoal \/ w;\n+        write(\"\\\\pichgoal\");\n+        write(String.valueOf(hgoal));\n+        write(\"\\r\\n\");\n+        \/\/ There is no set maximum line length for an RTF file.\n+        StringBuilder sb = new StringBuilder(2);\n+        for (int i = 0; i < bytes.length; i++) {\n+            byte b = bytes[i];\n+            hex2(sb, b);\n+            write(sb.toString());\n+            if ((i % 80) == 79) {\n+                write(\"\\r\\n\");\n+            }\n+        }\n+        write(\"\\r\\n}}\\r\\n\");\n+    }\n+\n+    private static void hex2(StringBuilder sb, byte b) {\n+        sb.setLength(0);\n+        String hex = \"0123456789abcdef\";\n+        sb.append(hex.charAt((b >> 4) & 0x0f));\n+        sb.append(hex.charAt(b & 0x0f));\n+    }\n+\n+    \/\/ TODO unit test!\n+    private static String encode(String text) {\n+        if (text == null) {\n+            return \"\";\n+        }\n+\n+        int ix = indexOfSpecialChar(text);\n+        if (ix < 0) {\n+            return text;\n+        }\n+\n+        int len = text.length();\n+        StringBuilder sb = new StringBuilder(len + 32);\n+        sb.append(text, 0, ix);\n+\n+        for (int i = ix; i < len; i++) {\n+            char c = text.charAt(i);\n+            if (c < 0x20) {\n+                switch (c) {\n+                case '\\n':\n+                case '\\r':\n+                    break;\n+                case '\\t':\n+                    sb.append(c);\n+                    break;\n+                }\n+            } else if (c < 0x80) {\n+                switch (c) {\n+                case '\\\\':\n+                    sb.append(\"\\\\\\\\\");\n+                    break;\n+                case '{':\n+                    sb.append(\"\\\\{\");\n+                    break;\n+                case '}':\n+                    sb.append(\"\\\\}\");\n+                    break;\n+                default:\n+                    sb.append(c);\n+                    break;\n+                }\n+            } else {\n+                sb.append(\"\\\\u\");\n+                sb.append(String.valueOf((short)c));\n+                sb.append(\"?\");\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    private static int indexOfSpecialChar(String text) {\n+        int len = text.length();\n+        for (int i = 0; i < len; i++) {\n+            char c = text.charAt(i);\n+            if (c < 0x20) {\n+                switch (c) {\n+                case '\\t':\n+                    continue;\n+                default:\n+                    return i;\n+                }\n+            } else if (c < 0x80) {\n+                switch (c) {\n+                case '\\\\':\n+                case '{':\n+                case '}':\n+                    return i;\n+                default:\n+                    continue;\n+                }\n+            } else {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private static String toInt255(double x) {\n+        int v = (int)Math.round(255 * x);\n+        if (v < 0) {\n+            v = 0;\n+        } else if (v > 255) {\n+            v = 255;\n+        }\n+        return String.valueOf(v);\n+    }\n+\n+    private static void checkCancelled() throws IOException {\n+        \/\/ check if interrupted\n+        if (Thread.currentThread().isInterrupted()) {\n+            \/\/ don't want to have it as a checked exception... may be throws Exception?\n+            throw new IOException(new InterruptedException());\n+        }\n+\n+        \/\/ TODO check if nearly out of memory\n+    }\n+\n+    private void write(String s) throws IOException {\n+        writer.write(s);\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        writer.flush();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        writer.close();\n+    }\n+\n+    private static Color getTextColor(StyleAttributeMap a) {\n+        Color c = a.getTextColor();\n+        return c == null ? Color.BLACK : c;\n+    }\n+\n+    \/** RTF is unable to specify colors inline it seems, needs a color lookup table *\/\n+    protected static class LookupTable<T> {\n+        private final ArrayList<T> items = new ArrayList<>();\n+        private final HashMap<T, Integer> indexes = new HashMap<>();\n+\n+        public LookupTable(T initValue) {\n+            if (initValue != null) {\n+                add(initValue);\n+            }\n+        }\n+\n+        public void add(T item) {\n+            if (!indexes.containsKey(item)) {\n+                Integer ix = Integer.valueOf(items.size());\n+                items.add(item);\n+                indexes.put(item, ix);\n+            }\n+        }\n+\n+        \/** returns index or 0 if not found *\/\n+        public int getIndexFor(T c) {\n+            Integer ix = indexes.get(c);\n+            if (ix == null) {\n+                return 0;\n+            }\n+            return ix.intValue();\n+        }\n+\n+        public List<T> getItems() {\n+            return items;\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/RtfStyledOutput.java","additions":556,"deletions":0,"binary":false,"changes":556,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import jfx.incubator.scene.control.richtext.model.StyledInput;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+\n+public class SegmentStyledInput implements StyledInput {\n+    private final StyledSegment[] segments;\n+    private int index;\n+\n+    public SegmentStyledInput(StyledSegment[] segments) {\n+        this.segments = segments;\n+    }\n+\n+    @Override\n+    public StyledSegment nextSegment() {\n+        if (index < segments.length) {\n+            return segments[index++];\n+        }\n+        return null;\n+    }\n+\n+    public static SegmentStyledInput of(List<StyledSegment> segments) {\n+        StyledSegment[] ss = segments.toArray(new StyledSegment[segments.size()]);\n+        return new SegmentStyledInput(ss);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/SegmentStyledInput.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import jfx.incubator.scene.control.richtext.model.StyledOutput;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+\n+\/**\n+ * This StyledOutput simply collects StyledSegments in a list.\n+ *\/\n+public class SegmentStyledOutput implements StyledOutput {\n+    private ArrayList<StyledSegment> segments;\n+\n+    public SegmentStyledOutput(int initialCapacity) {\n+        segments = new ArrayList<>(initialCapacity);\n+    }\n+\n+    @Override\n+    public void consume(StyledSegment s) throws IOException {\n+        segments.add(s);\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }\n+\n+    public StyledSegment[] getSegments() {\n+        return segments.toArray(new StyledSegment[segments.size()]);\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/SegmentStyledOutput.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * A utility class to help deal with anchor and caret positions.\n+ *\/\n+public class SelInfo {\n+    private final RichTextArea control;\n+    private final TextPos caret;\n+    private final TextPos anchor;\n+    private final boolean caretAtMin;\n+\n+    public SelInfo(RichTextArea control, TextPos caret, TextPos anchor, boolean caretAtMin) {\n+        this.control = control;\n+        this.caret = caret;\n+        this.anchor = anchor;\n+        this.caretAtMin = caretAtMin;\n+    }\n+\n+    public static SelInfo get(RichTextArea control) {\n+        if (control == null) {\n+            return null;\n+        }\n+        TextPos ca = control.getCaretPosition();\n+        if (ca == null) {\n+            return null;\n+        }\n+        TextPos an = control.getAnchorPosition();\n+        if (an == null) {\n+            an = ca;\n+        }\n+        boolean atMin = (ca.compareTo(an) <= 0);\n+        return new SelInfo(control, ca, an, atMin);\n+    }\n+\n+    public TextPos getMin() {\n+        return caretAtMin ? caret : anchor;\n+    }\n+\n+    public TextPos getMax() {\n+        return caretAtMin ? anchor : caret;\n+    }\n+\n+    public TextPos getCaret() {\n+        return caret;\n+    }\n+\n+    public TextPos getAnchor() {\n+        return anchor;\n+    }\n+\n+    public boolean hasSelection() {\n+        return caret.compareTo(anchor) != 0;\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/SelInfo.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,247 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\/\/ Copyright © 2017-2023 Andy Goryachev <andy@goryachev.com>\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import javafx.scene.shape.LineTo;\n+import javafx.scene.shape.MoveTo;\n+import javafx.scene.shape.PathElement;\n+\n+\/**\n+ * Selection Helper encapsulates the logic required to generate selection shapes.\n+ *\n+ * The goal is to find out which shapes correspond to the top-most and bottom-most\n+ * text rows (in the presence of wrapping).  These shapes (#) should be added to selection as is.\n+ * Any space in between (x) would generate a single rectangular block that fills the\n+ * width of the container.  Additional shapes (#) will be added when necessary to make\n+ * the selection appear contiguious.  These shapes are positioned to the left or to the right\n+ * of the selected text depending on the direction of text.\n+ *\n+ * TODO RTL text\n+ * <pre>\n+ * ----***--***####\n+ * xxxxxxxxxxxxxxxx\n+ * xxxxxxxxxxxxxxxx\n+ * ####**----------\n+ * <\/pre>\n+ * TODO this class can be static because everything happens in the FX app thread.\n+ *\/\n+public class SelectionHelper {\n+    private final FxPathBuilder pathBuilder;\n+    private final double left;\n+    private final double right;\n+    private double topUp = Double.POSITIVE_INFINITY;\n+    private double topDn = Double.POSITIVE_INFINITY;\n+    private double topLeft = Double.POSITIVE_INFINITY;\n+    private double topRight = Double.NEGATIVE_INFINITY;\n+    private double bottomUp = Double.NEGATIVE_INFINITY;\n+    private double bottomDn = Double.NEGATIVE_INFINITY;\n+    private double bottomLeft = Double.POSITIVE_INFINITY;\n+    private double bottomRight = Double.NEGATIVE_INFINITY;\n+    private static final double EPSILON = 0.001; \/\/ float point arithmetic is inexact\n+\n+    public SelectionHelper(FxPathBuilder b, double left, double right) {\n+        this.pathBuilder = b;\n+        this.left = left;\n+        this.right = right;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"topUp=\" + topUp + \" topDn=\" + topDn + \" botUp=\" + bottomUp + \" botDn=\" + bottomDn;\n+    }\n+\n+    @FunctionalInterface\n+    protected interface PathHandler {\n+        public void processPoint(double x, double y);\n+    }\n+\n+    private void process(PathElement[] elements, PathHandler h) {\n+        if (elements != null) {\n+            for (PathElement em : elements) {\n+                if (em instanceof LineTo p) {\n+                    h.processPoint(p.getX(), p.getY());\n+                } else if (em instanceof MoveTo p) {\n+                    h.processPoint(p.getX(), p.getY());\n+                } else {\n+                    throw new Error(\"?\" + em);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void generateMiddle(boolean topLTR, boolean bottomLTR, double lineSpacing) {\n+        if (Double.isNaN(topUp)) {\n+            return;\n+        }\n+\n+        double td = topDn + lineSpacing;\n+        double bd = bottomDn + lineSpacing;\n+\n+        \/\/ only if the middle exists\n+        if (bottomUp > topDn) {\n+            if (topLTR) {\n+                pathBuilder.moveto(topRight, topUp);\n+                pathBuilder.lineto(right, topUp);\n+                pathBuilder.lineto(right, td);\n+                pathBuilder.lineto(topRight, td);\n+                pathBuilder.lineto(topRight, topUp);\n+            } else {\n+                \/\/ TODO\n+            }\n+\n+            pathBuilder.moveto(left, td);\n+            pathBuilder.lineto(right, td);\n+            pathBuilder.lineto(right, bottomUp);\n+            pathBuilder.lineto(left, bottomUp);\n+            pathBuilder.lineto(left, td);\n+\n+            \/\/ trailer\n+\n+            if (bottomLTR) {\n+                pathBuilder.moveto(left, bottomUp);\n+                pathBuilder.lineto(bottomLeft, bottomUp);\n+                pathBuilder.lineto(bottomLeft, bd);\n+                pathBuilder.lineto(left, bd);\n+                pathBuilder.lineto(left, bottomUp);\n+            } else {\n+                \/\/ TODO\n+            }\n+        }\n+    }\n+\n+    private boolean isNear(double a, double b) {\n+        return Math.abs(a - b) < EPSILON;\n+    }\n+\n+    private void determineTopYLimits(double x, double y) {\n+        if (y < topUp) {\n+            topUp = y;\n+        }\n+    }\n+\n+    private void determineTopXLimits(double x, double y) {\n+        if (isNear(y, topUp)) {\n+            if (x < topLeft) {\n+                topLeft = x;\n+            }\n+\n+            if (x > topRight) {\n+                topRight = x;\n+            }\n+        } else {\n+            if (y < topDn) {\n+                topDn = y;\n+            }\n+        }\n+    }\n+\n+    private void determineBottomYLimits(double x, double y) {\n+        if (y > bottomDn) {\n+            bottomDn = y;\n+        }\n+    }\n+\n+    private void determineBottomXLimits(double x, double y) {\n+        if (isNear(y, bottomDn)) {\n+            if (x < bottomLeft) {\n+                bottomLeft = x;\n+            }\n+\n+            if (x > bottomRight) {\n+                bottomRight = x;\n+            }\n+        } else {\n+            if (y > bottomUp) {\n+                bottomUp = y;\n+            }\n+        }\n+    }\n+\n+    \/** adjusts for line spacing and left padding *\/\n+    private void adjust(PathElement[] elements, double px, double py, double dx, double dy) {\n+        if (elements != null) {\n+            for (PathElement em : elements) {\n+                if (em instanceof LineTo p) {\n+                    double x = p.getX();\n+                    if (isNear(x, px)) {\n+                        \/\/p.setX(x - dx);\n+                    }\n+\n+                    double y = p.getY();\n+                    if (isNear(y, py)) {\n+                        p.setY(y + dy);\n+                    }\n+                } else if (em instanceof MoveTo p) {\n+                    double x = p.getX();\n+                    if (isNear(x, px)) {\n+                        \/\/p.setX(x - dx);\n+                    }\n+\n+                    double y = p.getY();\n+                    if (isNear(y, py)) {\n+                        p.setY(y + dy);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public void generate(\n+        PathElement[] top,\n+        PathElement[] bottom,\n+        boolean topLTR,\n+        boolean bottomLTR,\n+        double leftPadding,\n+        double lineSpacing\n+    ) {\n+        process(top, this::determineTopYLimits);\n+        process(top, this::determineTopXLimits);\n+\n+        if (bottom == null) {\n+            \/\/ TODO special handling when outside of visible area\n+\n+            adjust(top, topLeft, topDn, leftPadding, lineSpacing);\n+            pathBuilder.addAll(top);\n+        } else {\n+            process(bottom, this::determineBottomYLimits);\n+            process(bottom, this::determineBottomXLimits);\n+\n+            adjust(top, topLeft, topDn, leftPadding, lineSpacing);\n+            adjust(bottom, bottomLeft, bottomDn, leftPadding, lineSpacing);\n+\n+\/\/            D.p(\"top\", dump(top), \"bottom\", dump(btm)); \/\/ FIX\n+\/\/            D.p(\" top: y=\" + r(topUp) + \"..\" + r(topDn) + \" x=\" + r(topLeft) + \"..\" + r(topRight));\n+\/\/            D.p(\" bot: y=\" + r(bottomUp) + \"..\" + r(bottomDn) + \" x=\" + r(bottomLeft) + \"..\" + r(bottomRight));\n+\n+            pathBuilder.addAll(top);\n+            generateMiddle(topLTR, bottomLTR, lineSpacing);\n+            pathBuilder.addAll(bottom);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/SelectionHelper.java","additions":247,"deletions":0,"binary":false,"changes":247,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.io.IOException;\n+import jfx.incubator.scene.control.richtext.model.StyledOutput;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+\n+public class StringBuilderStyledOutput implements StyledOutput {\n+    private final StringBuilder sb;\n+    private String newline = System.getProperty(\"line.separator\");\n+\n+    public StringBuilderStyledOutput(int initialCapacity) {\n+        sb = new StringBuilder(initialCapacity);\n+    }\n+\n+    public StringBuilderStyledOutput() {\n+        this(1024);\n+    }\n+\n+    public void setLineSeparator(String s) {\n+        newline = s;\n+    }\n+\n+    @Override\n+    public void consume(StyledSegment seg) {\n+        switch (seg.getType()) {\n+        case LINE_BREAK:\n+            sb.append(newline);\n+            break;\n+        case TEXT:\n+            String text = seg.getText();\n+            sb.append(text);\n+            break;\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/StringBuilderStyledOutput.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.io.IOException;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledInput;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+\n+public class StringStyledInput implements StyledInput {\n+    private final String text;\n+    private final StyleAttributeMap attrs;\n+    private int offset;\n+\n+    \/\/ TODO check for illegal chars (<0x20 except for \\r \\n \\t)\n+    public StringStyledInput(String text, StyleAttributeMap a) {\n+        this.text = (text == null ? \"\" : text);\n+        this.attrs = a;\n+    }\n+\n+    @Override\n+    public StyledSegment nextSegment() {\n+        if (offset < text.length()) {\n+            int c = text.charAt(offset);\n+            \/\/ is it a line break;?\n+            switch(c) {\n+            case '\\n':\n+                offset++;\n+                return StyledSegment.LINE_BREAK;\n+            case '\\r':\n+                c = charAt(++offset);\n+                switch(c) {\n+                case '\\n':\n+                    offset++;\n+                    break;\n+                }\n+                return StyledSegment.LINE_BREAK;\n+            }\n+\n+            int ix = indexOfLineBreak(offset);\n+            if (ix < 0) {\n+                String s = text.substring(offset);\n+                offset = text.length();\n+                return StyledSegment.of(s, attrs);\n+            } else {\n+                String s = text.substring(offset, ix);\n+                offset = ix;\n+                return StyledSegment.of(s, attrs);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private int charAt(int index) {\n+        if (index < text.length()) {\n+            return text.charAt(index);\n+        }\n+        return -1;\n+    }\n+\n+    private int indexOfLineBreak(int start) {\n+        int len = text.length();\n+        for(int i=start; i<len; i++) {\n+            char c = text.charAt(i);\n+            switch(c) {\n+            case '\\r':\n+            case '\\n':\n+                return i;\n+            \/\/ TODO we can check for invalid ctrl characters here,\n+            \/\/ or use a string builder to filter out unwanted chars\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/StringStyledInput.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import com.sun.javafx.util.Utils;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * Provides access to private methods in StyleAttributeMap.\n+ *\/\n+public class StyleAttributeMapHelper {\n+    public interface Accessor {\n+        public StyleAttributeMap filterAttributes(StyleAttributeMap ss, boolean isParagraph);\n+    }\n+\n+    static {\n+        Utils.forceInit(StyleAttributeMap.class);\n+    }\n+\n+    private static Accessor accessor;\n+\n+    public static void setAccessor(Accessor a) {\n+        if (accessor != null) {\n+            throw new IllegalStateException();\n+        }\n+        accessor = a;\n+    }\n+\n+    \/**\n+     * Returns a new StyleAttributeMap instance which contains only the character attributes,\n+     * or null if no character attributes found.\n+     * @param ss the style attribute map\n+     * @return the instance\n+     *\/\n+    public static StyleAttributeMap getCharacterAttrs(StyleAttributeMap ss) {\n+        return accessor.filterAttributes(ss, false);\n+    }\n+\n+    \/**\n+     * Returns a new StyleAttributeMap instance which contains only the paragraph attributes.,\n+     * or null if no paragraph attributes found.\n+     * @param ss the style attribute map\n+     * @return the instance\n+     *\/\n+    public static StyleAttributeMap getParagraphAttrs(StyleAttributeMap ss) {\n+        return accessor.filterAttributes(ss, true);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/StyleAttributeMapHelper.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.util.Objects;\n+import javafx.geometry.Pos;\n+import javafx.scene.Node;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.Region;\n+import javafx.scene.paint.Color;\n+import javafx.scene.shape.LineTo;\n+import javafx.scene.shape.MoveTo;\n+import javafx.scene.shape.PathElement;\n+import javafx.scene.text.TextFlow;\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n+\n+\/**\n+ * Provides a visual representation of a paragraph.\n+ * <p>\n+ * Typically, a TextCell contains a TextFlow with styled text (and possibly inline Nodes).\n+ * It is also possible to create a TextCell containing a single Region (which can be a Node of any complexity,\n+ * even including a different instance of RichTextArea).  These Regions will be presented as is, and,\n+ * for editable models, would not be editable via the RichTextArea mechanisms.\n+ * <p>\n+ * Each visible TextCell will be resized horizontally to fill the available width and then resized vertically\n+ * according to its preferred size for that width.\n+ *\/\n+public final class TextCell extends BorderPane {\n+    private final int index;\n+    private final Region content;\n+    private double width;\n+    private double height;\n+    private double y;\n+\n+    \/**\n+     * Creates a text cell with the specified {@code Region} as its content.\n+     * @param index paragraph index\n+     * @param content non-null content\n+     *\/\n+    public TextCell(int index, Region content) {\n+        Objects.nonNull(content);\n+        this.index = index;\n+        this.content = content;\n+        setManaged(false);\n+        setCenter(content);\n+    }\n+\n+    \/**\n+     * Creates a text cell with {@link TextFlow} as its content.\n+     * @param index paragraph index\n+     *\/\n+    public TextCell(int index) {\n+        this(index, textFlow());\n+    }\n+\n+    private static TextFlow textFlow() {\n+        TextFlow t = new TextFlow();\n+        t.setMinHeight(0.0); \/\/ speeds up the layout\n+        return t;\n+    }\n+\n+    \/**\n+     * Returns the content of this cell.\n+     * @return the content Region\n+     *\/\n+    public final Region getContent() {\n+        return content;\n+    }\n+\n+    \/**\n+     * Adds a node to the text flow.\n+     * @param node the node to add\n+     *\/\n+    public void add(Node node) {\n+        flow().getChildren().add(node);\n+    }\n+\n+    \/**\n+     * Returns the model index for this text cell.\n+     * @return model index (>=0)\n+     *\/\n+    public final int getIndex() {\n+        return index;\n+    }\n+\n+    \/**\n+     * Returns the length of text in this cell.  A cell containing a non-text content will return 0.\n+     * @return the text length\n+     *\/\n+    public int getTextLength() {\n+        if (content instanceof TextFlow f) {\n+            return RichUtils.getTextLength(f);\n+        }\n+        return 0;\n+    }\n+\n+    private TextFlow flow() {\n+        if(content instanceof TextFlow f) {\n+            return f;\n+        } else {\n+            throw new IllegalArgumentException(\"Not a TextFlow: \" + content.getClass());\n+        }\n+    }\n+\n+    \/** sets cell position along the y axis of this cell in VFlow coordinates *\/\n+    public void setPosition(double y, double height) {\n+        this.y = y;\n+        this.height = height;\n+    }\n+\n+    public double getCellHeight() {\n+        return height;\n+    }\n+\n+    public void setCellWidth(double w) {\n+        width = w;\n+    }\n+\n+    public double getCellWidth() {\n+        return width;\n+    }\n+\n+    public double getY() {\n+        return y;\n+    }\n+\n+    public void addBoxOutline(FxPathBuilder b, double x, double w, double h) {\n+        double y0 = getLayoutY();\n+        double y1 = y0 + h;\n+\n+        b.moveto(x, y0);\n+        b.lineto(w, y0);\n+        b.lineto(w, y1);\n+        b.lineto(x, y1);\n+        b.lineto(x, y0);\n+    }\n+\n+    \/**\n+     * Returns the {@code PathElement} array for the caret at the given character index and bias,\n+     * translated to the {@code target} frame of reference.\n+     *\n+     * @param target the Region that provides the target frame of reference\n+     * @param charIndex the character index\n+     * @param leading the character bias\n+     * @param dx the additional X offset\n+     * @param dy the additional Y offset\n+     * @return the array of path elements translated to the target coordinates\n+     *\/\n+    public PathElement[] getCaretShape(Region target, int charIndex, boolean leading, double dx, double dy) {\n+        PathElement[] p;\n+        if (content instanceof TextFlow f) {\n+            dx += f.snappedLeftInset(); \/\/ TODO RTL?\n+            dy += f.snappedTopInset();\n+\n+            p = f.caretShape(charIndex, leading);\n+\n+            if (p.length == 2) {\n+                PathElement p0 = p[0];\n+                PathElement p1 = p[1];\n+                if ((p0 instanceof MoveTo m0) && (p1 instanceof LineTo m1)) {\n+                    if (Math.abs(m0.getY() - m1.getY()) < 0.01) {\n+                        double x = m0.getX();\n+                        double y = m0.getY();\n+                        \/\/ empty line generates a single dot shape, not what we need\n+                        \/\/ using text flow height to get us a line caret shape\n+                        p[1] = new LineTo(x, y + f.getHeight());\n+                    }\n+                }\n+            }\n+        } else {\n+            p = new PathElement[] {\n+                new MoveTo(0.0, 0.0),\n+                new LineTo(0.0, content.getHeight())\n+            };\n+        }\n+        return RichUtils.translatePath(target, content, p, dx, dy);\n+    }\n+\n+    \/**\n+     * Returns the {@code PathElement} array for the range shape,\n+     * translated to the {@code target} frame of reference.\n+     *\n+     * @param target the Region that provides the target frame of reference\n+     * @param start the start offset\n+     * @param end the end offset\n+     * @param dx the additional X offset\n+     * @param dy the additional Y offset\n+     * @return the array of path elements translated to the target coordinates\n+     *\/\n+    public PathElement[] getRangeShape(Region target, int start, int end, double dx, double dy) {\n+        PathElement[] p;\n+        if (content instanceof TextFlow f) {\n+            dx += f.snappedLeftInset(); \/\/ TODO RTL?\n+            dy += f.snappedTopInset();\n+\n+            p = f.rangeShape(start, end);\n+\n+            if ((p == null) || (p.length == 0)) {\n+                p = new PathElement[] {\n+                    new MoveTo(0.0, 0.0),\n+                    new LineTo(0.0, f.getHeight())\n+                };\n+            }\n+        } else {\n+            double w = getWidth();\n+            double h = getHeight();\n+\n+            p = new PathElement[] {\n+                new MoveTo(0.0, 0.0),\n+                new LineTo(w, 0.0),\n+                new LineTo(w, h),\n+                new LineTo(0.0, h),\n+                new LineTo(0.0, 0.0)\n+            };\n+        }\n+        return RichUtils.translatePath(target, content, p, dx, dy);\n+    }\n+\n+    \/**\n+     * Highlights the specified text range.\n+     *\n+     * @param start start offset for the range\n+     * @param end end offset for the range\n+     * @param color highlight color\n+     *\/\n+    public void addHighlight(int start, int end, Color color) {\n+        HighlightShape.addTo(content, HighlightShape.Type.HIGHLIGHT, start, end, color);\n+    }\n+\n+    \/**\n+     * Highlights the specified text range, using style names.\n+     *\n+     * @param start start offset for the range\n+     * @param end end offset for the range\n+     * @param styles CSS style names\n+     *\/\n+    public void addHighlight(int start, int end, String... styles) {\n+        HighlightShape.addTo(content, HighlightShape.Type.HIGHLIGHT, start, end, styles);\n+    }\n+\n+    \/**\n+     * Underlines the specified text range using squiggly line (as typically used by a spell checker).\n+     *\n+     * @param start start offset for the range\n+     * @param end end offset for the range\n+     * @param color highlight color\n+     *\/\n+    public void addSquiggly(int start, int end, Color color) {\n+        HighlightShape.addTo(content, HighlightShape.Type.SQUIGGLY, start, end, color);\n+    }\n+\n+    \/**\n+     * Underlines the specified text range using squiggly line (as typically used by a spell checker),\n+     * using style names.\n+     *\n+     * @param start start offset for the range\n+     * @param end end offset for the range\n+     * @param styles CSS style names\n+     *\/\n+    public void addSquiggly(int start, int end, String... styles) {\n+        HighlightShape.addTo(content, HighlightShape.Type.SQUIGGLY, start, end, styles);\n+    }\n+\n+    \/**\n+     * Sets the bullet decoration by adding a Label with the specified character.\n+     *\n+     * @param bullet\n+     *\/\n+    public void setBullet(String bullet) {\n+        Label b = new Label(bullet);\n+        b.setAlignment(Pos.TOP_CENTER);\n+        \/\/ TODO get some attributes from the first text segment - font? color? or use default paragraph attrs?\n+        setLeft(b);\n+    }\n+\n+    \/**\n+     * Returns line spacing if the content is a {@code TextFlow}, 0.0 otherwise.\n+     *\n+     * @return the line spacing\n+     *\/\n+    public double getLineSpacing() {\n+        if (content instanceof TextFlow f) {\n+            return f.getLineSpacing();\n+        }\n+        return 0.0;\n+    }\n+\n+    \/**\n+     * Returns the line index of the given character offset.\n+     *\n+     * @param offset the character offset\n+     * @return the line index\n+     *\/\n+    public Integer lineForOffset(int offset) {\n+        if (content instanceof TextFlow f) {\n+            return RichUtils.lineForOffset(f, offset);\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the line start offset of the given line index.\n+     *\n+     * @param line the line index\n+     * @return the line start offset\n+     *\/\n+    public Integer lineStart(int line) {\n+        if (content instanceof TextFlow f) {\n+            return RichUtils.lineStart(f, line);\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the line end offset of the given line index.\n+     *\n+     * @param line the line index\n+     * @return the line offset\n+     *\/\n+    public Integer lineEnd(int line) {\n+        if (content instanceof TextFlow f) {\n+            return RichUtils.lineEnd(f, line);\n+        }\n+        return null;\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/TextCell.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.io.IOException;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+\n+\/**\n+ * Represents an undo-able and redo-able change.\n+ *\/\n+public class UndoableChange {\n+    private final StyledTextModel model;\n+    private final TextPos start;\n+    private final StyledSegment[] undo;\n+    private StyledSegment[] redo;\n+    private final TextPos endBefore;\n+    private TextPos endAfter;\n+    private UndoableChange prev;\n+    private UndoableChange next;\n+\n+    private UndoableChange(StyledTextModel model, TextPos start, TextPos end, StyledSegment[] undo) {\n+        this.model = model;\n+        this.start = start;\n+        this.endBefore = end;\n+        this.undo = undo;\n+    }\n+\n+    \/**\n+     * Creates an UndoableChange object.\n+     * This method might return null if an error happened during creation, for example, if the model\n+     * could not export the affected area as a sequence of StyledSegments.\n+     * <p>\n+     * TODO perhaps it should throw an exception which will be handled by the control, in order to provide\n+     * user feedback.\n+     * @param model source model\n+     * @param start start text position\n+     * @param end end text position\n+     * @throws IOException if the save point cannot be created\n+     *\/\n+    public static UndoableChange create(StyledTextModel model, TextPos start, TextPos end) {\n+        try {\n+            SegmentStyledOutput out = new SegmentStyledOutput(128);\n+            model.export(start, end, out);\n+            StyledSegment[] ss = out.getSegments();\n+            return new UndoableChange(model, start, end, ss);\n+        } catch (IOException e) {\n+            \/\/ TODO log\n+            return null;\n+        }\n+    }\n+\n+    public static UndoableChange createHead() {\n+        return new UndoableChange(null, null, null, null);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return\n+            \"UndoableChange{\" +\n+            \"start=\" + start +\n+            \", endBefore=\" + endBefore +\n+            \", endAfter=\" + endAfter;\n+    }\n+\n+    public void setEndAfter(TextPos p) {\n+        endAfter = p;\n+    }\n+\n+    public void undo(StyleResolver resolver) throws IOException {\n+        if (redo == null) {\n+            \/\/ create redo\n+            SegmentStyledOutput out = new SegmentStyledOutput(128);\n+            model.export(start, endAfter, out);\n+            redo = out.getSegments();\n+        }\n+\n+        \/\/ undo\n+        SegmentStyledInput in = new SegmentStyledInput(undo);\n+        model.replace(resolver, start, endAfter, in, false);\n+    }\n+\n+    public void redo(StyleResolver resolver) throws IOException {\n+        SegmentStyledInput in = new SegmentStyledInput(redo);\n+        model.replace(resolver, start, endBefore, in, false);\n+    }\n+\n+    public UndoableChange getPrev() {\n+        return prev;\n+    }\n+\n+    public void setPrev(UndoableChange ch) {\n+        prev = ch;\n+    }\n+\n+    public UndoableChange getNext() {\n+        return next;\n+    }\n+\n+    public void setNext(UndoableChange ch) {\n+        next = ch;\n+    }\n+\n+    public TextPos[] getSelectionBefore() {\n+        return new TextPos[] {\n+            start,\n+            endBefore\n+        };\n+    }\n+\n+    public TextPos[] getSelectionAfter() {\n+        return new TextPos[] {\n+            start,\n+            endAfter\n+        };\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/UndoableChange.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,1573 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javafx.animation.Animation;\n+import javafx.animation.KeyFrame;\n+import javafx.animation.Timeline;\n+import javafx.application.Platform;\n+import javafx.beans.binding.BooleanBinding;\n+import javafx.beans.property.ReadOnlyObjectWrapper;\n+import javafx.beans.property.ReadOnlyProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.event.EventType;\n+import javafx.geometry.Insets;\n+import javafx.geometry.NodeOrientation;\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+import javafx.scene.control.ScrollBar;\n+import javafx.scene.image.WritableImage;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.layout.Region;\n+import javafx.scene.shape.LineTo;\n+import javafx.scene.shape.MoveTo;\n+import javafx.scene.shape.Path;\n+import javafx.scene.shape.PathElement;\n+import javafx.scene.text.Text;\n+import javafx.scene.text.TextFlow;\n+import javafx.util.Duration;\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.SideDecorator;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.ContentChange;\n+import jfx.incubator.scene.control.richtext.model.ParagraphDirection;\n+import jfx.incubator.scene.control.richtext.model.RichParagraph;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+import jfx.incubator.scene.control.richtext.skin.RichTextAreaSkin;\n+\n+\/**\n+ * Contains all the parts representing the visuals of the RichTextAreaSkin.\n+ *\n+ * Component hierarchy (all the way to the top):\n+ * <pre>\n+ *  RichTextArea (Region) .rich-text-area\n+ *    └─ VFlow (Pane) .flow\n+ *        ├─ left gutter (ClippedPane) .left-side\n+ *        ├─ right gutter (ClippedPane) .right-side\n+ *        ├─ vertical ScrollBar\n+ *        ├─ horizontal ScrollBar\n+ *        └─ view port (ClippedPane) .vport\n+ *            └─ content (StackPane) .content\n+ *                ├─ caret (Path) .caret\n+ *                ├─ cells[]\n+ *                ├─ selection highlight (Path) .selection-highlight\n+ *                └─ caret line highlight (Path) .caret-line\n+ * <\/pre>\n+ *\/\n+public class VFlow extends Pane implements StyleResolver, StyledTextModel.Listener {\n+    private final RichTextAreaSkin skin;\n+    private final RichTextArea control;\n+    private final ScrollBar vscroll;\n+    private final ScrollBar hscroll;\n+    private final ClippedPane leftGutter;\n+    private final ClippedPane rightGutter;\n+    private final Pane content;\n+    private final ClippedPane vport;\n+    private final Path caretPath;\n+    private final Path caretLineHighlight;\n+    private final Path selectionHighlight;\n+    private final SimpleBooleanProperty caretVisible = new SimpleBooleanProperty(true);\n+    private final SimpleBooleanProperty suppressBlink = new SimpleBooleanProperty(false);\n+    private final SimpleDoubleProperty offsetX = new SimpleDoubleProperty(0.0);\n+    private final ReadOnlyObjectWrapper<Origin> origin = new ReadOnlyObjectWrapper(Origin.ZERO);\n+    private final Timeline caretAnimation;\n+    private final FastCache<TextCell> cellCache;\n+    private CellArrangement arrangement;\n+    private boolean dirty = true;\n+    private FastCache<Node> leftCache;\n+    private FastCache<Node> rightCache;\n+    private boolean handleScrollEvents = true;\n+    private boolean vsbPressed;\n+    private double contentPaddingTop;\n+    private double contentPaddingBottom;\n+    private double contentPaddingLeft;\n+    private double contentPaddingRight;\n+    private double leftSide;\n+    private double rightSide;\n+    private boolean inReflow;\n+    private double unwrappedContentWidth;\n+    private double viewPortWidth;\n+    private double viewPortHeight;\n+    private static final Text measurer = makeMeasurer();\n+    private static final VFlowCellContext context = new VFlowCellContext();\n+\n+    public VFlow(RichTextAreaSkin skin, ScrollBar vsb, ScrollBar hsb) {\n+        this.skin = skin;\n+        this.control = skin.getSkinnable();\n+        this.vscroll = vsb;\n+        this.hscroll = hsb;\n+\n+        vscroll.setManaged(false);\n+        vscroll.setMin(0.0);\n+        vscroll.setMax(1.0);\n+        vscroll.setUnitIncrement(Params.SCROLL_BARS_UNIT_INCREMENT);\n+        vscroll.setBlockIncrement(Params.SCROLL_BARS_BLOCK_INCREMENT);\n+\n+        hscroll.setManaged(false);\n+        hscroll.setMin(0.0);\n+        hscroll.setMax(1.0);\n+        hscroll.setUnitIncrement(Params.SCROLL_BARS_UNIT_INCREMENT);\n+        hscroll.setBlockIncrement(Params.SCROLL_BARS_BLOCK_INCREMENT);\n+\n+        cellCache = new FastCache(Params.CELL_CACHE_SIZE);\n+\n+        getStyleClass().add(\"vflow\");\n+        setPadding(new Insets(Params.LAYOUT_FOCUS_BORDER));\n+\n+        \/\/ TODO consider creating on demand\n+        leftGutter = new ClippedPane(\"left-side\");\n+        leftGutter.setManaged(false);\n+        \/\/ TODO consider creating on demand\n+        rightGutter = new ClippedPane(\"right-side\");\n+        rightGutter.setManaged(false);\n+\n+        vport = new ClippedPane(\"vport\");\n+        vport.setManaged(false);\n+\n+        content = new Pane();\n+        content.getStyleClass().add(\"content\");\n+        content.setManaged(false);\n+\n+        caretPath = new Path();\n+        caretPath.getStyleClass().add(\"caret\");\n+        caretPath.setManaged(false);\n+\n+        caretLineHighlight = new Path();\n+        caretLineHighlight.getStyleClass().add(\"caret-line\");\n+        caretLineHighlight.setManaged(false);\n+\n+        selectionHighlight = new Path();\n+        selectionHighlight.getStyleClass().add(\"selection-highlight\");\n+        selectionHighlight.setManaged(false);\n+\n+        \/\/ layout\n+        getChildren().addAll(leftGutter, rightGutter, vscroll, hscroll, vport);\n+        vport.getChildren().addAll(content);\n+        content.getChildren().addAll(caretLineHighlight, selectionHighlight, caretPath);\n+        \/\/ caret on top, then the cells (visual order = 0), then the selection highlight, then the caret line\n+        caretPath.setViewOrder(-10);\n+        selectionHighlight.setViewOrder(10);\n+        caretLineHighlight.setViewOrder(20);\n+\n+        caretAnimation = new Timeline();\n+        caretAnimation.setCycleCount(Animation.INDEFINITE);\n+\n+        caretPath.visibleProperty().bind(new BooleanBinding() {\n+            {\n+                bind(\n+                    caretVisible,\n+                    control.displayCaretProperty(),\n+                    control.focusedProperty(),\n+                    control.disabledProperty(),\n+                    suppressBlink\n+                );\n+            }\n+\n+            @Override\n+            protected boolean computeValue() {\n+                return\n+                    (isCaretVisible() || suppressBlink.get()) &&\n+                    control.isDisplayCaret() &&\n+                    control.isFocused() &&\n+                    (!control.isDisabled());\n+            }\n+        });\n+\n+        \/\/ FIX contentWidth.addListener((p) -> updateHorizontalScrollBar());\n+        offsetX.addListener((p) -> updateHorizontalScrollBar());\n+        origin.addListener((p) -> handleOriginChange());\n+        widthProperty().addListener((p) -> handleWidthChange());\n+        heightProperty().addListener((p) -> handleHeightChange());\n+\n+        vscroll.addEventFilter(MouseEvent.ANY, this::handleVScrollMouseEvent);\n+\n+        updateHorizontalScrollBar();\n+        handleOriginChange();\n+    }\n+\n+    public void dispose() {\n+        caretPath.visibleProperty().unbind();\n+    }\n+\n+    public Pane getContentPane() {\n+        return content;\n+    }\n+\n+    private static Text makeMeasurer() {\n+        Text t = new Text(\"8\");\n+        t.setManaged(false);\n+        return t;\n+    }\n+\n+    public void handleModelChange() {\n+        setOrigin(new Origin(0, -contentPaddingTop));\n+        handleWrapText();\n+\/\/        setUnwrappedContentWidth(0.0);\n+\/\/        setOffsetX(0.0);\n+\/\/        requestControlLayout(true);\n+\/\/        control.select(TextPos.ZERO);\n+    }\n+\n+    public void handleWrapText() {\n+        if (control.isWrapText()) {\n+            double w = viewPortWidth;\n+            setUnwrappedContentWidth(w);\n+        } else {\n+            setUnwrappedContentWidth(0.0);\n+        }\n+        setOffsetX(0.0);\n+\n+        layoutChildren();\n+        updateHorizontalScrollBar();\n+        updateVerticalScrollBar();\n+        requestControlLayout(true);\n+    }\n+\n+    public void handleDecoratorChange() {\n+        leftCache = updateSideCache(control.getLeftDecorator(), leftCache);\n+        rightCache = updateSideCache(control.getRightDecorator(), rightCache);\n+        requestControlLayout(false);\n+    }\n+\n+    private FastCache<Node> updateSideCache(SideDecorator decorator, FastCache<Node> cache) {\n+        if (decorator == null) {\n+            if (cache != null) {\n+                cache.clear();\n+            }\n+        } else {\n+            if (cache == null) {\n+                cache = new FastCache<>(Params.CELL_CACHE_SIZE);\n+            } else {\n+                cache.clear();\n+            }\n+        }\n+        return cache;\n+    }\n+\n+    public void invalidateLayout() {\n+        cellCache.clear();\n+        requestLayout();\n+        updateHorizontalScrollBar();\n+        updateVerticalScrollBar();\n+    }\n+\n+    public void handleContentPadding() {\n+        Insets m = control.getContentPadding();\n+        if (m == null) {\n+            m = Insets.EMPTY;\n+        }\n+\n+        contentPaddingLeft = snapPositionX(m.getLeft());\n+        contentPaddingRight = snapPositionX(m.getRight());\n+        contentPaddingTop = snapPositionY(m.getTop());\n+        contentPaddingBottom = snapPositionY(m.getBottom());\n+\n+        setOffsetX(0.0);\n+\n+        if (getOrigin().index() == 0) {\n+            setOrigin(new Origin(0, -contentPaddingTop));\n+        }\n+\n+        requestLayout();\n+        updateHorizontalScrollBar();\n+        updateVerticalScrollBar();\n+    }\n+\n+    public double leftPadding() {\n+        return contentPaddingLeft;\n+    }\n+\n+    \/** Location of the top left corner. *\/\n+    public final ReadOnlyProperty<Origin> originProperty() {\n+        return origin.getReadOnlyProperty();\n+    }\n+\n+    public final Origin getOrigin() {\n+        return origin.get();\n+    }\n+\n+    private void setOrigin(Origin or) {\n+        if (or == null) {\n+            throw new NullPointerException();\n+        }\n+        \/\/ prevent scrolling\n+        if (control.isUseContentHeight() || ((or.index() == 0) && (or.offset() == 0))) {\n+            or = new Origin(0, -contentPaddingTop);\n+        }\n+        origin.set(or);\n+    }\n+\n+    private void handleOriginChange() {\n+        if (!inReflow) {\n+            requestLayout();\n+        }\n+    }\n+\n+    public int topCellIndex() {\n+        return getOrigin().index();\n+    }\n+\n+    public final double getOffsetX() {\n+        return offsetX.get();\n+    }\n+\n+    private final void setOffsetX(double x) {\n+        \/\/ prevent scrolling\n+        if (control.isUseContentWidth()) {\n+            x = 0.0;\n+        } else {\n+            x = Math.max(0.0, snapPositionX(x));\n+        }\n+        offsetX.set(x);\n+        content.setTranslateX(-x);\n+    }\n+\n+    private void setUnwrappedContentWidth(double w) {\n+        \/\/ TODO remove this check later\n+        if (Math.abs(w - snapPositionX(w)) > 0.0001) {\n+            System.err.println(\"unwrapped position is not snapped!\");\n+        }\n+\n+        double min = snapPositionX(Params.LAYOUT_MIN_WIDTH);\n+        if (w < min) {\n+            w = min;\n+        }\n+        unwrappedContentWidth = w;\n+    }\n+\n+    \/** returns the content width, including padding and horizontal guard, snapped *\/\n+    private double contentWidth() {\n+        return unwrappedContentWidth + contentPaddingLeft + contentPaddingRight + snapPositionX(Params.HORIZONTAL_GUARD);\n+    }\n+\n+    public void setCaretVisible(boolean on) {\n+        caretVisible.set(on);\n+    }\n+\n+    public boolean isCaretVisible() {\n+        return caretVisible.get();\n+    }\n+\n+    \/** reacts to width changes *\/\n+    void handleWidthChange() {\n+        if (!control.isWrapText()) {\n+            \/\/ scroll horizontally when expanding beyond right boundary\n+            double delta = unwrappedContentWidth + contentPaddingRight - getOffsetX() - viewPortWidth;\n+            if (delta < 0.0) {\n+                double off = getOffsetX() + delta;\n+                if (off > -contentPaddingLeft) {\n+                    setOffsetX(off);\n+                }\n+            }\n+\n+            updateHorizontalScrollBar();\n+        }\n+        requestLayout();\n+    }\n+\n+    \/** reacts to height changes *\/\n+    void handleHeightChange() {\n+        requestLayout();\n+    }\n+\n+    public void handleSelectionChange() {\n+        setSuppressBlink(true);\n+        updateCaretAndSelection();\n+        scrollCaretToVisible();\n+        setSuppressBlink(false);\n+    }\n+\n+    public void updateCaretAndSelection() {\n+        if (arrangement == null) {\n+            removeCaretAndSelection();\n+            return;\n+        }\n+\n+        TextPos caret = control.getCaretPosition();\n+        if (caret == null) {\n+            removeCaretAndSelection();\n+            return;\n+        }\n+\n+        TextPos anchor = control.getAnchorPosition();\n+        if (anchor == null) {\n+            anchor = caret;\n+        }\n+\n+        \/\/ current line highlight\n+        if (control.isHighlightCurrentParagraph()) {\n+            FxPathBuilder b = new FxPathBuilder();\n+            createCurrentLineHighlight(b, caret);\n+            caretLineHighlight.getElements().setAll(b.getPathElements());\n+        } else {\n+            caretLineHighlight.getElements().clear();\n+        }\n+\n+        \/\/ selection\n+        FxPathBuilder b = new FxPathBuilder();\n+        createSelectionHighlight(b, anchor, caret);\n+        selectionHighlight.getElements().setAll(b.getPathElements());\n+        selectionHighlight.setTranslateX(contentPaddingLeft);\n+\n+        \/\/ caret\n+        b = new FxPathBuilder();\n+        createCaretPath(b, caret);\n+        caretPath.getElements().setAll(b.getPathElements());\n+        caretPath.setTranslateX(contentPaddingLeft);\n+    }\n+\n+    protected void removeCaretAndSelection() {\n+        caretLineHighlight.getElements().clear();\n+        selectionHighlight.getElements().clear();\n+        caretPath.getElements().clear();\n+    }\n+\n+    protected void createCaretPath(FxPathBuilder b, TextPos p) {\n+        CaretInfo c = getCaretInfo(p);\n+        if (c != null) {\n+            b.addAll(c.path());\n+        }\n+    }\n+\n+    protected void createSelectionHighlight(FxPathBuilder b, TextPos start, TextPos end) {\n+        \/\/ probably unnecessary\n+        if ((start == null) || (end == null)) {\n+            return;\n+        }\n+\n+        int eq = start.compareTo(end);\n+        if (eq == 0) {\n+            return;\n+        } else if (eq > 0) {\n+            TextPos p = start;\n+            start = end;\n+            end = p;\n+        }\n+\n+        int topCellIndex = topCellIndex();\n+        if (end.index() < topCellIndex) {\n+            \/\/ selection is above visible area\n+            return;\n+        } else if (start.index() >= (topCellIndex + arrangement().getVisibleCellCount())) {\n+            \/\/ selection is below visible area\n+            return;\n+        }\n+\n+        \/\/ get selection shapes for top and bottom segments,\n+        \/\/ translated to this VFlow coordinates.\n+        PathElement[] top;\n+        PathElement[] bottom;\n+        if (start.index() == end.index()) {\n+            top = getRangeShape(start.index(), start.offset(), end.offset());\n+            bottom = null;\n+        } else {\n+            top = getRangeShape(start.index(), start.offset(), -1);\n+            if (top == null) {\n+                top = getRangeTop();\n+            }\n+\n+            bottom = getRangeShape(end.index(), 0, end.offset());\n+            if (bottom == null) {\n+                bottom = getRangeBottom();\n+            }\n+        }\n+\n+        \/\/ generate shapes\n+        double left = -contentPaddingLeft;\n+        double right = contentWidth();\n+        boolean topLTR = true;\n+        boolean bottomLTR = true;\n+\n+        \/\/ FIX\n+        double lineSpacing = 0.0; \/\/ this is a problem!\n+        new SelectionHelper(b, left, right).generate(top, bottom, topLTR, bottomLTR, contentPaddingLeft, lineSpacing);\n+    }\n+\n+    protected void createCurrentLineHighlight(FxPathBuilder b, TextPos caret) {\n+        int ix = caret.index();\n+        TextCell cell = arrangement().getVisibleCell(ix);\n+        if (cell != null) {\n+            double w;\n+            if (control.isWrapText()) {\n+                w = getWidth();\n+            } else {\n+                w = Math.max(getWidth(), contentWidth());\n+            }\n+            cell.addBoxOutline(b, 0.0, snapPositionX(w), cell.getCellHeight());\n+        }\n+    }\n+\n+    \/** uses vflow.content cooridinates *\/\n+    public TextPos getTextPosLocal(double localX, double localY) {\n+        return arrangement().getTextPos(localX - contentPaddingLeft, localY);\n+    }\n+\n+    \/** in vflow.content coordinates *\/\n+    protected CaretInfo getCaretInfo(TextPos p) {\n+        return arrangement().getCaretInfo(content, p);\n+    }\n+\n+    \/** returns caret sizing info using vflow.content coordinates, or null *\/\n+    public CaretInfo getCaretInfo() {\n+        TextPos p = control.getCaretPosition();\n+        if (p == null) {\n+            return null;\n+        }\n+        return getCaretInfo(p);\n+    }\n+\n+    protected PathElement[] getRangeTop() {\n+        double w = getWidth();\n+        return new PathElement[] {\n+            new MoveTo(0, -1),\n+            new LineTo(w, -1),\n+            new LineTo(w, 0),\n+            new LineTo(0, 0),\n+            new LineTo(0, -1)\n+        };\n+    }\n+\n+    protected PathElement[] getRangeBottom() {\n+        double w = getWidth();\n+        double h = getHeight();\n+        double h1 = h + 1.0;\n+\n+        return new PathElement[] {\n+            new MoveTo(0, h),\n+            new LineTo(w, h),\n+            new LineTo(w, h1),\n+            new LineTo(0, h1),\n+            new LineTo(0, h)\n+        };\n+    }\n+\n+    \/** returns the shape if both ends are at the same line, in VFlow coordinates *\/\n+    public PathElement[] getRangeShape(int line, int startOffset, int endOffset) {\n+        TextCell cell = arrangement().getVisibleCell(line);\n+        if (cell == null) {\n+            return null;\n+        }\n+\n+        if (endOffset < 0) {\n+            \/\/ FIX to the edge?? but beware of RTL\n+            endOffset = cell.getTextLength();\n+        }\n+\n+        PathElement[] pe;\n+        if (startOffset == endOffset) {\n+            \/\/ TODO handle split caret!\n+            pe = cell.getCaretShape(content, startOffset, true, -contentPaddingLeft, 0.0);\n+        } else {\n+            pe = cell.getRangeShape(content, startOffset, endOffset, -contentPaddingLeft, 0.0);\n+        }\n+        return pe;\n+    }\n+\n+    public final void setSuppressBlink(boolean on) {\n+        suppressBlink.set(on);\n+        if (!on) {\n+            updateRateRestartBlink();\n+        }\n+    }\n+\n+    public final void updateRateRestartBlink() {\n+        Duration t2 = control.getCaretBlinkPeriod();\n+        Duration t1 = t2.divide(2.0);\n+\n+        caretAnimation.stop();\n+        caretAnimation.getKeyFrames().setAll(\n+            new KeyFrame(Duration.ZERO, (ev) -> setCaretVisible(true)),\n+            new KeyFrame(t1, (ev) -> setCaretVisible(false)),\n+            new KeyFrame(t2)\n+        );\n+        caretAnimation.play();\n+    }\n+\n+    public final int getParagraphCount() {\n+        return control.getParagraphCount();\n+    }\n+\n+    \/**\n+     * Returns control's content padding, always non-null.\n+     * @return the content padding\n+     *\/\n+    public final Insets contentPadding() {\n+        Insets m = control.getContentPadding();\n+        return m == null ? Insets.EMPTY : m;\n+    }\n+\n+    private void handleVScrollMouseEvent(MouseEvent ev) {\n+        EventType<? extends MouseEvent> t = ev.getEventType();\n+        if (t == MouseEvent.MOUSE_PRESSED) {\n+            vsbPressed = true;\n+        } else if (t == MouseEvent.MOUSE_RELEASED) {\n+            vsbPressed = false;\n+            updateVerticalScrollBar();\n+        }\n+    }\n+\n+    \/** updates VSB in response to change in height, layout, or offsetY *\/\n+    protected void updateVerticalScrollBar() {\n+        double visible;\n+        double val;\n+        if (getParagraphCount() == 0) {\n+            visible = 1.0;\n+            val = 0.0;\n+        } else {\n+            CellArrangement ar = arrangement();\n+            double av = ar.averageHeight();\n+            double max = ar.estimatedMax();\n+            double h = getHeight();\n+            val = toScrollBarValue((topCellIndex() - ar.topCount()) * av + ar.topHeight(), h, max);\n+            visible = h \/ max;\n+        }\n+\n+        handleScrollEvents = false;\n+\n+        vscroll.setVisibleAmount(visible);\n+        vscroll.setValue(val);\n+\n+        handleScrollEvents = true;\n+    }\n+\n+    \/** handles user moving the vertical scroll bar *\/\n+    public void handleVerticalScroll() {\n+        if (handleScrollEvents) {\n+            if (getParagraphCount() == 0) {\n+                return;\n+            }\n+\n+            double max = vscroll.getMax();\n+            double val = vscroll.getValue();\n+            double visible = vscroll.getVisibleAmount();\n+            double pos = fromScrollBarValue(val, visible, max); \/\/ max is 1.0\n+\n+            Origin p = arrangement().fromAbsolutePosition(pos);\n+            setOrigin(p);\n+        }\n+    }\n+\n+    \/** updates HSB in response to change in width, layout, or offsetX *\/\n+    protected void updateHorizontalScrollBar() {\n+        if (control.isWrapText()) {\n+            return;\n+        }\n+\n+        double max = contentWidth();\n+        double w = vport.getWidth();\n+        double off = getOffsetX();\n+        double vis = w \/ max;\n+        double val = toScrollBarValue(off, w, max);\n+\n+        handleScrollEvents = false;\n+\n+        hscroll.setVisibleAmount(vis);\n+        hscroll.setValue(val);\n+\n+        handleScrollEvents = true;\n+    }\n+\n+    \/** handles user moving the horizontal scroll bar *\/\n+    public void handleHorizontalScroll() {\n+        if (handleScrollEvents) {\n+            if ((arrangement == null) || control.isWrapText()) {\n+                return;\n+            }\n+\n+            double max = contentWidth();\n+            double visible = vport.getWidth();\n+            double val = hscroll.getValue();\n+            double off = fromScrollBarValue(val, visible, max);\n+\n+            setOffsetX(off);\n+        }\n+    }\n+\n+    \/**\n+     * javafx ScrollBar is weird in that the value has a range between [min,max] regardless of visible amount.\n+     * this method generates the value ScrollBar expects by renormalizing it to a [min,max-visible] range,\n+     * assuming min == 0.\n+     *\/\n+    private static double toScrollBarValue(double val, double visible, double max) {\n+        if (Math.abs(max - visible) < 1e-10) {\n+            return 0.0;\n+        } else {\n+            return val \/ (max - visible);\n+        }\n+    }\n+\n+    \/** inverse of {@link #toScrollBarValue}, returns the scroll bar value that takes into account visible amount *\/\n+    private static double fromScrollBarValue(double val, double visible, double max) {\n+        return val * (max - visible);\n+    }\n+\n+    public TextCell getCell(int modelIndex) {\n+        TextCell cell = cellCache.get(modelIndex);\n+        if (cell == null) {\n+            RichParagraph rp = control.getModel().getParagraph(modelIndex);\n+            cell = createTextCell(modelIndex, rp);\n+            cellCache.add(cell.getIndex(), cell);\n+        }\n+        return cell;\n+    }\n+\n+    private TextCell createTextCell(int index, RichParagraph par) {\n+        if(par == null) {\n+            return null;\n+        }\n+        TextCell cell;\n+        StyleAttributeMap pa = par.getParagraphAttributes();\n+        Supplier<Region> gen = par.getParagraphRegion();\n+        if (gen != null) {\n+            \/\/ it's a paragraph node\n+            Region content = gen.get();\n+            cell = new TextCell(index, content);\n+        } else {\n+            \/\/ it's a regular text cell\n+            cell = new TextCell(index);\n+\n+            \/\/ first line indent operates on TextCell and not its content\n+            if (pa != null) {\n+                Double firstLineIndent = pa.getFirstLineIndent();\n+                if (firstLineIndent != null) {\n+                    cell.add(new FirstLineIndentSpacer(firstLineIndent));\n+                }\n+            }\n+\n+            \/\/ highlights\n+            List<Consumer<TextCell>> highlights = RichParagraphHelper.getHighlights(par);\n+            if (highlights != null) {\n+                for (Consumer<TextCell> h : highlights) {\n+                    h.accept(cell);\n+                }\n+            }\n+\n+            \/\/ segments\n+            List<StyledSegment> segments = RichParagraphHelper.getSegments(par);\n+            if ((segments == null) || segments.isEmpty()) {\n+                \/\/ a bit of a hack: avoid TextCells with an empty TextFlow,\n+                \/\/ otherwise it makes the caret collapse to a single point\n+                cell.add(createTextNode(\"\", StyleAttributeMap.EMPTY));\n+            } else {\n+                for (StyledSegment seg : segments) {\n+                    switch (seg.getType()) {\n+                    case INLINE_NODE:\n+                        Node n = seg.getInlineNodeGenerator().get();\n+                        cell.add(n);\n+                        break;\n+                    case TEXT:\n+                        String text = seg.getText();\n+                        StyleAttributeMap a = seg.getStyleAttributeMap(this);\n+                        Text t = createTextNode(text, a);\n+                        cell.add(t);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (pa == null) {\n+            pa = StyleAttributeMap.EMPTY;\n+        } else {\n+            \/\/ these two attributes operate on TextCell instead of its content\n+            String bullet = pa.getBullet();\n+            if (bullet != null) {\n+                cell.setBullet(bullet);\n+            }\n+\n+            if (control.isWrapText()) {\n+                ParagraphDirection d = pa.getParagraphDirection();\n+                if (d != null) {\n+                    switch (d) {\n+                    case LEFT_TO_RIGHT:\n+                        cell.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);\n+                        break;\n+                    case RIGHT_TO_LEFT:\n+                        cell.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        context.reset(cell.getContent(), pa);\n+        skin.applyStyles(context, pa, true);\n+        context.apply();\n+\n+        return cell;\n+    }\n+\n+    private Text createTextNode(String text, StyleAttributeMap attrs) {\n+        Text t = new Text(text);\n+        context.reset(t, attrs);\n+        skin.applyStyles(context, attrs, false);\n+        context.apply();\n+        return t;\n+    }\n+\n+    private double computeSideWidth(SideDecorator d) {\n+        if (d != null) {\n+            double w = d.getPrefWidth(getWidth());\n+            if (w <= 0.0) {\n+                int top = topCellIndex();\n+                Node n = d.getNode(top, true);\n+                n.setManaged(false);\n+\n+                content.getChildren().add(n);\n+                try {\n+                    n.applyCss();\n+                    if (n instanceof Parent p) {\n+                        p.layout();\n+                    }\n+                    w = n.prefWidth(-1);\n+                } finally {\n+                    content.getChildren().remove(n);\n+                }\n+            }\n+            \/\/ introducing some granularity in order to avoid left boundary moving back and forth when scrolling\n+            double granularity = 15;\n+            w = (Math.round((w + 1.0) \/ granularity) + 1.0) * granularity;\n+            return snapSizeX(w);\n+        }\n+        return 0.0;\n+    }\n+\n+    \/** returns a non-null layout, laying out cells if necessary *\/\n+    protected CellArrangement arrangement() {\n+        if (!inReflow && dirty || (arrangement == null)) {\n+            layoutChildren();\n+        }\n+        return arrangement;\n+    }\n+\n+    private double getLineSpacing(Region r) {\n+        if (r instanceof TextFlow f) {\n+            return f.getLineSpacing();\n+        }\n+        return 0.0;\n+    }\n+\n+    public double getViewPortHeight() {\n+        return viewPortHeight;\n+    }\n+\n+    public void pageUp() {\n+        scrollVerticalPixels(-getViewPortHeight());\n+    }\n+\n+    public void pageDown() {\n+        scrollVerticalPixels(getViewPortHeight());\n+    }\n+\n+    public void scrollVerticalFraction(double fractionOfHeight) {\n+        scrollVerticalPixels(getViewPortHeight() * fractionOfHeight);\n+    }\n+\n+    \/** scroll by a number of pixels, delta must not exceed the view height in absolute terms *\/\n+    public void scrollVerticalPixels(double delta) {\n+        scrollVerticalPixels(delta, false);\n+    }\n+\n+    \/** scroll by a number of pixels, delta must not exceed the view height in absolute terms *\/\n+    public void scrollVerticalPixels(double delta, boolean forceLayout) {\n+        Origin or = arrangement().computeOrigin(delta);\n+        if (or != null) {\n+            setOrigin(or);\n+            if (forceLayout) {\n+                layoutChildren();\n+            }\n+        }\n+    }\n+\n+    public void scrollHorizontalFraction(double delta) {\n+        double w = content.getWidth() + contentPaddingLeft + contentPaddingRight;\n+        scrollHorizontalPixels(delta * w);\n+    }\n+\n+    public void scrollHorizontalPixels(double delta) {\n+        double x = getOffsetX() + delta;\n+        if ((x + vport.getWidth()) > contentWidth()) {\n+            x = contentWidth() - vport.getWidth();\n+        }\n+        setOffsetX(x);\n+    }\n+\n+    \/** x in vflow.content coordinate *\/\n+    private void scrollHorizontalToVisible(double x) {\n+        if (!control.isWrapText()) {\n+            double off;\n+            if (x < getOffsetX()) {\n+                off = x - Params.HORIZONTAL_GUARD;\n+            } else if (x > (getOffsetX() + vport.getWidth())) {\n+                off = x + Params.HORIZONTAL_GUARD - vport.getWidth();\n+            } else {\n+                return;\n+            }\n+\n+            setOffsetX(off);\n+        }\n+    }\n+\n+    \/** scrolls to visible area, using vflow.content coordinates *\/\n+    public void scrollToVisible(double x, double y) {\n+        if (y < 0.0) {\n+            \/\/ above viewport\n+            scrollVerticalPixels(y);\n+        } else if (y >= getViewPortHeight()) {\n+            \/\/ below viewport\n+            scrollVerticalPixels(y - getViewPortHeight());\n+        }\n+\n+        scrollHorizontalToVisible(x);\n+    }\n+\n+    public void scrollCaretToVisible() {\n+        CaretInfo c = getCaretInfo();\n+        if (c == null) {\n+            \/\/ caret is outside of the layout; let's set the origin first to the caret position\n+            \/\/ and then block scroll to avoid scrolling past the document end, if needed\n+            TextPos p = control.getCaretPosition();\n+            if (p != null) {\n+                int ix = p.index();\n+                Origin or = new Origin(ix, 0.0);\n+                boolean moveDown = (ix > getOrigin().index());\n+                setOrigin(or);\n+                c = getCaretInfo();\n+                if (moveDown) {\n+                    scrollVerticalPixels(c.getMaxY() - c.getMinY() - getViewPortHeight());\n+                }\n+                checkForExcessiveWhitespaceAtTheEnd();\n+            }\n+        } else {\n+            \/\/ block scroll, if needed\n+            if (c.getMinY() < 0.0) {\n+                scrollVerticalPixels(c.getMinY());\n+            } else if (c.getMaxY() > getViewPortHeight()) {\n+                scrollVerticalPixels(c.getMaxY() - getViewPortHeight());\n+            }\n+\n+            if (!control.isWrapText()) {\n+                \/\/ FIX primary caret\n+                double x = c.getMinX();\n+                if (x + contentPaddingLeft < 0.0) {\n+                    scrollHorizontalToVisible(x);\n+                } else {\n+                    scrollHorizontalToVisible(c.getMaxX());\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void checkForExcessiveWhitespaceAtTheEnd() {\n+        double delta = arrangement().bottomHeight() - getViewPortHeight();\n+        if (delta < 0) {\n+            if (getOrigin().index() == 0) {\n+                if (getOrigin().offset() <= -contentPaddingTop) {\n+                    return;\n+                }\n+            }\n+            scrollVerticalPixels(delta);\n+        }\n+    }\n+\n+    @Override\n+    public void onContentChange(ContentChange ch) {\n+        if (ch.isEdit()) {\n+            Origin newOrigin = computeNewOrigin(ch);\n+            if (newOrigin != null) {\n+                setOrigin(newOrigin);\n+            }\n+        }\n+        \/\/ TODO this could be more advanced to reduce the amount of re-computation and re-flow\n+        \/\/ TODO clear cache >= start, update layout\n+        cellCache.clear();\n+        \/\/ TODO rebuild from start.lineIndex()\n+        requestLayout();\n+    }\n+\n+    private Origin computeNewOrigin(ContentChange ch) {\n+        int startIndex = ch.getStart().index();\n+        int endIndex = ch.getEnd().index();\n+        \/\/ TODO store position of the last visible symbol, use that to compare with 'start' to avoid reflow\n+        Origin or = getOrigin();\n+        int lineDelta = endIndex - startIndex + ch.getLinesAdded();\n+\n+        \/\/ jump to start if the old origin is within the changed range\n+        if ((startIndex <= or.index()) && (or.index() < (startIndex + lineDelta))) {\n+            return new Origin(startIndex, 0);\n+        }\n+\n+        \/\/ adjust index only if the end precedes the origin\n+        if (lineDelta != 0) {\n+            if (\n+                (endIndex < or.index()) ||\n+                (\n+                    (endIndex == or.index()) &&\n+                    (ch.getEnd().offset() < or.offset())\n+                )\n+            )\n+            {\n+                return new Origin(or.index() + lineDelta, or.offset());\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public StyleAttributeMap resolveStyles(StyleAttributeMap attrs) {\n+        if (attrs == null) {\n+            return attrs;\n+        }\n+        CssStyles css = attrs.get(CssStyles.CSS);\n+        if (css == null) {\n+            \/\/ no conversion is needed\n+            return attrs;\n+        }\n+\n+        String directStyle = css.style();\n+        String[] names = css.names();\n+\n+        getChildren().add(measurer);\n+        try {\n+            measurer.setStyle(directStyle);\n+            if (names == null) {\n+                measurer.getStyleClass().clear();\n+            } else {\n+                measurer.getStyleClass().setAll(names);\n+            }\n+            measurer.applyCss();\n+            return StyleAttributeMap.fromTextNode(measurer);\n+        } finally {\n+            getChildren().remove(measurer);\n+        }\n+    }\n+\n+    @Override\n+    public WritableImage snapshot(Node n) {\n+        n.setManaged(false);\n+        getChildren().add(n);\n+        try {\n+            n.applyCss();\n+            if (n instanceof Region r) {\n+                double w = unwrappedContentWidth;\n+                double h = r.prefHeight(w);\n+                RichUtils.layoutInArea(r, 0, -h, w, h);\n+            }\n+            return n.snapshot(null, null);\n+        } finally {\n+            getChildren().remove(n);\n+        }\n+    }\n+\n+    public void handleUseContentHeight() {\n+        boolean on = control.isUseContentHeight();\n+        if (on) {\n+            setUnwrappedContentWidth(0.0);\n+            setOrigin(new Origin(0, -contentPaddingTop));\n+            setOffsetX(0.0);\n+        }\n+        requestControlLayout(false);\n+    }\n+\n+    public void handleUseContentWidth() {\n+        boolean on = control.isUseContentWidth();\n+        if (on) {\n+            setUnwrappedContentWidth(0.0);\n+            setOrigin(new Origin(0, -contentPaddingTop));\n+            setOffsetX(0.0);\n+        }\n+        requestControlLayout(false);\n+    }\n+\n+    @Override\n+    public void requestLayout() {\n+        dirty = true;\n+        super.requestLayout();\n+    }\n+\n+    \/**\n+     * Requests full layout with optional clearing of the cached cells.\n+     * @param clearCache if true, clears the cell cache\n+     *\/\n+    public void requestControlLayout(boolean clearCache) {\n+        if (clearCache) {\n+            cellCache.clear();\n+        }\n+        requestParentLayout();\n+        requestLayout();\n+    }\n+\n+    private void updatePrefWidth() {\n+        if (!control.prefWidthProperty().isBound()) {\n+            double w =\n+                arrangement().getUnwrappedWidth() +\n+                snapSizeX(leftSide) +\n+                snapSizeX(rightSide) +\n+                contentPaddingLeft +\n+                contentPaddingRight +\n+                snapSizeX(Params.HORIZONTAL_GUARD);\n+\n+            if (w >= 0.0) {\n+                if (vscroll.isVisible()) {\n+                    w += vscroll.getWidth();\n+                }\n+            }\n+\n+            Parent parent = getParent();\n+            if (parent instanceof Region r) {\n+                if (r.getPrefWidth() != w) {\n+                    r.setPrefWidth(w);\n+                    control.getParent().requestLayout();\n+                    requestControlLayout(false);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected double computePrefHeight(double width) {\n+        if (control.isUseContentHeight()) {\n+            double h = snapSizeY(Math.max(Params.LAYOUT_MIN_HEIGHT, arrangement().bottomHeight())) + snappedTopInset() + snappedBottomInset();\n+            if (hscroll.isVisible()) {\n+                h += hscroll.prefHeight(width);\n+            }\n+            return h;\n+        }\n+        return super.computePrefHeight(width);\n+    }\n+\n+    @Override\n+    protected double computePrefWidth(double height) {\n+        if (control.isUseContentWidth()) {\n+            double w = contentWidth() + leftSide + rightSide + snappedLeftInset() + snappedRightInset();\n+            if (vscroll.isVisible()) {\n+                w += vscroll.prefWidth(height);\n+            }\n+            return w;\n+        }\n+        return super.computePrefWidth(height);\n+    }\n+\n+    @Override\n+    protected void layoutChildren() {\n+        inReflow = true;\n+        try {\n+            layoutCells();\n+\n+            checkForExcessiveWhitespaceAtTheEnd();\n+            updateCaretAndSelection();\n+\n+            \/\/ eliminate VSB jitter during scrolling with a mouse\n+            \/\/ the VSB will finally get updated on mouse released event\n+            if (!vsbPressed) {\n+                updateVerticalScrollBar();\n+            }\n+        } finally {\n+            dirty = false;\n+            inReflow = false;\n+        }\n+    }\n+\n+    \/**\n+     * Recomputes sliding window and lays out scrollbars, left\/right sides, and viewport.\n+     * This process might be repeated if one of the scroll bars changes its visibility as a result.\n+     * (up to 4 times worst case)\n+     *\/\n+    protected void layoutCells() {\n+        if (arrangement != null) {\n+            arrangement.removeNodesFrom(content);\n+            arrangement = null;\n+        }\n+        arrangement = new CellArrangement(this);\n+\n+        double width = getWidth();\n+        if (width == 0.0) {\n+            return;\n+        }\n+\n+        double padTop = snappedTopInset();\n+        double padBottom = snappedBottomInset();\n+        double padLeft = snappedLeftInset();\n+        double padRight = snappedRightInset();\n+\n+        \/\/ sides\n+        SideDecorator leftDecorator = control.getLeftDecorator();\n+        SideDecorator rightDecorator = control.getRightDecorator();\n+        leftSide = computeSideWidth(leftDecorator);\n+        rightSide = computeSideWidth(rightDecorator);\n+\n+        int paragraphCount = getParagraphCount();\n+        boolean useContentHeight = control.isUseContentHeight();\n+        boolean useContentWidth = control.isUseContentWidth();\n+        boolean wrap = control.isWrapText() && !useContentWidth;\n+        \/\/ FIX height as in component height vs. contentHeight in useContentHeight!\n+        \/\/double height = useContentHeight ? (padTop + padBottom + contentPaddingTop + contentPaddingBottom) : getHeight();\n+        double height = getHeight();\n+        double vsbWidth = vscroll.isVisible() ? vscroll.prefWidth(-1) : 0.0;\n+        double hsbHeight = hscroll.isVisible() ? hscroll.prefHeight(-1) : 0.0;\n+\n+        double forWidth; \/\/ to be used for cell sizing in prefHeight()\n+        double maxWidth; \/\/ TODO what is it?  replace with cell's preferred width (in unwrapped mode)\n+        if (wrap) {\n+            forWidth = width - leftSide - rightSide - contentPaddingLeft - contentPaddingRight - vsbWidth - padLeft - padRight;\n+            maxWidth = forWidth;\n+        } else {\n+            forWidth = -1.0;\n+            maxWidth = Params.MAX_WIDTH_FOR_LAYOUT;\n+        }\n+\n+        double unwrappedWidth = 0.0;\n+        \/\/ total height of visible cells for the purpose of determining vsb visibility\n+        double arrangementHeight = 0.0;\n+\n+        double ytop = snapPositionY(-getOrigin().offset());\n+        double y = ytop;\n+        double margin = Params.SLIDING_WINDOW_EXTENT * height;\n+        int topMarginCount = 0;\n+        int bottomMarginCount = 0;\n+        int count = 0;\n+        boolean cellOnScreen = true;\n+        \/\/ TODO if topCount < marginCount, increase bottomCount correspondingly\n+\n+        \/\/ populating visible part of the sliding window + bottom margin\n+        int i = topCellIndex();\n+        for ( ; i < paragraphCount; i++) {\n+            TextCell cell = getCell(i);\n+            \/\/ TODO skip computation if layout width is the same\n+            Region r = cell.getContent();\n+            content.getChildren().add(cell);\n+            cell.setMaxWidth(maxWidth);\n+            cell.setMaxHeight(USE_COMPUTED_SIZE);\n+            cell.applyCss();\n+            cell.layout();\n+\n+            arrangement.addCell(cell);\n+\n+            double h = cell.prefHeight(forWidth) + getLineSpacing(r);\n+            h = snapSizeY(h);\n+            cell.setPosition(y, h);\n+\n+            if (!wrap) {\n+                if (cellOnScreen) {\n+                    double w = cell.prefWidth(-1);\n+                    cell.setCellWidth(w);\n+                    if (w > unwrappedWidth) {\n+                        unwrappedWidth = w;\n+                    }\n+                }\n+            }\n+\n+            y = snapPositionY(y + h);\n+            arrangementHeight += h;\n+            count++;\n+\n+            if (useContentHeight) {\n+                \/\/ avoid laying out millions of invisible cells\n+                if (y > Params.MAX_HEIGHT_SAFEGUARD) {\n+                    break;\n+                }\n+            } else {\n+                \/\/ stop populating the bottom part of the sliding window\n+                \/\/ when exceeded both pixel and line count margins\n+                if (cellOnScreen) {\n+                    if (y > height) {\n+                        topMarginCount = (int)Math.ceil(count * Params.SLIDING_WINDOW_EXTENT);\n+                        bottomMarginCount = count + topMarginCount;\n+                        arrangement.setVisibleCellCount(count);\n+                        cellOnScreen = false;\n+                    }\n+                } else {\n+                    \/\/ remove invisible cell from layout after sizing\n+                    content.getChildren().remove(cell);\n+\n+                    if ((y > (height + margin)) && (count > bottomMarginCount)) {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ in case there are less paragraphs than can fit in the view\n+        if (cellOnScreen) {\n+            arrangement.setVisibleCellCount(count);\n+        }\n+\n+        if (i == paragraphCount) {\n+            y += contentPaddingBottom;\n+        }\n+\n+        \/\/ populate side nodes\n+        if (leftDecorator != null) {\n+            if (leftCache == null) {\n+                leftCache = updateSideCache(leftDecorator, null);\n+            }\n+\n+            for (i = 0; i < arrangement.getVisibleCellCount(); i++) {\n+                TextCell cell = arrangement.getCellAt(i);\n+                int ix = cell.getIndex();\n+                Node n = leftCache.get(ix);\n+                if (n == null) {\n+                    n = leftDecorator.getNode(ix, false);\n+                    if (n != null) {\n+                        n.setManaged(false);\n+                        leftCache.add(ix, n);\n+                    }\n+                }\n+                if (n != null) {\n+                    arrangement.addLeftNode(i, n);\n+                }\n+            }\n+        }\n+\n+        if (rightDecorator != null) {\n+            if (rightCache == null) {\n+                rightCache = updateSideCache(rightDecorator, null);\n+            }\n+\n+            for (i = 0; i < arrangement.getVisibleCellCount(); i++) {\n+                TextCell cell = arrangement.getCellAt(i);\n+                int ix = cell.getIndex();\n+                Node n = rightCache.get(ix);\n+                if (n == null) {\n+                    n = rightDecorator.getNode(cell.getIndex(), false);\n+                    if (n != null) {\n+                        n.setManaged(false);\n+                        rightCache.add(ix, n);\n+                    }\n+                }\n+                if (n != null) {\n+                    arrangement.addRightNode(i, n);\n+                }\n+            }\n+        }\n+\n+        unwrappedWidth = snapSizeX(unwrappedWidth);\n+\n+        arrangement.setBottomCount(count);\n+        arrangement.setBottomHeight(y);\n+        arrangement.setUnwrappedWidth(unwrappedWidth);\n+        count = 0;\n+        y = ytop;\n+\n+        \/\/ populate top margin, going backwards from topCellIndex\n+        \/\/ TODO populate more, if bottom ended prematurely\n+        for (i = topCellIndex() - 1; i >= 0; i--) {\n+            TextCell cell = getCell(i);\n+            \/\/ TODO maybe skip computation if layout width is the same\n+            Region r = cell.getContent();\n+            content.getChildren().add(cell);\n+            cell.setMaxWidth(maxWidth);\n+            cell.setMaxHeight(USE_COMPUTED_SIZE);\n+\n+            cell.applyCss();\n+\/\/            cell.layout();\n+\n+            arrangement.addCell(cell);\n+\n+            double h = cell.prefHeight(forWidth) + getLineSpacing(r);\n+            h = snapSizeY(h);\n+            y = snapPositionY(y - h);\n+            count++;\n+\n+            cell.setPosition(y, h);\n+\n+            content.getChildren().remove(cell);\n+\n+            \/\/ stop populating the top part of the sliding window\n+            \/\/ when exceeded both pixel and line count margins\n+            if ((-y > margin) && (count > topMarginCount)) {\n+                break;\n+            }\n+        }\n+\n+        arrangement.setTopHeight(-y);\n+\n+        if (useContentWidth) {\n+            width = unwrappedWidth + leftSide + rightSide + contentPaddingLeft + contentPaddingRight + padLeft + padRight;\n+        }\n+\n+        viewPortWidth = width - leftSide - rightSide - vsbWidth - padLeft - padRight;\n+        if (viewPortWidth < Params.MIN_VIEWPORT_WIDTH) {\n+            viewPortWidth = Params.MIN_VIEWPORT_WIDTH;\n+        }\n+        viewPortHeight = height - hsbHeight - padTop - padBottom;\n+\n+        \/\/ layout\n+\n+        \/\/ scroll bars\n+        boolean vsbVisible = useContentHeight ?\n+            false :\n+            (topCellIndex() > 0) ?\n+                true :\n+                (arrangementHeight + contentPaddingTop + contentPaddingBottom) > viewPortHeight;\n+\n+        if (vsbVisible != vscroll.isVisible()) {\n+            vscroll.setVisible(vsbVisible);\n+            \/\/ do another layout pass with the scrollbar updated\n+            layoutCells();\n+            return;\n+        }\n+        if (vsbVisible) {\n+            width -= vsbWidth; \/\/ TODO or use viewportwidth?\n+        }\n+\n+        boolean hsbVisible = (wrap || useContentWidth) ?\n+            false :\n+            (unwrappedWidth + contentPaddingLeft + contentPaddingRight) > viewPortWidth;\n+\n+        if (hscroll.isVisible() != hsbVisible) {\n+            hscroll.setVisible(hsbVisible);\n+            \/\/ do another layout pass with the scrollbar updated\n+            layoutCells();\n+            return;\n+        }\n+\n+        double h;\n+        if (useContentHeight) {\n+            h = contentPaddingTop + contentPaddingBottom + arrangementHeight;\n+        } else {\n+            h = height - hsbHeight - padTop - padBottom;\n+        }\n+\n+        if (vsbVisible) {\n+            RichUtils.layoutInArea(vscroll, width - padRight, padTop, vsbWidth, h);\n+        }\n+        if (hsbVisible) {\n+            RichUtils.layoutInArea(hscroll, padLeft, h, width - padLeft - padRight, hsbHeight);\n+        }\n+\n+        \/\/ gutters\n+        if (leftDecorator == null) {\n+            leftGutter.setVisible(false);\n+        } else {\n+            leftGutter.setVisible(true);\n+            RichUtils.layoutInArea(leftGutter, padLeft, padTop, leftSide, h);\n+        }\n+\n+        if (rightDecorator == null) {\n+            rightGutter.setVisible(false);\n+        } else {\n+            rightGutter.setVisible(true);\n+            RichUtils.layoutInArea(rightGutter, width - rightSide - padRight, padTop, rightSide, h);\n+        }\n+\n+        RichUtils.layoutInArea(vport, leftSide + padLeft, padTop, viewPortWidth, h);\n+        \/\/ vport is a child of content\n+        RichUtils.layoutInArea(content, 0.0, 0.0, viewPortWidth, h);\n+\n+        if (wrap) {\n+            double w = viewPortWidth;\n+            setUnwrappedContentWidth(w);\n+        } else {\n+            if (unwrappedContentWidth != unwrappedWidth) {\n+                setUnwrappedContentWidth(unwrappedWidth);\n+\n+                if (useContentWidth) {\n+                    requestControlLayout(false);\n+                }\n+            }\n+        }\n+\n+        if (useContentWidth) {\n+            updatePrefWidth();\n+        }\n+\n+        if (useContentHeight) {\n+            double ph = computePrefHeight(-1);\n+            double prev = getPrefHeight();\n+\n+            \/\/ necessary for vertical stacking\n+            setPrefHeight(ph);\n+            requestParentLayout();\n+\n+            \/\/ avoids infinite layout loop in MultipleStackedBoxWindow but ... why?\n+            if (ph != prev) {\n+                requestLayout();\n+                \/\/ FIX perhaps create a boolean for 'reflow is required' and layoutCells again at the end?\n+                \/\/ weird, need this to make sure the reflow happens when changing models\n+                Platform.runLater(() -> layoutChildren());\n+            }\n+        } else {\n+            if (getPrefHeight() != USE_COMPUTED_SIZE) {\n+                setPrefHeight(USE_COMPUTED_SIZE);\n+            }\n+        }\n+\n+        \/\/ position cells\n+\n+        leftGutter.getChildren().clear();\n+        rightGutter.getChildren().clear();\n+\n+        boolean addLeft = control.getLeftDecorator() != null;\n+        boolean addRight = control.getRightDecorator() != null;\n+\n+        \/\/ FIX weird, it should be contentPaddingLeft always...\n+        double x = wrap ? 0.0 : contentPaddingLeft;\n+\n+        int sz = arrangement.getVisibleCellCount();\n+        for (i = 0; i < sz; i++) {\n+            TextCell cell = arrangement.getCellAt(i);\n+            double ch = cell.getCellHeight();\n+            double cy = cell.getY();\n+            double cw = wrap ? viewPortWidth : cell.getCellWidth();\n+            RichUtils.layoutInArea(cell, x, cy, cw, ch);\n+\n+            \/\/ needed to get the correct caret path afterwards\n+            cell.layout();\n+\n+            \/\/ place side nodes\n+            if (addLeft) {\n+                Node n = arrangement.getLeftNodeAt(i);\n+                if (n != null) {\n+                    leftGutter.getChildren().add(n);\n+                    n.applyCss();\n+                    RichUtils.layoutInArea(n, 0.0, cy, leftGutter.getWidth(), ch);\n+                }\n+            }\n+\n+            if (addRight) {\n+                Node n = arrangement.getRightNodeAt(i);\n+                if (n != null) {\n+                    rightGutter.getChildren().add(n);\n+                    n.applyCss();\n+                    RichUtils.layoutInArea(n, 0.0, cy, rightGutter.getWidth(), ch);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/VFlow.java","additions":1573,"deletions":0,"binary":false,"changes":1573,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import javafx.scene.Node;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.skin.CellContext;\n+\n+\/**\n+ * Assist in creating virtualized text cells.\n+ *\/\n+class VFlowCellContext implements CellContext {\n+    private Node node;\n+    private StyleAttributeMap attrs;\n+    private final StringBuilder style = new StringBuilder();\n+\n+    public VFlowCellContext() {\n+    }\n+\n+    @Override\n+    public void addStyle(String fxStyle) {\n+        style.append(fxStyle);\n+    }\n+\n+    @Override\n+    public StyleAttributeMap getAttributes() {\n+        return attrs;\n+    }\n+\n+    @Override\n+    public Node getNode() {\n+        return node;\n+    }\n+\n+    void reset(Node n, StyleAttributeMap a) {\n+        this.node = n;\n+        this.attrs = a;\n+        style.setLength(0);\n+    }\n+\n+    void apply() {\n+        if (style.length() > 0) {\n+            String s = style.toString();\n+            node.setStyle(s);\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/VFlowCellContext.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ adapted from package javax.swing.text.rtf;\n+package com.sun.jfx.incubator.scene.control.richtext.rtf;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Reader;\n+\n+\/**\n+ * A generic superclass for streams which read and parse text\n+ * consisting of runs of characters interspersed with occasional\n+ * ``specials'' (formatting characters).\n+ *\n+ * <p> Most of the functionality\n+ * of this class would be redundant except that the\n+ * <code>ByteToChar<\/code> converters\n+ * are suddenly private API. Presumably this class will disappear\n+ * when the API is made public again. (sigh) That will also let us handle\n+ * multibyte character sets...\n+ *\n+ * <P> A subclass should override at least <code>write(char)<\/code>\n+ * and <code>writeSpecial(int)<\/code>. For efficiency's sake it's a\n+ * good idea to override <code>write(String)<\/code> as well. The subclass'\n+ * initializer may also install appropriate translation and specials tables.\n+ *\n+ * @see OutputStream\n+ *\/\n+abstract class AbstractFilter extends OutputStream {\n+    \/** A table mapping bytes to characters *\/\n+    protected char[] translationTable;\n+    \/** A table indicating which byte values should be interpreted as\n+     *  characters and which should be treated as formatting codes *\/\n+    protected boolean[] specialsTable;\n+\n+    \/** A translation table which does ISO Latin-1 (trivial) *\/\n+    static final char[] latin1TranslationTable;\n+    \/** A specials table which indicates that no characters are special *\/\n+    static final boolean[] noSpecialsTable;\n+    \/** A specials table which indicates that all characters are special *\/\n+    static final boolean[] allSpecialsTable;\n+\n+    static {\n+        noSpecialsTable = new boolean[256];\n+        for (int i = 0; i < 256; i++) {\n+            noSpecialsTable[i] = false;\n+        }\n+        allSpecialsTable = new boolean[256];\n+        for (int i = 0; i < 256; i++) {\n+            allSpecialsTable[i] = true;\n+        }\n+        latin1TranslationTable = new char[256];\n+        for (int i = 0; i < 256; i++) {\n+            latin1TranslationTable[i] = (char)i;\n+        }\n+    }\n+\n+    \/**\n+     * A convenience method that reads text from a FileInputStream\n+     * and writes it to the receiver.\n+     * The format in which the file\n+     * is read is determined by the concrete subclass of\n+     * AbstractFilter to which this method is sent.\n+     * <p>This method does not close the receiver after reaching EOF on\n+     * the input stream.\n+     * The user must call <code>close()<\/code> to ensure that all\n+     * data are processed.\n+     *\n+     * @param in      An InputStream providing text.\n+     *\/\n+    public void readFromStream(InputStream in) throws IOException {\n+        in.transferTo(this);\n+    }\n+\n+    public void readFromReader(Reader in) throws IOException {\n+        char[] buf = new char[2048];\n+        while (true) {\n+            int count = in.read(buf);\n+            if (count < 0) {\n+                break;\n+            }\n+            for (int i = 0; i < count; i++) {\n+                this.write(buf[i]);\n+            }\n+        }\n+    }\n+\n+    public AbstractFilter() {\n+        translationTable = latin1TranslationTable;\n+        specialsTable = noSpecialsTable;\n+    }\n+\n+    \/**\n+     * Implements the abstract method of OutputStream, of which this class\n+     * is a subclass.\n+     *\/\n+    @Override\n+    public void write(int b) throws IOException {\n+        b &= 0xff;\n+        if (specialsTable[b])\n+            writeSpecial(b);\n+        else {\n+            char ch = translationTable[b];\n+            if (ch != (char)0) {\n+                write(ch);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Implements the buffer-at-a-time write method for greater\n+     * efficiency.\n+     *\n+     * <p> <strong>PENDING:<\/strong> Does <code>write(byte[])<\/code>\n+     * call <code>write(byte[], int, int)<\/code> or is it the other way\n+     * around?\n+     *\/\n+    @Override\n+    public void write(byte[] buf, int off, int len) throws IOException {\n+        StringBuilder accumulator = null;\n+        while (len > 0) {\n+            int b = (buf[off] & 0xff);\n+            if (specialsTable[b]) {\n+                if (accumulator != null) {\n+                    write(accumulator.toString());\n+                    accumulator = null;\n+                }\n+                writeSpecial(b);\n+            } else {\n+                char ch = translationTable[b];\n+                if (ch != (char)0) {\n+                    if (accumulator == null) {\n+                        accumulator = new StringBuilder();\n+                    }\n+                    accumulator.append(ch);\n+                }\n+            }\n+\n+            len--;\n+            off++;\n+        }\n+\n+        if (accumulator != null) {\n+            write(accumulator.toString());\n+        }\n+    }\n+\n+    \/**\n+     * Hopefully, all subclasses will override this method to accept strings\n+     * of text, but if they don't, AbstractFilter's implementation\n+     * will spoon-feed them via <code>write(char)<\/code>.\n+     *\n+     * @param s The string of non-special characters written to the\n+     *          OutputStream.\n+     *\/\n+    public void write(String s) throws IOException {\n+        int length = s.length();\n+        for (int i = 0; i < length; i++) {\n+            write(s.charAt(i));\n+        }\n+    }\n+\n+    \/**\n+     * Subclasses must provide an implementation of this method which\n+     * accepts a single (non-special) character.\n+     *\n+     * @param ch The character written to the OutputStream.\n+     *\/\n+    protected abstract void write(char ch) throws IOException;\n+\n+    \/**\n+     * Subclasses must provide an implementation of this method which\n+     * accepts a single special byte. No translation is performed\n+     * on specials.\n+     *\n+     * @param b The byte written to the OutputStream.\n+     *\/\n+    protected abstract void writeSpecial(int b) throws IOException;\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/AbstractFilter.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext.rtf;\n+\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Set;\n+import javafx.scene.paint.Color;\n+import javafx.scene.text.TextAlignment;\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * Attribute Container\n+ *\/\n+public class AttrSet {\n+    private final HashMap<Object, Object> attrs = new HashMap<>();\n+    private AttrSet parent;\n+\n+    public AttrSet(AttrSet a) {\n+    }\n+\n+    public AttrSet() {\n+    }\n+\n+    public Object getAttribute(Object attr) {\n+        Object v = attrs.get(attr);\n+        if (v == null) {\n+            if (parent != null) {\n+                v = parent.getAttribute(attr);\n+            }\n+        }\n+        return v;\n+    }\n+\n+    public Set<Object> getAttributeNames() {\n+        return attrs.keySet();\n+    }\n+\n+    public void addAttribute(Object attr, Object value) {\n+        attrs.put(attr, value);\n+    }\n+\n+    public void addAttributes(AttrSet a) {\n+        attrs.putAll(a.attrs);\n+    }\n+\n+    public void removeAttribute(Object attr) {\n+        attrs.remove(attr);\n+    }\n+\n+    \/**\n+     * Sets the resolving parent.  This is the set\n+     * of attributes to resolve through if an attribute\n+     * isn't defined locally.\n+     *\n+     * @param parent the parent\n+     *\/\n+    public void setResolveParent(AttrSet parent) {\n+        this.parent = parent;\n+    }\n+\n+    public StyleAttributeMap getStyleAttributeMap() {\n+        return StyleAttributeMap.builder().\n+            setBold(getBoolean(StyleAttributeMap.BOLD)).\n+            setFontFamily(getString(StyleAttributeMap.FONT_FAMILY)).\n+            setItalic(getBoolean(StyleAttributeMap.ITALIC)).\n+            setTextColor(getColor(StyleAttributeMap.TEXT_COLOR)).\n+            setUnderline(getBoolean(StyleAttributeMap.UNDERLINE)).\n+            build();\n+    }\n+\n+    private boolean getBoolean(Object attr) {\n+        return Boolean.TRUE.equals(attrs.get(attr));\n+    }\n+\n+    private String getString(Object attr) {\n+        Object v = attrs.get(attr);\n+        if (v instanceof String s) {\n+            return s;\n+        }\n+        return null;\n+    }\n+\n+    private Color getColor(Object attr) {\n+        Object v = attrs.get(attr);\n+        if (v instanceof Color c) {\n+            return c;\n+        }\n+        return null;\n+    }\n+\n+    public void setItalic(boolean on) {\n+        attrs.put(StyleAttributeMap.ITALIC, on);\n+    }\n+\n+    public void setBold(boolean on) {\n+        attrs.put(StyleAttributeMap.BOLD, on);\n+    }\n+\n+    public void setUnderline(boolean on) {\n+        attrs.put(StyleAttributeMap.UNDERLINE, on);\n+    }\n+\n+    public void setForeground(Color c) {\n+        attrs.put(StyleAttributeMap.TEXT_COLOR, c);\n+    }\n+\n+    public void setLeftIndent(double d) {\n+        \/\/ TODO\n+    }\n+\n+    public void setRightIndent(double d) {\n+        \/\/ TODO\n+    }\n+\n+    public void setFirstLineIndent(double d) {\n+        \/\/ TODO\n+    }\n+\n+    public void setFontFamily(String fontFamily) {\n+        attrs.put(StyleAttributeMap.FONT_FAMILY, fontFamily);\n+    }\n+\n+    public void setBackground(Color bg) {\n+        \/\/ TODO\n+    }\n+\n+    public void setAlignment(TextAlignment left) {\n+        \/\/ TODO\n+    }\n+\n+    \/**\n+     * An internal AttrSet holder.  Original name: MockAttributeSet.\n+     *\/\n+    public static class Holder extends AttrSet {\n+        public HashMap<Object, Object> backing;\n+\n+        public boolean isEmpty() {\n+            return backing.isEmpty();\n+        }\n+\n+        public int getAttributeCount() {\n+            return backing.size();\n+        }\n+\n+        public boolean isDefined(Object name) {\n+            return (backing.get(name)) != null;\n+        }\n+\n+        public boolean isEqual(AttrSet attr) {\n+            throw new InternalError();\n+        }\n+\n+        public AttrSet copyAttributes() {\n+            throw new InternalError();\n+        }\n+\n+        @Override\n+        public Object getAttribute(Object name) {\n+            return backing.get(name);\n+        }\n+\n+        public void addAttribute(StyleAttribute name, Object value) {\n+            backing.put(name, value);\n+        }\n+\n+        @Override\n+        public void addAttributes(AttrSet attr) {\n+            for (Object k : attr.getAttributeNames()) {\n+                Object v = attr.getAttribute(k);\n+                backing.put(k, v);\n+            }\n+        }\n+\n+        @Override\n+        public void removeAttribute(Object name) {\n+            backing.remove(name);\n+        }\n+\n+        public void removeAttributes(AttrSet attr) {\n+            throw new InternalError();\n+        }\n+\n+        public void removeAttributes(Enumeration<?> en) {\n+            throw new InternalError();\n+        }\n+\n+        @Override\n+        public void setResolveParent(AttrSet pp) {\n+            throw new InternalError();\n+        }\n+\n+        @Override\n+        public Set<Object> getAttributeNames() {\n+            return backing.keySet();\n+        }\n+\n+        public boolean containsAttribute(Object name, Object value) {\n+            throw new InternalError();\n+        }\n+\n+        public boolean containsAttributes(AttrSet attr) {\n+            throw new InternalError();\n+        }\n+\n+        public AttrSet getResolveParent() {\n+            throw new InternalError();\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/AttrSet.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ adapted from package javax.swing.text.rtf;\n+package com.sun.jfx.incubator.scene.control.richtext.rtf;\n+\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+\n+\/**\n+ * This abstract class defines a 1-1 mapping between\n+ * an RTF keyword and a StyleAttribute attribute.\n+ *\/\n+abstract class  RTFAttribute {\n+    public static final int D_CHARACTER = 0;\n+    public static final int D_PARAGRAPH = 1;\n+    public static final int D_SECTION = 2;\n+    public static final int D_DOCUMENT = 3;\n+    public static final int D_META = 4;\n+\n+    public abstract boolean set(AttrSet target);\n+\n+    public abstract boolean set(AttrSet target, int parameter);\n+\n+    public abstract boolean setDefault(AttrSet target);\n+\n+    protected final int domain;\n+    protected final StyleAttribute attribute;\n+    protected final String rtfName;\n+\n+    protected RTFAttribute(int domain, StyleAttribute attribute, String rtfName) {\n+        this.domain = domain;\n+        this.attribute = attribute;\n+        this.rtfName = rtfName;\n+    }\n+\n+    public int domain() {\n+        return domain;\n+    }\n+\n+    public StyleAttribute getStyleAttribute() {\n+        return attribute;\n+    }\n+\n+    public String rtfName() {\n+        return rtfName;\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/RTFAttribute.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ adapted from package javax.swing.text.rtf;\n+package com.sun.jfx.incubator.scene.control.richtext.rtf;\n+\n+import java.util.HashMap;\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+class RTFAttributes {\n+    private static final RTFAttribute[] attributes = {\n+        new BooleanAttribute(RTFAttribute.D_CHARACTER, StyleAttributeMap.ITALIC, \"i\"),\n+        new BooleanAttribute(RTFAttribute.D_CHARACTER, StyleAttributeMap.BOLD, \"b\"),\n+        new BooleanAttribute(RTFAttribute.D_CHARACTER, StyleAttributeMap.UNDERLINE, \"ul\"),\n+        new BooleanAttribute(RTFAttribute.D_CHARACTER, StyleAttributeMap.STRIKE_THROUGH, \"strike\")\n+    };\n+\n+    public static HashMap<String, RTFAttribute> attributesByKeyword() {\n+        HashMap<String, RTFAttribute> d = new HashMap<String, RTFAttribute>(attributes.length);\n+        for (RTFAttribute attribute : attributes) {\n+            d.put(attribute.rtfName(), attribute);\n+        }\n+        return d;\n+    }\n+\n+    \/**\n+     * Defines a boolean attribute.\n+     *\/\n+    static class BooleanAttribute extends RTFAttribute {\n+        private final boolean rtfDefault;\n+        private final boolean defaultValue;\n+\n+        public BooleanAttribute(int domain, StyleAttribute s, String rtfName, boolean ds, boolean dr) {\n+            super(domain, s, rtfName);\n+            defaultValue = ds;\n+            rtfDefault = dr;\n+        }\n+\n+        public BooleanAttribute(int d, StyleAttribute s, String r) {\n+            super(d, s, r);\n+\n+            defaultValue = false;\n+            rtfDefault = false;\n+        }\n+\n+        @Override\n+        public boolean set(AttrSet target) {\n+            \/* TODO: There's some ambiguity about whether this should\n+               *set* or *toggle* the attribute. *\/\n+            target.addAttribute(attribute, Boolean.TRUE);\n+\n+            return true; \/* true indicates we were successful *\/\n+        }\n+\n+        @Override\n+        public boolean set(AttrSet target, int parameter) {\n+            \/* See above note in the case that parameter==1 *\/\n+            Boolean value = Boolean.valueOf(parameter != 0);\n+            target.addAttribute(attribute, value);\n+            return true; \/* true indicates we were successful *\/\n+        }\n+\n+        @Override\n+        public boolean setDefault(AttrSet target) {\n+            if (defaultValue != rtfDefault || (target.getAttribute(attribute) != null)) {\n+                target.addAttribute(getStyleAttribute(), Boolean.valueOf(rtfDefault));\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * Defines an object attribute.\n+     *\/\n+    static class AssertiveAttribute extends RTFAttribute {\n+        private final Object value;\n+\n+        public AssertiveAttribute(int d, StyleAttribute s, String r) {\n+            super(d, s, r);\n+            value = Boolean.valueOf(true);\n+        }\n+\n+        public AssertiveAttribute(int d, StyleAttribute s, String r, Object v) {\n+            super(d, s, r);\n+            value = v;\n+        }\n+\n+        public AssertiveAttribute(int d, StyleAttribute s, String r, int v) {\n+            super(d, s, r);\n+            value = Integer.valueOf(v);\n+        }\n+\n+        @Override\n+        public boolean set(AttrSet target) {\n+            if (value == null) {\n+                target.removeAttribute(attribute);\n+            } else {\n+                target.addAttribute(attribute, value);\n+            }\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean set(AttrSet target, int parameter) {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean setDefault(AttrSet target) {\n+            target.removeAttribute(attribute);\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * Defines a numeric attribute.\n+     *\/\n+    static class NumericAttribute extends RTFAttribute {\n+        private final int rtfDefault;\n+        private final Number defaultValue;\n+        private final float scale;\n+\n+        protected NumericAttribute(int d, StyleAttribute s, String r) {\n+            super(d, s, r);\n+            rtfDefault = 0;\n+            defaultValue = null;\n+            scale = 1f;\n+        }\n+\n+        public NumericAttribute(int d, StyleAttribute s, String r, int ds, int dr) {\n+            this(d, s, r, Integer.valueOf(ds), dr, 1f);\n+        }\n+\n+        public NumericAttribute(int d, StyleAttribute s, String r, Number ds, int dr, float sc) {\n+            super(d, s, r);\n+            defaultValue = ds;\n+            rtfDefault = dr;\n+            scale = sc;\n+        }\n+\n+        @Override\n+        public boolean set(AttrSet target) {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean set(AttrSet target, int parameter) {\n+            Number v;\n+            if (scale == 1f) {\n+                v = Integer.valueOf(parameter);\n+            } else {\n+                v = Float.valueOf(parameter \/ scale);\n+            }\n+            target.addAttribute(attribute, v);\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean setDefault(AttrSet target) {\n+            Number old = (Number)target.getAttribute(attribute);\n+            if (old == null) {\n+                old = defaultValue;\n+            }\n+            if (old != null && ((scale == 1f && old.intValue() == rtfDefault)\n+                || (Math.round(old.floatValue() * scale) == rtfDefault))) {\n+                return true;\n+            }\n+            set(target, rtfDefault);\n+            return true;\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/RTFAttributes.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,346 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ adapted from package javax.swing.text.rtf;\n+package com.sun.jfx.incubator.scene.control.richtext.rtf;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+\/**\n+ * <b>RTFParser<\/b> is a subclass of <b>AbstractFilter<\/b> which understands basic RTF syntax\n+ * and passes a stream of control words, text, and begin\/end group\n+ * indications to its subclass.\n+ *\n+ * Normally programmers will only use <b>RTFReader<\/b>, a subclass of this class that knows what to\n+ * do with the tokens this class parses.\n+ *\n+ * @see AbstractFilter\n+ * @see RTFReader\n+ *\/\n+\/\/ copied from package javax.swing.text.rtf;\n+abstract class RTFParser extends AbstractFilter {\n+    \/** The current RTF group nesting level. *\/\n+    public int level;\n+    private int state;\n+    private StringBuffer currentCharacters;\n+    private String pendingKeyword; \/\/ where keywords go while we read their parameters\n+    private int pendingCharacter; \/\/ for the \\'xx construct\n+    private long binaryBytesLeft; \/\/ in a \\bin blob?\n+    ByteArrayOutputStream binaryBuf;\n+    private boolean[] savedSpecials;\n+\n+    \/\/ value for the 'state' variable\n+    private final int S_text = 0; \/\/ reading random text\n+    private final int S_backslashed = 1; \/\/ read a backslash, waiting for next\n+    private final int S_token = 2; \/\/ reading a multicharacter token\n+    private final int S_parameter = 3; \/\/ reading a token's parameter\n+    private final int S_aftertick = 4; \/\/ after reading \\'\n+    private final int S_aftertickc = 5; \/\/ after reading \\'x\n+    private final int S_inblob = 6; \/\/ in a \\bin blob\n+\n+    \/** Implemented by subclasses to interpret a parameter-less RTF keyword.\n+     *  The keyword is passed without the leading '\/' or any delimiting\n+     *  whitespace. *\/\n+    public abstract boolean handleKeyword(String keyword);\n+\n+    \/** Implemented by subclasses to interpret a keyword with a parameter.\n+     *  @param keyword   The keyword, as with <code>handleKeyword(String)<\/code>.\n+     *  @param parameter The parameter following the keyword. *\/\n+    public abstract boolean handleKeyword(String keyword, int parameter);\n+\n+    \/** Implemented by subclasses to interpret text from the RTF stream. *\/\n+    public abstract void handleText(String text);\n+\n+    public void handleText(char ch) {\n+        handleText(String.valueOf(ch));\n+    }\n+\n+    \/** Implemented by subclasses to handle the contents of the \\bin keyword. *\/\n+    public abstract void handleBinaryBlob(byte[] data);\n+\n+    \/** Implemented by subclasses to react to an increase\n+     *  in the nesting level. *\/\n+    public abstract void begingroup();\n+\n+    \/** Implemented by subclasses to react to the end of a group. *\/\n+    public abstract void endgroup();\n+\n+    \/\/ table of non-text characters in rtf\n+    static final boolean[] rtfSpecialsTable;\n+    static {\n+        rtfSpecialsTable = noSpecialsTable.clone();\n+        rtfSpecialsTable['\\n'] = true;\n+        rtfSpecialsTable['\\r'] = true;\n+        rtfSpecialsTable['{'] = true;\n+        rtfSpecialsTable['}'] = true;\n+        rtfSpecialsTable['\\\\'] = true;\n+    }\n+\n+    public RTFParser() {\n+        currentCharacters = new StringBuffer();\n+        state = S_text;\n+        pendingKeyword = null;\n+        level = 0;\n+\n+        specialsTable = rtfSpecialsTable;\n+    }\n+\n+    @Override\n+    public void writeSpecial(int b) throws IOException {\n+        write((char)b);\n+    }\n+\n+    @Override\n+    public void write(String s) throws IOException {\n+        if (state != S_text) {\n+            int index = 0;\n+            int length = s.length();\n+            while (index < length && state != S_text) {\n+                write(s.charAt(index));\n+                index++;\n+            }\n+\n+            if (index >= length) {\n+                return;\n+            }\n+\n+            s = s.substring(index);\n+        }\n+\n+        if (currentCharacters.length() > 0) {\n+            currentCharacters.append(s);\n+        } else {\n+            handleText(s);\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"fallthrough\")\n+    public void write(char ch) throws IOException {\n+        boolean ok;\n+\n+        switch (state) {\n+        case S_text:\n+            if (ch == '\\n' || ch == '\\r') {\n+                break; \/\/ unadorned newlines are ignored\n+            } else if (ch == '{') {\n+                if (currentCharacters.length() > 0) {\n+                    handleText(currentCharacters.toString());\n+                    currentCharacters = new StringBuffer();\n+                }\n+                level++;\n+                begingroup();\n+            } else if (ch == '}') {\n+                if (currentCharacters.length() > 0) {\n+                    handleText(currentCharacters.toString());\n+                    currentCharacters = new StringBuffer();\n+                }\n+                if (level == 0) {\n+                    throw new IOException(\"Too many close-groups in RTF text\");\n+                }\n+                endgroup();\n+                level--;\n+            } else if (ch == '\\\\') {\n+                if (currentCharacters.length() > 0) {\n+                    handleText(currentCharacters.toString());\n+                    currentCharacters = new StringBuffer();\n+                }\n+                state = S_backslashed;\n+            } else {\n+                currentCharacters.append(ch);\n+            }\n+            break;\n+        case S_backslashed:\n+            if (ch == '\\'') {\n+                state = S_aftertick;\n+                break;\n+            }\n+            if (!Character.isLetter(ch)) {\n+                String kw = String.valueOf(ch);\n+                if (!handleKeyword(kw)) {\n+                    \/\/warning(\"Unknown keyword: \" + kw + \" (\" + (byte)ch + \")\");\n+                }\n+                state = S_text;\n+                pendingKeyword = null;\n+                \/* currentCharacters is already an empty stringBuffer *\/\n+                break;\n+            }\n+\n+            state = S_token;\n+            \/* FALL THROUGH *\/\n+        case S_token:\n+            if (Character.isLetter(ch)) {\n+                currentCharacters.append(ch);\n+            } else {\n+                pendingKeyword = currentCharacters.toString();\n+                currentCharacters = new StringBuffer();\n+\n+                \/\/ Parameter following?\n+                if (Character.isDigit(ch) || (ch == '-')) {\n+                    state = S_parameter;\n+                    currentCharacters.append(ch);\n+                } else {\n+                    ok = handleKeyword(pendingKeyword);\n+\/\/                    if (!ok) {\n+\/\/                        warning(\"Unknown keyword: \" + pendingKeyword);\n+\/\/                    }\n+                    pendingKeyword = null;\n+                    state = S_text;\n+\n+                    \/\/ Non-space delimiters get included in the text\n+                    if (!Character.isWhitespace(ch)) {\n+                        write(ch);\n+                    }\n+                }\n+            }\n+            break;\n+        case S_parameter:\n+            if (Character.isDigit(ch)) {\n+                currentCharacters.append(ch);\n+            } else {\n+                \/* TODO: Test correct behavior of \\bin keyword *\/\n+                if (pendingKeyword.equals(\"bin\")) { \/* magic layer-breaking kwd *\/\n+                    long parameter = 0L;\n+                    try {\n+                        parameter = Long.parseLong(currentCharacters.toString());\n+                    } catch (NumberFormatException e) {\n+                        \/\/warning(\"Illegal number format \" + currentCharacters.toString() + \" in \\bin tag\");\n+                        pendingKeyword = null;\n+                        currentCharacters = new StringBuffer();\n+                        state = S_text;\n+                        \/\/ Delimiters here are interpreted as text too\n+                        if (!Character.isWhitespace(ch)) {\n+                            write(ch);\n+                        }\n+                        break;\n+                    }\n+                    pendingKeyword = null;\n+                    state = S_inblob;\n+                    int maxBytes = 4 * 1024 * 1024;\n+                    binaryBytesLeft = parameter;\n+\n+                    if (binaryBytesLeft > maxBytes) {\n+                        binaryBuf = new ByteArrayOutputStream(maxBytes);\n+                    } else if (binaryBytesLeft < 0) {\n+                        binaryBytesLeft = 0;\n+                        binaryBuf = new ByteArrayOutputStream((int)binaryBytesLeft);\n+                    } else {\n+                        binaryBuf = new ByteArrayOutputStream((int)binaryBytesLeft);\n+                    }\n+                    savedSpecials = specialsTable;\n+                    specialsTable = allSpecialsTable;\n+                    break;\n+                }\n+\n+                int parameter = 0;\n+                try {\n+                    parameter = Integer.parseInt(currentCharacters.toString());\n+                    ok = handleKeyword(pendingKeyword, parameter);\n+\/\/                    if (!ok) {\n+\/\/                        warning(\"Unknown keyword: \" + pendingKeyword + \" (param \" + currentCharacters + \")\");\n+\/\/                    }\n+                } catch (NumberFormatException e) {\n+                    \/\/warning(\"Illegal number format \" + currentCharacters.toString() + \" in \" + pendingKeyword + \" tag\");\n+                }\n+                pendingKeyword = null;\n+                currentCharacters = new StringBuffer();\n+                state = S_text;\n+\n+                \/\/ Delimiters here are interpreted as text too\n+                if (!Character.isWhitespace(ch)) {\n+                    write(ch);\n+                }\n+            }\n+            break;\n+        case S_aftertick:\n+            if (Character.digit(ch, 16) == -1) {\n+                state = S_text;\n+            } else {\n+                pendingCharacter = Character.digit(ch, 16);\n+                state = S_aftertickc;\n+            }\n+            break;\n+        case S_aftertickc:\n+            state = S_text;\n+            if (Character.digit(ch, 16) != -1) {\n+                pendingCharacter = pendingCharacter * 16 + Character.digit(ch, 16);\n+                ch = translationTable[pendingCharacter];\n+                if (ch != 0) {\n+                    handleText(ch);\n+                }\n+            }\n+            break;\n+        case S_inblob:\n+            if (binaryBytesLeft > 0) {\n+                binaryBuf.write(ch);\n+                binaryBytesLeft--;\n+            }\n+            if (binaryBytesLeft == 0) {\n+                state = S_text;\n+                specialsTable = savedSpecials;\n+                savedSpecials = null;\n+                handleBinaryBlob(binaryBuf.toByteArray());\n+                binaryBuf = null;\n+            }\n+        }\n+    }\n+\n+    \/** Flushes any buffered but not yet written characters.\n+     *  Subclasses which override this method should call this\n+     *  method <em>before<\/em> flushing\n+     *  any of their own buffers. *\/\n+    @Override\n+    public void flush() throws IOException {\n+        super.flush();\n+\n+        if (state == S_text && currentCharacters.length() > 0) {\n+            handleText(currentCharacters.toString());\n+            currentCharacters = new StringBuffer();\n+        }\n+    }\n+\n+    \/** Closes the parser. Currently, this simply does a <code>flush()<\/code>,\n+     *  followed by some minimal consistency checks. *\/\n+    @Override\n+    public void close() throws IOException {\n+        flush();\n+\n+        if (state != S_text || level > 0) {\n+            \/\/warning(\"Truncated RTF file.\");\n+\n+            \/* TODO: any sane way to handle termination in a non-S_text state? *\/\n+            \/* probably not *\/\n+\n+            \/* this will cause subclasses to behave more reasonably\n+               some of the time *\/\n+            while (level > 0) {\n+                endgroup();\n+                level--;\n+            }\n+        }\n+\n+        super.close();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/RTFParser.java","additions":346,"deletions":0,"binary":false,"changes":346,"status":"added"},{"patch":"@@ -0,0 +1,1449 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ adapted from package javax.swing.text.rtf;\n+package com.sun.jfx.incubator.scene.control.richtext.rtf;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StreamTokenizer;\n+import java.io.StringReader;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import javafx.scene.paint.Color;\n+import javafx.scene.text.TextAlignment;\n+import com.sun.jfx.incubator.scene.control.richtext.SegmentStyledInput;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledInput;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+\n+\/**\n+ * Takes a sequence of RTF tokens and text and appends the text\n+ * described by the RTF to a <code>StyledDocument<\/code> (the <em>target<\/em>).\n+ * The RTF is lexed\n+ * from the character stream by the <code>RTFParser<\/code> which is this class's\n+ * superclass.\n+ *\n+ * This class is an indirect subclass of OutputStream. It must be closed\n+ * in order to guarantee that all of the text has been sent to\n+ * the text acceptor.\n+ *\/\n+public class RTFReader extends RTFParser {\n+    \/** Indicates the domain of a Style *\/\n+    private static final Object STYLE_TYPE = new Object();\n+    \/** Value for StyleType indicating a section style *\/\n+    private static final Object STYLE_SECTION = new Object();\n+    \/** Value for StyleType indicating a paragraph style *\/\n+    private static final Object STYLE_PARAGRAPH = new Object();\n+    \/** Value for StyleType indicating a character style *\/\n+    private static final Object STYLE_CHARACTER = new Object();\n+    \/** The style of the text following this style *\/\n+    private static final Object STYLE_NEXT = new Object();\n+    \/** Whether the style is additive *\/\n+    private static final Object STYLE_ADDITIVE = new Object();\n+    \/** Whether the style is hidden from the user *\/\n+    private static final Object STYLE_HIDDEN = new Object();\n+\n+    private final String text;\n+    private ArrayList<StyledSegment> segments;\n+\n+    \/** Miscellaneous information about the parser's state. This\n+     *  dictionary is saved and restored when an RTF group begins\n+     *  or ends. *\/\n+    private HashMap<Object, Object> parserState; \/* Current parser state *\/\n+    \/** This is the \"dst\" item from parserState. rtfDestination\n+     *  is the current rtf destination. It is cached in an instance\n+     *  variable for speed. *\/\n+    private Destination rtfDestination;\n+    \/** This holds the current document attributes. *\/\n+    private AttrSet documentAttributes;\n+\n+    \/** This Dictionary maps Integer font numbers to String font names. *\/\n+    private HashMap<Integer, String> fontTable;\n+    \/** This array maps color indices to Color objects. *\/\n+    private Color[] colorTable;\n+    \/** This Map maps character style numbers to Style objects. *\/\n+    private HashMap<Integer, Style> characterStyles;\n+    \/** This Map maps paragraph style numbers to Style objects. *\/\n+    private HashMap<Integer, Style> paragraphStyles;\n+    \/** This Map maps section style numbers to Style objects. *\/\n+    private HashMap<Integer, Style> sectionStyles;\n+\n+    \/** <code>true<\/code> to indicate that if the next keyword is unknown,\n+     *  the containing group should be ignored. *\/\n+    private boolean ignoreGroupIfUnknownKeyword;\n+\n+    \/** The parameter of the most recently parsed \\\\ucN keyword,\n+     *  used for skipping alternative representations after a\n+     *  Unicode character. *\/\n+    private int skippingCharacters;\n+\n+    private final AttrSet.Holder holder = new AttrSet.Holder();\n+\n+    private static final String DEFAULT_STYLE = \"default\";\n+    private final HashMap<String,Style> styles = initStyles(); \/\/ TODO can init default style on demand\n+\n+    private static final HashMap<String, RTFAttribute> straightforwardAttributes = RTFAttributes.attributesByKeyword();\n+\n+    \/** textKeywords maps RTF keywords to single-character strings,\n+     *  for those keywords which simply insert some text. *\/\n+    private static final HashMap<String, String> textKeywords = initTextKeywords();\n+    private static final HashMap<String, char[]> characterSets = initCharacterSets();\n+\n+    \/* TODO: per-font font encodings ( \\fcharset control word ) ? *\/\n+\n+    \/**\n+     * Creates a new RTFReader instance.\n+     * @param text the RTF input string\n+     *\/\n+    public RTFReader(String text) {\n+        this.text = text;\n+        \/\/System.err.println(text); \/\/ FIX\n+\n+        parserState = new HashMap<>();\n+        fontTable = new HashMap<Integer, String>();\n+        documentAttributes = new AttrSet();\n+    }\n+\n+    \/**\n+     * Processes the RTF input and generates a StyledInput instance.\n+     * @return the StyledInput\n+     * @throws IOException when an I\/O error occurs.\n+     *\/\n+    public StyledInput generateStyledInput() throws IOException {\n+        if (segments == null) {\n+            segments = new ArrayList<>();\n+            readFromReader(new StringReader(text));\n+        }\n+        return SegmentStyledInput.of(segments);\n+    }\n+\n+    private static HashMap<String, String> initTextKeywords() {\n+        HashMap<String, String> m = new HashMap<>();\n+        m.put(\"\\\\\", \"\\\\\");\n+        m.put(\"{\", \"{\");\n+        m.put(\"}\", \"}\");\n+        m.put(\" \", \"\\u00A0\"); \/* not in the spec... *\/\n+        m.put(\"~\", \"\\u00A0\"); \/* nonbreaking space *\/\n+        m.put(\"_\", \"\\u2011\"); \/* nonbreaking hyphen *\/\n+        m.put(\"bullet\", \"\\u2022\");\n+        m.put(\"emdash\", \"\\u2014\");\n+        m.put(\"emspace\", \"\\u2003\");\n+        m.put(\"endash\", \"\\u2013\");\n+        m.put(\"enspace\", \"\\u2002\");\n+        m.put(\"ldblquote\", \"\\u201C\");\n+        m.put(\"lquote\", \"\\u2018\");\n+        m.put(\"ltrmark\", \"\\u200E\");\n+        m.put(\"rdblquote\", \"\\u201D\");\n+        m.put(\"rquote\", \"\\u2019\");\n+        m.put(\"rtlmark\", \"\\u200F\");\n+        m.put(\"tab\", \"\\u0009\");\n+        m.put(\"zwj\", \"\\u200D\");\n+        m.put(\"zwnj\", \"\\u200C\");\n+        \/\/ There is no Unicode equivalent to an optional hyphen, as far as I can tell.\n+        \/\/ TODO optional hyphen\n+        m.put(\"-\", \"\\u2027\");\n+        return m;\n+    }\n+\n+    private static HashMap<String, char[]> initCharacterSets() {\n+        HashMap<String, char[]> m = new HashMap<>();\n+        m.put(\"ansicpg\", latin1TranslationTable);\n+        return m;\n+    }\n+\n+    private HashMap<String, Style> initStyles() {\n+        HashMap<String, Style> m = new HashMap<>();\n+        m.put(DEFAULT_STYLE, new Style());\n+        return m;\n+    }\n+\n+    private Style addStyle(String nm, Style parent) {\n+        Style s = new Style();\n+        s.setResolveParent(parent);\n+        styles.put(nm, s);\n+        return s;\n+    }\n+\n+    private Style getDefaultStyle() {\n+        return styles.get(DEFAULT_STYLE);\n+    }\n+\n+    \/**\n+     * Called when the RTFParser encounters a bin keyword in the RTF stream.\n+     *\/\n+    @Override\n+    public void handleBinaryBlob(byte[] data) {\n+        if (skippingCharacters > 0) {\n+            \/\/ a blob only counts as one character for skipping purposes\n+            skippingCharacters--;\n+            return;\n+        }\n+\n+        \/\/ TODO\n+    }\n+\n+    \/**\n+     * Handles any pure text (containing no control characters) in the input\n+     * stream. Called by the superclass. *\/\n+    @Override\n+    public void handleText(String text) {\n+        if (skippingCharacters > 0) {\n+            if (skippingCharacters >= text.length()) {\n+                skippingCharacters -= text.length();\n+                return;\n+            } else {\n+                text = text.substring(skippingCharacters);\n+                skippingCharacters = 0;\n+            }\n+        }\n+\n+        if (rtfDestination != null) {\n+            rtfDestination.handleText(text);\n+            return;\n+        }\n+    }\n+\n+    \/** Called by the superclass when a new RTF group is begun.\n+     *  This implementation saves the current <code>parserState<\/code>, and gives\n+     *  the current destination a chance to save its own state.\n+     * @see RTFParser#begingroup\n+     *\/\n+    @Override\n+    public void begingroup() {\n+        if (skippingCharacters > 0) {\n+            \/* TODO this indicates an error in the RTF. Log it? *\/\n+            skippingCharacters = 0;\n+        }\n+\n+        \/* we do this little dance to avoid cloning the entire state stack and\n+           immediately throwing it away. *\/\n+        Object oldSaveState = parserState.get(\"_savedState\");\n+        if (oldSaveState != null) {\n+            parserState.remove(\"_savedState\");\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        HashMap<String, Object> saveState = (HashMap<String, Object>)parserState.clone();\n+        if (oldSaveState != null) {\n+            saveState.put(\"_savedState\", oldSaveState);\n+        }\n+        parserState.put(\"_savedState\", saveState);\n+\n+        if (rtfDestination != null) {\n+            rtfDestination.begingroup();\n+        }\n+    }\n+\n+    \/** Called by the superclass when the current RTF group is closed.\n+     *  This restores the parserState saved by <code>begingroup()<\/code>\n+     *  as well as invoking the endgroup method of the current\n+     *  destination.\n+     * @see RTFParser#endgroup\n+     *\/\n+    @Override\n+    public void endgroup() {\n+        if (skippingCharacters > 0) {\n+            \/* NB this indicates an error in the RTF. Log it? *\/\n+            skippingCharacters = 0;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        HashMap<Object, Object> restoredState = (HashMap<Object, Object>)parserState.get(\"_savedState\");\n+        Destination restoredDestination = (Destination)restoredState.get(\"dst\");\n+        if (restoredDestination != rtfDestination) {\n+            rtfDestination.close(); \/* allow the destination to clean up *\/\n+            rtfDestination = restoredDestination;\n+        }\n+        HashMap<Object, Object> oldParserState = parserState;\n+        parserState = restoredState;\n+        if (rtfDestination != null) {\n+            rtfDestination.endgroup(oldParserState);\n+        }\n+    }\n+\n+    protected void setRTFDestination(Destination newDestination) {\n+        \/* Check that setting the destination won't close the\n+           current destination (should never happen) *\/\n+        HashMap<Object, Object> previousState = (HashMap<Object,Object>)parserState.get(\"_savedState\");\n+        if (previousState != null) {\n+            if (rtfDestination != previousState.get(\"dst\")) {\n+                \/\/warning(\"Warning, RTF destination overridden, invalid RTF.\");\n+                rtfDestination.close();\n+            }\n+        }\n+        rtfDestination = newDestination;\n+        parserState.put(\"dst\", rtfDestination);\n+    }\n+\n+    \/** Called by the user when there is no more input (<i>i.e.<\/i>,\n+     * at the end of the RTF file.)\n+     *\n+     * @see OutputStream#close\n+     *\/\n+    @Override\n+    public void close() throws IOException {\n+        \/\/ FIX remove this\n+\/\/        Enumeration<Object> docProps = documentAttributes.getAttributeNames();\n+\/\/        while (docProps.hasMoreElements()) {\n+\/\/            Object propName = docProps.nextElement();\n+\/\/            \/\/target.putProperty(propName, documentAttributes.getAttribute(propName));\n+\/\/        }\n+\n+        super.close();\n+    }\n+\n+    \/**\n+     * Handles a parameterless RTF keyword. This is called by the superclass\n+     * (RTFParser) when a keyword is found in the input stream.\n+     *\n+     * @return true if the keyword is recognized and handled;\n+     *         false otherwise\n+     * @see RTFParser#handleKeyword\n+     *\/\n+    @Override\n+    public boolean handleKeyword(String keyword) {\n+        String item;\n+        boolean ignoreGroupIfUnknownKeywordSave = ignoreGroupIfUnknownKeyword;\n+\n+        if (skippingCharacters > 0) {\n+            skippingCharacters--;\n+            return true;\n+        }\n+\n+        ignoreGroupIfUnknownKeyword = false;\n+\n+        if ((item = textKeywords.get(keyword)) != null) {\n+            handleText(item);\n+            return true;\n+        }\n+\n+        if (keyword.equals(\"fonttbl\")) {\n+            setRTFDestination(new FonttblDestination());\n+            return true;\n+        }\n+\n+        if (keyword.equals(\"colortbl\")) {\n+            setRTFDestination(new ColortblDestination());\n+            return true;\n+        }\n+\n+        if (keyword.equals(\"stylesheet\")) {\n+            setRTFDestination(new StylesheetDestination());\n+            return true;\n+        }\n+\n+        if (keyword.equals(\"info\")) {\n+            setRTFDestination(new Destination());\n+            return false;\n+        }\n+\n+        if (keyword.equals(\"mac\")) {\n+            setCharacterSet(\"mac\");\n+            return true;\n+        }\n+\n+        if (keyword.equals(\"ansi\")) {\n+            setCharacterSet(\"ansi\");\n+            return true;\n+        }\n+\n+        if (keyword.equals(\"next\")) {\n+            setCharacterSet(\"NeXT\");\n+            return true;\n+        }\n+\n+        if (keyword.equals(\"pc\")) {\n+            setCharacterSet(\"cpg437\"); \/* IBM Code Page 437 *\/\n+            return true;\n+        }\n+\n+        if (keyword.equals(\"pca\")) {\n+            setCharacterSet(\"cpg850\"); \/* IBM Code Page 850 *\/\n+            return true;\n+        }\n+\n+        if (keyword.equals(\"*\")) {\n+            ignoreGroupIfUnknownKeyword = true;\n+            return true;\n+        }\n+\n+        if (rtfDestination != null) {\n+            if (rtfDestination.handleKeyword(keyword)) {\n+                return true;\n+            }\n+        }\n+\n+        \/\/ this point is reached only if the keyword is unrecognized\n+        \/\/ other destinations we don't understand and therefore ignore\n+        switch(keyword) {\n+        case \"aftncn\":\n+        case \"aftnsep\":\n+        case \"aftnsepc\":\n+        case \"annotation\":\n+        case \"atnauthor\":\n+        case \"atnicn\":\n+        case \"atnid\":\n+        case \"atnref\":\n+        case \"atntime\":\n+        case \"atrfend\":\n+        case \"atrfstart\":\n+        case \"bkmkend\":\n+        case \"bkmkstart\":\n+        case \"datafield\":\n+        case \"do\":\n+        case \"dptxbxtext\":\n+        case \"falt\":\n+        case \"field\":\n+        case \"file\":\n+        case \"filetbl\":\n+        case \"fname\":\n+        case \"fontemb\":\n+        case \"fontfile\":\n+        case \"footer\":\n+        case \"footerf\":\n+        case \"footerl\":\n+        case \"footerr\":\n+        case \"footnote\":\n+        case \"ftncn\":\n+        case \"ftnsep\":\n+        case \"ftnsepc\":\n+        case \"header\":\n+        case \"headerf\":\n+        case \"headerl\":\n+        case \"headerr\":\n+        case \"keycode\":\n+        case \"nextfile\":\n+        case \"object\":\n+        case \"pict\":\n+        case \"pn\":\n+        case \"pnseclvl\":\n+        case \"pntxtb\":\n+        case \"pntxta\":\n+        case \"revtbl\":\n+        case \"rxe\":\n+        case \"tc\":\n+        case \"template\":\n+        case \"txe\":\n+        case \"xe\":\n+            ignoreGroupIfUnknownKeywordSave = true;\n+            break;\n+        }\n+\n+        if (ignoreGroupIfUnknownKeywordSave) {\n+            setRTFDestination(new Destination());\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Handles an RTF keyword and its integer parameter.\n+     * This is called by the superclass\n+     * (RTFParser) when a keyword is found in the input stream.\n+     *\n+     * @return true if the keyword is recognized and handled;\n+     *         false otherwise\n+     * @see RTFParser#handleKeyword\n+     *\/\n+    @Override\n+    public boolean handleKeyword(String keyword, int parameter) {\n+        boolean ignoreGroupIfUnknownKeywordSave = ignoreGroupIfUnknownKeyword;\n+\n+        if (skippingCharacters > 0) {\n+            skippingCharacters--;\n+            return true;\n+        }\n+\n+        ignoreGroupIfUnknownKeyword = false;\n+\n+        if (keyword.equals(\"uc\")) {\n+            \/* count of characters to skip after a unicode character *\/\n+            parserState.put(\"UnicodeSkip\", Integer.valueOf(parameter));\n+            return true;\n+        }\n+        if (keyword.equals(\"u\")) {\n+            if (parameter < 0) {\n+                parameter = parameter + 65536;\n+            }\n+            handleText((char)parameter);\n+            Number skip = (Number)(parserState.get(\"UnicodeSkip\"));\n+            if (skip != null) {\n+                skippingCharacters = skip.intValue();\n+            } else {\n+                skippingCharacters = 1;\n+            }\n+            return true;\n+        }\n+\n+        if (keyword.equals(\"rtf\")) {\n+            \/\/rtfversion = parameter;\n+            setRTFDestination(new DocumentDestination());\n+            return true;\n+        }\n+\n+        if (keyword.startsWith(\"NeXT\") || keyword.equals(\"private\")) {\n+            ignoreGroupIfUnknownKeywordSave = true;\n+        }\n+\n+        if (keyword.contains(\"ansicpg\")) {\n+            setCharacterSet(\"ansicpg\");\n+            return true;\n+        }\n+\n+        if (rtfDestination != null) {\n+            if (rtfDestination.handleKeyword(keyword, parameter)) {\n+                return true;\n+            }\n+        }\n+\n+        \/\/ this point is reached only if the keyword is unrecognized\n+        if (ignoreGroupIfUnknownKeywordSave) {\n+            setRTFDestination(new Destination());\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * setCharacterSet sets the current translation table to correspond with\n+     * the named character set. The character set is loaded if necessary.\n+     *\n+     * @see AbstractFilter\n+     *\/\n+    public void setCharacterSet(String name) {\n+        Object set;\n+\n+        try {\n+            set = getCharacterSet(name);\n+        } catch (Exception e) {\n+            \/\/warning(\"Exception loading RTF character set \\\"\" + name + \"\\\": \" + e);\n+            set = null;\n+        }\n+\n+        if (set != null) {\n+            translationTable = (char[])set;\n+        } else {\n+            \/\/warning(\"Unknown RTF character set \\\"\" + name + \"\\\"\");\n+            if (!name.equals(\"ansi\")) {\n+                try {\n+                    translationTable = (char[])getCharacterSet(\"ansi\");\n+                } catch (IOException e) {\n+                    throw new InternalError(\"RTFReader: Unable to find character set resources (\" + e + \")\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Adds a character set to the RTFReader's list\n+     *  of known character sets *\/\n+    private static void defineCharacterSet(String name, char[] table) {\n+        if (table.length < 256) {\n+            throw new IllegalArgumentException(\"Translation table must have 256 entries.\");\n+        }\n+        characterSets.put(name, table);\n+    }\n+\n+    \/** Looks up a named character set. A character set is a 256-entry\n+     *  array of characters, mapping unsigned byte values to their Unicode\n+     *  equivalents. The character set is loaded if necessary.\n+     *\n+     *  @return the character set\n+     *\/\n+    public static Object getCharacterSet(final String name) throws IOException {\n+        char[] set = characterSets.get(name);\n+        if (set == null) {\n+            try (InputStream in = RTFReader.class.getResourceAsStream(\"charsets\/\" + name + \".txt\")) {\n+                set = readCharset(in);\n+                defineCharacterSet(name, set);\n+            }\n+        }\n+        return set;\n+    }\n+\n+    \/** Parses a character set from an InputStream. The character set\n+     * must contain 256 decimal integers, separated by whitespace, with\n+     * no punctuation. B- and C- style comments are allowed.\n+     *\n+     * @return the newly read character set\n+     *\/\n+    static char[] readCharset(InputStream strm) throws IOException {\n+        char[] values = new char[256];\n+\n+        try (BufferedReader rd = new BufferedReader(new InputStreamReader(strm, StandardCharsets.ISO_8859_1))) {\n+            StreamTokenizer in = new StreamTokenizer(rd);\n+            in.eolIsSignificant(false);\n+            in.commentChar('#');\n+            in.slashSlashComments(true);\n+            in.slashStarComments(true);\n+\n+            int i = 0;\n+            while (i < 256) {\n+                int ttype;\n+                try {\n+                    ttype = in.nextToken();\n+                } catch (Exception e) {\n+                    throw new IOException(\"Unable to read from character set file (\" + e + \")\");\n+                }\n+                if (ttype != StreamTokenizer.TT_NUMBER) {\n+                    \/\/          System.out.println(\"Bad token: type=\" + ttype + \" tok=\" + in.sval);\n+                    throw new IOException(\"Unexpected token in character set file\");\n+                    \/\/          continue;\n+                }\n+                values[i] = (char)(in.nval);\n+                i++;\n+            }\n+        }\n+\n+        return values;\n+    }\n+\n+    \/**\n+     * The base class for an RTF destination.\n+     * The RTF reader always has a current destination\n+     * which is where text is sent.  This class provides a discarding destination:\n+     * it accepts all keywords and text but does nothing with them.\n+     *\/\n+    static class Destination {\n+        public void handleBinaryBlob(byte[] data) {\n+        }\n+\n+        public void handleText(String text) {\n+        }\n+\n+        public boolean handleKeyword(String text) {\n+            \/* Accept and discard keywords. *\/\n+            return true;\n+        }\n+\n+        public boolean handleKeyword(String text, int parameter) {\n+            \/* Accept and discard parameterized keywords. *\/\n+            return true;\n+        }\n+\n+        public void begingroup() {\n+        }\n+\n+        public void endgroup(Map<Object, Object> oldState) {\n+        }\n+\n+        public void close() {\n+        }\n+    }\n+\n+    \/**\n+     * Reads the fonttbl group, inserting fonts into the RTFReader's fontTable map.\n+     *\/\n+    class FonttblDestination extends Destination {\n+        private int nextFontNumber;\n+        private Integer fontNumberKey;\n+        private String nextFontFamily;\n+\n+        @Override\n+        public void handleText(String text) {\n+            int semicolon = text.indexOf(';');\n+            String fontName;\n+\n+            if (semicolon > -1) {\n+                fontName = text.substring(0, semicolon);\n+            } else {\n+                fontName = text;\n+            }\n+\n+            if (nextFontNumber == -1 && fontNumberKey != null) {\n+                \/\/font name might be broken across multiple calls\n+                fontName = fontTable.get(fontNumberKey) + fontName;\n+            } else {\n+                fontNumberKey = Integer.valueOf(nextFontNumber);\n+            }\n+            fontTable.put(fontNumberKey, fontName);\n+\n+            nextFontNumber = -1;\n+            nextFontFamily = null;\n+        }\n+\n+        @Override\n+        public boolean handleKeyword(String keyword) {\n+            if (keyword.charAt(0) == 'f') {\n+                nextFontFamily = keyword.substring(1);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean handleKeyword(String keyword, int parameter) {\n+            if (keyword.equals(\"f\")) {\n+                nextFontNumber = parameter;\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Reads the colortbl group. Upon end-of-group, the RTFReader's\n+     * color table is set to an array containing the read colors.\n+     *\/\n+    class ColortblDestination extends Destination {\n+        private int red;\n+        private int green;\n+        private int blue;\n+        private final ArrayList<Color> colors = new ArrayList<>();\n+\n+        public ColortblDestination() {\n+        }\n+\n+        @Override\n+        public void handleText(String text) {\n+            for (int index = 0; index < text.length(); index++) {\n+                if (text.charAt(index) == ';') {\n+                    Color newColor;\n+                    newColor = Color.rgb(red, green, blue);\n+                    colors.add(newColor);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void close() {\n+            int sz = colors.size();\n+            colorTable = colors.toArray(new Color[sz]);\n+        }\n+\n+        @Override\n+        public boolean handleKeyword(String keyword, int parameter) {\n+            switch (keyword) {\n+            case \"red\":\n+                red = parameter;\n+                return true;\n+            case \"green\":\n+                green = parameter;\n+                return true;\n+            case \"blue\":\n+                blue = parameter;\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean handleKeyword(String keyword) {\n+            \/\/ Colortbls don't understand any parameterless keywords\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Handles the stylesheet keyword. Styles are read and sorted\n+     * into the three style arrays in the RTFReader.\n+     *\/\n+    class StylesheetDestination extends Destination {\n+        private HashMap<Integer, StyleDefiningDestination> definedStyles = new HashMap<>();\n+\n+        public StylesheetDestination() {\n+        }\n+\n+        @Override\n+        public void begingroup() {\n+            setRTFDestination(new StyleDefiningDestination());\n+        }\n+\n+        @Override\n+        public void close() {\n+            HashMap<Integer, Style> chrStyles = new HashMap<>();\n+            HashMap<Integer, Style> pgfStyles = new HashMap<>();\n+            HashMap<Integer, Style> secStyles = new HashMap<>();\n+            for (StyleDefiningDestination style : definedStyles.values()) {\n+                Style defined = style.realize();\n+                String stype = (String)defined.getAttribute(STYLE_TYPE);\n+                Map<Integer, Style> toMap;\n+                if (stype.equals(STYLE_SECTION)) {\n+                    toMap = secStyles;\n+                } else if (stype.equals(STYLE_CHARACTER)) {\n+                    toMap = chrStyles;\n+                } else {\n+                    toMap = pgfStyles;\n+                }\n+                toMap.put(style.number, defined);\n+            }\n+            if (!(chrStyles.isEmpty())) {\n+                characterStyles = chrStyles;\n+            }\n+            if (!(pgfStyles.isEmpty())) {\n+                paragraphStyles = pgfStyles;\n+            }\n+            if (!(secStyles.isEmpty())) {\n+                sectionStyles = secStyles;\n+            }\n+        }\n+\n+        \/** This subclass handles an individual style *\/\n+        class StyleDefiningDestination extends AttributeTrackingDestination {\n+            private static final int STYLENUMBER_NONE = 222;\n+            private boolean additive;\n+            private boolean characterStyle;\n+            private boolean sectionStyle;\n+            public String styleName;\n+            public int number;\n+            private int basedOn = STYLENUMBER_NONE;\n+            private int nextStyle = STYLENUMBER_NONE;\n+            private boolean hidden;\n+            private Style realizedStyle;\n+\n+            @Override\n+            public void handleText(String text) {\n+                if (styleName != null) {\n+                    styleName = styleName + text;\n+                } else {\n+                    styleName = text;\n+                }\n+            }\n+\n+            @Override\n+            public void close() {\n+                int semicolon = (styleName == null) ? 0 : styleName.indexOf(';');\n+                if (semicolon > 0) {\n+                    styleName = styleName.substring(0, semicolon);\n+                }\n+                definedStyles.put(Integer.valueOf(number), this);\n+                super.close();\n+            }\n+\n+            @Override\n+            public boolean handleKeyword(String keyword) {\n+                switch (keyword) {\n+                case \"additive\":\n+                    additive = true;\n+                    return true;\n+                case \"shidden\":\n+                    hidden = true;\n+                    return true;\n+                }\n+                return super.handleKeyword(keyword);\n+            }\n+\n+            @Override\n+            public boolean handleKeyword(String keyword, int parameter) {\n+                \/\/ As per http:\/\/www.biblioscape.com\/rtf15_spec.htm#Heading2\n+                \/\/ we are restricting control word delimiter numeric value\n+                \/\/ to be within -32767 through 32767\n+                if (parameter > 32767) {\n+                    parameter = 32767;\n+                } else if (parameter < -32767) {\n+                    parameter = -32767;\n+                }\n+\n+                switch (keyword) {\n+                case \"s\":\n+                    characterStyle = false;\n+                    sectionStyle = false;\n+                    number = parameter;\n+                    return true;\n+                case \"cs\":\n+                    characterStyle = true;\n+                    sectionStyle = false;\n+                    number = parameter;\n+                    return true;\n+                case \"ds\":\n+                    characterStyle = false;\n+                    sectionStyle = true;\n+                    number = parameter;\n+                    return true;\n+                case \"sbasedon\":\n+                    basedOn = parameter;\n+                    return true;\n+                case \"snext\":\n+                    nextStyle = parameter;\n+                    return true;\n+                }\n+\n+                return super.handleKeyword(keyword, parameter);\n+            }\n+\n+            public Style realize() {\n+                return realize(null);\n+            }\n+\n+            private Style realize(Set<Integer> alreadyMetBasisIndexSet) {\n+                Style basis = null;\n+                Style next = null;\n+\n+                if (alreadyMetBasisIndexSet == null) {\n+                    alreadyMetBasisIndexSet = new HashSet<>();\n+                }\n+\n+                if (realizedStyle != null) {\n+                    return realizedStyle;\n+                }\n+\n+                if (basedOn != STYLENUMBER_NONE && alreadyMetBasisIndexSet.add(basedOn)) {\n+                    StyleDefiningDestination styleDest;\n+                    styleDest = definedStyles.get(basedOn);\n+                    if (styleDest != null && styleDest != this) {\n+                        basis = styleDest.realize(alreadyMetBasisIndexSet);\n+                    }\n+                }\n+\n+                \/* NB: Swing StyleContext doesn't allow distinct styles with\n+                   the same name; RTF apparently does. This may confuse the\n+                   user. *\/\n+                realizedStyle = addStyle(styleName, basis);\n+\n+                if (characterStyle) {\n+                    realizedStyle.addAttributes(currentTextAttributes());\n+                    realizedStyle.addAttribute(STYLE_TYPE, STYLE_CHARACTER);\n+                } else if (sectionStyle) {\n+                    realizedStyle.addAttributes(currentSectionAttributes());\n+                    realizedStyle.addAttribute(STYLE_TYPE, STYLE_SECTION);\n+                } else { \/* must be a paragraph style *\/\n+                    realizedStyle.addAttributes(currentParagraphAttributes());\n+                    realizedStyle.addAttribute(STYLE_TYPE, STYLE_PARAGRAPH);\n+                }\n+\n+                if (nextStyle != STYLENUMBER_NONE) {\n+                    StyleDefiningDestination styleDest;\n+                    styleDest = definedStyles.get(Integer.valueOf(nextStyle));\n+                    if (styleDest != null) {\n+                        next = styleDest.realize();\n+                    }\n+                }\n+\n+                if (next != null) {\n+                    realizedStyle.addAttribute(STYLE_NEXT, next);\n+                }\n+                realizedStyle.addAttribute(STYLE_ADDITIVE, Boolean.valueOf(additive));\n+                realizedStyle.addAttribute(STYLE_HIDDEN, Boolean.valueOf(hidden));\n+\n+                return realizedStyle;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * An abstract RTF destination which simply tracks the attributes specified by the RTF control words\n+     * in internal form and can produce acceptable attribute sets for the\n+     * current character, paragraph, and section attributes.\n+     * It is up to the subclasses to determine what is done with the actual text.\n+     *\/\n+    abstract class AttributeTrackingDestination extends Destination {\n+        @Override\n+        public abstract void handleText(String text);\n+\n+        \/** This is the \"chr\" element of parserState, cached for more efficient use *\/\n+        private AttrSet characterAttributes;\n+        \/** This is the \"pgf\" element of parserState, cached for more efficient use *\/\n+        private AttrSet paragraphAttributes;\n+        \/** This is the \"sec\" element of parserState, cached for more efficient use *\/\n+        private AttrSet sectionAttributes;\n+\n+        public AttributeTrackingDestination() {\n+            characterAttributes = rootCharacterAttributes();\n+            parserState.put(\"chr\", characterAttributes);\n+            paragraphAttributes = rootParagraphAttributes();\n+            parserState.put(\"pgf\", paragraphAttributes);\n+            sectionAttributes = rootSectionAttributes();\n+            parserState.put(\"sec\", sectionAttributes);\n+        }\n+\n+        @Override\n+        public void begingroup() {\n+            AttrSet characterParent = currentTextAttributes();\n+            AttrSet paragraphParent = currentParagraphAttributes();\n+            AttrSet sectionParent = currentSectionAttributes();\n+\n+            \/* update the cached attribute dictionaries *\/\n+            characterAttributes = new AttrSet();\n+            characterAttributes.addAttributes(characterParent);\n+            parserState.put(\"chr\", characterAttributes);\n+\n+            paragraphAttributes = new AttrSet();\n+            paragraphAttributes.addAttributes(paragraphParent);\n+            parserState.put(\"pgf\", paragraphAttributes);\n+\n+            sectionAttributes = new AttrSet();\n+            sectionAttributes.addAttributes(sectionParent);\n+            parserState.put(\"sec\", sectionAttributes);\n+        }\n+\n+        @Override\n+        public void endgroup(Map<Object, Object> oldState) {\n+            characterAttributes = (AttrSet)parserState.get(\"chr\");\n+            paragraphAttributes = (AttrSet)parserState.get(\"pgf\");\n+            sectionAttributes = (AttrSet)parserState.get(\"sec\");\n+        }\n+\n+        @Override\n+        public boolean handleKeyword(String keyword) {\n+            if (keyword.equals(\"ulnone\")) {\n+                return handleKeyword(\"ul\", 0);\n+            }\n+\n+            {\n+                RTFAttribute attr = straightforwardAttributes.get(keyword);\n+                if (attr != null) {\n+                    boolean ok;\n+\n+                    switch (attr.domain()) {\n+                    case RTFAttribute.D_CHARACTER:\n+                        ok = attr.set(characterAttributes);\n+                        break;\n+                    case RTFAttribute.D_PARAGRAPH:\n+                        ok = attr.set(paragraphAttributes);\n+                        break;\n+                    case RTFAttribute.D_SECTION:\n+                        ok = attr.set(sectionAttributes);\n+                        break;\n+                    case RTFAttribute.D_META:\n+                        holder.backing = parserState;\n+                        ok = attr.set(holder);\n+                        holder.backing = null;\n+                        break;\n+                    case RTFAttribute.D_DOCUMENT:\n+                        ok = attr.set(documentAttributes);\n+                        break;\n+                    default:\n+                        \/\/ should never happen\n+                        ok = false;\n+                        break;\n+                    }\n+                    if (ok) {\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            switch (keyword) {\n+            case \"plain\":\n+                resetCharacterAttributes();\n+                return true;\n+            case \"pard\":\n+                resetParagraphAttributes();\n+                return true;\n+            case \"sectd\":\n+                resetSectionAttributes();\n+                return true;\n+            }\n+\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean handleKeyword(String keyword, int parameter) {\n+            if (keyword.equals(\"fc\")) {\n+                keyword = \"cf\";\n+            }\n+\n+            switch (keyword) {\n+            case \"f\":\n+                parserState.put(keyword, Integer.valueOf(parameter));\n+                return true;\n+            case \"cf\":\n+                parserState.put(keyword, Integer.valueOf(parameter));\n+                return true;\n+            case \"cb\":\n+                parserState.put(keyword, Integer.valueOf(parameter));\n+                return true;\n+            }\n+\n+            {\n+                RTFAttribute attr = straightforwardAttributes.get(keyword);\n+                if (attr != null) {\n+                    boolean ok;\n+\n+                    switch (attr.domain()) {\n+                    case RTFAttribute.D_CHARACTER:\n+                        ok = attr.set(characterAttributes, parameter);\n+                        break;\n+                    case RTFAttribute.D_PARAGRAPH:\n+                        ok = attr.set(paragraphAttributes, parameter);\n+                        break;\n+                    case RTFAttribute.D_SECTION:\n+                        ok = attr.set(sectionAttributes, parameter);\n+                        break;\n+                    case RTFAttribute.D_META:\n+                        holder.backing = parserState;\n+                        ok = attr.set(holder, parameter);\n+                        holder.backing = null;\n+                        break;\n+                    case RTFAttribute.D_DOCUMENT:\n+                        ok = attr.set(documentAttributes, parameter);\n+                        break;\n+                    default:\n+                        \/\/ should never happen\n+                        ok = false;\n+                        break;\n+                    }\n+                    if (ok) {\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            \/* TODO: superscript\/subscript *\/\n+\n+            \/\/ TODO\n+\/\/            if (keyword.equals(\"sl\")) {\n+\/\/                if (parameter == 1000) { \/* magic value! *\/\n+\/\/                    characterAttributes.removeAttribute(StyleConstants.LineSpacing);\n+\/\/                } else {\n+\/\/                    \/* TODO: The RTF sl attribute has special meaning if it's\n+\/\/                       negative. Make sure that SwingText has the same special\n+\/\/                       meaning, or find a way to imitate that. When SwingText\n+\/\/                       handles this, also recognize the slmult keyword. *\/\n+\/\/                    StyleConstants.setLineSpacing(characterAttributes, parameter \/ 20f);\n+\/\/                }\n+\/\/                return true;\n+\/\/            }\n+\n+            \/* TODO: Other kinds of underlining *\/\n+\n+\/\/            if (keyword.equals(\"tx\") || keyword.equals(\"tb\")) {\n+\/\/                float tabPosition = parameter \/ 20f;\n+\/\/                int tabAlignment, tabLeader;\n+\/\/                Number item;\n+\/\/\n+\/\/                tabAlignment = TabStop.ALIGN_LEFT;\n+\/\/                item = (Number)(parserState.get(\"tab_alignment\"));\n+\/\/                if (item != null)\n+\/\/                    tabAlignment = item.intValue();\n+\/\/                tabLeader = TabStop.LEAD_NONE;\n+\/\/                item = (Number)(parserState.get(\"tab_leader\"));\n+\/\/                if (item != null)\n+\/\/                    tabLeader = item.intValue();\n+\/\/                if (keyword.equals(\"tb\"))\n+\/\/                    tabAlignment = TabStop.ALIGN_BAR;\n+\/\/\n+\/\/                parserState.remove(\"tab_alignment\");\n+\/\/                parserState.remove(\"tab_leader\");\n+\/\/\n+\/\/                TabStop newStop = new TabStop(tabPosition, tabAlignment, tabLeader);\n+\/\/                Dictionary<Object, Object> tabs;\n+\/\/                Integer stopCount;\n+\/\/\n+\/\/                @SuppressWarnings(\"unchecked\")\n+\/\/                Dictionary<Object, Object> tmp = (Dictionary)parserState.get(\"_tabs\");\n+\/\/                tabs = tmp;\n+\/\/                if (tabs == null) {\n+\/\/                    tabs = new Hashtable<Object, Object>();\n+\/\/                    parserState.put(\"_tabs\", tabs);\n+\/\/                    stopCount = Integer.valueOf(1);\n+\/\/                } else {\n+\/\/                    stopCount = (Integer)tabs.get(\"stop count\");\n+\/\/                    stopCount = Integer.valueOf(1 + stopCount.intValue());\n+\/\/                }\n+\/\/                tabs.put(stopCount, newStop);\n+\/\/                tabs.put(\"stop count\", stopCount);\n+\/\/                parserState.remove(\"_tabs_immutable\");\n+\/\/\n+\/\/                return true;\n+\/\/            }\n+\n+            switch (keyword) {\n+            case \"fs\":\n+                characterAttributes.addAttribute(StyleAttributeMap.FONT_SIZE, (parameter \/ 2));\n+                return true;\n+            }\n+\n+            if (keyword.equals(\"s\") && paragraphStyles != null) {\n+                parserState.put(\"paragraphStyle\", paragraphStyles.get(parameter));\n+                return true;\n+            }\n+\n+            if (keyword.equals(\"cs\") && characterStyles != null) {\n+                parserState.put(\"characterStyle\", characterStyles.get(parameter));\n+                return true;\n+            }\n+\n+            if (keyword.equals(\"ds\") && sectionStyles != null) {\n+                parserState.put(\"sectionStyle\", sectionStyles.get(parameter));\n+                return true;\n+            }\n+\n+            return false;\n+        }\n+\n+        \/** Returns a new AttrSet containing the\n+         *  default character attributes *\/\n+        protected AttrSet rootCharacterAttributes() {\n+            AttrSet a = new AttrSet();\n+            \/* TODO: default font *\/\n+            a.setItalic(false);\n+            a.setBold(false);\n+            a.setUnderline(false);\n+            a.setForeground(Color.BLACK);\n+            return a;\n+        }\n+\n+        \/** Returns a new AttrSet containing the\n+         *  default paragraph attributes *\/\n+        protected AttrSet rootParagraphAttributes() {\n+            AttrSet a = new AttrSet();\n+            a.setLeftIndent(0.0);\n+            a.setRightIndent(0.0);\n+            a.setFirstLineIndent(0.0);\n+            a.setResolveParent(getDefaultStyle());\n+            return a;\n+        }\n+\n+        \/** Returns a new AttrSet containing the\n+         *  default section attributes *\/\n+        protected AttrSet rootSectionAttributes() {\n+            AttrSet a = new AttrSet();\n+            return a;\n+        }\n+\n+        \/**\n+         * Calculates the current text (character) attributes in a form suitable\n+         * for SwingText from the current parser state.\n+         *\n+         * @return a new AttrSet containing the text attributes.\n+         *\/\n+        AttrSet currentTextAttributes() {\n+            AttrSet attributes = new AttrSet(characterAttributes);\n+\n+            \/* figure out the font name *\/\n+            \/* TODO: catch exceptions for undefined attributes,\n+               bad font indices, etc.? (as it stands, it is the caller's\n+               job to clean up after corrupt RTF) *\/\n+            Integer fontnum = (Integer)parserState.get(\"f\");\n+            \/* note setFontFamily() can not handle a null font *\/\n+            String fontFamily;\n+            if (fontnum != null) {\n+                fontFamily = fontTable.get(fontnum);\n+            } else {\n+                fontFamily = null;\n+            }\n+            attributes.setFontFamily(fontFamily);\n+\n+            if (colorTable != null) {\n+                Integer stateItem = (Integer)parserState.get(\"cf\");\n+                if (stateItem != null) {\n+                    Color fg = colorTable[stateItem.intValue()];\n+                    attributes.setForeground(fg);\n+                } else {\n+                    attributes.setForeground(null);\n+                }\n+            }\n+\n+            if (colorTable != null) {\n+                Integer stateItem = (Integer)parserState.get(\"cb\");\n+                if (stateItem != null) {\n+                    Color bg = colorTable[stateItem.intValue()];\n+                    attributes.setBackground(bg);\n+                } else {\n+                    attributes.setBackground(null);\n+                }\n+            }\n+\n+            Style characterStyle = (Style)parserState.get(\"characterStyle\");\n+            if (characterStyle != null) {\n+                attributes.setResolveParent(characterStyle);\n+            }\n+\n+            \/* Other attributes are maintained directly in \"attributes\" *\/\n+\n+            return attributes;\n+        }\n+\n+        \/**\n+         * Calculates the current paragraph attributes (with keys\n+         * as given in StyleConstants) from the current parser state.\n+         *\n+         * @return a newly created AttrSet.\n+         *\/\n+        AttrSet currentParagraphAttributes() {\n+            \/* NB if there were a mutableCopy() method we should use it *\/\n+            AttrSet a = new AttrSet(paragraphAttributes);\n+\n+            \/*** Tab stops ***\/\n+\/\/            TabStop[] tabs = (TabStop[])parserState.get(\"_tabs_immutable\");\n+\/\/            if (tabs == null) {\n+\/\/                @SuppressWarnings(\"unchecked\")\n+\/\/                Dictionary<Object, Object> workingTabs = (Dictionary)parserState.get(\"_tabs\");\n+\/\/                if (workingTabs != null) {\n+\/\/                    int count = ((Integer)workingTabs.get(\"stop count\")).intValue();\n+\/\/                    tabs = new TabStop[count];\n+\/\/                    for (int ix = 1; ix <= count; ix++)\n+\/\/                        tabs[ix - 1] = (TabStop)workingTabs.get(Integer.valueOf(ix));\n+\/\/                    parserState.put(\"_tabs_immutable\", tabs);\n+\/\/                }\n+\/\/            }\n+\/\/            if (tabs != null) {\n+\/\/                a.addAttribute(Constants.Tabs, tabs);\n+\/\/            }\n+\n+            Style paragraphStyle = (Style)parserState.get(\"paragraphStyle\");\n+            if (paragraphStyle != null) {\n+                a.setResolveParent(paragraphStyle);\n+            }\n+\n+            return a;\n+        }\n+\n+        \/**\n+         * Calculates the current section attributes\n+         * from the current parser state.\n+         *\n+         * @return a newly created AttrSet.\n+         *\/\n+        public AttrSet currentSectionAttributes() {\n+            AttrSet attributes = new AttrSet(sectionAttributes);\n+\n+            Style sectionStyle = (Style)parserState.get(\"sectionStyle\");\n+            if (sectionStyle != null) {\n+                attributes.setResolveParent(sectionStyle);\n+            }\n+\n+            return attributes;\n+        }\n+\n+        \/** Resets the filter's internal notion of the current character\n+         *  attributes to their default values. Invoked to handle the\n+         *  \\plain keyword. *\/\n+        protected void resetCharacterAttributes() {\n+            handleKeyword(\"f\", 0);\n+            handleKeyword(\"cf\", 0);\n+            handleKeyword(\"fs\", 24); \/* 12 pt. *\/\n+\n+            for (RTFAttribute attr : straightforwardAttributes.values()) {\n+                if (attr.domain() == RTFAttribute.D_CHARACTER) {\n+                    attr.setDefault(characterAttributes);\n+                }\n+            }\n+\n+            handleKeyword(\"sl\", 1000);\n+\n+            parserState.remove(\"characterStyle\");\n+        }\n+\n+        \/** Resets the filter's internal notion of the current paragraph's\n+         *  attributes to their default values. Invoked to handle the\n+         *  \\pard keyword. *\/\n+        protected void resetParagraphAttributes() {\n+            parserState.remove(\"_tabs\");\n+            parserState.remove(\"_tabs_immutable\");\n+            parserState.remove(\"paragraphStyle\");\n+\n+            paragraphAttributes.setAlignment(TextAlignment.LEFT);\n+\n+            for (RTFAttribute attr : straightforwardAttributes.values()) {\n+                if (attr.domain() == RTFAttribute.D_PARAGRAPH) {\n+                    attr.setDefault(characterAttributes);\n+                }\n+            }\n+        }\n+\n+        \/** Resets the filter's internal notion of the current section's\n+         *  attributes to their default values. Invoked to handle the\n+         *  \\sectd keyword. *\/\n+        protected void resetSectionAttributes() {\n+            for (RTFAttribute attr : straightforwardAttributes.values()) {\n+                if (attr.domain() == RTFAttribute.D_SECTION) {\n+                    attr.setDefault(characterAttributes);\n+                }\n+            }\n+\n+            parserState.remove(\"sectionStyle\");\n+        }\n+    }\n+\n+    \/**\n+     * This Destination accumulates the styled segments within this reader.\n+     *\/\n+    class DocumentDestination extends AttributeTrackingDestination {\n+        \/** <code>true<\/code> if the reader has not just finished a paragraph; false upon startup *\/\n+        private boolean inParagraph;\n+\n+        public DocumentDestination() {\n+        }\n+\n+        public void deliverText(String text, AttrSet characterAttributes) {\n+            StyleAttributeMap a = characterAttributes.getStyleAttributeMap();\n+            StyledSegment seg = StyledSegment.of(text, a);\n+            segments.add(seg);\n+        }\n+\n+        public void finishParagraph(AttrSet pgfAttributes, AttrSet chrAttributes) {\n+            \/\/ characterAttributes are ignored here\n+            \/\/ TODO we could supply paragraph attributes either\n+            \/\/ with a special StyledSegment (before the paragraph starts), or\n+            \/\/ as a part of insertLineBreak.  but for now, let's ignore them all\n+            \/\/ TODO pgfAttributes\n+            segments.add(StyledSegment.LINE_BREAK);\n+        }\n+\n+        protected void endSection() {\n+            \/\/ no-op\n+        }\n+\n+        @Override\n+        public void handleText(String text) {\n+            if (!inParagraph) {\n+                beginParagraph();\n+            }\n+            deliverText(text, currentTextAttributes());\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (inParagraph) {\n+                endParagraph();\n+            }\n+            super.close();\n+        }\n+\n+        @Override\n+        public boolean handleKeyword(String keyword) {\n+            switch (keyword) {\n+            case \"\\r\":\n+            case \"\\n\":\n+            case \"par\":\n+                endParagraph();\n+                return true;\n+            case \"sect\":\n+                endSection();\n+                return true;\n+            }\n+\n+            return super.handleKeyword(keyword);\n+        }\n+\n+        protected void beginParagraph() {\n+            inParagraph = true;\n+        }\n+\n+        protected void endParagraph() {\n+            AttrSet pgfAttributes = currentParagraphAttributes();\n+            AttrSet chrAttributes = currentTextAttributes();\n+            finishParagraph(pgfAttributes, chrAttributes);\n+            inParagraph = false;\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/RTFReader.java","additions":1449,"deletions":0,"binary":false,"changes":1449,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext.rtf;\n+\n+\/**\n+ * Replacement for javax.swing.text.Style.\n+ *\/\n+class Style extends AttrSet {\n+    \/** Default constructor. *\/\n+    public Style() {\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/Style.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/* the character set used for the \\ansi control word in NeXT-rtf mode *\/\n+0\t1\t2\t3\t4\t5\t6\t7\n+8\t9\t0\t11\t12\t0\t14\t15\n+16\t17\t18\t19\t20\t21\t22\t23\n+24\t25\t26\t27\t28\t29\t30\t31\n+32\t33\t34\t35\t36\t37\t38\t39\n+40\t41\t42\t43\t44\t45\t46\t47\n+48\t49\t50\t51\t52\t53\t54\t55\n+56\t57\t58\t59\t60\t61\t62\t63\n+64\t65\t66\t67\t68\t69\t70\t71\n+72\t73\t74\t75\t76\t77\t78\t79\n+80\t81\t82\t83\t84\t85\t86\t87\n+88\t89\t90\t91\t0\t93\t94\t95\n+96\t97\t98\t99\t100\t101\t102\t103\n+104\t105\t106\t107\t108\t109\t110\t111\n+112\t113\t114\t115\t116\t117\t118\t119\n+120\t121\t122\t0\t124\t0\t126\t127\n+160\t192\t193\t194\t195\t196\t197\t199\n+200\t201\t202\t203\t204\t205\t206\t207\n+208\t209\t210\t211\t212\t213\t214\t217\n+218\t219\t220\t221\t222\t181\t215\t247\n+169\t161\t162\t163\t8260\t165\t402\t167\n+164\t8217\t8220\t171\t8249\t8250\t64257\t64258\n+174\t8211\t8224\t8225\t183\t166\t182\t8226\n+8218\t8222\t8221\t187\t8230\t8240\t172\t191\n+185\t715\t180\t710\t732\t175\t728\t729\n+168\t178\t730\t184\t179\t733\t731\t711\n+8212\t177\t188\t189\t190\t224\t225\t226\n+227\t228\t229\t231\t232\t233\t234\t235\n+236\t198\t237\t170\t238\t239\t240\t241\n+321\t216\t338\t186\t242\t243\t244\t245\n+246\t230\t249\t250\t251\t305\t252\t253\n+322\t248\t339\t223\t254\t255\t0\t0\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/charsets\/NeXT.txt","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+# The character set used to read documents with the \\ansi control\n+# word. The default \"ansi\" character set doesn't seem to be defined\n+# anywhere; this table is derived from the behavior of MSWord97\n+# and some guesswork. For the most part it corresponds to\n+# ISO 8859 Latin-1.\n+0\t1\t2\t3\t4\t5\t6\t7\t\n+8\t9\t10\t11\t12\t13\t14\t15\t\n+16\t17\t18\t19\t20\t21\t22\t23\t\n+24\t25\t26\t27\t28\t29\t30\t31\t\n+32\t33\t34\t35\t36\t37\t38\t39\t\n+40\t41\t42\t43\t44\t45\t46\t47\t\n+48\t49\t50\t51\t52\t53\t54\t55\t\n+56\t57\t58\t59\t60\t61\t62\t63\t\n+64\t65\t66\t67\t68\t69\t70\t71\t\n+72\t73\t74\t75\t76\t77\t78\t79\t\n+80\t81\t82\t83\t84\t85\t86\t87\t\n+88\t89\t90\t91\t92\t93\t94\t95\t\n+96\t97\t98\t99\t100\t101\t102\t103\t\n+104\t105\t106\t107\t108\t109\t110\t111\t\n+112\t113\t114\t115\t116\t117\t118\t119\t\n+120\t121\t122\t123\t124\t125\t126\t127\t\n+\n+1026\t1027\t8218\t402\t8222\t8230\t8224\t8225\n+710\t8240\t352\t8249\t346\t356\t381\t377\n+1106\t0\t0\t0\t0\t0\t0\t0\n+0\t8482\t353\t8250\t347\t357\t382\t378\n+0\t161\t162\t163\t164\t165\t166\t167\n+168\t169\t170\t171\t172\t173\t174\t175\n+176\t177\t178\t179\t180\t181\t182\t183\n+184\t185\t186\t187\t188\t189\t190\t191\n+192\t193\t194\t195\t196\t197\t198\t199\n+200\t201\t202\t203\t204\t205\t206\t207\n+208\t209\t210\t211\t212\t213\t214\t215\n+216\t217\t218\t219\t220\t221\t222\t223\n+224\t225\t226\t227\t228\t229\t230\t231\n+232\t233\t234\t235\t236\t237\t238\t239\n+240\t241\t242\t243\t244\t245\t246\t247\n+248\t249\t250\t251\t252\t253\t254\t255\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/charsets\/ansi.txt","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/* IBM\/Microsoft Code Page 437 character set *\/\n+\/* Derived from tables on ftp.unicode.org *\/\n+\/* Original header:\n+#\n+#    Name:     cp437_DOSLatinUS to Unicode table\n+#    Unicode version: 2.0\n+#    Table version: 2.00\n+#    Table format:  Format A\n+#    Date:          04\/24\/96\n+#    Authors:       Lori Brownell <loribr@microsoft.com>\n+#                   K.D. Chang    <a-kchang@microsoft.com>\n+#    General notes: none\n+*\/\n+0\t1\t2\t3\t4\t5\t6\t7\t\n+8\t9\t10\t11\t12\t13\t14\t15\t\n+16\t17\t18\t19\t20\t21\t22\t23\t\n+24\t25\t26\t27\t28\t29\t30\t31\t\n+32\t33\t34\t35\t36\t37\t38\t39\t\n+40\t41\t42\t43\t44\t45\t46\t47\t\n+48\t49\t50\t51\t52\t53\t54\t55\t\n+56\t57\t58\t59\t60\t61\t62\t63\t\n+64\t65\t66\t67\t68\t69\t70\t71\t\n+72\t73\t74\t75\t76\t77\t78\t79\t\n+80\t81\t82\t83\t84\t85\t86\t87\t\n+88\t89\t90\t91\t92\t93\t94\t95\t\n+96\t97\t98\t99\t100\t101\t102\t103\t\n+104\t105\t106\t107\t108\t109\t110\t111\t\n+112\t113\t114\t115\t116\t117\t118\t119\t\n+120\t121\t122\t123\t124\t125\t126\t127\t\n+199\t252\t233\t226\t228\t224\t229\t231\t\n+234\t235\t232\t239\t238\t236\t196\t197\t\n+201\t230\t198\t244\t246\t242\t251\t249\t\n+255\t214\t220\t162\t163\t165\t8359\t402\t\n+225\t237\t243\t250\t241\t209\t170\t186\t\n+191\t8976\t172\t189\t188\t161\t171\t187\t\n+9617\t9618\t9619\t9474\t9508\t9569\t9570\t9558\t\n+9557\t9571\t9553\t9559\t9565\t9564\t9563\t9488\t\n+9492\t9524\t9516\t9500\t9472\t9532\t9566\t9567\t\n+9562\t9556\t9577\t9574\t9568\t9552\t9580\t9575\t\n+9576\t9572\t9573\t9561\t9560\t9554\t9555\t9579\t\n+9578\t9496\t9484\t9608\t9604\t9612\t9616\t9600\t\n+945\t223\t915\t960\t931\t963\t181\t964\t\n+934\t920\t937\t948\t8734\t966\t949\t8745\t\n+8801\t177\t8805\t8804\t8992\t8993\t247\t8776\t\n+176\t8729\t183\t8730\t8319\t178\t9632\t160\t\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/charsets\/cpg437.txt","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/* IBM\/Microsoft Code Page 850 character set *\/\n+\/* derived form tables on ftp.unicode.org *\/\n+\/* Original header:\n+#    Name:     cp850_DOSLatin1 to Unicode table\n+#    Unicode version: 2.0\n+#    Table version: 2.00\n+#    Table format:  Format A\n+#    Date:          04\/24\/96\n+#    Authors:       Lori Brownell <loribr@microsoft.com>\n+#                   K.D. Chang    <a-kchang@microsoft.com>\n+#    General notes: none\n+*\/\n+0\t1\t2\t3\t4\t5\t6\t7\t\n+8\t9\t10\t11\t12\t13\t14\t15\t\n+16\t17\t18\t19\t20\t21\t22\t23\t\n+24\t25\t26\t27\t28\t29\t30\t31\t\n+32\t33\t34\t35\t36\t37\t38\t39\t\n+40\t41\t42\t43\t44\t45\t46\t47\t\n+48\t49\t50\t51\t52\t53\t54\t55\t\n+56\t57\t58\t59\t60\t61\t62\t63\t\n+64\t65\t66\t67\t68\t69\t70\t71\t\n+72\t73\t74\t75\t76\t77\t78\t79\t\n+80\t81\t82\t83\t84\t85\t86\t87\t\n+88\t89\t90\t91\t92\t93\t94\t95\t\n+96\t97\t98\t99\t100\t101\t102\t103\t\n+104\t105\t106\t107\t108\t109\t110\t111\t\n+112\t113\t114\t115\t116\t117\t118\t119\t\n+120\t121\t122\t123\t124\t125\t126\t127\t\n+199\t252\t233\t226\t228\t224\t229\t231\t\n+234\t235\t232\t239\t238\t236\t196\t197\t\n+201\t230\t198\t244\t246\t242\t251\t249\t\n+255\t214\t220\t248\t163\t216\t215\t402\t\n+225\t237\t243\t250\t241\t209\t170\t186\t\n+191\t174\t172\t189\t188\t161\t171\t187\t\n+9617\t9618\t9619\t9474\t9508\t193\t194\t192\t\n+169\t9571\t9553\t9559\t9565\t162\t165\t9488\t\n+9492\t9524\t9516\t9500\t9472\t9532\t227\t195\t\n+9562\t9556\t9577\t9574\t9568\t9552\t9580\t164\t\n+240\t208\t202\t203\t200\t305\t205\t206\t\n+207\t9496\t9484\t9608\t9604\t166\t204\t9600\t\n+211\t223\t212\t210\t245\t213\t181\t254\t\n+222\t218\t219\t217\t253\t221\t175\t180\t\n+173\t177\t8215\t190\t182\t167\t247\t184\t\n+176\t168\t183\t185\t179\t178\t9632\t160\t\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/charsets\/cpg850.txt","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/* MS RTF MacRoman character set *\/\n+\/* Derived from tables on ftp.unicode.org *\/\n+\/* original header: follows: *\/\n+#    Name:     cp10000_MacRoman to Unicode table\n+#    Unicode version: 2.0\n+#    Table version: 2.00\n+#    Table format:  Format A\n+#    Date:          04\/24\/96\n+#    Authors:       Lori Brownell <loribr@microsoft.com>\n+#                   K.D. Chang    <a-kchang@microsoft.com>\n+#    General notes: none\n+0\t1\t2\t3\t4\t5\t6\t7\t\n+8\t9\t10\t11\t12\t13\t14\t15\t\n+16\t17\t18\t19\t20\t21\t22\t23\t\n+24\t25\t26\t27\t28\t29\t30\t31\t\n+32\t33\t34\t35\t36\t37\t38\t39\t\n+40\t41\t42\t43\t44\t45\t46\t47\t\n+48\t49\t50\t51\t52\t53\t54\t55\t\n+56\t57\t58\t59\t60\t61\t62\t63\t\n+64\t65\t66\t67\t68\t69\t70\t71\t\n+72\t73\t74\t75\t76\t77\t78\t79\t\n+80\t81\t82\t83\t84\t85\t86\t87\t\n+88\t89\t90\t91\t92\t93\t94\t95\t\n+96\t97\t98\t99\t100\t101\t102\t103\t\n+104\t105\t106\t107\t108\t109\t110\t111\t\n+112\t113\t114\t115\t116\t117\t118\t119\t\n+120\t121\t122\t123\t124\t125\t126\t127\t\n+196\t197\t199\t201\t209\t214\t220\t225\t\n+224\t226\t228\t227\t229\t231\t233\t232\t\n+234\t235\t237\t236\t238\t239\t241\t243\t\n+242\t244\t246\t245\t250\t249\t251\t252\t\n+8224\t176\t162\t163\t167\t8226\t182\t223\t\n+174\t169\t8482\t180\t168\t8800\t198\t216\t\n+8734\t177\t8804\t8805\t165\t181\t8706\t8721\t\n+8719\t960\t8747\t170\t186\t8486\t230\t248\t\n+191\t161\t172\t8730\t402\t8776\t8710\t171\t\n+187\t8230\t160\t192\t195\t213\t338\t339\t\n+8211\t8212\t8220\t8221\t8216\t8217\t247\t9674\t\n+255\t376\t8260\t164\t8249\t8250\t64257\t64258\t\n+8225\t183\t8218\t8222\t8240\t194\t202\t193\t\n+203\t200\t205\t206\t207\t204\t211\t212\t\n+0\t210\t218\t219\t217\t305\t710\t732\t\n+175\t728\t729\t730\t184\t733\t731\t711\t\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/charsets\/mac.txt","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+package com.sun.jfx.incubator.scene.control.richtext.util;\n+\n+import java.text.DecimalFormat;\n+\n+\/** debugging aid *\/\n+public class D {\n+    private static final DecimalFormat DOUBLE_FORMAT = new DecimalFormat(\"0.###\");\n+\n+    public static void p(Object... a) {\n+        StringBuilder sb = new StringBuilder();\n+        for (Object x : a) {\n+            if (sb.length() > 0) {\n+                sb.append(' ');\n+            }\n+            sb.append(x);\n+        }\n+        withCaller(2, sb.toString());\n+    }\n+\n+    private static void withCaller(int level, String msg) {\n+        StackTraceElement t = new Throwable().getStackTrace()[level];\n+        String className = t.getClassName();\n+        int ix = className.lastIndexOf('.');\n+        if (ix >= 0) {\n+            className = className.substring(ix + 1);\n+        }\n+        System.err.println(className + \".\" + t.getMethodName() + \":\" + t.getLineNumber() + \" \" + msg);\n+    }\n+\n+    public static void trace() {\n+        new Error(\"Stack Trace:\").printStackTrace();\n+    }\n+\n+    public static String f(double v) {\n+        return DOUBLE_FORMAT.format(v);\n+    }\n+\n+    public static SW sw() {\n+        return new SW();\n+    }\n+\n+    \/** stop watch *\/\n+    public static class SW {\n+        private final long start = System.nanoTime();\n+\n+        public SW() {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            double ms = (System.nanoTime() - start) \/ 1_000_000_000.0;\n+            return f(ms);\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/util\/D.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ Original code is re-licensed to Oracle by the author.\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxTextEditor\/blob\/master\/src\/goryachev\/common\/util\/Disconnectable.java\n+\/\/ Copyright © 2021-2022 Andy Goryachev <andy@goryachev.com>\n+package com.sun.jfx.incubator.scene.control.richtext.util;\n+\n+\/**\n+ * A functional interface that provides a {@link #disconnect()} method.\n+ *\/\n+@FunctionalInterface\n+public interface IDisconnectable {\n+    \/**\n+     * Disconnects what has been connected. May be called multiple times, only the\n+     * first invocation actually disconnects.\n+     *\/\n+    public void disconnect();\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/util\/IDisconnectable.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.jfx.incubator.scene.control.richtext.util;\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBufferInt;\n+import java.awt.image.SampleModel;\n+import java.awt.image.SinglePixelPackedSampleModel;\n+import java.nio.IntBuffer;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.PixelFormat;\n+import javafx.scene.image.PixelReader;\n+import javafx.scene.image.PixelWriter;\n+import javafx.scene.image.WritableImage;\n+import javafx.scene.image.WritablePixelFormat;\n+import javafx.scene.paint.Color;\n+\n+\/**\n+ * Image Utilities copied from javafx.embed.swing.SwingFXUtils.\n+ * Avoids creating dependency on javafx.swing to javafx.controls.\n+ *\/\n+public class ImgUtil {\n+    private ImgUtil() { } \/\/ no instances\n+\n+    \/**\n+     * Snapshots the specified {@link BufferedImage} and stores a copy of\n+     * its pixels into a JavaFX {@link Image} object, creating a new\n+     * object if needed.\n+     * The returned {@code Image} will be a static snapshot of the state\n+     * of the pixels in the {@code BufferedImage} at the time the method\n+     * completes.  Further changes to the {@code BufferedImage} will not\n+     * be reflected in the {@code Image}.\n+     * <p>\n+     * The optional JavaFX {@link WritableImage} parameter may be reused\n+     * to store the copy of the pixels.\n+     * A new {@code Image} will be created if the supplied object is null,\n+     * is too small or of a type which the image pixels cannot be easily\n+     * converted into.\n+     *\n+     * @param bimg the {@code BufferedImage} object to be converted\n+     * @param wimg an optional {@code WritableImage} object that can be\n+     *        used to store the returned pixel data\n+     * @return an {@code Image} object representing a snapshot of the\n+     *         current pixels in the {@code BufferedImage}.\n+     * @since JavaFX 2.2\n+     *\/\n+    public static WritableImage toFXImage(BufferedImage bimg, WritableImage wimg) {\n+        int bw = bimg.getWidth();\n+        int bh = bimg.getHeight();\n+        switch (bimg.getType()) {\n+            case BufferedImage.TYPE_INT_ARGB:\n+            case BufferedImage.TYPE_INT_ARGB_PRE:\n+                break;\n+            default:\n+                BufferedImage converted =\n+                    new BufferedImage(bw, bh, BufferedImage.TYPE_INT_ARGB_PRE);\n+                Graphics2D g2d = converted.createGraphics();\n+                g2d.drawImage(bimg, 0, 0, null);\n+                g2d.dispose();\n+                bimg = converted;\n+                break;\n+        }\n+        \/\/ assert(bimg.getType == TYPE_INT_ARGB[_PRE]);\n+        if (wimg != null) {\n+            int iw = (int) wimg.getWidth();\n+            int ih = (int) wimg.getHeight();\n+            if (iw < bw || ih < bh) {\n+                wimg = null;\n+            } else if (bw < iw || bh < ih) {\n+                int empty[] = new int[iw];\n+                PixelWriter pw = wimg.getPixelWriter();\n+                PixelFormat<IntBuffer> pf = PixelFormat.getIntArgbPreInstance();\n+                if (bw < iw) {\n+                    pw.setPixels(bw, 0, iw-bw, bh, pf, empty, 0, 0);\n+                }\n+                if (bh < ih) {\n+                    pw.setPixels(0, bh, iw, ih-bh, pf, empty, 0, 0);\n+                }\n+            }\n+        }\n+        if (wimg == null) {\n+            wimg = new WritableImage(bw, bh);\n+        }\n+        PixelWriter pw = wimg.getPixelWriter();\n+        DataBufferInt db = (DataBufferInt)bimg.getRaster().getDataBuffer();\n+        int data[] = db.getData();\n+        int offset = bimg.getRaster().getDataBuffer().getOffset();\n+        int scan =  0;\n+        SampleModel sm = bimg.getRaster().getSampleModel();\n+        if (sm instanceof SinglePixelPackedSampleModel) {\n+            scan = ((SinglePixelPackedSampleModel)sm).getScanlineStride();\n+        }\n+\n+        PixelFormat<IntBuffer> pf = (bimg.isAlphaPremultiplied() ?\n+                                     PixelFormat.getIntArgbPreInstance() :\n+                                     PixelFormat.getIntArgbInstance());\n+        pw.setPixels(0, 0, bw, bh, pf, data, offset, scan);\n+        return wimg;\n+    }\n+\n+    \/**\n+     * Determine the optimal BufferedImage type to use for the specified\n+     * {@code fxFormat} allowing for the specified {@code bimg} to be used\n+     * as a potential default storage space if it is not null and is compatible.\n+     *\n+     * @param fxFormat the PixelFormat of the source FX Image\n+     * @param bimg an optional existing {@code BufferedImage} to be used\n+     *             for storage if it is compatible, or null\n+     * @return\n+     *\/\n+    static int\n+            getBestBufferedImageType(PixelFormat<?> fxFormat, BufferedImage bimg,\n+                                     boolean isOpaque)\n+    {\n+        if (bimg != null) {\n+            int bimgType = bimg.getType();\n+            if (bimgType == BufferedImage.TYPE_INT_ARGB ||\n+                bimgType == BufferedImage.TYPE_INT_ARGB_PRE ||\n+                (isOpaque &&\n+                     (bimgType == BufferedImage.TYPE_INT_BGR ||\n+                      bimgType == BufferedImage.TYPE_INT_RGB)))\n+            {\n+                \/\/ We will allow the caller to give us a BufferedImage\n+                \/\/ that has an alpha channel, but we might not otherwise\n+                \/\/ construct one ourselves.\n+                \/\/ We will also allow them to choose their own premultiply\n+                \/\/ type which may not match the image.\n+                \/\/ If left to our own devices we might choose a more specific\n+                \/\/ format as indicated by the choices below.\n+                return bimgType;\n+            }\n+        }\n+        switch (fxFormat.getType()) {\n+            default:\n+            case BYTE_BGRA_PRE:\n+            case INT_ARGB_PRE:\n+                return BufferedImage.TYPE_INT_ARGB_PRE;\n+            case BYTE_BGRA:\n+            case INT_ARGB:\n+                return BufferedImage.TYPE_INT_ARGB;\n+            case BYTE_RGB:\n+                return BufferedImage.TYPE_INT_RGB;\n+            case BYTE_INDEXED:\n+                return (fxFormat.isPremultiplied()\n+                        ? BufferedImage.TYPE_INT_ARGB_PRE\n+                        : BufferedImage.TYPE_INT_ARGB);\n+        }\n+    }\n+\n+    \/**\n+     * Determine the appropriate {@link WritablePixelFormat} type that can\n+     * be used to transfer data into the indicated BufferedImage.\n+     *\n+     * @param bimg the BufferedImage that will be used as a destination for\n+     *             a {@code PixelReader<IntBuffer>#getPixels()} operation.\n+     * @return\n+     *\/\n+    private static WritablePixelFormat<IntBuffer>\n+        getAssociatedPixelFormat(BufferedImage bimg)\n+    {\n+        switch (bimg.getType()) {\n+            \/\/ We lie here for xRGB, but we vetted that the src data was opaque\n+            \/\/ so we can ignore the alpha.  We use ArgbPre instead of Argb\n+            \/\/ just to get a loop that does not have divides in it if the\n+            \/\/ PixelReader happens to not know the data is opaque.\n+            case BufferedImage.TYPE_INT_RGB:\n+            case BufferedImage.TYPE_INT_ARGB_PRE:\n+                return PixelFormat.getIntArgbPreInstance();\n+            case BufferedImage.TYPE_INT_ARGB:\n+                return PixelFormat.getIntArgbInstance();\n+            default:\n+                \/\/ Should not happen...\n+                throw new InternalError(\"Failed to validate BufferedImage type\");\n+        }\n+    }\n+\n+    private static boolean checkFXImageOpaque(PixelReader pr, int iw, int ih) {\n+        for (int x = 0; x < iw; x++) {\n+            for (int y = 0; y < ih; y++) {\n+                Color color = pr.getColor(x,y);\n+                if (color.getOpacity() != 1.0) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Snapshots the specified JavaFX {@link Image} object and stores a\n+     * copy of its pixels into a {@link BufferedImage} object, creating\n+     * a new object if needed.\n+     * The method will only convert a JavaFX {@code Image} that is readable\n+     * as per the conditions on the\n+     * {@link Image#getPixelReader() Image.getPixelReader()}\n+     * method.\n+     * If the {@code Image} is not readable, as determined by its\n+     * {@code getPixelReader()} method, then this method will return null.\n+     * If the {@code Image} is a writable, or other dynamic image, then\n+     * the {@code BufferedImage} will only be set to the current state of\n+     * the pixels in the image as determined by its {@link PixelReader}.\n+     * Further changes to the pixels of the {@code Image} will not be\n+     * reflected in the returned {@code BufferedImage}.\n+     * <p>\n+     * The optional {@code BufferedImage} parameter may be reused to store\n+     * the copy of the pixels.\n+     * A new {@code BufferedImage} will be created if the supplied object\n+     * is null, is too small or of a type which the image pixels cannot\n+     * be easily converted into.\n+     *\n+     * @param img the JavaFX {@code Image} to be converted\n+     * @param bimg an optional {@code BufferedImage} object that may be\n+     *        used to store the returned pixel data\n+     * @return a {@code BufferedImage} containing a snapshot of the JavaFX\n+     *         {@code Image}, or null if the {@code Image} is not readable.\n+     * @since JavaFX 2.2\n+     *\/\n+    public static BufferedImage fromFXImage(Image img, BufferedImage bimg) {\n+        PixelReader pr = img.getPixelReader();\n+        if (pr == null) {\n+            return null;\n+        }\n+        int iw = (int) img.getWidth();\n+        int ih = (int) img.getHeight();\n+        PixelFormat<?> fxFormat = pr.getPixelFormat();\n+        boolean srcPixelsAreOpaque = false;\n+        switch (fxFormat.getType()) {\n+            case INT_ARGB_PRE:\n+            case INT_ARGB:\n+            case BYTE_BGRA_PRE:\n+            case BYTE_BGRA:\n+                \/\/ Check fx image opacity only if\n+                \/\/ supplied BufferedImage is without alpha channel\n+                if (bimg != null &&\n+                        (bimg.getType() == BufferedImage.TYPE_INT_BGR ||\n+                         bimg.getType() == BufferedImage.TYPE_INT_RGB)) {\n+                    srcPixelsAreOpaque = checkFXImageOpaque(pr, iw, ih);\n+                }\n+                break;\n+            case BYTE_RGB:\n+                srcPixelsAreOpaque = true;\n+                break;\n+        }\n+        int prefBimgType = getBestBufferedImageType(pr.getPixelFormat(), bimg, srcPixelsAreOpaque);\n+        if (bimg != null) {\n+            int bw = bimg.getWidth();\n+            int bh = bimg.getHeight();\n+            if (bw < iw || bh < ih || bimg.getType() != prefBimgType) {\n+                bimg = null;\n+            } else if (iw < bw || ih < bh) {\n+                Graphics2D g2d = bimg.createGraphics();\n+                g2d.setComposite(AlphaComposite.Clear);\n+                g2d.fillRect(0, 0, bw, bh);\n+                g2d.dispose();\n+            }\n+        }\n+        if (bimg == null) {\n+            bimg = new BufferedImage(iw, ih, prefBimgType);\n+        }\n+        DataBufferInt db = (DataBufferInt)bimg.getRaster().getDataBuffer();\n+        int data[] = db.getData();\n+        int offset = bimg.getRaster().getDataBuffer().getOffset();\n+        int scan =  0;\n+        SampleModel sm = bimg.getRaster().getSampleModel();\n+        if (sm instanceof SinglePixelPackedSampleModel) {\n+            scan = ((SinglePixelPackedSampleModel)sm).getScanlineStride();\n+        }\n+\n+        WritablePixelFormat<IntBuffer> pf = getAssociatedPixelFormat(bimg);\n+        pr.getPixels(0, 0, iw, ih, pf, data, offset, scan);\n+        return bimg;\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/util\/ImgUtil.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -0,0 +1,447 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ Original code is re-licensed to Oracle by the author.\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxTextEditor\/blob\/master\/src\/goryachev\/fx\/FxDisconnector.java\n+\/\/ Copyright © 2021-2022 Andy Goryachev <andy@goryachev.com>\n+package com.sun.jfx.incubator.scene.control.richtext.util;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.Observable;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.MapChangeListener;\n+import javafx.collections.ObservableList;\n+import javafx.collections.ObservableMap;\n+import javafx.collections.ObservableSet;\n+import javafx.collections.SetChangeListener;\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.event.EventTarget;\n+import javafx.event.EventType;\n+import javafx.scene.control.SkinBase;\n+\n+\/**\n+ * This class provides convenience methods for adding various listeners, both\n+ * strong and weak, as well as a single {@link #disconnect()} method to remove\n+ * all listeners.\n+ * <p>\n+ * There are two usage patterns:\n+ * <ul>\n+ * <li>Client code registers a number of listeners and removes them all at once\n+ * via {@link #disconnect()} call.\n+ * <li>Client code registers a number of listeners and removes one via its\n+ * {@link IDisconnectable} instance.\n+ * <\/ul>\n+ *\n+ * This class is currently used for clean replacement of {@link Skin}s.\n+ * We should consider making this class a part of the public API in {@code javax.base},\n+ * since it proved itself useful in removing listeners and handlers in bulk at the application level.\n+ *\/\n+public class ListenerHelper implements IDisconnectable {\n+    private WeakReference<Object> ownerRef;\n+    private final ArrayList<IDisconnectable> items = new ArrayList<>(4);\n+    private static Function<SkinBase<?>,ListenerHelper> accessor;\n+\n+    public ListenerHelper(Object owner) {\n+        ownerRef = new WeakReference<>(owner);\n+    }\n+\n+    public ListenerHelper() {\n+    }\n+\n+    public static void setAccessor(Function<SkinBase<?>,ListenerHelper> a) {\n+        accessor = a;\n+    }\n+\n+    public static ListenerHelper get(SkinBase<?> skin) {\n+        return accessor.apply(skin);\n+    }\n+\n+    public IDisconnectable addDisconnectable(Runnable r) {\n+        IDisconnectable d = new IDisconnectable() {\n+            @Override\n+            public void disconnect() {\n+                items.remove(this);\n+                r.run();\n+            }\n+        };\n+        items.add(d);\n+        return d;\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        for (int i = items.size() - 1; i >= 0; i--) {\n+            IDisconnectable d = items.remove(i);\n+            d.disconnect();\n+        }\n+    }\n+\n+    private boolean isAliveOrDisconnect() {\n+        if (ownerRef != null) {\n+            if (ownerRef.get() == null) {\n+                disconnect();\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/\/ change listeners\n+\n+    public IDisconnectable addChangeListener(Runnable callback, ObservableValue<?>... props) {\n+        return addChangeListener(callback, false, props);\n+    }\n+\n+    public IDisconnectable addChangeListener(Runnable onChange, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (onChange == null) {\n+            throw new NullPointerException(\"onChange must not be null.\");\n+        }\n+\n+        ChLi li = new ChLi() {\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue p, Object oldValue, Object newValue) {\n+                if (isAliveOrDisconnect()) {\n+                    onChange.run();\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            onChange.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, ChangeListener<T> listener) {\n+        return addChangeListener(prop, false, listener);\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, boolean fireImmediately, ChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        ChLi<T> li = new ChLi<T>() {\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(this);\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue<? extends T> src, T oldValue, T newValue) {\n+                if (isAliveOrDisconnect()) {\n+                    listener.changed(src, oldValue, newValue);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        prop.addListener(li);\n+\n+        if (fireImmediately) {\n+            T v = prop.getValue();\n+            listener.changed(prop, null, v);\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, Consumer<T> callback) {\n+        return addChangeListener(prop, false, callback);\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, boolean fireImmediately, Consumer<T> callback) {\n+        if (callback == null) {\n+            throw new NullPointerException(\"Callback must be specified.\");\n+        }\n+\n+        ChLi<T> li = new ChLi<T>() {\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(this);\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue<? extends T> observable, T oldValue, T newValue) {\n+                if (isAliveOrDisconnect()) {\n+                    callback.accept(newValue);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        prop.addListener(li);\n+\n+        if (fireImmediately) {\n+            T v = prop.getValue();\n+            callback.accept(v);\n+        }\n+\n+        return li;\n+    }\n+\n+    \/\/ invalidation listeners\n+\n+    public IDisconnectable addInvalidationListener(Runnable callback, ObservableValue<?>... props) {\n+        return addInvalidationListener(callback, false, props);\n+    }\n+\n+    public IDisconnectable addInvalidationListener(Runnable callback, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (callback == null) {\n+            throw new NullPointerException(\"Callback must be specified.\");\n+        }\n+\n+        InLi li = new InLi() {\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void invalidated(Observable p) {\n+                if (isAliveOrDisconnect()) {\n+                    callback.run();\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            callback.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addInvalidationListener(ObservableValue<T> prop, InvalidationListener listener) {\n+        return addInvalidationListener(prop, false, listener);\n+    }\n+\n+    public <T> IDisconnectable addInvalidationListener(ObservableValue<T> prop, boolean fireImmediately, InvalidationListener listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        InLi li = new InLi() {\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(this);\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void invalidated(Observable observable) {\n+                if (isAliveOrDisconnect()) {\n+                    listener.invalidated(observable);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        prop.addListener(li);\n+\n+        if (fireImmediately) {\n+            listener.invalidated(prop);\n+        }\n+\n+        return li;\n+    }\n+\n+    \/\/ list change listeners\n+\n+    public <T> IDisconnectable addListChangeListener(ObservableList<T> list, ListChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        LiChLi<T> li = new LiChLi<T>() {\n+            @Override\n+            public void disconnect() {\n+                list.removeListener(this);\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void onChanged(Change<? extends T> ch) {\n+                if (isAliveOrDisconnect()) {\n+                    listener.onChanged(ch);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        list.addListener(li);\n+\n+        return li;\n+    }\n+\n+    \/\/ map change listener\n+\n+    public <K,V> IDisconnectable addMapChangeListener(ObservableMap<K,V> list, MapChangeListener<K,V> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        MaChLi<K,V> li = new MaChLi<K,V>() {\n+            @Override\n+            public void disconnect() {\n+                list.removeListener(this);\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void onChanged(Change<? extends K, ? extends V> ch) {\n+                if (isAliveOrDisconnect()) {\n+                    listener.onChanged(ch);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        list.addListener(li);\n+\n+        return li;\n+    }\n+\n+    \/\/ set change listeners\n+\n+    public <T> IDisconnectable addSetChangeListener(ObservableSet<T> set, SetChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        SeChLi<T> li = new SeChLi<T>() {\n+            @Override\n+            public void disconnect() {\n+                set.removeListener(this);\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void onChanged(Change<? extends T> ch) {\n+                if (isAliveOrDisconnect()) {\n+                    listener.onChanged(ch);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        set.addListener(li);\n+\n+        return li;\n+    }\n+\n+    \/\/ event handlers\n+\n+    public <T extends Event> IDisconnectable addEventHandler(EventTarget x, EventType<T> t, EventHandler<T> handler) {\n+        EvHa<T> h = new EvHa<>(handler) {\n+            @Override\n+            public void disconnect() {\n+                x.removeEventHandler(t, this);\n+            }\n+        };\n+\n+        items.add(h);\n+\n+        x.addEventHandler(t, h);\n+\n+        return h;\n+    }\n+\n+    \/\/ event filters\n+\n+    public <T extends Event> IDisconnectable addEventFilter(EventTarget x, EventType<T> t, EventHandler<T> handler) {\n+        EvHa<T> h = new EvHa<>(handler) {\n+            @Override\n+            public void disconnect() {\n+                x.removeEventFilter(t, this);\n+            }\n+        };\n+\n+        items.add(h);\n+\n+        x.addEventFilter(t, h);\n+\n+        return h;\n+    }\n+\n+    \/\/\n+\n+    private static abstract class ChLi<T> implements IDisconnectable, ChangeListener<T> { }\n+\n+    private static abstract class InLi implements IDisconnectable, InvalidationListener { }\n+\n+    private static abstract class LiChLi<T> implements IDisconnectable, ListChangeListener<T> { }\n+\n+    private static abstract class MaChLi<K,V> implements IDisconnectable, MapChangeListener<K,V> { }\n+\n+    private static abstract class SeChLi<T> implements IDisconnectable, SetChangeListener<T> { }\n+\n+    private abstract class EvHa<T extends Event> implements IDisconnectable, EventHandler<T> {\n+        private final EventHandler<T> handler;\n+\n+        public EvHa(EventHandler<T> h) {\n+            this.handler = h;\n+        }\n+\n+        @Override\n+        public void handle(T ev) {\n+            if (isAliveOrDisconnect()) {\n+                handler.handle(ev);\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/util\/ListenerHelper.java","additions":447,"deletions":0,"binary":false,"changes":447,"status":"added"},{"patch":"@@ -0,0 +1,628 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext.util;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DecimalFormat;\n+import java.util.List;\n+import javax.imageio.ImageIO;\n+import javafx.application.ConditionalFeature;\n+import javafx.application.Platform;\n+import javafx.css.CssMetaData;\n+import javafx.css.Styleable;\n+import javafx.geometry.BoundingBox;\n+import javafx.geometry.Bounds;\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.VPos;\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+import javafx.scene.image.Image;\n+import javafx.scene.layout.Region;\n+import javafx.scene.paint.Color;\n+import javafx.scene.shape.LineTo;\n+import javafx.scene.shape.MoveTo;\n+import javafx.scene.shape.PathElement;\n+import javafx.scene.text.Text;\n+import javafx.scene.text.TextAlignment;\n+import javafx.scene.text.TextFlow;\n+import com.sun.javafx.scene.text.TextFlowHelper;\n+import com.sun.javafx.scene.text.TextLayout;\n+import com.sun.javafx.scene.text.TextLine;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * RichTextArea specific utility methods.\n+ *\/\n+public final class RichUtils {\n+\n+    private static final DecimalFormat format = new DecimalFormat(\"#0.##\");\n+\n+    private RichUtils() {\n+    }\n+\n+    \/**\n+     * A safe substring method which is tolerant to null text, and offsets being outside of the text boundaries.\n+     *\n+     * @param text source text or null\n+     * @param start start offset, must be >= 0\n+     * @param end end offset\n+     * @return a non-null substring\n+     *\/\n+    public static String substring(String text, int start, int end) {\n+        if (text == null) {\n+            return \"\";\n+        }\n+\n+        int len = text.length();\n+        if ((end < 0) || (end > len)) {\n+            end = len;\n+        }\n+\n+        if ((start == 0) && (end == len)) {\n+            return text;\n+        }\n+\n+        return text.substring(start, end);\n+    }\n+\n+    \/** Converts Color to \"#rrggbb\" or \"rgba(r,g,b,a)\" string *\/\n+    public static String toCssColor(Color c) {\n+        if (c.getOpacity() == 1.0) {\n+            return String.format(\n+                \"#%02x%02x%02x\",\n+                eightBit(c.getRed()),\n+                eightBit(c.getGreen()),\n+                eightBit(c.getBlue())\n+            );\n+        } else {\n+            return String.format(\n+                \"rgba(%d,%d,%d,%f)\",\n+                eightBit(c.getRed()),\n+                eightBit(c.getGreen()),\n+                eightBit(c.getBlue()),\n+                c.getOpacity()\n+            );\n+        }\n+    }\n+\n+    \/* Converts Color to its web CSS value #rrggbb *\/\n+    public static String toWebColor(Color c) {\n+        return String.format(\n+            \"#%02x%02x%02x\",\n+            eightBit(c.getRed()),\n+            eightBit(c.getGreen()),\n+            eightBit(c.getBlue())\n+        );\n+    }\n+\n+    private static int eightBit(double val) {\n+        int v = (int)Math.round(val * 255);\n+        if (v < 0) {\n+            return 0;\n+        } else if (v > 255) {\n+            return 255;\n+        }\n+        return v;\n+    }\n+\n+    \/** null-tolerant !equals() *\/\n+    public static boolean notEquals(Object a, Object b) {\n+        return !equals(a, b);\n+    }\n+\n+    \/** null-tolerant equals() *\/\n+    public static boolean equals(Object a, Object b) {\n+        if (a == b) {\n+            return true;\n+        } else if (a == null) {\n+            return (b == null);\n+        } else if (b == null) {\n+            return false;\n+        } else {\n+            return a.equals(b);\n+        }\n+    }\n+\n+    public static boolean isTouchSupported() {\n+        return Platform.isSupported(ConditionalFeature.INPUT_TOUCH);\n+    }\n+\n+    public static int getTextLength(TextFlow f) {\n+        int len = 0;\n+        for (Node n : f.getChildrenUnmodifiable()) {\n+            if (n instanceof Text t) {\n+                len += t.getText().length();\n+            } else {\n+                \/\/ treat non-Text nodes as having 1 character\n+                len++;\n+            }\n+        }\n+        return len;\n+    }\n+\n+    \/\/ TODO javadoc\n+    \/\/ translates path elements from src frame of reference to target, with additional shift by dx, dy\n+    \/\/ only MoveTo, LineTo are supported\n+    \/\/ may return null\n+    public static PathElement[] translatePath(Region tgt, Region src, PathElement[] elements, double deltax, double deltay) {\n+        \/\/System.out.println(\"translatePath from=\" + dump(elements) + \" dx=\" + deltax + \" dy=\" + deltay); \/\/ FIX\n+        Point2D ps = src.localToScreen(0.0, 0.0);\n+        if (ps == null) {\n+            return null;\n+        }\n+\n+        Point2D pt = tgt.localToScreen(tgt.snappedLeftInset(), tgt.snappedTopInset());\n+        double dx = ps.getX() - pt.getX() + deltax;\n+        double dy = ps.getY() - pt.getY() + deltay;\n+        \/\/System.out.println(\"dx=\" + dx + \" dy=\" + dy); \/\/ FIX\n+\n+        for (int i = 0; i < elements.length; i++) {\n+            PathElement em = elements[i];\n+            if (em instanceof LineTo m) {\n+                em = new LineTo(m.getX() + dx, m.getY() + dy);\n+            } else if (em instanceof MoveTo m) {\n+                em = new MoveTo(m.getX() + dx, m.getY() + dy);\n+            } else {\n+                throw new RuntimeException(\"unexpected path element \" + em);\n+            }\n+\n+            elements[i] = em;\n+        }\n+        \/\/System.out.println(\"translatePath to=\" + dump(elements)); \/\/ FIX\n+        return elements;\n+    }\n+\n+    \/**\n+     * Returns true if the font family corresponds to a logical font as defined in\n+     * <a href=\"https:\/\/wiki.openjdk.org\/display\/OpenJFX\/Font+Setup\">OpenJFX Font Setup<\/a> wiki.\n+     * @param family the font family\n+     * @return true if logical, false otherwise\n+     *\/\n+    public static boolean isLogicalFont(String family) {\n+        switch (family) {\n+        case \"System\":\n+        case \"Serif\":\n+        case \"SansSerif\":\n+        case \"Monospaced\":\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Guesses the font style from the font name, until JDK-8092191 is implemented.\n+     * @param lowerCaseName font name, must be lowercase'd\n+     * @return font style: [ normal | italic | oblique ]\n+     *\/\n+    public static String guessFontStyle(String lowerCaseName) {\n+        \/\/ are we going to encounter a localized font name?\n+        if (lowerCaseName.contains(\"italic\")) {\n+            return \"italic\";\n+        } else if (lowerCaseName.contains(\"oblique\")) {\n+            return \"oblique\";\n+        }\n+        return \"normal\";\n+    }\n+\n+    \/**\n+     * Guesses the font weight from the font name, until JDK-8092191 is implemented.\n+     * @param lowerCaseName font name, must be lowercase'd\n+     * @return font weight: [ normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 ]\n+     *\/\n+    public static String guessFontWeight(String lowerCaseName) {\n+        \/\/ are we going to encounter a localized font name?\n+        if (lowerCaseName.contains(\"thin\")) {\n+            return \"100\";\n+        } else if (lowerCaseName.contains(\"extralight\")) {\n+            return \"200\";\n+        } else if (lowerCaseName.contains(\"light\")) {\n+            return \"300\";\n+        } else if (lowerCaseName.contains(\"medium\")) {\n+            return \"500\";\n+        } else if (lowerCaseName.contains(\"semibold\")) {\n+            return \"600\";\n+        } else if (lowerCaseName.contains(\"demibold\")) {\n+            return \"600\";\n+        } else if (lowerCaseName.contains(\"bold\")) {\n+            return \"700\";\n+        } else if (lowerCaseName.contains(\"extrabold\")) {\n+            return \"800\";\n+        } else if (lowerCaseName.contains(\"heavy\")) {\n+            return \"900\";\n+        }\n+        return \"normal\"; \/\/ 400, see FontWeight\n+    }\n+\n+    \/**\n+     * Returns true if the specified lowercased font name is determined to be bold.\n+     * This method is not guaranteed to work in any circumstances, see JDK-8092191\n+     * @param lowerCaseFontName the font name converted to lower case\n+     * @return true if the font is bold\n+     *\/\n+    public static boolean isBold(String lowerCaseFontName) {\n+        \/\/ any others?\n+        \/\/ non-english names?\n+        return\n+            lowerCaseFontName.contains(\"bold\") ||\n+            lowerCaseFontName.contains(\"extrabold\") ||\n+            lowerCaseFontName.contains(\"heavy\");\n+    }\n+\n+    \/**\n+     * Returns true if the specified lowercased font name is determined to be italic or oblique.\n+     * This method is not guaranteed to work in any circumstances, see JDK-8092191\n+     * @param lowerCaseFontName the font name converted to lower case\n+     * @return true if the font is italic\n+     *\/\n+    public static boolean isItalic(String lowerCaseFontName) {\n+        \/\/ any others?\n+        \/\/ non-english names?\n+        return\n+            lowerCaseFontName.contains(\"italic\") ||\n+            lowerCaseFontName.contains(\"oblique\");\n+    }\n+\n+    \/** dumps the path element array to a compact human-readable string *\/\n+    public static String dump(PathElement[] elements) {\n+        StringBuilder sb = new StringBuilder();\n+        if (elements == null) {\n+            sb.append(\"null\");\n+        } else {\n+            for (PathElement em : elements) {\n+                if (em instanceof MoveTo p) {\n+                    sb.append('M');\n+                    sb.append(r(p.getX()));\n+                    sb.append(',');\n+                    sb.append(r(p.getY()));\n+                    sb.append(' ');\n+                } else if (em instanceof LineTo p) {\n+                    sb.append('L');\n+                    sb.append(r(p.getX()));\n+                    sb.append(',');\n+                    sb.append(r(p.getY()));\n+                    sb.append(' ');\n+                } else {\n+                    sb.append(em);\n+                    sb.append(' ');\n+                }\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static int r(double x) {\n+        return (int)Math.round(x);\n+    }\n+\n+    public static String toCss(TextAlignment a) {\n+        switch(a) {\n+        case CENTER:\n+            return \"center\";\n+        case JUSTIFY:\n+            return \"justify\";\n+        case RIGHT:\n+            return \"right\";\n+        case LEFT:\n+        default:\n+            return \"left\";\n+        }\n+    }\n+\n+    public static String formatDouble(Double value) {\n+        return format.format(value);\n+    }\n+\n+    @Deprecated \/\/ FIX remove\n+    public static char encodeAlignment(TextAlignment a) {\n+        switch (a) {\n+        case CENTER:\n+            return 'C';\n+        case JUSTIFY:\n+            return 'J';\n+        case RIGHT:\n+            return 'R';\n+        case LEFT:\n+        default:\n+            return 'L';\n+        }\n+    }\n+\n+    @Deprecated \/\/ FIX remove\n+    public static TextAlignment decodeAlignment(int c) throws IOException {\n+        switch (c) {\n+        case 'C':\n+            return TextAlignment.CENTER;\n+        case 'J':\n+            return TextAlignment.JUSTIFY;\n+        case 'L':\n+            return TextAlignment.LEFT;\n+        case 'R':\n+            return TextAlignment.RIGHT;\n+        default:\n+            throw new IOException(\"failed parsing alignment (\" + (char)c + \")\");\n+        }\n+    }\n+\n+    \/**\n+     * Combines style attributes, returning combined object (or null).\n+     *\n+     * @param lowPri the low priority attributes\n+     * @param hiPri the high priority attributes\n+     * @return the combined attributes, or null\n+     *\/\n+    public static StyleAttributeMap combine(StyleAttributeMap lowPri, StyleAttributeMap hiPri) {\n+        if ((lowPri != null) && (!lowPri.isEmpty())) {\n+            if (hiPri == null) {\n+                return lowPri;\n+            } else {\n+                return StyleAttributeMap.builder().merge(lowPri).merge(hiPri).build();\n+            }\n+        }\n+        return hiPri;\n+    }\n+\n+    \/**\n+     * Utility method which combines {@code CssMetaData} items in one immutable list.\n+     * <p>\n+     * The intended usage is to combine the parent and the child {@code CssMetaData} for\n+     * the purposes of {@code getClassCssMetaData()} method, see for example {@link Node#getClassCssMetaData()}.\n+     * <p>\n+     * Example:\n+     * <pre>{@code\n+     * private static final List<CssMetaData<? extends Styleable, ?>> STYLEABLES = CssMetaData.combine(\n+     *      <Parent>.getClassCssMetaData(),\n+     *      STYLEABLE1,\n+     *      STYLEABLE2\n+     *  );\n+     * }<\/pre>\n+     * This method returns an instance of a {@code List} that implements\n+     * {@link java.util.RandomAccess} interface.\n+     *\n+     * @param inheritedFromParent the {@code CssMetaData} items inherited from parent, must not be null\n+     * @param items the additional items\n+     * @return the immutable list containing all of the items\n+     *\/\n+    \/\/ NOTE: this should be a public utility, see https:\/\/bugs.openjdk.org\/browse\/JDK-8320796\n+    public static List<CssMetaData<? extends Styleable, ?>> combine(\n+        List<CssMetaData<? extends Styleable, ?>> inheritedFromParent,\n+        CssMetaData<? extends Styleable, ?>... items)\n+    {\n+        CssMetaData[] combined = new CssMetaData[inheritedFromParent.size() + items.length];\n+        inheritedFromParent.toArray(combined);\n+        System.arraycopy(items, 0, combined, inheritedFromParent.size(), items.length);\n+        \/\/ makes a copy, unfortunately\n+        return List.of(combined);\n+    }\n+\n+    \/**\n+     * Reads a UTF8 string from the input stream.\n+     * This method does not close the input stream.\n+     * @param in the input stream\n+     * @return the string\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    public static String readString(InputStream in) throws IOException {\n+        BufferedInputStream b = new BufferedInputStream(in);\n+        InputStreamReader rd = new InputStreamReader(in, StandardCharsets.UTF_8);\n+        StringBuilder sb = new StringBuilder(65536);\n+        int c;\n+        while ((c = in.read()) >= 0) {\n+            sb.append((char)c);\n+        }\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Invoked when the user attempts an invalid operation,\n+     * such as pasting into an uneditable <code>TextInputControl<\/code>\n+     * that has focus. The default implementation beeps.\n+     *\n+     * @param originator the <code>Node<\/code> the error occurred in, may be <code>null<\/code>\n+     *                   indicating the error condition is not directly associated with a <code>Node<\/code>\n+     * @param error the exception thrown (can be null)\n+     *\/\n+    \/\/ TODO this probably should be in Platform\n+    public static void provideErrorFeedback(Node originator, Throwable error) {\n+        beep();\n+        if (error != null) {\n+            \/\/ TODO should be using logging\n+            error.printStackTrace();\n+        }\n+    }\n+\n+    \/** Emits a short audible alert, if supported by the platform. *\/\n+    public static void beep() {\n+        \/\/ TODO not supported in FX\n+    }\n+\n+    \/**\n+     * Writes an Image to a byte array in PNG format.\n+     *\n+     * @param im source image\n+     * @return byte array containing PNG image\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    public static byte[] writePNG(Image im) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream(65536);\n+        \/\/ this might conflict with user-set value\n+        ImageIO.setUseCache(false);\n+        ImageIO.write(ImgUtil.fromFXImage(im, null), \"PNG\", out);\n+        return out.toByteArray();\n+    }\n+\n+    \/**\n+     * Returns true if code point at the specified offset is a letter or a digit,\n+     * returns false otherwise or if the offset is outside of the valid range.\n+     * @param text the text\n+     * @param offset the character offset\n+     * @param len the text length\n+     * @return true if the code point at the specified offset is a letter or a digit\n+     *\/\n+    public static boolean isLetterOrDigit(String text, int offset) {\n+        if (offset < 0) {\n+            return false;\n+        } else if (offset >= text.length()) {\n+            return false;\n+        }\n+        \/\/ ignore the case when 'c' is a high surrogate without the low surrogate\n+        int c = Character.codePointAt(text, offset);\n+        return Character.isLetterOrDigit(c);\n+    }\n+\n+    \/**\n+     * Returns the offset of the next code point, or the end of the text string.\n+     * @param text the text\n+     * @param offset the offset to start from\n+     * @return the offset of the next code point, or the end of the text string\n+     *\/\n+    public static int nextCodePoint(String text, int offset) {\n+        int len = text.length();\n+        if (offset < len) {\n+            char ch1 = text.charAt(offset++);\n+            if (Character.isHighSurrogate(ch1) && offset < len) {\n+                char ch2 = text.charAt(offset);\n+                if (Character.isLowSurrogate(ch2)) {\n+                    ++offset;\n+                }\n+            }\n+            return offset;\n+        }\n+        return len;\n+    }\n+\n+    \/**\n+     * Converts PathElement[] in the owner's coordinates to a Bounds[] in screen coordinates.\n+     * It assumes the input array is a sequence of <pre>\n+     * MoveTo (top-left)\n+     * LineTo (to top-right)\n+     * LineTo (bottom-right)\n+     * LineTo (bottom-left)\n+     * LineTo (back to top-left)\n+     * <\/pre>\n+     * This method will break if the input sequence is different.\n+     *\/\n+    public static Bounds[] pathToBoundsArray(Node owner, PathElement[] elements) {\n+        Bounds[] bounds = new Bounds[elements.length \/ 5];\n+        int index = 0;\n+        for (int i = 0; i < bounds.length; i++) {\n+            MoveTo topLeft = (MoveTo)elements[index];\n+            LineTo topRight = (LineTo)elements[index + 1];\n+            LineTo bottomRight = (LineTo)elements[index + 2];\n+            BoundingBox b = new BoundingBox(\n+                topLeft.getX(),\n+                topLeft.getY(),\n+                topRight.getX() - topLeft.getX(),\n+                bottomRight.getY() - topRight.getY()\n+            );\n+            bounds[i] = owner.localToScreen(b);\n+            index += 5;\n+        }\n+        return bounds;\n+    }\n+\n+    private static int parseInt(Object x) {\n+        if (x instanceof Integer n) {\n+            return n.intValue();\n+        }\n+        return 0;\n+    }\n+\n+    \/**\n+     * Returns the line index of the given character offset.\n+     *\n+     * @param offset the character offset\n+     * @return the line index\n+     *\/\n+    public static int lineForOffset(TextFlow f, int offset) {\n+        TextLayout la = TextFlowHelper.getTextLayout(f);\n+        TextLine[] lines = la.getLines();\n+        int line = 0;\n+        for (int i = 1; i < lines.length; i++) {\n+            TextLine t = lines[i];\n+            if (t.getStart() > offset) {\n+                return line;\n+            }\n+            line++;\n+        }\n+        return line;\n+    }\n+\n+    \/**\n+     * Returns the line start offset of the given line index.\n+     *\n+     * @param line the line index\n+     * @return the line start offset\n+     *\/\n+    public static Integer lineStart(TextFlow f, int line) {\n+        TextLayout la = TextFlowHelper.getTextLayout(f);\n+        TextLine[] lines = la.getLines();\n+        if (0 <= line && line < lines.length) {\n+            TextLine t = lines[line];\n+            return t.getStart();\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the line end offset of the given line index.\n+     *\n+     * @param line the line index\n+     * @return the line offset\n+     *\/\n+    public static Integer lineEnd(TextFlow f, int line) {\n+        TextLayout la = TextFlowHelper.getTextLayout(f);\n+        TextLine[] lines = la.getLines();\n+        if (0 <= line && line < lines.length) {\n+            TextLine t = lines[line];\n+            return t.getStart() + t.getLength();\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Convenience method for laying out the node within its parent, filling the available area.\n+     * This method is equivalent to calling\n+     * {@code Region.layoutInArea(n, x, y, w, h, 0.0, Insets.EMPTY, true, true, HPos.CENTER, VPos.CENTER, snap);}\n+     *\n+     * @param n the node to lay out\n+     * @param x the horizontal offset of the layout area\n+     * @param y the vertical offset of the layout area\n+     * @param w the width of the layout area\n+     * @param h the height of the layout area\n+     *\/\n+    public static void layoutInArea(Node n, double x, double y, double w, double h) {\n+        Parent p = n.getParent();\n+        boolean snap = (p instanceof Region r) ? r.isSnapToPixel() : false;\n+        Region.layoutInArea(n, x, y, w, h, 0.0, Insets.EMPTY, true, true, HPos.CENTER, VPos.CENTER, snap);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/util\/RichUtils.java","additions":628,"deletions":0,"binary":false,"changes":628,"status":"added"},{"patch":"@@ -0,0 +1,425 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jfx.incubator.scene.control.richtext;\n+\n+import java.util.List;\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.DoubleProperty;\n+import javafx.beans.property.IntegerProperty;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.value.WritableValue;\n+import javafx.css.CssMetaData;\n+import javafx.css.FontCssMetaData;\n+import javafx.css.StyleOrigin;\n+import javafx.css.Styleable;\n+import javafx.css.StyleableDoubleProperty;\n+import javafx.css.StyleableIntegerProperty;\n+import javafx.css.StyleableObjectProperty;\n+import javafx.css.StyleableProperty;\n+import javafx.css.converter.SizeConverter;\n+import javafx.scene.AccessibleAttribute;\n+import javafx.scene.Node;\n+import javafx.scene.control.Labeled;\n+import javafx.scene.text.Font;\n+import com.sun.jfx.incubator.scene.control.richtext.Params;\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n+import jfx.incubator.scene.control.richtext.model.CodeTextModel;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+import jfx.incubator.scene.control.richtext.skin.CodeAreaSkin;\n+import jfx.incubator.scene.control.richtext.skin.RichTextAreaSkin;\n+\n+\/**\n+ * CodeArea is an editable text component which supports styling (syntax highlighting) of plain text.\n+ * <p>\n+ * Unlike its base class {@link RichTextArea}, the {@code CodeArea} requires a special kind of model to be used,\n+ * a {@link CodeTextModel}.\n+ * <h2>Creating a CodeArea<\/h2>\n+ * <p>\n+ * The following example creates an editable control with the default {@link CodeArea}:\n+ * <pre>{@code    CodeArea codeArea = new CodeArea();\n+ *   codeArea.setWrapText(true);\n+ *   codeArea.setLineNumbersEnabled(true);\n+ *   codeArea.setText(\"Lorem\\nIpsum\");\n+ * }<\/pre>\n+ * Which results in the following visual representation:\n+ * <p>\n+ * <img src=\"doc-files\/CodeArea.png\" alt=\"Image of the CodeArea control\">\n+ * <\/p>\n+ *\/\n+public class CodeArea extends RichTextArea {\n+    private BooleanProperty lineNumbers;\n+    private StyleableIntegerProperty tabSize;\n+    private StyleableObjectProperty<Font> font;\n+    private StyleableDoubleProperty lineSpacing;\n+    private String fontStyle;\n+\n+    \/**\n+     * This constructor creates the CodeArea with the specified {@link CodeTextModel}.\n+     * @param model the instance of {@link CodeTextModel} to use\n+     *\/\n+    public CodeArea(CodeTextModel model) {\n+        super(model);\n+\n+        getStyleClass().add(\"code-area\");\n+        setAccessibleRoleDescription(\"Code Area\");\n+\n+        modelProperty().addListener((s, prev, newValue) -> {\n+            \/\/ TODO is there a better way?\n+            \/\/ perhaps even block any change of (already set CodeModel)\n+            if (newValue != null) {\n+                if (!(newValue instanceof CodeTextModel)) {\n+                    setModel(prev);\n+                    throw new IllegalArgumentException(\"model must be of type \" + CodeTextModel.class);\n+                }\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * This constructor creates the CodeArea with the default {@link CodeTextModel}.\n+     *\/\n+    public CodeArea() {\n+        this(new CodeTextModel());\n+    }\n+\n+    @Override\n+    protected RichTextAreaSkin createDefaultSkin() {\n+        return new CodeAreaSkin(this);\n+    }\n+\n+    \/**\n+     * This convenience method sets the decorator property in the {@link CodeTextModel}.\n+     * Nothing is done if the model is null.\n+     *\n+     * @param d the syntax decorator\n+     * @see CodeTextModel#setDecorator(SyntaxDecorator)\n+     *\/\n+    public final void setSyntaxDecorator(SyntaxDecorator d) {\n+        CodeTextModel m = codeModel();\n+        if (m != null) {\n+            m.setDecorator(d);\n+        }\n+    }\n+\n+    \/**\n+     * This convenience method returns the syntax decorator value in the {@link CodeTextModel},\n+     * or null if the model is null.\n+     * @return the syntax decorator value, or null\n+     *\/\n+    public final SyntaxDecorator getSyntaxDecorator() {\n+        CodeTextModel m = codeModel();\n+        return (m == null) ? null : m.getDecorator();\n+    }\n+\n+    \/**\n+     * Determines whether to show line numbers.\n+     * @return the line numbers enabled property\n+     * @defaultValue false\n+     *\/\n+    \/\/ TODO should there be a way to customize the line number component? createLineNumberDecorator() ?\n+    \/\/ TODO should this be a styleable property?\n+    public final BooleanProperty lineNumbersEnabledProperty() {\n+        if (lineNumbers == null) {\n+            lineNumbers = new SimpleBooleanProperty() {\n+                @Override\n+                protected void invalidated() {\n+                    LineNumberDecorator d;\n+                    if (get()) {\n+                        \/\/ TODO create line number decorator method?\n+                        d = new LineNumberDecorator() {\n+                            @Override\n+                            public Node getNode(int ix, boolean forMeasurement) {\n+                                Node n = super.getNode(ix, forMeasurement);\n+                                if (n instanceof Labeled t) {\n+                                    t.fontProperty().bind(fontProperty());\n+                                }\n+                                return n;\n+                            }\n+                        };\n+                    } else {\n+                        d = null;\n+                    }\n+                    setLeftDecorator(d);\n+                }\n+            };\n+        }\n+        return lineNumbers;\n+    }\n+\n+    public final boolean isLineNumbersEnabled() {\n+        return lineNumbers == null ? false : lineNumbers.get();\n+    }\n+\n+    public final void setLineNumbersEnabled(boolean on) {\n+        lineNumbersEnabledProperty().set(on);\n+    }\n+\n+    \/**\n+     * The size of a tab stop in spaces.\n+     * Values less than 1 are treated as 1.\n+     * @return the tab size property\n+     * @defaultValue 8\n+     *\/\n+    public final IntegerProperty tabSizeProperty() {\n+        if (tabSize == null) {\n+            tabSize = new StyleableIntegerProperty(Params.DEFAULT_TAB_SIZE) {\n+                @Override\n+                public Object getBean() {\n+                    return CodeArea.this;\n+                }\n+\n+                @Override\n+                public String getName() {\n+                    return \"tabSize\";\n+                }\n+\n+                @Override\n+                public CssMetaData getCssMetaData() {\n+                    return StyleableProperties.TAB_SIZE;\n+                }\n+            };\n+        }\n+        return tabSize;\n+    }\n+\n+    public final int getTabSize() {\n+        return tabSize == null ? Params.DEFAULT_TAB_SIZE : tabSize.get();\n+    }\n+\n+    public final void setTabSize(int spaces) {\n+        tabSizeProperty().set(spaces);\n+    }\n+\n+    \/**\n+     * The font to use for text in the {@code CodeArea}.\n+     * @return the font property\n+     * @defaultValue the Monospaced font with size 12.0 px\n+     *\/\n+    public final ObjectProperty<Font> fontProperty() {\n+        if (font == null) {\n+            font = new StyleableObjectProperty<Font>(defaultFont())\n+            {\n+                private boolean fontSetByCss;\n+\n+                @Override\n+                public void applyStyle(StyleOrigin newOrigin, Font value) {\n+                    \/\/ TODO perhaps this is not needed\n+                    \/\/ RT-20727 JDK-8127428\n+                    \/\/ if CSS is setting the font, then make sure invalidate doesn't call NodeHelper.reapplyCSS\n+                    try {\n+                        \/\/ super.applyStyle calls set which might throw if value is bound.\n+                        \/\/ Have to make sure fontSetByCss is reset.\n+                        fontSetByCss = true;\n+                        super.applyStyle(newOrigin, value);\n+                    } catch (Exception e) {\n+                        throw e;\n+                    } finally {\n+                        fontSetByCss = false;\n+                    }\n+                }\n+\n+                @Override\n+                public void set(Font value) {\n+                    Font old = get();\n+                    if (value == null ? old == null : value.equals(old)) {\n+                        return;\n+                    }\n+                    super.set(value);\n+                }\n+\n+                @Override\n+                public CssMetaData<CodeArea, Font> getCssMetaData() {\n+                    return StyleableProperties.FONT;\n+                }\n+\n+                @Override\n+                public Object getBean() {\n+                    return CodeArea.this;\n+                }\n+\n+                @Override\n+                public String getName() {\n+                    return \"font\";\n+                }\n+            };\n+        }\n+        return font;\n+    }\n+\n+    public final void setFont(Font value) {\n+        fontProperty().setValue(value);\n+    }\n+\n+    public final Font getFont() {\n+        return font == null ? defaultFont() : font.getValue();\n+    }\n+\n+    private static Font defaultFont() {\n+        return Font.font(\"Monospaced\", 12.0);\n+    }\n+\n+    \/**\n+     * Defines the vertical space in pixels between lines.\n+     *\n+     * @return the property instance\n+     * @defaultValue 0\n+     *\/\n+    public final DoubleProperty lineSpacingProperty() {\n+        if (lineSpacing == null) {\n+            lineSpacing = new StyleableDoubleProperty(0) {\n+                @Override\n+                public Object getBean() {\n+                    return CodeArea.this;\n+                }\n+\n+                @Override\n+                public String getName() {\n+                    return \"lineSpacing\";\n+                }\n+\n+                @Override\n+                public CssMetaData<CodeArea, Number> getCssMetaData() {\n+                    return StyleableProperties.LINE_SPACING;\n+                }\n+            };\n+        }\n+        return lineSpacing;\n+    }\n+\n+    public final void setLineSpacing(double spacing) {\n+        lineSpacingProperty().set(spacing);\n+    }\n+\n+    public final double getLineSpacing() {\n+        return lineSpacing == null ? 0 : lineSpacing.get();\n+    }\n+\n+    @Override\n+    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {\n+        switch (attribute) {\n+        case FONT:\n+            return getFont();\n+        default:\n+            return super.queryAccessibleAttribute(attribute, parameters);\n+        }\n+    }\n+\n+    \/** styleable properties *\/\n+    private static class StyleableProperties {\n+        private static final CssMetaData<CodeArea,Number> LINE_SPACING =\n+            new CssMetaData<>(\"-fx-line-spacing\", SizeConverter.getInstance(), 0) {\n+\n+            @Override public boolean isSettable(CodeArea n) {\n+                return n.lineSpacing == null || !n.lineSpacing.isBound();\n+            }\n+\n+            @Override public StyleableProperty<Number> getStyleableProperty(CodeArea n) {\n+                return (StyleableProperty<Number>)n.lineSpacingProperty();\n+            }\n+        };\n+\n+        private static final FontCssMetaData<CodeArea> FONT =\n+            new FontCssMetaData<>(\"-fx-font\", defaultFont())\n+        {\n+            @Override\n+            public boolean isSettable(CodeArea n) {\n+                return n.font == null || !n.font.isBound();\n+            }\n+\n+            @Override\n+            public StyleableProperty<Font> getStyleableProperty(CodeArea n) {\n+                return (StyleableProperty<Font>)(WritableValue<Font>)n.fontProperty();\n+            }\n+        };\n+\n+        private static final CssMetaData<CodeArea, Number> TAB_SIZE =\n+            new CssMetaData<>(\"-fx-tab-size\", SizeConverter.getInstance(), Params.DEFAULT_TAB_SIZE)\n+        {\n+            @Override\n+            public boolean isSettable(CodeArea n) {\n+                return n.tabSize == null || !n.tabSize.isBound();\n+            }\n+\n+            @Override\n+            public StyleableProperty<Number> getStyleableProperty(CodeArea n) {\n+                return (StyleableProperty<Number>)n.tabSizeProperty();\n+            }\n+        };\n+\n+        private static final List<CssMetaData<? extends Styleable, ?>> STYLEABLES = RichUtils.combine(\n+            RichTextArea.getClassCssMetaData(),\n+            FONT,\n+            LINE_SPACING,\n+            TAB_SIZE\n+        );\n+    }\n+\n+    \/**\n+     * Gets the {@code CssMetaData} associated with this class, which may include the\n+     * {@code CssMetaData} of its superclasses.\n+     * @return the {@code CssMetaData}\n+     *\/\n+    public static List<CssMetaData<? extends Styleable, ?>> getClassCssMetaData() {\n+        return StyleableProperties.STYLEABLES;\n+    }\n+\n+    @Override\n+    public List<CssMetaData<? extends Styleable, ?>> getControlCssMetaData() {\n+        return StyleableProperties.STYLEABLES;\n+    }\n+\n+    \/**\n+     * Returns plain text.\n+     * @return plain text\n+     *\/\n+    public final String getText() {\n+        \/\/ TODO or use save(DataFormat, Writer) ?\n+        StyledTextModel m = getModel();\n+        StringBuilder sb = new StringBuilder(4096);\n+        int sz = m.size();\n+        for(int i=0; i<sz; i++) {\n+            String s = m.getPlainText(i);\n+            sb.append(s);\n+            sb.append('\\n');\n+        }\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Replaces text in this CodeArea.\n+     * <p>\n+     * The caret gets reset to the start of the document, selection gets cleared, and an undo event gets created.\n+     * @param text the text string\n+     *\/\n+    public final void setText(String text) {\n+        TextPos end = getDocumentEnd();\n+        getModel().replace(null, TextPos.ZERO, end, text, true);\n+    }\n+\n+    private CodeTextModel codeModel() {\n+        return (CodeTextModel)getModel();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/CodeArea.java","additions":425,"deletions":0,"binary":false,"changes":425,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext;\n+\n+import java.text.DecimalFormat;\n+import javafx.geometry.Pos;\n+import javafx.scene.Node;\n+import javafx.scene.control.Label;\n+\n+\/**\n+ * Side decorator which shows paragraph (line) numbers.\n+ * The numbering starts at line 1.\n+ *\/\n+public class LineNumberDecorator implements SideDecorator {\n+    private final DecimalFormat format;\n+\n+    \/**\n+     * Creates an instance using Western-style group separator (comma).\n+     *\/\n+    public LineNumberDecorator() {\n+        this(\"#,##0\");\n+    }\n+\n+    \/**\n+     * Creates an instance using the specified pattern for {@link DecimalFormat}.\n+     * @param pattern the DecimalFormat pattern to use\n+     *\/\n+    public LineNumberDecorator(String pattern) {\n+        format = new DecimalFormat(pattern);\n+    }\n+\n+    @Override\n+    public double getPrefWidth(double viewWidth) {\n+        \/\/ no set width, must request a measurer Node\n+        return 0;\n+    }\n+\n+    @Override\n+    public Node getNode(int ix, boolean forMeasurement) {\n+        if (forMeasurement) {\n+            \/\/ for measurer node only: allow for extra digit(s) in the bottom rows\n+            ix += 300;\n+        }\n+\n+        String s = format.format(ix + 1);\n+        if (forMeasurement) {\n+            \/\/ account for some variability with proportional font\n+            s += \" \";\n+        }\n+\n+        Label t = new Label(s);\n+        t.getStyleClass().add(\"line-number-decorator\");\n+        \/\/ label needs to fill all available space\n+        t.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);\n+        \/\/ do not interfere with vflow layout\n+        t.setMinHeight(1);\n+        t.setPrefHeight(1);\n+        \/\/ numbers should be right aligned\n+        t.setAlignment(Pos.CENTER_RIGHT);\n+        t.setOpacity(1.0);\n+        return t;\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/LineNumberDecorator.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\n+package jfx.incubator.scene.control.richtext;\n+\n+import java.util.Objects;\n+import javafx.beans.property.ReadOnlyObjectProperty;\n+import javafx.beans.property.ReadOnlyObjectWrapper;\n+import com.sun.jfx.incubator.scene.control.richtext.MarkerHelper;\n+\n+\/**\n+ * Tracks the text position in a document in the presence of edits.\n+ *\/\n+public final class Marker implements Comparable<Marker> {\n+    static {\n+        MarkerHelper.setAccessor(new MarkerHelper.Accessor() {\n+            @Override\n+            public void setMarkerPos(Marker m, TextPos p) {\n+                m.setTextPos(p);\n+            }\n+\n+            @Override\n+            public Marker createMarker(TextPos p) {\n+                return new Marker(p);\n+            }\n+        });\n+    }\n+\n+    private final ReadOnlyObjectWrapper<TextPos> pos;\n+\n+    private Marker(TextPos pos) {\n+        Objects.nonNull(pos);\n+        this.pos = new ReadOnlyObjectWrapper<>(pos);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Marker{\" + getIndex() + \",\" + getOffset() + \"}\";\n+    }\n+\n+    \/**\n+     * This property tracks the marker's position within the model (value is never null).\n+     * @return the text position property\n+     *\/\n+    public final ReadOnlyObjectProperty<TextPos> textPosProperty() {\n+        return pos.getReadOnlyProperty();\n+    }\n+\n+    public final TextPos getTextPos() {\n+        return pos.get();\n+    }\n+\n+    private final void setTextPos(TextPos p) {\n+        pos.set(p);\n+    }\n+\n+    @Override\n+    public final int compareTo(Marker m) {\n+        return getTextPos().compareTo(m.getTextPos());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int h = Marker.class.hashCode();\n+        h = h * 31 + getTextPos().hashCode();\n+        return h;\n+    }\n+\n+    @Override\n+    public boolean equals(Object x) {\n+        if (x == this) {\n+            return true;\n+        } else if (x instanceof Marker m) {\n+            return getTextPos().equals(m.getTextPos());\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns the model paragraph index.\n+     * @return paragraph index\n+     *\/\n+    public final int getIndex() {\n+        return getTextPos().index();\n+    }\n+\n+    \/**\n+     * Returns the insert offset within the paragraph.\n+     * @return offset value\n+     *\/\n+    public final int getOffset() {\n+        return getTextPos().offset();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/Marker.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,2345 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\n+package jfx.incubator.scene.control.richtext;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.List;\n+import java.util.Objects;\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.ReadOnlyBooleanProperty;\n+import javafx.beans.property.ReadOnlyBooleanWrapper;\n+import javafx.beans.property.ReadOnlyProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.css.CssMetaData;\n+import javafx.css.SimpleStyleableObjectProperty;\n+import javafx.css.StyleConverter;\n+import javafx.css.Styleable;\n+import javafx.css.StyleableBooleanProperty;\n+import javafx.css.StyleableProperty;\n+import javafx.css.converter.DurationConverter;\n+import javafx.css.converter.InsetsConverter;\n+import javafx.geometry.Insets;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.Point2D;\n+import javafx.scene.AccessibleAction;\n+import javafx.scene.AccessibleAttribute;\n+import javafx.scene.AccessibleRole;\n+import javafx.scene.control.Control;\n+import javafx.scene.input.DataFormat;\n+import javafx.util.Duration;\n+import com.sun.jfx.incubator.scene.control.input.InputMapHelper;\n+import com.sun.jfx.incubator.scene.control.richtext.CssStyles;\n+import com.sun.jfx.incubator.scene.control.richtext.Params;\n+import com.sun.jfx.incubator.scene.control.richtext.RTAccessibilityHelper;\n+import com.sun.jfx.incubator.scene.control.richtext.RichTextAreaSkinHelper;\n+import com.sun.jfx.incubator.scene.control.richtext.VFlow;\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n+import jfx.incubator.scene.control.input.FunctionTag;\n+import jfx.incubator.scene.control.input.InputMap;\n+import jfx.incubator.scene.control.richtext.model.RichTextModel;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledInput;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+import jfx.incubator.scene.control.richtext.skin.RichTextAreaSkin;\n+\n+\/**\n+ * The RichTextArea control is designed for visualizing and editing rich text that can be styled in a variety of ways.\n+ *\n+ * <p>The RichTextArea control has a number of features, including:\n+ * <ul>\n+ * <li> {@link StyledTextModel paragraph-oriented model}, up to ~2 billion rows\n+ * <li> virtualized text cell flow\n+ * <li> support for text styling with an application stylesheet or {@link StyleAttributeMap inline attributes}\n+ * <li> supports for multiple views connected to the same model\n+ * <li> {@link SelectionModel single selection}\n+ * <li> {@link InputMap input map} which allows for easy behavior customization and extension\n+ * <\/ul>\n+ *\n+ * <h2>Creating a RichTextArea<\/h2>\n+ * <p>\n+ * The following example creates an editable control with the default {@link RichTextModel}:\n+ * <pre>{@code    RichTextArea textArea = new RichTextArea();\n+ * }<\/pre>\n+ * The methods\n+ * {@code appendText()}, {@code insertText()}, {@code replaceText()}, {@code applyStyle()},\n+ * {@code setStyle()}, or {@code clear()} can be used to modify text programmatically:\n+ * <pre>{@code    \/\/ create styles\n+ *   StyleAttributeMap heading = StyleAttributeMap.builder().setBold(true).setUnderline(true).setFontSize(18).build();\n+ *   StyleAttributeMap mono = StyleAttributeMap.builder().setFontFamily(\"Monospaced\").build();\n+ *\n+ *   RichTextArea textArea = new RichTextArea();\n+ *   \/\/ build the content\n+ *   textArea.appendText(\"RichTextArea\\n\", heading);\n+ *   textArea.appendText(\"Example:\\nText is \", StyleAttributeMap.EMPTY);\n+ *   textArea.appendText(\"monospaced.\\n\", mono);\n+ * }<\/pre>\n+ * Which results in the following visual representation:\n+ * <p>\n+ * <img src=\"doc-files\/RichTextArea.png\" alt=\"Image of the RichTextArea control\">\n+ * <\/p>\n+ * <p>\n+ * A view-only information control requires a different model.  The following example illustrates how to\n+ * create a model that uses a style sheet for styling:\n+ * <pre>{@code\n+ *     SimpleViewOnlyStyledModel m = new SimpleViewOnlyStyledModel();\n+ *     \/\/ add text segment using CSS style name (requires a style sheet)\n+ *     m.addSegment(\"RichTextArea \", null, \"HEADER\");\n+ *     \/\/ add text segment using direct style\n+ *     m.addSegment(\"Demo\", \"-fx-font-size:200%;\", null);\n+ *     \/\/ newline\n+ *     m.nl();\n+ *\n+ *     RichTextArea textArea = new RichTextArea(m);\n+ * }<\/pre>\n+ *\n+ * <h2>Text Models<\/h2>\n+ * <p>\n+ * A number of standard models can be used with RichTextArea, each addressing a specific use case:\n+ * <\/p>\n+ * <table border=1>\n+ * <caption>Standard Models<\/caption>\n+ * <tr><th>Model Class<\/th><th>Description<\/th><\/tr>\n+ * <tr><td><pre>{@link StyledTextModel}<\/pre><\/td><td>Base class (abstract)<\/td><\/tr>\n+ * <tr><td><pre> ├─ {@link RichTextModel}<\/pre><\/td><td>Default model for RichTextArea<\/td><\/tr>\n+ * <tr><td><pre> ├─ {@link jfx.incubator.scene.control.richtext.model.BasicTextModel BasicTextModel}<\/pre><\/td><td>Unstyled text model<\/td><\/tr>\n+ * <tr><td><pre> │   └─ {@link jfx.incubator.scene.control.richtext.model.CodeTextModel CodeTextModel}<\/pre><\/td><td>Default model for CodeArea<\/td><\/tr>\n+ * <tr><td><pre> └─ {@link jfx.incubator.scene.control.richtext.model.StyledTextModelViewOnlyBase StyledTextModelViewOnlyBase}<\/pre><\/td><td>Base class for a view-only model (abstract)<\/td><\/tr>\n+ * <tr><td><pre>     └─ {@link jfx.incubator.scene.control.richtext.model.SimpleViewOnlyStyledModel SimpleViewOnlyStyledModel}<\/pre><\/td><td>In-memory view-only styled model<\/td><\/tr>\n+ * <\/table>\n+ *\n+ * <h2>Selection<\/h2>\n+ * <p>\n+ * The RichTextArea control maintains a single {@link #selectionProperty() contiguous selection segment}\n+ * as a part of the {@link SelectionModel}.  Additionally,\n+ * {@link #anchorPositionProperty()} and {@link #caretPositionProperty()} read-only properties\n+ * are derived from the {@link #selectionProperty()} for convenience.\n+ *\n+ * <h2>Customizing<\/h2>\n+ * The RichTextArea control offers some degree of customization that does not require subclassing:\n+ * <ul>\n+ * <li>customizing key bindings with the {@link InputMap}\n+ * <li>setting {@link #leftDecoratorProperty() leftDecorator}\n+ * and {@link #rightDecoratorProperty() rightDecorator} properties\n+ * <\/ul>\n+ *\n+ * @author Andy Goryachev\n+ * @since 999 TODO\n+ *\/\n+public class RichTextArea extends Control {\n+    \/**\n+     * Function tags serve as identifiers of methods that can be customized via the {@code InputMap}.\n+     * <p>\n+     * Any method in RichTextArea referenced by one of these tags can be customized by providing\n+     * a different implementation using {@link InputMap#registerFunction(FunctionTag, FunctionHandler)}.\n+     * Additionally, a key binding can be customized (added, removed, or replaced) via\n+     * {@link InputMap#registerKey(jfx.incubator.scene.control.input.KeyBinding, FunctionTag)} or\n+     * {@link  InputMap#register(jfx.incubator.scene.control.input.KeyBinding, FunctionHandler)}.\n+     *\/\n+    public static class Tags {\n+        \/** Deletes the symbol before the caret. *\/\n+        public static final FunctionTag BACKSPACE = new FunctionTag();\n+        \/** Copies selected text to the clipboard. *\/\n+        public static final FunctionTag COPY = new FunctionTag();\n+        \/** Cuts selected text and places it to the clipboard. *\/\n+        public static final FunctionTag CUT = new FunctionTag();\n+        \/** Deletes symbol at the caret. *\/\n+        public static final FunctionTag DELETE = new FunctionTag();\n+        \/** Deletes paragraph at the caret, or selected paragraphs *\/\n+        public static final FunctionTag DELETE_PARAGRAPH = new FunctionTag();\n+        \/** Deletes text from the caret to paragraph start, ignoring selection. *\/\n+        public static final FunctionTag DELETE_PARAGRAPH_START = new FunctionTag();\n+        \/** Deletes empty paragraph or text to the end of the next word. *\/\n+        public static final FunctionTag DELETE_WORD_NEXT_END = new FunctionTag();\n+        \/** Deletes empty paragraph or text to the start of the next word. *\/\n+        public static final FunctionTag DELETE_WORD_NEXT_START = new FunctionTag();\n+        \/** Deletes (multiple) empty paragraphs or text to the beginning of the previous word. *\/\n+        public static final FunctionTag DELETE_WORD_PREVIOUS = new FunctionTag();\n+        \/** Clears any existing selection by moving anchor to the caret position *\/\n+        public static final FunctionTag DESELECT = new FunctionTag();\n+        \/** Focus the next focusable node *\/\n+        public static final FunctionTag FOCUS_NEXT = new FunctionTag();\n+        \/** Focus the previous focusable node *\/\n+        public static final FunctionTag FOCUS_PREVIOUS = new FunctionTag();\n+        \/** Inserts a line break at the caret. *\/\n+        public static final FunctionTag INSERT_LINE_BREAK = new FunctionTag();\n+        \/** Moves the caret one visual line down. *\/\n+        public static final FunctionTag MOVE_DOWN = new FunctionTag();\n+        \/** Moves the caret one symbol to the left. *\/\n+        public static final FunctionTag MOVE_LEFT = new FunctionTag();\n+        \/** Moves the caret to the end of the current paragraph, or, if already there, to the end of the next paragraph. *\/\n+        public static final FunctionTag MOVE_PARAGRAPH_DOWN = new FunctionTag();\n+        \/** Moves the caret to the start of the current paragraph, or, if already there, to the start of the previous paragraph. *\/\n+        public static final FunctionTag MOVE_PARAGRAPH_UP = new FunctionTag();\n+        \/** Moves the caret one symbol to the right. *\/\n+        public static final FunctionTag MOVE_RIGHT = new FunctionTag();\n+        \/** Moves the caret to after the last character of the text. *\/\n+        public static final FunctionTag MOVE_TO_DOCUMENT_END = new FunctionTag();\n+        \/** Moves the caret to before the first character of the text. *\/\n+        public static final FunctionTag MOVE_TO_DOCUMENT_START = new FunctionTag();\n+        \/** Moves the caret to the end of the paragraph at caret. *\/\n+        public static final FunctionTag MOVE_TO_PARAGRAPH_END = new FunctionTag();\n+        \/** Moves the caret to the beginning of the paragraph at caret. *\/\n+        public static final FunctionTag MOVE_TO_PARAGRAPH_START = new FunctionTag();\n+        \/** Moves the caret one visual text line up. *\/\n+        public static final FunctionTag MOVE_UP = new FunctionTag();\n+        \/** Moves the caret one word left (previous word if LTR, next word if RTL). *\/\n+        public static final FunctionTag MOVE_WORD_LEFT = new FunctionTag();\n+        \/** Moves the caret to the start of the next word, or next paragraph if at the start of an empty paragraph. *\/\n+        public static final FunctionTag MOVE_WORD_NEXT_START = new FunctionTag();\n+        \/** Moves the caret to the end of the next word. *\/\n+        public static final FunctionTag MOVE_WORD_NEXT_END = new FunctionTag();\n+        \/** Moves the caret to the beginning of previous word. *\/\n+        public static final FunctionTag MOVE_WORD_PREVIOUS = new FunctionTag();\n+        \/** Moves the caret one word right (next word if LTR, previous word if RTL). *\/\n+        public static final FunctionTag MOVE_WORD_RIGHT = new FunctionTag();\n+        \/** Moves the caret one visual page down. *\/\n+        public static final FunctionTag PAGE_DOWN = new FunctionTag();\n+        \/** Moves the caret one visual page up. *\/\n+        public static final FunctionTag PAGE_UP = new FunctionTag();\n+        \/** Pastes the clipboard content. *\/\n+        public static final FunctionTag PASTE = new FunctionTag();\n+        \/** Pastes the plain text clipboard content. *\/\n+        public static final FunctionTag PASTE_PLAIN_TEXT = new FunctionTag();\n+        \/** If possible, redoes the last undone modification. *\/\n+        public static final FunctionTag REDO = new FunctionTag();\n+        \/** Selects all text in the document. *\/\n+        public static final FunctionTag SELECT_ALL = new FunctionTag();\n+        \/** Extends selection one visual text line down. *\/\n+        public static final FunctionTag SELECT_DOWN = new FunctionTag();\n+        \/** Extends selection one symbol to the left. *\/\n+        public static final FunctionTag SELECT_LEFT = new FunctionTag();\n+        \/** Extends selection one visible page down. *\/\n+        public static final FunctionTag SELECT_PAGE_DOWN = new FunctionTag();\n+        \/** Extends selection one visible page up. *\/\n+        public static final FunctionTag SELECT_PAGE_UP = new FunctionTag();\n+        \/** Selects the current paragraph. *\/\n+        public static final FunctionTag SELECT_PARAGRAPH = new FunctionTag();\n+        \/** Extends selection to the end of the current paragraph, or, if already there, to the end of the next paragraph. *\/\n+        public static final FunctionTag SELECT_PARAGRAPH_DOWN = new FunctionTag();\n+        \/** Extends selection to the paragraph end. *\/\n+        public static final FunctionTag SELECT_PARAGRAPH_END = new FunctionTag();\n+        \/** Extends selection to the paragraph start. *\/\n+        public static final FunctionTag SELECT_PARAGRAPH_START = new FunctionTag();\n+        \/** Extends selection to the start of the current paragraph, or, if already there, to the start of the previous paragraph. *\/\n+        public static final FunctionTag SELECT_PARAGRAPH_UP = new FunctionTag();\n+        \/** Extends selection one symbol to the right. *\/\n+        public static final FunctionTag SELECT_RIGHT = new FunctionTag();\n+        \/** Extends selection to the end of the document. *\/\n+        public static final FunctionTag SELECT_TO_DOCUMENT_END = new FunctionTag();\n+        \/** Extends selection to the start of the document. *\/\n+        public static final FunctionTag SELECT_TO_DOCUMENT_START = new FunctionTag();\n+        \/** Extends selection one visual text line up. *\/\n+        public static final FunctionTag SELECT_UP = new FunctionTag();\n+        \/** Selects a word at the caret position. *\/\n+        public static final FunctionTag SELECT_WORD = new FunctionTag();\n+        \/** Extends selection to the previous word (LTR) or next word (RTL). *\/\n+        public static final FunctionTag SELECT_WORD_LEFT = new FunctionTag();\n+        \/** Extends selection to the beginning of next word. *\/\n+        public static final FunctionTag SELECT_WORD_NEXT = new FunctionTag();\n+        \/** Extends selection to the end of next word. *\/\n+        public static final FunctionTag SELECT_WORD_NEXT_END = new FunctionTag();\n+        \/** Extends selection to the previous word. *\/\n+        public static final FunctionTag SELECT_WORD_PREVIOUS = new FunctionTag();\n+        \/** Extends selection to the next word (LTR) or previous word (RTL). *\/\n+        public static final FunctionTag SELECT_WORD_RIGHT = new FunctionTag();\n+        \/** Inserts a tab symbol at the caret (editable), or transfer focus to the next focusable node. *\/\n+        public static final FunctionTag INSERT_TAB = new FunctionTag();\n+        \/** If possible, undoes the last modification. *\/\n+        public static final FunctionTag UNDO = new FunctionTag();\n+\n+        private Tags() { }\n+    }\n+\n+    private SimpleObjectProperty<StyledTextModel> model;\n+    private final SelectionModel selectionModel = new SingleSelectionModel();\n+    private SimpleBooleanProperty editableProperty;\n+    private SimpleObjectProperty<SideDecorator> leftDecorator;\n+    private SimpleObjectProperty<SideDecorator> rightDecorator;\n+    private ReadOnlyBooleanWrapper undoable;\n+    private ReadOnlyBooleanWrapper redoable;\n+    \/\/ styleables\n+    private SimpleStyleableObjectProperty<Duration> caretBlinkPeriod;\n+    private SimpleStyleableObjectProperty<Insets> contentPadding;\n+    private StyleableBooleanProperty displayCaret;\n+    private StyleableBooleanProperty highlightCurrentParagraph;\n+    private StyleableBooleanProperty useContentHeight;\n+    private StyleableBooleanProperty useContentWidth;\n+    private StyleableBooleanProperty wrapText;\n+    private RTAccessibilityHelper accessibilityHelper;\n+    \/\/ will be moved to Control JDK-8314968\n+    private final InputMap inputMap = new InputMap(this);\n+\n+    \/** The style handler registry instance, made available for use by subclasses to add support for new style attributes. *\/\n+    protected static final StyleHandlerRegistry styleHandlerRegistry = initStyleHandlerRegistry();\n+\n+    \/**\n+     * Creates the instance with the in-memory model {@link RichTextModel}.\n+     *\/\n+    public RichTextArea() {\n+        this(new RichTextModel());\n+    }\n+\n+    \/**\n+     * Creates the instance using the specified model.\n+     * <p>\n+     * Multiple RichTextArea instances can work off a single model.\n+     *\n+     * @param model the model\n+     *\/\n+    public RichTextArea(StyledTextModel model) {\n+        setFocusTraversable(true);\n+        getStyleClass().add(\"rich-text-area\");\n+        setAccessibleRole(AccessibleRole.TEXT_AREA);\n+        setAccessibleRoleDescription(\"Rich Text Area\");\n+\n+        selectionModel.selectionProperty().addListener((s, old, cur) -> {\n+            TextPos min0 = old == null ? null : old.getMin();\n+            TextPos max0 = old == null ? null : old.getMax();\n+            TextPos min2 = cur == null ? null : cur.getMin();\n+            TextPos max2 = cur == null ? null : cur.getMax();\n+\n+            if (accessibilityHelper != null) {\n+                if (accessibilityHelper.handleSelectionChange(cur)) {\n+                    notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);\n+                }\n+            }\n+\n+            if (!Objects.equals(min0, min2)) {\n+                notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);\n+            }\n+\n+            if (!Objects.equals(max0, max2)) {\n+                notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_END);\n+            }\n+        });\n+\n+        setModel(model);\n+    }\n+\n+    \/\/ Properties\n+\n+    \/**\n+     * Tracks the selection anchor position within the document.  This read-only property is derived from\n+     * {@link #selectionProperty() selection} property.  The value can be null.\n+     * <p>\n+     * Setting a {@link SelectionSegment} causes an update to both the anchor and the caret positions.\n+     * A null selection segment results in both positions to become null, a non-null selection segment sets both to\n+     * non-null values.\n+     * <p>\n+     * Note:\n+     * {@code StyledTextModel.selectionProperty()}, {@link #anchorPositionProperty()}, and {@link #caretPositionProperty()}\n+     * are logically connected.  When a change occurs, the anchor position is updated first, followed by\n+     * the caret position, followed by the selection segment.\n+     *\n+     * @return the anchor position property\n+     * @see selectionProperty\n+     * @see caretPositionProperty\n+     * @defaultValue null\n+     *\/\n+    public final ReadOnlyProperty<TextPos> anchorPositionProperty() {\n+        return selectionModel.anchorPositionProperty();\n+    }\n+\n+    public final TextPos getAnchorPosition() {\n+        return anchorPositionProperty().getValue();\n+    }\n+\n+    \/**\n+     * Determines the caret blink period.  This property cannot be set to {@code null}.\n+     * <p>\n+     * This is a {@link StyleableProperty} with the name {@code -fx-caret-blink-period}.\n+     * <p>\n+     * alternative:<br>\n+     * This property can be styled with CSS using {@code -fx-caret-blink-period} name.\n+     * @implNote The property object implements {@link StyleableProperty} interface.\n+     *\n+     * @return the caret blink period property\n+     * @defaultValue 1000 ms\n+     *\/\n+    public final ObjectProperty<Duration> caretBlinkPeriodProperty() {\n+        if (caretBlinkPeriod == null) {\n+            caretBlinkPeriod = new SimpleStyleableObjectProperty<>(\n+                StyleableProperties.CARET_BLINK_PERIOD,\n+                this,\n+                \"caretBlinkPeriod\",\n+                Params.DEFAULT_CARET_BLINK_PERIOD\n+            ) {\n+                private Duration old;\n+\n+                @Override\n+                public void invalidated() {\n+                    final Duration v = get();\n+                    if (v == null) {\n+                        set(old);\n+                        throw new NullPointerException(\"cannot set caretBlinkPeriodProperty to null\");\n+                    }\n+                    old = v;\n+                }\n+            };\n+        }\n+        return caretBlinkPeriod;\n+    }\n+\n+    public final void setCaretBlinkPeriod(Duration period) {\n+        caretBlinkPeriodProperty().set(period);\n+    }\n+\n+    public final Duration getCaretBlinkPeriod() {\n+        return caretBlinkPeriod == null ? Params.DEFAULT_CARET_BLINK_PERIOD : caretBlinkPeriod.get();\n+    }\n+\n+    \/**\n+     * Tracks the caret position within the document.  This read-only property is derived from\n+     * {@link #selectionProperty() selection} property.  The value can be null.\n+     * <p>\n+     * Setting a {@link SelectionSegment} causes an update to both the anchor and the caret positions.\n+     * A null selection segment results in both positions to become null, a non-null selection segment sets both to\n+     * non-null values.\n+     * <p>\n+     * Note:\n+     * {@code StyledTextModel.selectionProperty()}, {@link #anchorPositionProperty()}, and {@link #caretPositionProperty()}\n+     * are logically connected.  When a change occurs, the anchor position is updated first, followed by\n+     * the caret position, followed by the selection segment.\n+     *\n+     * @return the caret position property\n+     * @see selectionProperty\n+     * @see anchorPositionProperty\n+     * @defaultValue null\n+     *\/\n+    public final ReadOnlyProperty<TextPos> caretPositionProperty() {\n+        return selectionModel.caretPositionProperty();\n+    }\n+\n+    public final TextPos getCaretPosition() {\n+        return caretPositionProperty().getValue();\n+    }\n+\n+    \/**\n+     * Specifies the padding for the RichTextArea content.\n+     * The content padding value can be null, which is treated as no padding.\n+     * <p>\n+     * This property can be styled with CSS using {@code -fx-content-padding} name.\n+     * @implNote The property object implements {@link StyleableProperty} interface.\n+     *\n+     * @return the content padding property\n+     * @defaultValue null\n+     *\/\n+    public final ObjectProperty<Insets> contentPaddingProperty() {\n+        if (contentPadding == null) {\n+            contentPadding = new SimpleStyleableObjectProperty<Insets>(\n+                StyleableProperties.CONTENT_PADDING,\n+                this,\n+                \"contentPadding\"\n+            );\n+        }\n+        return contentPadding;\n+    }\n+\n+    public final void setContentPadding(Insets value) {\n+        contentPaddingProperty().set(value);\n+    }\n+\n+    public final Insets getContentPadding() {\n+        return contentPadding == null ? null : contentPadding.get();\n+    }\n+\n+    \/**\n+     * This property controls whether caret will be displayed or not.\n+     * <p>\n+     * This property can be styled with CSS using {@code -fx-display-caret} name.\n+     * @implNote The property object implements {@link StyleableProperty} interface.\n+     *\n+     * @return the display caret property\n+     * @defaultValue true\n+     *\/\n+    public final BooleanProperty displayCaretProperty() {\n+        if (displayCaret == null) {\n+            displayCaret = new StyleableBooleanProperty(Params.DEFAULT_DISPLAY_CARET) {\n+                @Override\n+                public Object getBean() {\n+                    return RichTextArea.this;\n+                }\n+\n+                @Override\n+                public String getName() {\n+                    return \"displayCaret\";\n+                }\n+\n+                @Override\n+                public CssMetaData<RichTextArea, Boolean> getCssMetaData() {\n+                    return StyleableProperties.DISPLAY_CARET;\n+                }\n+            };\n+        }\n+        return displayCaret;\n+    }\n+\n+    public final void setDisplayCaret(boolean on) {\n+        displayCaretProperty().set(on);\n+    }\n+\n+    public final boolean isDisplayCaret() {\n+        return displayCaret == null ? Params.DEFAULT_DISPLAY_CARET : displayCaret.get();\n+    }\n+\n+    \/**\n+     * Indicates whether this RichTextArea can be edited by the user, provided the model is also editable.\n+     * Changing the value of this property with a view-only model or a null model has no effect.\n+     *\n+     * @return the editable property\n+     * @see canEdit() method\n+     * @defaultValue true\n+     *\/\n+    public final BooleanProperty editableProperty() {\n+        if (editableProperty == null) {\n+            editableProperty = new SimpleBooleanProperty(this, \"editable\", true);\n+        }\n+        return editableProperty;\n+    }\n+\n+    public final boolean isEditable() {\n+        if (editableProperty == null) {\n+            return true;\n+        }\n+        return editableProperty().get();\n+    }\n+\n+    public final void setEditable(boolean on) {\n+        editableProperty().set(on);\n+    }\n+\n+    \/**\n+     * Indicates whether the current paragraph will be visually highlighted.\n+     * <p>\n+     * This property can be styled with CSS using {@code -fx-highlight-current-paragraph} name.\n+     * @implNote The property object implements {@link StyleableProperty} interface.\n+     *\n+     * @return the highlight current paragraph property\n+     * @defaultValue false\n+     *\/\n+    public final BooleanProperty highlightCurrentParagraphProperty() {\n+        if (highlightCurrentParagraph == null) {\n+            highlightCurrentParagraph = new StyleableBooleanProperty(Params.DEFAULT_HIGHLIGHT_CURRENT_PARAGRAPH) {\n+                @Override\n+                public Object getBean() {\n+                    return RichTextArea.this;\n+                }\n+\n+                @Override\n+                public String getName() {\n+                    return \"highlightCurrentParagraph\";\n+                }\n+\n+                @Override\n+                public CssMetaData<RichTextArea, Boolean> getCssMetaData() {\n+                    return StyleableProperties.HIGHLIGHT_CURRENT_PARAGRAPH;\n+                }\n+            };\n+        }\n+        return highlightCurrentParagraph;\n+    }\n+\n+    public final boolean isHighlightCurrentParagraph() {\n+        return highlightCurrentParagraph == null ? Params.DEFAULT_HIGHLIGHT_CURRENT_PARAGRAPH : highlightCurrentParagraph.get();\n+    }\n+\n+    public final void setHighlightCurrentParagraph(boolean on) {\n+        highlightCurrentParagraphProperty().set(on);\n+    }\n+\n+    \/**\n+     * Specifies the left-side paragraph decorator.\n+     * The value can be null.\n+     *\n+     * @return the left decorator property\n+     * @defaultValue null\n+     *\/\n+    public final ObjectProperty<SideDecorator> leftDecoratorProperty() {\n+        if (leftDecorator == null) {\n+            leftDecorator = new SimpleObjectProperty<>(this, \"leftDecorator\");\n+        }\n+        return leftDecorator;\n+    }\n+\n+    public final SideDecorator getLeftDecorator() {\n+        if (leftDecorator == null) {\n+            return null;\n+        }\n+        return leftDecorator.get();\n+    }\n+\n+    public final void setLeftDecorator(SideDecorator d) {\n+        leftDecoratorProperty().set(d);\n+    }\n+\n+    \/**\n+     * Determines the {@link StyledTextModel} to use with this RichTextArea.\n+     * The model can be null, which results in an empty, uneditable control.\n+     * <p>\n+     * Note: Subclasses may impose additional restrictions on the type of the model they require.\n+     *\n+     * @return the model property\n+     * @defaultValue an instance of {@link RichTextModel}\n+     *\/\n+    public final ObjectProperty<StyledTextModel> modelProperty() {\n+        if (model == null) {\n+            model = new SimpleObjectProperty<>(this, \"model\") {\n+                \/\/ TODO does this create a memory leak?  should we bind or weak listen?\n+                private final StyledTextModel.Listener li = (ch) -> {\n+                    if (ch.isEdit()) {\n+                        if (accessibilityHelper != null) {\n+                            if (accessibilityHelper.handleTextUpdate(ch.getStart(), ch.getEnd())) {\n+                                \/\/ TODO check the timing, may be runLater?\n+                                notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);\n+                            }\n+                        }\n+                    }\n+                };\n+                private StyledTextModel old;\n+\n+                @Override\n+                protected void invalidated() {\n+                    if (undoable != null) {\n+                        undoable.unbind();\n+                        StyledTextModel m = get();\n+                        if (m != null) {\n+                            undoable.bind(m.undoableProperty());\n+                        }\n+                    }\n+\n+                    if(redoable != null) {\n+                        redoable.unbind();\n+                        StyledTextModel m = get();\n+                        if (m != null) {\n+                            redoable.bind(m.redoableProperty());\n+                        }\n+                    }\n+\n+                    if (old != null) {\n+                        old.removeListener(li);\n+                    }\n+                    StyledTextModel m = get();\n+                    if (m != null) {\n+                        m.addListener(li);\n+                    }\n+                    old = m;\n+\n+                    if (accessibilityHelper != null) {\n+                        accessibilityHelper.handleModelChange();\n+                    }\n+                    selectionModel.clear();\n+                    notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);\n+                }\n+            };\n+        }\n+        return model;\n+    }\n+\n+    public final void setModel(StyledTextModel m) {\n+        modelProperty().set(m);\n+    }\n+\n+    public final StyledTextModel getModel() {\n+        return model == null ? null : model.get();\n+    }\n+\n+    \/**\n+     * The property describes if it's currently possible to redo the latest change of the content that was undone.\n+     *\n+     * @return the read-only property\n+     * @defaultValue false\n+     *\/\n+    public final ReadOnlyBooleanProperty redoableProperty() {\n+        if (redoable == null) {\n+            redoable = new ReadOnlyBooleanWrapper(this, \"redoable\", false);\n+            StyledTextModel m = getModel();\n+            if (m != null) {\n+                redoable.bind(m.redoableProperty());\n+            }\n+        }\n+        return redoable.getReadOnlyProperty();\n+    }\n+\n+    public final boolean isRedoable() {\n+        return redoableProperty().get();\n+    }\n+\n+    \/**\n+     * Specifies the right-side paragraph decorator.\n+     * The value can be null.\n+     *\n+     * @return the right decorator property\n+     * @defaultValue null\n+     *\/\n+    public final ObjectProperty<SideDecorator> rightDecoratorProperty() {\n+        if (rightDecorator == null) {\n+            rightDecorator = new SimpleObjectProperty<>(this, \"rightDecorator\");\n+        }\n+        return rightDecorator;\n+    }\n+\n+    public final SideDecorator getRightDecorator() {\n+        if (rightDecorator == null) {\n+            return null;\n+        }\n+        return rightDecorator.get();\n+    }\n+\n+    public final void setRightDecorator(SideDecorator d) {\n+        rightDecoratorProperty().set(d);\n+    }\n+\n+    \/**\n+     * Tracks the current selection.  The {@link SelectionSegment} consists of two values - the caret and the anchor\n+     * positions which may get changed independently.  This property allows for tracking the selection as an single\n+     * entity.  A null value for the selection segment causes both the caret and the anchor positions to become\n+     * null.\n+     * <p>\n+     * Note:\n+     * {@code StyledTextModel.selectionProperty()}, {@link #anchorPositionProperty()}, and {@link #caretPositionProperty()}\n+     * are logically connected.  When a change occurs, the anchor position is updated first, followed by\n+     * the caret position, followed by the selection segment.\n+     *\n+     * @return the selection property\n+     * @see anchorPositionProperty\n+     * @see caretPositionProperty\n+     * @defaultValue null\n+     *\/\n+    public final ReadOnlyProperty<SelectionSegment> selectionProperty() {\n+        return selectionModel.selectionProperty();\n+    }\n+\n+    public final SelectionSegment getSelection() {\n+        return selectionModel.getSelection();\n+    }\n+\n+    \/**\n+     * The property describes if it's currently possible to undo the latest change of the content that was done.\n+     *\n+     * @return the read-only property\n+     * @defaultValue false\n+     *\/\n+    public final ReadOnlyBooleanProperty undoableProperty() {\n+        if (undoable == null) {\n+            undoable = new ReadOnlyBooleanWrapper(this, \"undoable\", false);\n+            StyledTextModel m = getModel();\n+            if (m != null) {\n+                undoable.bind(m.undoableProperty());\n+            }\n+        }\n+        return undoable.getReadOnlyProperty();\n+    }\n+\n+    public final boolean isUndoable() {\n+        return undoableProperty().get();\n+    }\n+\n+    \/**\n+     * Determines whether the preferred height is the same as the content height.\n+     * When set to true, the vertical scroll bar is disabled.\n+     * <p>\n+     * This property can be styled with CSS using {@code -fx-use-content-height} name.\n+     * @implNote The property object implements {@link StyleableProperty} interface.\n+     *\n+     * @return the use content height property\n+     * @defaultValue false\n+     *\/\n+    public final BooleanProperty useContentHeightProperty() {\n+        if (useContentHeight == null) {\n+            useContentHeight = new StyleableBooleanProperty(Params.DEFAULT_USE_CONTENT_HEIGHT) {\n+                @Override\n+                public Object getBean() {\n+                    return RichTextArea.this;\n+                }\n+\n+                @Override\n+                public String getName() {\n+                    return \"useContentHeight\";\n+                }\n+\n+                @Override\n+                public CssMetaData<RichTextArea, Boolean> getCssMetaData() {\n+                    return StyleableProperties.USE_CONTENT_HEIGHT;\n+                }\n+            };\n+        }\n+        return useContentHeight;\n+    }\n+\n+    public final boolean isUseContentHeight() {\n+        return useContentHeight == null ? Params.DEFAULT_USE_CONTENT_HEIGHT : useContentHeight.get();\n+    }\n+\n+    public final void setUseContentHeight(boolean on) {\n+        useContentHeightProperty().set(true);\n+    }\n+\n+    \/**\n+     * Determines whether the preferred width is the same as the content width.\n+     * When set to true, the horizontal scroll bar is disabled.\n+     * <p>\n+     * This property can be styled with CSS using {@code -fx-use-content-width} name.\n+     * @implNote The property object implements {@link StyleableProperty} interface.\n+     *\n+     * @return the use content width property\n+     * @defaultValue false\n+     *\/\n+    public final BooleanProperty useContentWidthProperty() {\n+        if (useContentWidth == null) {\n+            useContentWidth = new StyleableBooleanProperty(Params.DEFAULT_USE_CONTENT_WIDTH) {\n+                @Override\n+                public Object getBean() {\n+                    return RichTextArea.this;\n+                }\n+\n+                @Override\n+                public String getName() {\n+                    return \"useContentWidth\";\n+                }\n+\n+                @Override\n+                public CssMetaData<RichTextArea, Boolean> getCssMetaData() {\n+                    return StyleableProperties.USE_CONTENT_WIDTH;\n+                }\n+            };\n+        }\n+        return useContentWidth;\n+    }\n+\n+    public final boolean isUseContentWidth() {\n+        return useContentWidth == null ? Params.DEFAULT_USE_CONTENT_WIDTH : useContentWidth.get();\n+    }\n+\n+    public final void setUseContentWidth(boolean on) {\n+        useContentWidthProperty().set(true);\n+    }\n+\n+    \/**\n+     * Indicates whether text should be wrapped in this RichTextArea.\n+     * If a run of text exceeds the width of the {@code RichTextArea},\n+     * then this variable indicates whether the text should wrap onto\n+     * another line.\n+     * Setting this property to {@code true} hides the horizontal scroll bar.\n+     * <p>\n+     * This property can be styled with CSS using {@code -fx-wrap-text} name.\n+     * @implNote The property object implements {@link StyleableProperty} interface.\n+     *\n+     * @return the wrap text property\n+     * @defaultValue false\n+     *\/\n+    public final BooleanProperty wrapTextProperty() {\n+        if (wrapText == null) {\n+            wrapText = new StyleableBooleanProperty(Params.DEFAULT_WRAP_TEXT) {\n+                @Override\n+                public Object getBean() {\n+                    return RichTextArea.this;\n+                }\n+\n+                @Override\n+                public String getName() {\n+                    return \"wrapText\";\n+                }\n+\n+                @Override\n+                public CssMetaData<RichTextArea, Boolean> getCssMetaData() {\n+                    return StyleableProperties.WRAP_TEXT;\n+                }\n+            };\n+        }\n+        return wrapText;\n+    }\n+\n+    public final boolean isWrapText() {\n+        return wrapText == null ? Params.DEFAULT_WRAP_TEXT : wrapText.getValue();\n+    }\n+\n+    public final void setWrapText(boolean value) {\n+        wrapTextProperty().setValue(value);\n+    }\n+\n+    \/\/ Styleable Properties\n+\n+    \/** Defines styleable properties at the class level *\/\n+    private static class StyleableProperties {\n+        private static final CssMetaData<RichTextArea, Duration> CARET_BLINK_PERIOD =\n+            new CssMetaData<>(\"-fx-caret-blink-period\", DurationConverter.getInstance())\n+        {\n+            @Override\n+            public boolean isSettable(RichTextArea t) {\n+                return t.caretBlinkPeriod == null || !t.caretBlinkPeriod.isBound();\n+            }\n+\n+            @Override\n+            public StyleableProperty<Duration> getStyleableProperty(RichTextArea t) {\n+                return (StyleableProperty<Duration>)t.caretBlinkPeriodProperty();\n+            }\n+        };\n+\n+        private static final CssMetaData<RichTextArea, Insets> CONTENT_PADDING =\n+            new CssMetaData<>(\"-fx-content-padding\", InsetsConverter.getInstance())\n+        {\n+            @Override\n+            public boolean isSettable(RichTextArea t) {\n+                return t.contentPadding == null || !t.contentPadding.isBound();\n+            }\n+\n+            @Override\n+            public StyleableProperty<Insets> getStyleableProperty(RichTextArea t) {\n+                return (StyleableProperty<Insets>)t.contentPaddingProperty();\n+            }\n+        };\n+\n+        private static final CssMetaData<RichTextArea,Boolean> DISPLAY_CARET =\n+            new CssMetaData<>(\"-fx-display-caret\", StyleConverter.getBooleanConverter(), Params.DEFAULT_DISPLAY_CARET)\n+        {\n+            @Override\n+            public boolean isSettable(RichTextArea t) {\n+                return t.displayCaret == null || !t.displayCaret.isBound();\n+            }\n+\n+            @Override\n+            public StyleableProperty<Boolean> getStyleableProperty(RichTextArea t) {\n+                return (StyleableProperty<Boolean>)t.displayCaretProperty();\n+            }\n+        };\n+\n+        private static final CssMetaData<RichTextArea,Boolean> HIGHLIGHT_CURRENT_PARAGRAPH =\n+            new CssMetaData<>(\"-fx-highlight-current-paragraph\", StyleConverter.getBooleanConverter(), Params.DEFAULT_HIGHLIGHT_CURRENT_PARAGRAPH)\n+        {\n+            @Override\n+            public boolean isSettable(RichTextArea t) {\n+                return t.highlightCurrentParagraph == null || !t.highlightCurrentParagraph.isBound();\n+            }\n+\n+            @Override\n+            public StyleableProperty<Boolean> getStyleableProperty(RichTextArea t) {\n+                return (StyleableProperty<Boolean>)t.highlightCurrentParagraphProperty();\n+            }\n+        };\n+\n+        private static final CssMetaData<RichTextArea,Boolean> USE_CONTENT_HEIGHT =\n+            new CssMetaData<>(\"-fx-use-content-height\", StyleConverter.getBooleanConverter(), Params.DEFAULT_USE_CONTENT_HEIGHT)\n+        {\n+            @Override\n+            public boolean isSettable(RichTextArea t) {\n+                return t.useContentHeight == null || !t.useContentHeight.isBound();\n+            }\n+\n+            @Override\n+            public StyleableProperty<Boolean> getStyleableProperty(RichTextArea t) {\n+                return (StyleableProperty<Boolean>)t.useContentHeightProperty();\n+            }\n+        };\n+\n+        private static final CssMetaData<RichTextArea,Boolean> USE_CONTENT_WIDTH =\n+            new CssMetaData<>(\"-fx-use-content-width\", StyleConverter.getBooleanConverter(), Params.DEFAULT_USE_CONTENT_WIDTH)\n+        {\n+            @Override\n+            public boolean isSettable(RichTextArea t) {\n+                return t.useContentWidth == null || !t.useContentWidth.isBound();\n+            }\n+\n+            @Override\n+            public StyleableProperty<Boolean> getStyleableProperty(RichTextArea t) {\n+                return (StyleableProperty<Boolean>)t.useContentWidthProperty();\n+            }\n+        };\n+\n+        private static final CssMetaData<RichTextArea,Boolean> WRAP_TEXT =\n+            new CssMetaData<>(\"-fx-wrap-text\", StyleConverter.getBooleanConverter(), Params.DEFAULT_WRAP_TEXT)\n+        {\n+            @Override\n+            public boolean isSettable(RichTextArea t) {\n+                return t.wrapText == null || !t.wrapText.isBound();\n+            }\n+\n+            @Override\n+            public StyleableProperty<Boolean> getStyleableProperty(RichTextArea t) {\n+                return (StyleableProperty<Boolean>)t.wrapTextProperty();\n+            }\n+        };\n+\n+        private static final List<CssMetaData<? extends Styleable, ?>> STYLEABLES = RichUtils.combine(\n+            Control.getClassCssMetaData(),\n+            CARET_BLINK_PERIOD,\n+            CONTENT_PADDING,\n+            DISPLAY_CARET,\n+            HIGHLIGHT_CURRENT_PARAGRAPH,\n+            USE_CONTENT_HEIGHT,\n+            USE_CONTENT_WIDTH,\n+            WRAP_TEXT\n+        );\n+    }\n+\n+    \/**\n+     * Gets the {@code CssMetaData} associated with this class, which may include the\n+     * {@code CssMetaData} of its superclasses.\n+     * @return the {@code CssMetaData}\n+     *\/\n+    public static List<CssMetaData<? extends Styleable, ?>> getClassCssMetaData() {\n+        return StyleableProperties.STYLEABLES;\n+    }\n+\n+    @Override\n+    public List<CssMetaData<? extends Styleable, ?>> getControlCssMetaData() {\n+        return getClassCssMetaData();\n+    }\n+\n+    \/\/ Public Methods\n+\n+    \/**\n+     * Appends the styled text to the end of the document.  Any embedded {@code \"\\n\"} or {@code \"\\r\\n\"}\n+     * sequences result in a new paragraph being added.\n+     * <p>\n+     * This method is no-op if either the control or the model is not editable.  It is up to the model\n+     * to select whether to accept all, some, or none of the\n+     * {@link jfx.incubator.scene.control.richtext.model.StyleAttribute StyleAttribute}s.\n+     *\n+     * @param text the text to append\n+     * @param attrs the style attributes\n+     * @return the text position at the end of the appended text, or null if editing is disabled\n+     *\/\n+    public final TextPos appendText(String text, StyleAttributeMap attrs) {\n+        TextPos p = getDocumentEnd();\n+        return insertText(p, text, attrs);\n+    }\n+\n+    \/**\n+     * Appends the styled content to the end of the document.  Any embedded {@code \"\\n\"} or {@code \"\\r\\n\"}\n+     * sequences result in a new paragraph being added.\n+     * This method is no-op if either the control or the model is not editable.\n+     *\n+     * @param in the input stream\n+     * @return the text position at the end of the appended text, or null if editing is disabled\n+     *\/\n+    public final TextPos appendText(StyledInput in) {\n+        TextPos p = getDocumentEnd();\n+        return insertText(p, in);\n+    }\n+\n+    \/**\n+     * Applies the specified style to the selected range.  The specified attributes will be merged, overriding\n+     * the existing ones.\n+     * When applying paragraph attributes, the affected range might extend beyond {@code start} and {@code end}\n+     * to include whole paragraphs.\n+     *\n+     * @param start the start of text range\n+     * @param end the end of text range\n+     * @param attrs the style attributes to apply\n+     *\/\n+    public void applyStyle(TextPos start, TextPos end, StyleAttributeMap attrs) {\n+        if (canEdit()) {\n+            StyledTextModel m = getModel();\n+            m.applyStyle(start, end, attrs, true);\n+        }\n+    }\n+\n+    \/**\n+     * When selection exists, deletes selected text.  Otherwise, deletes the character preceding the caret,\n+     * possibly breaking up the grapheme clusters.\n+     * This method does nothing if {@link #canEdit()} returns false, or the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     *\n+     * @see RichTextArea.Tags#BACKSPACE\n+     *\/\n+    public void backspace() {\n+        execute(Tags.BACKSPACE);\n+    }\n+\n+    \/**\n+     * This convenience method returns true if all the following conditions are true:\n+     * <ul>\n+     * <li>this control's {@link #isEditable()} returns true<\/li>\n+     * <li>the model is not {@code null}<\/li>\n+     * <li>the model's {@link StyledTextModel#isUserEditable()} returns true<\/li>\n+     * <\/ul>\n+     *\n+     * @return true if the editing is allowed\n+     *\/\n+    public final boolean canEdit() {\n+        if (isEditable()) {\n+            StyledTextModel m = getModel();\n+            if (m != null) {\n+                return m.isUserEditable();\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Clears the document, creating an undo entry.\n+     * This method does nothing if {@link #canEdit()} returns false.\n+     *\/\n+    public final void clear() {\n+        TextPos end = getDocumentEnd();\n+        replaceText(TextPos.ZERO, end, StyledInput.EMPTY, true);\n+    }\n+\n+    \/**\n+     * Clears existing selection, if any.  This method is an alias for {@code getSelectionModel().clear()}.\n+     *\/\n+    public final void clearSelection() {\n+        selectionModel.clear();\n+    }\n+\n+    \/**\n+     * Clears the undo-redo stack of the underlying model.\n+     * This method does nothing if the model is null.\n+     *\/\n+    public final void clearUndoRedo() {\n+        StyledTextModel m = getModel();\n+        if (m != null) {\n+            m.clearUndoRedo();\n+        }\n+    }\n+\n+    \/**\n+     * When selection exists, copies the selected rich text to the clipboard in all the formats supported\n+     * by the model.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#COPY\n+     *\/\n+    public void copy() {\n+        execute(Tags.COPY);\n+    }\n+\n+    \/**\n+     * Copies the selected text in the specified format to the clipboard.\n+     * This method does nothing if no selection exists or when the data format is not supported by the model.\n+     *\n+     * @param format the data format to use\n+     *\/\n+    public final void copy(DataFormat format) {\n+        RichTextAreaSkin skin = richTextAreaSkin();\n+        if (skin != null) {\n+            skin.copyText(format);\n+        }\n+    }\n+\n+    \/**\n+     * Transfers the currently selected text to the clipboard,\n+     * removing the current selection.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false, or the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#CUT\n+     *\/\n+    public void cut() {\n+        execute(Tags.CUT);\n+    }\n+\n+    \/**\n+     * When selection exists, deletes selected text.  Otherwise, deletes the symbol at the caret.\n+     * When the symbol at the caret is a grapheme cluster, deletes the whole cluster.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false, or the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#DELETE\n+     *\/\n+    public void delete() {\n+        execute(Tags.DELETE);\n+    }\n+\n+    \/**\n+     * When selection exists, deletes selected paragraphs.  Otherwise, deletes the paragraph at the caret.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false, or the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#DELETE_PARAGRAPH\n+     *\/\n+    public void deleteParagraph() {\n+        execute(Tags.DELETE_PARAGRAPH);\n+    }\n+\n+    \/**\n+     * Deletes text from the caret position to the start of the paragraph, ignoring existing selection.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false, or the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#DELETE_PARAGRAPH_START\n+     *\/\n+    public void deleteParagraphStart() {\n+        execute(Tags.DELETE_PARAGRAPH_START);\n+    }\n+\n+    \/**\n+     * Deletes from the caret positon to the end of next word, ignoring existing selection.\n+     * When the caret is in an empty paragraph, deletes the paragraph.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false, or the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#DELETE_WORD_NEXT_END\n+     *\/\n+    public void deleteWordNextEnd() {\n+        execute(Tags.DELETE_WORD_NEXT_END);\n+    }\n+\n+    \/**\n+     * Deletes from the caret positon to the start of next word, ignoring existing selection.\n+     * When the caret is in an empty paragraph, deletes the paragraph.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false, or the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#DELETE_WORD_NEXT_START\n+     *\/\n+    public void deleteWordNextStart() {\n+        execute(Tags.DELETE_WORD_NEXT_START);\n+    }\n+\n+    \/**\n+     * Deletes (multiple) empty paragraphs or text from the caret position to the start of the previous word,\n+     * ignoring existing selection.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false, or the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#DELETE_WORD_PREVIOUS\n+     *\/\n+    public void deleteWordPrevious() {\n+        execute(Tags.DELETE_WORD_PREVIOUS);\n+    }\n+\n+    \/**\n+     * Clears the selected text range by moving anchor to the caret position.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#DESELECT\n+     *\/\n+    public void deselect() {\n+        execute(Tags.DESELECT);\n+    }\n+\n+    \/**\n+     * Executes a function mapped to the specified function tag.\n+     * This method does nothing if no function is mapped to the tag, or the function has been unbound.\n+     *\n+     * @param tag the function tag\n+     *\/\n+    \/\/ TODO to be moved to Control JDK-8314968\n+    public final void execute(FunctionTag tag) {\n+        InputMapHelper.execute(this, getInputMap(), tag);\n+    }\n+\n+    \/**\n+     * Executes the default function mapped to the specified tag.\n+     * This method does nothing if no default mapping exists.\n+     *\n+     * @param tag the function tag\n+     *\/\n+    \/\/ TODO to be moved to Control JDK-8314968\n+    public final void executeDefault(FunctionTag tag) {\n+        InputMapHelper.executeDefault(this, getInputMap(), tag);\n+    }\n+\n+    \/**\n+     * Extends selection to the specified position.  Internally, this method will normalized the position\n+     * to be within the document boundaries.\n+     * Calling this method produces the same result as {@code select(pos, pos)} if no prior selection exists.\n+     * This method does nothing if the model is null.\n+     *\n+     * @param pos the text position\n+     *\/\n+    public final void extendSelection(TextPos pos) {\n+        StyledTextModel m = getModel();\n+        if (m != null) {\n+            selectionModel.extendSelection(m, pos);\n+        }\n+    }\n+\n+    \/**\n+     * Returns {@code StyleAttributeMap} which contains character and paragraph attributes.\n+     * <p>\n+     * When selection exists, returns the attributes at the first selected character.\n+     * <p>\n+     * When no selection exists, returns the attributes at the character which immediately precedes the caret.\n+     * When at the beginning of the document, returns the attributes of the first character.\n+     * If the model uses CSS styles, this method resolves individual attributes (bold, font size, etc.)\n+     * for this instance of {@code RichTextArea}.\n+     *\n+     * @return the non-null {@code StyleAttributeMap} instance\n+     *\/\n+    public final StyleAttributeMap getActiveStyleAttributeMap() {\n+        StyleResolver r = resolver();\n+        return getModelStyleAttrs(r);\n+    }\n+\n+    \/**\n+     * Returns a TextPos corresponding to the end of the document.\n+     * When the model is null, returns {@link TextPos#ZERO}.\n+     *\n+     * @return the text position\n+     *\/\n+    public final TextPos getDocumentEnd() {\n+        StyledTextModel m = getModel();\n+        return (m == null) ? TextPos.ZERO : m.getDocumentEnd();\n+    }\n+\n+    \/**\n+     * Returns the input map instance.\n+     * @return the input map instance\n+     *\/\n+    \/\/ to be moved to Control JDK-8314968\n+    public final InputMap getInputMap() {\n+        return inputMap;\n+    }\n+\n+    \/**\n+     * Returns the number of paragraphs in the model.  This method returns 0 if the model is {@code null}.\n+     * @return the paragraph count\n+     *\/\n+    public final int getParagraphCount() {\n+        StyledTextModel m = getModel();\n+        return (m == null) ? 0 : m.size();\n+    }\n+\n+    \/**\n+     * Returns a TextPos corresponding to the end of paragraph.\n+     * When the model is null, returns {@link TextPos#ZERO}.\n+     *\n+     * @param index paragraph index\n+     * @return text position\n+     *\/\n+    public final TextPos getParagraphEnd(int index) {\n+        StyledTextModel m = getModel();\n+        return (m == null) ? TextPos.ZERO : m.getEndOfParagraphTextPos(index);\n+    }\n+\n+    \/**\n+     * Returns the plain text at the specified paragraph index.  The value of {@code index} must be between\n+     * 0 (inclusive) and the value returned by {@link #getParagraphCount()} (exclusive).\n+     *\n+     * @param index the paragraph index\n+     * @return the non-null plain text string\n+     * @throws IndexOutOfBoundsException if the index is outside of the range supported by the model\n+     *\/\n+    public final String getPlainText(int index) {\n+        if ((index < 0) || (index >= getParagraphCount())) {\n+            throw new IndexOutOfBoundsException(\"index=\" + index);\n+        }\n+        return getModel().getPlainText(index);\n+    }\n+\n+    \/**\n+     * Returns the style handler registry for this control.\n+     * Applications should not normally call this method as it is intended for use by the skin\n+     * subclasses.\n+     *\n+     * @return the style handler registry\n+     *\/\n+    public StyleHandlerRegistry getStyleHandlerRegistry() {\n+        return styleHandlerRegistry;\n+    }\n+\n+    \/**\n+     * Finds a text position corresponding to the specified screen coordinates.\n+     * This method returns {@code null} if the specified coordinates are outside of the content area.\n+     *\n+     * @param screenX the screen x coordinate\n+     * @param screenY the screen y coordinate\n+     * @return the text position, or null\n+     *\/\n+    public final TextPos getTextPosition(double screenX, double screenY) {\n+        Point2D local = vflow().getContentPane().screenToLocal(screenX, screenY);\n+        return vflow().getTextPosLocal(local.getX(), local.getY());\n+    }\n+\n+    \/**\n+     * This convenience method returns true when a non-empty selection exists.\n+     *\n+     * @return true when an non-empty selection exists\n+     *\/\n+    public final boolean hasNonEmptySelection() {\n+        TextPos ca = getCaretPosition();\n+        if (ca != null) {\n+            TextPos an = getAnchorPosition();\n+            if (an != null) {\n+                return !ca.isSameInsertionIndex(an);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Inserts a line break at the caret.  If selection exists, first deletes the selected text.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false, or the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#INSERT_LINE_BREAK\n+     *\/\n+    public void insertLineBreak() {\n+        execute(Tags.INSERT_LINE_BREAK);\n+    }\n+\n+    \/**\n+     * Inserts a tab symbol at the caret.  If selection exists, first deletes the selected text.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false, or the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#INSERT_TAB\n+     *\/\n+    public void insertTab() {\n+        execute(Tags.INSERT_TAB);\n+    }\n+\n+    \/**\n+     * Inserts the styled text at the specified position.  Any embedded {@code \"\\n\"} or {@code \"\\r\\n\"}\n+     * sequences result in a new paragraph being added.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false.\n+     *\n+     * @param pos the insert position\n+     * @param text the text to inser\n+     * @param attrs the style attributes\n+     * @return the text position at the end of the appended text, or null if editing is disabled\n+     *\/\n+    public final TextPos insertText(TextPos pos, String text, StyleAttributeMap attrs) {\n+        StyledInput in = StyledInput.of(text, attrs);\n+        return replaceText(pos, pos, in, true);\n+    }\n+\n+    \/**\n+     * Inserts the styled content at the specified position.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false.\n+     *\n+     * @param pos the insert position\n+     * @param in the input stream\n+     * @return the text position at the end of the appended text, or null if editing is disabled\n+     *\/\n+    public final TextPos insertText(TextPos pos, StyledInput in) {\n+        return replaceText(pos, pos, in, true);\n+    }\n+\n+    \/**\n+     * Moves the caret to after the last character of the text, clearing an existing selection.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_TO_DOCUMENT_END\n+     *\/\n+    public void moveDocumentEnd() {\n+        execute(Tags.MOVE_TO_DOCUMENT_END);\n+    }\n+\n+    \/**\n+     * Moves the caret to before the first character of the text, clearing an existing selection.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_TO_DOCUMENT_START\n+     *\/\n+    public void moveDocumentStart() {\n+        execute(Tags.MOVE_TO_DOCUMENT_START);\n+    }\n+\n+    \/**\n+     * Moves the caret one visual line down, clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_DOWN\n+     *\/\n+    public void moveDown() {\n+        execute(Tags.MOVE_DOWN);\n+    }\n+\n+    \/**\n+     * Moves the caret left, clearing an existing selection range.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_LEFT\n+     *\/\n+    public void moveLeft() {\n+        execute(Tags.MOVE_LEFT);\n+    }\n+\n+    \/**\n+     * Moves the caret to the end of the current paragraph, or, if already there, to the end of the next paragraph.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_PARAGRAPH_DOWN\n+     *\/\n+    public void moveParagraphDown() {\n+        execute(Tags.MOVE_PARAGRAPH_DOWN);\n+    }\n+\n+    \/**\n+     * Moves the caret to the end of the paragraph at caret, clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_TO_PARAGRAPH_END\n+     *\/\n+    public void moveParagraphEnd() {\n+        execute(Tags.MOVE_TO_PARAGRAPH_END);\n+    }\n+\n+    \/**\n+     * Moves the caret to the start of the current paragraph, clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_TO_PARAGRAPH_START\n+     *\/\n+    public void moveParagraphStart() {\n+        execute(Tags.MOVE_TO_PARAGRAPH_START);\n+    }\n+\n+    \/**\n+     * Moves the caret to the start of the current paragraph, or, if already there, to the start of the previous paragraph.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_PARAGRAPH_UP\n+     *\/\n+    public void moveParagraphUp() {\n+        execute(Tags.MOVE_PARAGRAPH_UP);\n+    }\n+\n+    \/**\n+     * Moves the caret to the next symbol, clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_RIGHT\n+     *\/\n+    public void moveRight() {\n+        execute(Tags.MOVE_RIGHT);\n+    }\n+\n+    \/**\n+     * Moves the caret one visual line up, clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_UP\n+     *\/\n+    public void moveUp() {\n+        execute(Tags.MOVE_UP);\n+    }\n+\n+    \/**\n+     * Moves the caret to the beginning of previous word in a left-to-right setting\n+     * (or the beginning of the next word in a right-to-left setting), clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_WORD_LEFT\n+     *\/\n+    public void moveWordLeft() {\n+        execute(Tags.MOVE_WORD_LEFT);\n+    }\n+\n+    \/**\n+     * Moves the caret to the end of the next word, clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_WORD_NEXT_END\n+     *\/\n+    public void moveWordNextEnd() {\n+        execute(Tags.MOVE_WORD_NEXT_END);\n+    }\n+\n+    \/**\n+     * Moves the caret to the start of next word, clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_WORD_NEXT_START\n+     *\/\n+    public void moveWordNextStart() {\n+        execute(Tags.MOVE_WORD_NEXT_START);\n+    }\n+\n+    \/**\n+     * Moves the caret to the beginning of previous word, clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_WORD_PREVIOUS\n+     *\/\n+    public void moveWordPrevious() {\n+        execute(Tags.MOVE_WORD_PREVIOUS);\n+    }\n+\n+    \/**\n+     * Moves the caret to the beginning of next word in a left-to-right setting\n+     * (or the beginning of the previous word in a right-to-left setting), clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_WORD_RIGHT\n+     *\/\n+    public void moveWordRight() {\n+        execute(Tags.MOVE_WORD_RIGHT);\n+    }\n+\n+    \/**\n+     * Move caret one visual page down, clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#PAGE_DOWN\n+     *\/\n+    public void pageDown() {\n+        execute(Tags.PAGE_DOWN);\n+    }\n+\n+    \/**\n+     * Move caret one visual page up, clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#PAGE_UP\n+     *\/\n+    public void pageUp() {\n+        execute(Tags.PAGE_UP);\n+    }\n+\n+    \/**\n+     * Pastes the clipboard content at the caret, or, if selection exists, replacing the selected text.\n+     * This method clears the selection afterward.\n+     * It is up to the model to pick the best data format to paste.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false, or the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#PASTE\n+     *\/\n+    public void paste() {\n+        execute(Tags.PASTE);\n+    }\n+\n+    \/**\n+     * Pastes the clipboard content at the caret, or, if selection exists, replacing the selected text.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false, of if the specified format is\n+     * not supported by the model.\n+     *\n+     * @param format the data format to use\n+     *\/\n+    public void paste(DataFormat format) {\n+        RichTextAreaSkin skin = richTextAreaSkin();\n+        if (skin != null) {\n+            skin.pasteText(format);\n+        }\n+    }\n+\n+    \/**\n+     * Pastes the plain text clipboard content at the caret, or, if selection exists, replacing the selected text.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false, or the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#PASTE_PLAIN_TEXT\n+     *\/\n+    public final void pastePlainText() {\n+        execute(Tags.PASTE_PLAIN_TEXT);\n+    }\n+\n+    \/**\n+     * Calls the model to replace the current document with the content read from the stream using\n+     * the specified {@code DataFormat}.\n+     * Any existing content is discarded and undo\/redo buffer is cleared.\n+     * <p>\n+     * This method does not close the input stream.  This method does nothing if the model is {@code null}.\n+     *\n+     * @param f the data format\n+     * @param in the input stream\n+     * @throws IOException if an I\/O error occurs\n+     * @throws UnsupportedOperationException when the data format is not supported by the model\n+     *\/\n+    public final void read(DataFormat f, InputStream in) throws IOException {\n+        StyledTextModel m = getModel();\n+        if (m != null) {\n+            StyleResolver r = resolver();\n+            m.read(r, f, in);\n+            select(TextPos.ZERO, TextPos.ZERO);\n+        }\n+    }\n+\n+    \/**\n+     * Calls the model to replace the current document with the content read from the input stream.\n+     * The model picks the best {@code DataFormat} to use based on priority.\n+     * Any existing content is discarded and undo\/redo buffer is cleared.\n+     * <p>\n+     * This method does not close the input stream.  This method does nothing if the model is {@code null}.\n+     *\n+     * @param in the input stream\n+     * @throws IOException if an I\/O error occurs\n+     * @throws UnsupportedOperationException when the data format is not supported by the model\n+     *\/\n+    public final void read(InputStream in) throws IOException {\n+        DataFormat f = bestDataFormat(false);\n+        if (f != null) {\n+            read(f, in);\n+        }\n+    }\n+\n+    \/**\n+     * If possible, redoes the last undone modification. If {@link #isRedoable()} returns\n+     * false, then calling this method has no effect.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#REDO\n+     *\/\n+    public void redo() {\n+        execute(Tags.REDO);\n+    }\n+\n+    \/**\n+     * Replaces the specified range with the new text.\n+     *\n+     * @param start the start text position\n+     * @param end the end text position\n+     * @param text the input text\n+     * @param allowUndo when true, creates an undo-redo entry\n+     * @return the new caret position at the end of inserted text, or null if the change cannot be made\n+     *\/\n+    public final TextPos replaceText(TextPos start, TextPos end, String text, boolean allowUndo) {\n+        if (canEdit()) {\n+            StyledTextModel m = getModel();\n+            return m.replace(vflow(), start, end, text, allowUndo);\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Replaces the specified range with the new input.\n+     * <p>\n+     * This method does nothing if the model is null.\n+     *\n+     * @param start the start text position\n+     * @param end the end text position\n+     * @param in the input stream\n+     * @param createUndo when true, creates an undo-redo entry\n+     * @return the new caret position at the end of inserted text, or null if the change cannot be made\n+     *\/\n+    public final TextPos replaceText(TextPos start, TextPos end, StyledInput in, boolean createUndo) {\n+        StyledTextModel m = getModel();\n+        if (m != null) {\n+            return m.replace(vflow(), start, end, in, createUndo);\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Moves both the caret and the anchor to the specified position, clearing any existing selection.\n+     * This method is equivalent to {@code select(pos, pos)}.\n+     *\n+     * @param pos the text position\n+     *\/\n+    public final void select(TextPos pos) {\n+        select(pos, pos);\n+    }\n+\n+    \/**\n+     * Selects the specified range and places the caret at the new position.\n+     * Both positions will be internally clamped to be within the document boundaries.\n+     * This method does nothing if the model is null.\n+     *\n+     * @param anchor the new selection anchor position\n+     * @param caret the new caret position\n+     *\/\n+    public final void select(TextPos anchor, TextPos caret) {\n+        StyledTextModel m = getModel();\n+        if (m != null) {\n+            selectionModel.setSelection(m, anchor, caret);\n+        }\n+    }\n+\n+    \/**\n+     * Selects all the text in the document: the anchor is set at the document start, while the caret is positioned\n+     * at the end of the document.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_ALL\n+     *\/\n+    public void selectAll() {\n+        execute(Tags.SELECT_ALL);\n+    }\n+\n+    \/**\n+     * Extends selection one visual text line down.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_DOWN\n+     *\/\n+    public void selectDown() {\n+        execute(Tags.SELECT_DOWN);\n+    }\n+\n+    \/**\n+     * Extends selection one symbol to the left.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_LEFT\n+     *\/\n+    public void selectLeft() {\n+        execute(Tags.SELECT_LEFT);\n+    }\n+\n+    \/**\n+     * Extends selection one visible page down.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_PAGE_DOWN\n+     *\/\n+    public void selectPageDown() {\n+        execute(Tags.SELECT_PAGE_DOWN);\n+    }\n+\n+    \/**\n+     * Extends selection one visible page up.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_PAGE_UP\n+     *\/\n+    public void selectPageUp() {\n+        execute(Tags.SELECT_PAGE_UP);\n+    }\n+\n+    \/**\n+     * Selects the current paragraph.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_PARAGRAPH\n+     *\/\n+    public void selectParagraph() {\n+        execute(Tags.SELECT_PARAGRAPH);\n+    }\n+\n+    \/**\n+     * Extends selection to the end of the current paragraph, or, if already at the end,\n+     * to the end of the next paragraph.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_PARAGRAPH_DOWN\n+     *\/\n+    public void selectParagraphDown() {\n+        execute(Tags.SELECT_PARAGRAPH_DOWN);\n+    }\n+\n+    \/**\n+     * Selects from the current position to the paragraph end.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_PARAGRAPH_END\n+     *\/\n+    public void selectParagraphEnd() {\n+        execute(Tags.SELECT_PARAGRAPH_END);\n+    }\n+\n+    \/**\n+     * Selects from the current position to the paragraph start.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_PARAGRAPH_START\n+     *\/\n+    public void selectParagraphStart() {\n+        execute(Tags.SELECT_PARAGRAPH_START);\n+    }\n+\n+    \/**\n+     * Extends selection to the start of the current paragraph, or, if already at the start,\n+     * to the start of the previous paragraph.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_PARAGRAPH_UP\n+     *\/\n+    public void selectParagraphUp() {\n+        execute(Tags.SELECT_PARAGRAPH_UP);\n+    }\n+\n+    \/**\n+     * Extends selection one symbol (or grapheme cluster) to the right.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_RIGHT\n+     *\/\n+    public void selectRight() {\n+        execute(Tags.SELECT_RIGHT);\n+    }\n+\n+    \/**\n+     * Extends selection to the end of the document.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_TO_DOCUMENT_END\n+     *\/\n+    public void selectToDocumentEnd() {\n+        execute(Tags.SELECT_TO_DOCUMENT_END);\n+    }\n+\n+    \/**\n+     * Extends selection to the start of the document.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_TO_DOCUMENT_START\n+     *\/\n+    public void selectToDocumentStart() {\n+        execute(Tags.SELECT_TO_DOCUMENT_START);\n+    }\n+\n+    \/**\n+     * Extends selection one visual text line up.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_UP\n+     *\/\n+    public void selectUp() {\n+        execute(Tags.SELECT_UP);\n+    }\n+\n+    \/**\n+     * Selects a word at the caret position.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_WORD\n+     *\/\n+    public void selectWord() {\n+        execute(Tags.SELECT_WORD);\n+    }\n+\n+    \/**\n+     * Moves the caret to the beginning of previous word in a left-to-right setting,\n+     * or to the beginning of the next word in a right-to-left setting.\n+     * This does not cause\n+     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is\n+     * moved to the beginning of next word.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_WORD_LEFT\n+     *\/\n+    public void selectWordLeft() {\n+        execute(Tags.SELECT_WORD_LEFT);\n+    }\n+\n+    \/**\n+     * Extends selection to the end of the next word.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_WORD_NEXT_END\n+     *\/\n+    public void selectWordNextEnd() {\n+        execute(Tags.SELECT_WORD_NEXT_END);\n+    }\n+\n+    \/**\n+     * Moves the caret to the start of the next word. This does not cause\n+     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is\n+     * moved to the beginning of next word.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_WORD_NEXT\n+     *\/\n+    public void selectWordNextStart() {\n+        execute(Tags.SELECT_WORD_NEXT);\n+    }\n+\n+    \/**\n+     * Moves the caret to the beginning of previous word. This does not cause\n+     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is\n+     * moved to the beginning of previous word.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_WORD_PREVIOUS\n+     *\/\n+    public void selectWordPrevious() {\n+        execute(Tags.SELECT_WORD_PREVIOUS);\n+    }\n+\n+    \/**\n+     * Moves the caret to the beginning of next word in a left-to-right setting,\n+     * or to the beginning of the previous word in a right-to-left setting.\n+     * This does not cause\n+     * the selection to be cleared. Rather, the anchor stays put and the caretPosition is\n+     * moved to the beginning of next word.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_WORD_RIGHT\n+     *\/\n+    public void selectWordRight() {\n+        execute(Tags.SELECT_WORD_RIGHT);\n+    }\n+\n+    \/**\n+     * Sets the specified style to the selected range.\n+     * All the existing attributes in the selected range will be cleared.\n+     * When setting the paragraph attributes, the affected range\n+     * might be wider than one specified.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false.\n+     *\n+     * @param start the start of text range\n+     * @param end the end of text range\n+     * @param attrs the style attributes to set\n+     *\/\n+    public final void setStyle(TextPos start, TextPos end, StyleAttributeMap attrs) {\n+        if (canEdit()) {\n+            StyledTextModel m = getModel();\n+            m.applyStyle(start, end, attrs, false);\n+        }\n+    }\n+\n+    \/**\n+     * If possible, undoes the last modification. If {@link #isUndoable()} returns\n+     * false, then calling this method has no effect.\n+     * <p>\n+     * This method does nothing if {@link #canEdit()} returns false.\n+     *\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#UNDO\n+     *\/\n+    public void undo() {\n+        execute(Tags.UNDO);\n+    }\n+\n+    \/**\n+     * Calls the model to writes the current document to the output stream using the specified {@code DataFormat}.\n+     * <p>\n+     * This method does not close the output stream.  This method does nothing if the model is {@code null}.\n+     *\n+     * @param f the data format\n+     * @param out the output stream\n+     * @throws IOException if an I\/O error occurs\n+     * @throws UnsupportedOperationException when the data format is not supported by the model\n+     *\/\n+    public final void write(DataFormat f, OutputStream out) throws IOException {\n+        StyledTextModel m = getModel();\n+        if (m != null) {\n+            StyleResolver r = resolver();\n+            m.write(r, f, out);\n+        }\n+    }\n+\n+    \/**\n+     * Calls the model to write the current document to the output stream, using the highest priority {@code DataFormat}\n+     * as determined by the model.\n+     * <p>\n+     * This method does not close the output stream.  This method does nothing if the model is {@code null}.\n+     * @param out the output stream\n+     * @throws IOException if an I\/O error occurs\n+     * @throws UnsupportedOperationException when no suitable data format can be found\n+     *\/\n+    public final void write(OutputStream out) throws IOException {\n+        if (getModel() != null) {\n+            DataFormat f = bestDataFormat(true);\n+            if (f == null) {\n+                throw new UnsupportedOperationException(\"no suitable format can be found\");\n+            }\n+            write(f, out);\n+        }\n+    }\n+\n+    \/\/ Non-public Methods\n+\n+    @Override\n+    protected RichTextAreaSkin createDefaultSkin() {\n+        return new RichTextAreaSkin(this);\n+    }\n+\n+    \/\/ package protected for testing\n+    VFlow vflow() {\n+        return RichTextAreaSkinHelper.getVFlow(this);\n+    }\n+\n+    private RichTextAreaSkin richTextAreaSkin() {\n+        return (RichTextAreaSkin)getSkin();\n+    }\n+\n+    private StyleResolver resolver() {\n+        RichTextAreaSkin skin = richTextAreaSkin();\n+        if (skin != null) {\n+            return skin.getStyleResolver();\n+        }\n+        return null;\n+    }\n+\n+    private StyleAttributeMap getModelStyleAttrs(StyleResolver r) {\n+        StyledTextModel m = getModel();\n+        if (m != null) {\n+            TextPos pos = getCaretPosition();\n+            if (pos != null) {\n+                if (hasNonEmptySelection()) {\n+                    TextPos an = getAnchorPosition();\n+                    if (pos.compareTo(an) > 0) {\n+                        pos = an;\n+                    }\n+                } else if (!TextPos.ZERO.equals(pos)) {\n+                    int ix = pos.offset() - 1;\n+                    if (ix < 0) {\n+                        \/\/ FIX find previous symbol\n+                        ix = 0;\n+                    }\n+                    pos = new TextPos(pos.index(), ix);\n+                }\n+                return m.getStyleAttributeMap(r, pos);\n+            }\n+        }\n+        return StyleAttributeMap.EMPTY;\n+    }\n+\n+    private static StyleHandlerRegistry initStyleHandlerRegistry() {\n+        StyleHandlerRegistry.Builder b = StyleHandlerRegistry.builder(null);\n+\n+        b.setParHandler(StyleAttributeMap.BACKGROUND, (c, cx, v) -> {\n+            String color = RichUtils.toCssColor(v);\n+            cx.addStyle(\"-fx-background-color:\" + color + \";\");\n+        });\n+\n+        b.setSegHandler(StyleAttributeMap.BOLD, (c, cx, v) -> {\n+            cx.addStyle(v ? \"-fx-font-weight:bold;\" : \"-fx-font-weight:normal;\");\n+        });\n+\n+        b.setSegHandler(CssStyles.CSS, (c, cx, v) -> {\n+            String st = v.style();\n+            if (st != null) {\n+                cx.addStyle(st);\n+            }\n+            String[] names = v.names();\n+            if (names != null) {\n+                cx.getNode().getStyleClass().addAll(names);\n+            }\n+        });\n+\n+        b.setSegHandler(StyleAttributeMap.FONT_FAMILY, (c, cx, v) -> {\n+            cx.addStyle(\"-fx-font-family:'\" + v + \"';\");\n+        });\n+\n+        b.setSegHandler(StyleAttributeMap.FONT_SIZE, (c, cx, v) -> {\n+            cx.addStyle(\"-fx-font-size:\" + v + \";\");\n+        });\n+\n+        b.setSegHandler(StyleAttributeMap.ITALIC, (c, cx, v) -> {\n+            if (v) {\n+                cx.addStyle(\"-fx-font-style:italic;\");\n+            }\n+        });\n+\n+        b.setParHandler(StyleAttributeMap.LINE_SPACING, (c, cx, v) -> {\n+            cx.addStyle(\"-fx-line-spacing:\" + v + \";\");\n+        });\n+\n+        b.setParHandler(StyleAttributeMap.PARAGRAPH_DIRECTION, (ctrl, cx, v) -> {\n+            if (ctrl.isWrapText()) {\n+                \/\/ node orientation property is not styleable (yet?)\n+                switch (v) {\n+                case LEFT_TO_RIGHT:\n+                    cx.getNode().setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);\n+                    break;\n+                case RIGHT_TO_LEFT:\n+                    cx.getNode().setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+                    break;\n+                }\n+            }\n+        });\n+\n+        \/\/ this is a special case: 4 attributes merged into one -fx style\n+        \/\/ unfortunately, this might create multiple copies of the same style string\n+        StyleAttributeHandler<RichTextArea, Double> spaceHandler = (c, cx, v) -> {\n+            StyleAttributeMap a = cx.getAttributes();\n+            double top = a.getDouble(StyleAttributeMap.SPACE_ABOVE, 0);\n+            double right = a.getDouble(StyleAttributeMap.SPACE_RIGHT, 0);\n+            double bottom = a.getDouble(StyleAttributeMap.SPACE_BELOW, 0);\n+            double left = a.getDouble(StyleAttributeMap.SPACE_LEFT, 0);\n+            cx.addStyle(\"-fx-padding:\" + top + ' ' + right + ' ' + bottom + ' ' + left + \";\");\n+        };\n+        b.setParHandler(StyleAttributeMap.SPACE_ABOVE, spaceHandler);\n+        b.setParHandler(StyleAttributeMap.SPACE_RIGHT, spaceHandler);\n+        b.setParHandler(StyleAttributeMap.SPACE_BELOW, spaceHandler);\n+        b.setParHandler(StyleAttributeMap.SPACE_LEFT, spaceHandler);\n+\n+        b.setSegHandler(StyleAttributeMap.STRIKE_THROUGH, (c, cx, v) -> {\n+            if (v) {\n+                cx.addStyle(\"-fx-strikethrough:true;\");\n+            }\n+        });\n+\n+        b.setParHandler(StyleAttributeMap.TEXT_ALIGNMENT, (c, cx, v) -> {\n+            if (c.isWrapText()) {\n+                String alignment = RichUtils.toCss(v);\n+                cx.addStyle(\"-fx-text-alignment:\" + alignment + \";\");\n+            }\n+        });\n+\n+        b.setSegHandler(StyleAttributeMap.TEXT_COLOR, (c, cx, v) -> {\n+            String color = RichUtils.toCssColor(v);\n+            cx.addStyle(\"-fx-fill:\" + color + \";\");\n+        });\n+\n+        b.setSegHandler(StyleAttributeMap.UNDERLINE, (cc, cx, v) -> {\n+            if (v) {\n+                cx.addStyle(\"-fx-underline:true;\");\n+            }\n+        });\n+\n+        return b.build();\n+    }\n+\n+    private DataFormat bestDataFormat(boolean forExport) {\n+        StyledTextModel m = getModel();\n+        if (m != null) {\n+            DataFormat[] fs = m.getSupportedDataFormats(forExport);\n+            if (fs.length > 0) {\n+                return fs[0];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private RTAccessibilityHelper accessibilityHelper() {\n+        if(accessibilityHelper == null) {\n+            accessibilityHelper = new RTAccessibilityHelper(this);\n+        }\n+        return accessibilityHelper;\n+    }\n+\n+    @Override\n+    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {\n+        \/\/System.out.println(\"execute: \" + action); \/\/ FIX\n+        switch (action) {\n+        case SET_TEXT:\n+            {\n+                String value = (String) parameters[0];\n+                if (value != null) {\n+                    \/\/ TODO\n+                    \/\/ setText(value);\n+                }\n+                return;\n+            }\n+        case SET_TEXT_SELECTION:\n+            {\n+                Integer start = (Integer) parameters[0];\n+                Integer end = (Integer) parameters[1];\n+                if (start != null && end != null) {\n+                    \/\/ TODO\n+                    \/\/ selectRange(start,  end);\n+                }\n+                return;\n+            }\n+        case SHOW_TEXT_RANGE:\n+            \/\/ TODO\n+            return;\n+        default:\n+            super.executeAccessibleAction(action, parameters);\n+        }\n+    }\n+\n+    @Override\n+    public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {\n+        switch (attribute) {\n+        case EDITABLE:\n+            return isEditable();\n+        case TEXT:\n+            {\n+                String accText = getAccessibleText();\n+                if (accText != null && !accText.isEmpty()) {\n+                    return accText;\n+                }\n+                return accessibilityHelper().getText();\n+            }\n+        case SELECTION_START:\n+            return accessibilityHelper().selectionStart();\n+        case SELECTION_END:\n+            return accessibilityHelper().selectionEnd();\n+        case CARET_OFFSET:\n+            return accessibilityHelper().caretOffset();\n+        default:\n+            return super.queryAccessibleAttribute(attribute, parameters);\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/RichTextArea.java","additions":2345,"deletions":0,"binary":false,"changes":2345,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\n+package jfx.incubator.scene.control.richtext;\n+\n+import javafx.beans.property.ReadOnlyProperty;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+\n+\/**\n+ * A Selection model that maintains a single {@link SelectionSegment}.\n+ *\/\n+\/\/ TODO perhaps we should support, at least theoretically, the concept of multiple selection\n+\/\/ and multiple carets.  The impacted areas:\n+\/\/ this interface\n+\/\/ changes in VFlow to handle multiple carets and decorations\n+\/\/ changes in RichTextAreaBehavior to handle selection and keyboard navigation\n+public interface SelectionModel {\n+    \/**\n+     * Clears the selection.  This sets {@code selectionProperty},\n+     * {@code anchorPositionProperty}, and {@code caretPositionProperty} to null.\n+     *\/\n+    public void clear();\n+\n+    \/**\n+     * Replaced existing selection, if any, with the new one.  While this method will accept the text positions\n+     * outside of the document range, the actual values of\n+     * {@code anchorPositionProperty}, and {@code caretPositionProperty} must always remain within\n+     * the valid range for the document.\n+     *\n+     * @param model the model, must be non-null\n+     * @param anchor the anchor position, must be non-null\n+     * @param caret the caret position, must be non-null\n+     *\/\n+    public void setSelection(StyledTextModel model, TextPos anchor, TextPos caret);\n+\n+    \/**\n+     * Extends selection to the specified position.\n+     * Internally, the position will be normalized to be within the document boundaries.\n+     * This method will issue a {@code setSelection(model, pos, pos)}\n+     * call if the model instance is different from that passed before.\n+     * <p>\n+     * While this method will accept the text position\n+     * outside of the document range, the actual values of\n+     * {@code anchorPositionProperty}, and {@code caretPositionProperty} must always remain within\n+     * the valid range for the document.\n+     *\n+     * @param model the model, must be non-null\n+     * @param pos the new caret position, must be non-null\n+     *\/\n+    public void extendSelection(StyledTextModel model, TextPos pos);\n+\n+    \/**\n+     * Caret position property.  The value can be null, indicating no selection.  When the caret position\n+     * is {@code null}, the {@code selectionProperty} and the {@code anchorPositionProperty} are also {@code null}.\n+     * <p>\n+     * Note:\n+     * {@link #selectionProperty()}, {@link #anchorPositionProperty()}, and {@link #caretPositionProperty()}\n+     * are logically connected.  When a change occurs, the anchor position is updated first, followed by\n+     * the caret position, followed by the selection segment.\n+     *\n+     * @return the caret position property\n+     * @defaultValue null\n+     *\/\n+    public ReadOnlyProperty<TextPos> caretPositionProperty();\n+\n+    \/**\n+     * Anchor position property.  The value can be null, indicating no selection.  When the anchor position\n+     * is {@code null}, the {@code selectionProperty} and the {@code caretPositionProperty} are also {@code null}.\n+     * <p>\n+     * Note:\n+     * {@link #selectionProperty()}, {@link #anchorPositionProperty()}, and {@link #caretPositionProperty()}\n+     * are logically connected.  When a change occurs, the anchor position is updated first, followed by\n+     * the caret position, followed by the selection segment.\n+     *\n+     * @return the anchor position property\n+     * @defaultValue null\n+     *\/\n+    public ReadOnlyProperty<TextPos> anchorPositionProperty();\n+\n+    \/**\n+     * Selection property.  The value can be null, indicating no selection.  When the selection segment\n+     * is {@code null}, the {@code anchorPositionProperty} and the {@code caretPositionProperty} are also {@code null}.\n+     *\n+     * @return the selection property\n+     * @defaultValue null\n+     *\/\n+    public ReadOnlyProperty<SelectionSegment> selectionProperty();\n+\n+    \/**\n+     * Returns the current selection.  The value can be null, indicating no selection.  When the selection segment\n+     * is {@code null}, the {@code anchorPositionProperty} and the {@code caretPositionProperty} are also {@code null}.\n+     *\n+     * @return current selection, or null\n+     *\/\n+    public SelectionSegment getSelection();\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/SelectionModel.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\n+package jfx.incubator.scene.control.richtext;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * Text selection segment, comprised of the selection anchor and the caret positions.\n+ * The main purpose of this class is to enable tracking of selection changes as a single entity.\n+ *\/\n+public final class SelectionSegment {\n+    private final TextPos min;\n+    private final TextPos max;\n+    private final boolean caretAtMin;\n+\n+    \/**\n+     * Constructs the selection segment.\n+     *\n+     * @param anchor the anchor position, must not be null\n+     * @param caret the caret position, must not be null\n+     *\/\n+    public SelectionSegment(TextPos anchor, TextPos caret) {\n+        Objects.requireNonNull(anchor, \"anchor cannot be null\");\n+        Objects.requireNonNull(caret, \"caret cannot be null\");\n+\n+        if (anchor.compareTo(caret) <= 0) {\n+            this.min = anchor;\n+            this.max = caret;\n+            this.caretAtMin = false;\n+        } else {\n+            this.min = caret;\n+            this.max = anchor;\n+            this.caretAtMin = true;\n+        }\n+    }\n+\n+    \/**\n+     * Returns the selection anchor position.\n+     * @return the anchor position\n+     *\/\n+    public final TextPos getAnchor() {\n+        return caretAtMin ? max : min;\n+    }\n+\n+    \/**\n+     * Returns the caret position.\n+     * @return the caret position\n+     *\/\n+    public final TextPos getCaret() {\n+        return caretAtMin ? min : max;\n+    }\n+\n+    \/**\n+     * Returns the position which is closer to the start of the document.\n+     * @return the text position\n+     *\/\n+    public final TextPos getMin() {\n+        return min;\n+    }\n+\n+    \/**\n+     * Returns the position which is closer to the end of the document.\n+     * @return the text position\n+     *\/\n+    public TextPos getMax() {\n+        return max;\n+    }\n+\n+    \/**\n+     * Returns true if the anchor and the caret are at the same position.\n+     * @return true if the anchor and the caret are at the same position\n+     *\/\n+    public boolean isCollapsed() {\n+        return min.equals(max);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"SelectionSegment{\" + min + \", \" + max + \", caretAtMin=\" + caretAtMin + \"}\";\n+    }\n+\n+    private static <T extends Comparable<T>> void isLessThanOrEqual(T min, T max, String nameMin, String nameMax) {\n+        if (min.compareTo(max) > 0) {\n+            throw new IllegalArgumentException(nameMin + \" must be less or equal to \" + nameMax);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object x) {\n+        if (x == this) {\n+            return true;\n+        } else if (x instanceof SelectionSegment s) {\n+            return\n+                (caretAtMin == s.caretAtMin) &&\n+                (min.equals(s.min)) &&\n+                (max.equals(s.max));\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int h = SelectionSegment.class.hashCode();\n+        h = 31 * h + Boolean.hashCode(caretAtMin);\n+        h = 31 * h + min.hashCode();\n+        h = 31 * h + max.hashCode();\n+        return h;\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/SelectionSegment.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext;\n+\n+import javafx.scene.Node;\n+\n+\/**\n+ * Provides a way to add side decorations to each paragraph\n+ * in a {@link RichTextArea}.\n+ * <p>\n+ * The side decorations Nodes are added to either left or right side of each paragraph.  Each side node will be\n+ * resized to the height of the corresponding paragraph.  The width of all the side nodes, in order to avoid complicated\n+ * layout process, would be determined by the following process:\n+ * <ul>\n+ * <li>if {@link #getPrefWidth} method returns a value greater than 0, that will be the width of all the side nodes.\n+ * <li>otherwise, the {@link #getNode(int, boolean)} method is called with {@code forMeasurement} argument set to\n+ * {@code true}.  The value returned will be used to size all other nodes for that side.\n+ * <\/ul>\n+ *\/\n+public interface SideDecorator {\n+    \/**\n+     * Returns the width for all the side Nodes, or 0 if a measurer Node needs to be obtained via\n+     * {@link #getNode(int, boolean)}.\n+     * @param viewWidth width of the view\n+     * @return preferred width\n+     *\/\n+    public double getPrefWidth(double viewWidth);\n+\n+    \/**\n+     * Creates a Node to be added to the layout to the right or to the left of the given paragraph.\n+     * <p>\n+     * When {@code forMeasurement} is true, this method is expected to create a special non-null\n+     * measurement Node, whose preferred width will be used to size all the side Nodes (and must, therefore,\n+     * be wider than any side node in the view).  The {@code modelIndex} is this case is the index of\n+     * the first paragraph in the view.\n+     * <p>\n+     * The measurement node will not be displayed and will be discarded.\n+     *\n+     * @param modelIndex model index\n+     * @param forMeasurement when true, specifies that a measurement Node must be created\n+     * @return new instance of the Node, or null\n+     *\/\n+    public Node getNode(int modelIndex, boolean forMeasurement);\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/SideDecorator.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\n+package jfx.incubator.scene.control.richtext;\n+\n+import javafx.beans.property.ReadOnlyObjectWrapper;\n+import javafx.beans.property.ReadOnlyProperty;\n+import javafx.beans.value.ChangeListener;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+\n+\/**\n+ * This {@link SelectionModel} supports a single selection segment.\n+ *\/\n+public final class SingleSelectionModel implements SelectionModel {\n+    private final ReadOnlyObjectWrapper<SelectionSegment> segment = new ReadOnlyObjectWrapper<>();\n+    private final ReadOnlyObjectWrapper<TextPos> anchorPosition = new ReadOnlyObjectWrapper<>();\n+    private final ReadOnlyObjectWrapper<TextPos> caretPosition = new ReadOnlyObjectWrapper<>();\n+    private final ChangeListener<TextPos> anchorListener;\n+    private final ChangeListener<TextPos> caretListener;\n+    private Marker anchorMarker;\n+    private Marker caretMarker;\n+    private StyledTextModel model;\n+\n+    \/** The constructor. *\/\n+    public SingleSelectionModel() {\n+        anchorListener = (src, old, pos) -> {\n+            anchorPosition.set(pos);\n+            segment.set(new SelectionSegment(pos, caretPosition.get()));\n+        };\n+        caretListener = (src, old, pos) -> {\n+            caretPosition.set(pos);\n+            segment.set(new SelectionSegment(anchorPosition.get(), pos));\n+        };\n+    }\n+\n+    @Override\n+    public void clear() {\n+        setSelectionSegment(null, null);\n+    }\n+\n+    @Override\n+    public void setSelection(StyledTextModel model, TextPos anchor, TextPos caret) {\n+        \/\/ non-null values are enforced by clamp()\n+        anchor = model.clamp(anchor);\n+        caret = model.clamp(caret);\n+        SelectionSegment sel = new SelectionSegment(anchor, caret);\n+        setSelectionSegment(model, sel);\n+    }\n+\n+    @Override\n+    public void extendSelection(StyledTextModel model, TextPos pos) {\n+        \/\/ reset selection if model is different\n+        if (isFlippingModel(model)) {\n+            setSelection(model, pos, pos);\n+            return;\n+        }\n+\n+        pos = model.clamp(pos);\n+        SelectionSegment sel = getSelection();\n+        TextPos a = sel == null ? null : sel.getAnchor();\n+        if (a == null) {\n+            a = pos;\n+        } else {\n+            if(pos.compareTo(sel.getMin()) < 0) {\n+                \/\/ extend before\n+                a = sel.getMax();\n+            } else if(pos.compareTo(sel.getMax()) > 0) {\n+                \/\/ extend after\n+                a = sel.getMin();\n+            } else {\n+                \/\/ extend from anchor to pos\n+                a = sel.getAnchor();\n+            }\n+        }\n+        setSelection(model, a, pos);\n+    }\n+\n+    private boolean isFlippingModel(StyledTextModel m) {\n+        if (model == null) {\n+            return false;\n+        } else if (m == null) {\n+            return false;\n+        }\n+        return m != model;\n+    }\n+\n+    @Override\n+    public ReadOnlyProperty<TextPos> anchorPositionProperty() {\n+        return anchorPosition.getReadOnlyProperty();\n+    }\n+\n+    @Override\n+    public ReadOnlyProperty<TextPos> caretPositionProperty() {\n+        return caretPosition;\n+    }\n+\n+    private void setSelectionSegment(StyledTextModel model, SelectionSegment sel) {\n+        this.model = model;\n+\n+        if (anchorMarker != null) {\n+            anchorMarker.textPosProperty().removeListener(anchorListener);\n+            anchorMarker = null;\n+        }\n+\n+        if (caretMarker != null) {\n+            caretMarker.textPosProperty().removeListener(caretListener);\n+            caretMarker = null;\n+        }\n+\n+        \/\/ since caretPosition, anchorPosition, and selectionSegment are separate properties,\n+        \/\/ there is a possibility that one is null and another is not (for example, in a listener).\n+        \/\/ this code guarantees a specific order of updates:\n+        \/\/ 1. anchor\n+        \/\/ 2. caret\n+        \/\/ 3. selection segment\n+        if (sel == null) {\n+            anchorPosition.set(null);\n+            caretPosition.set(null);\n+        } else {\n+            TextPos p = sel.getAnchor();\n+            anchorMarker = model.getMarker(p);\n+            anchorPosition.set(p);\n+            anchorMarker.textPosProperty().addListener(anchorListener);\n+\n+            p = sel.getCaret();\n+            caretMarker = model.getMarker(p);\n+            caretPosition.set(p);\n+            caretMarker.textPosProperty().addListener(caretListener);\n+        }\n+\n+        segment.set(sel);\n+    }\n+\n+    @Override\n+    public ReadOnlyProperty<SelectionSegment> selectionProperty() {\n+        return segment.getReadOnlyProperty();\n+    }\n+\n+    @Override\n+    public SelectionSegment getSelection() {\n+        return segment.get();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/SingleSelectionModel.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext;\n+\n+import jfx.incubator.scene.control.richtext.skin.CellContext;\n+\n+\/**\n+ * This functional interface defines a style attribute handler.\n+ * <p>\n+ * This interface is needed when extending the RichTextArea with support for other style attributes.\n+ * Applications should not normally use this interface.\n+ * <p>\n+ * The purpose of this handler is to apply changes to the {@code CellContext} based on the value\n+ * of the corresponding attribute.\n+ *\n+ * @param <C> the actual type of RichTextArea control\n+ * @param <T> the attribute value type\n+ *\/\n+@FunctionalInterface\n+public interface StyleAttributeHandler<C extends RichTextArea, T> {\n+    \/**\n+     * Executes the attribute handler for the given control, cell context,\n+     * and the attribute value.\n+     *\n+     * @param control the control\n+     * @param cx the cell context\n+     * @param value the attribute value\n+     *\/\n+    public void apply(C control, CellContext cx, T value);\n+}\n\\ No newline at end of file\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/StyleAttributeHandler.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext;\n+\n+import java.util.HashMap;\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.skin.CellContext;\n+\n+\/**\n+ * Style Handler Registry keeps track of the {@code StyleAttributeHandler} for supported\n+ * {@code StyleAttribute}s.  The registry, once created using its {@code Builder}, is immutable.\n+ *\n+ * This class is needed when extending the RichTextArea with support for other style attributes.\n+ * Applications should not normally use this interface.\n+ *\/\n+public class StyleHandlerRegistry {\n+    private final HashMap<StyleAttribute,StyleAttributeHandler> parStyleHandlerMap;\n+    private final HashMap<StyleAttribute,StyleAttributeHandler> segStyleHandlerMap;\n+\n+    private StyleHandlerRegistry(HashMap<StyleAttribute,StyleAttributeHandler> p, HashMap<StyleAttribute,StyleAttributeHandler> s) {\n+        parStyleHandlerMap = p;\n+        segStyleHandlerMap = s;\n+    }\n+\n+    \/**\n+     * Creates a builder initialized with the parent's registry content.\n+     *\n+     * @param parent the parent class' registry (can be null)\n+     * @return the builder instance\n+     *\/\n+    public static Builder builder(StyleHandlerRegistry parent) {\n+        Builder b = new Builder();\n+        if (parent != null) {\n+            b.parStyleHandlerMap.putAll(parent.parStyleHandlerMap);\n+            b.segStyleHandlerMap.putAll(parent.segStyleHandlerMap);\n+        }\n+        return b;\n+    }\n+\n+    \/**\n+     * Invokes the handler, if present, for the specified attribute in the context of the specified control.\n+     *\n+     * @param <C> the control type\n+     * @param <T> the attribute value type\n+     * @param control the control reference\n+     * @param forParagraph specifies which attribute to search for: paragraph ({@code true}) or text segment ({@code false})\n+     * @param cx the cell context\n+     * @param a the attribute\n+     * @param value the attribute value\n+     *\/\n+    public <C extends RichTextArea, T> void process(C control, boolean forParagraph, CellContext cx, StyleAttribute<T> a, T value) {\n+        StyleAttributeHandler h = (forParagraph ? parStyleHandlerMap : segStyleHandlerMap).get(a);\n+        if (h != null) {\n+            h.apply(control, cx, value);\n+        }\n+    }\n+\n+    \/**\n+     * The builder used to create an immutable instance of {@code StyleHandlerRegistry}.\n+     *\/\n+    public static class Builder {\n+        private HashMap<StyleAttribute, StyleAttributeHandler> parStyleHandlerMap = new HashMap<>();\n+        private HashMap<StyleAttribute, StyleAttributeHandler> segStyleHandlerMap = new HashMap<>();\n+\n+        Builder() {\n+        }\n+\n+        \/**\n+         * Sets the paragraph handler for the given attribute.\n+         *\n+         * @param <C> the control type\n+         * @param <T> the attribute value type\n+         * @param a the attribute\n+         * @param h the handler\n+         *\/\n+        public <C extends RichTextArea, T> void setParHandler(StyleAttribute<T> a, StyleAttributeHandler<C, T> h) {\n+            parStyleHandlerMap.put(a, h);\n+        }\n+\n+        \/**\n+         * Sets the text segment handler for the given attribute.\n+         *\n+         * @param <C> the control type\n+         * @param <T> the attribute value type\n+         * @param a the attribute\n+         * @param h the handler\n+         *\/\n+        public <C extends RichTextArea, T> void setSegHandler(StyleAttribute<T> a, StyleAttributeHandler<C, T> h) {\n+            segStyleHandlerMap.put(a, h);\n+        }\n+\n+        \/**\n+         * Creates an immutable instance of {@code StyleHandlerRegistry}.\n+         * @return the {@code StyleHandlerRegistry} instance\n+         *\/\n+        public StyleHandlerRegistry build() {\n+            return new StyleHandlerRegistry(parStyleHandlerMap, segStyleHandlerMap);\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/StyleHandlerRegistry.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext;\n+\n+import javafx.scene.Node;\n+import javafx.scene.image.WritableImage;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * Enables conversion of CSS styles to {@code StyleAttribute}s.\n+ * <p>\n+ * Whenever the {@code StyledTextModel} contains logical class names instead of actual attributes,\n+ * a separate CSS style resolution step is required.  The resulting attributes might depend on the view that\n+ * originated an operation such as exporting or coping.\n+ * <p>\n+ * This interface is a part of API layer between the model and the view, and only comes to play when the\n+ * model refers to CSS styles.\n+ * Applications should not normally use this interface.\n+ *\/\n+public interface StyleResolver {\n+    \/**\n+     * Resolves CSS styles (when present) to the individual attributes declared in {@link StyleAttributeMap}.\n+     *\n+     * @param attrs the style attributes\n+     * @return the resolved style attributes\n+     *\/\n+    public StyleAttributeMap resolveStyles(StyleAttributeMap attrs);\n+\n+    \/**\n+     * Creates a snapshot of the specified Node to be exported or copied as an image.\n+     *\n+     * @param node the {@link Node} to make a snapshot of\n+     * @return snapshot the generated {@link WritableImage}\n+     *\/\n+    public WritableImage snapshot(Node node);\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/StyleResolver.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext;\n+\n+import jfx.incubator.scene.control.richtext.model.CodeTextModel;\n+import jfx.incubator.scene.control.richtext.model.RichParagraph;\n+\n+\/**\n+ * Decorates plain text by producing a {@link RichParagraph}.\n+ *\/\n+public interface SyntaxDecorator {\n+    \/**\n+     * Creates a {@link RichParagraph} with syntax decoration for the given paragraph index.\n+     * <p>\n+     * For simple cases, when decorations can be generated using the paragraph text,\n+     * it can be obtained by calling {@link CodeTextModel#getPlainText(int)}.\n+     * This string is guaranteed to contain no control symbols except for TAB.\n+     * <p>\n+     * Alternatively, the syntax decorator may cache the syntax information,\n+     * or create {@link Marker}s at critical points in the model, or even perform processing in the background\n+     * (provided the model supports concurrent access), culminating in sending a refresh even in the FX\n+     * application thread by calling\n+     * {@link CodeTextModel#fireChangeEvent(TextPos, TextPos, int, int, int)} method.\n+     *\n+     * @param model the model\n+     * @param index the paragraph index\n+     * @return the decorated {@link RichParagraph} instance\n+     *\/\n+    public RichParagraph createRichParagraph(CodeTextModel model, int index);\n+\n+    \/**\n+     * Receives the updates from the model, before any of the model's\n+     * {@link jfx.incubator.scene.control.richtext.model.StyledTextModel.Listener StyledTextModel.Listener}s\n+     * are notified.\n+     * <p>\n+     * The implementation might do nothing if the syntax can be determined based on the text of a single\n+     * paragraph.  Other implementations, which handle more complex syntax might want to re-build the syntax model\n+     * any time the plain text document changes, should use this method to trigger the refresh.\n+     *\n+     * @param m the model\n+     * @param start start of the affected range\n+     * @param end end of the affected range\n+     * @param charsTop number of characters added before any added paragraphs\n+     * @param linesAdded number of paragraphs inserted\n+     * @param charsBottom number of characters added after any inserted paragraphs\n+     *\/\n+    public void handleChange(CodeTextModel m, TextPos start, TextPos end, int charsTop, int linesAdded, int charsBottom);\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/SyntaxDecorator.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext;\n+\n+\/**\n+ * An immutable position within the text.\n+ * <p>\n+ * Because it is immutable, it cannot track locations in the document which is being edited.\n+ * For that, use {@link Marker}.\n+ *\/\n+public final class TextPos implements Comparable<TextPos> {\n+    \/** A text position at the start of the document. *\/\n+    public static final TextPos ZERO = new TextPos(0, 0, 0, true);\n+    private final int index;\n+    private final int offset;\n+    private final int charIndex;\n+    private final boolean leading;\n+\n+    \/**\n+     * Creates a new text position.\n+     * @param index the paragraph index\n+     * @param offset the text offset\n+     * @param charIndex the character index\n+     * @param leading true if leading\n+     *\/\n+    public TextPos(int index, int offset, int charIndex, boolean leading) {\n+        if (index < 0) {\n+            throw new IllegalArgumentException(\"index cannot be negative\");\n+        } else if (offset < 0) {\n+            throw new IllegalArgumentException(\"offset cannot be negative\");\n+        } else if (charIndex < 0) {\n+            throw new IllegalArgumentException(\"charIndex cannot be negative\");\n+        }\n+        this.index = index;\n+        this.offset = offset;\n+        this.charIndex = charIndex;\n+        this.leading = leading;\n+    }\n+\n+    \/**\n+     * Constructs a new text position.\n+     * @param index the paragraph index\n+     * @param offset the text offset\n+     *\/\n+    public TextPos(int index, int offset) {\n+        this(index, offset, offset, true);\n+    }\n+\n+    \/**\n+     * Returns the model paragraph index.\n+     * @return the paragraph index\n+     *\/\n+    public int index() {\n+        return index;\n+    }\n+\n+    \/**\n+     * Returns the offset into the plain text string (insertion index).\n+     * @return the offset\n+     *\/\n+    public int offset() {\n+        return offset;\n+    }\n+\n+    \/**\n+     * Returns the character index.\n+     * @return the character index\n+     *\/\n+    public int charIndex() {\n+        return charIndex;\n+    }\n+\n+    \/**\n+     * Determines whether the text position is leading or trailing.\n+     * @return true if leading text position\n+     *\/\n+    public boolean isLeading() {\n+        return leading;\n+    }\n+\n+    @Override\n+    public boolean equals(Object x) {\n+        if (x == this) {\n+            return true;\n+        } else if (x instanceof TextPos p) {\n+            return\n+                (index == p.index) &&\n+                (charIndex == p.charIndex) &&\n+                (offset == p.offset) &&\n+                (leading == p.leading);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int h = TextPos.class.hashCode();\n+        h = 31 * h + index;\n+        h = 31 * h + charIndex;\n+        h = 31 * h + offset;\n+        h = 31 * h + (leading ? 1 : 0);\n+        return h;\n+    }\n+\n+    @Override\n+    public int compareTo(TextPos p) {\n+        int d = index - p.index;\n+        if (d == 0) {\n+            int off = offset();\n+            int poff = p.offset();\n+            if (off < poff) {\n+                return -1;\n+            } else if (off > poff) {\n+                return 1;\n+            }\n+            if (leading != p.leading) {\n+                return leading ? 1 : -1;\n+            }\n+            return 0;\n+        }\n+        return d;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return\n+            \"TextPos{\" +\n+            \"ix=\" + index +\n+            \", off=\" + offset +\n+            \", cix=\" + charIndex +\n+            (leading ? \", leading\" : \", trailing\") +\n+            \"}\";\n+    }\n+\n+    \/**\n+     * Returns true if the specified insertion point is the same.\n+     * @param p text position\n+     * @return true if same insertion index\n+     *\/\n+    public boolean isSameInsertionIndex(TextPos p) {\n+        \/\/ added this method in case we need to add leading\/trailing flag\n+        \/\/ semantics of this test is the insertion points are the same.\n+        if (p != null) {\n+            if (index == p.index) {\n+                return (offset == p.offset);\n+            }\n+        }\n+        return false;\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/TextPos.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.util.ArrayList;\n+import java.util.function.Supplier;\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.scene.layout.Region;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * A StyledTextModel based on plain text paragraphs.\n+ * <p>\n+ * This class provides no styling.  Subclasses might override {@link #getParagraph(int)} to provide\n+ * syntax highlighting based on the model content.\n+ * <p>\n+ * This model supports custom content storage mechanism via {@link BasicTextModel.Content}.  By default,\n+ * the model provides an in-memory storage via its {@link BasicTextModel.InMemoryContent} implementation.\n+ *\/\n+public class BasicTextModel extends StyledTextModel {\n+    \/**\n+     * This interface describes the underlying storage mechanism for the BasicTextModel.\n+     *\/\n+    public interface Content {\n+        \/**\n+         * Returns the number of paragraphs in this content.\n+         * @return number of text lines\n+         *\/\n+        public int size();\n+\n+        \/**\n+         * Returns the text string for the specified paragraph index.  The returned text string cannot be null\n+         * and must not contain any control characters other than TAB.\n+         * The caller should never attempt to ask for a paragraph outside of the valid range.\n+         *\n+         * @param index the paragraph index in the range (0...{@link #size()})\n+         * @return the text string or null\n+         *\/\n+        public String getText(int index);\n+\n+        \/**\n+         * This method is called to insert a single text segment at the given position.\n+         *\n+         * @param index the paragraph index\n+         * @param offset the insertion offset within the paragraph\n+         * @param text the text to insert\n+         * @param attrs the style attributes\n+         * @return the number of characters inserted\n+         *\/\n+        public int insertTextSegment(int index, int offset, String text, StyleAttributeMap attrs);\n+\n+        \/**\n+         * Inserts a line break.\n+         *\n+         * @param index the model index\n+         * @param offset the text offset\n+         *\/\n+        public void insertLineBreak(int index, int offset);\n+\n+        \/**\n+         * This method gets called only if the model is editable.\n+         * The caller guarantees that {@code start} precedes {@code end}.\n+         *\n+         * @param start the start of the region to be removed\n+         * @param end the end of the region to be removed, expected to be greater than the start position\n+         *\/\n+        public void removeRange(TextPos start, TextPos end);\n+\n+        \/**\n+         * Determines whether this content supports modification by the user.\n+         * @return true if editable\n+         *\/\n+        public boolean isUserEditable();\n+    }\n+\n+    private final Content content;\n+\n+    \/**\n+     * Constructs an empty model with the specified {@code Content}.\n+     * @param c the content to use\n+     *\/\n+    public BasicTextModel(Content c) {\n+        this.content = c;\n+        registerDataFormatHandler(PlainTextFormatHandler.INSTANCE, true, true, 0);\n+    }\n+\n+    \/**\n+     * Constructs an empty model with the in-memory {@code Content}.\n+     *\/\n+    public BasicTextModel() {\n+        this(new InMemoryContent());\n+    }\n+\n+    \/**\n+     * Inserts text at the specified position.\n+     * This is a convenience shortcut for {@link #replace(StyleResolver, TextPos, TextPos, String, boolean)}.\n+     * @param p the insertion position\n+     * @param text the text to insert\n+     *\/\n+    public void insertText(TextPos p, String text) {\n+        replace(null, p, p, text, false);\n+    }\n+\n+    @Override\n+    public int size() {\n+        return content.size();\n+    }\n+\n+    @Override\n+    public String getPlainText(int index) {\n+        return content.getText(index);\n+    }\n+\n+    @Override\n+    public RichParagraph getParagraph(int index) {\n+        String text = getPlainText(index);\n+        return RichParagraph.builder().\n+            addSegment(text).\n+            build();\n+    }\n+\n+    \/**\n+     * Determines whether the model is user-editable.\n+     * <p>\n+     * This method calls {@link BasicTextModel.Content#isUserEditable()}.\n+     *\n+     * @return true if the model is user-editable\n+     *\/\n+    @Override\n+    public final boolean isUserEditable() {\n+        return content.isUserEditable();\n+    }\n+\n+    @Override\n+    protected int insertTextSegment(int index, int offset, String text, StyleAttributeMap attrs) {\n+        return content.insertTextSegment(index, offset, text, attrs);\n+    }\n+\n+    @Override\n+    protected void insertLineBreak(int index, int offset) {\n+        content.insertLineBreak(index, offset);\n+    }\n+\n+    @Override\n+    protected void removeRange(TextPos start, TextPos end) {\n+        content.removeRange(start, end);\n+    }\n+\n+    @Override\n+    protected void insertParagraph(int index, Supplier<Region> generator) {\n+        \/\/ no-op\n+    }\n+\n+    @Override\n+    public StyleAttributeMap getStyleAttributeMap(StyleResolver resolver, TextPos pos) {\n+        return StyleAttributeMap.EMPTY;\n+    }\n+\n+    @Override\n+    protected final void setParagraphStyle(int index, StyleAttributeMap a) {\n+        \/\/ no-op\n+    }\n+\n+    @Override\n+    protected final void applyStyle(int index, int start, int end, StyleAttributeMap a, boolean merge) {\n+        \/\/ no-op\n+    }\n+\n+    \/**\n+     * This content provides in-memory storage in an {@code ArrayList} of {@code String}s.\n+     *\/\n+    public static class InMemoryContent implements Content {\n+        private final ArrayList<String> paragraphs = new ArrayList<>();\n+\n+        \/** The constructor. *\/\n+        public InMemoryContent() {\n+        }\n+\n+        @Override\n+        public int size() {\n+            int sz = paragraphs.size();\n+            \/\/ empty model always have one line\n+            return sz == 0 ? 1 : sz;\n+        }\n+\n+        @Override\n+        public String getText(int index) {\n+            if (index < paragraphs.size()) {\n+                return paragraphs.get(index);\n+            }\n+            return \"\";\n+        }\n+\n+        @Override\n+        public int insertTextSegment(int index, int offset, String text, StyleAttributeMap attrs) {\n+            String s = getText(index);\n+            String s2 = insertText(s, offset, text);\n+            setText(index, s2);\n+            return text.length();\n+        }\n+\n+        private static String insertText(String text, int offset, String toInsert) {\n+            if (offset >= text.length()) {\n+                return text + toInsert;\n+            } else {\n+                return text.substring(0, offset) + toInsert + text.substring(offset);\n+            }\n+        }\n+\n+        @Override\n+        public void insertLineBreak(int index, int offset) {\n+            if (index >= paragraphs.size()) {\n+                paragraphs.add(\"\");\n+            } else {\n+                String s = paragraphs.get(index);\n+                if (offset >= s.length()) {\n+                    paragraphs.add(index + 1, \"\");\n+                } else {\n+                    setText(index, s.substring(0, offset));\n+                    paragraphs.add(index + 1, s.substring(offset));\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void removeRange(TextPos start, TextPos end) {\n+            int ix = start.index();\n+            String text = getText(ix);\n+            String newText;\n+\n+            if (ix == end.index()) {\n+                int len = text.length();\n+                if (end.offset() >= len) {\n+                    newText = text.substring(0, start.offset());\n+                } else {\n+                    newText = text.substring(0, start.offset()) + text.substring(end.offset());\n+                }\n+                setText(ix, newText);\n+            } else {\n+                newText = text.substring(0, start.offset()) + paragraphs.get(end.index()).substring(end.offset());\n+                setText(ix, newText);\n+\n+                int ct = end.index() - ix;\n+                ix++;\n+                for (int i = 0; i < ct; i++) {\n+                    paragraphs.remove(ix);\n+                }\n+            }\n+        }\n+\n+        private void setText(int index, String text) {\n+            if (index < paragraphs.size()) {\n+                paragraphs.set(index, text);\n+            } else {\n+                \/\/ due to emulated empty paragraph in an empty model\n+                paragraphs.add(text);\n+            }\n+        }\n+\n+        @Override\n+        public boolean isUserEditable() {\n+            return true;\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/BasicTextModel.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.util.Set;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import jfx.incubator.scene.control.richtext.SyntaxDecorator;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * Editable plain text model with optional syntax highlighting for use with the\n+ * {@link jfx.incubator.scene.control.richtext.CodeArea CodeArea} control.\n+ * <p>\n+ * This model supports custom content storage mechanism via {@link BasicTextModel.Content}.  By default,\n+ * the model provides an in-memory storage via its {@link BasicTextModel.InMemoryContent} implementation.\n+ *\/\n+public class CodeTextModel extends BasicTextModel {\n+    private SimpleObjectProperty<SyntaxDecorator> decorator;\n+    private static final Set<StyleAttribute<?>> SUPPORTED = initSupportedAttributes();\n+\n+    \/**\n+     * Constructs the CodeTextModel with an in-memory content.\n+     *\/\n+    public CodeTextModel() {\n+    }\n+\n+    \/**\n+     * Constructs the CodeTextModel with the specified content.\n+     * @param c the content\n+     *\/\n+    public CodeTextModel(BasicTextModel.Content c) {\n+        super(c);\n+    }\n+\n+    \/\/ only a subset of attributes are supported\n+    private static Set<StyleAttribute<?>> initSupportedAttributes() {\n+        return Set.of(\n+            StyleAttributeMap.BOLD,\n+            StyleAttributeMap.ITALIC,\n+            StyleAttributeMap.STRIKE_THROUGH,\n+            StyleAttributeMap.TEXT_COLOR,\n+            StyleAttributeMap.UNDERLINE\n+        );\n+    }\n+\n+    @Override\n+    protected Set<StyleAttribute<?>> getSupportedAttributes() {\n+        return SUPPORTED;\n+    }\n+\n+    @Override\n+    public final RichParagraph getParagraph(int index) {\n+        SyntaxDecorator d = getDecorator();\n+        if (d == null) {\n+            return super.getParagraph(index);\n+        } else {\n+            return d.createRichParagraph(this, index);\n+        }\n+    }\n+\n+    \/**\n+     * Syntax decorator applies styling to the plain text stored in the model.\n+     * @return the syntax decorator value (may be null)\n+     *\/\n+    public final ObjectProperty<SyntaxDecorator> decoratorProperty() {\n+        if (decorator == null) {\n+            decorator = new SimpleObjectProperty<>() {\n+                @Override\n+                protected void invalidated() {\n+                    TextPos end = getDocumentEnd();\n+                    SyntaxDecorator d = get();\n+                    if (d != null) {\n+                        d.handleChange(CodeTextModel.this, TextPos.ZERO, end, 0, 0, 0);\n+                    }\n+                    fireStyleChangeEvent(TextPos.ZERO, end);\n+                }\n+            };\n+        }\n+        return decorator;\n+    }\n+\n+    public final SyntaxDecorator getDecorator() {\n+        return decorator == null ? null : decorator.get();\n+    }\n+\n+    public final void setDecorator(SyntaxDecorator d) {\n+        decoratorProperty().set(d);\n+    }\n+\n+    @Override\n+    public void fireChangeEvent(TextPos start, TextPos end, int charsTop, int linesAdded, int charsBottom) {\n+        SyntaxDecorator d = getDecorator();\n+        if (d != null) {\n+            d.handleChange(this, start, end, charsTop, linesAdded, charsBottom);\n+        }\n+        super.fireChangeEvent(start, end, charsTop, linesAdded, charsBottom);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/CodeTextModel.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * Contains information about {@link StyledTextModel} content change.\n+ * <p>\n+ * This class represents two kinds of changes made to the model: one that modifies the textual content\n+ * and embedded Nodes, and one that only changes styling of the content.\n+ * <p>\n+ * A content change can be though of as a replacement of content between the two positions\n+ * {@code start} and {@code end} with a different styled content (or no content).\n+ * The change object does not include the actual content, but only the information about inserted symbols:\n+ * <ul>\n+ * <li>the number of characters inserted to the first affected paragraph\n+ * <li>the number of complete paragraphs inserted\n+ * <li>the number of characters inserted into the first paragraph following the inserted lines\n+ * <\/ul>\n+ * The following diagram illustrates the inserted content relative to the start position (S) and\n+ * the end position (E):\n+ * <pre>\n+ * .......STTTTTTT\n+ * AAAAAAAAAAAAAAA\n+ * AAAAAAAAAAAAAAA\n+ * BBBE...........\n+ * <\/pre>\n+ * Where T are the characters inserted following the start position, A are the inserted complete paragraphs,\n+ * and B are the characters inserted at the beginning of the paragraph that contains the end position.\n+ *\n+ * @since 999 TODO\n+ *\/\n+public abstract class ContentChange {\n+    private final TextPos start;\n+    private final TextPos end;\n+\n+    private ContentChange(TextPos start, TextPos end) {\n+        this.start = start;\n+        this.end = end;\n+    }\n+\n+    \/**\n+     * Returns the start position.\n+     * @return the start position\n+     *\/\n+    public TextPos getStart() {\n+        return start;\n+    }\n+\n+    \/**\n+     * Returns the end position.\n+     * @return the end position\n+     *\/\n+    public TextPos getEnd() {\n+        return end;\n+    }\n+\n+    \/**\n+     * The number of characters added at the end of the paragraph which contains the start position.\n+     * @return the number of characters inserted\n+     *\/\n+    public int getCharsAddedTop() {\n+        return 0;\n+    }\n+\n+    \/**\n+     * The number of whole paragraphs inserted.\n+     * @return the number of paragraphs\n+     *\/\n+    public int getLinesAdded() {\n+        return 0;\n+    }\n+\n+    \/**\n+     * The number of characters added at the beginning of the existing paragraph which contains the end position.\n+     * @return the number of characters\n+     *\/\n+    public int getCharsAddedBottom() {\n+        return 0;\n+    }\n+\n+    \/**\n+     * Determines whether the change is an edit (true) or affects styling only (false).\n+     * @return true if change affects stylint only\n+     *\/\n+    public boolean isEdit() {\n+        return true;\n+    }\n+\n+    \/**\n+     * Creates the content change event which represents an edit.\n+     *\n+     * @param start the start position\n+     * @param end the end position\n+     * @param charsAddedTop the number of characters appended to the paragraph containing the start position\n+     * @param linesAdded the number of full paragraphs inserted\n+     * @param charsAddedBottom the number of characters inserted at the beginning of the paragraph containing the end position\n+     * @return the change instance\n+     *\/\n+    public static ContentChange ofEdit(TextPos start, TextPos end, int charsAddedTop, int linesAdded, int charsAddedBottom) {\n+        return new ContentChange(start, end) {\n+            @Override\n+            public int getCharsAddedTop() {\n+                return charsAddedTop;\n+            }\n+\n+            @Override\n+            public int getLinesAdded() {\n+                return linesAdded;\n+            }\n+\n+            @Override\n+            public int getCharsAddedBottom() {\n+                return charsAddedBottom;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Creates the content change event which represents a styling update.\n+     *\n+     * @param start the start position\n+     * @param end the end position\n+     * @return the change instance\n+     *\/\n+    public static ContentChange ofStyleChange(TextPos start, TextPos end) {\n+        return new ContentChange(start, end) {\n+            @Override\n+            public boolean isEdit() {\n+                return false;\n+            }\n+        };\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/ContentChange.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import javafx.scene.input.DataFormat;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * Facilitates import\/export of styled text into\/from a StyledTextModel.\n+ *\/\n+public abstract class DataFormatHandler {\n+    \/**\n+     * Creates a StyledInput for the given input string.  When pasting, the caller may pass\n+     * the style attributes {@code attr} at the insertion point.  This argument may be used by\n+     * the implementation if the format contains no styles on its own (for example, in the plain text format case).\n+     *\n+     * @param input the input string\n+     * @param attr the style attributes (can be null)\n+     * @return the StyledInput\n+     * @throws IOException when operation is not supported or an I\/O error occurs\n+     * @throws UnsupportedOperationException if the copy operation is not supported\n+     *\/\n+    public abstract StyledInput createStyledInput(String input, StyleAttributeMap attr) throws IOException;\n+\n+    \/**\n+     * Creates an object to be put into the Clipboard for the given text range.\n+     * The caller must guarantee that the {@code start} precedes the {@code end} position.\n+     * <p>\n+     * Typically, the implementation creates an instance of {@link StyledOutput} and calls\n+     * {@link StyledTextModel#export(TextPos, TextPos, StyledOutput)} method.\n+     *\n+     * @param model source model\n+     * @param resolver view-specific style resolver\n+     * @param start start text position\n+     * @param end end text position\n+     * @return an object to be placed to the Clipboard\n+     * @throws IOException when an I\/O error occurs\n+     * @throws UnsupportedOperationException if the copy operation is not supported\n+     *\/\n+    public abstract Object copy(\n+        StyledTextModel model,\n+        StyleResolver resolver,\n+        TextPos start,\n+        TextPos end\n+    ) throws IOException;\n+\n+    \/**\n+     * Save the text range in the handler's format to the output stream (e.g. save to file).\n+     * The caller must guarantee that the {@code start} precedes the {@code end} position.\n+     * It is the responsibility of the caller to close the {@code OutputStream}.\n+     * <p>\n+     * Typically, the implementation creates an instance of {@link StyledOutput} and calls\n+     * {@link StyledTextModel#export(TextPos, TextPos, StyledOutput)} method.\n+     *\n+     * @param model source model\n+     * @param resolver view-specific style resolver\n+     * @param start start text position\n+     * @param end end text position\n+     * @param out target {@code OutputStream}\n+     * @throws IOException when an I\/O error occurs\n+     * @throws UnsupportedOperationException if the copy operation is not supported\n+     *\/\n+    public abstract void save(\n+        StyledTextModel model,\n+        StyleResolver resolver,\n+        TextPos start,\n+        TextPos end,\n+        OutputStream out\n+    ) throws IOException;\n+\n+    private final DataFormat format;\n+\n+    \/**\n+     * Creates a DataHandler instance for the specified format.\n+     * @param f data format\n+     *\/\n+    public DataFormatHandler(DataFormat f) {\n+        this.format = f;\n+    }\n+\n+    \/**\n+     * Returns the {@link DataFormat} associated with this handler.\n+     * @return the data format\n+     *\/\n+    public final DataFormat getDataFormat() {\n+        return format;\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/DataFormatHandler.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import javafx.scene.input.DataFormat;\n+import com.sun.jfx.incubator.scene.control.richtext.HtmlStyledOutput;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * This partial {@link DataFormatHandler} supports export of styled text in a simple HTML format.\n+ *\/\n+public class HtmlExportFormatHandler extends DataFormatHandler {\n+    \/** when true, style attributes are inlined, this seems to work better in Thunderbird *\/\n+    private static final boolean INLINE_STYLES = true;\n+    \/** The singleton instance of {@code HtmlExportFormatHandler}. *\/\n+    public static final HtmlExportFormatHandler INSTANCE = new HtmlExportFormatHandler();\n+\n+    \/** The constructor *\/\n+    private HtmlExportFormatHandler() {\n+        super(DataFormat.HTML);\n+    }\n+\n+    @Override\n+    public StyledInput createStyledInput(String input, StyleAttributeMap attr) {\n+        throw new UnsupportedOperationException(\"import from HTML is not supported by this DataFormatHandler\");\n+    }\n+\n+    @Override\n+    public Object copy(StyledTextModel model, StyleResolver resolver, TextPos start, TextPos end) throws IOException {\n+        StringWriter wr = new StringWriter(65536);\n+        export(model, resolver, start, end, wr);\n+        return wr.toString();\n+    }\n+\n+    @Override\n+    public void save(StyledTextModel model, StyleResolver resolver, TextPos start, TextPos end, OutputStream out)\n+        throws IOException {\n+        Charset ascii = Charset.forName(\"ASCII\");\n+        OutputStreamWriter wr = new OutputStreamWriter(out, ascii);\n+        export(model, resolver, start, end, wr);\n+    }\n+\n+    private void export(StyledTextModel model, StyleResolver resolver, TextPos start, TextPos end, Writer wr)\n+        throws IOException {\n+        HtmlStyledOutput out = new HtmlStyledOutput(resolver, wr, INLINE_STYLES);\n+        \/\/ collect styles\n+        model.export(start, end, out.firstPassBuilder());\n+\n+        out.writePrologue();\n+        model.export(start, end, out);\n+        out.writeEpilogue();\n+        out.flush();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/HtmlExportFormatHandler.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+\/**\n+ * Paragraph direction attribute.\n+ *\/\n+public enum ParagraphDirection {\n+    \/** Indicates the left-to-right writing direction. *\/\n+    LEFT_TO_RIGHT,\n+    \/** Indicates the right-to-left writing direction. *\/\n+    RIGHT_TO_LEFT\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/ParagraphDirection.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import javafx.scene.input.DataFormat;\n+import com.sun.jfx.incubator.scene.control.richtext.StringBuilderStyledOutput;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * {@link DataFormatHandler} which operates with plain text.\n+ *\/\n+public class PlainTextFormatHandler extends DataFormatHandler {\n+    \/** The singleton instance of {@code PlainTextFormatHandler}. *\/\n+    public static final PlainTextFormatHandler INSTANCE = new PlainTextFormatHandler();\n+\n+    \/** The constructor. *\/\n+    private PlainTextFormatHandler() {\n+        super(DataFormat.PLAIN_TEXT);\n+    }\n+\n+    @Override\n+    public StyledInput createStyledInput(String text, StyleAttributeMap attr) {\n+        return StyledInput.of(text, attr);\n+    }\n+\n+    @Override\n+    public Object copy(StyledTextModel m, StyleResolver resolver, TextPos start, TextPos end) throws IOException {\n+        StringBuilderStyledOutput out = new StringBuilderStyledOutput();\n+        m.export(start, end, out);\n+        return out.toString();\n+    }\n+\n+    @Override\n+    public void save(StyledTextModel m, StyleResolver resolver, TextPos start, TextPos end, OutputStream out) throws IOException {\n+        Charset charset = Charset.forName(\"utf-8\");\n+        byte[] newline = System.getProperty(\"line.separator\").getBytes(charset);\n+\n+        StyledOutput so = new StyledOutput() {\n+            @Override\n+            public void consume(StyledSegment seg) throws IOException {\n+                switch (seg.getType()) {\n+                case LINE_BREAK:\n+                    out.write(newline);\n+                    break;\n+                case TEXT:\n+                    String text = seg.getText();\n+                    byte[] b = text.getBytes(charset);\n+                    out.write(b);\n+                    break;\n+                }\n+            }\n+\n+            @Override\n+            public void flush() throws IOException {\n+                out.flush();\n+            }\n+\n+            @Override\n+            public void close() throws IOException {\n+                out.close();\n+            }\n+        };\n+        m.export(start, end, so);\n+        out.flush();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/PlainTextFormatHandler.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,403 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javafx.scene.Node;\n+import javafx.scene.layout.Region;\n+import javafx.scene.paint.Color;\n+import com.sun.jfx.incubator.scene.control.richtext.RichParagraphHelper;\n+import com.sun.jfx.incubator.scene.control.richtext.TextCell;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+\n+\/**\n+ * Represents a single immutable paragraph within the {@code StyledModel}.\n+ * A single paragraph may contain either:\n+ * <ul>\n+ * <li>A number of {@code StyledSegments} such as styled text or {@code Supplier}s of embedded {@code Node}s\n+ * <li>A supplier of a single {@code Region} which fills the entire paragraph\n+ * <\/ul>\n+ *\/\n+public abstract class RichParagraph {\n+    static { initAccessor(); }\n+\n+    \/**\n+     * The constructor.\n+     *\/\n+    public RichParagraph() {\n+    }\n+\n+    \/**\n+     * Creates a paragraph consisting of a single Rectangle.\n+     * The paragraph will typically assume its Rectangle preferred size, or,\n+     * when the text wrap mode is on, might get resized to fit the available width.\n+     * <p>\n+     * The supplied generator must not cache or keep reference to the created Node,\n+     * but the created Node can keep a reference to the model or a property therein.\n+     * <p>\n+     * For example, a bidirectional binding between an inline control and some property in the model\n+     * would synchronize the model with all the views that use it.\n+     *\n+     * @param paragraphGenerator the content generator\n+     * @return the RichParagraph instance\n+     *\/\n+    public static RichParagraph of(Supplier<Region> paragraphGenerator) {\n+        return new RichParagraph() {\n+            @Override\n+            public final Supplier<Region> getParagraphRegion() {\n+                return paragraphGenerator;\n+            }\n+\n+            @Override\n+            public final String getPlainText() {\n+                return \"\";\n+            }\n+\n+            @Override\n+            public void export(int start, int end, StyledOutput out) throws IOException {\n+                StyledSegment seg = StyledSegment.ofRegion(paragraphGenerator);\n+                out.consume(seg);\n+            }\n+\n+            @Override\n+            List<StyledSegment> getSegments() {\n+                return null;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Returns the generator for this paragraph {@code Region} representation.\n+     * This method returns a non-null value when the paragraph is represented by a single {@code Region}.\n+     *\n+     * @return the generator, or null\n+     *\/\n+    public Supplier<Region> getParagraphRegion() {\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the plain text of this paragraph, or null.\n+     * @return the plain text\n+     *\/\n+    public abstract String getPlainText();\n+\n+    \/\/ this method could be made public, as long as the returned list is made immutable\n+    abstract List<StyledSegment> getSegments();\n+\n+    \/**\n+     * Returns the paragraph attributes.\n+     * @return the paragraph attributes, can be null\n+     *\/\n+    public StyleAttributeMap getParagraphAttributes() {\n+        return null;\n+    }\n+\n+    List<Consumer<TextCell>> getHighlights() {\n+        return null;\n+    }\n+\n+    \/\/ for use by StyledTextModel\n+    void export(int start, int end, StyledOutput out) throws IOException {\n+        List<StyledSegment> segments = getSegments();\n+        if (segments == null) {\n+            out.consume(StyledSegment.of(\"\"));\n+        } else {\n+            int off = 0;\n+            int sz = segments.size();\n+            for (int i = 0; i < sz; i++) {\n+                StyledSegment seg = segments.get(i);\n+                String text = seg.getText();\n+                int len = (text == null ? 0 : text.length());\n+                if (start <= (off + len)) {\n+                    int ix0 = Math.max(0, start - off);\n+                    int ix1 = Math.min(len, end - off);\n+                    if (ix1 > ix0) {\n+                        StyledSegment ss = seg.subSegment(ix0, ix1);\n+                        out.consume(ss);\n+                    }\n+                }\n+                off += len;\n+                if (off >= end) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ for use by SimpleReadOnlyStyledModel\n+    StyleAttributeMap getStyleAttributeMap(StyleResolver resolver, int offset) {\n+        int off = 0;\n+        List<StyledSegment> segments = getSegments();\n+        if (segments != null) {\n+            int sz = segments.size();\n+            for (int i = 0; i < sz; i++) {\n+                StyledSegment seg = segments.get(i);\n+                int len = seg.getTextLength();\n+                if (offset < (off + len) || (i == sz - 1)) {\n+                    return seg.getStyleAttributeMap(resolver);\n+                }\n+                off += len;\n+            }\n+        }\n+        return StyleAttributeMap.EMPTY;\n+    }\n+\n+    private static void initAccessor() {\n+        RichParagraphHelper.setAccessor(new RichParagraphHelper.Accessor() {\n+            @Override\n+            public List<StyledSegment> getSegments(RichParagraph p) {\n+                return p.getSegments();\n+            }\n+\n+            @Override\n+            public List<Consumer<TextCell>> getHighlights(RichParagraph p) {\n+                return p.getHighlights();\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Creates an instance of the {@code Builder} class.\n+     * @return the new Builder instance\n+     *\/\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    \/**\n+     * Utility class for building immutable {@code RichParagraph}s.\n+     *\/\n+    public static class Builder {\n+        private ArrayList<StyledSegment> segments;\n+        private ArrayList<Consumer<TextCell>> highlights;\n+        private StyleAttributeMap paragraphAttributes;\n+\n+        Builder() {\n+        }\n+\n+        \/**\n+         * Adds a squiggly line (as seen in a spell checker) with the given color.\n+         * @param start the start offset\n+         * @param length the end offset\n+         * @param color the background color\n+         * @return this {@code Builder} instance\n+         *\/\n+        public Builder addSquiggly(int start, int length, Color color) {\n+            int end = start + length;\n+            highlights().add((cell) -> {\n+                cell.addSquiggly(start, end, color);\n+            });\n+            return this;\n+        }\n+\n+        private List<Consumer<TextCell>> highlights() {\n+            if (highlights == null) {\n+                highlights = new ArrayList<>(4);\n+            }\n+            return highlights;\n+        }\n+\n+        \/**\n+         * Adds a text segment with no styling (i.e. using default style).\n+         * This convenience method is equivalent to calling {@code addSegment(text, StyleAttributeMap.EMPTY);}\n+         *\n+         * @param text the text to append, must not contain {@code \\n}, cannot be null\n+         * @return this {@code Builder} instance\n+         *\/\n+        public Builder addSegment(String text) {\n+            StyledSegment seg = StyledSegment.of(text);\n+            segments().add(seg);\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a styled text segment.\n+         *\n+         * @param text non-null text string\n+         * @param css array of style names, cannot be null\n+         * @return this {@code Builder} instance\n+         *\/\n+        public Builder withStyles(String text, String ... css) {\n+            Objects.nonNull(text);\n+            Objects.nonNull(css);\n+            StyleAttributeMap a = StyleAttributeMap.fromStyles(null, css);\n+            addSegment(text, a);\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a styled text segment.\n+         *\n+         * @param text non-null text string\n+         * @param style direct style (such as {@code -fx-fill:red;}), or null\n+         * @param css array of style names, or null\n+         * @return this {@code Builder} instance\n+         *\/\n+        public Builder withInlineAndExternalStyles(String text, String style, String ... css) {\n+            Objects.nonNull(text);\n+            StyleAttributeMap a = StyleAttributeMap.fromStyles(style, css);\n+            addSegment(text, a);\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a styled text segment, styled with the inline style.\n+         *\n+         * @param text non-null text string\n+         * @param style the inline style (example {@code \"-fx-fill:red;\"}), or null\n+         * @return this {@code Builder} instance\n+         *\/\n+        public Builder withInlineStyle(String text, String style) {\n+            Objects.nonNull(text);\n+            StyleAttributeMap a = StyleAttributeMap.fromStyles(style);\n+            addSegment(text, a);\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a styled text segment.\n+         *\n+         * @param text the text to append, must not contain {@code \\n}, cannot be null\n+         * @param attrs the styled attributes, cannot be null\n+         * @return this {@code Builder} instance\n+         *\/\n+        public Builder addSegment(String text, StyleAttributeMap attrs) {\n+            Objects.nonNull(text);\n+            Objects.nonNull(attrs);\n+            StyledSegment seg = StyledSegment.of(text, attrs);\n+            segments().add(seg);\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a styled text segment.\n+         * @param text the source non-null string\n+         * @param start the start offset of the input string\n+         * @param end the end offset of the input string\n+         * @param attrs the styled attributes\n+         * @return this {@code Builder} instance\n+         *\/\n+        public Builder addSegment(String text, int start, int end, StyleAttributeMap attrs) {\n+            Objects.nonNull(text);\n+            String s = text.substring(start, end);\n+            addSegment(s, attrs);\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a color background highlight.\n+         * Use translucent colors to enable multiple highlights in the same region of text.\n+         * @param start the start offset\n+         * @param length the end offset\n+         * @param color the background color\n+         * @return this {@code Builder} instance\n+         *\/\n+        public Builder addHighlight(int start, int length, Color color) {\n+            int end = start + length;\n+            highlights().add((cell) -> {\n+                cell.addHighlight(start, end, color);\n+            });\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds an inline node.\n+         * <p>\n+         * The supplied generator must not cache or keep reference to the created Node,\n+         * but the created Node can keep a reference to the model or some property therein.\n+         * <p>\n+         * For example, a bidirectional binding between an inline control and some property in the model\n+         * would synchronize the model with all the views that use it.\n+         * @param generator the generator that provides the actual {@code Node}\n+         * @return this {@code Builder} instance\n+         *\/\n+        public Builder addInlineNode(Supplier<Node> generator) {\n+            StyledSegment seg = StyledSegment.ofInlineNode(generator);\n+            segments().add(seg);\n+            return this;\n+        }\n+\n+        private List<StyledSegment> segments() {\n+            if (segments == null) {\n+                segments = new ArrayList<>(8);\n+            }\n+            return segments;\n+        }\n+\n+        \/**\n+         * Sets the paragraph attributes.\n+         * @param a the paragraph attributes\n+         * @return this {@code Builder} instance\n+         *\/\n+        public Builder setParagraphAttributes(StyleAttributeMap a) {\n+            paragraphAttributes = a;\n+            return this;\n+        }\n+\n+        \/**\n+         * Creates an instance of immutable {@code RichParagraph} from information\n+         * in this {@code Builder}.\n+         * @return the new paragraph instance\n+         *\/\n+        public RichParagraph build() {\n+            return new RichParagraph() {\n+                @Override\n+                public StyleAttributeMap getParagraphAttributes() {\n+                    return paragraphAttributes;\n+                }\n+\n+                @Override\n+                List<StyledSegment> getSegments() {\n+                    return segments;\n+                }\n+\n+                @Override\n+                public String getPlainText() {\n+                    if (segments == null) {\n+                        return \"\";\n+                    }\n+\n+                    StringBuilder sb = new StringBuilder();\n+                    for (StyledSegment seg : segments) {\n+                        sb.append(seg.getText());\n+                    }\n+                    return sb.toString();\n+                }\n+\n+                @Override\n+                List<Consumer<TextCell>> getHighlights() {\n+                    return highlights;\n+                }\n+            };\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/RichParagraph.java","additions":403,"deletions":0,"binary":false,"changes":403,"status":"added"},{"patch":"@@ -0,0 +1,634 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import javafx.scene.input.DataFormat;\n+import javafx.scene.paint.Color;\n+import javafx.scene.text.TextAlignment;\n+import javafx.util.StringConverter;\n+import javafx.util.converter.DoubleStringConverter;\n+import com.sun.jfx.incubator.scene.control.richtext.Converters;\n+import com.sun.jfx.incubator.scene.control.richtext.RichTextFormatHandlerHelper;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * A DataFormatHandler for use with attribute-based rich text models.\n+ * <p>\n+ * The handler uses a simple text-based format:<p>\n+ * (*) denotes an optional element.\n+ * <pre>\n+ * PARAGRAPH[]\n+ *\n+ * PARAGRAPH: {\n+ *     PARAGRAPH_ATTRIBUTE[]*,\n+ *     TEXT_SEGMENT[],\n+ *     \"\\n\"\n+ * }\n+ *\n+ * PARAGRAPH_ATTRIBUTE: {\n+ *     \"{!\"\n+ *     (name)\n+ *     ATTRIBUTE_VALUE[]*\n+ *     \"}\"\n+ * }\n+ *\n+ * ATTRIBUTE: {\n+ *     \"{\"\n+ *     (name)\n+ *     ATTRIBUTE_VALUE[]*\n+ *     \"}\"\n+ * }\n+ *\n+ * ATTRIBUTE_VALUE: {\n+ *     |\n+ *     (value)\n+ * }\n+ *\n+ * TEXT_SEGMENT: {\n+ *     ATTRIBUTE[]*\n+ *     (text string with escaped special characters)\n+ * }\n+ * <\/pre>\n+ * Attribute sequences are further deduplicated, using a single {number} token\n+ * which specifies the index into the list of unique sets of attributes.\n+ * Paragraph attribute sets are treated as separate from the segment attrubite sets.\n+ * <p>\n+ * The following characters are escaped in text segments: {,%,}\n+ * The escape format is %XX where XX is a hexadecimal value.\n+ * <p>\n+ * Example:\n+ * <pre>\n+ * {c|ff00ff}text{b}bold{!rtl}\\n\n+ * {1}line 2{!0}\\n\n+ * <\/pre>\n+ *\/\n+public class RichTextFormatHandler extends DataFormatHandler {\n+    static { initAccessor(); }\n+\n+    private static final boolean DEBUG = false;\n+\n+    \/** The data format identifier *\/\n+    public static final DataFormat DATA_FORMAT = new DataFormat(\"application\/x-com-oracle-editable-rich-text\");\n+\n+    private static final StringConverter<Boolean> BOOLEAN_CONVERTER = Converters.booleanConverter();\n+    private static final StringConverter<Color> COLOR_CONVERTER = Converters.colorConverter();\n+    private static final StringConverter<ParagraphDirection> DIRECTION_CONVERTER = Converters.paragraphDirectionConverter();\n+    private static final DoubleStringConverter DOUBLE_CONVERTER = new DoubleStringConverter();\n+    private static final StringConverter<String> STRING_CONVERTER = Converters.stringConverter();\n+    private static final StringConverter<TextAlignment> TEXT_ALIGNMENT_CONVERTER = Converters.textAlignmentConverter();\n+    \/\/ String -> Handler\n+    \/\/ StyleAttribute -> Handler\n+    private final HashMap<Object,Handler> handlers = new HashMap<>(64);\n+\n+    \/** The singleton instance of {@code RtfFormatHandler}. *\/\n+    public static final RichTextFormatHandler INSTANCE = new RichTextFormatHandler();\n+\n+    \/**\n+     * Constructor.\n+     *\/\n+    private RichTextFormatHandler() {\n+        super(DATA_FORMAT);\n+\n+        addHandlerBoolean(StyleAttributeMap.BOLD, \"b\");\n+        addHandler(StyleAttributeMap.BACKGROUND, \"bg\", COLOR_CONVERTER);\n+        addHandlerString(StyleAttributeMap.BULLET, \"bullet\");\n+        addHandlerString(StyleAttributeMap.FONT_FAMILY, \"ff\");\n+        addHandler(StyleAttributeMap.FIRST_LINE_INDENT, \"firstIndent\", DOUBLE_CONVERTER);\n+        addHandler(StyleAttributeMap.FONT_SIZE, \"fs\", DOUBLE_CONVERTER);\n+        addHandlerBoolean(StyleAttributeMap.ITALIC, \"i\");\n+        addHandler(StyleAttributeMap.LINE_SPACING, \"lineSpacing\", DOUBLE_CONVERTER);\n+        addHandler(StyleAttributeMap.PARAGRAPH_DIRECTION, \"dir\", DIRECTION_CONVERTER);\n+        addHandler(StyleAttributeMap.SPACE_ABOVE, \"spaceAbove\", DOUBLE_CONVERTER);\n+        addHandler(StyleAttributeMap.SPACE_BELOW, \"spaceBelow\", DOUBLE_CONVERTER);\n+        addHandler(StyleAttributeMap.SPACE_LEFT, \"spaceLeft\", DOUBLE_CONVERTER);\n+        addHandler(StyleAttributeMap.SPACE_RIGHT, \"spaceRight\", DOUBLE_CONVERTER);\n+        addHandlerBoolean(StyleAttributeMap.STRIKE_THROUGH, \"ss\");\n+        addHandler(StyleAttributeMap.TEXT_ALIGNMENT, \"alignment\", TEXT_ALIGNMENT_CONVERTER);\n+        addHandler(StyleAttributeMap.TEXT_COLOR, \"tc\", COLOR_CONVERTER);\n+        addHandlerBoolean(StyleAttributeMap.UNDERLINE, \"u\");\n+    }\n+\n+    private static void initAccessor() {\n+        RichTextFormatHandlerHelper.setAccessor(new RichTextFormatHandlerHelper.Accessor() {\n+            @Override\n+            public StyledOutput createStyledOutput(RichTextFormatHandler h, StyleResolver r, Writer wr) {\n+                return h.createStyledOutput(r, wr);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public StyledInput createStyledInput(String input, StyleAttributeMap attr) {\n+        return new RichStyledInput(input);\n+    }\n+\n+    @Override\n+    public Object copy(StyledTextModel m, StyleResolver r, TextPos start, TextPos end) throws IOException {\n+        StringWriter wr = new StringWriter();\n+        StyledOutput so = createStyledOutput(r, wr);\n+        m.export(start, end, so);\n+        return wr.toString();\n+    }\n+\n+    @Override\n+    public void save(StyledTextModel m, StyleResolver r, TextPos start, TextPos end, OutputStream out) throws IOException {\n+        Charset cs = Charset.forName(\"utf-8\");\n+        Writer wr = new OutputStreamWriter(out, cs);\n+        StyledOutput so = createStyledOutput(r, wr);\n+        m.export(start, end, so);\n+    }\n+\n+    private StyledOutput createStyledOutput(StyleResolver r, Writer wr) {\n+        Charset cs = Charset.forName(\"utf-8\");\n+        boolean buffered = isBuffered(wr);\n+        if (buffered) {\n+            return new RichStyledOutput(r, wr);\n+        } else {\n+            wr = new BufferedWriter(wr);\n+            return new RichStyledOutput(r, wr);\n+        }\n+    }\n+\n+    private static boolean isBuffered(Writer x) {\n+        return\n+            (x instanceof BufferedWriter) ||\n+            (x instanceof StringWriter);\n+    }\n+\n+    \/** attribute handler *\/\n+    static class Handler<T> {\n+        private final String id;\n+        private final StyleAttribute<T> attribute;\n+        private final StringConverter<T> converter;\n+\n+        public Handler(StyleAttribute<T> attribute, String id, StringConverter<T> converter) {\n+            this.id = id;\n+            this.attribute = attribute;\n+            this.converter = converter;\n+        }\n+\n+        public String getId() {\n+            return id;\n+        }\n+\n+        public StyleAttribute<T> getStyleAttribute() {\n+            return attribute;\n+        }\n+\n+        public boolean isAllowed(T value) {\n+            return true;\n+        }\n+\n+        public String write(T value) {\n+            return converter.toString(value);\n+        }\n+\n+        public T read(String s) {\n+            return converter.fromString(s);\n+        }\n+    }\n+\n+    private <T> void addHandler(StyleAttribute<T> a, String id, StringConverter<T> converter) {\n+        addHandler(new Handler<T>(a, id, converter));\n+    }\n+\n+    private <T> void addHandler(Handler<T> h) {\n+        handlers.put(h.getStyleAttribute(), h);\n+        handlers.put(h.getId(), h);\n+    }\n+\n+    private void addHandlerBoolean(StyleAttribute<Boolean> a, String id) {\n+        addHandler(new Handler<Boolean>(a, id, BOOLEAN_CONVERTER) {\n+            @Override\n+            public boolean isAllowed(Boolean value) {\n+                return Boolean.TRUE.equals(value);\n+            }\n+        });\n+    }\n+\n+    private void addHandlerString(StyleAttribute<String> a, String id) {\n+        addHandler(new Handler<String>(a, id, STRING_CONVERTER));\n+    }\n+\n+    private static void log(Object x) {\n+        if (DEBUG) {\n+            System.err.println(x);\n+        }\n+    }\n+\n+    \/** exporter *\/\n+    private class RichStyledOutput implements StyledOutput {\n+        private final StyleResolver resolver;\n+        private final Writer wr;\n+        private HashMap<StyleAttributeMap, Integer> styles = new HashMap<>();\n+\n+        public RichStyledOutput(StyleResolver r, Writer wr) {\n+            this.resolver = r;\n+            this.wr = wr;\n+        }\n+\n+        @Override\n+        public void consume(StyledSegment seg) throws IOException {\n+            switch (seg.getType()) {\n+            case INLINE_NODE:\n+                \/\/ TODO\n+                log(\"ignoring embedded node\");\n+                break;\n+            case LINE_BREAK:\n+                wr.write(\"\\n\");\n+                break;\n+            case PARAGRAPH_ATTRIBUTES:\n+                {\n+                    StyleAttributeMap attrs = seg.getStyleAttributeMap(resolver);\n+                    emitAttributes(attrs, true);\n+                }\n+                break;\n+            case REGION:\n+                \/\/ TODO\n+                break;\n+            case TEXT:\n+                {\n+                    StyleAttributeMap attrs = seg.getStyleAttributeMap(resolver);\n+                    emitAttributes(attrs, false);\n+\n+                    String text = seg.getText();\n+                    text = encode(text);\n+                    wr.write(text);\n+                }\n+                break;\n+            }\n+        }\n+\n+        private void emitAttributes(StyleAttributeMap attrs, boolean forParagraph) throws IOException {\n+            if ((attrs != null) && (!attrs.isEmpty())) {\n+                Integer num = styles.get(attrs);\n+                if (num == null) {\n+                    \/\/ new style, gets numbered and added to the cache\n+                    int sz = styles.size();\n+                    styles.put(attrs, Integer.valueOf(sz));\n+\n+                    ArrayList<StyleAttribute<?>> as = new ArrayList<>(attrs.getAttributes());\n+                    \/\/ sort by name to make serialized output stable\n+                    \/\/ the overhead is very low since this is done once per style\n+                    Collections.sort(as, new Comparator<StyleAttribute<?>>() {\n+                        @Override\n+                        public int compare(StyleAttribute<?> a, StyleAttribute<?> b) {\n+                            String sa = a.getName();\n+                            String sb = b.getName();\n+                            return sa.compareTo(sb);\n+                        }\n+                    });\n+\n+                    for (StyleAttribute<?> a : as) {\n+                        Handler h = handlers.get(a);\n+                        try {\n+                            if (h != null) {\n+                                Object v = attrs.get(a);\n+                                if (h.isAllowed(v)) {\n+                                    wr.write('{');\n+                                    if (forParagraph) {\n+                                        wr.write('!');\n+                                    }\n+                                    wr.write(h.getId());\n+                                    String ss = h.write(v);\n+                                    if (ss != null) {\n+                                        wr.write('|');\n+                                        wr.write(encode(ss));\n+                                    }\n+                                    wr.write('}');\n+                                }\n+                                continue;\n+                            }\n+                        } catch (Exception e) {\n+                            log(e);\n+                        }\n+                        \/\/ ignoring this attribute\n+                        log(\"failed to emit \" + a + \", skipping\");\n+                    }\n+                } else {\n+                    \/\/ cached style, emit the id\n+                    wr.write('{');\n+                    if (forParagraph) {\n+                        wr.write('!');\n+                    }\n+                    wr.write(String.valueOf(num));\n+                    wr.write('}');\n+                }\n+            } else if (forParagraph) {\n+                \/\/ this special token clears the paragraph attributes\n+                wr.write(\"{!}\");\n+            }\n+        }\n+\n+        private static String encode(String text) {\n+            if (text == null) {\n+                return \"\";\n+            }\n+\n+            int ix = indexOfSpecialChar(text);\n+            if (ix < 0) {\n+                return text;\n+            }\n+\n+            int len = text.length();\n+            StringBuilder sb = new StringBuilder(len + 32);\n+            if (ix > 0) {\n+                sb.append(text.substring(0, ix));\n+            }\n+\n+            for (int i = ix; i < len; i++) {\n+                char c = text.charAt(i);\n+                if (isSpecialChar(c)) {\n+                    sb.append(String.format(\"%%%02X\", (int)c));\n+                } else {\n+                    sb.append(c);\n+                }\n+            }\n+            return sb.toString();\n+        }\n+\n+        private static int indexOfSpecialChar(String text) {\n+            int len = text.length();\n+            for (int i = 0; i < len; i++) {\n+                char c = text.charAt(i);\n+                if (isSpecialChar(c)) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        private static boolean isSpecialChar(char c) {\n+            switch (c) {\n+            case '{':\n+            case '}':\n+            case '%':\n+            case '|':\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public void flush() throws IOException {\n+            wr.flush();\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            wr.close();\n+        }\n+    }\n+\n+    \/** importer *\/\n+    private class RichStyledInput implements StyledInput {\n+        private final String text;\n+        private int index;\n+        private StringBuilder sb;\n+        private final ArrayList<StyleAttributeMap> styles = new ArrayList<>();\n+        private int line = 1;\n+\n+        public RichStyledInput(String text) {\n+            this.text = text;\n+        }\n+\n+        @Override\n+        public StyledSegment nextSegment() {\n+            try {\n+                int c = charAt(0);\n+                switch (c) {\n+                case -1:\n+                    return null;\n+                case '\\n':\n+                    index++;\n+                    line++;\n+                    return StyledSegment.LINE_BREAK;\n+                case '{':\n+                    StyleAttributeMap a = parseAttributes(true);\n+                    if (a != null) {\n+                        if (a.isEmpty()) {\n+                            a = null;\n+                        }\n+                        return StyledSegment.ofParagraphAttributes(a);\n+                    } else {\n+                        a = parseAttributes(false);\n+                        String text = decodeText();\n+                        return StyledSegment.of(text, a);\n+                    }\n+                }\n+                String text = decodeText();\n+                return StyledSegment.of(text);\n+            } catch (IOException e) {\n+                err(e);\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+        }\n+\n+        private StyleAttributeMap parseAttributes(boolean forParagraph) throws IOException {\n+            StyleAttributeMap.Builder b = null;\n+            for (;;) {\n+                int c = charAt(0);\n+                if (c != '{') {\n+                    break;\n+                }\n+                c = charAt(1);\n+                if (forParagraph) {\n+                    if (c == '!') {\n+                        index++;\n+                    } else {\n+                        break;\n+                    }\n+                } else {\n+                    if (c == '!') {\n+                        throw err(\"unexpected paragraph attribute\");\n+                    }\n+                }\n+                index++;\n+\n+                int ix = text.indexOf('}', index);\n+                if (ix < 0) {\n+                    throw err(\"missing }\");\n+                }\n+                String s = text.substring(index, ix);\n+                if (s.length() == 0) {\n+                    if (forParagraph) {\n+                        index = ix + 1;\n+                        \/\/ special token clears paragraph attributes\n+                        return StyleAttributeMap.EMPTY;\n+                    } else {\n+                        throw err(\"empty attribute name\");\n+                    }\n+                }\n+                int n = parseStyleNumber(s);\n+                if (n < 0) {\n+                    \/\/ parse the attribute\n+                    String name;\n+                    String args;\n+                    int j = s.indexOf('|');\n+                    if (j < 0) {\n+                        name = s;\n+                        args = null;\n+                    } else {\n+                        name = s.substring(0, j);\n+                        args = s.substring(j + 1);\n+                    }\n+\n+                    Handler h = handlers.get(name);\n+                    if (h == null) {\n+                        \/\/ silently ignore the attribute\n+                        log(\"ignoring attribute: \" + name);\n+                    } else {\n+                        Object v = h.read(args);\n+                        StyleAttribute a = h.getStyleAttribute();\n+                        if (a.isParagraphAttribute() != forParagraph) {\n+                            throw err(\"paragraph type mismatch\");\n+                        }\n+                        if (b == null) {\n+                            b = StyleAttributeMap.builder();\n+                        }\n+                        b.set(a, v);\n+                    }\n+                    index = ix + 1;\n+                } else {\n+                    index = ix + 1;\n+                    \/\/ get style from cache\n+                    return styles.get(n);\n+                }\n+            }\n+            if (b == null) {\n+                return null;\n+            }\n+            StyleAttributeMap attrs = b.build();\n+            styles.add(attrs);\n+            return attrs;\n+        }\n+\n+        private int charAt(int delta) {\n+            int ix = index + delta;\n+            if (ix >= text.length()) {\n+                return -1;\n+            }\n+            return text.charAt(ix);\n+        }\n+\n+        private String decodeText() throws IOException {\n+            int start = index;\n+            for(;;) {\n+                int c = charAt(0);\n+                switch(c) {\n+                case '\\n':\n+                case '{':\n+                case -1:\n+                    return text.substring(start, index);\n+                case '%':\n+                    return decodeText(start, index);\n+                }\n+                index++;\n+            }\n+        }\n+\n+        private String decodeText(int start, int ix) throws IOException {\n+            if (sb == null) {\n+                sb = new StringBuilder();\n+            }\n+            if (ix > start) {\n+                sb.append(text, start, ix);\n+            }\n+            for (;;) {\n+                int c = charAt(0);\n+                switch (c) {\n+                case '\\n':\n+                case '{':\n+                case -1:\n+                    String s = sb.toString();\n+                    sb.setLength(0);\n+                    return s;\n+                case '%':\n+                    index++;\n+                    int ch = decodeHexByte();\n+                    sb.append((char)ch);\n+                    break;\n+                }\n+                index++;\n+            }\n+        }\n+\n+        private int decodeHexByte() throws IOException {\n+            int ch = decodeHex(charAt(0)) << 4;\n+            index++;\n+            ch += decodeHex(charAt(0));\n+            return ch;\n+        }\n+\n+        private static int decodeHex(int ch) throws IOException {\n+            int c = ch - '0'; \/\/ 0...9\n+            if ((c >= 0) && (c <= 9)) {\n+                return c;\n+            }\n+            c = ch - 55; \/\/ handle A...F\n+            if ((c >= 10) && (c <= 15)) {\n+                return c;\n+            }\n+            c = ch - 97; \/\/ handle a...f\n+            if ((c >= 10) && (c <= 15)) {\n+                return c;\n+            }\n+            throw new IOException(\"not a hex char:\" + ch);\n+        }\n+\n+        private int parseStyleNumber(String s) throws IOException {\n+            if (Character.isDigit(s.charAt(0))) {\n+                int n;\n+                try {\n+                    return Integer.parseInt(s);\n+                } catch (NumberFormatException e) {\n+                    throw err(\"invalid style number \" + s);\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        private IOException err(Object text) {\n+            return new IOException(\"malformed input: \" + text + \", line \" + line);\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/RichTextFormatHandler.java","additions":634,"deletions":0,"binary":false,"changes":634,"status":"added"},{"patch":"@@ -0,0 +1,790 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import javafx.scene.layout.Region;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * Editable, in-memory {@link StyledTextModel} based on a collection of styled segments.\n+ * <p>\n+ * This model is suitable for relatively small documents as it has neither disk storage backing\n+ * nor storage of incremental changes.\n+ *\/\n+public class RichTextModel extends StyledTextModel {\n+    private final ArrayList<RParagraph> paragraphs = new ArrayList<>();\n+    private final HashMap<StyleAttributeMap,StyleAttributeMap> styleCache = new HashMap<>();\n+\n+    \/**\n+     * Constructs the empty model.\n+     *\/\n+    public RichTextModel() {\n+        registerDataFormatHandler(RichTextFormatHandler.INSTANCE, true, true, 2000);\n+        registerDataFormatHandler(RtfFormatHandler.INSTANCE, true, true, 1000);\n+        registerDataFormatHandler(HtmlExportFormatHandler.INSTANCE, true, false, 100);\n+        registerDataFormatHandler(PlainTextFormatHandler.INSTANCE, true, true, 0);\n+        \/\/ always has at least one paragraph\n+        paragraphs.add(new RParagraph());\n+    }\n+\n+    @Override\n+    public final boolean isUserEditable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return paragraphs.size();\n+    }\n+\n+    @Override\n+    public String getPlainText(int index) {\n+        return paragraphs.get(index).getPlainText();\n+    }\n+\n+    @Override\n+    public int getParagraphLength(int index) {\n+        return paragraphs.get(index).getTextLength();\n+    }\n+\n+    @Override\n+    public RichParagraph getParagraph(int index) {\n+        RParagraph p = paragraphs.get(index);\n+        return p.createRichParagraph();\n+    }\n+\n+    @Override\n+    protected int insertTextSegment(int index, int offset, String text, StyleAttributeMap attrs) {\n+        attrs = dedup(attrs);\n+        RParagraph par = paragraphs.get(index);\n+        par.insertText(offset, text, attrs);\n+        return text.length();\n+    }\n+\n+    @Override\n+    protected void insertLineBreak(int index, int offset) {\n+        if (index >= size()) {\n+            \/\/ unlikely to happen\n+            RParagraph par = new RParagraph();\n+            paragraphs.add(par);\n+        } else {\n+            RParagraph par = paragraphs.get(index);\n+            RParagraph par2 = par.insertLineBreak(offset);\n+            paragraphs.add(index + 1, par2);\n+        }\n+    }\n+\n+    @Override\n+    protected void removeRange(TextPos start, TextPos end) {\n+        int ix = start.index();\n+        RParagraph par = paragraphs.get(ix);\n+\n+        if (ix == end.index()) {\n+            par.removeSpan(start.offset(), end.offset());\n+        } else {\n+            RParagraph last = paragraphs.get(end.index());\n+            last.removeSpan(0, end.offset());\n+\n+            par.removeSpan(start.offset(), Integer.MAX_VALUE);\n+            par.append(last);\n+\n+            int ct = end.index() - ix;\n+            ix++;\n+            for (int i = 0; i < ct; i++) {\n+                paragraphs.remove(ix);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void insertParagraph(int index, Supplier<Region> generator) {\n+        \/\/ TODO\n+    }\n+\n+    \/** deduplicates style attributes. *\/\n+    private StyleAttributeMap dedup(StyleAttributeMap a) {\n+        \/\/ the expectation is that the number of different style combinations is relatively low\n+        \/\/ but the number of instances can be large\n+        \/\/ the drawback is that there is no way to clear the cache\n+        StyleAttributeMap cached = styleCache.get(a);\n+        if (cached != null) {\n+            return cached;\n+        }\n+        styleCache.put(a, a);\n+        return a;\n+    }\n+\n+    @Override\n+    protected void setParagraphStyle(int index, StyleAttributeMap attrs) {\n+        paragraphs.get(index).setParagraphAttributes(attrs);\n+    }\n+\n+    @Override\n+    protected void applyStyle(int index, int start, int end, StyleAttributeMap attrs, boolean merge) {\n+        paragraphs.get(index).applyStyle(start, end, attrs, merge, this::dedup);\n+    }\n+\n+    @Override\n+    public StyleAttributeMap getStyleAttributeMap(StyleResolver resolver, TextPos pos) {\n+        int index = pos.index();\n+        if (index < paragraphs.size()) {\n+            int off = pos.offset();\n+            RParagraph par = paragraphs.get(index);\n+            StyleAttributeMap pa = par.getParagraphAttributes();\n+            StyleAttributeMap a = par.getStyleAttributeMap(off);\n+            if (pa == null) {\n+                return a;\n+            } else {\n+                return pa.combine(a);\n+            }\n+        }\n+        return StyleAttributeMap.EMPTY;\n+    }\n+\n+    \/**\n+     * Temporary method added for testing; will be removed in production.\n+     * @param model the model\n+     * @param out the output\n+     *\/\n+    \/\/ TODO remove later\n+    @Deprecated\n+    public static void dump(StyledTextModel model, PrintStream out) {\n+        if (model instanceof RichTextModel m) {\n+            m.dump(out);\n+        }\n+    }\n+\n+    private void dump(PrintStream out) {\n+        out.println(\"[\");\n+        for (RParagraph p : paragraphs) {\n+            dump(p, out);\n+        }\n+        out.println(\"]\");\n+    }\n+\n+    private void dump(RParagraph p, PrintStream out) {\n+        out.println(\"  {paragraphAttrs=\" + p.getParagraphAttributes() + \", segments=[\");\n+        for(RSegment s: p) {\n+            out.println(\"    {text=\\\"\" + s.text() + \"\\\", attr=\" + s.getStyleAttributeMap() + \"},\");\n+        }\n+        out.println(\"  ]}\");\n+    }\n+\n+    \/**\n+     * Represents a rich text segment having the same style attributes.\n+     *\/\n+    private static class RSegment {\n+        private String text;\n+        private StyleAttributeMap attrs;\n+\n+        public RSegment(String text, StyleAttributeMap attrs) {\n+            this.text = text;\n+            this.attrs = attrs;\n+        }\n+\n+        public String text() {\n+            return text;\n+        }\n+\n+        public StyleAttributeMap attrs() {\n+            return attrs;\n+        }\n+\n+        public void setAttrs(StyleAttributeMap a) {\n+            attrs = a;\n+        }\n+\n+        public StyleAttributeMap getStyleAttributeMap() {\n+            return attrs;\n+        }\n+\n+        public int getTextLength() {\n+            return text.length();\n+        }\n+\n+        \/** returns true if this segment becomes empty as a result *\/\n+        \/\/ TODO unit test\n+        public boolean removeRegion(int start, int end) {\n+            int len = text.length();\n+            if (end > len) {\n+                end = len;\n+            }\n+\n+            if (start == 0) {\n+                if (end < len) {\n+                    text = text.substring(end);\n+                } else {\n+                    text = \"\";\n+                }\n+            } else {\n+                if (end < len) {\n+                    text = text.substring(0, start) + text.substring(end, len);\n+                } else {\n+                    text = text.substring(0, start);\n+                }\n+            }\n+\n+            return (text.length() == 0);\n+        }\n+\n+        public void append(String s) {\n+            text = text + s;\n+        }\n+\n+        public void setText(String s) {\n+            text = s;\n+        }\n+    }\n+\n+    \/**\n+     * Model paragraph is a list of RSegments.\n+     *\/\n+    static class RParagraph extends ArrayList<RSegment> {\n+\n+        private StyleAttributeMap paragraphAttrs;\n+\n+        \/** Creates an instance *\/\n+        public RParagraph() {\n+        }\n+\n+        public StyleAttributeMap getParagraphAttributes() {\n+            return paragraphAttrs;\n+        }\n+\n+        public void setParagraphAttributes(StyleAttributeMap a) {\n+            paragraphAttrs = a;\n+        }\n+\n+        public String getPlainText() {\n+            StringBuilder sb = new StringBuilder();\n+            for(RSegment s: this) {\n+                sb.append(s.text());\n+            }\n+            return sb.toString();\n+        }\n+\n+        public int getTextLength() {\n+            int len = 0;\n+            for(RSegment s: this) {\n+                len += s.getTextLength();\n+            }\n+            return len;\n+        }\n+\n+        \/**\n+         * Retrieves the style attributes from the previous character (or next, if at the beginning).\n+         * @param offset the offset\n+         * @return the style info\n+         *\/\n+        public StyleAttributeMap getStyleAttributeMap(int offset) {\n+            int off = 0;\n+            int ct = size();\n+            for (int i = 0; i < ct; i++) {\n+                RSegment seg = get(i);\n+                int len = seg.getTextLength();\n+                if (offset < (off + len) || (i == ct - 1)) {\n+                    return seg.getStyleAttributeMap();\n+                }\n+                off += len;\n+            }\n+            return StyleAttributeMap.EMPTY;\n+        }\n+\n+        \/**\n+         * Inserts styled text at the specified offset.\n+         * @param offset the insertion offset\n+         * @param text the plain text\n+         * @param attrs the style attributes\n+         *\/\n+        public void insertText(int offset, String text, StyleAttributeMap attrs) {\n+            int off = 0;\n+            int ct = size();\n+            for (int i = 0; i < ct; i++) {\n+                if (offset == off) {\n+                    \/\/ insert at the beginning\n+                    insertSegment2(i, text, attrs);\n+                    return;\n+                } else {\n+                    RSegment seg = get(i);\n+                    int len = seg.getTextLength();\n+                    if ((offset > off) && (offset <= off + len)) {\n+                        \/\/ split segment\n+                        StyleAttributeMap a = seg.attrs();\n+                        String toSplit = seg.text();\n+                        int ix = offset - off;\n+\n+                        String s1 = toSplit.substring(0, ix);\n+                        set(i++, new RSegment(s1, a));\n+                        if (insertSegment2(i, text, attrs)) {\n+                            i++;\n+                        }\n+                        if (ix < toSplit.length()) {\n+                            String s2 = toSplit.substring(ix);\n+                            insertSegment2(i, s2, a);\n+                        }\n+                        return;\n+                    }\n+\n+                    off += len;\n+                }\n+            }\n+\n+            \/\/ insert at the end\n+            insertSegment2(ct, text, attrs);\n+        }\n+\n+        \/**\n+         * Inserts a new segment, or merges with adjacent segment if styles are the same.\n+         * Returns true if a segment has been added.\n+         * @param ix the segment index\n+         * @param text the plain text\n+         * @param a the style attributes\n+         * @return true if a segment has been added.\n+         *\/\n+        private boolean insertSegment2(int ix, String text, StyleAttributeMap a) {\n+            if (ix == 0) {\n+                \/\/ FIX aaaa combine with insertSegment\n+                if (ix < size()) {\n+                    RSegment seg = get(ix);\n+                    if (seg.getTextLength() == 0) {\n+                        \/\/ replace zero width segment\n+                        seg.setText(text);\n+                        seg.setAttrs(a);\n+                        return false;\n+                    } else if (a.equals(seg.attrs())) {\n+                        \/\/ combine\n+                        seg.setText(text + seg.text());\n+                        return false;\n+                    }\n+                }\n+            } else if (ix > 0) {\n+                RSegment prev = get(ix - 1);\n+                if (a.equals(prev.attrs())) {\n+                    \/\/ combine\n+                    prev.append(text);\n+                    return false;\n+                }\n+            }\n+\n+            RSegment seg = new RSegment(text, a);\n+            if (ix < size()) {\n+                add(ix, seg);\n+            } else {\n+                add(seg);\n+            }\n+            return true;\n+        }\n+\n+        \/**\n+         * inserts a new segment with the specified, deduplicated attributes.\n+         * if the new style is the same as the previous segment, merges text with the previous segment instead.\n+         * @return true if the new segment has been merged with the previous segment\n+         *\/\n+        \/\/ TODO should it also merge with the next segment if the styles are the same?\n+        \/\/ in this case it's better to return an int which is the amount of segments added\/removed\n+        private boolean insertSegment(int ix, String text, StyleAttributeMap a) {\n+            \/\/ TODO deal with zero width segment\n+            \/\/ FIX aaaa combine with insertSegment2\n+            if (ix > 0) {\n+                RSegment prev = get(ix - 1);\n+                if (prev.attrs().equals(a)) {\n+                    \/\/ merge\n+                    prev.append(text);\n+                    return true;\n+                }\n+            }\n+            RSegment seg = new RSegment(text, a);\n+            if (ix >= size()) {\n+                add(seg);\n+            } else {\n+                add(ix, seg);\n+            }\n+            return false;\n+        }\n+\n+        \/**\n+         * Trims this paragraph and returns the remaining text to be inserted after the line break.\n+         * @param offset the offset\n+         * @return the remaining portion of paragraph\n+         *\/\n+        public RParagraph insertLineBreak(int offset) {\n+            RParagraph next = new RParagraph();\n+            next.setParagraphAttributes(getParagraphAttributes());\n+\n+            int off = 0;\n+            int i;\n+            int ct = size();\n+            for (i = 0; i < ct; i++) {\n+                RSegment seg = get(i);\n+                int len = seg.getTextLength();\n+                if (offset < (off + len)) {\n+                    if (offset != off) {\n+                        \/\/ split segment\n+                        StyleAttributeMap a = seg.attrs();\n+                        String toSplit = seg.text();\n+                        int ix = offset - off;\n+                        String s1 = toSplit.substring(0, ix);\n+                        String s2 = toSplit.substring(ix);\n+                        set(i, new RSegment(s1, a));\n+\n+                        next.add(new RSegment(s2, a));\n+                        i++;\n+                    }\n+                    break;\n+                }\n+                off += len;\n+            }\n+\n+            \/\/ move remaining segments to the next paragraph\n+            while (i < size()) {\n+                RSegment seg = remove(i);\n+                next.add(seg);\n+            }\n+\n+            \/\/ preserve attributes using zero width segment\n+            if (size() == 0) {\n+                if (next.size() > 0) {\n+                    StyleAttributeMap a = next.get(0).getStyleAttributeMap();\n+                    add(new RSegment(\"\", a));\n+                }\n+            }\n+            if (next.size() == 0) {\n+                if (size() > 0) {\n+                    StyleAttributeMap a = get(size() - 1).getStyleAttributeMap();\n+                    next.add(new RSegment(\"\", a));\n+                }\n+            }\n+\n+            return next;\n+        }\n+\n+        \/**\n+         * Appends the specified paragraph by adding all of its segments.\n+         * @param p the paragraph to append\n+         *\/\n+        public void append(RParagraph p) {\n+            if (isMerge(p)) {\n+                int sz = p.size();\n+                for(int i=0; i<sz; i++) {\n+                    RSegment seg = p.get(i);\n+                    if(i == 0) {\n+                        \/\/ merge\n+                        RSegment last = get(size() - 1);\n+                        last.append(seg.text());\n+                    } else {\n+                        add(seg);\n+                    }\n+                }\n+                return;\n+            } else if (isZeroWidth()) {\n+                \/\/ remove zero width paragraph as it's no longer needed\n+                clear();\n+            }\n+            \/\/ TODO merge with previous?\n+            addAll(p);\n+        }\n+\n+        private boolean isMerge(RParagraph p) {\n+            if(size() == 0) {\n+                return false; \/\/ should never happen\n+            } else if(p.size() == 0) {\n+                return false; \/\/ should never happen\n+            }\n+            return get(size() - 1).getStyleAttributeMap().equals(p.get(0).getStyleAttributeMap());\n+        }\n+\n+        private boolean isZeroWidth() {\n+            if (size() == 1) {\n+                if (get(0).getTextLength() == 0) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        \/\/ TODO keep zero width segment with attributes\n+        public void removeSpan(int start, int end) {\n+            if (start == end) {\n+                \/\/ no change\n+                return;\n+            }\n+\n+            int ix0 = -1;\n+            int off0 = 0;\n+            int off = 0;\n+            int ct = size();\n+\n+            \/\/ find start segment\n+            int i = 0;\n+            for (; i < ct; i++) {\n+                RSegment seg = get(i);\n+                int len = seg.getTextLength();\n+                if (start < (off + len)) {\n+                    ix0 = i;\n+                    off0 = start - off;\n+                    break;\n+                }\n+                off += len;\n+            }\n+\n+            if (ix0 < 0) {\n+                \/\/ start not found\n+                return;\n+            }\n+\n+            \/\/ find end segment\n+            int ix1 = -1;\n+            int off1 = -1;\n+            for (; i < ct; i++) {\n+                RSegment seg = get(i);\n+                int len = seg.getTextLength();\n+                if (end <= (off + len)) {\n+                    ix1 = i;\n+                    off1 = end - off;\n+                    break;\n+                }\n+                off += len;\n+            }\n+\n+            if (ix0 == ix1) {\n+                \/\/ same segment\n+                RSegment seg = get(ix0);\n+                if (seg.removeRegion(off0, off1)) {\n+                    remove(ix0);\n+                    if (size() == 0) {\n+                        \/\/ keep attributes in a zero width segment\n+                        add(new RSegment(\"\", seg.getStyleAttributeMap()));\n+                    }\n+                }\n+            } else {\n+                \/\/ spans multiple segments\n+                \/\/ first segment\n+                RSegment seg = get(ix0);\n+                if (seg.removeRegion(off0, Integer.MAX_VALUE)) {\n+                    remove(ix0);\n+                    ix1--;\n+                    ct--;\n+                } else {\n+                    ix0++;\n+                }\n+                \/\/ last segment\n+                if (ix1 < 0) {\n+                    ix1 = ct;\n+                } else {\n+                    RSegment seg2 = get(ix1);\n+                    if (seg2.removeRegion(0, off1)) {\n+                        remove(ix1);\n+                        \/\/ TODO check for zero segment\n+                    }\n+                }\n+                \/\/ remove in-between segments\n+                removeRange(ix0, ix1);\n+                if (size() == 0) {\n+                    \/\/ keep attributes in a zero width segment\n+                    add(new RSegment(\"\", seg.getStyleAttributeMap()));\n+                }\n+            }\n+        }\n+\n+        public void applyStyle(int start, int end, StyleAttributeMap attrs, boolean merge, Function<StyleAttributeMap,StyleAttributeMap> dedup) {\n+            int off = 0;\n+            int i = 0;\n+            for ( ; i < size(); i++) {\n+                RSegment seg = get(i);\n+                int len = seg.getTextLength();\n+                int cs = whichCase(off, off + len, start, end);\n+                switch (cs) {\n+                case 0:\n+                    break;\n+                case 1:\n+                case 2:\n+                    if (applyStyle(i, seg, attrs, merge, dedup)) {\n+                        i--;\n+                    }\n+                    break;\n+                case 3:\n+                case 9:\n+                    applyStyle(i, seg, attrs, merge, dedup);\n+                    return;\n+                case 4:\n+                case 8:\n+                    \/\/ split\n+                    {\n+                        StyleAttributeMap a = seg.attrs();\n+                        StyleAttributeMap newAttrs = dedup.apply(merge ? a.combine(attrs) : attrs);\n+                        int ix = end - off;\n+                        String s1 = seg.text().substring(0, ix);\n+                        String s2 = seg.text().substring(ix);\n+                        remove(i);\n+                        if (insertSegment(i++, s1, newAttrs)) {\n+                            i--;\n+                        }\n+                        if (insertSegment(i, s2, a)) {\n+                            i--;\n+                        }\n+                    }\n+                    return;\n+                case 5:\n+                case 6:\n+                    \/\/ split\n+                    {\n+                        StyleAttributeMap a = seg.attrs();\n+                        StyleAttributeMap newAttrs = dedup.apply(merge ? a.combine(attrs) : attrs);\n+                        int ix = start - off;\n+                        String s1 = seg.text().substring(0, ix);\n+                        String s2 = seg.text().substring(ix);\n+                        remove(i);\n+                        if (insertSegment(i++, s1, a)) {\n+                            i--;\n+                        }\n+                        if (insertSegment(i, s2, newAttrs)) {\n+                            i--;\n+                        }\n+                    }\n+                    if (cs == 6) {\n+                        return;\n+                    }\n+                    break;\n+                case 7:\n+                    {\n+                        StyleAttributeMap a = seg.attrs();\n+                        StyleAttributeMap newAttrs = dedup.apply(merge ? a.combine(attrs) : attrs);\n+                        String text = seg.text();\n+                        int ix0 = start - off;\n+                        int ix1 = end - off;\n+                        String s1 = text.substring(0, ix0);\n+                        String s2 = text.substring(ix0, ix1);\n+                        String s3 = text.substring(ix1);\n+                        remove(i);\n+                        if (insertSegment(i++, s1, a)) {\n+                            i--;\n+                        }\n+                        if (insertSegment(i++, s2, newAttrs)) {\n+                            i--;\n+                        }\n+                        if (insertSegment(i, s3, a)) {\n+                            i--;\n+                        }\n+                    }\n+                    return;\n+                default:\n+                    throw new Error(\"?\" + cs);\n+                }\n+\n+                off += len;\n+            }\n+        }\n+\n+        \/**\n+         * Applies style to the segment.\n+         * If the new style is exactly the same as the style of the previous segment,\n+         * it simply merges the two segments.\n+         * @param ix the paragraph index\n+         * @param seg the segment\n+         * @param a the attributes\n+         * @param merge whether to merge or set\n+         * @param dedup the deduplicator\n+         * @return true if this segment has been merged with the previous segment\n+         *\/\n+        private boolean applyStyle(int ix, RSegment seg, StyleAttributeMap a, boolean merge, Function<StyleAttributeMap,StyleAttributeMap> dedup) {\n+            StyleAttributeMap newAttrs = dedup.apply(merge ? seg.attrs().combine(a) : a);\n+            if (ix > 0) {\n+                RSegment prev = get(ix - 1);\n+                if (prev.attrs().equals(newAttrs)) {\n+                    \/\/ merge\n+                    prev.append(seg.text());\n+                    remove(ix);\n+                    return true;\n+                }\n+            }\n+            seg.setAttrs(newAttrs);\n+            return false;\n+        }\n+\n+        \/**\n+         * <pre>\n+         * paragraph:    [=============]\n+         * case:\n+         *         0:                      |-\n+         *         1:  -------------------->\n+         *         2:    |----------------->\n+         *         3:    |-------------|\n+         *         4:    |--------|\n+         *         5:        |------------->\n+         *         6:        |---------|\n+         *         7:        |----|\n+         *         8:  -----------|\n+         *         9:  ----------------|\n+         *\/\n+        private static int whichCase(int off, int max, int start, int end) {\n+            \/\/ TODO unit test!\n+            if (start >= max) {\n+                return 0;\n+            } else if (start < off) {\n+                if (end > max) {\n+                    return 1;\n+                } else if (end < max) {\n+                    return 8;\n+                } else {\n+                    return 9;\n+                }\n+            } else if (start > off) {\n+                if (end > max) {\n+                    return 5;\n+                } else if (end < max) {\n+                    return 7;\n+                } else {\n+                    return 6;\n+                }\n+            } else {\n+                if (end > max) {\n+                    return 2;\n+                } else if (end < max) {\n+                    return 4;\n+                } else {\n+                    return 3;\n+                }\n+            }\n+        }\n+\n+        private RichParagraph createRichParagraph() {\n+            RichParagraph.Builder b = RichParagraph.builder();\n+            for (RSegment seg : this) {\n+                String text = seg.text();\n+                StyleAttributeMap a = seg.attrs();\n+                b.addSegment(text, a);\n+            }\n+            b.setParagraphAttributes(paragraphAttrs);\n+            return b.build();\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/RichTextModel.java","additions":790,"deletions":0,"binary":false,"changes":790,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import javafx.scene.input.DataFormat;\n+import com.sun.jfx.incubator.scene.control.richtext.RtfStyledOutput;\n+import com.sun.jfx.incubator.scene.control.richtext.rtf.RTFReader;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * This {@link DataFormatHandler} provides export\/import support for RTF format.\n+ *\/\n+\/\/ TODO import is not yet working...\n+public class RtfFormatHandler extends DataFormatHandler {\n+    \/** The singleton instance of {@code RtfFormatHandler}. *\/\n+    public static final RtfFormatHandler INSTANCE = new RtfFormatHandler();\n+\n+    \/** The constructor *\/\n+    private RtfFormatHandler() {\n+        super(DataFormat.RTF);\n+    }\n+\n+    @Override\n+    public StyledInput createStyledInput(String text, StyleAttributeMap attr) throws IOException {\n+        try (RTFReader rd = new RTFReader(text)) {\n+            return rd.generateStyledInput();\n+        }\n+    }\n+\n+    @Override\n+    public Object copy(StyledTextModel model, StyleResolver resolver, TextPos start, TextPos end) throws IOException {\n+        StringWriter wr = new StringWriter(65536);\n+        export(model, resolver, start, end, wr);\n+        return wr.toString();\n+    }\n+\n+    @Override\n+    public void save(StyledTextModel model, StyleResolver resolver, TextPos start, TextPos end, OutputStream out)\n+        throws IOException {\n+        Charset ascii = Charset.forName(\"ASCII\");\n+        OutputStreamWriter wr = new OutputStreamWriter(out, ascii);\n+        export(model, resolver, start, end, wr);\n+    }\n+\n+    private void export(StyledTextModel model, StyleResolver resolver, TextPos start, TextPos end, Writer wr)\n+        throws IOException {\n+        RtfStyledOutput out = new RtfStyledOutput(resolver, wr);\n+        \/\/ collect styles\n+        model.export(start, end, out.firstPassBuilder());\n+\n+        out.writePrologue();\n+        model.export(start, end, out);\n+        out.writeEpilogue();\n+        out.flush();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/RtfFormatHandler.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,543 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javafx.scene.Node;\n+import javafx.scene.image.Image;\n+import javafx.scene.layout.Region;\n+import javafx.scene.paint.Color;\n+import com.sun.jfx.incubator.scene.control.richtext.ImageCellPane;\n+import com.sun.jfx.incubator.scene.control.richtext.TextCell;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * A simple, view-only, in-memory, styled text model.\n+ *\/\n+public class SimpleViewOnlyStyledModel extends StyledTextModelViewOnlyBase {\n+    private final ArrayList<Paragraph> paragraphs = new ArrayList<>();\n+\n+    \/**\n+     * The constructor.\n+     *\/\n+    public SimpleViewOnlyStyledModel() {\n+    }\n+\n+    \/**\n+     * Creates the model from the supplied text string by breaking it down into individual text segments.\n+     * @param text the input multi-line text\n+     * @return the new instance\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    public static SimpleViewOnlyStyledModel from(String text) throws IOException {\n+        SimpleViewOnlyStyledModel m = new SimpleViewOnlyStyledModel();\n+        BufferedReader rd = new BufferedReader(new StringReader(text));\n+        String s;\n+        while ((s = rd.readLine()) != null) {\n+            m.addSegment(s);\n+            m.nl();\n+        }\n+        return m;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return paragraphs.size();\n+    }\n+\n+    @Override\n+    public String getPlainText(int index) {\n+        return paragraphs.get(index).getPlainText();\n+    }\n+\n+    @Override\n+    public RichParagraph getParagraph(int index) {\n+        return paragraphs.get(index).toRichParagraph();\n+    }\n+\n+    \/**\n+     * Appends a text segment to the last paragraph.\n+     * The {@code text} cannot contain newline ({@code \\n}) symbols.\n+     * This convenience method is equivalent to calling {@code addSegment(text, StyleAttributeMap.EMPTY);}\n+     *\n+     * @param text the text to append, must not contain {@code \\n}, cannot be null\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel addSegment(String text) {\n+        Objects.requireNonNull(text);\n+        return addSegment(text, StyleAttributeMap.EMPTY);\n+    }\n+\n+    \/**\n+     * Appends a text segment styled with either inline style or external style names (or both).\n+     * The {@code text} cannot contain newline ({@code \\n}) symbols.\n+     *\n+     * @param text the text to append, must not contain {@code \\n}, cannot be null\n+     * @param style the inline style (example {@code \"-fx-fill:red;\"}), or null\n+     * @param css the external style names\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel withInlineAndExternalStyles(String text, String style, String... css) {\n+        Objects.requireNonNull(text);\n+        StyleAttributeMap a = StyleAttributeMap.fromStyles(style, css);\n+        Paragraph p = lastParagraph();\n+        p.addSegment(text, a);\n+        return this;\n+    }\n+\n+    \/**\n+     * Appends a text segment styled with external (stylesheet) style names.\n+     * The {@code text} cannot contain newline ({@code \\n}) symbols.\n+     *\n+     * @param text the text to append, must not contain {@code \\n}, cannot be null\n+     * @param css the external style names\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel withStyles(String text, String... css) {\n+        Objects.requireNonNull(text);\n+        StyleAttributeMap a = StyleAttributeMap.fromStyles(null, css);\n+        Paragraph p = lastParagraph();\n+        p.addSegment(text, a);\n+        return this;\n+    }\n+\n+    \/**\n+     * Appends a text segment styled with external (stylesheet) style names.\n+     * The {@code text} cannot contain newline ({@code \\n}) symbols.\n+     *\n+     * @param text the text to append, must not contain {@code \\n}, cannot be null\n+     * @param style the inline style (example {@code \"-fx-fill:red;\"}), or null\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel withInlineStyle(String text, String style) {\n+        Objects.requireNonNull(text);\n+        StyleAttributeMap a = StyleAttributeMap.fromInlineStyle(style);\n+        Paragraph p = lastParagraph();\n+        p.addSegment(text, a);\n+        return this;\n+    }\n+\n+    \/**\n+     * Appends a text segment styled with the specified style attributes.\n+     * @param text the text to append, must not contain control symbols other than\n+     * TAB.\n+     *\n+     * @param a the style attributes\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel addSegment(String text, StyleAttributeMap a) {\n+        \/\/ TODO split into paragraphs if \\n is found, or check for \\n ?\n+        Objects.requireNonNull(a);\n+        Paragraph p = lastParagraph();\n+        p.addSegment(text, a);\n+        return this;\n+    }\n+\n+    \/**\n+     * Adds a highlight of the given color to the specified range within the last paragraph.\n+     *\n+     * @param start the start offset\n+     * @param length the length of the highlight\n+     * @param c the highlight color\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel highlight(int start, int length, Color c) {\n+        Paragraph p = lastParagraph();\n+        p.addHighlight(start, length, c);\n+        return this;\n+    }\n+\n+    \/**\n+     * Adds a squiggly line (typically used as a spell checker indicator) to the specified range within the last paragraph.\n+     *\n+     * @param start the start offset\n+     * @param length the length of the highlight\n+     * @param c the highlight color\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel squiggly(int start, int length, Color c) {\n+        Paragraph p = lastParagraph();\n+        p.addSquiggly(start, length, c);\n+        return this;\n+    }\n+\n+    private Paragraph lastParagraph() {\n+        int sz = paragraphs.size();\n+        if (sz == 0) {\n+            Paragraph p = new Paragraph();\n+            paragraphs.add(p);\n+            return p;\n+        }\n+        return paragraphs.get(sz - 1);\n+    }\n+\n+    \/**\n+     * Adds a paragraph containing an image.  The image will be reduced in size as necessary to fit into the available\n+     * area if {@code wrapText} property is set.\n+     * This method does not close the input stream.\n+     *\n+     * @param in the input stream providing the image.\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel addImage(InputStream in) {\n+        Image im = new Image(in);\n+        Paragraph p = Paragraph.of(() -> {\n+            return new ImageCellPane(im);\n+        });\n+        paragraphs.add(p);\n+        return this;\n+    }\n+\n+    \/**\n+     * Adds a paragraph containing a {@code Region}.\n+     * <p>\n+     * The supplied generator must not cache or keep reference to the created {@code Region},\n+     * but the created {@code Region} can keep a reference to the model or a property therein.\n+     * <p>\n+     * For example, a bidirectional binding between an inline control and some property in the model\n+     * would synchronize the model with all the views that use it.\n+     *\n+     * @param generator the supplier of the paragraph content\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel addParagraph(Supplier<Region> generator) {\n+        Paragraph p = Paragraph.of(() -> {\n+            return generator.get();\n+        });\n+        paragraphs.add(p);\n+        return this;\n+    }\n+\n+    \/**\n+     * Adds an inline Node to the last paragraph.\n+     * <p>\n+     * The supplied generator must not cache or keep reference to the created {@code Node},\n+     * but the created {@code Node} can keep a reference to the model or a property therein.\n+     * <p>\n+     * For example, a bidirectional binding between an inline control and some property in the model\n+     * would synchronize the model with all the views that use it.\n+     *\n+     * @param generator the supplier of the embedded Node\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel addNodeSegment(Supplier<Node> generator) {\n+        Paragraph p = lastParagraph();\n+        p.addInlineNode(generator);\n+        return this;\n+    }\n+\n+    \/**\n+     * Adds a new paragraph (as if inserting a newline symbol into the text).\n+     * This convenience method invokes {@link #nl(int)} with a value of 1.\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel nl() {\n+        return nl(1);\n+    }\n+\n+    \/**\n+     * Adds {@code n} new paragraphs (as if inserting a newline symbol into the text {@code n} times).\n+     *\n+     * @param count the number of paragraphs to append\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel nl(int count) {\n+        for (int i = 0; i < count; i++) {\n+            int ix = paragraphs.size();\n+            paragraphs.add(new Paragraph());\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public StyleAttributeMap getStyleAttributeMap(StyleResolver r, TextPos pos) {\n+        int index = pos.index();\n+        if (index < paragraphs.size()) {\n+            int off = pos.offset();\n+            Paragraph par = paragraphs.get(index);\n+            StyleAttributeMap pa = par.getParagraphAttributes();\n+            StyleAttributeMap a = par.getStyleAttrs(r, off);\n+            if (pa == null) {\n+                return a;\n+            } else {\n+                return pa.combine(a);\n+            }\n+        }\n+        return StyleAttributeMap.EMPTY;\n+    }\n+\n+    \/**\n+     * Sets the last paragraph's attributes.\n+     *\n+     * @param a the paragraph attributes\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel setParagraphAttributes(StyleAttributeMap a) {\n+        Paragraph p = lastParagraph();\n+        p.setParagraphAttributes(a);\n+        return this;\n+    }\n+\n+    \/** Encapsulates a paragraph *\/\n+    static class Paragraph {\n+        private ArrayList<StyledSegment> segments;\n+        private ArrayList<Consumer<TextCell>> highlights;\n+        private StyleAttributeMap paragraphAttributes;\n+\n+        public Paragraph() {\n+        }\n+\n+        public static Paragraph of(Supplier<Region> paragraphGenerator) {\n+            return new Paragraph() {\n+                @Override\n+                public final Supplier<Region> getParagraphRegion() {\n+                    return paragraphGenerator;\n+                }\n+\n+                @Override\n+                public final String getPlainText() {\n+                    return \"\";\n+                }\n+\n+                @Override\n+                public void export(int start, int end, StyledOutput out) throws IOException {\n+                    StyledSegment seg = StyledSegment.ofRegion(paragraphGenerator);\n+                    out.consume(seg);\n+                }\n+            };\n+        }\n+\n+        public Supplier<Region> getParagraphRegion() {\n+            return null;\n+        }\n+\n+        String getPlainText() {\n+            if (segments == null) {\n+                return \"\";\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (StyledSegment seg : segments) {\n+                sb.append(seg.getText());\n+            }\n+            return sb.toString();\n+        }\n+\n+        \/**\n+         * Adds a text segment with no styling (i.e. using default style).\n+         *\n+         * @param text segment text\n+         *\/\n+        void addSegment(String text) {\n+            StyledSegment seg = StyledSegment.of(text);\n+            segments().add(seg);\n+        }\n+\n+        \/**\n+         * Adds a styled text segment.\n+         * @param text the non-null text string\n+         * @param attrs the styled attributes\n+         *\/\n+        void addSegment(String text, StyleAttributeMap attrs) {\n+            StyledSegment seg = StyledSegment.of(text, attrs);\n+            segments().add(seg);\n+        }\n+\n+        \/**\n+         * Adds a styled text segment.\n+         * @param text the source non-null string\n+         * @param start the start offset of the input string\n+         * @param end the end offset of the input string\n+         * @param attrs the styled attributes\n+         *\/\n+        void addSegment(String text, int start, int end, StyleAttributeMap attrs) {\n+            String s = text.substring(start, end);\n+            addSegment(s, attrs);\n+        }\n+\n+        \/**\n+         * Adds a color background highlight.\n+         * Use translucent colors to enable multiple highlights in the same region of text.\n+         * @param start the start offset\n+         * @param length the end offset\n+         * @param color the background color\n+         *\/\n+        void addHighlight(int start, int length, Color color) {\n+            int end = start + length;\n+            highlights().add((cell) -> {\n+                cell.addHighlight(start, end, color);\n+            });\n+        }\n+\n+        \/**\n+         * Adds a squiggly line (as seen in a spell checker) with the given color.\n+         * @param start the start offset\n+         * @param length the end offset\n+         * @param color the background color\n+         *\/\n+        void addSquiggly(int start, int length, Color color) {\n+            int end = start + length;\n+            highlights().add((cell) -> {\n+                cell.addSquiggly(start, end, color);\n+            });\n+        }\n+\n+        private List<Consumer<TextCell>> highlights() {\n+            if (highlights == null) {\n+                highlights = new ArrayList<>(4);\n+            }\n+            return highlights;\n+        }\n+\n+        \/**\n+         * Adds an inline node.\n+         * <p>\n+         * The supplied generator must not cache or keep reference to the created Node,\n+         * but the created Node can keep a reference to the model or some property therein.\n+         * <p>\n+         * For example, a bidirectional binding between an inline control and some property in the model\n+         * would synchronize the model with all the views that use it.\n+         * @param generator the generator that provides the actual {@code Node}\n+         *\/\n+        void addInlineNode(Supplier<Node> generator) {\n+            StyledSegment seg = StyledSegment.ofInlineNode(generator);\n+            segments().add(seg);\n+        }\n+\n+        private List<StyledSegment> segments() {\n+            if (segments == null) {\n+                segments = new ArrayList<>(8);\n+            }\n+            return segments;\n+        }\n+\n+        private List<StyledSegment> getSegments() {\n+            return segments;\n+        }\n+\n+        private int size() {\n+            return segments == null ? 0 : segments.size();\n+        }\n+\n+        \/\/ for use by StyledTextModel\n+        void export(int start, int end, StyledOutput out) throws IOException {\n+            if (segments == null) {\n+                out.consume(StyledSegment.of(\"\"));\n+            } else {\n+                int off = 0;\n+                int sz = size();\n+                for (int i = 0; i < sz; i++) {\n+                    StyledSegment seg = segments.get(i);\n+                    String text = seg.getText();\n+                    int len = (text == null ? 0 : text.length());\n+                    if (start <= (off + len)) {\n+                        int ix0 = Math.max(0, start - off);\n+                        int ix1 = Math.min(len, end - off);\n+                        if (ix1 > ix0) {\n+                            StyledSegment ss = seg.subSegment(ix0, ix1);\n+                            out.consume(ss);\n+                        }\n+                    }\n+                    off += len;\n+                    if (off >= end) {\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Sets the paragraph attributes.\n+         * @param a the paragraph attributes\n+         *\/\n+        void setParagraphAttributes(StyleAttributeMap a) {\n+            paragraphAttributes = a;\n+        }\n+\n+        \/**\n+         * Returns the paragraph attributes.\n+         * @return the paragraph attributes, can be null\n+         *\/\n+        StyleAttributeMap getParagraphAttributes() {\n+            return paragraphAttributes;\n+        }\n+\n+        \/\/ for use by SimpleReadOnlyStyledModel\n+        StyleAttributeMap getStyleAttrs(StyleResolver resolver, int offset) {\n+            int off = 0;\n+            int ct = size();\n+            for (int i = 0; i < ct; i++) {\n+                StyledSegment seg = segments.get(i);\n+                int len = seg.getTextLength();\n+                if (offset < (off + len) || (i == ct - 1)) {\n+                    return seg.getStyleAttributeMap(resolver);\n+                }\n+                off += len;\n+            }\n+            return StyleAttributeMap.EMPTY;\n+        }\n+\n+        public RichParagraph toRichParagraph() {\n+            return new RichParagraph() {\n+                @Override\n+                public final String getPlainText() {\n+                    return Paragraph.this.getPlainText();\n+                }\n+\n+                @Override\n+                public final StyleAttributeMap getParagraphAttributes() {\n+                    return paragraphAttributes;\n+                }\n+\n+                @Override\n+                final List<StyledSegment> getSegments() {\n+                    return Paragraph.this.getSegments();\n+                }\n+\n+                @Override\n+                public final Supplier<Region> getParagraphRegion() {\n+                    return Paragraph.this.getParagraphRegion();\n+                }\n+\n+                @Override\n+                final List<Consumer<TextCell>> getHighlights() {\n+                    return highlights;\n+                }\n+            };\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/SimpleViewOnlyStyledModel.java","additions":543,"deletions":0,"binary":false,"changes":543,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * Style Attribute provides a way to specify style in the RichTextArea.\n+ *\n+ * @param <T> the attribute value type\n+ * @see StyleAttributeMap\n+ *\/\n+public final class StyleAttribute<T> {\n+    private final String name;\n+    private final Class<T> type;\n+    private final boolean isParagraph;\n+\n+    \/**\n+     * Constructs the style attribute.\n+     *\n+     * @param name the attribute name (cannot be null)\n+     * @param type the attribute type\n+     * @param isParagraph specifies a paragraph attribute (true), or a character attribute (false)\n+     *\/\n+    public StyleAttribute(String name, Class<T> type, boolean isParagraph) {\n+        Objects.requireNonNull(name, \"name cannot be null\");\n+        this.name = name;\n+        this.type = type;\n+        this.isParagraph = isParagraph;\n+    }\n+\n+    \/**\n+     * Attribute name.\n+     *\n+     * @return attribute name\n+     *\/\n+    public String getName() {\n+        return name;\n+    }\n+\n+    \/**\n+     * Returns the class corresponding to the attribute value.\n+     *\n+     * @return attribute type\n+     *\/\n+    public final Class<T> getType() {\n+        return type;\n+    }\n+\n+    \/**\n+     * Returns true for a paragraph attribute, false for a character attribute.\n+     *\n+     * @return true for a paragraph attribute, false for a character attribute\n+     *\/\n+    public boolean isParagraphAttribute() {\n+        return isParagraph;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    \/\/ TODO maybe it should override equals() and hashCode()\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/StyleAttribute.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,736 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.Paint;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.Text;\n+import javafx.scene.text.TextAlignment;\n+import com.sun.jfx.incubator.scene.control.richtext.CssStyles;\n+import com.sun.jfx.incubator.scene.control.richtext.StyleAttributeMapHelper;\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n+\n+\/**\n+ * This immutable object contains a map of {@link StyleAttribute}s.\n+ *\/\n+public final class StyleAttributeMap {\n+    \/** Paragraph background color attribute. *\/\n+    public static final StyleAttribute<Color> BACKGROUND = new StyleAttribute<>(\"BACKGROUND\", Color.class, true);\n+\n+    \/** Bullet point paragraph attribute. *\/\n+    public static final StyleAttribute<String> BULLET = new StyleAttribute<>(\"BULLET\", String.class, true);\n+\n+    \/** Bold typeface text attribute. *\/\n+    public static final StyleAttribute<Boolean> BOLD = new StyleAttribute<>(\"BOLD\", Boolean.class, false);\n+\n+    \/** First line indent paragraph attribute, in pixels. *\/\n+    public static final StyleAttribute<Double> FIRST_LINE_INDENT = new StyleAttribute<>(\"FIRST_LINE_INDENT\", Double.class, true);\n+\n+    \/** Font family text attribute. *\/\n+    public static final StyleAttribute<String> FONT_FAMILY = new StyleAttribute<>(\"FONT_FAMILY\", String.class, false);\n+\n+    \/** Font size text attribute, in pixels. *\/\n+    public static final StyleAttribute<Double> FONT_SIZE = new StyleAttribute<>(\"FONT_SIZE\", Double.class, false);\n+\n+    \/** Italic type face text attribute. *\/\n+    public static final StyleAttribute<Boolean> ITALIC = new StyleAttribute<>(\"ITALIC\", Boolean.class, false);\n+\n+    \/** Line spacing paragraph attribute. *\/\n+    public static final StyleAttribute<Double> LINE_SPACING = new StyleAttribute<>(\"LINE_SPACING\", Double.class, true);\n+\n+    \/** Paragraph direction attribute.  This attribute is considered only when text wrapping is enabled. *\/\n+    public static final StyleAttribute<ParagraphDirection> PARAGRAPH_DIRECTION = new StyleAttribute<>(\"PARAGRAPH_DIRECTION\", ParagraphDirection.class, true);\n+\n+    \/** Space above (top padding) paragraph attribute. *\/\n+    public static final StyleAttribute<Double> SPACE_ABOVE = new StyleAttribute<>(\"SPACE_ABOVE\", Double.class, true);\n+\n+    \/** Space below (bottom padding) paragraph attribute. *\/\n+    public static final StyleAttribute<Double> SPACE_BELOW = new StyleAttribute<>(\"SPACE_BELOW\", Double.class, true);\n+\n+    \/** Space to the left (left padding) paragraph attribute. *\/\n+    public static final StyleAttribute<Double> SPACE_LEFT = new StyleAttribute<>(\"SPACE_LEFT\", Double.class, true);\n+\n+    \/** Space to the right (right padding) paragraph attribute. *\/\n+    public static final StyleAttribute<Double> SPACE_RIGHT = new StyleAttribute<>(\"SPACE_RIGHT\", Double.class, true);\n+\n+    \/** Strike-through text attribute. *\/\n+    public static final StyleAttribute<Boolean> STRIKE_THROUGH = new StyleAttribute<>(\"STRIKE_THROUGH\", Boolean.class, false);\n+\n+    \/** Text alignment paragraph attribute. *\/\n+    public static final StyleAttribute<TextAlignment> TEXT_ALIGNMENT = new StyleAttribute<>(\"TEXT_ALIGNMENT\", TextAlignment.class, true);\n+\n+    \/** Text color attribute. *\/\n+    public static final StyleAttribute<Color> TEXT_COLOR = new StyleAttribute<>(\"TEXT_COLOR\", Color.class, false);\n+\n+    \/** Underline text attribute. *\/\n+    public static final StyleAttribute<Boolean> UNDERLINE = new StyleAttribute<>(\"UNDERLINE\", Boolean.class, false);\n+\n+    \/** Empty attribute set. *\/\n+    public static final StyleAttributeMap EMPTY = new StyleAttributeMap(Collections.emptyMap());\n+\n+    private static final String[] EMPTY_ARRAY = new String[0];\n+\n+    private final Map<StyleAttribute<?>,Object> attributes;\n+    static { initAccessor(); }\n+\n+    private StyleAttributeMap(Map<StyleAttribute<?>,Object> a) {\n+        this.attributes = Collections.unmodifiableMap(a);\n+    }\n+\n+    \/**\n+     * Convenience method creates the instance with a single attribute.\n+     *\n+     * @param <V> the attribute value type\n+     * @param attribute the attribute\n+     * @param value the attribute value\n+     * @return the new instance\n+     *\/\n+    public static <V> StyleAttributeMap of(StyleAttribute<V> attribute, V value) {\n+        return new Builder().set(attribute, value).build();\n+    }\n+\n+    \/**\n+     * This convenience method creates an instance from an inline style and a number of\n+     * CSS style names.\n+     *\n+     * @param style the inline style, will not be applied when null\n+     * @param names style names\n+     * @return the new instance\n+     *\/\n+    public static StyleAttributeMap fromStyles(String style, String... names) {\n+        if ((style == null) && (names == null)) {\n+            return StyleAttributeMap.EMPTY;\n+        } else if (names == null) {\n+            names = EMPTY_ARRAY;\n+        }\n+        return new Builder().set(CssStyles.CSS, new CssStyles(style, names)).build();\n+    }\n+\n+    \/**\n+     * This convenience method creates an instance from an inline style.\n+     *\n+     * @param style the inline style, can be null\n+     * @return the new instance\n+     *\/\n+    public static StyleAttributeMap fromInlineStyle(String style) {\n+        if (style == null) {\n+            return StyleAttributeMap.EMPTY;\n+        }\n+        return new Builder().set(CssStyles.CSS, new CssStyles(style, null)).build();\n+    }\n+\n+    @Override\n+    public boolean equals(Object x) {\n+        if (x == this) {\n+            return true;\n+        } else if (x instanceof StyleAttributeMap s) {\n+            return attributes.equals(s.attributes);\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return attributes.hashCode() + (31 * StyleAttributeMap.class.hashCode());\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this instance contains no attributes.\n+     * @return true is no attributes are present\n+     *\/\n+    public boolean isEmpty() {\n+        return attributes.isEmpty();\n+    }\n+\n+    \/**\n+     * Returns the attribute value, or null if no such attribute is present.\n+     *\n+     * @param <V> the attribute value type\n+     * @param a attribute\n+     * @return attribute value or null\n+     *\/\n+    public <V> V get(StyleAttribute<V> a) {\n+        return (V)attributes.get(a);\n+    }\n+\n+    \/**\n+     * Returns the set of {@link StyleAttribute}s.\n+     * @return attribute set\n+     *\/\n+    public Set<StyleAttribute<?>> getAttributes() {\n+        return attributes.keySet();\n+    }\n+\n+    \/**\n+     * Returns an immutable {@link Set} view of the mappings contained in this map.\n+     * @return a set view of the mappings contained in this attribute map\n+     *\/\n+    public Set<Map.Entry<StyleAttribute<?>, Object>> getAttributeEntrySet() {\n+        return attributes.entrySet();\n+    }\n+\n+    \/**\n+     * Returns true if the attribute is present; false otherwise.\n+     *\n+     * @param a the attribute\n+     * @return true if the attribute is present\n+     *\/\n+    public boolean contains(StyleAttribute<?> a) {\n+        return attributes.containsKey(a);\n+    }\n+\n+    \/**\n+     * Creates a new StyleAttributeMap instance by first copying attributes from this instance,\n+     * then adding (and\/or overwriting) the attributes from the specified instance.\n+     *\n+     * @param attrs the attributes to combine\n+     * @return the new instance combining the attributes\n+     *\/\n+    public StyleAttributeMap combine(StyleAttributeMap attrs) {\n+        return new Builder().\n+            merge(this).\n+            merge(attrs).\n+            build();\n+    }\n+\n+    \/**\n+     * Returns true if the specified attribute contains {@code Boolean.TRUE},\n+     * false in any other case.\n+     *\n+     * @param a the attribute\n+     * @return true if the attribute value is {@code Boolean.TRUE}\n+     *\/\n+    public boolean getBoolean(StyleAttribute<Boolean> a) {\n+        Object v = attributes.get(a);\n+        return Boolean.TRUE.equals(v);\n+    }\n+\n+    \/**\n+     * Returns the value of the specified attribute, or defaultValue if the specified attribute\n+     * is not present or is not a {@link Number}.\n+     *\n+     * @param a the attribute\n+     * @param defaultValue the default value\n+     * @return the attribute value\n+     *\/\n+    public double getDouble(StyleAttribute<? extends Number> a, double defaultValue) {\n+        Object v = attributes.get(a);\n+        if (v instanceof Number n) {\n+            return n.doubleValue();\n+        }\n+        return defaultValue;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(32);\n+        sb.append(\"{\");\n+        boolean sep = false;\n+        for (StyleAttribute<?> a : attributes.keySet()) {\n+            if (sep) {\n+                sb.append(\",\");\n+            } else {\n+                sep = true;\n+            }\n+            Object v = get(a);\n+            sb.append(a);\n+            sb.append('=');\n+            sb.append(v);\n+        }\n+        sb.append(\"}\");\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * This convenience method returns the value of {@link #BACKGROUND} attribute, or null.\n+     * @return the background color attribute value\n+     *\/\n+    public Color getBackground() {\n+        return get(BACKGROUND);\n+    }\n+\n+    \/**\n+     * This convenience method returns the value of {@link #BULLET} attribute, or null.\n+     * @return the bullet paragraph attribute value\n+     *\/\n+    public String getBullet() {\n+        return get(BULLET);\n+    }\n+\n+    \/**\n+     * This convenience method returns the value of the {@link #FIRST_LINE_INDENT} attribute.\n+     * @return the first line indent value in points\n+     *\/\n+    public Double getFirstLineIndent() {\n+        return get(FIRST_LINE_INDENT);\n+    }\n+\n+    \/**\n+     * This convenience method returns the value of the {@link #FONT_SIZE} attribute.\n+     * @return the font size\n+     *\/\n+    public final Double getFontSize() {\n+        return get(FONT_SIZE);\n+    }\n+\n+    \/**\n+     * This convenience method returns true if the value of the {@link #FONT_FAMILY} attribute is {@code Boolean.TRUE},\n+     * false otherwise.\n+     * @return the font family name\n+     *\/\n+    public String getFontFamily() {\n+        return get(FONT_FAMILY);\n+    }\n+\n+    \/**\n+     * This convenience method returns the value of the {@link #LINE_SPACING} attribute, or null.\n+     * @return the line spacing value\n+     *\/\n+    public Double getLineSpacing() {\n+        return get(LINE_SPACING);\n+    }\n+\n+    \/**\n+     * This convenience method returns the value of the {@link #SPACE_ABOVE} attribute, or null.\n+     * @return the space above paragraph attribute value\n+     *\/\n+    public Double getSpaceAbove() {\n+        return get(SPACE_ABOVE);\n+    }\n+\n+    \/**\n+     * This convenience method returns the value of the {@link #SPACE_BELOW} attribute, or null.\n+     * @return the space below paragraph attribute value\n+     *\/\n+    public Double getSpaceBelow() {\n+        return get(SPACE_BELOW);\n+    }\n+\n+    \/**\n+     * This convenience method returns the value of the {@link #SPACE_LEFT} attribute, or null.\n+     * @return the space left paragraph attribute value\n+     *\/\n+    public Double getSpaceLeft() {\n+        return get(SPACE_LEFT);\n+    }\n+\n+    \/**\n+     * This convenience method returns the value of the {@link #SPACE_RIGHT} attribute, or null.\n+     * @return the space right paragraph attribute value\n+     *\/\n+    public Double getSpaceRight() {\n+        return get(SPACE_RIGHT);\n+    }\n+\n+    \/**\n+     * This convenience method returns the value of {@link #TEXT_ALIGNMENT} attribute, or null.\n+     * @return the paragraph alignment attribute value\n+     *\/\n+    public TextAlignment getTextAlignment() {\n+        return get(TEXT_ALIGNMENT);\n+    }\n+\n+    \/**\n+     * This convenience method returns the value of {@link #TEXT_COLOR} attribute, or null.\n+     * @return the text color attribute value\n+     *\/\n+    public Color getTextColor() {\n+        return get(TEXT_COLOR);\n+    }\n+\n+    \/**\n+     * This convenience method returns true if the value of {@link #BOLD} attribute is {@code Boolean.TRUE},\n+     * false otherwise.\n+     * @return the bold attribute value\n+     *\/\n+    public boolean isBold() {\n+        return getBoolean(BOLD);\n+    }\n+\n+    \/**\n+     * This convenience method returns true if the value of {@link #ITALIC} attribute is {@code Boolean.TRUE},\n+     * false otherwise.\n+     * @return the italic attribute value\n+     *\/\n+    public boolean isItalic() {\n+        return getBoolean(ITALIC);\n+    }\n+\n+    \/**\n+     * This convenience method returns the value of {@link #PARAGRAPH_DIRECTION} paragraph attribute,\n+     * or null if the value is not set.\n+     * @return the paragraph direction attribute value, or null\n+     *\/\n+    public ParagraphDirection getParagraphDirection() {\n+        return get(PARAGRAPH_DIRECTION);\n+    }\n+\n+    \/**\n+     * This convenience method returns true if the value of {@link #STRIKE_THROUGH} attribute is {@code Boolean.TRUE},\n+     * false otherwise.\n+     * @return the strike through attribute value\n+     *\/\n+    public boolean isStrikeThrough() {\n+        return getBoolean(STRIKE_THROUGH);\n+    }\n+\n+    \/**\n+     * This convenience method returns true if the value of {@link #UNDERLINE} attribute is {@code Boolean.TRUE},\n+     * false otherwise.\n+     * @return the underline attribute value\n+     *\/\n+    public boolean isUnderline() {\n+        return getBoolean(UNDERLINE);\n+    }\n+\n+    private StyleAttributeMap filterAttributes(boolean isParagraph) {\n+        Builder b = null;\n+        for (StyleAttribute<?> a : attributes.keySet()) {\n+            if (a.isParagraphAttribute() == isParagraph) {\n+                if (b == null) {\n+                    b = StyleAttributeMap.builder();\n+                }\n+                Object v = attributes.get(a);\n+                b.setUnguarded(a, v);\n+            }\n+        }\n+        return (b == null) ? null : b.build();\n+    }\n+\n+    private static void initAccessor() {\n+        StyleAttributeMapHelper.setAccessor(new StyleAttributeMapHelper.Accessor() {\n+            @Override\n+            public StyleAttributeMap filterAttributes(StyleAttributeMap ss, boolean isParagraph) {\n+                return ss.filterAttributes(isParagraph);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Creates an instance of StyleAttributeMap which contains character attributes found in the specified {@link Text} node.\n+     * The following attributes will be set:\n+     * <ul>\n+     * <li>{@link #BOLD}\n+     * <li>{@link #FONT_FAMILY}\n+     * <li>{@link #FONT_SIZE}\n+     * <li>{@link #ITALIC}\n+     * <li>{@link #STRIKE_THROUGH}\n+     * <li>{@link #TEXT_COLOR}\n+     * <li>{@link #UNDERLINE}\n+     * <\/ul>\n+     *\n+     * @param textNode the text node\n+     * @return the StyleAttributeMap instance\n+     *\/\n+    public static StyleAttributeMap fromTextNode(Text textNode) {\n+        StyleAttributeMap.Builder b = StyleAttributeMap.builder();\n+        Font f = textNode.getFont();\n+        String st = f.getStyle().toLowerCase(Locale.US);\n+        boolean bold = RichUtils.isBold(st);\n+        boolean italic = RichUtils.isItalic(st);\n+\n+        if (bold) {\n+            b.setBold(true);\n+        }\n+\n+        if (italic) {\n+            b.setItalic(true);\n+        }\n+\n+        if (textNode.isStrikethrough()) {\n+            b.setStrikeThrough(true);\n+        }\n+\n+        if (textNode.isUnderline()) {\n+            b.setUnderline(true);\n+        }\n+\n+        String family = f.getFamily();\n+        b.setFontFamily(family);\n+\n+        double sz = f.getSize();\n+        if (sz != 12.0) {\n+            b.setFontSize(sz);\n+        }\n+\n+        Paint x = textNode.getFill();\n+        if (x instanceof Color c) {\n+            \/\/ we do not support gradients (although we could get the first color, for example)\n+            b.setTextColor(c);\n+        }\n+\n+        return b.build();\n+    }\n+\n+    \/**\n+     * Creates a new Builder instance.\n+     * @return the new Builder instance\n+     *\/\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    \/** StyleAttributeMap are immutable, so a Builder is required to create a new instance *\/\n+    public static class Builder {\n+        private final HashMap<StyleAttribute<?>,Object> attributes = new HashMap<>(4);\n+\n+        private Builder() {\n+        }\n+\n+        \/**\n+         * Creates an immutable instance of {@link StyleAttributeMap} with the attributes set by this Builder.\n+         * @return the new instance\n+         *\/\n+        public StyleAttributeMap build() {\n+            return new StyleAttributeMap(attributes);\n+        }\n+\n+        \/**\n+         * Sets the value for the specified attribute.\n+         * This method will throw an {@code IllegalArgumentException} if the value cannot be cast to the\n+         * type specified by the attribute.\n+         *\n+         * @param <V> the attribute value type\n+         * @param a the attribute\n+         * @param value the attribute value\n+         * @return this Builder instance\n+         *\/\n+        public <V> Builder set(StyleAttribute<V> a, V value) {\n+            if (value == null) {\n+                attributes.put(a, null);\n+            } else if (value.getClass().isAssignableFrom(a.getType())) {\n+                attributes.put(a, value);\n+            } else {\n+                throw new IllegalArgumentException(a + \" requires value of type \" + a.getType());\n+            }\n+            return this;\n+        }\n+\n+        private Builder setUnguarded(StyleAttribute<?> a, Object value) {\n+            attributes.put(a, value);\n+            return this;\n+        }\n+\n+        \/**\n+         * Merges the specified attributes with the attributes in this instance.\n+         * The new values override any existing ones.\n+         * @param attrs the attributes to merge, may be null\n+         * @return this Builder instance\n+         *\/\n+        public Builder merge(StyleAttributeMap attrs) {\n+            if (attrs != null) {\n+                for (StyleAttribute<?> a : attrs.attributes.keySet()) {\n+                    Object v = attrs.get(a);\n+                    setUnguarded(a, v);\n+                }\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the paragraph background attribute to the specified color.\n+         * It is recommended to specify a translucent background color in order to avoid obstructing\n+         * the selection and the current line highlights.\n+         * @param color the color\n+         * @return this Builder instance\n+         *\/\n+        public Builder setBackground(Color color) {\n+            set(BACKGROUND, color);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the bold attribute.\n+         * @param on true for bold typeface\n+         * @return this Builder instance\n+         *\/\n+        public Builder setBold(boolean on) {\n+            set(BOLD, Boolean.valueOf(on));\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the BULLET attribute.\n+         * @param bullet the bullet character\n+         * @return this Builder instance\n+         *\/\n+        public Builder setBullet(String bullet) {\n+            set(BULLET, bullet);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the FIRST_LINE_INDENT attribute.\n+         * @param size the first line indent value\n+         * @return this Builder instance\n+         *\/\n+        public Builder setFirstLineIndent(double size) {\n+            set(FIRST_LINE_INDENT, size);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the font family attribute.\n+         * @param name the font family name\n+         * @return this Builder instance\n+         *\/\n+        public Builder setFontFamily(String name) {\n+            set(FONT_FAMILY, name);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the font size attribute.\n+         * @param size the font size in points\n+         * @return this Builder instance\n+         *\/\n+        public Builder setFontSize(double size) {\n+            set(FONT_SIZE, size);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the line spacing paragraph attribute.\n+         * @param value the line spacing value\n+         * @return this Builder instance\n+         *\/\n+        public Builder setLineSpacing(double value) {\n+            set(LINE_SPACING, value);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the italic attribute.\n+         * @param on true for italic typeface\n+         * @return this Builder instance\n+         *\/\n+        public Builder setItalic(boolean on) {\n+            set(ITALIC, Boolean.valueOf(on));\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the paragraph direction attribute.\n+         * @param d the paragraph direction\n+         * @return this Builder instance\n+         *\/\n+        public Builder setRTL(ParagraphDirection d) {\n+            set(PARAGRAPH_DIRECTION, d);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the space above paragraph attribute.\n+         * This method also sets SPACE attribute to Boolean.TRUE.\n+         * @param value the space amount\n+         * @return this Builder instance\n+         *\/\n+        public Builder setSpaceAbove(double value) {\n+            set(SPACE_ABOVE, value);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the space below paragraph attribute.\n+         * This method also sets SPACE attribute to Boolean.TRUE.\n+         * @param value the space amount\n+         * @return this Builder instance\n+         *\/\n+        public Builder setSpaceBelow(double value) {\n+            set(SPACE_BELOW, value);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the space left paragraph attribute.\n+         * This method also sets SPACE attribute to Boolean.TRUE.\n+         * @param value the space amount\n+         * @return this Builder instance\n+         *\/\n+        public Builder setSpaceLeft(double value) {\n+            set(SPACE_LEFT, value);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the space right paragraph attribute.\n+         * This method also sets SPACE attribute to Boolean.TRUE.\n+         * @param value the space amount\n+         * @return this Builder instance\n+         *\/\n+        public Builder setSpaceRight(double value) {\n+            set(SPACE_RIGHT, value);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the strike-through attribute.\n+         * @param on true for strike-through typeface\n+         * @return this Builder instance\n+         *\/\n+        public Builder setStrikeThrough(boolean on) {\n+            set(STRIKE_THROUGH, Boolean.valueOf(on));\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the text alignment attribute to the specified color.\n+         * @param a the alignment\n+         * @return this Builder instance\n+         *\/\n+        public Builder setTextAlignment(TextAlignment a) {\n+            set(TEXT_ALIGNMENT, a);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the text color attribute to the specified color.\n+         * @param color the color\n+         * @return this Builder instance\n+         *\/\n+        public Builder setTextColor(Color color) {\n+            set(TEXT_COLOR, color);\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the underline attribute.\n+         * @param on true for underline\n+         * @return this Builder instance\n+         *\/\n+        public Builder setUnderline(boolean on) {\n+            set(UNDERLINE, Boolean.valueOf(on));\n+            return this;\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/StyleAttributeMap.java","additions":736,"deletions":0,"binary":false,"changes":736,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import com.sun.jfx.incubator.scene.control.richtext.StringStyledInput;\n+\n+\/**\n+ * This interface represents a source of styled text segments for the purposes of\n+ * pasting, importing, or loading from an input stream.\n+ *\/\n+public interface StyledInput extends Closeable {\n+    \/**\n+     * Returns the next segment, or null if no more segments.\n+     * @return the next segment, or null if no more segments\n+     *\/\n+    public abstract StyledSegment nextSegment();\n+\n+    \/** An empty StyledInput. *\/\n+    public static final StyledInput EMPTY = new StyledInput() {\n+        @Override\n+        public StyledSegment nextSegment() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+        }\n+    };\n+\n+    \/**\n+     * Creates a plain text styled input with the specified style.\n+     *\n+     * @param text the source text\n+     * @param attrs the source style attributes\n+     * @return the StyledInput instance\n+     *\/\n+    public static StyledInput of(String text, StyleAttributeMap attrs) {\n+        return new StringStyledInput(text, attrs);\n+    }\n+\n+    \/**\n+     * Creates a plain text styled input with {@link StyleAttributeMap#EMPTY}.\n+     *\n+     * @param text the source text\n+     * @return the StyledInput instance\n+     *\/\n+    public static StyledInput of(String text) {\n+        return new StringStyledInput(text, StyleAttributeMap.EMPTY);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/StyledInput.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import com.sun.jfx.incubator.scene.control.richtext.StringBuilderStyledOutput;\n+\n+\/**\n+ * Class represents a consumer of styled text segments for the purposes of\n+ * exporting, copying, or saving to an output stream.\n+ *\/\n+public interface StyledOutput extends Closeable {\n+    \/**\n+     * Consumes the next styled segment.\n+     *\n+     * @param segment the segment to output\n+     * @throws IOException when an I\/O error occurs\n+     *\/\n+    public void consume(StyledSegment segment) throws IOException;\n+\n+    \/**\n+     * Flushes this output stream.\n+     * @throws IOException when an I\/O error occurs\n+     *\/\n+    public void flush() throws IOException;\n+\n+    \/**\n+     * Creates an instance of a plain text StyledOutput.\n+     * @return the instance of a plain text StyledOutput\n+     *\/\n+    public static StyledOutput forPlainText() {\n+        return new StringBuilderStyledOutput();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/StyledOutput.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,295 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.util.function.Supplier;\n+import javafx.scene.Node;\n+import javafx.scene.layout.Region;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+\n+\/**\n+ * Data structure used to modify the styled text model.\n+ * <p>\n+ * Each instance represents:\n+ * <ol>\n+ * <li>a single text segment with direct style and\/or style names\n+ * <li>a line break\n+ * <li>an inline Node\n+ * <li>a paragraph containing a single Region\n+ * <li>paragraph attributes\n+ * <\/ol>\n+ *\/\n+\/\/ TODO perhaps add guarded\/unguarded factory methods (of(), ofGuarded()) that check for <0x20, or specify that\n+\/\/ text must not include those characters.\n+public abstract class StyledSegment {\n+    \/** StyledSegment type *\/\n+    public enum Type {\n+        \/** Identifies a segment which contains an inline node. *\/\n+        INLINE_NODE,\n+        \/** Identifies a line break segment. *\/\n+        LINE_BREAK,\n+        \/** Identifies a segment which contains the paragraph attributes. *\/\n+        PARAGRAPH_ATTRIBUTES,\n+        \/** Identifies a segment which contains a single paragraph containing a {@code Region}. *\/\n+        REGION,\n+        \/** Identifies a text segment *\/\n+        TEXT\n+    }\n+\n+    \/**\n+     * Returns the type of this StyledSegment.\n+     * @return the type\n+     *\/\n+    public abstract Type getType();\n+\n+    \/**\n+     * Returns the text associated with this segment.\n+     * Must be one character for inline nodes, must be null for node paragraphs or line breaks.\n+     * @return the segment plain text\n+     *\/\n+    public String getText() { return null; }\n+\n+    \/**\n+     * Returns the length of text in the segment, or 0 for segments that contain no text or where\n+     * {@link #getText()} returns null.\n+     * @return the length in characters\n+     *\/\n+    public int getTextLength() { return 0; }\n+\n+    \/**\n+     * This method must return a non-null value for a segment of {@code INLINE_NODE} type,\n+     * or null in any other case.\n+     * @return code that creates a Node instance, or null\n+     *\/\n+    public Supplier<Node> getInlineNodeGenerator() { return null; }\n+\n+    \/**\n+     * This method must return a non-null value for a segment of {@code REGION} type,\n+     * or null in any other case.\n+     * @return code that creates a Region instance, or null\n+     *\/\n+    public Supplier<Region> getParagraphNodeGenerator() { return null; }\n+\n+    \/**\n+     * This method returns StyleAttributeMap (or null) for this segment.\n+     * When the model manages style names (instead of actual attributes), an instance of {@link StyleResolver}\n+     * may be used to convert the style names to individual attributes.\n+     * Keep in mind that different views might have different stylesheet applied and\n+     * resulting in a different set of attributes.\n+     * @param resolver the style resolver to use\n+     * @return style attributes\n+     *\/\n+    public StyleAttributeMap getStyleAttributeMap(StyleResolver resolver) { return null; }\n+\n+    \/**\n+     * Creates a sub-segment of this segment.\n+     * @param start the start offset\n+     * @param end the end offset\n+     * @return the StyledSegment\n+     *\/\n+    public abstract StyledSegment subSegment(int start, int end);\n+\n+    private StyledSegment() {\n+    }\n+\n+    \/** A styled segment that represents a line break *\/\n+    public static final StyledSegment LINE_BREAK = new StyledSegment() {\n+        @Override\n+        public Type getType() {\n+            return Type.LINE_BREAK;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"LINE_BREAK\";\n+        }\n+\n+        @Override\n+        public StyledSegment subSegment(int start, int end) {\n+            return this;\n+        }\n+    };\n+\n+    \/**\n+     * Creates a StyleSegment from a non-null plain text.\n+     * Important: text must not contain any characters &lt; 0x20, except for TAB.\n+     * @param text the segment text\n+     * @return the StyledSegment instance\n+     *\/\n+    \/\/ TODO guarded of() ?\n+    public static StyledSegment of(String text) {\n+        return of(text, StyleAttributeMap.EMPTY);\n+    }\n+\n+    \/**\n+     * Creates a StyleSegment from a non-null plain text and style attributes.\n+     * Important: text must not contain any characters &lt; 0x20, except for TAB.\n+     *\n+     * @param text the segment text\n+     * @param attrs the segment style attributes\n+     * @return the StyledSegment instance\n+     *\/\n+    \/\/ TODO guarded of() ?\n+    \/\/ TODO check for null text?\n+    public static StyledSegment of(String text, StyleAttributeMap attrs) {\n+        return new StyledSegment() {\n+            @Override\n+            public Type getType() {\n+                return Type.TEXT;\n+            }\n+\n+            @Override\n+            public String getText() {\n+                return text;\n+            }\n+\n+            @Override\n+            public int getTextLength() {\n+                return text.length();\n+            }\n+\n+            @Override\n+            public StyleAttributeMap getStyleAttributeMap(StyleResolver resolver) {\n+                if ((resolver != null) && (attrs != null)) {\n+                    return resolver.resolveStyles(attrs);\n+                }\n+                return attrs;\n+            }\n+\n+            @Override\n+            public StyledSegment subSegment(int start, int end) {\n+                if ((start == 0) && (end == text.length())) {\n+                    return this;\n+                }\n+                return StyledSegment.of(substring(text, start, end), attrs);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"StyledSegment{text=\" + getText() + \", attrs=\" + attrs + \"}\";\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Creates a StyledSegment which consists of a single inline Node.\n+     * @param generator the code to create a Node instance\n+     * @return the StyledSegment instance\n+     *\/\n+    public static StyledSegment ofInlineNode(Supplier<Node> generator) {\n+        return new StyledSegment() {\n+            @Override\n+            public Type getType() {\n+                return Type.INLINE_NODE;\n+            }\n+\n+            @Override\n+            public String getText() {\n+                return \" \";\n+            }\n+\n+            @Override\n+            public int getTextLength() {\n+                return 1;\n+            }\n+\n+            @Override\n+            public Supplier<Node> getInlineNodeGenerator() {\n+                return generator;\n+            }\n+\n+            @Override\n+            public StyledSegment subSegment(int start, int end) {\n+                return this;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Creates a StyledSegment for a paragraph that contains a single Region.\n+     * @param generator the code to create a Region instance\n+     * @return the StyledSegment instance\n+     *\/\n+    public static StyledSegment ofRegion(Supplier<Region> generator) {\n+        return new StyledSegment() {\n+            @Override\n+            public Type getType() {\n+                return Type.REGION;\n+            }\n+\n+            @Override\n+            public Supplier<Region> getParagraphNodeGenerator() {\n+                return generator;\n+            }\n+\n+            @Override\n+            public StyledSegment subSegment(int start, int end) {\n+                return this;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Creates a StyledSegment which contains paragraph attributes only.\n+     * @param attrs the paragraph attributes\n+     * @return the StyledSegment instance\n+     *\/\n+    public static StyledSegment ofParagraphAttributes(StyleAttributeMap attrs) {\n+        return new StyledSegment() {\n+            @Override\n+            public Type getType() {\n+                return Type.PARAGRAPH_ATTRIBUTES;\n+            }\n+\n+            @Override\n+            public StyleAttributeMap getStyleAttributeMap(StyleResolver resolver) {\n+                if (resolver != null) {\n+                    return resolver.resolveStyles(attrs);\n+                }\n+                return attrs;\n+            }\n+\n+            @Override\n+            public StyledSegment subSegment(int start, int end) {\n+                return this;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return \"StyledSegment{par.attrs=\" + attrs + \"}\";\n+            }\n+        };\n+    }\n+\n+    private static String substring(String text, int start, int end) {\n+        int len = text.length();\n+        if ((start <= 0) && (end >= len)) {\n+            return text;\n+        } else {\n+            return text.substring(Math.max(0, start), Math.min(end, len));\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/StyledSegment.java","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"@@ -0,0 +1,969 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.function.Supplier;\n+import javafx.beans.property.ReadOnlyBooleanProperty;\n+import javafx.beans.property.ReadOnlyBooleanWrapper;\n+import javafx.scene.input.DataFormat;\n+import javafx.scene.layout.Region;\n+import com.sun.javafx.ModuleUtil;\n+import com.sun.jfx.incubator.scene.control.richtext.Markers;\n+import com.sun.jfx.incubator.scene.control.richtext.StyleAttributeMapHelper;\n+import com.sun.jfx.incubator.scene.control.richtext.UndoableChange;\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n+import jfx.incubator.scene.control.richtext.Marker;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * The base class for styled text models used by the\n+ * {@link jfx.incubator.scene.control.richtext.RichTextArea RichTextArea}.\n+ * <p>\n+ * This class handles the following functionality with the intent\n+ * to simplify custom models:\n+ * <ul>\n+ * <li>managing listeners\n+ * <li>firing events\n+ * <li>decomposing the edits into multiple operations performed on individual paragraphs\n+ * <li>managing {@link Marker}s\n+ * <\/ul>\n+ *\n+ * <h2>Editing<\/h2>\n+ * The model supports editing when {@link #isUserEditable()} returns {@code true}.\n+ * Three methods participate in modification of the content:\n+ * {@link #replace(StyleResolver, TextPos, TextPos, String, boolean)},\n+ * {@link #replace(StyleResolver, TextPos, TextPos, StyledInput, boolean)},\n+ * {@link #applyStyle(TextPos, TextPos, StyleAttributeMap, boolean)}.\n+ * These methods decompose the main modification into operations with individual paragraphs\n+ * and delegate these to subclasses.\n+ * <p>\n+ * At the end of this process, an event is sent to all the {@link Listener}s, followed by the\n+ * skin requesting the updated paragraphs when required.\n+ *\n+ * <h2>Creating a Paragraph<\/h2>\n+ * The model presents its content to the view(s) via immutable {@link RichParagraph}.\n+ * There are three ways of styling: using inline {@link StyleAttributeMap attributes}, relying on\n+ * style names in the application style sheet, or using direct styles.\n+ *\n+ * <h2>Extending the Model<\/h2>\n+ * The subclasses are free to choose how the data is stored, the only limitation is that the model neither\n+ * stores nor caches any {@link javafx.scene.Node Node}s, since multiple skins might be attached to the same\n+ * model.  When required, the model may contain properties which can be bound to the Nodes created in\n+ * {@link #getParagraph(int)}.  It is the responsibility of the model to store and restore the values\n+ * of such properties.\n+ *\n+ * @since 999 TODO\n+ *\/\n+public abstract class StyledTextModel {\n+    \/**\n+     * Receives information about modifications of the model.\n+     *\/\n+    @FunctionalInterface\n+    public interface Listener {\n+        \/**\n+         * Informs the listener that the model content has changed.\n+         * @param ch the change\n+         *\/\n+        public void onContentChange(ContentChange ch);\n+    }\n+\n+    \/**\n+     * Indicates whether the model supports editing by the user.\n+     *\n+     * @return true if the model supports editing by the user\n+     *\/\n+    public abstract boolean isUserEditable();\n+\n+    \/**\n+     * Returns the number of paragraphs in the model.\n+     *\n+     * @return number of paragraphs\n+     *\/\n+    public abstract int size();\n+\n+    \/**\n+     * Returns the plain text string for the specified paragraph.  The returned text string cannot be null\n+     * and must not contain any control characters other than TAB.\n+     * The caller should never attempt to ask for a paragraph outside of the valid range.\n+     *\n+     * @param index the paragraph index in the range (0...{@link #size()})\n+     * @return the non-null paragraph text string\n+     *\/\n+    public abstract String getPlainText(int index);\n+\n+    \/**\n+     * Returns a {@link RichParagraph} at the given model index.\n+     * This method makes no guarantees that the same paragraph instance will be returned for the same model index.\n+     *\n+     * @param index paragraph index in the range (0...{@link #size()})\n+     * @return a new instance of TextCell created\n+     *\/\n+    public abstract RichParagraph getParagraph(int index);\n+\n+    \/**\n+     * Removes the specified text range.\n+     * This method gets called only if the model is editable.\n+     * The caller guarantees that {@code start} precedes {@code end}.\n+     *\n+     * @param start the start of the range to be removed\n+     * @param end the end of the range to be removed, expected to be greater than the start position\n+     *\/\n+    protected abstract void removeRange(TextPos start, TextPos end);\n+\n+    \/**\n+     * This method is called to insert a single styled text segment at the given position.\n+     *\n+     * @param index the paragraph index\n+     * @param offset the insertion offset within the paragraph\n+     * @param text the text to insert\n+     * @param attrs the style attributes\n+     * @return the number of characters inserted\n+     *\/\n+    protected abstract int insertTextSegment(int index, int offset, String text, StyleAttributeMap attrs);\n+\n+    \/**\n+     * Inserts a line break at the specified position.\n+     *\n+     * @param index the model index\n+     * @param offset the text offset\n+     *\/\n+    protected abstract void insertLineBreak(int index, int offset);\n+\n+    \/**\n+     * Inserts a paragraph that contains a single {@link Region}.\n+     * <p>\n+     * The model should not cache or otherwise retain references to the created {@code Region}s,\n+     * as they might be requested multiple times during the lifetime of the model, or by different views.\n+     * <p>\n+     * This method allows for embedding {@link javafx.scene.control.Control Control}s that handle user input.\n+     * In this case, the model should declare necessary properties and provide bidirectional bindings between\n+     * the properties in the model and the corresponding properties in the control, as well as handle copy, paste,\n+     * writing to and reading from I\/O streams.\n+     *\n+     * @param index model index\n+     * @param generator code that will be used to create a Node instance\n+     *\/\n+    protected abstract void insertParagraph(int index, Supplier<Region> generator);\n+\n+    \/**\n+     * Replaces the paragraph styles in the specified paragraph.\n+     *\n+     * @param index the paragraph index\n+     * @param paragraphAttrs the paragraph attributes\n+     *\/\n+    protected abstract void setParagraphStyle(int index, StyleAttributeMap paragraphAttrs);\n+\n+    \/**\n+     * Applies style to the specified text range within a single paragraph.\n+     * The new attributes override any existing attributes.\n+     * The {@code end} argument may exceed the paragraph length, in which case the outcome should be the same\n+     * as supplying the paragraph length value.\n+     *\n+     * @param index the paragraph index\n+     * @param start the start offset\n+     * @param end the end offset\n+     * @param a the character attributes\n+     * @param merge determines whether to merge with or overwrite the existing attributes\n+     *\/\n+    protected abstract void applyStyle(int index, int start, int end, StyleAttributeMap a, boolean merge);\n+\n+    \/**\n+     * Returns the {@link StyleAttributeMap} of the first character at the specified position.\n+     * When at the end of the document, returns the attributes of the last character.\n+     *\n+     * @param resolver the style resolver\n+     * @param pos the text position\n+     * @return the style attributes, non-null\n+     *\/\n+    public abstract StyleAttributeMap getStyleAttributeMap(StyleResolver resolver, TextPos pos);\n+\n+    \/**\n+     * Returns the set of attributes supported attributes.  When this method returns a non-null set,\n+     * it will be used by the methods which handle the\n+     * external input for the purpose of filtering out the attributes the model cannot understand, preventing\n+     * the attributes from being added to the model (for example, as a result of pasting from the system\n+     * clipboard).\n+     * <p>\n+     * The methods that utilize the filtering are:\n+     * {@link #applyStyle(TextPos, TextPos, StyleAttributeMap, boolean)},\n+     * {@link #replace(StyleResolver, TextPos, TextPos, StyledInput, boolean)}, and\n+     * {@link #replace(StyleResolver, TextPos, TextPos, String, boolean)}.\n+     * <p>\n+     * When this method returns {@code null}, no filtering is performed.\n+     * <p>\n+     * This method might be overridden by certain models.  The base class implementation returns {@code null}.\n+     *\n+     * @return the set of supported attributes, or null if the model requires no filtering\n+     *\/\n+    protected Set<StyleAttribute<?>> getSupportedAttributes() {\n+        return null;\n+    }\n+\n+    \/** stores the handler and its priority *\/\n+    private static record FHPriority(DataFormatHandler handler, int priority) implements Comparable<FHPriority>{\n+        @Override\n+        public int compareTo(FHPriority x) {\n+            int d = x.priority - priority;\n+            if (d == 0) {\n+                \/\/ compare formats to guard against someone adding two different formats under the same priority\n+                String us = handler().getDataFormat().toString();\n+                String them = x.handler().getDataFormat().toString();\n+                d = them.compareTo(us);\n+            }\n+            return d;\n+        }\n+    }\n+\n+    private record FHKey(DataFormat format, boolean forExport) { }\n+\n+    static { ModuleUtil.incubatorWarning(); }\n+\n+    \/\/ TODO should it hold WeakReferences?\n+    private final CopyOnWriteArrayList<Listener> listeners = new CopyOnWriteArrayList();\n+    private final HashMap<FHKey,FHPriority> handlers = new HashMap<>(2);\n+    private final Markers markers = new Markers();\n+    private final UndoableChange head = UndoableChange.createHead();\n+    private final ReadOnlyBooleanWrapper undoable = new ReadOnlyBooleanWrapper(this, \"undoable\", false);\n+    private final ReadOnlyBooleanWrapper redoable = new ReadOnlyBooleanWrapper(this, \"redoable\", false);\n+    private UndoableChange undo = head;\n+\n+    \/**\n+     * Constructs the instance of the model.\n+     * <p>\n+     * This constructor registers data handlers for RTF, HTML (export only), and plain text.\n+     *\/\n+    public StyledTextModel() {\n+        registerDataFormatHandler(RtfFormatHandler.INSTANCE, true, false, 1000);\n+        registerDataFormatHandler(HtmlExportFormatHandler.INSTANCE, true, false, 100);\n+        registerDataFormatHandler(PlainTextFormatHandler.INSTANCE, true, false, 0);\n+    }\n+\n+    \/**\n+     * Adds a {@link Listener} to this model.\n+     *\n+     * @param listener a non-null listener\n+     *\/\n+    public final void addListener(StyledTextModel.Listener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    \/**\n+     * Removes a {@link Listener} from this model.\n+     * <p>\n+     * This method does nothing if this listener has never been added.\n+     *\n+     * @param listener a non-null listener\n+     *\/\n+    public final void removeListener(StyledTextModel.Listener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    \/**\n+     * Registers a format handler for export and\/or import operations.\n+     * The priority determines the format chosen for operations with the {@link javafx.scene.input.Clipboard}\n+     * when input data is available in more than one supported format.\n+     * The handler with the highest priority will be used by\n+     * {@link jfx.incubator.scene.control.richtext.RichTextArea#read(InputStream)} and\n+     * {@link jfx.incubator.scene.control.richtext.RichTextArea#write(OutputStream)} methods.\n+     * <p>\n+     * The same handler can be registered for input and export.  When registering multiple handlers\n+     * for the same data handler and import\/export, the last registered one wins.\n+     * <p>\n+     * This method is expected to be called from a {@code StyledTextModel} child class constructor.\n+     *\n+     * @param h data format handler\n+     * @param forExport true if the handler supports export operations\n+     * @param forImport true if the handler supports import operations\n+     * @param priority from 0 (lowest, usually plain text) to {@code Integer.MAX_VALUE}\n+     *\/\n+    \/\/ TODO this method could be made public to allow for adding new handlers to existing models\n+    \/\/ such as RichTextModel.\n+    protected final void registerDataFormatHandler(DataFormatHandler h, boolean forExport, boolean forImport, int priority) {\n+        FHPriority p = new FHPriority(h, priority);\n+        if (forExport) {\n+            handlers.put(new FHKey(h.getDataFormat(), true), p);\n+        }\n+        if (forImport) {\n+            handlers.put(new FHKey(h.getDataFormat(), false), p);\n+        }\n+    }\n+\n+    \/**\n+     * Removes the data format handler registered previously with\n+     * {@link #registerDataFormatHandler(DataFormatHandler, boolean, boolean, int)}.\n+     *\n+     * @param f the data format\n+     * @param forExport whether to remove the export handler\n+     * @param forImport whether to remove the import handler\n+     *\/\n+    protected final void removeDataFormatHandler(DataFormat f, boolean forExport, boolean forImport) {\n+        if (forExport) {\n+            handlers.remove(new FHKey(f, true));\n+        }\n+        if (forImport) {\n+            handlers.remove(new FHKey(f, false));\n+        }\n+    }\n+\n+    \/**\n+     * Returns an array of supported data formats for either export or import operations,\n+     * in the order of priority - from high to low.\n+     * <p>\n+     * The top priority format will be used by\n+     * {@link jfx.incubator.scene.control.richtext.RichTextArea#read(InputStream)} and\n+     * {@link jfx.incubator.scene.control.richtext.RichTextArea#write(OutputStream)} methods.\n+     *\n+     * @param forExport determines whether the operation is export (true) or import (false)\n+     * @return supported formats\n+     *\/\n+    public final DataFormat[] getSupportedDataFormats(boolean forExport) {\n+        ArrayList<FHPriority> fs = new ArrayList<>(handlers.size());\n+        handlers.forEach((k, p) -> {\n+            if (k.forExport == forExport) {\n+                fs.add(p);\n+            }\n+        });\n+        Collections.sort(fs);\n+        int sz = fs.size();\n+        DataFormat[] formats = new DataFormat[sz];\n+        for (int i = 0; i < sz; i++) {\n+            formats[i] = fs.get(i).handler().getDataFormat();\n+        }\n+        return formats;\n+    }\n+\n+    \/**\n+     * Returns a {@link DataFormatHandler} instance corresponding to the given {@link DataFormat}.\n+     * This method will return {@code null} if the data format is not supported.\n+     *\n+     * @param format data format\n+     * @param forExport for export (true) or for input (false)\n+     * @return DataFormatHandler or null\n+     *\/\n+    public final DataFormatHandler getDataFormatHandler(DataFormat format, boolean forExport) {\n+        FHKey k = new FHKey(format, forExport);\n+        FHPriority p = handlers.get(k);\n+        return p == null ? null : p.handler();\n+    }\n+\n+    \/**\n+     * Fires a text modification event for the given range.\n+     *\n+     * @param start start of the affected range\n+     * @param end end of the affected range\n+     * @param charsTop number of characters added before any added paragraphs\n+     * @param linesAdded number of paragraphs inserted\n+     * @param charsBottom number of characters added after any inserted paragraphs\n+     *\/\n+    public void fireChangeEvent(TextPos start, TextPos end, int charsTop, int linesAdded, int charsBottom) {\n+        ContentChange ch = ContentChange.ofEdit(start, end, charsTop, linesAdded, charsBottom);\n+        markers.update(start, end, charsTop, linesAdded, charsBottom);\n+        for (Listener li : listeners) {\n+            li.onContentChange(ch);\n+        }\n+    }\n+\n+    \/**\n+     * Fires a style change event for the given range.\n+     * This event indicates that only the styling has changed, with no  changes to any text positions.\n+     *\n+     * @param start the start position\n+     * @param end the end position, must be greater than the start position\n+     *\/\n+    public void fireStyleChangeEvent(TextPos start, TextPos end) {\n+        ContentChange ch = ContentChange.ofStyleChange(start, end);\n+        for (Listener li : listeners) {\n+            li.onContentChange(ch);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the length of text in a paragraph at the specified index.\n+     *\n+     * @param index the paragraph index\n+     * @return the length\n+     *\/\n+    public int getParagraphLength(int index) {\n+        return getPlainText(index).length();\n+    }\n+\n+    \/**\n+     * Exports the stream of {@code StyledSegment}s in the given range to the specified\n+     * {@code StyledOutput}.\n+     *\n+     * @param start start of the range\n+     * @param end end of the range\n+     * @param out {@link StyledOutput} to receive the stream\n+     * @throws IOException when an I\/O error occurs\n+     * @see #replace(StyleResolver, TextPos, TextPos, StyledInput, boolean)\n+     *\/\n+    public final void export(TextPos start, TextPos end, StyledOutput out) throws IOException {\n+        int cmp = start.compareTo(end);\n+        if (cmp > 0) {\n+            \/\/ make sure start < end\n+            TextPos p = start;\n+            start = end;\n+            end = p;\n+        }\n+\n+        int ix0 = start.index();\n+        int ix1 = end.index();\n+        if (ix0 == ix1) {\n+            \/\/ single line\n+            int soff = start.offset();\n+            int eoff = end.offset();\n+            int len = getParagraphLength(ix0);\n+            boolean withParAttrs = ((soff == 0) && ((eoff >= len) || (eoff < 0)));\n+            exportParagraph(ix0, soff, eoff, withParAttrs, out);\n+        } else {\n+            \/\/ multi-line\n+            boolean lineBreak = false;\n+            for (int ix = ix0; ix <= ix1; ix++) {\n+                if (lineBreak) {\n+                    out.consume(StyledSegment.LINE_BREAK);\n+                } else {\n+                    lineBreak = true;\n+                }\n+\n+                int off0;\n+                int off1;\n+                if (ix == ix0) {\n+                    off0 = start.offset();\n+                    off1 = Integer.MAX_VALUE;\n+                } else if (ix == ix1) {\n+                    off0 = 0;\n+                    off1 = end.offset();\n+                } else {\n+                    off0 = 0;\n+                    off1 = Integer.MAX_VALUE;\n+                }\n+\n+                exportParagraph(ix, off0, off1, true, out);\n+            }\n+        }\n+\n+        out.flush();\n+    }\n+\n+    \/**\n+     * Exports part of the paragraph as a sequence of styled segments.\n+     * The caller guarantees that the start position precedes the end.\n+     * The subclass may override this method to provide a more performant implementation.\n+     * The paragraph end argument may exceed the actual length of the paragraph, in which case it\n+     * should be treated as equal to the paragraph text length.\n+     *\n+     * @param index the paragraph index in the model\n+     * @param start the start offset\n+     * @param end the end offset (may exceed the paragraph length)\n+     * @param withParAttrs determines whether to emit paragraph attributes\n+     * @param out the target StyledOutput\n+     * @throws IOException when an I\/O error occurs\n+     *\/\n+    protected final void exportParagraph(int index, int start, int end, boolean withParAttrs, StyledOutput out) throws IOException {\n+        RichParagraph par = getParagraph(index);\n+        par.export(start, end, out);\n+        if (withParAttrs) {\n+            \/\/ sent last after the paragraph has been created\n+            StyleAttributeMap pa = par.getParagraphAttributes();\n+            out.consume(StyledSegment.ofParagraphAttributes(pa));\n+        }\n+    }\n+\n+    \/**\n+     * Returns the {@link Marker} at the specified position.\n+     * The actual text position tracked by the marker will always be within the document boundaries.\n+     *\n+     * @param pos text position\n+     * @return Marker instance\n+     *\/\n+    public final Marker getMarker(TextPos pos) {\n+        TextPos p = clamp(pos);\n+        return markers.getMarker(p);\n+    }\n+\n+    \/**\n+     * Returns the text position guaranteed to be within the document and paragraph limits.\n+     *\n+     * @param p text position, cannot be null\n+     * @return text position\n+     *\/\n+    public final TextPos clamp(TextPos p) {\n+        Objects.nonNull(p);\n+        int ct = size();\n+        int ix = p.index();\n+        if (ix < 0) {\n+            return TextPos.ZERO;\n+        } else if (ix < ct) {\n+            \/\/ clamp to paragraph length\n+            int len = getParagraphLength(ix);\n+            if (p.offset() < len) {\n+                return p;\n+            }\n+            return new TextPos(ix, len);\n+        } else {\n+            if (ct == 0) {\n+                return TextPos.ZERO;\n+            } else {\n+                ix = ct - 1;\n+                int len = getParagraphLength(ix);\n+                return new TextPos(ct - 1, len);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns the text position corresponding to the end of the document.\n+     * The start of the document can be referenced by the {@link TextPos#ZERO} constant.\n+     *\n+     * @return the text position\n+     * @see TextPos#ZERO\n+     *\/\n+    public final TextPos getDocumentEnd() {\n+        int ix = size() - 1;\n+        if (ix < 0) {\n+            return TextPos.ZERO;\n+        } else {\n+            return getEndOfParagraphTextPos(ix);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a TextPos corresponding to the end of paragraph at the given index.\n+     *\n+     * @param index the paragraph index\n+     * @return the text position\n+     *\/\n+    public final TextPos getEndOfParagraphTextPos(int index) {\n+        int off = getParagraphLength(index);\n+        int cix = off - 1;\n+        if (cix < 0) {\n+            return new TextPos(index, off);\n+        } else {\n+            return new TextPos(index, off, cix, false);\n+        }\n+    }\n+\n+    \/**\n+     * Replaces the given range with the provided plain text.\n+     * <p>\n+     * This is a convenience method which eventually calls\n+     * {@link #replace(StyleResolver, TextPos, TextPos, StyledInput, boolean)}\n+     * with the attributes provided by {@link #getStyleAttributeMap(StyleResolver, TextPos)} at the\n+     * {@code start} position.\n+     *\n+     * @param resolver the StyleResolver to use\n+     * @param start start text position\n+     * @param end end text position\n+     * @param text text string to insert\n+     * @param allowUndo when true, creates an undo-redo entry\n+     * @return the text position at the end of the inserted text, or null if the model is read only\n+     *\/\n+    public final TextPos replace(StyleResolver resolver, TextPos start, TextPos end, String text, boolean allowUndo) {\n+        if (isUserEditable()) {\n+            \/\/ TODO pick the lowest from start,end.  Possibly add (end) argument to getStyleAttributes?\n+            StyleAttributeMap a = getStyleAttributeMap(resolver, start);\n+            StyledInput in = StyledInput.of(text, a);\n+            return replace(resolver, start, end, in, allowUndo);\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Replaces the given range with the provided styled text input.\n+     * When inserting plain text, the style is taken from the preceding text segment, or, if the text is being\n+     * inserted in the beginning of the document, the style is taken from the following text segment.\n+     * <p>\n+     * After the model applies the requested changes, an event is sent to all the registered listeners.\n+     *\n+     * @param resolver the StyleResolver to use, can be null\n+     * @param start the start text position\n+     * @param end the end text position\n+     * @param input the input content stream\n+     * @param allowUndo when true, creates an undo-redo entry\n+     * @return the text position at the end of the inserted text, or null if the model is read only\n+     *\/\n+    public final TextPos replace(StyleResolver resolver, TextPos start, TextPos end, StyledInput input, boolean allowUndo) {\n+        if (isUserEditable()) {\n+            \/\/ TODO clamp to document boundaries\n+            int cmp = start.compareTo(end);\n+            if (cmp > 0) {\n+                TextPos p = start;\n+                start = end;\n+                end = p;\n+            }\n+\n+            UndoableChange ch = allowUndo ? UndoableChange.create(this, start, end) : null;\n+\n+            if (cmp != 0) {\n+                removeRange(start, end);\n+            }\n+\n+            int index = start.index();\n+            int offset = start.offset();\n+            int top = 0;\n+            int btm = 0;\n+\n+            StyledSegment seg;\n+            while ((seg = input.nextSegment()) != null) {\n+                switch (seg.getType()) {\n+                case LINE_BREAK:\n+                    insertLineBreak(index, offset);\n+                    index++;\n+                    offset = 0;\n+                    btm = 0;\n+                    break;\n+                case PARAGRAPH_ATTRIBUTES:\n+                    StyleAttributeMap pa = seg.getStyleAttributeMap(resolver);\n+                    setParagraphStyle(index, pa);\n+                    break;\n+                case REGION:\n+                    offset = 0;\n+                    btm = 0;\n+                    index++;\n+                    Supplier<Region> gen = seg.getParagraphNodeGenerator();\n+                    insertParagraph(index, gen);\n+                    break;\n+                case TEXT:\n+                    String text = seg.getText();\n+                    StyleAttributeMap a = seg.getStyleAttributeMap(resolver);\n+                    if (a == null) {\n+                        a = StyleAttributeMap.EMPTY;\n+                    } else {\n+                        a = filterUnsupportedAttributes(a);\n+                    }\n+                    int len = insertTextSegment(index, offset, text, a);\n+                    if (index == start.index()) {\n+                        top += len;\n+                    }\n+                    offset += len;\n+                    btm += len;\n+                    break;\n+                }\n+            }\n+\n+            int lines = index - start.index();\n+            if (lines == 0) {\n+                btm = 0;\n+            }\n+\n+            fireChangeEvent(start, end, top, lines, btm);\n+\n+            TextPos newEnd = new TextPos(index, offset);\n+            if (allowUndo) {\n+                add(ch, newEnd);\n+            }\n+            return newEnd;\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Applies the style attributes to the specified range in the document.<p>\n+     * Depending on {@code mergeAttributes} parameter, the attributes will either be merged with (true) or completely\n+     * replace the existing attributes within the range.  The affected range might be wider than the range specified\n+     * when applying the paragraph attributes.\n+     * <p>\n+     * This operation is undoable.\n+     *\n+     * @param start the start of text range\n+     * @param end the end of text range\n+     * @param attrs the style attributes to set\n+     * @param mergeAttributes whether to merge or replace the attributes\n+     *\/\n+    public final void applyStyle(TextPos start, TextPos end, StyleAttributeMap attrs, boolean mergeAttributes) {\n+        if (isUserEditable()) {\n+            if (start.compareTo(end) > 0) {\n+                TextPos p = start;\n+                start = end;\n+                end = p;\n+            }\n+\n+            attrs = filterUnsupportedAttributes(attrs);\n+\n+            TextPos evStart;\n+            TextPos evEnd;\n+            boolean changed;\n+\n+            StyleAttributeMap pa = StyleAttributeMapHelper.getParagraphAttrs(attrs);\n+            if (pa == null) {\n+                evStart = start;\n+                evEnd = end;\n+                changed = false;\n+            } else {\n+                evStart = new TextPos(start.index(), 0, 0, true);\n+                evEnd = getEndOfParagraphTextPos(end.index());\n+                changed = true;\n+            }\n+\n+            UndoableChange ch = UndoableChange.create(this, evStart, evEnd);\n+\n+            if (pa != null) {\n+                \/\/ set paragraph attributes\n+                for (int ix = start.index(); ix <= end.index(); ix++) {\n+                    setParagraphStyle(ix, pa);\n+                }\n+            }\n+\n+            \/\/ apply character styles\n+            StyleAttributeMap ca = StyleAttributeMapHelper.getCharacterAttrs(attrs);\n+            if (ca != null) {\n+                int ix = start.index();\n+                if (ix == end.index()) {\n+                    applyStyle(ix, start.offset(), end.offset(), attrs, mergeAttributes);\n+                } else {\n+                    applyStyle(ix, start.offset(), Integer.MAX_VALUE, attrs, mergeAttributes);\n+                    ix++;\n+                    while (ix < end.index()) {\n+                        applyStyle(ix, 0, Integer.MAX_VALUE, attrs, mergeAttributes);\n+                        ix++;\n+                    }\n+                    applyStyle(ix, 0, end.offset(), attrs, mergeAttributes);\n+                }\n+                changed = true;\n+            }\n+\n+            if (changed) {\n+                fireStyleChangeEvent(evStart, evEnd);\n+                add(ch, end);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Removes unsupported attributes per {@link #getSupportedAttributes()}.\n+     *\n+     * @param attrs the input attributes\n+     * @return the attributes that exclude unsupported ones\n+     *\/\n+    private StyleAttributeMap filterUnsupportedAttributes(StyleAttributeMap attrs) {\n+        Set<StyleAttribute<?>> supported = getSupportedAttributes();\n+        if (supported == null) {\n+            return attrs;\n+        }\n+\n+        StyleAttributeMap.Builder b = StyleAttributeMap.builder();\n+        for (StyleAttribute a : attrs.getAttributes()) {\n+            if (supported.contains(a)) {\n+                b.set(a, attrs.get(a));\n+            }\n+        }\n+        return b.build();\n+    }\n+\n+    \/**\n+     * Clears the undo-redo stack.\n+     *\/\n+    public final void clearUndoRedo() {\n+        undo = head;\n+        updateUndoRedo();\n+    }\n+\n+    \/**\n+     * Adds an {@code UndoableChange} to the undo\/redo buffer.\n+     *\n+     * @param ch the change\n+     * @param end the caret position after the change\n+     *\/\n+    private void add(UndoableChange ch, TextPos end) {\n+        if (ch == null) {\n+            \/\/ the undo-redo system is in inconsistent state, let's drop everything\n+            clearUndoRedo();\n+            return;\n+        }\n+\n+        ch.setEndAfter(end);\n+        ch.setPrev(undo);\n+        undo.setNext(ch);\n+        undo = ch;\n+        updateUndoRedo();\n+    }\n+\n+    \/**\n+     * Undoes the recent change, if possible, returning an array comprising [start, end] text positions\n+     * prior to the change.\n+     * Returns null when the undo operation is not possible.\n+     *\n+     * @param resolver the StyleResolver to use\n+     * @return the [start, end] text positions prior to the change\n+     *\/\n+    public final TextPos[] undo(StyleResolver resolver) {\n+        if (undo != head) {\n+            try {\n+                undo.undo(resolver);\n+                TextPos[] sel = undo.getSelectionBefore();\n+                undo = undo.getPrev();\n+                updateUndoRedo();\n+                return sel;\n+            } catch (IOException e) {\n+                \/\/ undo-redo is in inconsistent state, clear\n+                clearUndoRedo();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Redoes the recent change, if possible, returning an array comprising [start, end] text positions\n+     * prior to the change.\n+     * Returns null when the redo operation is not possible.\n+     * @param resolver the StyleResolver to use\n+     * @return the [start, end] text positions prior to the change\n+     *\/\n+    public final TextPos[] redo(StyleResolver resolver) {\n+        if (undo.getNext() != null) {\n+            try {\n+                undo.getNext().redo(resolver);\n+                TextPos[] sel = undo.getNext().getSelectionAfter();\n+                undo = undo.getNext();\n+                updateUndoRedo();\n+                return sel;\n+            } catch (IOException e) {\n+                \/\/ undo-redo is in inconsistent state, clear\n+                clearUndoRedo();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * The property describes if it's currently possible to undo the latest change of the content that was done.\n+     * @return the read-only property\n+     * @defaultValue false\n+     *\/\n+    public final ReadOnlyBooleanProperty undoableProperty() {\n+        return undoable.getReadOnlyProperty();\n+    }\n+\n+    public final boolean isUndoable() {\n+        return undoable.get();\n+    }\n+\n+    private void setUndoable(boolean on) {\n+        undoable.set(on);\n+    }\n+\n+    \/**\n+     * The property describes if it's currently possible to redo the latest change of the content that was undone.\n+     * @return the read-only property\n+     * @defaultValue false\n+     *\/\n+    public final ReadOnlyBooleanProperty redoableProperty() {\n+        return redoable.getReadOnlyProperty();\n+    }\n+\n+    public final boolean isRedoable() {\n+        return redoable.get();\n+    }\n+\n+    private void setRedoable(boolean on) {\n+        redoable.set(on);\n+    }\n+\n+    private void updateUndoRedo() {\n+        setUndoable(undo != head);\n+        setRedoable(undo.getNext() != null);\n+    }\n+\n+    \/** for debugging *\/\n+    private String dump() {\n+        StringBuilder sb = new StringBuilder(2048);\n+        try {\n+            sb.append(\"\\n\");\n+            TextPos end = getDocumentEnd();\n+            export(TextPos.ZERO, end, new StyledOutput() {\n+                @Override\n+                public void consume(StyledSegment seg) throws IOException {\n+                    sb.append(\" \");\n+                    sb.append(seg);\n+                    sb.append(\"\\n\");\n+                }\n+\n+                @Override\n+                public void flush() throws IOException {\n+                }\n+\n+                @Override\n+                public void close() throws IOException {\n+                }\n+            });\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Replaces the content of the model with the data read from the input stream,\n+     * using the specified {@code DataFormat}.  This operation clears the undo\/redo stack.\n+     *\n+     * @param r the style resolver\n+     * @param f the data format\n+     * @param input the input stream\n+     * @throws IOException in case of an I\/O error\n+     * @throws UnsupportedOperationException when the data format is not supported by the model\n+     *\/\n+    public final void read(StyleResolver r, DataFormat f, InputStream input) throws IOException {\n+        clearUndoRedo();\n+        TextPos end = getDocumentEnd();\n+        DataFormatHandler h = getDataFormatHandler(f, false);\n+        if (h == null) {\n+            throw new UnsupportedOperationException(\"format not supported: \" + f);\n+        }\n+        String text = RichUtils.readString(input);\n+        StyledInput in = h.createStyledInput(text, null);\n+        replace(r, TextPos.ZERO, end, in, false);\n+    }\n+\n+    \/**\n+     * Writes the model content to the output stream using the specified {@code DataFormat}.\n+     *\n+     * @param r the style resolver\n+     * @param f the data format\n+     * @param out the output stream\n+     * @throws IOException in case of an I\/O error\n+     * @throws UnsupportedOperationException when the data format is not supported by the model\n+     *\/\n+    public final void write(StyleResolver r, DataFormat f, OutputStream out) throws IOException {\n+        TextPos end = getDocumentEnd();\n+        DataFormatHandler h = getDataFormatHandler(f, true);\n+        if (h == null) {\n+            throw new UnsupportedOperationException(\"format not supported: \" + f);\n+        }\n+        h.save(this, r, TextPos.ZERO, end, out);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/StyledTextModel.java","additions":969,"deletions":0,"binary":false,"changes":969,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.util.function.Supplier;\n+import javafx.scene.layout.Region;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * The base class for view-only {@link StyledTextModel}s.\n+ * <p>\n+ * Models extending this class will not be user editable.\n+ *\/\n+public abstract class StyledTextModelViewOnlyBase extends StyledTextModel {\n+    \/** The constructor. *\/\n+    public StyledTextModelViewOnlyBase() {\n+        registerDataFormatHandler(RichTextFormatHandler.INSTANCE, true, false, 2000);\n+    }\n+\n+    @Override\n+    public final boolean isUserEditable() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected void removeRange(TextPos start, TextPos end) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected int insertTextSegment(int index, int offset, String text, StyleAttributeMap attrs) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void insertLineBreak(int index, int offset) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void insertParagraph(int index, Supplier<Region> generator) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected final void setParagraphStyle(int ix, StyleAttributeMap a) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected final void applyStyle(int ix, int start, int end, StyleAttributeMap a, boolean merge) {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/StyledTextModelViewOnlyBase.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides common models for\n+ * {@link jfx.incubator.scene.control.richtext.RichTextArea RichTextArea} and\n+ * {@link jfx.incubator.scene.control.richtext.CodeArea CodeArea} controls.\n+ * <p>\n+ * The {@link jfx.incubator.scene.control.richtext.RichTextArea RichTextArea}\n+ * control separates data model from the view by providing the\n+ * {@link jfx.incubator.scene.control.richtext.RichTextArea#modelProperty() model} property.\n+ * The base class for any data model is\n+ * {@link jfx.incubator.scene.control.richtext.model.StyledTextModel StyledTextModel}.\n+ * This abstract class provides no data storage, focusing instead on providing common functionality\n+ * to the actual models, such as dealing with styled segments, keeping track of markers, sending events, etc.\n+ * <p>\n+ * This package provides a number of standard models are provided, each designed for a specific use case.\n+ * <ul>\n+ * <li>The {@link jfx.incubator.scene.control.richtext.model.RichTextModel RichTextModel} stores the data in memory,\n+ *     in the form of text segments styled with attributes defined in\n+ *     {@link jfx.incubator.scene.control.richtext.model.StyleAttributeMap StyleAttributeMap} class.\n+ *     This is a default model for RichTextArea.\n+ * <li>The {@link jfx.incubator.scene.control.richtext.model.BasicTextModel BasicTextModel}\n+ *     could be used as a base class for in-memory or virtualized text models based on plain text.\n+ *     This class provides foundation for the\n+ *     {@link jfx.incubator.scene.control.richtext.model.CodeTextModel CodeTextModel},\n+ *     which supports styling using a pluggable\n+ *     {@link jfx.incubator.scene.control.richtext.SyntaxDecorator SyntaxDecorator}.\n+ * <li>The abstract\n+ *     {@link jfx.incubator.scene.control.richtext.model.StyledTextModelViewOnlyBase StyledTextModelViewOnlyBase}\n+ *     is a base class for immutable models.  This class is used by\n+ *     {@link jfx.incubator.scene.control.richtext.model.SimpleViewOnlyStyledModel SimpleViewOnlyStyledModel}\n+ *     which simplifies building of in-memory view-only styled documents.\n+ * <\/ul>\n+ * <b><a href=\"https:\/\/openjdk.org\/jeps\/11\">Incubating Feature.<\/a>\n+ * Will be removed in a future release.<\/b>\n+ *\n+ * @since 999 TODO\n+ *\/\n+package jfx.incubator.scene.control.richtext.model;\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/package-info.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides two controls for displaying and editing large, virtualized, rich text documents:\n+ * {@link jfx.incubator.scene.control.richtext.RichTextArea RichTextArea} and\n+ * {@link jfx.incubator.scene.control.richtext.CodeArea CodeArea}.\n+ * <p>\n+ * While {@code RichTextArea} works with styled text and embedded Nodes,\n+ * the {@code CodeArea} is optimized for plain text documents with syntax highlighting.\n+ * <p>\n+ * <b><a href=\"https:\/\/openjdk.org\/jeps\/11\">Incubating Feature.<\/a>\n+ * Will be removed in a future release.<\/b>\n+ *\n+ * @since 999 TODO\n+ *\/\n+package jfx.incubator.scene.control.richtext;\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/package-info.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.skin;\n+\n+import javafx.scene.Node;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * This interface provides a mechanism for the Skin to support custom {@code StyleAttribute}s.\n+ * During the layout pass, the cell context is passed to the Skin so the latter can add inline style(s)\n+ * to either the paragraph Node (typically {@code TextFlow}) or the text segment Node ({@code Text}).\n+ *\n+ * @see RichTextAreaSkin#applyStyles(CellContext, StyleAttributeMap, boolean)\n+ *\/\n+public interface CellContext {\n+    \/**\n+     * Adds an inline style.\n+     * <p>\n+     * The inline style must be a valid CSS style string, for example {@code \"-fx-font-size:15px;\"}.\n+     * This string might contain multiple CSS properties.\n+     *\n+     * @param fxStyle the inline style string\n+     *\/\n+    public void addStyle(String fxStyle);\n+\n+    \/**\n+     * Returns the node being styled.\n+     * <p>\n+     * This might be a TextFlow (for the paragraph cell context) or Text (for the text segment cell context).\n+     * @return the node being styled.\n+     *\/\n+    public Node getNode();\n+\n+    \/**\n+     * Returns the current attributes.\n+     * @return the current attributes.\n+     *\/\n+    public StyleAttributeMap getAttributes();\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/skin\/CellContext.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.skin;\n+\n+import java.util.Locale;\n+import javafx.scene.text.Font;\n+import com.sun.jfx.incubator.scene.control.richtext.RichTextAreaSkinHelper;\n+import com.sun.jfx.incubator.scene.control.richtext.util.ListenerHelper;\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n+import jfx.incubator.scene.control.richtext.CodeArea;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * The skin for {@link CodeArea}.\n+ *\/\n+public class CodeAreaSkin extends RichTextAreaSkin {\n+    \/**\n+     * Constructs the CodeArea skin.\n+     * @param control the CodeArea instance\n+     *\/\n+    public CodeAreaSkin(CodeArea control) {\n+        super(control);\n+\n+        ListenerHelper lh = RichTextAreaSkinHelper.getListenerHelper(this);\n+        lh.addInvalidationListener(\n+            this::refreshLayout,\n+            control.fontProperty(),\n+            control.lineSpacingProperty(),\n+            control.tabSizeProperty()\n+        );\n+    }\n+\n+    @Override\n+    public void applyStyles(CellContext cx, StyleAttributeMap attrs, boolean forParagraph) {\n+        super.applyStyles(cx, attrs, forParagraph);\n+\n+        if (forParagraph) {\n+            CodeArea control = (CodeArea)getSkinnable();\n+            \/\/ font\n+            Font f = control.getFont();\n+            if (f != null) {\n+                double size = f.getSize();\n+                String family = f.getFamily();\n+                String name = f.getName();\n+                if (RichUtils.isLogicalFont(family)) {\n+                    String lowerCaseName = name.toLowerCase(Locale.ENGLISH);\n+                    String style = RichUtils.guessFontStyle(lowerCaseName);\n+                    String weight = RichUtils.guessFontWeight(lowerCaseName);\n+                    cx.addStyle(\"-fx-font-family:'\" + family + \"';\");\n+                    cx.addStyle(\"-fx-font-style:\" + style + \";\");\n+                    cx.addStyle(\"-fx-font-weight:\" + weight + \";\");\n+                } else {\n+                    cx.addStyle(\"-fx-font-family:'\" + name + \"';\");\n+                }\n+                cx.addStyle(\"-fx-font-size:\" + size + \";\");\n+            }\n+\n+            \/\/ line spacing\n+            double lineSpacing = control.getLineSpacing();\n+            cx.addStyle(\"-fx-line-spacing:\" + lineSpacing + \";\");\n+\n+            \/\/ tab size\n+            double tabSize = control.getTabSize();\n+            cx.addStyle(\"-fx-tab-size:\" + tabSize + \";\");\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/skin\/CodeAreaSkin.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,460 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxEditor\n+\n+package jfx.incubator.scene.control.richtext.skin;\n+\n+import javafx.event.EventHandler;\n+import javafx.geometry.Orientation;\n+import javafx.geometry.Point2D;\n+import javafx.scene.AccessibleAction;\n+import javafx.scene.AccessibleAttribute;\n+import javafx.scene.control.ScrollBar;\n+import javafx.scene.control.Skin;\n+import javafx.scene.control.SkinBase;\n+import javafx.scene.input.DataFormat;\n+import javafx.scene.input.InputMethodEvent;\n+import javafx.scene.input.InputMethodRequests;\n+import javafx.scene.input.ScrollEvent;\n+import javafx.scene.shape.PathElement;\n+import javafx.scene.text.Font;\n+import com.sun.jfx.incubator.scene.control.richtext.Params;\n+import com.sun.jfx.incubator.scene.control.richtext.RichTextAreaBehavior;\n+import com.sun.jfx.incubator.scene.control.richtext.RichTextAreaSkinHelper;\n+import com.sun.jfx.incubator.scene.control.richtext.TextCell;\n+import com.sun.jfx.incubator.scene.control.richtext.VFlow;\n+import com.sun.jfx.incubator.scene.control.richtext.util.ListenerHelper;\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.StyleHandlerRegistry;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+\n+\/**\n+ * Provides visual representation for RichTextArea.\n+ * <p>\n+ * This skin consists of a top level Pane that manages the following children:\n+ * <ul>\n+ * <li>virtual flow Pane\n+ * <li>horizontal scroll bar\n+ * <li>vertical scroll bar\n+ * <\/ul>\n+ *\/\n+public class RichTextAreaSkin extends SkinBase<RichTextArea> {\n+    private final ListenerHelper listenerHelper;\n+    private final RichTextAreaBehavior behavior;\n+    private final VFlow vflow;\n+    private final ScrollBar vscroll;\n+    private final ScrollBar hscroll;\n+    private final EventHandler<InputMethodEvent> inputMethodTextChangedHandler = this::handleInputMethodEvent;\n+    private InputMethodRequests inputMethodRequests;\n+\n+    static {\n+        RichTextAreaSkinHelper.setAccessor(new RichTextAreaSkinHelper.Accessor() {\n+            @Override\n+            public VFlow getVFlow(Skin<?> skin) {\n+                if (skin instanceof RichTextAreaSkin s) {\n+                    return s.getVFlow();\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public ListenerHelper getListenerHelper(Skin<?> skin) {\n+                return ((RichTextAreaSkin)skin).listenerHelper;\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Constructs the skin.\n+     * @param control the owner\n+     *\/\n+    public RichTextAreaSkin(RichTextArea control) {\n+        super(control);\n+\n+        this.listenerHelper = new ListenerHelper();\n+\n+        vscroll = createVScrollBar();\n+        vscroll.setOrientation(Orientation.VERTICAL);\n+        vscroll.addEventFilter(ScrollEvent.ANY, (ev) -> ev.consume());\n+\n+        hscroll = createHScrollBar();\n+        hscroll.setOrientation(Orientation.HORIZONTAL);\n+        hscroll.addEventFilter(ScrollEvent.ANY, (ev) -> ev.consume());\n+\n+        vflow = new VFlow(this, vscroll, hscroll);\n+        getChildren().add(vflow);\n+\n+        behavior = new RichTextAreaBehavior(control);\n+\n+        listenerHelper.addChangeListener(vflow::handleSelectionChange, control.selectionProperty());\n+        listenerHelper.addInvalidationListener(vflow::updateRateRestartBlink, true, control.caretBlinkPeriodProperty());\n+        listenerHelper.addInvalidationListener(vflow::updateCaretAndSelection, control.highlightCurrentParagraphProperty());\n+        listenerHelper.addInvalidationListener(vflow::handleContentPadding, true, control.contentPaddingProperty());\n+        listenerHelper.addInvalidationListener(vflow::handleDecoratorChange,\n+            control.leftDecoratorProperty(),\n+            control.rightDecoratorProperty()\n+        );\n+        listenerHelper.addInvalidationListener(vflow::handleUseContentHeight, true, control.useContentHeightProperty());\n+        listenerHelper.addInvalidationListener(vflow::handleUseContentWidth, true, control.useContentWidthProperty());\n+        listenerHelper.addInvalidationListener(vflow::handleVerticalScroll, vscroll.valueProperty());\n+        listenerHelper.addInvalidationListener(vflow::handleHorizontalScroll, hscroll.valueProperty());\n+        listenerHelper.addInvalidationListener(vflow::handleWrapText, control.wrapTextProperty());\n+        listenerHelper.addInvalidationListener(vflow::handleModelChange, control.modelProperty());\n+        listenerHelper.addChangeListener(control.modelProperty(), true, this::handleModelChange);\n+    }\n+\n+    @Override\n+    public void install() {\n+        getSkinnable().getInputMap().setSkinInputMap(behavior.getSkinInputMap());\n+\n+        \/\/ IMPORTANT: both setOnInputMethodTextChanged() and setInputMethodRequests() are required for IME to work\n+        if (getSkinnable().getOnInputMethodTextChanged() == null) {\n+            getSkinnable().setOnInputMethodTextChanged(inputMethodTextChangedHandler);\n+        }\n+\n+        if (getSkinnable().getInputMethodRequests() == null) {\n+            inputMethodRequests = new InputMethodRequests() {\n+                @Override\n+                public Point2D getTextLocation(int offset) {\n+                    System.out.println(\"getTextLocation offset=\" + offset); \/\/ FIX\n+                    return null;\n+                }\n+\n+                @Override\n+                public String getSelectedText() {\n+                    System.out.println(\"getSelectedText\"); \/\/ FIX\n+                    return null;\n+                }\n+\n+                @Override\n+                public int getLocationOffset(int x, int y) {\n+                    System.out.println(\"getLocationOffset x=\" + x + \" y=\" + y); \/\/ FIX\n+                    return 0;\n+                }\n+\n+                @Override\n+                public void cancelLatestCommittedText() {\n+                    System.out.println(\"cancelLatestCommittedText\"); \/\/ FIX\n+                }\n+            };\n+            \/\/ TODO getSkinnable().setInputMethodRequests(inputMethodRequests);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (getSkinnable() != null) {\n+            if (getSkinnable().getInputMethodRequests() == inputMethodRequests) {\n+                getSkinnable().setInputMethodRequests(null);\n+            }\n+            if (getSkinnable().getOnInputMethodTextChanged() == inputMethodTextChangedHandler) {\n+                getSkinnable().setOnInputMethodTextChanged(null);\n+            }\n+\n+            listenerHelper.disconnect();\n+            vflow.dispose();\n+            getChildren().remove(vflow);\n+\n+            super.dispose();\n+        }\n+    }\n+\n+    private void handleModelChange(Object src, StyledTextModel old, StyledTextModel m) {\n+        if (old != null) {\n+            old.removeListener(vflow);\n+        }\n+\n+        if (m != null) {\n+            m.addListener(vflow);\n+        }\n+    }\n+\n+    \/**\n+     * Creates the vertical scroll bar.\n+     * <p>\n+     * The subclasses may override this method to provide custom ScrollBar implementation.\n+     *\n+     * @return the vertical scroll bar\n+     *\/\n+    protected ScrollBar createVScrollBar() {\n+        return new ScrollBar();\n+    }\n+\n+    \/**\n+     * Creates the horizontal scroll bar.\n+     * <p>\n+     * The subclasses may override this method to provide custom ScrollBar implementation.\n+     *\n+     * @return the horizontal scroll bar\n+     *\/\n+    protected ScrollBar createHScrollBar() {\n+        return new ScrollBar();\n+    }\n+\n+    private VFlow getVFlow() {\n+        return vflow;\n+    }\n+\n+    \/**\n+     * Returns the skin's {@link StyleResolver}.\n+     * @return style resolver instance\n+     *\/\n+    public StyleResolver getStyleResolver() {\n+        return vflow;\n+    }\n+\n+    \/**\n+     * Copies the text in the specified format when selection exists and when the export in this format\n+     * is supported by the model, and the skin must be installed; otherwise, this method is a no-op.\n+     *\n+     * @param format data format\n+     *\/\n+    public void copyText(DataFormat format) {\n+        behavior.copy(format);\n+    }\n+\n+    \/**\n+     * Pastes the clipboard content at the caret, or, if selection exists, replacing the selected text.\n+     * The format must be supported by the model, and the skin must be installed,\n+     * otherwise this method has no effect.\n+     *\n+     * @param format data format\n+     *\/\n+    public void pasteText(DataFormat format) {\n+        behavior.paste(format);\n+    }\n+\n+    \/**\n+     * Applies styles based on supplied attribute set to either the whole paragraph or the text segment.\n+     * This method can be overriden by other skin implementations to provide additional styling.\n+     * The overriding method must call super implementation.\n+     *\n+     * @param context the cell context\n+     * @param attrs the attributes\n+     * @param forParagraph determines whether the styles are applied to the paragraph (true), or text segment (false)\n+     *\/\n+    public void applyStyles(CellContext context, StyleAttributeMap attrs, boolean forParagraph) {\n+        if (attrs != null) {\n+            RichTextArea c = getSkinnable();\n+            StyleHandlerRegistry r = c.getStyleHandlerRegistry();\n+            for (StyleAttribute a : attrs.getAttributes()) {\n+                Object v = attrs.get(a);\n+                if (v != null) {\n+                    r.process(c, forParagraph, context, a, v);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Discards any cached layout information and calls\n+     * {@link javafx.scene.Parent#requestLayout() requestLayout()}.\n+     *\/\n+    \/\/ TODO alternative: simply override requestLayout() ?\n+    public void refreshLayout() {\n+        vflow.invalidateLayout();\n+        getSkinnable().requestLayout();\n+    }\n+\n+    @Override\n+    protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {\n+        if (getSkinnable().isUseContentHeight()) {\n+            return super.computePrefHeight(width, topInset, rightInset, bottomInset, leftInset);\n+        }\n+        return Params.PREF_HEIGHT;\n+    }\n+\n+    @Override\n+    protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {\n+        if (getSkinnable().isUseContentWidth()) {\n+            return super.computePrefWidth(height, topInset, rightInset, bottomInset, leftInset);\n+        }\n+        return Params.PREF_WIDTH;\n+    }\n+\n+    @Override\n+    protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {\n+        return Params.MIN_HEIGHT;\n+    }\n+\n+    @Override\n+    protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {\n+        return Params.MIN_WIDTH;\n+    }\n+\n+    \/**\n+     * Handles an input method event.\n+     * @param ev the {@code InputMethodEvent} to be handled\n+     *\/\n+    private void handleInputMethodEvent(InputMethodEvent ev) {\n+        RichTextArea textInput = getSkinnable();\n+        \/** TODO this is taken from TextInputControlSkin:763\n+        if (textInput.isEditable() && !textInput.textProperty().isBound() && !textInput.isDisabled()) {\n+\n+            \/\/ remove previous input method text (if any) or selected text\n+            if (imlength != 0) {\n+                removeHighlight(imattrs);\n+                imattrs.clear();\n+                textInput.selectRange(imstart, imstart + imlength);\n+            }\n+\n+            \/\/ Insert committed text\n+            if (ev.getCommitted().length() != 0) {\n+                String committed = ev.getCommitted();\n+                textInput.replaceText(textInput.getSelection(), committed);\n+            }\n+\n+            \/\/ Replace composed text\n+            imstart = textInput.getSelection().getStart();\n+            StringBuilder composed = new StringBuilder();\n+            for (InputMethodTextRun run : ev.getComposed()) {\n+                composed.append(run.getText());\n+            }\n+            textInput.replaceText(textInput.getSelection(), composed.toString());\n+            imlength = composed.length();\n+            if (imlength != 0) {\n+                int pos = imstart;\n+                for (InputMethodTextRun run : ev.getComposed()) {\n+                    int endPos = pos + run.getText().length();\n+                    createInputMethodAttributes(run.getHighlight(), pos, endPos);\n+                    pos = endPos;\n+                }\n+                addHighlight(imattrs, imstart);\n+\n+                \/\/ Set caret position in composed text\n+                int caretPos = ev.getCaretPosition();\n+                if (caretPos >= 0 && caretPos < imlength) {\n+                    textInput.selectRange(imstart + caretPos, imstart + caretPos);\n+                }\n+            }\n+        }\n+        *\/\n+    }\n+\n+    @Override\n+    public void executeAccessibleAction(AccessibleAction action, Object... parameters) {\n+        switch(action) {\n+        case SHOW_TEXT_RANGE:\n+            {\n+                Integer start = (Integer)parameters[0];\n+                Integer end = (Integer)parameters[1];\n+                if (start != null && end != null) {\n+                    \/\/ TODO\n+\/\/                    scrollCharacterToVisible(end);\n+\/\/                    scrollCharacterToVisible(start);\n+\/\/                    scrollCharacterToVisible(end);\n+                }\n+                break;\n+            }\n+        default:\n+            super.executeAccessibleAction(action, parameters);\n+        }\n+    }\n+\n+    @Override\n+    protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {\n+        switch (attribute) {\n+        case BOUNDS_FOR_RANGE:\n+            {\n+                TextPos p = getSkinnable().getCaretPosition();\n+                if (p != null) {\n+                    int start = (Integer)parameters[0];\n+                    int end = (Integer)parameters[1];\n+                    PathElement[] elements = getVFlow().getRangeShape(p.index(), start, end + 1);\n+                    return RichUtils.pathToBoundsArray(getVFlow(), elements);\n+                }\n+                return null;\n+            }\n+        case FONT:\n+            {\n+                StyleAttributeMap a = getSkinnable().getActiveStyleAttributeMap();\n+                if (a != null) {\n+                    String family = a.getFontFamily();\n+                    if (family != null) {\n+                        Double size = a.getFontSize();\n+                        if (size != null) {\n+                            return Font.font(family, size);\n+                        }\n+                    }\n+                }\n+                return null;\n+            }\n+        case HORIZONTAL_SCROLLBAR:\n+            return hscroll;\n+        case LINE_FOR_OFFSET:\n+            {\n+                TextPos p = getSkinnable().getCaretPosition();\n+                if (p != null) {\n+                    TextCell cell = getVFlow().getCell(p.index());\n+                    if (cell != null) {\n+                        int offset = (Integer)parameters[0];\n+                        return cell.lineForOffset(offset);\n+                    }\n+                }\n+                return null;\n+            }\n+        case LINE_START:\n+            {\n+                TextPos p = getSkinnable().getCaretPosition();\n+                if (p != null) {\n+                    TextCell cell = getVFlow().getCell(p.index());\n+                    if (cell != null) {\n+                        int lineIndex = (Integer)parameters[0];\n+                        return cell.lineStart(lineIndex);\n+                    }\n+                }\n+                return null;\n+            }\n+        case LINE_END:\n+            {\n+                TextPos p = getSkinnable().getCaretPosition();\n+                if (p != null) {\n+                    TextCell cell = getVFlow().getCell(p.index());\n+                    if (cell != null) {\n+                        int lineIndex = (Integer)parameters[0];\n+                        return cell.lineEnd(lineIndex);\n+                    }\n+                }\n+                return null;\n+            }\n+        case OFFSET_AT_POINT:\n+            {\n+                Point2D screenPoint = (Point2D)parameters[0];\n+                TextPos p = getSkinnable().getTextPosition(screenPoint.getX(), screenPoint.getY());\n+                return p == null ? null : p.charIndex();\n+            }\n+        case VERTICAL_SCROLLBAR:\n+            return vscroll;\n+        default:\n+            return super.queryAccessibleAttribute(attribute, parameters);\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/skin\/RichTextAreaSkin.java","additions":460,"deletions":0,"binary":false,"changes":460,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Contains RichTextArea skin and related classes.\n+ * <p>\n+ * <b><a href=\"https:\/\/openjdk.org\/jeps\/11\">Incubating Feature.<\/a>\n+ * Will be removed in a future release.<\/b>\n+ *\n+ * @since 999 TODO\n+*\/\n+package jfx.incubator.scene.control.richtext.skin;\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/skin\/package-info.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Incubates the RichTextArea control and related classes.\n+ * <p>\n+ * <b><a href=\"https:\/\/openjdk.org\/jeps\/11\">Incubating Feature.<\/a>\n+ * Will be removed in a future release.<\/b>\n+ *\n+ * @moduleGraph\n+ * @since 999\n+ *\/\n+module jfx.incubator.richtext {\n+    requires transitive javafx.base;\n+    requires transitive javafx.graphics;\n+    requires transitive javafx.controls;\n+    requires transitive jfx.incubator.input;\n+    requires java.desktop;\n+\n+    exports jfx.incubator.scene.control.richtext;\n+    exports jfx.incubator.scene.control.richtext.skin;\n+    exports jfx.incubator.scene.control.richtext.model;\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/module-info.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext;\n+\n+import com.sun.jfx.incubator.scene.control.richtext.VFlow;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+\n+\/**\n+ * RichTextArea shim.\n+ *\/\n+public class RichTextAreaShim {\n+    \/** for when we need to access VFlow *\/\n+    public static VFlow vflow(RichTextArea t) {\n+        return t.vflow();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/shims\/java\/jfx\/incubator\/scene\/control\/richtext\/RichTextAreaShim.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jfx.incubator.scene.control.richtext.model;\n+\n+import java.util.List;\n+import jfx.incubator.scene.control.richtext.model.RichParagraph;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+\n+public class RichTextModelShim {\n+    public static List<StyledSegment> getSegments(RichParagraph par) {\n+        return par.getSegments();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/shims\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/RichTextModelShim.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+--add-exports javafx.base\/com.sun.javafx=ALL-UNNAMED\n+#\n+--add-exports javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.geom=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.perf=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.scene.text=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.scene=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.stage=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.tk=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.javafx.util=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.prism=ALL-UNNAMED\n+--add-exports javafx.graphics\/com.sun.scenario.animation=ALL-UNNAMED\n+#\n+--add-exports javafx.controls\/com.sun.javafx.scene.control.behavior=ALL-UNNAMED\n+--add-exports javafx.controls\/com.sun.javafx.scene.control.inputmap=ALL-UNNAMED\n+--add-exports javafx.controls\/com.sun.javafx.scene.control.skin=ALL-UNNAMED\n+--add-exports javafx.controls\/com.sun.javafx.scene.control=ALL-UNNAMED\n+#\n+--add-exports jfx.incubator.richtext\/com.sun.jfx.incubator.scene.control.dummy=ALL-UNNAMED\n+--add-exports jfx.incubator.richtext\/com.sun.jfx.incubator.scene.control.richtext=ALL-UNNAMED\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/addExports","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.jfx.incubator.scene.control.rich;\n+\n+import org.junit.jupiter.api.Test;\n+import com.sun.jfx.incubator.scene.control.richtext.VFlow;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.RichTextAreaShim;\n+\n+\/**\n+ * Tests RichTextArea control.\n+ *\/\n+public class TestRichTextArea {\n+    \/**\n+     * Tests the shim.\n+     *\/\n+    \/\/ TODO remove once a real test which needs the shim is added.\n+    @Test\n+    public void testShim() {\n+        RichTextArea t = new RichTextArea();\n+        VFlow f = RichTextAreaShim.vflow(t);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/com\/sun\/jfx\/incubator\/scene\/control\/rich\/TestRichTextArea.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.jfx.incubator.scene.control.richtext;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import jfx.incubator.scene.control.richtext.CodeArea;\n+import jfx.incubator.scene.control.richtext.model.CodeTextModel;\n+import jfx.incubator.scene.control.richtext.model.RichTextModel;\n+\n+\/**\n+ * Tests CodeArea.\n+ *\/\n+public class CodeAreaTest {\n+    @BeforeEach\n+    public void beforeEach() {\n+        setUncaughtExceptionHandler();\n+    }\n+\n+    @AfterEach\n+    public void cleanup() {\n+        removeUncaughtExceptionHandler();\n+    }\n+\n+    private void setUncaughtExceptionHandler() {\n+        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {\n+            if (throwable instanceof RuntimeException) {\n+                throw (RuntimeException)throwable;\n+            } else {\n+                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);\n+            }\n+        });\n+    }\n+\n+    private void removeUncaughtExceptionHandler() {\n+        Thread.currentThread().setUncaughtExceptionHandler(null);\n+    }\n+\n+    \/** can set a null and non-null CodeTextModel *\/\n+    @Test\n+    public void nullModel() {\n+        CodeArea t = new CodeArea();\n+        t.setModel(null);\n+        t.setModel(new CodeTextModel());\n+\n+    }\n+\n+    \/** disallows setting model other than CodeTextModel *\/\n+    @Test\n+    public void wrongModel() {\n+        CodeArea t = new CodeArea();\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> {\n+            t.setModel(new RichTextModel());\n+        });\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/control\/richtext\/CodeAreaTest.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.jfx.incubator.scene.control.richtext.model;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javafx.scene.paint.Color;\n+import javafx.scene.text.TextAlignment;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import com.sun.jfx.incubator.scene.control.richtext.RichTextFormatHandlerHelper;\n+import jfx.incubator.scene.control.richtext.model.ParagraphDirection;\n+import jfx.incubator.scene.control.richtext.model.RichTextFormatHandler;\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledInput;\n+import jfx.incubator.scene.control.richtext.model.StyledOutput;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+\n+\/**\n+ * Tests RichTextFormatHandler.\n+ *\/\n+public class TestRichTextFormatHandler {\n+    private static final boolean DEBUG = true;\n+\n+    @Test\n+    public void testRoundTrip() throws IOException {\n+        Object[] ss = {\n+            List.of(\n+                p(\n+                    a(StyleAttributeMap.BACKGROUND, Color.RED),\n+                    a(StyleAttributeMap.BULLET, \"⌘\"),\n+                    a(StyleAttributeMap.FIRST_LINE_INDENT, 10.0),\n+                    a(StyleAttributeMap.LINE_SPACING, 11.0),\n+                    a(StyleAttributeMap.PARAGRAPH_DIRECTION, ParagraphDirection.RIGHT_TO_LEFT)\n+                ),\n+                s(\"bold\", StyleAttributeMap.BOLD),\n+                s(\"font family\", a(StyleAttributeMap.FONT_FAMILY, \"Arial\")),\n+                s(\"font size\", a(StyleAttributeMap.FONT_SIZE, 12.0)),\n+                s(\"italic\", StyleAttributeMap.ITALIC),\n+                nl(),\n+\n+                p(\n+                    a(StyleAttributeMap.SPACE_ABOVE, 13.0),\n+                    a(StyleAttributeMap.SPACE_BELOW, 14.0),\n+                    a(StyleAttributeMap.SPACE_LEFT, 15.0),\n+                    a(StyleAttributeMap.SPACE_RIGHT, 16.0),\n+                    a(StyleAttributeMap.TEXT_ALIGNMENT, TextAlignment.CENTER),\n+                    a(StyleAttributeMap.PARAGRAPH_DIRECTION, ParagraphDirection.LEFT_TO_RIGHT)\n+                ),\n+                s(\"strike through\", StyleAttributeMap.STRIKE_THROUGH),\n+                s(\"text color\", a(StyleAttributeMap.TEXT_COLOR, Color.GREEN)),\n+                s(\"underline\", StyleAttributeMap.UNDERLINE),\n+                nl(),\n+\n+                s(\"combined\", StyleAttributeMap.ITALIC, a(StyleAttributeMap.TEXT_COLOR, Color.RED), StyleAttributeMap.UNDERLINE),\n+                nl()\n+\n+                \/\/ TODO test escapes in text, attribute names, attribute values\n+            )\n+        };\n+\n+        RichTextFormatHandler handler = RichTextFormatHandler.INSTANCE;\n+\n+        for (Object x : ss) {\n+            testRoundTrip(handler, (List<StyledSegment>)x);\n+        }\n+    }\n+\n+    @Test\n+    public void testStyleDeduplication() throws IOException {\n+        StyledSegment[] input = {\n+            s(\"0\", StyleAttributeMap.BOLD),\n+            s(\"1\", StyleAttributeMap.ITALIC),\n+            s(\"2\", StyleAttributeMap.BOLD),\n+            s(\"3\", StyleAttributeMap.ITALIC)\n+        };\n+\n+        StringWriter wr = new StringWriter();\n+        StyledOutput out = RichTextFormatHandlerHelper.createStyledOutput(RichTextFormatHandler.INSTANCE, null, wr);\n+        for (StyledSegment s : input) {\n+            out.consume(s);\n+        }\n+        out.flush();\n+        String s = wr.toString();\n+        Assertions.assertTrue(s.indexOf(\"{0}\") > 0);\n+        Assertions.assertTrue(s.indexOf(\"{1}\") > 0);\n+    }\n+\n+    @Test\n+    public void testEscapes() throws IOException {\n+        StringWriter wr = new StringWriter();\n+        StyledOutput out = RichTextFormatHandlerHelper.createStyledOutput(RichTextFormatHandler.INSTANCE, null, wr);\n+        out.consume(StyledSegment.of(\"{|%}\"));\n+        out.flush();\n+        String s = wr.toString();\n+        String expected = \"%7B%7C%25%7D\";\n+        Assertions.assertEquals(expected, s);\n+    }\n+\n+    \/\/ creates a segment with paragraph attributes\n+    private static StyledSegment p(Object... items) {\n+        StyleAttributeMap.Builder b = StyleAttributeMap.builder();\n+        for (Object x : items) {\n+            if (x instanceof StyleAttribute a) {\n+                b.set(a, Boolean.TRUE);\n+            } else if (x instanceof StyleAttributeMap a) {\n+                b.merge(a);\n+            } else {\n+                throw new Error(\"?\" + x);\n+            }\n+        }\n+        StyleAttributeMap attrs = b.build();\n+        checkParagraphType(attrs, true);\n+        return StyledSegment.ofParagraphAttributes(attrs);\n+    }\n+\n+    \/\/ creates a text segment\n+    private static StyledSegment s(String text, Object... items) {\n+        StyleAttributeMap.Builder b = StyleAttributeMap.builder();\n+        for (Object x : items) {\n+            if (x instanceof StyleAttribute a) {\n+                b.set(a, Boolean.TRUE);\n+            } else if (x instanceof StyleAttributeMap a) {\n+                b.merge(a);\n+            } else {\n+                throw new Error(\"?\" + x);\n+            }\n+        }\n+        StyleAttributeMap attrs = b.build();\n+        checkParagraphType(attrs, false);\n+        return StyledSegment.of(text, attrs);\n+    }\n+\n+    private static void checkParagraphType(StyleAttributeMap attrs, boolean forParagraph) {\n+        for (StyleAttribute a : attrs.getAttributes()) {\n+            Assertions.assertEquals(forParagraph, a.isParagraphAttribute(), \"wrong isParagraph: \" + a);\n+        }\n+    }\n+\n+    private static <T> StyleAttributeMap a(StyleAttribute<T> a, T value) {\n+        return StyleAttributeMap.builder().set(a, value).build();\n+    }\n+\n+    private static StyledSegment nl() {\n+        return StyledSegment.LINE_BREAK;\n+    }\n+\n+    private void testRoundTrip(RichTextFormatHandler handler, List<StyledSegment> input) throws IOException {\n+        \/\/ export to string\n+        int ct = 0;\n+        StringWriter wr = new StringWriter();\n+        StyledOutput out = RichTextFormatHandlerHelper.createStyledOutput(handler, null, wr);\n+        for (StyledSegment s : input) {\n+            if (DEBUG) {\n+                System.out.println(s);\n+            }\n+            out.consume(s);\n+            ct++;\n+        }\n+        out.flush();\n+        String exported = wr.toString();\n+        if (DEBUG) {\n+            System.out.println(\"exported \" + ct + \" segments=\" + exported);\n+        }\n+\n+        \/\/ import from string\n+        ArrayList<StyledSegment> segments = new ArrayList<>();\n+        StyledInput in = handler.createStyledInput(exported, null);\n+        StyledSegment seg;\n+        while ((seg = in.nextSegment()) != null) {\n+            if (DEBUG) {\n+                System.out.println(seg);\n+            }\n+            segments.add(seg);\n+        }\n+\n+        \/\/ check segments for equality\n+        Assertions.assertEquals(input.size(), segments.size());\n+        for (int i = 0; i < input.size(); i++) {\n+            StyledSegment is = input.get(i);\n+            StyledSegment rs = segments.get(i);\n+            Assertions.assertEquals(is.getType(), rs.getType());\n+            Assertions.assertEquals(is.getText(), rs.getText());\n+            Assertions.assertEquals(is.getStyleAttributeMap(null), rs.getStyleAttributeMap(null));\n+        }\n+\n+        \/\/ export to a string again\n+        wr = new StringWriter();\n+        out = RichTextFormatHandlerHelper.createStyledOutput(handler, null, wr);\n+        for (StyledSegment s : segments) {\n+            out.consume(s);\n+        }\n+        out.flush();\n+        String result = wr.toString();\n+        if (DEBUG) {\n+            System.out.println(\"result=\" + result);\n+        }\n+\n+        \/\/ relying on stable order of attributes\n+        Assertions.assertEquals(exported, result);\n+    }\n+\n+    private void testRoundTrip_DELETE(RichTextFormatHandler handler, String text) throws IOException {\n+        ArrayList<StyledSegment> segments = new ArrayList<>();\n+\n+        StyledInput in = handler.createStyledInput(text, null);\n+        StyledSegment seg;\n+        while ((seg = in.nextSegment()) != null) {\n+            segments.add(seg);\n+            if (DEBUG) {\n+                System.out.println(seg);\n+            }\n+        }\n+\n+        StringWriter wr = new StringWriter();\n+        StyledOutput out = RichTextFormatHandlerHelper.createStyledOutput(handler, null, wr);\n+        for (StyledSegment s : segments) {\n+            out.consume(s);\n+        }\n+        out.flush();\n+\n+        String result = wr.toString();\n+        Assertions.assertEquals(text, result);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/control\/richtext\/model\/TestRichTextFormatHandler.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.jfx.incubator.scene.control.richtext.model;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import com.sun.jfx.incubator.scene.control.richtext.SegmentStyledInput;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.RichParagraph;\n+import jfx.incubator.scene.control.richtext.model.RichTextModel;\n+import jfx.incubator.scene.control.richtext.model.RichTextModelShim;\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledInput;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+\n+\/**\n+ * Tests RichTextModel.\n+ *\/\n+public class TestRichTextModel {\n+    private static final StyleAttributeMap BOLD = StyleAttributeMap.builder().setBold(true).build();\n+    private static final StyleAttributeMap ITALIC = StyleAttributeMap.builder().setItalic(true).build();\n+\n+    @Test\n+    public void insertLineBreak() {\n+        test(List.of(p()), List.of(p(), p()), (m) -> {\n+            m.replace(null, TextPos.ZERO, TextPos.ZERO, \"\\n\", true);\n+        });\n+    }\n+\n+    @Test\n+    public void delete() {\n+        \/\/ delete paragraph (multiple segments), keep its attributes\n+        test(\n+            List.of(\n+                p(s(\"aa\", BOLD), s(\"bb\", ITALIC), s(\"cc\", BOLD))\n+            ),\n+            List.of(\n+                p(\"\", BOLD)\n+            ),\n+            (m) -> {\n+                m.replace(null, t(0, 0), t(0, 6), \"\", false);\n+            }\n+        );\n+\n+        \/\/ delete paragraph (single segment), keep its attributes\n+        test(\n+            List.of(\n+                p(\"aa\", BOLD)\n+            ),\n+            List.of(\n+                p(\"\", BOLD)\n+            ),\n+            (m) -> {\n+                m.replace(null, t(0, 0), t(0, 2), \"\", false);\n+            }\n+        );\n+\n+        \/\/ delete newline and merge segments with same attributes\n+        test(\n+            List.of(\n+                p(\"aa\", BOLD),\n+                p(\"bb\", BOLD)\n+            ),\n+            List.of(\n+                p(\"aabb\", BOLD)\n+            ),\n+            (m) -> {\n+                m.replace(null, t(0, 2), t(1, 0), \"\", false);\n+            }\n+        );\n+\n+        \/\/ delete empty paragraph, i.e. backspace from pos(2, 0)\n+        test(\n+            List.of(\n+                p(\"aa\", BOLD),\n+                p(),\n+                p(\"bb\", BOLD)\n+            ),\n+            List.of(\n+                p(\"aa\", BOLD),\n+                p(\"bb\", BOLD)\n+            ),\n+            (m) -> {\n+                m.replace(null, t(2, 0), t(1, 0), \"\", false);\n+            }\n+        );\n+    }\n+\n+    private static RichParagraph p() {\n+        return RichParagraph.builder().build();\n+    }\n+\n+    private static RichParagraph p(String text, StyleAttributeMap a) {\n+        return RichParagraph.builder().addSegment(text, a).build();\n+    }\n+\n+    private static RichParagraph p(StyledSegment... segments) {\n+        RichParagraph.Builder b = RichParagraph.builder();\n+        for (StyledSegment s : segments) {\n+            b.addSegment(s.getText(), s.getStyleAttributeMap(null));\n+        }\n+        return b.build();\n+    }\n+\n+    private static StyledSegment s(String text, StyleAttributeMap a) {\n+        return StyledSegment.of(text, a);\n+    }\n+\n+    private static TextPos t(int index, int offset) {\n+        return new TextPos(index, offset);\n+    }\n+\n+    protected void test(List<RichParagraph> initial, List<RichParagraph> expected, Consumer<StyledTextModel> op) {\n+        RichTextModel m = new RichTextModel();\n+\n+        \/\/ initial state\n+        boolean newline = false;\n+        for (RichParagraph par : initial) {\n+            if (newline) {\n+                TextPos p = m.getDocumentEnd();\n+                m.replace(null, p, p, \"\\n\", false);\n+            } else {\n+                newline = true;\n+            }\n+\n+            List<StyledSegment> ss = RichTextModelShim.getSegments(par);\n+            if (ss == null) {\n+                ss = List.of();\n+            }\n+            StyledSegment[] segments = ss.toArray(StyledSegment[]::new);\n+            StyledInput in = new SegmentStyledInput(segments);\n+            TextPos p = m.getDocumentEnd();\n+            m.replace(null, p, p, in, false);\n+        }\n+\n+        \/\/ test operation\n+        op.accept(m);\n+\n+        \/\/ compare\n+        int sz = m.size();\n+        ArrayList<RichParagraph> result = new ArrayList<>(sz);\n+        for (int i = 0; i < sz; i++) {\n+            RichParagraph p = m.getParagraph(i);\n+            result.add(p);\n+        }\n+        String err = checkEquals(expected, result);\n+        if(err != null) {\n+            System.err.println(\"Error: \" + err);\n+            System.err.println(\"expected=\" + dump(expected));\n+            System.err.println(\"actual=\" + dump(result));\n+            Assertions.fail(err);\n+        }\n+    }\n+\n+    private static String dump(List<RichParagraph> ps) {\n+        if(ps == null) {\n+            return \"null\";\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"\\n\");\n+        for (RichParagraph p : ps) {\n+            dump(sb, p);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static void dump(StringBuilder sb, RichParagraph p) {\n+        sb.append(\"  {pa=\").append(p.getParagraphAttributes());\n+        sb.append(\", segments=\");\n+        List<StyledSegment> ss = RichTextModelShim.getSegments(p);\n+        if(ss == null) {\n+            sb.append(\"null\");\n+        } else {\n+            sb.append(\"\\n\");\n+            for(StyledSegment s: ss) {\n+                sb.append(\"    {text=\\\"\").append(s.getText());\n+                sb.append(\"\\\", a=\").append(s.getStyleAttributeMap(null)).append(\"\\n\");\n+            }\n+        }\n+    }\n+\n+    private static boolean eq(Object a, Object b) {\n+        if (a == null) {\n+            return b == null;\n+        }\n+        return a.equals(b);\n+    }\n+\n+    private static String checkEquals(List<RichParagraph> expected, List<RichParagraph> actual) {\n+        int sz = expected.size();\n+        if (sz != actual.size()) {\n+            return \"expected array size=\" + sz + \" actual=\" + actual.size();\n+        }\n+\n+        for (int i = 0; i < sz; i++) {\n+            RichParagraph pa = expected.get(i);\n+            RichParagraph pb = actual.get(i);\n+\n+            if (!eq(pa.getParagraphAttributes(), pb.getParagraphAttributes())) {\n+                return \"paragraph attributes at ix=\" + i;\n+            }\n+\n+            List<StyledSegment> lsa = RichTextModelShim.getSegments(pa);\n+            List<StyledSegment> lsb = RichTextModelShim.getSegments(pb);\n+            if (!((lsa != null) && (lsb != null))) {\n+                if ((lsa == null) && (lsb == null)) {\n+                    return null;\n+                }\n+                return \"segment array mismatch at ix=\" + i;\n+            }\n+            if (lsa != null) {\n+                for (int j = 0; j < lsa.size(); j++) {\n+                    StyledSegment a = lsa.get(j);\n+                    StyledSegment b = lsb.get(j);\n+                    if (!eq(a.getText(), b.getText())) {\n+                        return \"segment text[\" + j + \"] at ix=\" + i;\n+                    }\n+                    if (!eq(a.getStyleAttributeMap(null), b.getStyleAttributeMap(null))) {\n+                        return \"segment attrs[\" + j + \"] at ix=\" + i;\n+                    }\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/control\/richtext\/model\/TestRichTextModel.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.jfx.incubator.scene.control.richtext.model;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.util.function.Consumer;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import com.sun.jfx.incubator.scene.control.richtext.RichTextFormatHandlerHelper;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.RichTextFormatHandler;\n+import jfx.incubator.scene.control.richtext.model.RichTextModel;\n+import jfx.incubator.scene.control.richtext.model.StyledInput;\n+import jfx.incubator.scene.control.richtext.model.StyledOutput;\n+\n+\/**\n+ * Tests RichTextModel handling of style attributes when editing.\n+ * The tests use RichTextFormatHandler presentation, which may or may not be the best idea,\n+ * but it's definitely the quickest.\n+ *\/\n+public class TestRichTextModelAttributes {\n+    @Test\n+    public void testInsertLineBreak() {\n+        \/\/ empty model\n+        t(\n+            null,\n+            (m) -> {\n+                m.replace(null, TextPos.ZERO, TextPos.ZERO, \"\\n\", false);\n+            },\n+            \"{!}\\n{!}\"\n+        );\n+\n+        \/\/ two newlines\n+        t(\n+            null,\n+            (m) -> {\n+                m.replace(null, TextPos.ZERO, TextPos.ZERO, \"\\n\\n\", false);\n+            },\n+            \"{!}\\n{!}\\n{!}\"\n+        );\n+\n+        \/\/ in front of 1st segment\n+        t(\n+            \"{b}{i}0123{!}\",\n+            (m) -> {\n+                m.replace(null, TextPos.ZERO, TextPos.ZERO, \"\\n\", false);\n+            },\n+            \"{!}\\n{b}{i}0123{!}\"\n+        );\n+\n+        \/\/ in the middle of segment: both parts retain styles\n+        t(\n+            \"{b}{i}0123{!}\",\n+            (m) -> {\n+                m.replace(null, new TextPos(0, 2), new TextPos(0, 2), \"\\n\", false);\n+            },\n+            \"{b}{i}01{!}\\n{0}23{!}\"\n+        );\n+\n+        \/\/ at the end of segment\n+        t(\n+            \"{b}{i}0123{!}\",\n+            (m) -> {\n+                m.replace(null, new TextPos(0, 4), new TextPos(0, 4), \"\\n\", false);\n+            },\n+            \"{b}{i}0123{!}\\n{!}\"\n+        );\n+    }\n+\n+    @Test\n+    public void testDeleteParagraphStart() {\n+        t(\n+            \"{fs|24.0}{tc|808080}aaaaa:  {fs|24.0}bbbbb{!}\",\n+            (m) -> {\n+                m.replace(null, p(0, 13), p(0, 0), \"\", false);\n+            },\n+            \"{!}\"\n+        );\n+    }\n+\n+    @Test\n+    public void testZeroWidthSegment() {\n+        t(\n+            \"{fs|24.0}{tc|808080}a: {fs|24.0}b{!}\\n{0}c: {1}d{!}\",\n+            (m) -> {\n+                m.replace(null, p(0, 4), p(1, 0), \"\", false);\n+            },\n+            \"{fs|24.0}{tc|808080}a: {fs|24.0}b{0}c: {1}d{!}\"\n+        );\n+    }\n+\n+    private static TextPos p(int index, int offset) {\n+        return new TextPos(index, offset);\n+    }\n+\n+    private void t(String initial, Consumer<RichTextModel> op, String expected) {\n+        try {\n+            RichTextModel m = new RichTextModel();\n+            RichTextFormatHandler h = RichTextFormatHandler.INSTANCE;\n+\n+            \/\/ set initial text\n+            if (initial != null) {\n+                StyledInput in = h.createStyledInput(initial, null);\n+                TextPos end = m.replace(null, TextPos.ZERO, TextPos.ZERO, in, false);\n+                \/\/ check initial text\n+                StringWriter wr = new StringWriter();\n+                StyledOutput out = RichTextFormatHandlerHelper.createStyledOutput(h, null, wr);\n+                m.export(TextPos.ZERO, end, out);\n+                String s = wr.toString();\n+                Assertions.assertEquals(initial, s, \"problem setting initial text\");\n+            }\n+\n+            op.accept(m);\n+\n+            \/\/ check output\n+            {\n+                StringWriter wr = new StringWriter();\n+                StyledOutput out = RichTextFormatHandlerHelper.createStyledOutput(h, null, wr);\n+                TextPos end = m.getDocumentEnd();\n+                m.export(TextPos.ZERO, end, out);\n+                String s = wr.toString();\n+                Assertions.assertEquals(expected, s, \"operation failed\");\n+            }\n+        } catch(IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/control\/richtext\/model\/TestRichTextModelAttributes.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-include \"base\", \"graphics\", \"controls\", \"swing\", \"swt\", \"fxml\", \"web\", \"media\", \"systemTests\"\n+include \"base\", \"graphics\", \"controls\", \"incubator.input\", \"incubator.richtext\", \"swing\", \"swt\", \"fxml\", \"web\", \"media\", \"systemTests\"\n@@ -31,0 +31,2 @@\n+project(\":incubator.input\").projectDir = file(\"modules\/jfx.incubator.input\")\n+project(\":incubator.richtext\").projectDir = file(\"modules\/jfx.incubator.richtext\")\n","filename":"settings.gradle","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<classpath>\n+\t<classpathentry kind=\"src\" path=\"src\"\/>\n+\t<classpathentry kind=\"src\" output=\"testbin\" path=\"test\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"test\" value=\"true\"\/>\n+\t\t\t<attribute name=\"optional\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.junit.JUNIT_CONTAINER\/5\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"test\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/base\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/controls\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/fxml\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/graphics\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/media\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/swing\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/web\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/incubator.richtext\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/incubator.input\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n+\t<classpathentry kind=\"output\" path=\"bin\"\/>\n+<\/classpath>\n","filename":"tests\/manual\/RichTextAreaDemo\/.classpath","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<projectDescription>\n+\t<name>RichTextAreaDemo<\/name>\n+\t<comment><\/comment>\n+\t<projects>\n+\t<\/projects>\n+\t<buildSpec>\n+\t\t<buildCommand>\n+\t\t\t<name>org.eclipse.jdt.core.javabuilder<\/name>\n+\t\t\t<arguments>\n+\t\t\t<\/arguments>\n+\t\t<\/buildCommand>\n+\t<\/buildSpec>\n+\t<natures>\n+\t\t<nature>org.eclipse.jdt.core.javanature<\/nature>\n+\t<\/natures>\n+<\/projectDescription>\n","filename":"tests\/manual\/RichTextAreaDemo\/.project","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"","filename":"tests\/manual\/RichTextAreaDemo\/.settings\/org.eclipse.core.resources.prefs","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":".settings\/org.eclipse.core.resources.prefs","status":"copied"},{"patch":"@@ -0,0 +1,24 @@\n+# Rich Text Area Demos\n+\n+This project contains a number of applications that use the new RichTextArea and CodeArea controls,\n+for the purposes of demonstration of capabilities as well as testing.\n+\n+\n+## Rich Editor Application\n+\n+[RichEditorDemoApp.java](src\/com\/oracle\/demo\/rich\/editor\/RichEditorDemoApp.java)\n+is an example of a simple standalone rich text editor that uses the new RichTextArea control.\n+\n+\n+\n+## RichTextArea Tester\n+\n+[RichTextAreaDemoApp.java](src\/com\/oracle\/demo\/rich\/rta\/RichTextAreaDemoApp.java)\n+provides a demo application primarily for testing of the RichTextArea behavior.\n+\n+\n+\n+## CodeArea Tester\n+\n+[CodeAreaDemoApp.java](src\/com\/oracle\/demo\/rich\/codearea\/CodeAreaDemoApp.java)\n+provides a demo application primarily for testing of the CodeArea behavior.\n","filename":"tests\/manual\/RichTextAreaDemo\/README.md","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.codearea;\n+\n+import javafx.application.Application;\n+import javafx.stage.Stage;\n+import com.oracle.demo.richtext.settings.FxSettings;\n+\n+\/**\n+ * CodeArea Demo Application.\n+ *\/\n+public class CodeAreaDemoApp extends Application {\n+    public static void main(String[] args) {\n+        Application.launch(CodeAreaDemoApp.class, args);\n+    }\n+\n+    @Override\n+    public void init() {\n+        FxSettings.useDirectory(\".CodeAreaDemoApp\");\n+    }\n+\n+    @Override\n+    public void start(Stage stage) throws Exception {\n+        new CodeAreaWindow(null).show();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/codearea\/CodeAreaDemoApp.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,355 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.codearea;\n+\n+import java.nio.charset.Charset;\n+import java.util.Base64;\n+import javafx.collections.ObservableList;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Orientation;\n+import javafx.geometry.Pos;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.CheckBox;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.Menu;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.SeparatorMenuItem;\n+import javafx.scene.control.SplitPane;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.Pane;\n+import javafx.stage.Window;\n+import javafx.util.StringConverter;\n+import com.oracle.demo.richtext.rta.FontOption;\n+import com.oracle.demo.richtext.rta.ROptionPane;\n+import com.oracle.demo.richtext.util.FX;\n+import jfx.incubator.scene.control.richtext.CodeArea;\n+import jfx.incubator.scene.control.richtext.SyntaxDecorator;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.CodeTextModel;\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * Main Panel contains CodeArea, split panes for quick size adjustment, and an option pane.\n+ *\/\n+public class CodeAreaDemoPane extends BorderPane {\n+    public final ROptionPane op;\n+    public final CodeArea control;\n+\n+    public CodeAreaDemoPane(CodeTextModel m) {\n+        FX.name(this, \"CodeAreaDemoPane\");\n+        control = new CodeArea(m);\n+\n+        SplitPane hsplit = new SplitPane(control, pane());\n+        FX.name(hsplit, \"hsplit\");\n+        hsplit.setBorder(null);\n+        hsplit.setDividerPositions(1.0);\n+        hsplit.setOrientation(Orientation.HORIZONTAL);\n+\n+        SplitPane vsplit = new SplitPane(hsplit, pane());\n+        FX.name(vsplit, \"vsplit\");\n+        vsplit.setBorder(null);\n+        vsplit.setDividerPositions(1.0);\n+        vsplit.setOrientation(Orientation.VERTICAL);\n+\n+        FontOption fontOption = new FontOption(\"font\", false, control.fontProperty());\n+\n+        CheckBox editable = new CheckBox(\"editable\");\n+        FX.name(editable, \"editable\");\n+        editable.selectedProperty().bindBidirectional(control.editableProperty());\n+\n+        CheckBox wrapText = new CheckBox(\"wrap text\");\n+        FX.name(wrapText, \"wrapText\");\n+        wrapText.selectedProperty().bindBidirectional(control.wrapTextProperty());\n+\n+        CheckBox displayCaret = new CheckBox(\"display caret\");\n+        FX.name(displayCaret, \"displayCaret\");\n+        displayCaret.selectedProperty().bindBidirectional(control.displayCaretProperty());\n+\n+        CheckBox fatCaret = new CheckBox(\"fat caret\");\n+        FX.name(fatCaret, \"fatCaret\");\n+        fatCaret.selectedProperty().addListener((s, p, on) -> {\n+            Node n = control.lookup(\".caret\");\n+            if (n != null) {\n+                if (on) {\n+                    n.setStyle(\n+                        \"-fx-stroke-width:2; -fx-stroke:red; -fx-effect:dropshadow(gaussian,rgba(0,0,0,.5),5,0,1,1);\");\n+                } else {\n+                    n.setStyle(null);\n+                }\n+            }\n+        });\n+\n+        CheckBox highlightCurrentLine = new CheckBox(\"highlight current line\");\n+        FX.name(highlightCurrentLine, \"highlightCurrentLine\");\n+        highlightCurrentLine.selectedProperty().bindBidirectional(control.highlightCurrentParagraphProperty());\n+\n+        ComboBox<Integer> tabSize = new ComboBox<>();\n+        FX.name(tabSize, \"tabSize\");\n+        tabSize.getItems().setAll(1, 2, 3, 4, 8, 16);\n+        tabSize.getSelectionModel().selectedItemProperty().addListener((s, p, v) -> {\n+            control.setTabSize(v);\n+        });\n+\n+        CheckBox customPopup = new CheckBox(\"custom popup menu\");\n+        FX.name(customPopup, \"customPopup\");\n+        customPopup.selectedProperty().addListener((s, p, v) -> {\n+            setCustomPopup(v);\n+        });\n+\n+        ComboBox<Insets> contentPadding = new ComboBox<>();\n+        FX.name(contentPadding, \"contentPadding\");\n+        contentPadding.setConverter(new StringConverter<Insets>() {\n+            @Override\n+            public String toString(Insets x) {\n+                if (x == null) {\n+                    return \"null\";\n+                }\n+                return String.format(\n+                    \"T%d, B%d, L%d, R%d\",\n+                    (int)x.getTop(),\n+                    (int)x.getBottom(),\n+                    (int)x.getLeft(),\n+                    (int)x.getRight()\n+                );\n+            }\n+\n+            @Override\n+            public Insets fromString(String s) {\n+                return null;\n+            }\n+        });\n+        contentPadding.getItems().setAll(\n+            null,\n+            new Insets(1),\n+            new Insets(2),\n+            new Insets(10),\n+            new Insets(22.22),\n+            new Insets(50),\n+            new Insets(100),\n+            new Insets(5, 10, 15, 20)\n+        );\n+        contentPadding.getSelectionModel().selectedItemProperty().addListener((s, p, v) -> {\n+            control.setContentPadding(v);\n+        });\n+\n+        ComboBox<Double> lineSpacing = new ComboBox<>();\n+        FX.name(lineSpacing, \"lineSpacing\");\n+        lineSpacing.getItems().setAll(\n+            0.0,\n+            5.0,\n+            31.415\n+        );\n+        lineSpacing.getSelectionModel().selectedItemProperty().addListener((s, p, v) -> {\n+            setLineSpacing(v);\n+        });\n+\n+        CheckBox lineNumbers = new CheckBox(\"line numbers\");\n+        FX.name(lineNumbers, \"lineNumbers\");\n+        lineNumbers.selectedProperty().bindBidirectional(control.lineNumbersEnabledProperty());\n+\n+        ComboBox<SyntaxDecorator> syntax = new ComboBox<>();\n+        FX.name(syntax, \"syntax\");\n+        syntax.getItems().addAll(\n+            null,\n+            new DemoSyntaxDecorator(),\n+            new JavaSyntaxDecorator()\n+        );\n+        syntax.setConverter(new StringConverter<SyntaxDecorator>() {\n+            @Override\n+            public String toString(SyntaxDecorator x) {\n+                return x == null ? \"<NULL>\" : x.toString();\n+            }\n+\n+            @Override\n+            public SyntaxDecorator fromString(String s) {\n+                return null;\n+            }\n+        });\n+        syntax.getSelectionModel().selectedItemProperty().addListener((s, p, v) -> {\n+            control.setSyntaxDecorator(v);\n+        });\n+\n+        op = new ROptionPane();\n+        op.option(editable);\n+        op.label(\"Font:\");\n+        op.option(fontOption);\n+        op.option(wrapText);\n+        op.option(displayCaret);\n+        op.option(fatCaret);\n+        op.option(highlightCurrentLine);\n+        op.option(lineNumbers);\n+        op.label(\"Tab Size:\");\n+        op.option(tabSize);\n+        op.option(customPopup);\n+        op.label(\"Content Padding:\");\n+        op.option(contentPadding);\n+        op.label(\"Line Spacing:\");\n+        op.option(lineSpacing);\n+        op.label(\"Syntax Highlighter:\");\n+        op.option(syntax);\n+\n+        setCenter(vsplit);\n+        setRight(op);\n+\n+        contentPadding.getSelectionModel().selectFirst();\n+        lineSpacing.getSelectionModel().selectFirst();\n+        syntax.getSelectionModel().selectFirst();\n+    }\n+\n+    protected static Pane pane() {\n+        Pane p = new Pane();\n+        SplitPane.setResizableWithParent(p, false);\n+        p.setStyle(\"-fx-background-color:#dddddd;\");\n+        return p;\n+    }\n+\n+    public Button addButton(String name, Runnable action) {\n+        Button b = new Button(name);\n+        b.setOnAction((ev) -> {\n+            action.run();\n+        });\n+\n+        toolbar().add(b);\n+        return b;\n+    }\n+\n+    public TBar toolbar() {\n+        if (getTop() instanceof TBar) {\n+            return (TBar)getTop();\n+        }\n+\n+        TBar t = new TBar();\n+        setTop(t);\n+        return t;\n+    }\n+\n+    public Window getWindow() {\n+        Scene s = getScene();\n+        if (s != null) {\n+            return s.getWindow();\n+        }\n+        return null;\n+    }\n+\n+    public void setOptions(Node n) {\n+        setRight(n);\n+    }\n+\n+    protected String generateStylesheet(boolean fat) {\n+        String s = \".rich-text-area .caret { -fx-stroke-width:\" + (fat ? 2 : 1) + \"; }\";\n+        return \"data:text\/css;base64,\" + Base64.getEncoder().encodeToString(s.getBytes(Charset.forName(\"utf-8\")));\n+    }\n+\n+    protected void setCustomPopup(boolean on) {\n+        if (on) {\n+            ContextMenu m = new ContextMenu();\n+            m.getItems().add(new MenuItem(\"Dummy\")); \/\/ otherwise no popup is shown\n+            m.addEventFilter(Menu.ON_SHOWING, (ev) -> {\n+                m.getItems().clear();\n+                populatePopupMenu(m.getItems());\n+            });\n+            control.setContextMenu(m);\n+        } else {\n+            control.setContextMenu(null);\n+        }\n+    }\n+\n+    protected void populatePopupMenu(ObservableList<MenuItem> items) {\n+        boolean sel = control.hasNonEmptySelection();\n+        boolean paste = true; \/\/ would be easier with Actions (findFormatForPaste() != null);\n+\n+        MenuItem m;\n+        items.add(m = new MenuItem(\"Undo\"));\n+        m.setOnAction((ev) -> control.undo());\n+        m.setDisable(!control.isUndoable());\n+\n+        items.add(m = new MenuItem(\"Redo\"));\n+        m.setOnAction((ev) -> control.redo());\n+        m.setDisable(!control.isRedoable());\n+\n+        items.add(new SeparatorMenuItem());\n+\n+        items.add(m = new MenuItem(\"Cut\"));\n+        m.setOnAction((ev) -> control.cut());\n+        m.setDisable(!sel);\n+\n+        items.add(m = new MenuItem(\"Copy\"));\n+        m.setOnAction((ev) -> control.copy());\n+        m.setDisable(!sel);\n+\n+        items.add(m = new MenuItem(\"Paste\"));\n+        m.setOnAction((ev) -> control.paste());\n+        m.setDisable(!paste);\n+\n+        items.add(new SeparatorMenuItem());\n+\n+        items.add(m = new MenuItem(\"Select All\"));\n+        m.setOnAction((ev) -> control.selectAll());\n+    }\n+\n+    protected <V> void apply(StyleAttribute<V> attr, V val) {\n+        TextPos ca = control.getCaretPosition();\n+        TextPos an = control.getAnchorPosition();\n+        StyleAttributeMap a = StyleAttributeMap.builder().set(attr, val).build();\n+        control.applyStyle(ca, an, a);\n+    }\n+\n+    protected void setLineSpacing(double x) {\n+        control.setLineSpacing(x);\n+    }\n+\n+    private <V> void applyStyle(StyleAttribute<V> a, V val) {\n+        TextPos ca = control.getCaretPosition();\n+        TextPos an = control.getAnchorPosition();\n+        StyleAttributeMap m = StyleAttributeMap.of(a, val);\n+        control.applyStyle(ca, an, m);\n+    }\n+\n+    \/\/\n+\n+    public static class TBar extends HBox {\n+        public TBar() {\n+            setFillHeight(true);\n+            setAlignment(Pos.CENTER_LEFT);\n+            setSpacing(2);\n+        }\n+\n+        public <T extends Node> T add(T n) {\n+            getChildren().add(n);\n+            return n;\n+        }\n+\n+        public void addAll(Node... nodes) {\n+            for (Node n : nodes) {\n+                add(n);\n+            }\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/codearea\/CodeAreaDemoPane.java","additions":355,"deletions":0,"binary":false,"changes":355,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.codearea;\n+\n+import javafx.application.Platform;\n+import javafx.geometry.Insets;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.MenuBar;\n+import javafx.scene.layout.BorderPane;\n+import javafx.stage.Stage;\n+import com.oracle.demo.richtext.rta.RichTextAreaWindow;\n+import com.oracle.demo.richtext.util.FX;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.CodeTextModel;\n+\n+\/**\n+ * CodeArea Demo window\n+ *\/\n+public class CodeAreaWindow extends Stage {\n+    private CodeTextModel model;\n+    public final CodeAreaDemoPane demoPane;\n+    public final Label status;\n+\n+    public CodeAreaWindow(CodeTextModel m) {\n+        model = (m == null ? new CodeTextModel() : m);\n+        demoPane = new CodeAreaDemoPane(model);\n+\n+        MenuBar mb = new MenuBar();\n+        FX.menu(mb, \"File\");\n+        FX.item(mb, \"New Window\", this::newWindow);\n+        FX.separator(mb);\n+        FX.item(mb, \"Close Window\", this::hide);\n+        FX.separator(mb);\n+        FX.item(mb, \"Quit\", () -> Platform.exit());\n+\n+        status = new Label();\n+        status.setPadding(new Insets(2, 10, 2, 10));\n+\n+        BorderPane bp = new BorderPane();\n+        bp.setTop(mb);\n+        bp.setCenter(demoPane);\n+        bp.setBottom(status);\n+\n+        Scene scene = new Scene(bp);\n+        setScene(scene);\n+        setTitle(\n+            \"CodeArea Tester  JFX:\" + System.getProperty(\"javafx.runtime.version\") +\n+            \"  JDK:\" + System.getProperty(\"java.version\")\n+        );\n+        setWidth(1200);\n+        setHeight(600);\n+\n+        demoPane.control.caretPositionProperty().addListener((x) -> updateStatus());\n+    }\n+\n+    protected void updateStatus() {\n+        RichTextArea t = demoPane.control;\n+        TextPos p = t.getCaretPosition();\n+\n+        StringBuilder sb = new StringBuilder();\n+\n+        if (p != null) {\n+            sb.append(\" line=\").append(p.index());\n+            sb.append(\" col=\").append(p.offset());\n+        }\n+\n+        status.setText(sb.toString());\n+    }\n+\n+    protected void newWindow() {\n+        double offset = 20;\n+\n+        CodeAreaWindow w = new CodeAreaWindow(model);\n+        w.setX(getX() + offset);\n+        w.setY(getY() + offset);\n+        w.setWidth(getWidth());\n+        w.setHeight(getHeight());\n+        w.show();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/codearea\/CodeAreaWindow.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.codearea;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import javafx.scene.paint.Color;\n+import jfx.incubator.scene.control.richtext.SyntaxDecorator;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.CodeTextModel;\n+import jfx.incubator.scene.control.richtext.model.RichParagraph;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * Simple {@code SyntaxDecorator} which emphasizes digits and java keywords.\n+ * This is just a demo.\n+ *\/\n+public class DemoSyntaxDecorator implements SyntaxDecorator {\n+    private static final StyleAttributeMap DIGITS = StyleAttributeMap.builder().setTextColor(Color.MAGENTA).build();\n+    private static final StyleAttributeMap KEYWORDS = StyleAttributeMap.builder().setTextColor(Color.GREEN).build();\n+    private static Pattern PATTERN = initPattern();\n+\n+    public DemoSyntaxDecorator() {\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"DemoSyntaxDecorator\";\n+    }\n+\n+    @Override\n+    public RichParagraph createRichParagraph(CodeTextModel model, int index) {\n+        String text = model.getPlainText(index);\n+        RichParagraph.Builder b = RichParagraph.builder();\n+        int len = text.length();\n+        if (len > 0) {\n+            Matcher m = PATTERN.matcher(text);\n+            int beg = 0;\n+            while (m.find(beg)) {\n+                int start = m.start();\n+                if (start > beg) {\n+                    b.addSegment(text, beg, start, null);\n+                }\n+                int end = m.end();\n+                boolean digit = (m.end(1) >= 0);\n+                b.addSegment(text, start, end, digit ? DIGITS : KEYWORDS);\n+                beg = end;\n+            }\n+            if (beg < len) {\n+                b.addSegment(text, beg, len, null);\n+            }\n+        }\n+        return b.build();\n+    }\n+\n+    private static Pattern initPattern() {\n+        String[] keywords = {\n+            \"abstract\",\n+            \"assert\",\n+            \"boolean\",\n+            \"break\",\n+            \"byte\",\n+            \"case\",\n+            \"catch\",\n+            \"char\",\n+            \"class\",\n+            \"const\",\n+            \"continue\",\n+            \"default\",\n+            \"do\",\n+            \"double\",\n+            \"else\",\n+            \"enum\",\n+            \"extends\",\n+            \"final\",\n+            \"finally\",\n+            \"float\",\n+            \"for\",\n+            \"goto\",\n+            \"if\",\n+            \"implements\",\n+            \"import\",\n+            \"instanceof\",\n+            \"int\",\n+            \"interface\",\n+            \"long\",\n+            \"native\",\n+            \"new\",\n+            \"package\",\n+            \"private\",\n+            \"protected\",\n+            \"public\",\n+            \"return\",\n+            \"short\",\n+            \"static\",\n+            \"strictfpv\",\n+            \"super\",\n+            \"switch\",\n+            \"synchronized\",\n+            \"this\",\n+            \"throw\",\n+            \"throws\",\n+            \"transient\",\n+            \"try\",\n+            \"void\",\n+            \"volatile\",\n+            \"while\"\n+        };\n+\n+        StringBuilder sb = new StringBuilder();\n+        \/\/ digits\n+        sb.append(\"(\\\\b\\\\d+\\\\b)\");\n+\n+        \/\/ keywords\n+        for (String k : keywords) {\n+            sb.append(\"|\\\\b(\");\n+            sb.append(k);\n+            sb.append(\")\\\\b\");\n+        }\n+        return Pattern.compile(sb.toString());\n+    }\n+\n+    @Override\n+    public void handleChange(CodeTextModel m, TextPos start, TextPos end, int charsTop, int linesAdded, int charsBottom) {\n+        \/\/ no-op\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/codearea\/DemoSyntaxDecorator.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,891 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.codearea;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * A simple Java syntax analyzer implemented as a recursive descent parser.\n+ * This is just a demo, as it has no link to the real compiler, does not understand Java language,\n+ * does not take into account version-specific language features, and reports no errors.\n+ * It also does not check validity of numeric literals, allowing malformed octal or binary numbers,\n+ * or values that are too large to be represented.\n+ *\/\n+public class JavaSyntaxAnalyzer {\n+    private boolean DEBUG = false;\n+\n+    \/** Encapsulates a paragraph containing segments with syntax highlighting *\/\n+    public static class Line {\n+        private ArrayList<Segment> segments = new ArrayList<>();\n+\n+        \/**\n+         * The constructor.\n+         *\/\n+        public Line() {\n+        }\n+\n+        \/**\n+         * Adds a segment.\n+         * @param type the segment type\n+         * @param text the segment text\n+         *\/\n+        public void addSegment(Type type, String text) {\n+            segments.add(new Segment(type, text));\n+        }\n+\n+        \/**\n+         * Returns the list of segments.\n+         * @return the list of segments\n+         *\/\n+        public List<Segment> getSegments() {\n+            return segments;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return segments.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object x) {\n+            if (x == this) {\n+                return true;\n+            } else if (x instanceof Line n) {\n+                return segments.equals(n.segments);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return 0; \/\/ we only need equals, don't put a hash table!\n+        }\n+    }\n+\n+    \/**\n+     * Encapsulates a text segment with the same syntax highlight type.\n+     *\/\n+    public static class Segment {\n+        private final Type type;\n+        private final String text;\n+\n+        \/**\n+         * The constructor.\n+         * @param type the segment type\n+         * @param text the segment text\n+         *\/\n+        public Segment(Type type, String text) {\n+            this.type = type;\n+            this.text = text;\n+        }\n+\n+        \/**\n+         * Returns the segment type.\n+         * @return the segment type\n+         *\/\n+        public Type getType() {\n+            return type;\n+        }\n+\n+        \/**\n+         * Returns the segment text.\n+         * @return the segment text\n+         *\/\n+        public String getText() {\n+            return text;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return type + \":[\" + text + \"]\";\n+        }\n+\n+        @Override\n+        public boolean equals(Object x) {\n+            if (x == this) {\n+                return true;\n+            } else if (x instanceof Segment s) {\n+                return\n+                    (type == s.type) &&\n+                    (text.equals(s.text));\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return 0; \/\/ we only need equals, don't put a hash table!\n+        }\n+    }\n+\n+    \/**\n+     * Defines the segment type generated by this analyzer\n+     *\/\n+    public enum Type {\n+        CHARACTER,\n+        COMMENT,\n+        KEYWORD,\n+        NUMBER,\n+        OTHER,\n+        STRING,\n+    }\n+\n+    private enum State {\n+        COMMENT_BLOCK,\n+        COMMENT_LINE,\n+        EOF,\n+        EOL,\n+        KEYWORD,\n+        OTHER,\n+        STRING,\n+        TEXT_BLOCK,\n+        WHITESPACE,\n+    }\n+\n+    private static final int EOF = -1;\n+    private static Pattern KEYWORDS;\n+    private static Pattern CHARS;\n+    static { init(); }\n+\n+    private final String text;\n+    private final Matcher keywordMatcher;\n+    private final Matcher charsMatcher;\n+    private int pos;\n+    private int start;\n+    private boolean blockComment;\n+    private State state = State.OTHER;\n+    private int tokenLength;\n+    private ArrayList<Line> lines;\n+    private Line currentLine;\n+\n+    \/**\n+     * Creates the syntax analyzer initialized with the specified text.\n+     * The text must have newline ({@code \/n}) characters as line delimiters.\n+     * @param text the input text\n+     *\/\n+    public JavaSyntaxAnalyzer(String text) {\n+        this.text = text;\n+        this.keywordMatcher = KEYWORDS.matcher(text);\n+        this.charsMatcher = CHARS.matcher(text);\n+    }\n+\n+    private static void init() {\n+        String[] keywords = {\n+            \"abstract\",\n+            \"assert\",\n+            \"boolean\",\n+            \"break\",\n+            \"byte\",\n+            \"case\",\n+            \"catch\",\n+            \"char\",\n+            \"class\",\n+            \"const\",\n+            \"continue\",\n+            \"default\",\n+            \"do\",\n+            \"double\",\n+            \"else\",\n+            \"enum\",\n+            \"extends\",\n+            \"false\",\n+            \"final\",\n+            \"finally\",\n+            \"float\",\n+            \"for\",\n+            \"goto\",\n+            \"if\",\n+            \"implements\",\n+            \"import\",\n+            \"instanceof\",\n+            \"int\",\n+            \"interface\",\n+            \"long\",\n+            \"native\",\n+            \"new\",\n+            \"package\",\n+            \"private\",\n+            \"protected\",\n+            \"public\",\n+            \"return\",\n+            \"short\",\n+            \"static\",\n+            \"strictfpv\",\n+            \"super\",\n+            \"switch\",\n+            \"synchronized\",\n+            \"this\",\n+            \"throw\",\n+            \"throws\",\n+            \"transient\",\n+            \"true\",\n+            \"try\",\n+            \"var\",\n+            \"void\",\n+            \"volatile\",\n+            \"while\"\n+        };\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"\\\\G\"); \/\/ match at start of the input in match(pos);\n+        sb.append(\"(\"); \/\/ capturing group\n+        boolean sep = false;\n+        for (String k : keywords) {\n+            if (sep) {\n+                sb.append(\"|\");\n+            } else {\n+                sep = true;\n+            }\n+            sb.append(\"(\"); \/\/ capturing group\n+            sb.append(k);\n+            \/\/ TODO add a post-match check instead\n+            sb.append(\"\\\\b\"); \/\/ word boundary\n+            sb.append(\")\"); \/\/ capturing group\n+        }\n+        sb.append(\")\"); \/\/ capturing group\n+\n+        KEYWORDS = Pattern.compile(sb.toString());\n+\n+        String charsPattern =\n+            \"(\\\\G\\\\\\\\[bfnrt'\\\"\\\\\\\\]')|\" +  \/\/ \\b' + \\f' + \\n' + \\r' + \\t' + \\'' + \\\"' +  \\\\'\n+            \"(\\\\G[^\\\\\\\\u]')|\" + \/\/ any char followed by ', except u and \\\n+            \"(\\\\G\\\\\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]')\" \/\/ unicode escapes\n+            ;\n+        CHARS = Pattern.compile(charsPattern);\n+    }\n+\n+    \/\/ returns the length of java keyword, 0 if not a java keyword\n+    private int matchJavaKeyword() {\n+        int c = charAt(-1);\n+        if (Character.isJavaIdentifierPart(c)) {\n+            return 0;\n+        }\n+\n+        c = charAt(0);\n+        switch (c) {\n+        case 'a':\n+        case 'b':\n+        case 'c':\n+        case 'd':\n+        case 'e':\n+        case 'f':\n+        case 'g':\n+        case 'i':\n+        case 'l':\n+        case 'n':\n+        case 'p':\n+        case 'r':\n+        case 's':\n+        case 't':\n+        case 'v':\n+        case 'w':\n+            break;\n+        default:\n+            return 0;\n+        };\n+\n+        if (keywordMatcher.find(pos)) {\n+            int start = keywordMatcher.start();\n+            int end = keywordMatcher.end();\n+            switch (charAt(end - pos)) {\n+            case '.':\n+                return 0;\n+            }\n+\n+            return (end - start);\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ returns the length of the character, or 0 if not a character\n+    private int matchCharacter() {\n+        if(charsMatcher.find(pos + 1)) {\n+            int start = charsMatcher.start();\n+            int end = charsMatcher.end();\n+            return (end - start);\n+        }\n+        return 0;\n+    }\n+\n+    private int peek() {\n+        if (pos < text.length()) {\n+            return text.charAt(pos);\n+        }\n+        return EOF;\n+    }\n+\n+    private Type type(State s) {\n+        switch(s) {\n+        case COMMENT_BLOCK:\n+            return Type.COMMENT;\n+        case COMMENT_LINE:\n+            return Type.COMMENT;\n+        case EOF:\n+            return Type.OTHER;\n+        case EOL:\n+            return Type.OTHER;\n+        case KEYWORD:\n+            return Type.KEYWORD;\n+        case OTHER:\n+            return Type.OTHER;\n+        case STRING:\n+            return Type.STRING;\n+        case TEXT_BLOCK:\n+            return Type.STRING;\n+        case WHITESPACE:\n+            return Type.OTHER;\n+        default:\n+            throw new Error(\"?\" + s);\n+        }\n+    }\n+\n+    private void addSegment() {\n+        Type type = type(state);\n+        addSegment(type);\n+    }\n+\n+    private void addSegment(Type type) {\n+        if (pos > start) {\n+            String s = text.substring(start, pos);\n+\n+            if (currentLine == null) {\n+                currentLine = new Line();\n+            }\n+            currentLine.addSegment(type, s);\n+\n+            start = pos;\n+            if(DEBUG) System.out.println(\"  \" + type + \":[\" + s + \"]\"); \/\/ FIX\n+        }\n+    }\n+\n+    private void addNewLine() {\n+        if (currentLine == null) {\n+            currentLine = new Line();\n+        }\n+        lines.add(currentLine);\n+        currentLine = null;\n+        if(DEBUG) System.out.println(\"  <NL>\"); \/\/ FIX\n+    }\n+\n+    private boolean match(String pattern) {\n+        for (int i = 0; i < pattern.length(); i++) {\n+            if (charAt(i) != pattern.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        tokenLength = pattern.length();\n+        return true;\n+    }\n+\n+    \/\/ relative to 'pos'\n+    private int charAt(int ix) {\n+        ix += pos;\n+        if ((ix >= 0) && (ix < text.length())) {\n+            return text.charAt(ix);\n+        }\n+        return EOF;\n+    }\n+\n+    \/\/ leading: \"\"\"(whitespace)\\n  trailing: \"\"\"(whitespace);\n+    private boolean isTextBlock(boolean leading) {\n+        for (int i = 0; ; i++) {\n+            int c = charAt(i);\n+            switch (c) {\n+            case '\"':\n+                if (i >= 3) {\n+                    return false;\n+                }\n+                break;\n+            case ' ':\n+            case '\\t':\n+                if (i < 3) {\n+                    return false;\n+                }\n+                break;\n+            case '\\n':\n+                if (leading) {\n+                    tokenLength = i;\n+                    return true;\n+                } else {\n+                    return false;\n+                }\n+            case ';':\n+                if (i < 3) {\n+                    return false;\n+                }\n+                if (!leading) {\n+                    tokenLength = i;\n+                    return true;\n+                }\n+            case -1:\n+            default:\n+                return false;\n+            }\n+        }\n+    }\n+\n+    \/\/ relative to pos\n+    private boolean isBoundedByDigit(boolean hex, int ix, boolean increase) {\n+        for(;;) {\n+            int c = charAt(ix);\n+            switch (c) {\n+            case '0':\n+            case '1':\n+            case '2':\n+            case '3':\n+            case '4':\n+            case '5':\n+            case '6':\n+            case '7':\n+            case '8':\n+            case '9':\n+                return true;\n+            case 'a':\n+            case 'A':\n+            case 'b':\n+            case 'B':\n+            case 'c':\n+            case 'C':\n+            case 'd':\n+            case 'D':\n+            case 'e':\n+            case 'E':\n+            case 'f':\n+            case 'F':\n+                return hex ? true : false;\n+            case '_':\n+                break;\n+            default:\n+                return false;\n+            }\n+\n+            ix += (increase ? 1 : -1);\n+        }\n+    }\n+\n+    \/\/ TODO move up\n+    private enum Phase {\n+        S_BEG, \/\/ beginning of significand, before period\n+        S_PER, \/\/ decimal point in the significand\n+        S_END, \/\/ after period in significand\n+        E_DIV, \/\/ exponent divider ('e' or 'E')\n+        E_SIG, \/\/ exponent sign\n+        E_BEG, \/\/ exponent before decimal point\n+        E_END, \/\/ after decimal point in the exponent\n+        HEX,   \/\/ hexadecimal literal\n+        BIN,   \/\/ binary literal\n+        UNKNOWN\n+    }\n+    private Phase phase;\n+    private boolean hasSignificand;\n+    private boolean hasExponent;\n+\n+    private int matchNumber() {\n+        int c = charAt(0);\n+        switch (c) {\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            c = charAt(-1);\n+            switch (c) {\n+            case -1:\n+                break;\n+            default:\n+                if (Character.isJavaIdentifierPart(c)) {\n+                    return 0;\n+                }\n+            }\n+            break;\n+        case '.':\n+            break;\n+        default:\n+            return 0;\n+        }\n+\n+        phase = Phase.UNKNOWN;\n+        hasSignificand = false;\n+        hasExponent = false;\n+\n+        for (int i = 0; ; i++) {\n+            c = charAt(i);\n+            char ch = (char)c; \/\/ FIX\n+            switch (c) {\n+            case '0':\n+            case '1':\n+            case '2':\n+            case '3':\n+            case '4':\n+            case '5':\n+            case '6':\n+            case '7':\n+            case '8':\n+            case '9':\n+                switch (phase) {\n+                case HEX:\n+                case BIN:\n+                    \/\/ not validating binary literals\n+                    hasSignificand = true;\n+                    break;\n+                case UNKNOWN:\n+                    phase = Phase.S_BEG;\n+                    hasSignificand = true;\n+                    break;\n+                case S_BEG:\n+                    hasSignificand = true;\n+                    break;\n+                case S_PER:\n+                    phase = Phase.S_END;\n+                    hasSignificand = true;\n+                    break;\n+                case E_DIV:\n+                case E_SIG:\n+                    phase = Phase.E_BEG;\n+                    hasExponent = true;\n+                    break;\n+                }\n+                break;\n+            case 'a':\n+            case 'A':\n+            case 'c':\n+            case 'C':\n+                switch (phase) {\n+                case HEX:\n+                    hasSignificand = true;\n+                    break;\n+                default:\n+                    return 0;\n+                }\n+                break;\n+            case '.':\n+                switch (phase) {\n+                case UNKNOWN:\n+                case S_BEG:\n+                    phase = Phase.S_PER;\n+                    break;\n+                default:\n+                    return 0;\n+                }\n+                break;\n+            case '_':\n+                switch (phase) {\n+                case HEX:\n+                    if (!(isBoundedByDigit(true, i - 1, false) && isBoundedByDigit(true, i + 1, true))) {\n+                        return 0;\n+                    }\n+                    break;\n+                case BIN:\n+                case S_BEG:\n+                case S_END:\n+                case E_BEG:\n+                case E_END:\n+                    if (!(isBoundedByDigit(false, i - 1, false) && isBoundedByDigit(false, i + 1, true))) {\n+                        return 0;\n+                    }\n+                    break;\n+                default:\n+                    return 0;\n+                }\n+                break;\n+            case 'e':\n+            case 'E':\n+                switch (phase) {\n+                case HEX:\n+                    hasSignificand = true;\n+                    break;\n+                case S_PER:\n+                    if(!hasSignificand) {\n+                        return 0;\n+                    }\n+                    \/\/ fall through\n+                case S_BEG:\n+                case S_END:\n+                    phase = Phase.E_DIV;\n+                    break;\n+                default:\n+                    return 0;\n+                }\n+                break;\n+            case 'd':\n+            case 'D':\n+            case 'f':\n+            case 'F':\n+                switch (phase) {\n+                case HEX:\n+                    hasSignificand = true;\n+                    break;\n+                case S_BEG:\n+                case S_PER:\n+                case S_END:\n+                    return hasSignificand ? (i + 1) : 0;\n+                case E_BEG:\n+                case E_END:\n+                    return hasExponent ? (i + 1) : 0;\n+                default:\n+                    return 0;\n+                }\n+                break;\n+            case '+':\n+            case '-':\n+                switch (phase) {\n+                case E_DIV:\n+                    phase = Phase.E_SIG;\n+                    break;\n+                case S_BEG:\n+                case S_END:\n+                case S_PER:\n+                    return i;\n+                default:\n+                    return 0;\n+                }\n+                break;\n+            case 'l':\n+            case 'L':\n+                switch (phase) {\n+                case HEX:\n+                case BIN:\n+                case S_BEG:\n+                    return i + 1;\n+                }\n+                return 0;\n+            case 'x':\n+            case 'X':\n+                if ((i == 1) && (charAt(i - 1) == '0')) {\n+                    phase = Phase.HEX;\n+                    hasSignificand = false;\n+                } else {\n+                    return 0;\n+                }\n+                break;\n+            case 'b':\n+            case 'B':\n+                switch (phase) {\n+                case HEX:\n+                    hasSignificand = true;\n+                    break;\n+                default:\n+                    if ((i == 1) && (charAt(i - 1) == '0')) {\n+                        phase = Phase.BIN;\n+                        hasSignificand = false;\n+                    } else {\n+                        return 0;\n+                    }\n+                }\n+                break;\n+            case -1:\n+            default:\n+                switch (phase) {\n+                case S_PER:\n+                case HEX:\n+                case BIN:\n+                    return hasSignificand ? i : 0;\n+                case S_BEG:\n+                case S_END:\n+                case E_BEG:\n+                case E_END:\n+                    return i;\n+                default:\n+                    return 0;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Analyzes the input text, producing a list of {@code Line}s containing syntax information.\n+     * @return the list of lines with syntax highlighting\n+     *\/\n+    public List<Line> analyze() {\n+        if(DEBUG) System.out.println(\"analyze\"); \/\/ FIX\n+        lines = new ArrayList<>();\n+        start = 0;\n+\n+        for (;;) {\n+            tokenLength = 0;\n+            int c = peek();\n+\n+            switch (c) {\n+            case '*':\n+                switch (state) {\n+                case COMMENT_BLOCK:\n+                    if (match(\"*\/\")) {\n+                        pos += tokenLength;\n+                        addSegment();\n+                        state = State.OTHER;\n+                        continue;\n+                    }\n+                }\n+                break;\n+            case '\\n':\n+                addSegment();\n+                addNewLine();\n+                pos++;\n+                start = pos;\n+                switch (state) {\n+                case COMMENT_BLOCK:\n+                case TEXT_BLOCK:\n+                    break;\n+                default:\n+                    state = State.OTHER;\n+                    break;\n+                }\n+                continue;\n+            case '\/':\n+                switch(state) {\n+                case COMMENT_BLOCK:\n+                case COMMENT_LINE:\n+                case STRING:\n+                case TEXT_BLOCK:\n+                    break;\n+                default:\n+                    if (match(\"\/*\")) {\n+                        addSegment();\n+                        pos += tokenLength;\n+                        state = State.COMMENT_BLOCK;\n+                        continue;\n+                    } else if (match(\"\/\/\")) {\n+                        addSegment();\n+                        pos += tokenLength;\n+                        state = State.COMMENT_LINE;\n+                        continue;\n+                    }\n+                }\n+                break;\n+            case '\"':\n+                switch(state) {\n+                case COMMENT_BLOCK:\n+                case COMMENT_LINE:\n+                    break;\n+                case TEXT_BLOCK:\n+                    if(isTextBlock(false)) {\n+                        pos += tokenLength;\n+                        addSegment();\n+                        state = State.OTHER;\n+                        continue;\n+                    }\n+                    break;\n+                case STRING:\n+                    pos++;\n+                    addSegment();\n+                    state = State.OTHER;\n+                    continue;\n+                default:\n+                    if(isTextBlock(true)) {\n+                        addSegment();\n+                        pos += tokenLength;\n+                        state = State.TEXT_BLOCK;\n+                        continue;\n+                    } else {\n+                        addSegment();\n+                        state = State.STRING;\n+                    }\n+                    break;\n+                }\n+                break;\n+            case '\\'':\n+                switch(state) {\n+                case COMMENT_BLOCK:\n+                case COMMENT_LINE:\n+                case STRING:\n+                    break;\n+                default:\n+                    switch (charAt(1)) {\n+                    case '\\n':\n+                        pos++;\n+                        continue;\n+                    }\n+                    tokenLength = matchCharacter();\n+                    if (tokenLength > 0) {\n+                        addSegment();\n+                        pos += (tokenLength + 1);\n+                        addSegment(Type.CHARACTER);\n+                        state = State.OTHER;\n+                        continue;\n+                    }\n+                    break;\n+                }\n+                break;\n+            case '\\\\':\n+                switch (state) {\n+                case STRING:\n+                    switch (charAt(1)) {\n+                    case '\\n':\n+                        break;\n+                    default:\n+                        pos++;\n+                        break;\n+                    }\n+                    break;\n+                }\n+                break;\n+            case EOF:\n+                addSegment();\n+                if (currentLine != null) {\n+                    lines.add(currentLine);\n+                }\n+                if (lines.size() == 0) {\n+                    lines.add(new Line());\n+                }\n+                return lines;\n+            default:\n+                switch (state) {\n+                case OTHER:\n+                    tokenLength = matchJavaKeyword();\n+                    if (tokenLength > 0) {\n+                        addSegment();\n+                        pos += tokenLength;\n+                        addSegment(Type.KEYWORD);\n+                        state = State.OTHER;\n+                        continue;\n+                    }\n+                    tokenLength = matchNumber();\n+                    if (tokenLength > 0) {\n+                        addSegment();\n+                        pos += tokenLength;\n+                        addSegment(Type.NUMBER);\n+                        state = State.OTHER;\n+                        continue;\n+                    }\n+                    break;\n+                default:\n+                    break;\n+                }\n+                break;\n+            }\n+\n+            pos++;\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/codearea\/JavaSyntaxAnalyzer.java","additions":891,"deletions":0,"binary":false,"changes":891,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.codearea;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javafx.scene.paint.Color;\n+import jfx.incubator.scene.control.richtext.SyntaxDecorator;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.CodeTextModel;\n+import jfx.incubator.scene.control.richtext.model.RichParagraph;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * A simple {@code SyntaxDecorator} for Java source files.\n+ *\n+ * This is just a demo, as it has no link to the real compiler, does not understand Java language\n+ * and does not take into account version-specific language features.\n+ *\/\n+public class JavaSyntaxDecorator implements SyntaxDecorator {\n+    private static final StyleAttributeMap CHARACTER = mkStyle(Color.BLUE);\n+    private static final StyleAttributeMap COMMENT = mkStyle(Color.RED);\n+    private static final StyleAttributeMap KEYWORD = mkStyle(Color.GREEN);\n+    private static final StyleAttributeMap NUMBER = mkStyle(Color.MAGENTA);\n+    private static final StyleAttributeMap OTHER = mkStyle(Color.BLACK);\n+    private static final StyleAttributeMap STRING = mkStyle(Color.BLUE);\n+    private ArrayList<RichParagraph> paragraphs;\n+\n+    public JavaSyntaxDecorator() {\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"JavaSyntaxDecorator\";\n+    }\n+\n+\n+    @Override\n+    public void handleChange(CodeTextModel m, TextPos start, TextPos end, int top, int lines, int btm) {\n+        \/\/ in theory, it may reuse the portions that haven't changed\n+        \/\/ but java files are short enough to re-analyze in full each time\n+        reload(m);\n+    }\n+\n+    @Override\n+    public RichParagraph createRichParagraph(CodeTextModel model, int index) {\n+        if ((paragraphs == null) || (index >= paragraphs.size())) {\n+            return RichParagraph.builder().build();\n+        }\n+        return paragraphs.get(index);\n+    }\n+\n+    private static StyleAttributeMap mkStyle(Color c) {\n+        return StyleAttributeMap.builder().setTextColor(c).build();\n+    }\n+\n+    private void reload(CodeTextModel model) {\n+        String text = getPlainText(model);\n+        JavaSyntaxAnalyzer a = new JavaSyntaxAnalyzer(text);\n+        List<JavaSyntaxAnalyzer.Line> res = a.analyze();\n+        paragraphs = translate(res);\n+    }\n+\n+    private String getPlainText(CodeTextModel model) {\n+        StringBuilder sb = new StringBuilder(65536);\n+        int sz = model.size();\n+        boolean nl = false;\n+        for (int i = 0; i < sz; i++) {\n+            if (nl) {\n+                sb.append('\\n');\n+            } else {\n+                nl = true;\n+            }\n+            String s = model.getPlainText(i);\n+            sb.append(s);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private ArrayList<RichParagraph> translate(List<JavaSyntaxAnalyzer.Line> lines) {\n+        ArrayList<RichParagraph> res = new ArrayList<>(lines.size());\n+        for (JavaSyntaxAnalyzer.Line line : lines) {\n+            RichParagraph p = createParagraph(line);\n+            res.add(p);\n+        }\n+        return res;\n+    }\n+\n+    private RichParagraph createParagraph(JavaSyntaxAnalyzer.Line line) {\n+        RichParagraph.Builder b = RichParagraph.builder();\n+        for (JavaSyntaxAnalyzer.Segment seg : line.getSegments()) {\n+            JavaSyntaxAnalyzer.Type t = seg.getType();\n+            String text = seg.getText();\n+            StyleAttributeMap a = getStyleAttrs(t);\n+            b.addSegment(text, a);\n+        }\n+        return b.build();\n+    }\n+\n+    private StyleAttributeMap getStyleAttrs(JavaSyntaxAnalyzer.Type t) {\n+        switch(t) {\n+        case CHARACTER:\n+            return CHARACTER;\n+        case COMMENT:\n+            return COMMENT;\n+        case KEYWORD:\n+            return KEYWORD;\n+        case NUMBER:\n+            return NUMBER;\n+        case STRING:\n+            return STRING;\n+        }\n+        return OTHER;\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/codearea\/JavaSyntaxDecorator.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.common;\n+\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+public class Styles {\n+    \/\/ TODO perhaps we should specifically set fonts to be used,\n+    \/\/ and couple that with the app stylesheet\n+    public static final StyleAttributeMap TITLE = s(\"System\", 24, true);\n+    public static final StyleAttributeMap HEADING = s(\"System\", 18, true);\n+    public static final StyleAttributeMap SUBHEADING = s(\"System\", 14, true);\n+    public static final StyleAttributeMap BODY = s(\"System\", 12, false);\n+    public static final StyleAttributeMap MONOSPACED = s(\"Monospace\", 12, false);\n+\n+    private static StyleAttributeMap s(String font, double size, boolean bold) {\n+        return StyleAttributeMap.builder().\n+            setFontFamily(font).\n+            setFontSize(size).\n+            setBold(bold).\n+            build();\n+    }\n+\n+    public static StyleAttributeMap getStyleAttributeMap(TextStyle st) {\n+        switch (st) {\n+        case BODY:\n+            return BODY;\n+        case HEADING:\n+            return HEADING;\n+        case MONOSPACED:\n+            return MONOSPACED;\n+        case TITLE:\n+            return TITLE;\n+        case SUBHEADING:\n+            return SUBHEADING;\n+        default:\n+            return BODY;\n+        }\n+    }\n+\n+    public static TextStyle guessTextStyle(StyleAttributeMap attrs) {\n+        if (attrs != null) {\n+            if (attrs.isEmpty()) {\n+                return TextStyle.BODY;\n+            }\n+            StyleAttribute<?>[] keys = {\n+                StyleAttributeMap.BOLD,\n+                StyleAttributeMap.FONT_FAMILY,\n+                StyleAttributeMap.FONT_SIZE\n+            };\n+            for (TextStyle st : TextStyle.values()) {\n+                StyleAttributeMap a = getStyleAttributeMap(st);\n+                if (match(attrs, a, keys)) {\n+                    return st;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static boolean match(StyleAttributeMap attrs, StyleAttributeMap builtin, StyleAttribute<?>[] keys) {\n+        for (StyleAttribute<?> k : keys) {\n+            Object v1 = attrs.get(k);\n+            Object v2 = builtin.get(k);\n+            if (!eq(v1, v2)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private static boolean eq(Object a, Object b) {\n+        if (a == null) {\n+            return b == null;\n+        }\n+        return a.equals(b);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/common\/Styles.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.common;\n+\n+import javafx.util.StringConverter;\n+\n+\/**\n+ * Build-in text styles.\n+ *\/\n+public enum TextStyle {\n+    TITLE,\n+    HEADING,\n+    SUBHEADING,\n+    BODY,\n+    MONOSPACED;\n+\n+    public String getDisplayName() {\n+        switch (this) {\n+        case BODY:\n+            return \"Body\";\n+        case HEADING:\n+            return \"Heading\";\n+        case MONOSPACED:\n+            return \"Monospaced\";\n+        case TITLE:\n+            return \"Title\";\n+        case SUBHEADING:\n+            return \"Subheading\";\n+        default:\n+            return \"?\" + this;\n+        }\n+    }\n+\n+    public static StringConverter<TextStyle> converter() {\n+        return new StringConverter<TextStyle>() {\n+            @Override\n+            public String toString(TextStyle t) {\n+                return t == null ? null : t.getDisplayName();\n+            }\n+\n+            @Override\n+            public TextStyle fromString(String s) {\n+                for (TextStyle t : TextStyle.values()) {\n+                    if (s.equals(t.getDisplayName())) {\n+                        return t;\n+                    }\n+                }\n+                return TextStyle.BODY;\n+            }\n+        };\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/common\/TextStyle.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,450 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.editor;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.util.Optional;\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.ReadOnlyBooleanProperty;\n+import javafx.beans.property.ReadOnlyBooleanWrapper;\n+import javafx.beans.property.ReadOnlyObjectProperty;\n+import javafx.beans.property.ReadOnlyObjectWrapper;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Alert.AlertType;\n+import javafx.scene.control.ButtonBar.ButtonData;\n+import javafx.scene.control.ButtonType;\n+import javafx.scene.input.DataFormat;\n+import javafx.scene.paint.Color;\n+import javafx.stage.FileChooser;\n+import javafx.stage.Window;\n+import com.oracle.demo.richtext.common.Styles;\n+import com.oracle.demo.richtext.common.TextStyle;\n+import com.oracle.demo.richtext.util.FX;\n+import com.oracle.demo.richtext.util.FxAction;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.SelectionSegment;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.ContentChange;\n+import jfx.incubator.scene.control.richtext.model.RichTextFormatHandler;\n+import jfx.incubator.scene.control.richtext.model.RichTextModel;\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+\n+\/**\n+ * This is a bit of hack.  JavaFX has no actions (yet), so here we are using FxActions from\n+ * https:\/\/github.com\/andy-goryachev\/AppFramework (with permission from the author).\n+ * Ideally, these actions should be created upon demand and managed by the control, because\n+ * control knows when the enabled state of each action changes.\n+ * <p>\n+ * This class adds a listener to the model and updates the states of all the actions.\n+ * (The model does not change in this application).\n+ *\/\n+public class Actions {\n+    \/\/ file\n+    public final FxAction newDocument = new FxAction(this::newDocument);\n+    public final FxAction open = new FxAction(this::open);\n+    public final FxAction save = new FxAction(this::save);\n+    \/\/ style\n+    public final FxAction bold = new FxAction(this::bold);\n+    public final FxAction italic = new FxAction(this::italic);\n+    public final FxAction strikeThrough = new FxAction(this::strikeThrough);\n+    public final FxAction underline = new FxAction(this::underline);\n+    \/\/ editing\n+    public final FxAction copy = new FxAction(this::copy);\n+    public final FxAction cut = new FxAction(this::cut);\n+    public final FxAction paste = new FxAction(this::paste);\n+    public final FxAction pasteUnformatted = new FxAction(this::pasteUnformatted);\n+    public final FxAction redo = new FxAction(this::redo);\n+    public final FxAction selectAll = new FxAction(this::selectAll);\n+    public final FxAction undo = new FxAction(this::undo);\n+    \/\/ view\n+    public final FxAction wrapText = new FxAction();\n+\n+    private final RichTextArea control;\n+    private final ReadOnlyBooleanWrapper modified = new ReadOnlyBooleanWrapper();\n+    private final ReadOnlyObjectWrapper<File> file = new ReadOnlyObjectWrapper<>();\n+    private final SimpleObjectProperty<StyleAttributeMap> styles = new SimpleObjectProperty<>();\n+    private final SimpleObjectProperty<TextStyle> textStyle = new SimpleObjectProperty<>();\n+\n+    public Actions(RichTextArea control) {\n+        this.control = control;\n+\n+        \/\/ undo\/redo actions\n+        redo.disabledProperty().bind(control.redoableProperty().not());\n+        undo.disabledProperty().bind(control.undoableProperty().not());\n+\n+        undo.disabledProperty().bind(Bindings.createBooleanBinding(() -> {\n+            return !control.isUndoable();\n+        }, control.undoableProperty()));\n+\n+        redo.disabledProperty().bind(Bindings.createBooleanBinding(() -> {\n+            return !control.isRedoable();\n+        }, control.redoableProperty()));\n+\n+        wrapText.selectedProperty().bindBidirectional(control.wrapTextProperty());\n+\n+        control.getModel().addListener(new StyledTextModel.Listener() {\n+            @Override\n+            public void onContentChange(ContentChange ch) {\n+                handleEdit();\n+            }\n+        });\n+\n+        control.caretPositionProperty().addListener((x) -> {\n+            handleCaret();\n+        });\n+\n+        control.selectionProperty().addListener((p) -> {\n+            updateSourceStyles();\n+        });\n+\n+        styles.addListener((s,p,a) -> {\n+            bold.setSelected(hasStyle(a, StyleAttributeMap.BOLD), false);\n+            italic.setSelected(hasStyle(a, StyleAttributeMap.ITALIC), false);\n+            strikeThrough.setSelected(hasStyle(a, StyleAttributeMap.STRIKE_THROUGH), false);\n+            underline.setSelected(hasStyle(a, StyleAttributeMap.UNDERLINE), false);\n+        });\n+\n+        updateSourceStyles();\n+\n+        handleEdit();\n+        handleCaret();\n+        setModified(false);\n+    }\n+\n+    private boolean hasStyle(StyleAttributeMap attrs, StyleAttribute<Boolean> a) {\n+        return attrs == null ? false : Boolean.TRUE.equals(attrs.get(a));\n+    }\n+\n+    public final ObjectProperty<TextStyle> textStyleProperty() {\n+        return textStyle;\n+    }\n+\n+    public final ReadOnlyBooleanProperty modifiedProperty() {\n+        return modified.getReadOnlyProperty();\n+    }\n+\n+    public final boolean isModified() {\n+        return modified.get();\n+    }\n+\n+    private void setModified(boolean on) {\n+        modified.set(on);\n+    }\n+\n+    public final ReadOnlyObjectProperty<File> fileNameProperty() {\n+        return file.getReadOnlyProperty();\n+    }\n+\n+    public final File getFile() {\n+        return file.get();\n+    }\n+\n+    private void handleEdit() {\n+        setModified(true);\n+    }\n+\n+    private void handleCaret() {\n+        boolean sel = control.hasNonEmptySelection();\n+        StyleAttributeMap a = control.getActiveStyleAttributeMap();\n+\n+        cut.setEnabled(sel);\n+        copy.setEnabled(sel);\n+\n+        bold.setSelected(a.getBoolean(StyleAttributeMap.BOLD), false);\n+        italic.setSelected(a.getBoolean(StyleAttributeMap.ITALIC), false);\n+        underline.setSelected(a.getBoolean(StyleAttributeMap.UNDERLINE), false);\n+        strikeThrough.setSelected(a.getBoolean(StyleAttributeMap.STRIKE_THROUGH), false);\n+    }\n+\n+    private void toggle(StyleAttribute<Boolean> attr) {\n+        TextPos start = control.getAnchorPosition();\n+        TextPos end = control.getCaretPosition();\n+        if (start == null) {\n+            return;\n+        } else if (start.equals(end)) {\n+            \/\/ apply to the whole paragraph\n+            int ix = start.index();\n+            start = new TextPos(ix, 0);\n+            end = control.getParagraphEnd(ix);\n+        }\n+\n+        StyleAttributeMap a = control.getActiveStyleAttributeMap();\n+        boolean on = !a.getBoolean(attr);\n+        a = StyleAttributeMap.builder().set(attr, on).build();\n+        control.applyStyle(start, end, a);\n+    }\n+\n+    private <T> void apply(StyleAttribute<T> attr, T value) {\n+        TextPos start = control.getAnchorPosition();\n+        TextPos end = control.getCaretPosition();\n+        if (start == null) {\n+            return;\n+        } else if (start.equals(end)) {\n+            \/\/ apply to the whole paragraph\n+            int ix = start.index();\n+            start = new TextPos(ix, 0);\n+            end = control.getParagraphEnd(ix);\n+        }\n+\n+        StyleAttributeMap a = control.getActiveStyleAttributeMap();\n+        a = StyleAttributeMap.builder().set(attr, value).build();\n+        control.applyStyle(start, end, a);\n+    }\n+\n+    \/\/ TODO need to bind selected item in the combo\n+    public void setFontSize(Integer size) {\n+        apply(StyleAttributeMap.FONT_SIZE, size.doubleValue());\n+    }\n+\n+    \/\/ TODO need to bind selected item in the combo\n+    public void setFontName(String name) {\n+        apply(StyleAttributeMap.FONT_FAMILY, name);\n+    }\n+\n+    public void setTextColor(Color color) {\n+        apply(StyleAttributeMap.TEXT_COLOR, color);\n+    }\n+\n+    private void newDocument() {\n+        if (askToSave()) {\n+            return;\n+        }\n+        control.setModel(new RichTextModel());\n+        setModified(false);\n+    }\n+\n+    private void open() {\n+        if (askToSave()) {\n+            return;\n+        }\n+\n+        FileChooser ch = new FileChooser();\n+        ch.setTitle(\"Open File\");\n+        \/\/ TODO add extensions\n+        Window w = FX.getParentWindow(control);\n+        File f = ch.showOpenDialog(w);\n+        if (f != null) {\n+            try {\n+                readFile(f, RichTextFormatHandler.DATA_FORMAT);\n+            } catch (Exception e) {\n+                new ExceptionDialog(control, e).open();\n+            }\n+        }\n+    }\n+\n+    \/\/ FIX this is too simplistic, need save() and save as...\n+    private void save() {\n+        File f = getFile();\n+        if (f == null) {\n+            FileChooser ch = new FileChooser();\n+            ch.setTitle(\"Save File\");\n+            \/\/ TODO add extensions\n+            Window w = FX.getParentWindow(control);\n+            f = ch.showSaveDialog(w);\n+            if (f == null) {\n+                return;\n+            }\n+        }\n+        try {\n+            writeFile(f, RichTextFormatHandler.DATA_FORMAT);\n+        } catch (Exception e) {\n+            new ExceptionDialog(control, e).open();\n+        }\n+    }\n+\n+    \/\/ returns true if the user chose to Cancel\n+    private boolean askToSave() {\n+        if (isModified()) {\n+            \/\/ alert: has been modified. do you want to save?\n+            Alert alert = new Alert(AlertType.CONFIRMATION);\n+            alert.initOwner(FX.getParentWindow(control));\n+            alert.setTitle(\"Document is Modified\");\n+            alert.setHeaderText(\"Do you want to save this document?\");\n+            ButtonType delete = new ButtonType(\"Delete\");\n+            ButtonType cancel = new ButtonType(\"Cancel\", ButtonData.CANCEL_CLOSE);\n+            ButtonType save = new ButtonType(\"Save\", ButtonData.APPLY);\n+            alert.getButtonTypes().setAll(\n+                delete,\n+                cancel,\n+                save\n+            );\n+\n+            File f = getFile();\n+            SavePane sp = new SavePane();\n+            sp.setFile(f);\n+            alert.getDialogPane().setContent(sp);\n+            Optional<ButtonType> result = alert.showAndWait();\n+            if (result.isPresent()) {\n+                ButtonType t = result.get();\n+                if (t == delete) {\n+                    return false;\n+                } else if (t == cancel) {\n+                    return true;\n+                } else {\n+                    \/\/ save using info in the panel\n+                    f = sp.getFile();\n+                    DataFormat fmt = sp.getFileFormat();\n+                    \/\/ FIX\n+                    fmt = RichTextFormatHandler.DATA_FORMAT;\n+\n+                    try {\n+                        writeFile(f, fmt);\n+                    } catch (Exception e) {\n+                        new ExceptionDialog(control, e).open();\n+                        return true;\n+                    }\n+                }\n+            } else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void readFile(File f, DataFormat fmt) throws Exception {\n+        try (FileInputStream in = new FileInputStream(f)) {\n+            control.read(fmt, in);\n+            file.set(f);\n+            setModified(false);\n+        }\n+    }\n+\n+    private void writeFile(File f, DataFormat fmt) throws Exception {\n+        try (FileOutputStream out = new FileOutputStream(f)) {\n+            control.write(fmt, out);\n+            file.set(f);\n+            setModified(false);\n+        }\n+    }\n+\n+    public void copy() {\n+        control.copy();\n+    }\n+\n+    public void cut() {\n+        control.cut();\n+    }\n+\n+    public void paste() {\n+        control.paste();\n+    }\n+\n+    public void pasteUnformatted() {\n+        control.pastePlainText();\n+    }\n+\n+    public void selectAll() {\n+        control.selectAll();\n+    }\n+\n+    public void redo() {\n+       control.redo();\n+    }\n+\n+    public void undo() {\n+        control.undo();\n+    }\n+\n+    public void bold() {\n+        toggleStyle(StyleAttributeMap.BOLD);\n+    }\n+\n+    public void italic() {\n+        toggleStyle(StyleAttributeMap.ITALIC);\n+    }\n+\n+    public void strikeThrough() {\n+        toggleStyle(StyleAttributeMap.STRIKE_THROUGH);\n+    }\n+\n+    public void underline() {\n+        toggleStyle(StyleAttributeMap.UNDERLINE);\n+    }\n+\n+    private void toggleStyle(StyleAttribute<Boolean> attr) {\n+        TextPos start = control.getAnchorPosition();\n+        TextPos end = control.getCaretPosition();\n+        if (start == null) {\n+            return;\n+        } else if (start.equals(end)) {\n+            \/\/ apply to the whole paragraph\n+            int ix = start.index();\n+            start = new TextPos(ix, 0);\n+            end = control.getParagraphEnd(ix);\n+        }\n+\n+        StyleAttributeMap a = control.getActiveStyleAttributeMap();\n+        boolean on = !a.getBoolean(attr);\n+        a = StyleAttributeMap.builder().set(attr, on).build();\n+        control.applyStyle(start, end, a);\n+        updateSourceStyles();\n+    }\n+\n+    public void setTextStyle(TextStyle st) {\n+        TextPos start = control.getAnchorPosition();\n+        TextPos end = control.getCaretPosition();\n+        if (start == null) {\n+            return;\n+        } else if (start.equals(end)) {\n+            TextStyle cur = Styles.guessTextStyle(control.getActiveStyleAttributeMap());\n+            if (cur == st) {\n+                return;\n+            }\n+            \/\/ apply to the whole paragraph\n+            int ix = start.index();\n+            start = new TextPos(ix, 0);\n+            end = control.getParagraphEnd(ix);\n+        }\n+\n+        StyleAttributeMap a = Styles.getStyleAttributeMap(st);\n+        control.applyStyle(start, end, a);\n+        updateSourceStyles();\n+    }\n+\n+    private void updateSourceStyles() {\n+        StyleAttributeMap a = getSourceStyleAttrs();\n+        if (a != null) {\n+            styles.set(a);\n+\n+            TextStyle st = Styles.guessTextStyle(a);\n+            textStyle.set(st);\n+        }\n+    }\n+\n+    private StyleAttributeMap getSourceStyleAttrs() {\n+        SelectionSegment sel = control.getSelection();\n+        if ((sel == null) || (!sel.isCollapsed())) {\n+            return null;\n+        }\n+        return control.getActiveStyleAttributeMap();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/editor\/Actions.java","additions":450,"deletions":0,"binary":false,"changes":450,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.editor;\n+\n+import java.io.FileNotFoundException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import javafx.scene.Node;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.Priority;\n+\n+public class ExceptionDialog extends Alert {\n+    public ExceptionDialog(Node owner, Throwable err) {\n+        super(AlertType.ERROR);\n+\n+        setTitle(\"An Error Occurred\");\n+        \/\/setHeaderText(\"\");\n+        \/\/setContentText(\"\");\n+\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw);\n+        err.printStackTrace(pw);\n+        String text = sw.toString();\n+\n+        Label label = new Label(\"The exception stacktrace:\");\n+\n+        TextArea textArea = new TextArea(text);\n+        textArea.setEditable(false);\n+        textArea.setWrapText(false);\n+\n+        textArea.setMaxWidth(Double.MAX_VALUE);\n+        textArea.setMaxHeight(Double.MAX_VALUE);\n+        GridPane.setVgrow(textArea, Priority.ALWAYS);\n+        GridPane.setHgrow(textArea, Priority.ALWAYS);\n+\n+        GridPane expContent = new GridPane();\n+        expContent.setMaxWidth(Double.MAX_VALUE);\n+        expContent.add(label, 0, 0);\n+        expContent.add(textArea, 0, 1);\n+\n+        getDialogPane().setExpandableContent(expContent);\n+    }\n+\n+    public void open() {\n+        showAndWait();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/editor\/ExceptionDialog.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.editor;\n+\n+import javafx.application.Application;\n+import javafx.stage.Stage;\n+import com.oracle.demo.richtext.settings.FxSettings;\n+\n+\/**\n+ * Rich Text Editor Demo Application.\n+ *\/\n+public class RichEditorDemoApp extends Application {\n+    public static void main(String[] args) {\n+        Application.launch(RichEditorDemoApp.class, args);\n+    }\n+\n+    @Override\n+    public void init() {\n+        FxSettings.useDirectory(\".RichEditorDemoApp\");\n+    }\n+\n+    @Override\n+    public void start(Stage stage) throws Exception {\n+        new RichEditorDemoWindow().show();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/editor\/RichEditorDemoApp.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.editor;\n+\n+import java.util.List;\n+import javafx.scene.control.ColorPicker;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.ToolBar;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.text.Font;\n+import com.oracle.demo.richtext.common.TextStyle;\n+import com.oracle.demo.richtext.util.FX;\n+import jfx.incubator.scene.control.input.KeyBinding;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+\n+\/**\n+ * Main Panel.\n+ *\/\n+public class RichEditorDemoPane extends BorderPane {\n+    public final RichTextArea control;\n+    public final Actions actions;\n+    private final ComboBox<String> fontName;\n+    private final ComboBox<Integer> fontSize;\n+    private final ColorPicker textColor;\n+    private final ComboBox<TextStyle> textStyle;\n+\n+    public RichEditorDemoPane() {\n+        FX.name(this, \"RichEditorDemoPane\");\n+\n+        control = new RichTextArea();\n+        \/\/ custom function\n+        control.getInputMap().register(KeyBinding.shortcut(KeyCode.W), () -> {\n+            System.out.println(\"Custom function: W key is pressed\");\n+        });\n+\n+        actions = new Actions(control);\n+        control.setContextMenu(createContextMenu());\n+\n+        fontName = new ComboBox<>();\n+        fontName.getItems().setAll(collectFonts());\n+        fontName.setOnAction((ev) -> {\n+            actions.setFontName(fontName.getSelectionModel().getSelectedItem());\n+        });\n+\n+        fontSize = new ComboBox<>();\n+        fontSize.getItems().setAll(\n+            7,\n+            8,\n+            9,\n+            10,\n+            11,\n+            12,\n+            13,\n+            14,\n+            16,\n+            18,\n+            20,\n+            22,\n+            24,\n+            28,\n+            32,\n+            36,\n+            48,\n+            72,\n+            96,\n+            128\n+        );\n+        fontSize.setOnAction((ev) -> {\n+            actions.setFontSize(fontSize.getSelectionModel().getSelectedItem());\n+        });\n+\n+        textColor = new ColorPicker();\n+        \/\/ TODO save\/restore custom colors\n+        FX.tooltip(textColor, \"Text Color\");\n+        \/\/ FIX there is no API for this!  why is this a property of a skin, not the control??\n+        \/\/ https:\/\/stackoverflow.com\/questions\/21246137\/remove-text-from-colour-picker\n+        textColor.setStyle(\"-fx-color-label-visible: false ;\");\n+        textColor.setOnAction((ev) -> {\n+            actions.setTextColor(textColor.getValue());\n+        });\n+\n+        textStyle = new ComboBox<>();\n+        textStyle.getItems().setAll(TextStyle.values());\n+        textStyle.setConverter(TextStyle.converter());\n+        textStyle.setOnAction((ev) -> {\n+            updateTextStyle();\n+        });\n+\n+        setTop(createToolBar());\n+        setCenter(control);\n+\n+        actions.textStyleProperty().addListener((s,p,c) -> {\n+            setTextStyle(c);\n+        });\n+    }\n+\n+    private ToolBar createToolBar() {\n+        ToolBar t = new ToolBar();\n+        FX.add(t, fontName);\n+        FX.add(t, fontSize);\n+        FX.add(t, textColor);\n+        FX.space(t);\n+        \/\/ TODO background\n+        \/\/ TODO alignment\n+        \/\/ TODO bullet\n+        \/\/ TODO space left (indent left, indent right)\n+        \/\/ TODO line spacing\n+        FX.toggleButton(t, \"𝐁\", \"Bold text\", actions.bold);\n+        FX.toggleButton(t, \"𝐼\", \"Bold text\", actions.italic);\n+        FX.toggleButton(t, \"S\\u0336\", \"Strike through text\", actions.strikeThrough);\n+        FX.toggleButton(t, \"U\\u0332\", \"Underline text\", actions.underline);\n+        FX.add(t, textStyle);\n+        FX.space(t);\n+        FX.toggleButton(t, \"W\", \"Wrap Text\", actions.wrapText);\n+        \/\/ TODO line numbers\n+        return t;\n+    }\n+\n+    private ContextMenu createContextMenu() {\n+        ContextMenu m = new ContextMenu();\n+        FX.item(m, \"Undo\", actions.undo);\n+        FX.item(m, \"Redo\", actions.redo);\n+        FX.separator(m);\n+        FX.item(m, \"Cut\", actions.cut);\n+        FX.item(m, \"Copy\", actions.copy);\n+        FX.item(m, \"Paste\", actions.paste);\n+        FX.item(m, \"Paste and Retain Style\", actions.pasteUnformatted);\n+        FX.separator(m);\n+        FX.item(m, \"Select All\", actions.selectAll);\n+        FX.separator(m);\n+        \/\/ TODO under \"Style\" submenu?\n+        FX.item(m, \"Bold\", actions.bold);\n+        FX.item(m, \"Italic\", actions.italic);\n+        FX.item(m, \"Strike Through\", actions.strikeThrough);\n+        FX.item(m, \"Underline\", actions.underline);\n+        return m;\n+    }\n+\n+    private static List<String> collectFonts() {\n+        return Font.getFamilies();\n+    }\n+\n+    private void updateTextStyle() {\n+        TextStyle st = textStyle.getSelectionModel().getSelectedItem();\n+        if (st != null) {\n+            actions.setTextStyle(st);\n+        }\n+    }\n+\n+    public void setTextStyle(TextStyle v) {\n+        textStyle.setValue(v);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/editor\/RichEditorDemoPane.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.editor;\n+\n+import java.io.File;\n+import javafx.application.Platform;\n+import javafx.geometry.Insets;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.MenuBar;\n+import javafx.scene.layout.BorderPane;\n+import javafx.stage.Stage;\n+import com.oracle.demo.richtext.rta.RichTextAreaWindow;\n+import com.oracle.demo.richtext.util.FX;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * Rich Editor Demo window\n+ *\/\n+public class RichEditorDemoWindow extends Stage {\n+    public final RichEditorDemoPane pane;\n+    public final Label status;\n+\n+    public RichEditorDemoWindow() {\n+        pane = new RichEditorDemoPane();\n+\n+        status = new Label();\n+        status.setPadding(new Insets(2, 10, 2, 10));\n+\n+        BorderPane bp = new BorderPane();\n+        bp.setTop(createMenu());\n+        bp.setCenter(pane);\n+        bp.setBottom(status);\n+\n+        Scene scene = new Scene(bp);\n+\n+        \/\/ TODO input map for the window: add shortcut-S for saving\n+\n+        setScene(scene);\n+        setWidth(1200);\n+        setHeight(600);\n+\n+        pane.control.caretPositionProperty().addListener((x) -> {\n+            updateStatus();\n+        });\n+        pane.actions.modifiedProperty().addListener((x) -> {\n+            updateTitle();\n+        });\n+        pane.actions.fileNameProperty().addListener((x) -> {\n+            updateTitle();\n+        });\n+        updateStatus();\n+        updateTitle();\n+    }\n+\n+    private MenuBar createMenu() {\n+        Actions actions = pane.actions;\n+        MenuBar m = new MenuBar();\n+        \/\/ file\n+        FX.menu(m, \"File\");\n+        FX.item(m, \"New\", actions.newDocument);\n+        FX.item(m, \"Open...\", actions.open);\n+        FX.separator(m);\n+        FX.item(m, \"Save...\", actions.save);\n+        \/\/ TODO print?\n+        FX.item(m, \"Quit\", () -> Platform.exit());\n+\n+        \/\/ edit\n+        FX.menu(m, \"Edit\");\n+        FX.item(m, \"Undo\", actions.undo);\n+        FX.item(m, \"Redo\", actions.redo);\n+        FX.separator(m);\n+        FX.item(m, \"Cut\", actions.cut);\n+        FX.item(m, \"Copy\", actions.copy);\n+        FX.item(m, \"Paste\", actions.paste);\n+        FX.item(m, \"Paste and Retain Style\", actions.pasteUnformatted);\n+\n+        \/\/ format\n+        FX.menu(m, \"Format\");\n+        FX.item(m, \"Bold\", actions.bold);\n+        FX.item(m, \"Italic\", actions.italic);\n+        FX.item(m, \"Strike Through\", actions.strikeThrough);\n+        FX.item(m, \"Underline\", actions.underline);\n+\n+        \/\/ view\n+        FX.menu(m, \"View\");\n+        FX.checkItem(m, \"Wrap Text\", actions.wrapText);\n+        \/\/ TODO line numbers\n+        \/\/ TODO line spacing\n+\n+        \/\/ help\n+        FX.menu(m, \"Help\");\n+        \/\/ TODO about\n+        return m;\n+    }\n+\n+    private void updateStatus() {\n+        RichTextArea t = pane.control;\n+        TextPos p = t.getCaretPosition();\n+\n+        StringBuilder sb = new StringBuilder();\n+\n+        if (p != null) {\n+            sb.append(\" Line: \").append(p.index() + 1);\n+            sb.append(\"  Column: \").append(p.offset() + 1);\n+        }\n+\n+        status.setText(sb.toString());\n+    }\n+\n+    private void updateTitle() {\n+        File f = pane.actions.getFile();\n+        boolean modified = pane.actions.isModified();\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"Rich Text Editor Demo\");\n+        if (f != null) {\n+            sb.append(\" - \");\n+            sb.append(f.getName());\n+        }\n+        if (modified) {\n+            sb.append(\" *\");\n+        }\n+        setTitle(sb.toString());\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/editor\/RichEditorDemoWindow.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.editor;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import javafx.application.Platform;\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.TextField;\n+import javafx.scene.input.DataFormat;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.Priority;\n+import javafx.stage.DirectoryChooser;\n+import javafx.stage.Window;\n+import com.oracle.demo.richtext.util.FX;\n+\n+public class SavePane extends GridPane {\n+    private final TextField nameField;\n+    private final ComboBox<File> folderField;\n+    private final ComboBox<DataFormat> formatField;\n+\n+    public SavePane() {\n+        nameField = new TextField();\n+        setHgrow(nameField, Priority.ALWAYS);\n+        setFillWidth(nameField, Boolean.TRUE);\n+\n+        folderField = new ComboBox<>();\n+        setHgrow(folderField, Priority.ALWAYS);\n+        setFillWidth(folderField, Boolean.TRUE);\n+\n+        formatField = new ComboBox<>();\n+\n+        Button browse = new Button(\"Browse\");\n+        setFillWidth(browse, Boolean.TRUE);\n+        browse.setOnAction((ev) -> {\n+            browse();\n+        });\n+\n+        int r = 0;\n+        add(label(\"Save As:\"), 0, r);\n+        add(nameField, 1, r, 3, 1);\n+        r++;\n+        add(label(\"Where:\"), 0, r);\n+        add(folderField, 1, r);\n+        add(browse, 2, r);\n+        r++;\n+        add(label(\"File Format:\"), 0, r);\n+        add(formatField, 1, r, 2, 1);\n+\n+        setHgap(10);\n+        setVgap(5);\n+        setPadding(new Insets(10));\n+\n+        Platform.runLater(() -> {\n+            nameField.selectAll();\n+            nameField.requestFocus();\n+        });\n+    }\n+\n+    private static Label label(String text) {\n+        Label t = new Label(text);\n+        setHalignment(t, HPos.RIGHT);\n+        return t;\n+    }\n+\n+    public void setFile(File f) {\n+        if (f == null) {\n+            nameField.setText(\"Untitled.rich\");\n+            setDir(null);\n+        } else {\n+            nameField.setText(f.getName());\n+            setDir(f.getParentFile());\n+        }\n+    }\n+\n+    private void setDir(File dir) {\n+        if (dir == null) {\n+            dir = new File(System.getProperty(\"user.home\"));\n+        }\n+        ArrayList<File> fs = new ArrayList<>();\n+        File f = dir;\n+        do {\n+            fs.add(f);\n+            f = f.getParentFile();\n+        } while (f != null);\n+        folderField.getItems().setAll(fs);\n+        folderField.getSelectionModel().select(dir);\n+    }\n+\n+    public void setFormat(DataFormat f) {\n+        \/\/ TODO\n+    }\n+\n+    public File getFile() {\n+        File dir = getDir();\n+        \/\/ TODO extension based on data format\n+        return new File(dir, nameField.getText());\n+    }\n+\n+    public DataFormat getFileFormat() {\n+        return null; \/\/ FIX\n+    }\n+\n+    private File getDir() {\n+        return folderField.getSelectionModel().getSelectedItem();\n+    }\n+\n+    private void browse() {\n+        DirectoryChooser ch = new DirectoryChooser();\n+        ch.setTitle(\"Choose Folder\");\n+        ch.setInitialDirectory(getDir());\n+        Window w = FX.getParentWindow(this);\n+        File f = ch.showDialog(w);\n+        if (f != null) {\n+            setDir(f);\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/editor\/SavePane.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,807 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import javafx.application.Platform;\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.binding.BooleanBinding;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.ReadOnlyBooleanProperty;\n+import javafx.beans.property.ReadOnlyBooleanWrapper;\n+import javafx.beans.property.ReadOnlyObjectProperty;\n+import javafx.beans.property.ReadOnlyObjectWrapper;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.beans.value.ChangeListener;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.scene.Node;\n+import javafx.scene.input.DataFormat;\n+import com.oracle.demo.richtext.common.Styles;\n+import com.oracle.demo.richtext.common.TextStyle;\n+import com.oracle.demo.richtext.notebook.data.CellInfo;\n+import com.oracle.demo.richtext.notebook.data.Notebook;\n+import com.oracle.demo.richtext.util.FX;\n+import com.oracle.demo.richtext.util.FxAction;\n+import jfx.incubator.scene.control.richtext.CodeArea;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.SelectionSegment;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.ContentChange;\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+\n+\/**\n+ * This class reacts to changes in application state such as currently active cell,\n+ * caret, selection, model, etc.; then updates the actions disabled and selected properties.\n+ * <p>\n+ * JavaFX has no actions (yet), so here we are using FxActions from\n+ * https:\/\/github.com\/andy-goryachev\/AppFramework (with permission from the author).\n+ *\/\n+public class Actions {\n+    \/\/ file\n+    public final FxAction newDocument = new FxAction(this::newDocument);\n+    public final FxAction open = new FxAction(this::open);\n+    public final FxAction save = new FxAction(this::save);\n+    \/\/ style\n+    public final FxAction bold = new FxAction(this::bold);\n+    public final FxAction italic = new FxAction(this::italic);\n+    public final FxAction strikeThrough = new FxAction(this::strikeThrough);\n+    public final FxAction underline = new FxAction(this::underline);\n+    \/\/ editing\n+    public final FxAction copy = new FxAction(this::copy);\n+    public final FxAction cut = new FxAction(this::cut);\n+    public final FxAction paste = new FxAction(this::paste);\n+    public final FxAction pasteUnformatted = new FxAction(this::pasteUnformatted);\n+    public final FxAction redo = new FxAction(this::redo);\n+    public final FxAction selectAll = new FxAction(this::selectAll);\n+    public final FxAction undo = new FxAction(this::undo);\n+    \/\/ cells\n+    public final FxAction copyCell = new FxAction(this::copyCell);\n+    public final FxAction cutCell = new FxAction(this::cutCell);\n+    public final FxAction deleteCell = new FxAction(this::deleteCell);\n+    public final FxAction insertCellBelow = new FxAction(this::insertCellBelow);\n+    public final FxAction mergeCellAbove = new FxAction(this::mergeCellAbove);\n+    public final FxAction mergeCellBelow = new FxAction(this::mergeCellBelow);\n+    public final FxAction moveCellDown = new FxAction(this::moveCellDown);\n+    public final FxAction moveCellUp = new FxAction(this::moveCellUp);\n+    public final FxAction pasteCellBelow = new FxAction(this::pasteCellBelow);\n+    public final FxAction runAndAdvance = new FxAction(this::runAndAdvance);\n+    public final FxAction runAll = new FxAction(this::runAll);\n+    public final FxAction splitCell = new FxAction(this::splitCell);\n+\n+    private enum EditorType {\n+        CODE,\n+        NONE,\n+        OUTPUT,\n+        TEXT,\n+    }\n+\n+    private final NotebookWindow window;\n+    private final DemoScriptEngine engine;\n+    private final ObservableList<CellPane> cellPanes = FXCollections.observableArrayList();\n+    private final ReadOnlyObjectWrapper<CellPane> activeCellPane = new ReadOnlyObjectWrapper<>();\n+    private final ReadOnlyBooleanWrapper modified = new ReadOnlyBooleanWrapper();\n+    private final ReadOnlyObjectWrapper<File> file = new ReadOnlyObjectWrapper<>();\n+    private final SimpleBooleanProperty executing = new SimpleBooleanProperty();\n+    private final SimpleObjectProperty<RichTextArea> editor = new SimpleObjectProperty<>();\n+    private final SimpleObjectProperty<EditorType> editorType = new SimpleObjectProperty<>(EditorType.NONE);\n+    private final SimpleObjectProperty<StyleAttributeMap> styles = new SimpleObjectProperty<>();\n+    private final SimpleObjectProperty<TextStyle> textStyle = new SimpleObjectProperty<>();\n+    private final BooleanBinding disabledStyleEditing;\n+    private int sequenceNumber;\n+\n+    public Actions(NotebookWindow w) {\n+        this.window = w;\n+\n+        engine = new DemoScriptEngine();\n+\n+        BooleanBinding disabledEditing = Bindings.createBooleanBinding(\n+            () -> {\n+                if (isExecuting()) {\n+                    return true;\n+                }\n+                RichTextArea r = editor.get();\n+                if (r == null) {\n+                    return true;\n+                }\n+                return !r.canEdit();\n+            },\n+            editor,\n+            executing\n+        );\n+\n+        disabledStyleEditing = Bindings.createBooleanBinding(\n+            () -> {\n+                if (isExecuting()) {\n+                    return true;\n+                }\n+                return (editorType.get() != EditorType.TEXT);\n+            },\n+            editorType,\n+            executing\n+        );\n+\n+        BooleanBinding cellActionsDisabled = Bindings.createBooleanBinding(\n+            () -> {\n+                if(isExecuting()) {\n+                    return true;\n+                }\n+                CellPane p = getActiveCellPane();\n+                return p == null;\n+            },\n+            activeCellPane,\n+            executing\n+        );\n+\n+        BooleanBinding runDisabled = Bindings.createBooleanBinding(\n+            () -> {\n+                if(isExecuting()) {\n+                    return true;\n+                }\n+                CellType p = getActiveCellType();\n+                return p != CellType.CODE;\n+            },\n+            activeCellPane,\n+            executing\n+        );\n+\n+        SimpleBooleanProperty redoDisabled = new SimpleBooleanProperty();\n+        SimpleBooleanProperty undoDisabled = new SimpleBooleanProperty();\n+\n+        \/\/ file actions\n+        open.setDisabled(true);\n+        save.setDisabled(true);\n+\n+        \/\/ style actions\n+        bold.disabledProperty().bind(disabledStyleEditing);\n+        italic.disabledProperty().bind(disabledStyleEditing);\n+        strikeThrough.disabledProperty().bind(disabledStyleEditing);\n+        underline.disabledProperty().bind(disabledStyleEditing);\n+\n+        \/\/ editing actions\n+        copy.setEnabled(true); \/\/ always\n+        cut.disabledProperty().bind(disabledEditing);\n+        paste.disabledProperty().bind(disabledEditing);\n+        pasteUnformatted.disabledProperty().bind(disabledEditing);\n+        selectAll.setEnabled(true); \/\/ always\n+\n+        \/\/ undo\/redo actions\n+        redo.disabledProperty().bind(redoDisabled);\n+        undo.disabledProperty().bind(undoDisabled);\n+\n+        \/\/ cell actions\n+        copyCell.setDisabled(true);\n+        cutCell.setDisabled(true);\n+        deleteCell.disabledProperty().bind(cellActionsDisabled);\n+        insertCellBelow.disabledProperty().bind(cellActionsDisabled);\n+        mergeCellAbove.setDisabled(true);\n+        mergeCellBelow.setDisabled(true);\n+        moveCellDown.disabledProperty().bind(cellActionsDisabled);\n+        moveCellUp.disabledProperty().bind(cellActionsDisabled);\n+        pasteCellBelow.setDisabled(true);\n+        runAndAdvance.disabledProperty().bind(runDisabled);\n+        runAll.setDisabled(true);\n+        splitCell.disabledProperty().bind(disabledEditing);\n+\n+        \/\/ listeners\n+\n+        styles.addListener((s,p,a) -> {\n+            bold.setSelected(hasStyle(a, StyleAttributeMap.BOLD), false);\n+            italic.setSelected(hasStyle(a, StyleAttributeMap.ITALIC), false);\n+            strikeThrough.setSelected(hasStyle(a, StyleAttributeMap.STRIKE_THROUGH), false);\n+            underline.setSelected(hasStyle(a, StyleAttributeMap.UNDERLINE), false);\n+        });\n+\n+        ChangeListener<Node> focusOwnerListener = (src, old, node) -> {\n+            CellPane p = FX.findParentOf(CellPane.class, node);\n+            if (p == null) {\n+                return;\n+            }\n+\n+            RichTextArea r = FX.findParentOf(RichTextArea.class, node);\n+            editor.set(r);\n+\n+            EditorType t = getEditorType(r);\n+            editorType.set(t);\n+            updateSourceStyles();\n+        };\n+\n+        window.sceneProperty().addListener((src, old, cur) -> {\n+           if(old != null) {\n+               old.focusOwnerProperty().removeListener(focusOwnerListener);\n+           }\n+           if(cur != null) {\n+               cur.focusOwnerProperty().addListener(focusOwnerListener);\n+           }\n+        });\n+\n+        StyledTextModel.Listener changeListener = new StyledTextModel.Listener() {\n+            @Override\n+            public void onContentChange(ContentChange ch) {\n+                if (ch.isEdit()) {\n+                    handleEdit();\n+                } else {\n+                    if (editorType.get() == EditorType.TEXT) {\n+                        handleEdit();\n+                    }\n+                }\n+            }\n+        };\n+\n+        InvalidationListener selectionListener = (p) -> {\n+            updateSourceStyles();\n+        };\n+\n+        editor.addListener((src, old, ed) -> {\n+            if (old != null) {\n+                if (isSourceEditor(old)) {\n+                    old.getModel().removeListener(changeListener);\n+                    old.selectionProperty().removeListener(selectionListener);\n+                }\n+            }\n+\n+            redoDisabled.unbind();\n+            redoDisabled.set(true);\n+            undoDisabled.unbind();\n+            undoDisabled.set(true);\n+\n+            if (ed != null) {\n+                if (isSourceEditor(ed)) {\n+                    ed.getModel().addListener(changeListener);\n+                    ed.selectionProperty().addListener(selectionListener);\n+                    redoDisabled.bind(executing.or(ed.redoableProperty().not()));\n+                    undoDisabled.bind(executing.or(ed.undoableProperty().not()));\n+                }\n+            }\n+        });\n+\n+        updateSourceStyles();\n+\n+        activeCellPane.addListener((src, prev, cur) -> {\n+            if (prev != null) {\n+                prev.setActive(false);\n+            }\n+            if (cur != null) {\n+                cur.setActive(true);\n+            }\n+        });\n+    }\n+\n+    private EditorType getEditorType(RichTextArea r) {\n+        if (r == null) {\n+            return EditorType.NONE;\n+        } else if (r instanceof CodeArea) {\n+            if (r.canEdit()) {\n+                return EditorType.CODE;\n+            } else {\n+                return EditorType.OUTPUT;\n+            }\n+        }\n+        return EditorType.TEXT;\n+    }\n+\n+    private boolean isSourceEditor(RichTextArea r) {\n+        EditorType t = getEditorType(r);\n+        switch (t) {\n+        case CODE:\n+        case TEXT:\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private void updateSourceStyles() {\n+        StyleAttributeMap a = getSourceStyleAttrs();\n+        if (a != null) {\n+            styles.set(a);\n+\n+            TextStyle st = Styles.guessTextStyle(a);\n+            textStyle.set(st);\n+        }\n+    }\n+\n+    public final ObjectProperty<TextStyle> textStyleProperty() {\n+        return textStyle;\n+    }\n+\n+    private StyleAttributeMap getSourceStyleAttrs() {\n+        RichTextArea r = editor.get();\n+        EditorType t = getEditorType(r);\n+        switch (t) {\n+        case TEXT:\n+            SelectionSegment sel = r.getSelection();\n+            if ((sel == null) || (!sel.isCollapsed())) {\n+                return null;\n+            }\n+            return r.getActiveStyleAttributeMap();\n+        }\n+        return null;\n+    }\n+\n+    private boolean hasStyle(StyleAttributeMap attrs, StyleAttribute<Boolean> a) {\n+        return attrs == null ? false : Boolean.TRUE.equals(attrs.get(a));\n+    }\n+\n+    private final boolean isExecuting() {\n+        return executing.get();\n+    }\n+\n+    private void setExecuting(boolean on) {\n+        executing.set(on);\n+    }\n+\n+    public final ReadOnlyBooleanProperty modifiedProperty() {\n+        return modified.getReadOnlyProperty();\n+    }\n+\n+    public final boolean isModified() {\n+        return modified.get();\n+    }\n+\n+    private void setModified(boolean on) {\n+        modified.set(on);\n+    }\n+\n+    public final ReadOnlyObjectProperty<File> fileNameProperty() {\n+        return file.getReadOnlyProperty();\n+    }\n+\n+    public final File getFile() {\n+        return file.get();\n+    }\n+\n+    private void handleEdit() {\n+        setModified(true);\n+    }\n+\n+    public void newDocument() {\n+\/\/        if (askToSave()) {\n+\/\/            return;\n+\/\/        }\n+        Notebook n = new Notebook();\n+        n.add(new CellInfo(CellType.CODE));\n+        window.setNotebook(n);\n+    }\n+\n+    private void open() {\n+\/\/        if (askToSave()) {\n+\/\/            return;\n+\/\/        }\n+\/\/\n+\/\/        FileChooser ch = new FileChooser();\n+\/\/        ch.setTitle(\"Open File\");\n+\/\/        \/\/ TODO add extensions\n+\/\/        Window w = FX.getParentWindow(control);\n+\/\/        File f = ch.showOpenDialog(w);\n+\/\/        if (f != null) {\n+\/\/            try {\n+\/\/                readFile(f, RichTextFormatHandler.DATA_FORMAT);\n+\/\/            } catch (Exception e) {\n+\/\/                new ExceptionDialog(control, e).open();\n+\/\/            }\n+\/\/        }\n+    }\n+\n+    \/\/ FIX this is too simplistic, need save() and save as...\n+    private void save() {\n+\/\/        File f = getFile();\n+\/\/        if (f == null) {\n+\/\/            FileChooser ch = new FileChooser();\n+\/\/            ch.setTitle(\"Save File\");\n+\/\/            \/\/ TODO add extensions\n+\/\/            Window w = FX.getParentWindow(control);\n+\/\/            f = ch.showSaveDialog(w);\n+\/\/            if (f == null) {\n+\/\/                return;\n+\/\/            }\n+\/\/        }\n+\/\/        try {\n+\/\/            writeFile(f, RichTextFormatHandler.DATA_FORMAT);\n+\/\/        } catch (Exception e) {\n+\/\/            new ExceptionDialog(control, e).open();\n+\/\/        }\n+    }\n+\n+    \/\/ returns true if the user chose to Cancel\n+    private boolean askToSave() {\n+\/\/        if (isModified()) {\n+\/\/            \/\/ alert: has been modified. do you want to save?\n+\/\/            Alert alert = new Alert(AlertType.CONFIRMATION);\n+\/\/            alert.initOwner(FX.getParentWindow(control));\n+\/\/            alert.setTitle(\"Document is Modified\");\n+\/\/            alert.setHeaderText(\"Do you want to save this document?\");\n+\/\/            ButtonType delete = new ButtonType(\"Delete\");\n+\/\/            ButtonType cancel = new ButtonType(\"Cancel\", ButtonData.CANCEL_CLOSE);\n+\/\/            ButtonType save = new ButtonType(\"Save\", ButtonData.APPLY);\n+\/\/            alert.getButtonTypes().setAll(\n+\/\/                delete,\n+\/\/                cancel,\n+\/\/                save\n+\/\/            );\n+\/\/\n+\/\/            File f = getFile();\n+\/\/            \/\/ FIX format selector is not needed!\n+\/\/            SavePane sp = new SavePane();\n+\/\/            sp.setFile(f);\n+\/\/            alert.getDialogPane().setContent(sp);\n+\/\/            Optional<ButtonType> result = alert.showAndWait();\n+\/\/            if (result.isPresent()) {\n+\/\/                ButtonType t = result.get();\n+\/\/                if (t == delete) {\n+\/\/                    return false;\n+\/\/                } else if (t == cancel) {\n+\/\/                    return true;\n+\/\/                } else {\n+\/\/                    \/\/ save using info in the panel\n+\/\/                    f = sp.getFile();\n+\/\/                    DataFormat fmt = sp.getFileFormat();\n+\/\/                    \/\/ FIX\n+\/\/                    fmt = RichTextFormatHandler.DATA_FORMAT;\n+\/\/\n+\/\/                    try {\n+\/\/                        writeFile(f, fmt);\n+\/\/                    } catch (Exception e) {\n+\/\/                        new ExceptionDialog(control, e).open();\n+\/\/                        return true;\n+\/\/                    }\n+\/\/                }\n+\/\/            } else {\n+\/\/                return true;\n+\/\/            }\n+\/\/        }\n+        return false;\n+    }\n+\n+    private void readFile(File f, DataFormat fmt) throws Exception {\n+\/\/        try (FileInputStream in = new FileInputStream(f)) {\n+\/\/            control.read(fmt, in);\n+\/\/            file.set(f);\n+\/\/            modified.set(false);\n+\/\/        }\n+    }\n+\n+    private void writeFile(File f, DataFormat fmt) throws Exception {\n+\/\/        try (FileOutputStream out = new FileOutputStream(f)) {\n+\/\/            control.write(fmt, out);\n+\/\/            file.set(f);\n+\/\/            modified.set(false);\n+\/\/        }\n+    }\n+\n+    private void runAll() {\n+        \/\/ TODO\n+    }\n+\n+    public void runAndAdvance() {\n+        CellPane p = getActiveCellPane();\n+        if (p != null) {\n+            CellInfo cell = p.getCellInfo();\n+            if (cell.isCode()) {\n+                String src = cell.getSource();\n+                runScript(p, src, true);\n+            }\n+        }\n+    }\n+\n+    private void runScript(CellPane p, String src, boolean advance) {\n+        setExecuting(true);\n+        p.setExecuting();\n+\n+        Thread t = new Thread(\"executing script [\" + (sequenceNumber + 1) + \"]\") {\n+            @Override\n+            public void run() {\n+                Object r;\n+                try {\n+                    r = engine.executeScript(src);\n+                } catch (Throwable e) {\n+                    r = e;\n+                }\n+                handleCompletion(p, r, advance);\n+            }\n+        };\n+        t.setPriority(Thread.MIN_PRIORITY);\n+        t.start();\n+    }\n+\n+    \/** this method is called from a background thread *\/\n+    private void handleCompletion(CellPane p, Object result, boolean advance) {\n+        Platform.runLater(() -> {\n+            setExecuting(false);\n+            p.setResult(result, ++sequenceNumber);\n+            if (advance) {\n+                int ix = getActiveCellIndex();\n+                ix++;\n+                if (ix < cellPanes.size()) {\n+                    CellPane next = cellPanes.get(ix);\n+                    setActiveCellPane(next);\n+                    next.focusLater();\n+                }\n+            }\n+        });\n+    }\n+\n+    public final ObservableList<CellPane> getCellPanes() {\n+        return cellPanes;\n+    }\n+\n+    public final void setActiveCellPane(CellPane p) {\n+        activeCellPane.set(p);\n+    }\n+\n+    public final CellPane getActiveCellPane() {\n+        return activeCellPane.get();\n+    }\n+\n+    private CellType getActiveCellType() {\n+        CellPane p = getActiveCellPane();\n+        return (p == null ? null : p.getCellType());\n+    }\n+\n+    private RichTextArea getSourceEditor() {\n+        CellPane p = getActiveCellPane();\n+        return (p == null ? null : p.getSourceEditor());\n+    }\n+\n+    public void setNotebook(Notebook b) {\n+        int sz = b == null ? 0 : b.size();\n+        ArrayList<CellPane> ps = new ArrayList<>(sz);\n+        if (b != null) {\n+            for (int i = 0; i < sz; i++) {\n+                CellInfo cell = b.getCell(i);\n+                ps.add(new CellPane(cell));\n+            }\n+        }\n+        cellPanes.setAll(ps);\n+        setModified(false);\n+    }\n+\n+    public void copy() {\n+        whenCell((t) -> t.copy());\n+    }\n+\n+    public void cut() {\n+        whenCell((t) -> t.cut());\n+    }\n+\n+    public void paste() {\n+        whenCell((t) -> t.paste());\n+    }\n+\n+    public void pasteUnformatted() {\n+        whenCell((t) -> t.pastePlainText());\n+    }\n+\n+    private void whenCell(Consumer<RichTextArea> c) {\n+        whenCell(null, c);\n+    }\n+\n+    private void whenCell(CellType type, Consumer<RichTextArea> c) {\n+        CellPane p = getActiveCellPane();\n+        if (p != null) {\n+            if (type != null) {\n+                if (type != p.getCellType()) {\n+                    return;\n+                }\n+            }\n+            RichTextArea r = p.getSourceEditor();\n+            if (r != null) {\n+                c.accept(r);\n+            }\n+        }\n+    }\n+\n+    public int getActiveCellIndex() {\n+        CellPane p = getActiveCellPane();\n+        return cellPanes.indexOf(p);\n+    }\n+\n+    public void insertCellBelow() {\n+        int ix = getActiveCellIndex();\n+        if (ix < 0) {\n+            ix = 0;\n+        }\n+        CellInfo cell = new CellInfo(CellType.CODE);\n+        CellPane p = new CellPane(cell);\n+        add(ix + 1, p);\n+        p.focusLater();\n+    }\n+\n+    public void moveCellDown() {\n+        int ix = getActiveCellIndex();\n+        if (ix >= 0) {\n+            if (ix + 1 < cellPanes.size()) {\n+                CellPane p = cellPanes.remove(ix);\n+                add(ix + 1, p);\n+            }\n+        }\n+    }\n+\n+    public void moveCellUp() {\n+        int ix = getActiveCellIndex();\n+        if (ix > 0) {\n+            CellPane p = cellPanes.remove(ix);\n+            add(ix - 1, p);\n+        }\n+    }\n+\n+    private void add(int ix, CellPane p) {\n+        if (ix < cellPanes.size()) {\n+            cellPanes.add(ix, p);\n+        } else {\n+            cellPanes.add(p);\n+        }\n+    }\n+\n+    public void deleteCell() {\n+        if (cellPanes.size() > 1) {\n+            int ix = getActiveCellIndex();\n+            if (ix >= 0) {\n+                cellPanes.remove(ix);\n+            }\n+        }\n+    }\n+\n+    public void selectAll() {\n+        whenCell((c) -> {\n+            c.selectAll();\n+         });\n+    }\n+\n+    public void redo() {\n+        whenCell((c) -> {\n+           c.redo();\n+        });\n+    }\n+\n+    public void undo() {\n+        whenCell((c) -> {\n+            c.undo();\n+        });\n+    }\n+\n+    public void bold() {\n+        toggleStyle(StyleAttributeMap.BOLD);\n+    }\n+\n+    public void italic() {\n+        toggleStyle(StyleAttributeMap.ITALIC);\n+    }\n+\n+    public void strikeThrough() {\n+        toggleStyle(StyleAttributeMap.STRIKE_THROUGH);\n+    }\n+\n+    public void underline() {\n+        toggleStyle(StyleAttributeMap.UNDERLINE);\n+    }\n+\n+    private void toggleStyle(StyleAttribute<Boolean> attr) {\n+        whenCell(CellType.TEXT, (c) -> {\n+            TextPos start = c.getAnchorPosition();\n+            TextPos end = c.getCaretPosition();\n+            if (start == null) {\n+                return;\n+            } else if (start.equals(end)) {\n+                \/\/ apply to the whole paragraph\n+                int ix = start.index();\n+                start = new TextPos(ix, 0);\n+                end = c.getParagraphEnd(ix);\n+            }\n+\n+            StyleAttributeMap a = c.getActiveStyleAttributeMap();\n+            boolean on = !a.getBoolean(attr);\n+            a = StyleAttributeMap.builder().set(attr, on).build();\n+            c.applyStyle(start, end, a);\n+            updateSourceStyles();\n+        });\n+    }\n+\n+    public void setTextStyle(TextStyle st) {\n+        whenCell(CellType.TEXT, (c) -> {\n+            TextPos start = c.getAnchorPosition();\n+            TextPos end = c.getCaretPosition();\n+            if (start == null) {\n+                return;\n+            } else if (start.equals(end)) {\n+                TextStyle cur = Styles.guessTextStyle(c.getActiveStyleAttributeMap());\n+                if (cur == st) {\n+                    return;\n+                }\n+                \/\/ apply to the whole paragraph\n+                int ix = start.index();\n+                start = new TextPos(ix, 0);\n+                end = c.getParagraphEnd(ix);\n+            }\n+\n+            StyleAttributeMap a = Styles.getStyleAttributeMap(st);\n+            c.applyStyle(start, end, a);\n+            updateSourceStyles();\n+        });\n+    }\n+\n+    public void setActiveCellType(CellType t) {\n+        if (t != null) {\n+            CellPane p = getActiveCellPane();\n+            int ix = cellPanes.indexOf(p);\n+            if (ix >= 0) {\n+                CellInfo cell = p.getCellInfo();\n+                if (t != cell.getCellType()) {\n+                    cell.setCellType(t);\n+                    p = new CellPane(cell);\n+                    cellPanes.set(ix, p);\n+                    p.focusLater();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void copyCell() {\n+        \/\/ TODO\n+    }\n+\n+    private void cutCell() {\n+        \/\/ TODO\n+    }\n+\n+    private void mergeCellAbove() {\n+        \/\/ TODO\n+    }\n+\n+    private void mergeCellBelow() {\n+        \/\/ TODO\n+    }\n+\n+    private void pasteCellBelow() {\n+        \/\/ TODO\n+    }\n+\n+    private void splitCell() {\n+        whenCell((c) -> {\n+            int ix = getActiveCellIndex();\n+            if(ix < 0) {\n+                return;\n+            }\n+            CellPane p = cellPanes.get(ix);\n+            List<CellPane> ps = p.split();\n+            if(ps == null) {\n+                return;\n+            }\n+            cellPanes.remove(ix);\n+            cellPanes.addAll(ix, ps);\n+        });\n+    }\n+\n+    public BooleanBinding disabledStyleEditingProperty() {\n+        return disabledStyleEditing;\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/Actions.java","additions":807,"deletions":0,"binary":false,"changes":807,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook;\n+\n+import javafx.geometry.Insets;\n+import javafx.scene.layout.VBox;\n+import com.oracle.demo.richtext.notebook.data.Notebook;\n+\n+\/**\n+ * Cell Container.\n+ *\/\n+public class CellContainer extends VBox {\n+    private Notebook notebook;\n+\n+    public CellContainer() {\n+        setSpacing(3);\n+        setPadding(new Insets(3));\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/CellContainer.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import javafx.application.Platform;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.css.PseudoClass;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Pos;\n+import javafx.geometry.VPos;\n+import javafx.scene.Node;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.ScrollPane;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.Priority;\n+import javafx.scene.layout.Region;\n+import javafx.scene.text.Font;\n+import com.oracle.demo.richtext.codearea.JavaSyntaxDecorator;\n+import com.oracle.demo.richtext.notebook.data.CellInfo;\n+import com.oracle.demo.richtext.util.FX;\n+import jfx.incubator.scene.control.richtext.CodeArea;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.CodeTextModel;\n+\n+\/**\n+ * Pane holds the visuals for the cell: source editor, output pane, execution label, current cell highlight.\n+ *\/\n+public class CellPane extends GridPane {\n+    private static final PseudoClass EXECUTING = PseudoClass.getPseudoClass(\"executing\");\n+    private static final Font FONT = new Font(\"Iosevka Fixed SS16\", 12);\n+    private static final Insets OUTPUT_PADDING = new Insets(0, 0, 3, 0);\n+    private final CellInfo cell;\n+    private final Region codeBar;\n+    private final Label execLabel;\n+    private final BorderPane sourcePane;\n+    private final BorderPane outputPane;\n+    private final SimpleBooleanProperty active = new SimpleBooleanProperty();\n+\n+    \/\/ TODO the side bar and exec label turn orange when source has been edited and the old output is still present\n+    \/\/ also exec label shows an asterisk *[N]\n+    public CellPane(CellInfo c) {\n+        super(3, 0);\n+\n+        this.cell = c;\n+        FX.style(this, \"cell-pane\");\n+\n+        codeBar = new Region();\n+        codeBar.setMinWidth(6);\n+        codeBar.setMaxWidth(6);\n+        FX.style(codeBar, \"code-bar\");\n+\n+        execLabel = new Label(cell.isCode() ? \"[ ]:\" : null);\n+        execLabel.setAlignment(Pos.TOP_RIGHT);\n+        execLabel.setMinWidth(50);\n+        FX.style(execLabel, \"exec-label\");\n+        \/\/ TODO bind to font property, set preferred width\n+        setValignment(execLabel, VPos.TOP);\n+\n+        sourcePane = new BorderPane();\n+        setHgrow(sourcePane, Priority.ALWAYS);\n+        setVgrow(sourcePane, Priority.NEVER);\n+\n+        outputPane = new BorderPane();\n+        FX.style(outputPane, \"output-pane\");\n+        outputPane.setMaxHeight(200);\n+        setHgrow(outputPane, Priority.ALWAYS);\n+        setVgrow(outputPane, Priority.NEVER);\n+        setMargin(outputPane, OUTPUT_PADDING);\n+\n+        int r = 0;\n+        add(codeBar, 0, r, 1, 2);\n+        add(execLabel, 1, r);\n+        add(sourcePane, 2, r);\n+        r++;\n+        add(outputPane, 2, r);\n+\n+        updateContent();\n+\n+        active.addListener((s,p,v) -> {\n+            FX.style(this, \"active-cell\", v);\n+        });\n+    }\n+\n+    private void updateContent() {\n+        RichTextArea ed = createEditor();\n+        sourcePane.setCenter(ed);\n+        outputPane.setCenter(null);\n+        ed.applyCss();\n+    }\n+\n+    private RichTextArea createEditor() {\n+        CellType t = cell.getCellType();\n+        switch (t) {\n+        case CODE:\n+            CodeArea c = new CodeArea();\n+            FX.style(c, \"code-cell\");\n+            c.setFont(FONT);\n+            c.setModel(cell.getModel());\n+            c.setSyntaxDecorator(new JavaSyntaxDecorator());\n+            c.setUseContentHeight(true);\n+            c.setWrapText(true);\n+            return c;\n+        case TEXT:\n+            RichTextArea r = new RichTextArea();\n+            FX.style(r, \"text-cell\");\n+            r.setModel(cell.getModel());\n+            r.setUseContentHeight(true);\n+            r.setWrapText(true);\n+            return r;\n+        }\n+        return null;\n+    }\n+\n+    public final CellInfo getCellInfo() {\n+        return cell;\n+    }\n+\n+    public final CellType getCellType() {\n+        return cell.getCellType();\n+    }\n+\n+    public void setExecuting() {\n+        execLabel.setText(\"[*]:\");\n+        FX.style(execLabel, EXECUTING, true);\n+\n+        getSourceEditor().requestFocus();\n+        outputPane.setCenter(null);\n+    }\n+\n+    public void setResult(Object result, int execCount) {\n+        String s = (execCount <= 0) ? \" \" : String.valueOf(execCount);\n+        execLabel.setText(\"[\" + s + \"]:\");\n+        FX.style(execLabel, EXECUTING, false);\n+\n+        Node n = createResultNode(result);\n+        outputPane.setCenter(n);\n+    }\n+\n+    private Node createResultNode(Object result) {\n+        if(result != null) {\n+            if(result instanceof Supplier gen) {\n+                Object v = gen.get();\n+                if(v instanceof Node n) {\n+                    return n;\n+                }\n+            } else if(result instanceof Throwable err) {\n+                StringWriter sw = new StringWriter();\n+                PrintWriter wr = new PrintWriter(sw);\n+                err.printStackTrace(wr);\n+                String text = sw.toString();\n+                return textViewer(text, true);\n+            } else if(result instanceof Image im) {\n+                ImageView v = new ImageView(im);\n+                ScrollPane sp = new ScrollPane(v);\n+                FX.style(sp, \"image-result\");\n+                return sp;\n+            } else if(result instanceof CodeTextModel m) {\n+                CodeArea t = new CodeArea(m);\n+                t.setMinHeight(300);\n+                t.setSyntaxDecorator(new SimpleJsonDecorator());\n+                t.setFont(FONT);\n+                t.setWrapText(false);\n+                t.setEditable(false);\n+                t.setLineNumbersEnabled(true);\n+                FX.style(t, \"output-text\");\n+                return t;\n+            } else {\n+                String text = result.toString();\n+                return textViewer(text, false);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static CodeTextModel from(String text) throws IOException {\n+        CodeTextModel m = new CodeTextModel();\n+        m.insertText(TextPos.ZERO, text);\n+        return m;\n+    }\n+\n+    private Node textViewer(String text, boolean error) {\n+        try {\n+            CodeTextModel m = from(text);\n+\n+            CodeArea t = new CodeArea();\n+            t.setFont(FONT);\n+            t.setModel(m);\n+            t.setUseContentHeight(true);\n+            t.setWrapText(false);\n+            t.setEditable(false);\n+            FX.style(t, error ? \"output-error\" : \"output-text\");\n+            return t;\n+        } catch (IOException wontHappen) {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ FIX does not work!\n+    public void focusLater() {\n+        Platform.runLater(() -> {\n+            Node n = sourcePane.getCenter();\n+            if (n instanceof RichTextArea a) {\n+                a.requestFocus();\n+            }\n+        });\n+    }\n+\n+    public RichTextArea getSourceEditor() {\n+        Node n = sourcePane.getCenter();\n+        if (n instanceof RichTextArea r) {\n+            return r;\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Splits the cell at the current source editor caret position.\n+     * TODO split into three parts when non-empty selection exists.\n+     * @return the list of cells resulting from the split\n+     *\/\n+    public List<CellPane> split() {\n+        RichTextArea r = getSourceEditor();\n+        if (r != null) {\n+            TextPos start = r.getAnchorPosition();\n+            if (start != null) {\n+                TextPos end = r.getCaretPosition();\n+                if (start.equals(end)) {\n+                    return splitInTwo(start);\n+                } else {\n+                    \/\/ TODO split into 3 parts?\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private List<CellPane> splitInTwo(TextPos p) {\n+        RichTextArea ed = getSourceEditor();\n+        CellType t = getCellType();\n+\n+        try {\n+            CellPane cell1 = new CellPane(new CellInfo(t));\n+            insert(ed, TextPos.ZERO, p, cell1.getSourceEditor(), TextPos.ZERO);\n+\n+            CellPane cell2 = new CellPane(new CellInfo(t));\n+            insert(ed, p, ed.getDocumentEnd(), cell2.getSourceEditor(), TextPos.ZERO);\n+\n+            return List.of(cell1, cell2);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    private void insert(RichTextArea src, TextPos start, TextPos end, RichTextArea tgt, TextPos pos) throws IOException {\n+        SegmentBuffer b = new SegmentBuffer();\n+        src.getModel().export(start, end, b.getStyledOutput());\n+        tgt.insertText(pos, b.getStyledInput());\n+    }\n+\n+    public void setActive(boolean on) {\n+        active.set(on);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/CellPane.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook;\n+\n+import javafx.util.StringConverter;\n+\n+\/**\n+ * Cell type enum.\n+ *\/\n+public enum CellType {\n+    CODE,\n+    TEXT;\n+\n+    public String getDisplayName() {\n+        switch(this) {\n+        case CODE:\n+            return \"Code\";\n+        case TEXT:\n+            return \"Text\";\n+        }\n+        throw new Error(\"?\" + this);\n+    }\n+\n+    public static StringConverter<CellType> converter() {\n+        return new StringConverter<CellType>() {\n+            @Override\n+            public String toString(CellType t) {\n+                return t == null ? null : t.getDisplayName();\n+            }\n+\n+            @Override\n+            public CellType fromString(String s) {\n+                for (CellType t : CellType.values()) {\n+                    if (s.equals(t.getDisplayName())) {\n+                        return t;\n+                    }\n+                }\n+                return CellType.TEXT;\n+            }\n+        };\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/CellType.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook;\n+\n+import java.io.IOException;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.CodeTextModel;\n+import jfx.incubator.scene.control.richtext.model.ContentChange;\n+import jfx.incubator.scene.control.richtext.model.StyledOutput;\n+\n+\/**\n+ * Cell Text Model.\n+ *\/\n+public class CodeCellTextModel extends CodeTextModel {\n+    private boolean modified;\n+\n+    public CodeCellTextModel() {\n+        addListener(new Listener() {\n+            @Override\n+            public void onContentChange(ContentChange ch) {\n+                if (ch.isEdit()) {\n+                    setModified(true);\n+                }\n+            }\n+        });\n+    }\n+\n+    public boolean isModified() {\n+        return modified;\n+    }\n+\n+    public void setModified(boolean on) {\n+        modified = on;\n+    }\n+\n+    public void setText(String text) {\n+        replace(null, TextPos.ZERO, TextPos.ZERO, text, false);\n+        setModified(false);\n+    }\n+\n+    public String getText() {\n+        try {\n+            StyledOutput out = StyledOutput.forPlainText();\n+            TextPos end = getDocumentEnd();\n+            export(TextPos.ZERO, end, out);\n+            return out.toString();\n+        } catch (IOException e) {\n+            return null;\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/CodeCellTextModel.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook;\n+\n+import com.oracle.demo.richtext.notebook.data.CellInfo;\n+import com.oracle.demo.richtext.notebook.data.Notebook;\n+\n+public class Demo {\n+    public static Notebook createNotebookExample() {\n+        Notebook b = new Notebook();\n+        {\n+            CellInfo c = new CellInfo(CellType.TEXT);\n+            c.setSource(\n+                \"\"\"\n+                Notebook Interface\n+\n+                A notebook interface or computational notebook is a virtual notebook environment used for literate programming, a method of writing computer programs.  Some notebooks are WYSIWYG environments including executable calculations embedded in formatted documents; others separate calculations and text into separate sections. Notebooks share some goals and features with spreadsheets and word processors but go beyond their limited data models.\n+\n+                Modular notebooks may connect to a variety of computational back ends, called \"kernels\". Notebook interfaces are widely used for statistics, data science, machine learning, and computer algebra.\n+\n+                https:\/\/en.wikipedia.org\/wiki\/Notebook_interface\"\"\");\n+            b.add(c);\n+        }\n+        {\n+            CellInfo c = new CellInfo(CellType.CODE);\n+            c.setSource(\n+                \"\"\"\n+                \/**\n+                 * This code cell generates a multi-line text result.\n+                 *\/\n+                int x = 5;\n+                String text = \"text\";\n+                print(x);\"\"\");\n+            b.add(c);\n+        }\n+        {\n+            CellInfo c = new CellInfo(CellType.CODE);\n+            c.setSource(\n+                \"\"\"\n+                \/\/\n+                \/\/ This code cell generates a general failure (exception)\n+                \/\/\n+                double sin(double x) {\n+                    return Math.sin(x);\n+                }\n+                print(sin(x) + 5.0);\"\"\");\n+            b.add(c);\n+        }\n+        {\n+            CellInfo c = new CellInfo(CellType.CODE);\n+            c.setSource(\n+                \"\"\"\n+                \/\/\n+                \/\/ This code cell generates an image output\n+                \/\/\n+                display(image);\"\"\");\n+            b.add(c);\n+        }\n+        {\n+            CellInfo c = new CellInfo(CellType.CODE);\n+            c.setSource(\n+                \"\"\"\n+                \/\/ And finally, this code cell generates a Node output.\n+                \/\/ This way any complex result can be rendered: a chart, a table or a spreadsheet, a complex input form...\n+                \/\/\n+                var node = new ListView(data);\n+                render(node);\"\"\");\n+            b.add(c);\n+        }\n+        {\n+            CellInfo c = new CellInfo(CellType.CODE);\n+            c.setSource(\n+                \"\"\"\n+                \/\/ This example simulates a JSON output backed by an external source, such as\n+                \/\/ database or remote API call.\n+                json = generateJsonOutput();\"\"\");\n+            b.add(c);\n+        }\n+        return b;\n+    }\n+\n+    public static Notebook createSingleTextCell() {\n+        Notebook b = new Notebook();\n+        {\n+            CellInfo c = new CellInfo(CellType.TEXT);\n+            c.setSource(\n+                \"\"\"\n+                This is a text cell.\n+                Right now it is a plain text cell, but we can make it a rich text cell.\n+                The only problem is that the user can change the cell type - and changing it from rich text to\n+                code or any other plain text based types will remove the styles.\n+                We could, of course, save the rich text until the user modifies the text, or may be even preserve\n+                the style information by simply rendering the plain text paragraphs, but then what would happen if\n+                the user switches back to rich text after editing?  Worth the try.\"\"\");\n+            b.add(c);\n+        }\n+        return b;\n+    }\n+\n+    public static Notebook createSingleCodeCell() {\n+        Notebook b = new Notebook();\n+        {\n+            CellInfo c = new CellInfo(CellType.CODE);\n+            b.add(c);\n+        }\n+        return b;\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/Demo.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook;\n+\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+import javafx.application.Platform;\n+import javafx.collections.FXCollections;\n+import javafx.scene.Node;\n+import javafx.scene.canvas.Canvas;\n+import javafx.scene.canvas.GraphicsContext;\n+import javafx.scene.control.ListView;\n+import javafx.scene.image.Image;\n+import javafx.scene.paint.Color;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.CodeTextModel;\n+\n+\/**\n+ * A demo script engine for the notebook.\n+ *\/\n+public class DemoScriptEngine {\n+    public DemoScriptEngine() {\n+    }\n+\n+    \/**\n+     * Executes the script and returns the result.\n+     * Result object can be one of the following:\n+     * - a Throwable (either returned or thrown when executing the script)\n+     * - a String for a text result\n+     * - a Supplier that creates a Node to be inserted into the output pane\n+     * @param src the source script\n+     * @return the result of computation\n+     *\/\n+    public Object executeScript(String src) throws Throwable {\n+        \/\/ pretent we are working\n+        Thread.sleep(500);\n+\n+        if (src == null) {\n+            return null;\n+        } else if (src.contains(\"text\")) {\n+            return \"\"\"\n+                Multi-line execution result.\n+                Line 1.\n+                Line 2.\n+                Line 3.\n+                Completed.\n+                \"\"\";\n+        } else if (src.contains(\"json\")) {\n+            JsonContentWithAsyncUpdate content = new JsonContentWithAsyncUpdate(10_000_000);\n+            return new CodeTextModel(content)\n+            {\n+                {\n+                    content.setUpdater((ix) -> {\n+                        TextPos p = new TextPos(ix, 0);\n+                        int len = getPlainText(ix).length();\n+                        fireChangeEvent(p, p, len, 0, 0);\n+                    });\n+                }\n+            };\n+        } else if (src.contains(\"node\")) {\n+            return new Supplier<Node>() {\n+                @Override\n+                public Node get() {\n+                    return new ListView(FXCollections.observableArrayList(\n+                        \"one\",\n+                        \"two\",\n+                        \"three\",\n+                        \"four\",\n+                        \"five\",\n+                        \"six\",\n+                        \"seven\",\n+                        \"eight\",\n+                        \"nine\",\n+                        \"ten\",\n+                        \"eleven\",\n+                        \"twelve\",\n+                        \"thirteen\",\n+                        \"fourteen\",\n+                        \"fifteen\",\n+                        \"sixteen\",\n+                        \"seventeen\",\n+                        \"nineteen\",\n+                        \"twenty\"\n+                    ));\n+                }\n+            };\n+        } else if (src.contains(\"image\")) {\n+            return executeInFx(this::generateImage);\n+        } else {\n+            throw new Error(\"script failed\");\n+        }\n+    }\n+\n+    private Image generateImage() {\n+        int w = 700;\n+        int h = 500;\n+        Canvas c = new Canvas(w, h);\n+        GraphicsContext g = c.getGraphicsContext2D();\n+        g.setFill(Color.gray(1.0));\n+        g.fillRect(0, 0, w, h);\n+\n+        g.setLineWidth(0.25);\n+\n+        Random rnd = new Random();\n+        for(int i=0; i<128; i++) {\n+            double x = rnd.nextInt(w);\n+            double y = rnd.nextInt(h);\n+            double r = rnd.nextInt(64);\n+            int hue = rnd.nextInt(360);\n+\n+            g.setFill(Color.hsb(hue, 0.5, 1.0, 0.5));\n+            g.fillOval(x - r, y - r, r + r, r + r);\n+\n+            g.setStroke(Color.hsb(hue, 0.5, 0.5, 1.0));\n+            g.strokeOval(x - r, y - r, r + r, r + r);\n+        }\n+        return c.snapshot(null, null);\n+    }\n+\n+    private static Object executeInFx(Supplier gen) {\n+        AtomicReference<Object> result = new AtomicReference<>();\n+        CountDownLatch latch = new CountDownLatch(1);\n+\n+        Platform.runLater(() -> {\n+            try {\n+                Object r = gen.get();\n+                result.set(r);\n+            } catch (Throwable e) {\n+                result.set(e);\n+            } finally {\n+                latch.countDown();\n+            }\n+        });\n+\n+        try {\n+            latch.await();\n+            return result.get();\n+        } catch (InterruptedException e) {\n+            return e;\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/DemoScriptEngine.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook;\n+\n+import java.io.FileNotFoundException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import javafx.scene.Node;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.Priority;\n+\n+public class ExceptionDialog extends Alert {\n+    public ExceptionDialog(Node owner, Throwable err) {\n+        super(AlertType.ERROR);\n+\n+        setTitle(\"An Error Occurred\");\n+        \/\/setHeaderText(\"\");\n+        \/\/setContentText(\"\");\n+\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw);\n+        err.printStackTrace(pw);\n+        String text = sw.toString();\n+\n+        Label label = new Label(\"The exception stacktrace:\");\n+\n+        TextArea textArea = new TextArea(text);\n+        textArea.setEditable(false);\n+        textArea.setWrapText(false);\n+\n+        textArea.setMaxWidth(Double.MAX_VALUE);\n+        textArea.setMaxHeight(Double.MAX_VALUE);\n+        GridPane.setVgrow(textArea, Priority.ALWAYS);\n+        GridPane.setHgrow(textArea, Priority.ALWAYS);\n+\n+        GridPane expContent = new GridPane();\n+        expContent.setMaxWidth(Double.MAX_VALUE);\n+        expContent.add(label, 0, 0);\n+        expContent.add(textArea, 0, 1);\n+\n+        getDialogPane().setExpandableContent(expContent);\n+    }\n+\n+    public void open() {\n+        showAndWait();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/ExceptionDialog.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.HashMap;\n+import java.util.HexFormat;\n+import java.util.Random;\n+import java.util.function.Consumer;\n+import javafx.animation.KeyFrame;\n+import javafx.animation.Timeline;\n+import javafx.util.Duration;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.BasicTextModel;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * Mock content which simulates non-instantaneous retrieval of the underlying data,\n+ * as in database call or remote file system.\n+ *\/\n+public class JsonContentWithAsyncUpdate implements BasicTextModel.Content {\n+    private final int size;\n+    private final HashMap<Integer,String> data;\n+    private final Random random = new Random();\n+    private final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy\/MM\/dd HH:mm:ss.SSSS\");\n+    private final HexFormat hex = HexFormat.of();\n+    private Consumer<Integer> updater;\n+\n+    public JsonContentWithAsyncUpdate(int size) {\n+        this.size = size;\n+        this.data = new HashMap<>(size);\n+    }\n+\n+    @Override\n+    public boolean isUserEditable() {\n+        return true;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return size;\n+    }\n+\n+    @Override\n+    public String getText(int index) {\n+        String s = data.get(index);\n+        if (s == null) {\n+            queue(index);\n+            return \"\";\n+        }\n+        return s;\n+    }\n+\n+    private void queue(int index) {\n+        Duration simulatedDelay = Duration.millis(200 + random.nextInt(3_000));\n+        Timeline t = new Timeline();\n+        t.setCycleCount(1);\n+        t.getKeyFrames().add(\n+            new KeyFrame(simulatedDelay, (ev) -> {\n+                String s = generate(index);\n+                if(!data.containsKey(index)) {\n+                    data.put(index, s);\n+                    update(index);\n+                }\n+            })\n+        );\n+        t.play();\n+    }\n+\n+    private void update(int index) {\n+        if (updater != null) {\n+            updater.accept(index);\n+        }\n+    }\n+\n+    public void setUpdater(Consumer<Integer> u) {\n+        updater = u;\n+    }\n+\n+    @Override\n+    public int insertTextSegment(int index, int offset, String text, StyleAttributeMap attrs) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void insertLineBreak(int index, int offset) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void removeRange(TextPos start, TextPos end) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    private String bytes(int count) {\n+        byte[] b = new byte[count];\n+        random.nextBytes(b);\n+        return hex.formatHex(b);\n+    }\n+\n+    private String generate(int index) {\n+        Random r = new Random();\n+        long time = System.currentTimeMillis() - ((size - 1 - index) * 145_678L);\n+        String date = dateFormat.format(time);\n+        String id = bytes(8);\n+        String message = bytes(1 + random.nextInt(10));\n+        String payload = bytes(10 + random.nextInt(128));\n+        int size = payload.length() \/ 2;\n+\n+        return\n+            \"{date=\\\"\" + date + \"\\\"\" +\n+            \", timestamp=\" + time +\n+            \", id=\\\"\" + id + \"\\\"\" +\n+            \", message-id=\\\"\" + message + \"\\\"\" +\n+            \", payload=\\\"\" + payload + \"\\\"\" +\n+            \", size=\" + size +\n+            \"}\";\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/JsonContentWithAsyncUpdate.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.notebook;\n+\n+import javafx.application.Application;\n+import javafx.stage.Stage;\n+import com.oracle.demo.richtext.settings.FxSettings;\n+\n+\/**\n+ * Interactive Notebook Skeleton Implementation.\n+ * Demonstrates the use of RichTextArea\/CodeArea in a notebook-like setting.\n+ *\/\n+public class NotebookMockupApp extends Application {\n+    public static void main(String[] args) {\n+        Application.launch(NotebookMockupApp.class, args);\n+    }\n+\n+    @Override\n+    public void init() {\n+        FxSettings.useDirectory(\".NotebookMockupApp\");\n+    }\n+\n+    @Override\n+    public void start(Stage stage) throws Exception {\n+        new NotebookWindow().show();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/NotebookMockupApp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.notebook;\n+\n+import javafx.beans.binding.Bindings;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.ScrollPane;\n+import javafx.scene.control.ToolBar;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyEvent;\n+import javafx.scene.layout.BorderPane;\n+import com.oracle.demo.richtext.common.TextStyle;\n+import com.oracle.demo.richtext.util.FX;\n+\n+\/**\n+ * Main Panel.\n+ *\/\n+public class NotebookPane extends BorderPane {\n+    public final CellContainer cellContainer;\n+    private final Actions actions;\n+    private final ComboBox<CellType> cellType;\n+    private final ComboBox<TextStyle> textStyle;\n+\n+    public NotebookPane(Actions a) {\n+        FX.name(this, \"RichEditorDemoPane\");\n+\n+        this.actions = a;\n+\n+        cellContainer = new CellContainer();\n+        Bindings.bindContent(cellContainer.getChildren(), actions.getCellPanes());\n+        \/\/cellPane.setContextMenu(createContextMenu());\n+        \/\/ this is a job for the InputMap!\n+        cellContainer.addEventFilter(KeyEvent.KEY_PRESSED, this::handleContextExecute);\n+\n+        cellType = new ComboBox<>();\n+        cellType.getItems().setAll(CellType.values());\n+        cellType.setConverter(CellType.converter());\n+        cellType.setOnAction((ev) -> {\n+            updateActiveCellType();\n+        });\n+\n+        textStyle = new ComboBox<>();\n+        textStyle.getItems().setAll(TextStyle.values());\n+        textStyle.setConverter(TextStyle.converter());\n+        textStyle.setOnAction((ev) -> {\n+            updateTextStyle();\n+        });\n+        textStyle.disableProperty().bind(actions.disabledStyleEditingProperty());\n+\n+        ScrollPane scroll = new ScrollPane(cellContainer);\n+        scroll.setFitToWidth(true);\n+\n+        setTop(createToolBar());\n+        setCenter(scroll);\n+\n+        actions.textStyleProperty().addListener((s,p,c) -> {\n+            setTextStyle(c);\n+        });\n+    }\n+\n+    \/\/ TODO move to window?\n+    private ToolBar createToolBar() {\n+        ToolBar t = new ToolBar();\n+        FX.button(t, \"+\", \"Insert a cell below\", actions.insertCellBelow);\n+        FX.button(t, \"Cu\", \"Cut this cell\");\n+        FX.button(t, \"Co\", \"Copy this cell\");\n+        FX.button(t, \"Pa\", \"Paste this cell from the clipboard\");\n+        FX.add(t, cellType);\n+        FX.space(t);\n+        FX.button(t, \"▶\", \"Run this cell and advance\", actions.runAndAdvance);\n+        FX.button(t, \"▶▶\", \"Run all cells\", actions.runAll);\n+        FX.space(t);\n+        FX.toggleButton(t, \"𝐁\", \"Bold text\", actions.bold);\n+        FX.toggleButton(t, \"𝐼\", \"Bold text\", actions.italic);\n+        FX.toggleButton(t, \"S\\u0336\", \"Strike through text\", actions.strikeThrough);\n+        FX.toggleButton(t, \"U\\u0332\", \"Underline text\", actions.underline);\n+        FX.add(t, textStyle);\n+        return t;\n+    }\n+\n+    \/\/ TODO use this?\n+    private ContextMenu createContextMenu() {\n+        ContextMenu m = new ContextMenu();\n+        FX.item(m, \"Cut Cell\");\n+        FX.item(m, \"Copy Cell\");\n+        FX.item(m, \"Paste Cell Below\");\n+        FX.separator(m);\n+        FX.item(m, \"Delete Cell\");\n+        FX.separator(m);\n+        FX.item(m, \"Split Cell\");\n+        FX.item(m, \"Merge Selected Cell\");\n+        FX.item(m, \"Merge Cell Above\");\n+        FX.item(m, \"Merge Cell Below\");\n+        FX.separator(m);\n+        FX.item(m, \"Undo\", actions.undo);\n+        FX.item(m, \"Redo\", actions.redo);\n+        FX.separator(m);\n+        FX.item(m, \"Cut\", actions.cut);\n+        FX.item(m, \"Copy\", actions.copy);\n+        FX.item(m, \"Paste\", actions.paste);\n+        FX.item(m, \"Paste and Retain Style\", actions.pasteUnformatted);\n+        FX.separator(m);\n+        FX.item(m, \"Select All\", actions.selectAll);\n+        return m;\n+    }\n+\n+    public void setActiveCellPane(CellPane p) {\n+        CellType t = (p == null ? null : p.getCellType());\n+        cellType.getSelectionModel().select(t);\n+    }\n+\n+    private void updateActiveCellType() {\n+        CellType t = cellType.getSelectionModel().getSelectedItem();\n+        actions.setActiveCellType(t);\n+    }\n+\n+    private void handleContextExecute(KeyEvent ev) {\n+        if (ev.getCode() == KeyCode.ENTER) {\n+            if (ev.isShortcutDown()) {\n+                actions.runAndAdvance();\n+            }\n+        }\n+    }\n+\n+    private void updateTextStyle() {\n+        TextStyle st = textStyle.getSelectionModel().getSelectedItem();\n+        if (st != null) {\n+            actions.setTextStyle(st);\n+        }\n+    }\n+\n+    public void setTextStyle(TextStyle v) {\n+        textStyle.setValue(v);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/NotebookPane.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.notebook;\n+\n+import java.io.File;\n+import javafx.application.Platform;\n+import javafx.geometry.Insets;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Menu;\n+import javafx.scene.control.MenuBar;\n+import javafx.scene.layout.BorderPane;\n+import javafx.stage.Stage;\n+import com.oracle.demo.richtext.notebook.data.Notebook;\n+import com.oracle.demo.richtext.rta.RichTextAreaWindow;\n+import com.oracle.demo.richtext.util.FX;\n+\n+\/**\n+ * Notebook Demo main window.\n+ *\/\n+public class NotebookWindow extends Stage {\n+    private static final String TITLE = \"Interactive Notebook (Mockup)\";\n+    private final Actions actions;\n+    private final NotebookPane pane;\n+    private final Label status;\n+\n+    public NotebookWindow() {\n+        FX.name(this, \"NotebookWindow\");\n+\n+        actions = new Actions(this);\n+\n+        pane = new NotebookPane(actions);\n+\n+        status = new Label();\n+        status.setPadding(new Insets(2, 10, 2, 10));\n+\n+        BorderPane bp = new BorderPane();\n+        bp.setTop(createMenu());\n+        bp.setCenter(pane);\n+        bp.setBottom(status);\n+\n+        Scene scene = new Scene(bp);\n+        scene.getStylesheets().addAll(\n+            getClass().getResource(\"notebook.css\").toExternalForm()\n+        );\n+        scene.focusOwnerProperty().addListener((s,p,c) -> {\n+            handleFocusUpdate(c);\n+        });\n+\n+        \/\/ TODO input map for the window: add shortcut-S for saving\n+\n+        setScene(scene);\n+        setWidth(1200);\n+        setHeight(600);\n+\n+        actions.modifiedProperty().addListener((x) -> {\n+            updateTitle();\n+        });\n+        actions.fileNameProperty().addListener((x) -> {\n+            updateTitle();\n+        });\n+        updateTitle();\n+\n+        setNotebook(Demo.createSingleCodeCell());\n+        \/\/setNotebook(Demo.createNotebookExample());\n+    }\n+\n+    private MenuBar createMenu() {\n+        Menu m2;\n+        MenuBar b = new MenuBar();\n+        \/\/ file\n+        FX.menu(b, \"File\");\n+        FX.item(b, \"New\", actions.newDocument);\n+        FX.item(b, \"Open...\", actions.open);\n+        m2 = FX.submenu(b, \"Open Recent\");\n+        FX.item(m2, \"Notebook Example\", () -> setNotebook(Demo.createNotebookExample()));\n+        FX.item(m2, \"Single Text Cell\", () -> setNotebook(Demo.createSingleTextCell()));\n+        FX.item(m2, \"Empty Code Cell\", () -> setNotebook(Demo.createSingleCodeCell()));\n+        FX.separator(b);\n+        FX.item(b, \"Save...\", actions.save);\n+        \/\/ TODO print?\n+        FX.item(b, \"Quit\", () -> Platform.exit());\n+\n+        \/\/ edit\n+        FX.menu(b, \"Edit\");\n+        FX.item(b, \"Undo\", actions.undo);\n+        FX.item(b, \"Redo\", actions.redo);\n+        FX.separator(b);\n+        FX.item(b, \"Cut\", actions.cut);\n+        FX.item(b, \"Copy\", actions.copy);\n+        FX.item(b, \"Paste\", actions.paste);\n+        FX.item(b, \"Paste and Retain Style\", actions.pasteUnformatted);\n+\n+        \/\/ format\n+        FX.menu(b, \"Format\");\n+        FX.checkItem(b, \"Bold\", actions.bold);\n+        FX.checkItem(b, \"Italic\", actions.italic);\n+        FX.checkItem(b, \"Strike Through\", actions.strikeThrough);\n+        FX.checkItem(b, \"Underline\", actions.underline);\n+\n+        \/\/ cell\n+        FX.menu(b, \"Cell\");\n+        FX.item(b, \"Cut Cell\", actions.cutCell);\n+        FX.item(b, \"Copy Cell\", actions.copyCell);\n+        FX.item(b, \"Paste Cell Below\", actions.pasteCellBelow);\n+        FX.separator(b);\n+        FX.item(b, \"Insert Cell Below\", actions.insertCellBelow);\n+        FX.separator(b);\n+        FX.item(b, \"Move Up\", actions.moveCellUp);\n+        FX.item(b, \"Move Down\", actions.moveCellDown);\n+        FX.separator(b);\n+        FX.item(b, \"Split Cell\", actions.splitCell);\n+        FX.item(b, \"Merge Cell Above\", actions.mergeCellAbove);\n+        FX.item(b, \"Merge Cell Below\", actions.mergeCellBelow);\n+        FX.separator(b);\n+        FX.item(b, \"Delete\", actions.deleteCell);\n+\n+        \/\/ run\n+        FX.menu(b, \"Run\");\n+        FX.item(b, \"Run Current Cell And Advance\", actions.runAndAdvance);\n+        FX.item(b, \"Run All Cells\", actions.runAll);\n+\n+        \/\/ view\n+        FX.menu(b, \"View\");\n+        FX.item(b, \"Show Line Numbers\");\n+\n+        \/\/ help\n+        FX.menu(b, \"Help\");\n+        FX.item(b, \"About\");\n+        return b;\n+    }\n+\n+    private void updateTitle() {\n+        File f = actions.getFile();\n+        boolean modified = actions.isModified();\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(TITLE);\n+        if (f != null) {\n+            sb.append(\" - \");\n+            sb.append(f.getName());\n+        }\n+        if (modified) {\n+            sb.append(\" *\");\n+        }\n+        setTitle(sb.toString());\n+    }\n+\n+    private void handleFocusUpdate(Node n) {\n+        CellPane p = FX.findParentOf(CellPane.class, n);\n+        if (p != null) {\n+            actions.setActiveCellPane(p);\n+            pane.setActiveCellPane(p);\n+        }\n+    }\n+\n+    public void setNotebook(Notebook b) {\n+        actions.setNotebook(b);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/NotebookWindow.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import javafx.application.Platform;\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.TextField;\n+import javafx.scene.input.DataFormat;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.Priority;\n+import javafx.stage.DirectoryChooser;\n+import javafx.stage.Window;\n+import com.oracle.demo.richtext.util.FX;\n+\n+public class SavePane extends GridPane {\n+    private final TextField nameField;\n+    private final ComboBox<File> folderField;\n+    private final ComboBox<DataFormat> formatField;\n+\n+    public SavePane() {\n+        nameField = new TextField();\n+        setHgrow(nameField, Priority.ALWAYS);\n+        setFillWidth(nameField, Boolean.TRUE);\n+\n+        folderField = new ComboBox<>();\n+        setHgrow(folderField, Priority.ALWAYS);\n+        setFillWidth(folderField, Boolean.TRUE);\n+\n+        formatField = new ComboBox<>();\n+\n+        Button browse = new Button(\"Browse\");\n+        setFillWidth(browse, Boolean.TRUE);\n+        browse.setOnAction((ev) -> {\n+            browse();\n+        });\n+\n+        int r = 0;\n+        add(label(\"Save As:\"), 0, r);\n+        add(nameField, 1, r, 3, 1);\n+        r++;\n+        add(label(\"Where:\"), 0, r);\n+        add(folderField, 1, r);\n+        add(browse, 2, r);\n+        r++;\n+        add(label(\"File Format:\"), 0, r);\n+        add(formatField, 1, r, 2, 1);\n+\n+        setHgap(10);\n+        setVgap(5);\n+        setPadding(new Insets(10));\n+\n+        Platform.runLater(() -> {\n+            nameField.selectAll();\n+            nameField.requestFocus();\n+        });\n+    }\n+\n+    private static Label label(String text) {\n+        Label t = new Label(text);\n+        setHalignment(t, HPos.RIGHT);\n+        return t;\n+    }\n+\n+    public void setFile(File f) {\n+        if (f == null) {\n+            nameField.setText(\"Untitled.rich\");\n+            setDir(null);\n+        } else {\n+            nameField.setText(f.getName());\n+            setDir(f.getParentFile());\n+        }\n+    }\n+\n+    private void setDir(File dir) {\n+        if (dir == null) {\n+            dir = new File(System.getProperty(\"user.home\"));\n+        }\n+        ArrayList<File> fs = new ArrayList<>();\n+        File f = dir;\n+        do {\n+            fs.add(f);\n+            f = f.getParentFile();\n+        } while (f != null);\n+        folderField.getItems().setAll(fs);\n+        folderField.getSelectionModel().select(dir);\n+    }\n+\n+    public void setFormat(DataFormat f) {\n+        \/\/ TODO\n+    }\n+\n+    public File getFile() {\n+        File dir = getDir();\n+        \/\/ TODO extension based on data format\n+        return new File(dir, nameField.getText());\n+    }\n+\n+    public DataFormat getFileFormat() {\n+        return null; \/\/ FIX\n+    }\n+\n+    private File getDir() {\n+        return folderField.getSelectionModel().getSelectedItem();\n+    }\n+\n+    private void browse() {\n+        DirectoryChooser ch = new DirectoryChooser();\n+        ch.setTitle(\"Choose Folder\");\n+        ch.setInitialDirectory(getDir());\n+        Window w = FX.getParentWindow(this);\n+        File f = ch.showDialog(w);\n+        if (f != null) {\n+            setDir(f);\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/SavePane.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import jfx.incubator.scene.control.richtext.model.StyledInput;\n+import jfx.incubator.scene.control.richtext.model.StyledOutput;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+\n+\/**\n+ * In-memory buffer which stored {@code StyledSegment}s with associated output and input streams,\n+ * for the use in export\/import or transfer operations.\n+ * This class and its streams are not thread safe.\n+ *\/\n+public class SegmentBuffer {\n+    private ArrayList<StyledSegment> segments;\n+    private Output output;\n+\n+    \/**\n+     * Creates the buffer with the specified initial capacity.\n+     * @param initialCapacity the initial capacity\n+     *\/\n+    public SegmentBuffer(int initialCapacity) {\n+        segments = new ArrayList<>(initialCapacity);\n+    }\n+\n+    \/**\n+     * Creates the buffer.\n+     *\/\n+    public SegmentBuffer() {\n+        this(256);\n+    }\n+\n+    \/**\n+     * Returns the singleton {@code StyledOutput} instance associated with this buffer.\n+     * @return the StyledOutput instance\n+     *\/\n+    public StyledOutput getStyledOutput() {\n+        if(output == null) {\n+            output = new Output();\n+        }\n+        return output;\n+    }\n+\n+    \/**\n+     * Returns an array of {@code StyledSegment}s accumulated so far.\n+     * @return the array of {@code StyledSegment}s\n+     *\/\n+    public StyledSegment[] getSegments() {\n+        return segments.toArray(new StyledSegment[segments.size()]);\n+    }\n+\n+    \/**\n+     * Returns a new instance of {@code StyledInput} which contains the segments accumulated so far.\n+     * @return the instance of {@code StyledInput}\n+     *\/\n+    public StyledInput getStyledInput() {\n+        return new Input(getSegments());\n+    }\n+\n+    private class Output implements StyledOutput {\n+        Output() {\n+        }\n+\n+        @Override\n+        public void consume(StyledSegment s) throws IOException {\n+            segments.add(s);\n+        }\n+\n+        @Override\n+        public void flush() throws IOException {\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            \/\/ possibly create a boolean flag to force an IOException in append when closed\n+        }\n+    }\n+\n+    private static class Input implements StyledInput {\n+        private final StyledSegment[] segments;\n+        private int index;\n+\n+        Input(StyledSegment[] segments) {\n+            this.segments = segments;\n+        }\n+\n+        @Override\n+        public StyledSegment nextSegment() {\n+            if (index < segments.length) {\n+                return segments[index++];\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/SegmentBuffer.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,230 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javafx.scene.paint.Color;\n+import com.oracle.demo.richtext.codearea.JavaSyntaxAnalyzer.Line;\n+import com.oracle.demo.richtext.codearea.JavaSyntaxAnalyzer.Type;\n+import jfx.incubator.scene.control.richtext.SyntaxDecorator;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.CodeTextModel;\n+import jfx.incubator.scene.control.richtext.model.RichParagraph;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * Super simple (and therefore not always correct) syntax decorator for JSON\n+ * which works one line at a time.\n+ *\/\n+public class SimpleJsonDecorator implements SyntaxDecorator {\n+    private static final StyleAttributeMap NORMAL = mkStyle(Color.BLACK);\n+    private static final StyleAttributeMap NUMBER = mkStyle(Color.MAGENTA);\n+    private static final StyleAttributeMap STRING = mkStyle(Color.BLUE);\n+\n+    public SimpleJsonDecorator() {\n+    }\n+\n+    @Override\n+    public void handleChange(CodeTextModel m, TextPos start, TextPos end, int top, int added, int bottom) {\n+    }\n+\n+    @Override\n+    public RichParagraph createRichParagraph(CodeTextModel model, int index) {\n+        String text = model.getPlainText(index);\n+        List<Seg> segments = new Analyzer(text).parse();\n+        RichParagraph.Builder b = RichParagraph.builder();\n+        for (Seg seg : segments) {\n+            b.addSegment(seg.text, seg.style);\n+        }\n+        return b.build();\n+    }\n+\n+    private static StyleAttributeMap mkStyle(Color c) {\n+        return StyleAttributeMap.builder().setTextColor(c).build();\n+    }\n+\n+    private static record Seg(StyleAttributeMap style, String text) {\n+    }\n+\n+    private enum State {\n+        NUMBER,\n+        STRING,\n+        TEXT,\n+        VALUE,\n+    }\n+\n+    private static class Analyzer {\n+        private final String text;\n+        private final ArrayList<Seg> segments = new ArrayList<>();\n+        private static final int EOF = -1;\n+        private int start;\n+        private int pos;\n+        private State state = State.TEXT;\n+\n+        public Analyzer(String text) {\n+            this.text = text;\n+        }\n+\n+        private int peek(int delta) {\n+            int ix = pos + delta;\n+            if ((ix >= 0) && (ix < text.length())) {\n+                return text.charAt(ix);\n+            }\n+            return EOF;\n+        }\n+\n+        private void addSegment() {\n+            StyleAttributeMap type = toStyleAttrs(state);\n+            addSegment(type);\n+        }\n+\n+        private StyleAttributeMap toStyleAttrs(State s) {\n+            switch (s) {\n+            case STRING:\n+                return STRING;\n+            case NUMBER:\n+                return NUMBER;\n+            case VALUE:\n+            default:\n+                return NORMAL;\n+            }\n+        }\n+\n+        private void addSegment(StyleAttributeMap style) {\n+            if (pos > start) {\n+                String s = text.substring(start, pos);\n+                segments.add(new Seg(style, s));\n+                start = pos;\n+            }\n+        }\n+\n+        private Error err(String text) {\n+            return new Error(text + \" state=\" + state + \" pos=\" + pos);\n+        }\n+\n+        private int parseNumber() {\n+            int ix = indexOfNonNumber();\n+            if (ix < 0) {\n+                return 0;\n+            }\n+            String s = text.substring(pos, pos + ix);\n+            try {\n+                Double.parseDouble(s);\n+                return ix;\n+            } catch (NumberFormatException e) {\n+            }\n+            return 0;\n+        }\n+\n+        private int indexOfNonNumber() {\n+            int i = 0;\n+            for (;;) {\n+                int c = peek(i);\n+                switch (c) {\n+                case EOF:\n+                    return i;\n+                \/\/ we'll parse integers only for now case '.':\n+                case '-':\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    i++;\n+                    continue;\n+                default:\n+                    return i;\n+                }\n+            }\n+        }\n+\n+        public List<Seg> parse() {\n+            start = 0;\n+            for (;;) {\n+                int c = peek(0);\n+                switch (c) {\n+                case EOF:\n+                    addSegment();\n+                    return segments;\n+                case '\"':\n+                    switch (state) {\n+                    case TEXT:\n+                    case VALUE:\n+                        addSegment();\n+                        state = State.STRING;\n+                        pos++;\n+                        break;\n+                    case STRING:\n+                        pos++;\n+                        addSegment();\n+                        state = State.TEXT;\n+                        break;\n+                    default:\n+                        throw err(\"state must be either TEXT, STRING, or VALUE\");\n+                    }\n+                    break;\n+                case '=':\n+                    state = State.VALUE;\n+                    break;\n+                \/\/case '.':\n+                case '-':\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    switch (state) {\n+                    case VALUE:\n+                        int len = parseNumber();\n+                        if (len > 0) {\n+                            addSegment();\n+                            state = State.NUMBER;\n+                            pos += len;\n+                            addSegment();\n+                        }\n+                        break;\n+                    }\n+                    break;\n+                default:\n+                    break;\n+                }\n+\n+                pos++;\n+            }\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/SimpleJsonDecorator.java","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook;\n+\n+import java.io.IOException;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.ContentChange;\n+import jfx.incubator.scene.control.richtext.model.RichTextModel;\n+import jfx.incubator.scene.control.richtext.model.StyledOutput;\n+\n+public class TextCellTextModel extends RichTextModel {\n+    private boolean modified;\n+\n+    public TextCellTextModel() {\n+        addListener(new Listener() {\n+            @Override\n+            public void onContentChange(ContentChange ch) {\n+                setModified(true);\n+            }\n+        });\n+    }\n+\n+    public boolean isModified() {\n+        return modified;\n+    }\n+\n+    public void setModified(boolean on) {\n+        modified = on;\n+    }\n+\n+    public void setText(String text) {\n+        replace(null, TextPos.ZERO, TextPos.ZERO, text, false);\n+        setModified(false);\n+    }\n+\n+    public String getPlainText() {\n+        try {\n+            StyledOutput out = StyledOutput.forPlainText();\n+            TextPos end = getDocumentEnd();\n+            export(TextPos.ZERO, end, out);\n+            return out.toString();\n+        } catch (IOException e) {\n+            return null;\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/TextCellTextModel.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook.data;\n+\n+import com.oracle.demo.richtext.notebook.CellType;\n+import com.oracle.demo.richtext.notebook.CodeCellTextModel;\n+import com.oracle.demo.richtext.notebook.TextCellTextModel;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+\n+\/**\n+ * This data structure represents a cell in the notebook.\n+ *\/\n+public class CellInfo {\n+    private CellType type;\n+    private String source;\n+    private CodeCellTextModel codeModel;\n+    private TextCellTextModel textModel;\n+\n+    public CellInfo(CellType t) {\n+        this.type = t;\n+    }\n+\n+    public final CellType getCellType() {\n+        return type;\n+    }\n+\n+    public final void setCellType(CellType t) {\n+        type = t;\n+    }\n+\n+    public boolean isCode() {\n+        return getCellType() == CellType.CODE;\n+    }\n+\n+    public boolean isText() {\n+        return getCellType() == CellType.TEXT;\n+    }\n+\n+    public final StyledTextModel getModel() {\n+        switch (type) {\n+        case CODE:\n+            if (textModel != null) {\n+                if (textModel.isModified()) {\n+                    source = textModel.getPlainText();\n+                    codeModel = null;\n+                }\n+            }\n+            if (codeModel == null) {\n+                codeModel = new CodeCellTextModel();\n+                codeModel.setText(source);\n+            }\n+            return codeModel;\n+        case TEXT:\n+        default:\n+            if (codeModel != null) {\n+                if (codeModel.isModified()) {\n+                    source = codeModel.getText();\n+                    textModel = null;\n+                }\n+            }\n+            if (textModel == null) {\n+                textModel = new TextCellTextModel();\n+                textModel.setText(source);\n+            }\n+            return textModel;\n+        }\n+    }\n+\n+    private void handleTypeChange(CellType old, CellType type) {\n+        switch (type) {\n+        case CODE:\n+            \/\/ TODO\n+        case TEXT:\n+        default:\n+            break;\n+        }\n+    }\n+\n+    public String getSource() {\n+        switch (type) {\n+        case CODE:\n+            if (codeModel != null) {\n+                if (codeModel.isModified()) {\n+                    source = codeModel.getText();\n+                    codeModel.setModified(false);\n+                }\n+            }\n+            break;\n+        case TEXT:\n+        default:\n+            if (textModel != null) {\n+                if (textModel.isModified()) {\n+                    source = textModel.getPlainText();\n+                    textModel.setModified(false);\n+                }\n+            }\n+            break;\n+        }\n+        return source;\n+    }\n+\n+    public void setSource(String text) {\n+        this.source = text;\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/data\/CellInfo.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.notebook.data;\n+\n+import java.util.ArrayList;\n+\n+\/**\n+ * Notebook Data Object.\n+ *\/\n+public class Notebook {\n+    private final ArrayList<CellInfo> cells = new ArrayList<>();\n+\n+    public Notebook() {\n+    }\n+\n+    public int size() {\n+        return cells.size();\n+    }\n+\n+    public CellInfo getCell(int ix) {\n+        return cells.get(ix);\n+    }\n+\n+    public void add(CellInfo cell) {\n+        cells.add(cell);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/data\/Notebook.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+.active-cell .code-bar {\n+    -fx-background-color: #488f48;\n+    -fx-background-radius: 2;\n+}\n+\n+.exec-label {\n+    -fx-text-fill: gray;\n+}\n+\n+.cell-pane:focus-within .exec-label {\n+    -fx-text-fill: black;\n+}\n+\n+.exec-label:executing {\n+    -fx-text-fill: red;\n+    -fx-font-weight: bold;\n+}\n+\n+.output-text .content {\n+    -fx-background-color:f8f8f8;\n+    -fx-background-insets:0;\n+}\n+\n+.output-error .content {\n+    -fx-background-color:fff0f0;\n+    -fx-background-insets:0;\n+}\n+\n+.image-result {\n+    -fx-background-color: #888888;\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/notebook\/notebook.css","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import javafx.scene.canvas.Canvas;\n+import javafx.scene.canvas.GraphicsContext;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.paint.Color;\n+\n+public class BifurcationDiagram {\n+    private static final double min = 2.4;\n+    private static final double max = 4.0;\n+\n+    public static Pane generate() {\n+        Pane p = new Pane();\n+        p.setPrefSize(600, 200);\n+        p.widthProperty().addListener((x) -> update(p));\n+        p.heightProperty().addListener((x) -> update(p));\n+        update(p);\n+        return p;\n+    }\n+\n+    protected static void update(Pane p) {\n+        double w = p.getWidth();\n+        double h = p.getHeight();\n+\n+        if ((w < 1) || (h < 1)) {\n+            return;\n+        } else if (w > 600) {\n+            w = 600;\n+        }\n+\n+        Canvas c = new Canvas(w, h);\n+        GraphicsContext g = c.getGraphicsContext2D();\n+\n+        g.setFill(Color.gray(0.9));\n+        g.fillRect(0, 0, w, h);\n+\n+        int count = 1000;\n+        int start = 500;\n+        double r = 0.3;\n+        g.setFill(Color.rgb(0, 0, 0, 0.2));\n+\n+        for (double λ = min; λ < max; λ += 0.001) {\n+            double x = 0.5;\n+            for (int i = 0; i < count; i++) {\n+                x = λ * x * (1.0 - x);\n+                if (i > start) {\n+                    double px = w * (λ - min) \/ (max - min);\n+                    double py = h * (1.0 - x);\n+\n+                    g.fillOval(px - r, py - r, r + r, r + r);\n+                }\n+            }\n+        }\n+\n+        p.getChildren().setAll(c);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/BifurcationDiagram.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import java.nio.charset.Charset;\n+import java.util.Base64;\n+import javafx.collections.ObservableList;\n+import javafx.geometry.Insets;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.Priority;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Window;\n+import com.oracle.demo.richtext.util.FX;\n+\n+\/**\n+ * CSS Tool\n+ *\/\n+public class CssToolPane extends BorderPane {\n+    private final TextArea cssField;\n+    private static String oldStylesheet;\n+\n+    public CssToolPane() {\n+        cssField = new TextArea();\n+        cssField.setId(\"CssPlaygroundPaneCss\");\n+        cssField.setMaxWidth(Double.POSITIVE_INFINITY);\n+        cssField.setMaxHeight(Double.POSITIVE_INFINITY);\n+\n+        Button updateButton = FX.button(\"Update\", this::update);\n+\n+        \/\/ why can't I fill the width of the container with this grid pane??\n+        GridPane p = new GridPane();\n+        p.setPadding(new Insets(10));\n+        p.setHgap(5);\n+        p.setVgap(5);\n+        int r = 0;\n+        p.add(new Label(\"Custom CSS:\"), 0, r);\n+        r++;\n+        p.add(cssField, 0, r, 3, 1);\n+        r++;\n+        p.add(updateButton, 2, r);\n+        GridPane.setHgrow(cssField, Priority.ALWAYS);\n+        GridPane.setVgrow(cssField, Priority.ALWAYS);\n+\n+        setCenter(p);\n+    }\n+\n+    private void update() {\n+        String css = cssField.getText();\n+        applyStyleSheet(css);\n+    }\n+\n+    private static String toCssColor(Color c) {\n+        int r = toInt8(c.getRed());\n+        int g = toInt8(c.getGreen());\n+        int b = toInt8(c.getBlue());\n+        return String.format(\"#%02X%02X%02X\", r, g, b);\n+    }\n+\n+    private static int toInt8(double x) {\n+        int v = (int)Math.round(x * 255);\n+        if (v < 0) {\n+            return 0;\n+        } else if (v > 255) {\n+            return 255;\n+        }\n+        return v;\n+    }\n+\n+    private static String encode(String s) {\n+        if (s == null) {\n+            return null;\n+        }\n+        Charset utf8 = Charset.forName(\"utf-8\");\n+        byte[] b = s.getBytes(utf8);\n+        return \"data:text\/css;base64,\" + Base64.getEncoder().encodeToString(b);\n+    }\n+\n+    private static void applyStyleSheet(String styleSheet) {\n+        String ss = encode(styleSheet);\n+        if (ss != null) {\n+            for (Window w : Window.getWindows()) {\n+                Scene scene = w.getScene();\n+                if (scene != null) {\n+                    ObservableList<String> sheets = scene.getStylesheets();\n+                    if (oldStylesheet != null) {\n+                        sheets.remove(oldStylesheet);\n+                    }\n+                    sheets.add(ss);\n+                }\n+            }\n+        }\n+        oldStylesheet = ss;\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/CssToolPane.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import java.util.ArrayList;\n+\n+public class DataFrame {\n+    private String[] columns;\n+    private final ArrayList<String[]> rows = new ArrayList();\n+\n+    public DataFrame() {\n+    }\n+\n+    public static DataFrame parse(String[] lines) {\n+        DataFrame f = new DataFrame();\n+        for (int i = 0; i < lines.length; i++) {\n+            String line = lines[i];\n+            String[] ss = line.split(\"\\\\|\");\n+            if (i == 0) {\n+                f.setColumns(ss);\n+            } else {\n+                f.addValues(ss);\n+            }\n+        }\n+        return f;\n+    }\n+\n+    public String[] getColumnNames() {\n+        return columns;\n+    }\n+\n+    public void setColumns(String[] columns) {\n+        this.columns = columns;\n+    }\n+\n+    public void addValues(String[] ss) {\n+        rows.add(ss);\n+    }\n+\n+    public int getRowCount() {\n+        return rows.size();\n+    }\n+\n+    public String[] getRow(int ix) {\n+        return rows.get(ix);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/DataFrame.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import javafx.scene.Node;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.BackgroundFill;\n+import javafx.scene.layout.Region;\n+import javafx.scene.paint.Color;\n+import jfx.incubator.scene.control.richtext.SideDecorator;\n+\n+public class DemoColorSideDecorator implements SideDecorator {\n+    public DemoColorSideDecorator() {\n+    }\n+\n+    @Override\n+    public double getPrefWidth(double viewWidth) {\n+        return 20.0;\n+    }\n+\n+    @Override\n+    public Node getNode(int modelIndex, boolean forMeasurement) {\n+        int num = 36;\n+        double a = 360.0 * (modelIndex % num) \/ num;\n+        Color c = Color.hsb(a, 0.5, 1.0);\n+\n+        Region r = new Region();\n+        r.setOpacity(1.0);\n+        r.setBackground(new Background(new BackgroundFill(c, null, null)));\n+        return r;\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/DemoColorSideDecorator.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+import java.util.Arrays;\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.TextField;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.Region;\n+import javafx.scene.paint.Color;\n+import jfx.incubator.scene.control.richtext.model.RichTextFormatHandler;\n+import jfx.incubator.scene.control.richtext.model.SimpleViewOnlyStyledModel;\n+\n+\/**\n+ * RichTextArea demo model.\n+ *\/\n+public class DemoModel extends SimpleViewOnlyStyledModel {\n+    private final SimpleStringProperty textField = new SimpleStringProperty();\n+\n+    public DemoModel() {\n+        \/\/ see RichTextAreaDemo.css\n+        String ARABIC = \"arabic\";\n+        String CODE = \"code\";\n+        String RED = \"red\";\n+        String GREEN = \"green\";\n+        String GRAY = \"gray\";\n+        String LARGE = \"large\";\n+        String BOLD = \"bold\";\n+        String ITALIC = \"italic\";\n+        String STRIKETHROUGH = \"strikethrough\";\n+        String UNDERLINE = \"underline\";\n+\n+        withInlineAndExternalStyles(\"RichTextArea Control\", \"-fx-font-size:200%;\", UNDERLINE);\n+        nl(2);\n+\n+\/\/        addParagraph(() -> {\n+\/\/            Region r = new Region();\n+\/\/            r.getchi\n+\/\/            r.setw 300, 50);\n+\/\/            r.setFill(Color.RED);\n+\/\/            return r;\n+\/\/        });\n+\n+        withStyles(\"\/**\", RED, CODE);\n+        nl();\n+        withStyles(\" * Syntax Highlight Demo.\", RED, CODE);\n+        nl();\n+        withStyles(\" *\/\", RED, CODE);\n+        nl();\n+        withStyles(\"public class \", GREEN, CODE);\n+        withStyles(\"SyntaxHighlightDemo \", CODE);\n+        withStyles(\"extends \", GREEN, CODE);\n+        withStyles(\"Application {\", CODE);\n+        nl();\n+        withStyles(\"\\tpublic static void\", GREEN, CODE);\n+        withStyles(\" main(String[] args) {\", CODE);\n+        nl();\n+        withStyles(\"\\t\\tApplication.launch(SyntaxHighlightDemo.\", CODE);\n+        withStyles(\"class\", CODE, GREEN);\n+        withStyles(\", args);\", CODE);\n+        nl();\n+        withStyles(\"\\t}\", CODE);\n+        nl();\n+        withStyles(\"}\", CODE);\n+        nl(2);\n+        \/\/ font attributes\n+        withStyles(\"BOLD \", BOLD);\n+        withStyles(\"ITALIC \", ITALIC);\n+        withStyles(\"STRIKETHROUGH \", STRIKETHROUGH);\n+        withStyles(\"UNDERLINE \", UNDERLINE);\n+        withStyles(\"ALL OF THEM \", BOLD, ITALIC, STRIKETHROUGH, UNDERLINE);\n+        nl(2);\n+        \/\/ inline nodes\n+        addSegment(\"Inline Nodes: \");\n+        addNodeSegment(() -> {\n+            TextField f = new TextField();\n+            f.setPrefColumnCount(20);\n+            f.textProperty().bindBidirectional(textField);\n+            return f;\n+        });\n+        addSegment(\" \");\n+        addNodeSegment(() -> new Button(\"OK\"));\n+        addSegment(\" \"); \/\/ FIX cannot navigate over this segment\n+        nl(2);\n+        withStyles(\"A regular Arabic verb, كَتَبَ‎ kataba (to write).\", ARABIC).nl();\n+        withStyles(\"Emojis: [🔥🦋😀😃😄😁😆😅🤣😂🙂🙃😉😊😇]\", LARGE).nl();\n+        nl();\n+        withStyles(\"Halfwidth and FullWidth Forms\", UNDERLINE).nl();\n+        withInlineStyle(\"ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯ\", \"-fx-font-family:monospaced;\").nl();\n+        withInlineStyle(\"ABCDEFGHIJKLMNO\", \"-fx-font-family:monospaced;\").nl();\n+        withStyles(\"        leading and trailing whitespace         \", CODE).nl();\n+        nl(3);\n+        withStyles(\"Behold various types of highlights, including overlapping highlights.\", LARGE);\n+        highlight(7, 7, Color.rgb(255, 255, 128, 0.7));\n+        squiggly(36, 100, Color.RED);\n+        highlight(46, 11, Color.rgb(255, 255, 128, 0.7));\n+        highlight(50, 20, Color.rgb(0, 0, 128, 0.1));\n+        nl(2);\n+        addSegment(\"Behold various types of highlights, including overlapping highlights.\");\n+        highlight(7, 7, Color.rgb(255, 255, 128, 0.7));\n+        squiggly(36, 100, Color.RED);\n+        highlight(46, 11, Color.rgb(255, 255, 128, 0.7));\n+        highlight(50, 20, Color.rgb(0, 0, 128, 0.1));\n+        nl(2);\n+\n+        \/\/ FIX adding a control messes up the view with text wrap off\n+\/\/        addParagraph(() -> {\n+\/\/            TextField t = new TextField(\"yo\");\n+\/\/            t.setMaxWidth(100);\n+\/\/            return t;\n+\/\/        });\n+\/\/        nl(2);\n+\n+        addParagraph(this::createRect);\n+        nl(2);\n+\n+        ParagraphAttributesDemoModel.insert(this);\n+\n+        addImage(DemoModel.class.getResourceAsStream(\"animated.gif\"));\n+        withStyles(\"  Fig. 1 Embedded animated GIF image.\", GRAY, ITALIC);\n+        nl(2);\n+\n+        \/*\n+        Random r = new Random();\n+        for(int line=0; line<100; line++) {\n+            int ct = r.nextInt(10);\n+            for (int word = 0; word < ct; word++) {\n+                int len = 1 + r.nextInt(7);\n+                char c = '*';\n+\n+                if (word == 0) {\n+                    addSegment(\"L\" + (size() + 1), null, GRAY);\n+                }\n+\n+                addSegment(\" \");\n+\n+                if (r.nextFloat() < 0.1) {\n+                    addSegment(word + \".\" + word(c, len), null, RED);\n+                } else {\n+                    addSegment(word + \".\" + word(c, len));\n+                }\n+            }\n+            nl();\n+        }\n+        *\/\n+\n+        nl();\n+        withInlineStyle(\"\\t\\t終 The End.\", \"-fx-font-size:200%;\");\n+        nl();\n+\n+        registerDataFormatHandler(RichTextFormatHandler.INSTANCE, true, false, 2000);\n+    }\n+\n+    private Region createRect() {\n+        Label t = new Label() {\n+            @Override\n+            protected double computePrefHeight(double w) {\n+                return 400;\n+            }\n+        };\n+        t.setPrefSize(400, 200);\n+        t.setMaxWidth(400);\n+        t.textProperty().bind(Bindings.createObjectBinding(\n+            () -> {\n+                return String.format(\"%.1f x %.1f\", t.getWidth(), t.getHeight());\n+            },\n+            t.widthProperty(),\n+            t.heightProperty()\n+        ));\n+        t.setBackground(Background.fill(Color.LIGHTGRAY));\n+\n+        BorderPane p = new BorderPane();\n+        p.setLeft(t);\n+        return p;\n+    }\n+\n+    private String word(char c, int len) {\n+        char[] cs = new char[len];\n+        Arrays.fill(cs, c);\n+        return new String(cs);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/DemoModel.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import java.text.DecimalFormat;\n+import javafx.scene.Node;\n+import javafx.scene.text.Text;\n+import javafx.scene.text.TextFlow;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.RichParagraph;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModelViewOnlyBase;\n+\n+\/**\n+ * Demo StyledTextModel.\n+ * Does not support editing events - populate the model first, then pass it to the control.\n+ *\/\n+public class DemoStyledTextModel extends StyledTextModelViewOnlyBase {\n+    private final int size;\n+    private final boolean monospaced;\n+    private static final DecimalFormat format = new DecimalFormat(\"#,##0\");\n+\n+    public DemoStyledTextModel(int size, boolean monospaced) {\n+        this.size = size;\n+        this.monospaced = monospaced;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return size;\n+    }\n+\n+    @Override\n+    public StyleAttributeMap getStyleAttributeMap(StyleResolver resolver, TextPos pos) {\n+        return StyleAttributeMap.EMPTY;\n+    }\n+\n+    @Override\n+    public String getPlainText(int index) {\n+        RichParagraph p = getParagraph(index);\n+        return p.getPlainText();\n+    }\n+\n+    private static String getText(TextFlow f) {\n+        StringBuilder sb = new StringBuilder();\n+        for (Node n : f.getChildrenUnmodifiable()) {\n+            if (n instanceof Text t) {\n+                sb.append(t.getText());\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public RichParagraph getParagraph(int ix) {\n+        RichParagraph.Builder b = RichParagraph.builder();\n+        String s = format.format(ix + 1);\n+        String sz = format.format(size);\n+        String[] css = monospaced ? new String[] { \"monospaced\" } : new String[0];\n+\n+        b.withInlineAndExternalStyles(s, \"-fx-fill:darkgreen;\", css);\n+        b.withStyles(\" \/ \", css);\n+        b.withInlineAndExternalStyles(sz, \"-fx-fill:black;\", css);\n+        if (monospaced) {\n+            b.withStyles(\" (monospaced)\", css);\n+        }\n+\n+        if ((ix % 10) == 9) {\n+            String words = generateWords(ix);\n+            b.withStyles(words, css);\n+        }\n+        return b.build();\n+    }\n+\n+    private String generateWords(int ix) {\n+        String s = String.valueOf(ix);\n+        StringBuilder sb = new StringBuilder(128);\n+        for (char c: s.toCharArray()) {\n+            String digit = getDigit(c);\n+            sb.append(digit);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private String getDigit(char c) {\n+        switch (c) {\n+        case '0':\n+            return \" zero\";\n+        case '1':\n+            return \" one\";\n+        case '2':\n+            return \" two\";\n+        case '3':\n+            return \" three\";\n+        case '4':\n+            return \" four\";\n+        case '5':\n+            return \" five\";\n+        case '6':\n+            return \" six\";\n+        case '7':\n+            return \" seven\";\n+        case '8':\n+            return \" eight\";\n+        default:\n+            return \" nine\";\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/DemoStyledTextModel.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.rta;\n+\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.scene.control.TextField;\n+import javafx.scene.paint.Color;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.RichParagraph;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModelViewOnlyBase;\n+\n+\/** This model contains code examples used in the documentation. *\/\n+public class ExamplesModel extends StyledTextModelViewOnlyBase {\n+    \/** properties in the model allow for inline controls *\/\n+    private final SimpleStringProperty exampleProperty = new SimpleStringProperty();\n+\n+    public ExamplesModel() {\n+    }\n+\n+    @Override\n+    public int size() {\n+        return 10;\n+    }\n+\n+    @Override\n+    public String getPlainText(int index) {\n+        return getParagraph(index).getPlainText();\n+    }\n+\n+    @Override\n+    public StyleAttributeMap getStyleAttributeMap(StyleResolver resolver, TextPos pos) {\n+        return null;\n+    }\n+\n+    @Override\n+    public RichParagraph getParagraph(int index) {\n+        switch(index) {\n+        case 0:\n+            {\n+                StyleAttributeMap a1 = StyleAttributeMap.builder().setBold(true).build();\n+                RichParagraph.Builder b = RichParagraph.builder();\n+                b.addSegment(\"Example: \", a1);\n+                b.addSegment(\"spelling, highlights\");\n+                b.addSquiggly(9, 8, Color.RED);\n+                b.addHighlight(19, 4, Color.rgb(255, 128, 128, 0.5));\n+                b.addHighlight(20, 7, Color.rgb(128, 255, 128, 0.5));\n+                return b.build();\n+            }\n+        case 4:\n+            {\n+                RichParagraph.Builder b = RichParagraph.builder();\n+                b.addSegment(\"Input field: \");\n+                \/\/ creates an embedded control bound to a property within this model\n+                b.addInlineNode(() -> {\n+                   TextField t = new TextField();\n+                   t.textProperty().bindBidirectional(exampleProperty);\n+                   return t;\n+                });\n+                return b.build();\n+            }\n+        }\n+        return RichParagraph.builder().build();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/ExamplesModel.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.geometry.Insets;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.Priority;\n+import javafx.scene.text.Font;\n+import com.oracle.demo.richtext.util.FX;\n+\n+\/**\n+ * Font Option Bound to a Property.\n+ *\/\n+public class FontOption extends HBox {\n+    private final SimpleObjectProperty<Font> property = new SimpleObjectProperty<>();\n+    private final ComboBox<String> fontField = new ComboBox<>();\n+    private final ComboBox<String> styleField = new ComboBox<>();\n+    private final ComboBox<Double> sizeField = new ComboBox<>();\n+\n+    public FontOption(String name, boolean allowNull, ObjectProperty<Font> p) {\n+        FX.name(this, name);\n+        if (p != null) {\n+            property.bindBidirectional(p);\n+        }\n+\n+        FX.name(fontField, name + \"_FONT\");\n+        fontField.getItems().setAll(collectFonts(allowNull));\n+        fontField.getSelectionModel().selectedItemProperty().addListener((x) -> {\n+            String fam = fontField.getSelectionModel().getSelectedItem();\n+            updateStyles(fam);\n+            update();\n+        });\n+\n+        FX.name(styleField, name + \"_STYLE\");\n+        styleField.getSelectionModel().selectedItemProperty().addListener((x) -> {\n+            update();\n+        });\n+\n+        FX.name(sizeField, name + \"_SIZE\");\n+        sizeField.getItems().setAll(\n+            1.0,\n+            2.5,\n+            6.0,\n+            8.0,\n+            10.0,\n+            11.0,\n+            12.0,\n+            16.0,\n+            24.0,\n+            32.0,\n+            48.0,\n+            72.0,\n+            144.0,\n+            480.0\n+        );\n+        sizeField.getSelectionModel().selectedItemProperty().addListener((x) -> {\n+            update();\n+        });\n+\n+        getChildren().setAll(fontField, styleField, sizeField);\n+        setHgrow(fontField, Priority.ALWAYS);\n+        setMargin(sizeField, new Insets(0, 0, 0, 2));\n+\n+        setFont(property.get());\n+    }\n+\n+    public SimpleObjectProperty<Font> getProperty() {\n+        return property;\n+    }\n+\n+    public void select(String name) {\n+        fontField.getSelectionModel().select(name);\n+    }\n+\n+    public Font getFont() {\n+        String name = fontField.getSelectionModel().getSelectedItem();\n+        if (name == null) {\n+            return null;\n+        }\n+        String style = styleField.getSelectionModel().getSelectedItem();\n+        if (!isBlank(style)) {\n+            name = name + \" \" + style;\n+        }\n+        Double size = sizeField.getSelectionModel().getSelectedItem();\n+        if (size == null) {\n+            size = 12.0;\n+        }\n+        return new Font(name, size);\n+    }\n+\n+    private static boolean isBlank(String s) {\n+        return s == null ? true : s.trim().length() == 0;\n+    }\n+\n+    protected void updateStyles(String family) {\n+        String st = styleField.getSelectionModel().getSelectedItem();\n+        if (st == null) {\n+            st = \"\";\n+        }\n+\n+        List<String> ss = Font.getFontNames(family);\n+        for (int i = 0; i < ss.size(); i++) {\n+            String s = ss.get(i);\n+            if (s.startsWith(family)) {\n+                s = s.substring(family.length()).trim();\n+                ss.set(i, s);\n+            }\n+        }\n+        Collections.sort(ss);\n+\n+        styleField.getItems().setAll(ss);\n+        int ix = ss.indexOf(st);\n+        if (ix >= 0) {\n+            styleField.getSelectionModel().select(ix);\n+        }\n+    }\n+\n+    protected void update() {\n+        Font f = getFont();\n+        property.set(f);\n+    }\n+\n+    private void setFont(Font f) {\n+        String name;\n+        String style;\n+        double size;\n+        if (f == null) {\n+            name = null;\n+            style = null;\n+            size = 12.0;\n+        } else {\n+            name = f.getFamily();\n+            style = f.getStyle();\n+            size = f.getSize();\n+        }\n+        fontField.getSelectionModel().select(name);\n+        styleField.getSelectionModel().select(style);\n+        sizeField.getSelectionModel().select(size);\n+    }\n+\n+    protected List<String> collectFonts(boolean allowNull) {\n+        ArrayList<String> rv = new ArrayList<>();\n+        if (allowNull) {\n+            rv.add(null);\n+        }\n+        rv.addAll(Font.getFamilies());\n+        return rv;\n+    }\n+\n+    public void selectSystemFont() {\n+        FX.select(fontField, \"System\");\n+        FX.select(styleField, \"\");\n+        FX.select(sizeField, 12.0);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/FontOption.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.TextField;\n+import jfx.incubator.scene.control.richtext.model.SimpleViewOnlyStyledModel;\n+\n+\/**\n+ * A demo model with inline Nodes.\n+ *\/\n+public class InlineNodesModel extends SimpleViewOnlyStyledModel {\n+    private final SimpleStringProperty textField = new SimpleStringProperty();\n+\n+    public InlineNodesModel() {\n+        String ARABIC = \"arabic\";\n+        String CODE = \"code\";\n+        String RED = \"red\";\n+        String GREEN = \"green\";\n+        String UNDER = \"underline\";\n+        String GRAY = \"gray\";\n+        String LARGE = \"large\";\n+        String ITALIC = \"italic\";\n+\n+        withStyles(\"Inline Nodes\", UNDER, LARGE);\n+        nl();\n+        \/\/ trailing text\n+        addNodeSegment(() -> {\n+            TextField f = new TextField();\n+            f.setPrefColumnCount(20);\n+            f.textProperty().bindBidirectional(textField);\n+            return f;\n+        });\n+        withStyles(\" \", LARGE);\n+        addNodeSegment(() -> new Button(\"OK\"));\n+        withStyles(\" trailing segment.\", LARGE); \/\/ FIX cannot navigate over this segment\n+        nl();\n+\n+        \/\/ leading text\n+        withStyles(\"Leading text\", LARGE);\n+        addNodeSegment(() -> {\n+            TextField f = new TextField();\n+            f.setPrefColumnCount(20);\n+            f.textProperty().bindBidirectional(textField);\n+            return f;\n+        });\n+        withStyles(\"- in between text-\", LARGE);\n+        addNodeSegment(() -> new Button(\"Find\"));\n+        nl();\n+\n+        \/\/ leading and trailing text\n+        withStyles(\"Leading text\", LARGE);\n+        addNodeSegment(() -> {\n+            TextField f = new TextField();\n+            f.setPrefColumnCount(20);\n+            f.textProperty().bindBidirectional(textField);\n+            return f;\n+        });\n+        withStyles(\"- in between text-\", LARGE);\n+        addNodeSegment(() -> new Button(\"Find\"));\n+        withStyles(\" trailing segment.\", LARGE);\n+        nl();\n+\n+        \/\/ adjacent nodes\n+        addNodeSegment(() -> new Button(\"One\"));\n+        addNodeSegment(() -> new Button(\"Two\"));\n+        addNodeSegment(() -> new Button(\"Three\"));\n+        addNodeSegment(() -> new Button(\"Four\"));\n+        addNodeSegment(() -> new Button(\"Five\"));\n+        nl();\n+        withStyles(\"\", LARGE);\n+        nl();\n+\n+        withStyles(\"A regular text segment for reference.\", LARGE);\n+        nl();\n+        withStyles(\"The End █\", LARGE);\n+        nl();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/InlineNodesModel.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import java.util.Random;\n+import jfx.incubator.scene.control.richtext.model.SimpleViewOnlyStyledModel;\n+\n+public class LargeTextModel extends SimpleViewOnlyStyledModel {\n+    private final String STYLE = \"-fx-font-size:500%\";\n+    private final Random random = new Random();\n+\n+    public LargeTextModel(int lineCount) {\n+        for (int i = 0; i < lineCount; i++) {\n+            addLine(i);\n+        }\n+    }\n+\n+    private void addLine(int n) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"L\").append(n).append(' ');\n+        int ct;\n+        if (random.nextFloat() < 0.01f) {\n+            ct = 200;\n+        } else {\n+            ct = random.nextInt(10);\n+        }\n+\n+        for (int i = 0; i < ct; i++) {\n+            sb.append(\" \").append(i);\n+            int len = random.nextInt(10) + 1;\n+            for (int j = 0; j < len; j++) {\n+                sb.append('*');\n+            }\n+        }\n+        withStyles(sb.toString(), STYLE);\n+        nl();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/LargeTextModel.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import java.io.IOException;\n+import javafx.scene.paint.Color;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.BasicTextModel;\n+import jfx.incubator.scene.control.richtext.model.RichParagraph;\n+import jfx.incubator.scene.control.richtext.model.RichTextModel;\n+import jfx.incubator.scene.control.richtext.model.SimpleViewOnlyStyledModel;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledInput;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+\n+public enum ModelChoice {\n+    DEMO(\"Demo\"),\n+    PARAGRAPH(\"Paragraph Attributes\"),\n+    WRITING_SYSTEMS_EDITABLE(\"Writing Systems (Editable)\"),\n+    EDITABLE_STYLED(\"❤ Editable Rich Text Model\"),\n+    BILLION_LINES(\"2,000,000,000 Lines\"),\n+    NOTEBOOK(\"Notebook: Embedded Chart\"),\n+    NOTEBOOK2(\"Notebook: SQL Queries\"),\n+    EDITABLE_PLAIN(\"Plaintext with Syntax Highlighting\"),\n+    NULL(\"null\"),\n+    EXAMPLES(\"Examples\"),\n+    INLINE(\"Inline Nodes\"),\n+    MONOSPACED(\"Monospaced\"),\n+    TABS(\"Tabs\"),\n+    UNEVEN_SMALL(\"Uneven Small\"),\n+    UNEVEN_LARGE(\"Uneven Large\"),\n+    WRITING_SYSTEMS(\"Writing Systems\"),\n+    ZERO_LINES(\"0 Lines\"),\n+    ONE_LINE(\"1 Line\"),\n+    TEN_LINES(\"10 Lines\"),\n+    THOUSAND_LINES(\"1,000 Lines\"),\n+    LARGE_TEXT(\"Large text\"),\n+    LARGE_TEXT_LONG(\"Large Text, Long\"),\n+    NO_LAST_NEWLINE_SHORT(\"No Last Newline, Short\"),\n+    NO_LAST_NEWLINE_MEDIUM(\"No Last Newline, Medium\"),\n+    NO_LAST_NEWLINE_LONG(\"No Last Newline, Long\"),\n+    ;\n+\n+    private final String name;\n+\n+    ModelChoice(String name) {\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    public static StyledTextModel create(ModelChoice ch) {\n+        if(ch == null) {\n+            return null;\n+        }\n+\n+        switch(ch) {\n+        case BILLION_LINES:\n+            return new DemoStyledTextModel(2_000_000_000, false);\n+        case DEMO:\n+            return new DemoModel();\n+        case EXAMPLES:\n+            return new ExamplesModel();\n+        case INLINE:\n+            return new InlineNodesModel();\n+        case EDITABLE_PLAIN:\n+            {\n+                BasicTextModel m = new BasicTextModel() {\n+                    private static final String DIGITS = \"-fx-fill:magenta;\";\n+\n+                    @Override\n+                    public RichParagraph getParagraph(int index) {\n+                        String text = getPlainText(index);\n+                        RichParagraph.Builder b = RichParagraph.builder();\n+                        int start = 0;\n+                        int sz = text.length();\n+                        boolean num = false;\n+                        for (int i = 0; i < sz; i++) {\n+                            char c = text.charAt(i);\n+                            if (num != Character.isDigit(c)) {\n+                                if (i > start) {\n+                                    String s = text.substring(start, i);\n+                                    String style = num ? DIGITS : null;\n+                                    b.withInlineStyle(s, style);\n+                                    start = i;\n+                                }\n+                                num = !num;\n+                            }\n+                        }\n+                        if (start < sz) {\n+                            String s = text.substring(start);\n+                            String style = num ? DIGITS : null;\n+                            b.withInlineStyle(s, style);\n+                        }\n+                        return b.build();\n+                    }\n+                };\n+                return m;\n+            }\n+        case EDITABLE_STYLED:\n+            return new RichTextModel();\n+        case LARGE_TEXT:\n+            return new LargeTextModel(10);\n+        case LARGE_TEXT_LONG:\n+            return new LargeTextModel(5_000);\n+        case NO_LAST_NEWLINE_SHORT:\n+            return new NoLastNewlineModel(1);\n+        case NO_LAST_NEWLINE_MEDIUM:\n+            return new NoLastNewlineModel(5);\n+        case NO_LAST_NEWLINE_LONG:\n+            return new NoLastNewlineModel(300);\n+        case MONOSPACED:\n+            return new DemoStyledTextModel(2_000_000_000, true);\n+        case NOTEBOOK:\n+            return new NotebookModel();\n+        case NOTEBOOK2:\n+            return new NotebookModel2();\n+        case NULL:\n+            return null;\n+        case ONE_LINE:\n+            return new DemoStyledTextModel(1, false);\n+        case PARAGRAPH:\n+            return new ParagraphAttributesDemoModel();\n+        case TABS:\n+            return tabs();\n+        case TEN_LINES:\n+            return new DemoStyledTextModel(10, false);\n+        case THOUSAND_LINES:\n+            return new DemoStyledTextModel(1_000, false);\n+        case UNEVEN_SMALL:\n+            return new UnevenStyledTextModel(20);\n+        case UNEVEN_LARGE:\n+            return new UnevenStyledTextModel(2000);\n+        case WRITING_SYSTEMS:\n+            return writingSystemsPlain();\n+        case WRITING_SYSTEMS_EDITABLE:\n+            return writingSystems();\n+        case ZERO_LINES:\n+            return new DemoStyledTextModel(0, false);\n+        default:\n+            throw new Error(\"?\" + ch);\n+        }\n+    }\n+\n+    private static StyledTextModel writingSystemsPlain() {\n+        try {\n+            return SimpleViewOnlyStyledModel.from(WritingSystemsDemo.getText());\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    private static StyledTextModel tabs() {\n+        try {\n+            return SimpleViewOnlyStyledModel.from(\"0123456789012345678901234567890\\n0\\n\\t1\\n\\t\\t2\\n\\t\\t\\t3\\n\\t\\t\\t\\t4\\n0\\n\");\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    private static StyledTextModel writingSystems() {\n+        StyleAttributeMap name = StyleAttributeMap.builder().\n+            setFontSize(24).\n+            setTextColor(Color.gray(0.5)).\n+            build();\n+\n+        StyleAttributeMap value = StyleAttributeMap.builder().\n+            setFontSize(24).\n+            build();\n+\n+        RichTextModel m = new RichTextModel();\n+        String[] ss = WritingSystemsDemo.PAIRS;\n+        for (int i = 0; i < ss.length;) {\n+            String s = ss[i++] + \":  \";\n+            append(m, s, name);\n+\n+            s = ss[i++];\n+            append(m, s, value);\n+\n+            append(m, \"\\n\", null);\n+        }\n+        return m;\n+    }\n+\n+    \/\/ TODO add to StyledModel?\n+    private static void append(StyledTextModel m, String text, StyleAttributeMap style) {\n+        TextPos p = m.getDocumentEnd();\n+        m.replace(null, p, p, StyledInput.of(text, style), false);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/ModelChoice.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.rta;\n+\n+import javafx.geometry.Insets;\n+import javafx.scene.Scene;\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Menu;\n+import javafx.scene.control.ScrollPane;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.VBox;\n+import javafx.stage.Stage;\n+import com.oracle.demo.richtext.util.FX;\n+import jfx.incubator.scene.control.richtext.LineNumberDecorator;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+\n+\/**\n+ * Test Window that stacks multiple RichTextAreas and other components either vertically or horizontally.\n+ *\/\n+public class MultipleStackedBoxWindow extends Stage {\n+\n+    public MultipleStackedBoxWindow(boolean vertical) {\n+        RichTextArea a1 = new RichTextArea(NotebookModelStacked.m1());\n+        a1.setHighlightCurrentParagraph(true);\n+        a1.setWrapText(true);\n+        a1.setLeftDecorator(new LineNumberDecorator());\n+        createPopupMenu(a1);\n+\n+        TextArea t1 = new TextArea(\"This TextArea has wrap text property set to false.\");\n+        t1.setPrefHeight(50);\n+\n+        Label t2 = new Label(\"Label\");\n+\n+        RichTextArea a2 = new RichTextArea(NotebookModelStacked.m2());\n+        a2.setHighlightCurrentParagraph(true);\n+        a2.setWrapText(true);\n+        a2.setLeftDecorator(new LineNumberDecorator());\n+        createPopupMenu(a2);\n+\n+        PrefSizeTester tester = new PrefSizeTester();\n+\n+        ScrollPane sp = new ScrollPane();\n+\n+        if (vertical) {\n+            a1.setUseContentHeight(true);\n+            a2.setUseContentHeight(true);\n+\n+            VBox vb = new VBox(\n+                a1,\n+                t1,\n+                a2,\n+                t2,\n+                tester\n+            );\n+            sp.setContent(vb);\n+            sp.setFitToWidth(true);\n+\n+            setTitle(\"Test Vertical Stack\");\n+            setWidth(600);\n+            setHeight(1200);\n+            FX.name(this, \"VerticalStack\");\n+        } else {\n+            a1.setUseContentWidth(true);\n+            a2.setUseContentWidth(true);\n+\n+            HBox hb = new HBox(\n+                a1,\n+                t1,\n+                a2,\n+                t2,\n+                tester\n+            );\n+            sp.setContent(hb);\n+            sp.setFitToHeight(true);\n+\n+            setTitle(\"Test Horizontal Stack\");\n+            setWidth(1200);\n+            setHeight(600);\n+            FX.name(this, \"HorizontalStack\");\n+        }\n+\n+        Scene scene = new Scene(sp);\n+        scene.getStylesheets().addAll(\n+            RichTextAreaWindow.class.getResource(\"RichTextAreaDemo.css\").toExternalForm()\n+        );\n+        setScene(scene);\n+    }\n+\n+    protected void createPopupMenu(RichTextArea t) {\n+        FX.setPopupMenu(t, () -> {\n+            Menu m;\n+            ContextMenu c = new ContextMenu();\n+            \/\/ left side\n+            m = FX.menu(c, \"Left Side\");\n+            FX.checkItem(m, \"null\", t.getLeftDecorator() == null, (on) -> {\n+                if (on) {\n+                    t.setLeftDecorator(null);\n+                }\n+            });\n+            FX.checkItem(m, \"Line Numbers\", t.getLeftDecorator() instanceof LineNumberDecorator, (on) -> {\n+                if (on) {\n+                    t.setLeftDecorator(new LineNumberDecorator());\n+                }\n+            });\n+            FX.checkItem(m, \"Colors\", t.getLeftDecorator() instanceof DemoColorSideDecorator, (on) -> {\n+                if (on) {\n+                    t.setLeftDecorator(new DemoColorSideDecorator());\n+                }\n+            });\n+            \/\/ right side\n+            m = FX.menu(c, \"Right Side\");\n+            FX.checkItem(m, \"null\", t.getRightDecorator() == null, (on) -> {\n+                if (on) {\n+                    t.setRightDecorator(null);\n+                }\n+            });\n+            FX.checkItem(m, \"Line Numbers\", t.getRightDecorator() instanceof LineNumberDecorator, (on) -> {\n+                if (on) {\n+                    t.setRightDecorator(new LineNumberDecorator());\n+                }\n+            });\n+            FX.checkItem(m, \"Colors\", t.getRightDecorator() instanceof DemoColorSideDecorator, (on) -> {\n+                if (on) {\n+                    t.setRightDecorator(new DemoColorSideDecorator());\n+                }\n+            });\n+            \/\/ content padding\n+            m = FX.menu(c, \"Content Padding\");\n+            FX.checkItem(m, \"null\", t.getContentPadding() == null, (on) -> {\n+                if (on) {\n+                    t.setContentPadding(null);\n+                }\n+            });\n+            FX.checkItem(m, \"1\", new Insets(1).equals(t.getContentPadding()), (on) -> {\n+                if (on) {\n+                    t.setContentPadding(new Insets(1));\n+                }\n+            });\n+            FX.checkItem(m, \"2\", new Insets(1).equals(t.getContentPadding()), (on) -> {\n+                if (on) {\n+                    t.setContentPadding(new Insets(2));\n+                }\n+            });\n+            FX.checkItem(m, \"10\", new Insets(10).equals(t.getContentPadding()), (on) -> {\n+                if (on) {\n+                    t.setContentPadding(new Insets(10));\n+                }\n+            });\n+            FX.checkItem(m, \"55.75\", new Insets(55.75).equals(t.getContentPadding()), (on) -> {\n+                if (on) {\n+                    t.setContentPadding(new Insets(55.75));\n+                }\n+            });\n+\n+            FX.checkItem(c, \"Wrap Text\", t.isWrapText(), (on) -> t.setWrapText(on));\n+            return c;\n+        });\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/MultipleStackedBoxWindow.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import jfx.incubator.scene.control.richtext.model.SimpleViewOnlyStyledModel;\n+\n+public class NoLastNewlineModel extends SimpleViewOnlyStyledModel {\n+    public NoLastNewlineModel(int lineCount) {\n+        for(int i=0; i<lineCount; i++) {\n+            addSegment(\"L.\" + i);\n+            if(i != (lineCount - 1)) {\n+                nl();\n+            }\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/NoLastNewlineModel.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import jfx.incubator.scene.control.richtext.model.SimpleViewOnlyStyledModel;\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+public class NotebookModel extends SimpleViewOnlyStyledModel {\n+\n+    public static final StyleAttribute<Boolean> OUTLINE = new StyleAttribute<>(\"OUTLINE\", Boolean.class, true);\n+\n+    public NotebookModel() {\n+        String GREEN = \"green\";\n+        String GRAY = \"gray\";\n+        String EQ = \"equation\";\n+        String SUB = \"sub\";\n+        String UNDER = \"underline\";\n+\n+        withInlineAndExternalStyles(\"Bifurcation Diagram\", \"-fx-font-size:200%;\", UNDER);\n+        nl(2);\n+        withStyles(\"In mathematics, particularly in dynamical systems, a \", GRAY);\n+        withStyles(\"bifurcation diagram \", \"-fx-font-weight:bold;\"); \/\/ FIX does not work on mac\n+        withStyles(\"shows the values visited or approached asymptotically (fixed points, periodic orbits, or chaotic attractors) of a system as a function of a bifurcation parameter in the system. It is usual to represent stable values with a solid line and unstable values with a dotted line, although often the unstable points are omitted. Bifurcation diagrams enable the visualization of bifurcation theory.\", GRAY);\n+        nl(2);\n+        withStyles(\"An example is the bifurcation diagram of the logistic map:\", GRAY);\n+        nl(2);\n+        withStyles(\"   x\", EQ);\n+        withStyles(\"n+1\", EQ, SUB);\n+        withStyles(\" = λx\", EQ);\n+        withStyles(\"n\", EQ, SUB);\n+        withStyles(\"(1 - x\", EQ);\n+        withStyles(\"n\", EQ, SUB);\n+        withStyles(\")\", EQ);\n+        setParagraphAttributes(StyleAttributeMap.of(OUTLINE, Boolean.TRUE));\n+        nl(2);\n+        withStyles(\"The bifurcation parameter λ is shown on the horizontal axis of the plot and the vertical axis shows the set of values of the logistic function visited asymptotically from almost all initial conditions.\", GRAY);\n+        nl(2);\n+        withStyles(\"The bifurcation diagram shows the forking of the periods of stable orbits from 1 to 2 to 4 to 8 etc. Each of these bifurcation points is a period-doubling bifurcation. The ratio of the lengths of successive intervals between values of r for which bifurcation occurs converges to the first Feigenbaum constant.\", GRAY);\n+        nl(2);\n+        withStyles(\"The diagram also shows period doublings from 3 to 6 to 12 etc., from 5 to 10 to 20 etc., and so forth.\", GRAY);\n+        nl();\n+        addParagraph(BifurcationDiagram::generate);\n+        nl(2);\n+        addSegment(\"Source: Wikipedia\");\n+        nl();\n+        withStyles(\"https:\/\/en.wikipedia.org\/wiki\/Bifurcation_diagram\", GREEN, UNDER);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/NotebookModel.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.TextField;\n+import jfx.incubator.scene.control.richtext.model.SimpleViewOnlyStyledModel;\n+\n+\/**\n+ * Mocks a Notebook Page that Provides a SQL Query Engine Interface\n+ *\/\n+public class NotebookModel2 extends SimpleViewOnlyStyledModel {\n+    private final SimpleStringProperty query = new SimpleStringProperty();\n+    private final SimpleObjectProperty<Object> result = new SimpleObjectProperty<>();\n+    private static final String QUERY = \"SELECT * FROM Book WHERE price > 100.00;\";\n+\n+    public NotebookModel2() {\n+        String ARABIC = \"arabic\";\n+        String CODE = \"code\";\n+        String RED = \"red\";\n+        String GREEN = \"green\";\n+        String UNDER = \"underline\";\n+        String GRAY = \"gray\";\n+        String LARGE = \"large\";\n+        String EQ = \"equation\";\n+        String SUB = \"sub\";\n+\n+        withInlineAndExternalStyles(\"SQL Select\", \"-fx-font-size:200%;\", UNDER);\n+        nl(2);\n+        withStyles(\"The SQL \", GRAY);\n+        withInlineStyle(\"SELECT \", \"-fx-font-weight:bold;\"); \/\/ FIX does not work on mac\n+        withStyles(\"statement returns a result set of records, from one or more tables.\", GRAY);\n+        nl(2);\n+        withStyles(\"A SELECT statement retrieves zero or more rows from one or more database tables or database views. In most applications, SELECT is the most commonly used data manipulation language (DML) command. As SQL is a declarative programming language, SELECT queries specify a result set, but do not specify how to calculate it. The database translates the query into a \\\"query plan\\\" which may vary between executions, database versions and database software. This functionality is called the \\\"query optimizer\\\" as it is responsible for finding the best possible execution plan for the query, within applicable constraints.\", GRAY);\n+        nl(2);\n+        withInlineStyle(QUERY, \"-fx-font-weight:bold;\"); \/\/ FIX does not work on mac\n+        nl(2);\n+        addNodeSegment(() -> {\n+            TextField f = new TextField();\n+            f.setPrefColumnCount(50);\n+            f.textProperty().bindBidirectional(query);\n+            return f;\n+        });\n+        withStyles(\" \", GRAY);\n+        addNodeSegment(() -> {\n+            Button b = new Button(\"Run\");\n+            b.setOnAction((ev) -> execute());\n+            return b;\n+        });\n+        nl(2);\n+        withStyles(\"Result:\", GRAY);\n+        nl();\n+        addParagraph(() -> new ResultParagraph(result));\n+        nl(2);\n+        addSegment(\"Source: Wikipedia\");\n+        nl();\n+        withStyles(\"https:\/\/en.wikipedia.org\/wiki\/Select_(SQL)\", GREEN, UNDER);\n+    }\n+\n+    protected void execute() {\n+        String q = query.get();\n+        if (q == null) {\n+            q = \"\";\n+        }\n+        q = q.toLowerCase();\n+        if(q.equals(QUERY.toLowerCase())) {\n+            result.set(generate());\n+        } else {\n+            result.set(\"This query is not supported by the demo engine.\");\n+        }\n+    }\n+\n+    private String[] generate() {\n+        return new String[] {\n+            \"Title|Author|Price\",\n+            \"SQL Examples and Guide|J.Goodwell|145.55\",\n+            \"The Joy of SQL|M.C.Eichler|250.00\",\n+            \"An Introduction to SQL|Q.Adams|101.99\",\n+        };\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/NotebookModel2.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.rta;\n+\n+import java.util.ArrayList;\n+import java.util.function.Supplier;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.layout.Region;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.BasicTextModel;\n+import jfx.incubator.scene.control.richtext.model.RichParagraph;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+\n+public class NotebookModelStacked extends StyledTextModel {\n+    enum Type {\n+        CODE,\n+        COMMENT,\n+        TEXTAREA,\n+    }\n+\n+    private final ArrayList<Object> paragraphs = new ArrayList<>();\n+\n+    public NotebookModelStacked() {\n+        paragraphs.add(m1());\n+        paragraphs.add(Type.TEXTAREA);\n+        paragraphs.add(m2());\n+    }\n+\n+    public static StyledTextModel m1() {\n+        return create(Type.COMMENT, \"██This is\\na comment cell.██p\");\n+    }\n+\n+    public static StyledTextModel m2() {\n+        return create(Type.CODE, \"x = 5;\\nprint(x);\");\n+    }\n+\n+    public static StyledTextModel create(Type type, String text) {\n+        BasicTextModel m;\n+        switch(type) {\n+        case CODE:\n+            m = new BasicTextModel() {\n+                @Override\n+                public RichParagraph getParagraph(int index) {\n+                    String text = getPlainText(index);\n+                    RichParagraph.Builder b = RichParagraph.builder();\n+                    b.withInlineStyle(text, \"-fx-text-fill:darkgreen; -fx-font-family:Monospace;\");\n+                    return b.build();\n+                }\n+            };\n+            break;\n+        case COMMENT:\n+            m = new BasicTextModel() {\n+                @Override\n+                public RichParagraph getParagraph(int index) {\n+                    String text = getPlainText(index);\n+                    RichParagraph.Builder b = RichParagraph.builder();\n+                    b.withInlineStyle(text, \"-fx-text-fill:gray;\");\n+                    return b.build();\n+                }\n+            };\n+            break;\n+        default:\n+            throw new Error(\"?\" + type);\n+        }\n+\n+        m.insertText(TextPos.ZERO, text);\n+        return m;\n+    }\n+\n+    @Override\n+    public boolean isUserEditable() {\n+        return false;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return paragraphs.size();\n+    }\n+\n+    @Override\n+    public String getPlainText(int index) {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public RichParagraph getParagraph(int index) {\n+        Object x = paragraphs.get(index);\n+        if(x instanceof StyledTextModel m) {\n+            return RichParagraph.of(() -> {\n+                RichTextArea t = new RichTextArea(m);\n+                t.setHighlightCurrentParagraph(true);\n+                t.setMaxWidth(Double.POSITIVE_INFINITY);\n+                t.setWrapText(true);\n+                t.setUseContentHeight(true);\n+                return t;\n+            });\n+        } else if(x instanceof Type type) {\n+            switch(type) {\n+            case TEXTAREA:\n+                return RichParagraph.of(() -> {\n+                    TextArea t = new TextArea();\n+                    t.setMaxWidth(Double.POSITIVE_INFINITY);\n+                    t.setWrapText(true);\n+                    return t;\n+                });\n+            }\n+        }\n+        throw new Error(\"?\" + x);\n+    }\n+\n+    @Override\n+    protected void removeRange(TextPos start, TextPos end) {\n+    }\n+\n+    @Override\n+    protected int insertTextSegment(int index, int offset, String text, StyleAttributeMap attrs) {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected void insertLineBreak(int index, int offset) {\n+    }\n+\n+    @Override\n+    protected void insertParagraph(int index, Supplier<Region> generator) {\n+    }\n+\n+    @Override\n+    public StyleAttributeMap getStyleAttributeMap(StyleResolver r, TextPos pos) {\n+        return StyleAttributeMap.EMPTY;\n+    }\n+\n+    @Override\n+    protected void setParagraphStyle(int ix, StyleAttributeMap paragraphAttrs) {\n+    }\n+\n+    @Override\n+    protected void applyStyle(int ix, int start, int end, StyleAttributeMap a, boolean merge) {\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/NotebookModelStacked.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.rta;\n+\n+import javafx.scene.paint.Color;\n+import javafx.scene.text.TextAlignment;\n+import com.oracle.demo.richtext.util.FX;\n+import jfx.incubator.scene.control.richtext.model.RtfFormatHandler;\n+import jfx.incubator.scene.control.richtext.model.SimpleViewOnlyStyledModel;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * This simple, read-only StyledModel demonstrates various paragraph attributes.\n+ *\/\n+public class ParagraphAttributesDemoModel extends SimpleViewOnlyStyledModel {\n+    private final static StyleAttributeMap TITLE = StyleAttributeMap.builder().\n+        setFontSize(24).\n+        setUnderline(true).\n+        build();\n+    private final static StyleAttributeMap BULLET = StyleAttributeMap.builder().\n+        setSpaceLeft(20).\n+        setBullet(\"•\").\n+        build();\n+    private final static StyleAttributeMap FIRST_LINE_INDENT = StyleAttributeMap.builder().\n+        setFirstLineIndent(100).\n+        build();\n+\n+    public ParagraphAttributesDemoModel() {\n+        registerDataFormatHandler(RtfFormatHandler.INSTANCE, true, false, 1000);\n+        insert(this);\n+    }\n+\n+    public static void insert(SimpleViewOnlyStyledModel m) {\n+        m.addSegment(\"Bullet List\", TITLE);\n+        m.nl(2);\n+        m.setParagraphAttributes(BULLET);\n+        m.addSegment(\"This little piggy went to market,\");\n+        m.setParagraphAttributes(BULLET);\n+        m.nl();\n+        m.addSegment(\"This little piggy stayed home,\");\n+        m.setParagraphAttributes(BULLET);\n+        m.nl();\n+        m.addSegment(\"This little piggy had roast beef,\");\n+        m.setParagraphAttributes(BULLET);\n+        m.nl();\n+        m.addSegment(\"This little piggy had none.\");\n+        m.setParagraphAttributes(BULLET);\n+        m.nl();\n+        m.addSegment(\"This little piggy went ...\");\n+        m.setParagraphAttributes(BULLET);\n+        m.nl();\n+        m.addSegment(\"Wee, wee, wee, all the way home!\");\n+        m.setParagraphAttributes(BULLET);\n+        m.nl(2);\n+\n+        m.addSegment(\"First Line Indent\", TITLE);\n+        m.nl(2);\n+        m.addSegment(words(60));\n+        m.setParagraphAttributes(FIRST_LINE_INDENT);\n+        m.nl(2);\n+\n+        m.addSegment(\"Paragraph Attributes\", TITLE);\n+        m.nl(2);\n+\n+        m.addSegment(\"✓ Opaque Background Color\");\n+        m.setParagraphAttributes(StyleAttributeMap.builder().\n+            setBackground(Color.LIGHTGREEN).\n+            build());\n+        m.nl();\n+\n+        m.addSegment(\"✓ Translucent Background Color\");\n+        m.setParagraphAttributes(StyleAttributeMap.builder().\n+            setBackground(FX.alpha(Color.LIGHTGREEN, 0.5)).\n+            build());\n+        m.nl();\n+\n+        \/\/ space\n+\n+        m.addSegment(\"✓ Space Above\");\n+        m.setParagraphAttributes(StyleAttributeMap.builder().\n+            setSpaceAbove(20).\n+            setBackground(Color.gray(0.95, 0.5)).\n+            setBullet(\"•\").\n+            build());\n+        m.nl();\n+\n+        m.addSegment(\"✓ Space Below\");\n+        m.setParagraphAttributes(StyleAttributeMap.builder().\n+            setSpaceBelow(20).\n+            setBackground(Color.gray(0.9, 0.5)).\n+            setBullet(\"◦\").\n+            build());\n+        m.nl();\n+\n+        m.addSegment(\"✓ Space Left \" + words(50));\n+        m.setParagraphAttributes(StyleAttributeMap.builder().\n+            setSpaceLeft(20).\n+            setBackground(Color.gray(0.85, 0.5)).\n+            setBullet(\"∙\").\n+            build());\n+        m.nl();\n+\n+        m.addSegment(\"✓ Space Right \" + words(10));\n+        m.setParagraphAttributes(StyleAttributeMap.builder().\n+            setSpaceRight(20).\n+            setBackground(Color.gray(0.8, 0.5)).\n+            setBullet(\"‣\").\n+            build());\n+        m.nl();\n+\n+        \/\/ text alignment\n+\n+        m.addSegment(\"✓ Text Alignment Left \" + words(20));\n+        m.setParagraphAttributes(StyleAttributeMap.builder().\n+            setBackground(Color.gray(0.95, 0.5)).\n+            setTextAlignment(TextAlignment.LEFT).\n+            build());\n+        m.nl();\n+\n+        m.addSegment(\"✓ Text Alignment Right \" + words(20));\n+        m.setParagraphAttributes(StyleAttributeMap.builder().\n+            setBackground(Color.gray(0.9, 0.5)).\n+            setTextAlignment(TextAlignment.RIGHT).\n+            build());\n+        m.nl();\n+\n+        m.addSegment(\"✓ Text Alignment Center \" + words(20));\n+        m.setParagraphAttributes(StyleAttributeMap.builder().\n+            setBackground(Color.gray(0.85, 0.5)).\n+            setTextAlignment(TextAlignment.CENTER).\n+            build());\n+        m.nl();\n+\n+        m.addSegment(\"✓ Text Alignment Justify \" + words(20));\n+        m.setParagraphAttributes(StyleAttributeMap.builder().\n+            setBackground(Color.gray(0.8, 0.5)).\n+            setTextAlignment(TextAlignment.JUSTIFY).\n+            build());\n+        m.nl();\n+\n+        \/\/ line spacing\n+\n+        m.addSegment(\"✓ Line Spacing 0 \" + words(200));\n+        m.highlight(50, 100, FX.alpha(Color.RED, 0.4));\n+        m.setParagraphAttributes(StyleAttributeMap.builder().\n+            setBackground(Color.gray(0.95, 0.5)).\n+            setLineSpacing(0).\n+            build());\n+        m.nl();\n+\n+        m.addSegment(\"✓ Line Spacing 20 \" + words(200));\n+        m.highlight(50, 100, FX.alpha(Color.RED, 0.4));\n+        m.setParagraphAttributes(StyleAttributeMap.builder().\n+            setBackground(Color.gray(0.9, 0.5)).\n+            setLineSpacing(20).\n+            build());\n+        m.nl();\n+\n+        m.addSegment(\"✓ Line Spacing 40 \" + words(200));\n+        m.highlight(50, 100, FX.alpha(Color.RED, 0.4));\n+        m.setParagraphAttributes(StyleAttributeMap.builder().\n+            setBackground(Color.gray(0.9, 0.5)).\n+            setLineSpacing(40).\n+            build());\n+        m.nl();\n+    }\n+\n+    private static String words(int count) {\n+        String[] lorem = {\n+            \"Lorem\",\n+            \"ipsum\",\n+            \"dolor\",\n+            \"sit\",\n+            \"amet,\",\n+            \"consectetur\",\n+            \"adipiscing\",\n+            \"elit,\",\n+            \"sed\",\n+            \"do\",\n+            \"eiusmod\",\n+            \"tempor\",\n+            \"incididunt\",\n+            \"ut\",\n+            \"labore\",\n+            \"et\",\n+            \"dolore\",\n+            \"magna\",\n+            \"aliqua\"\n+        };\n+\n+        StringBuilder sb = new StringBuilder();\n+        for(int i=0; i<count; i++) {\n+            if(i > 0) {\n+                sb.append(' ');\n+            }\n+            sb.append(lorem[i % lorem.length]);\n+        }\n+        sb.append(\".\");\n+        return sb.toString();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/ParagraphAttributesDemoModel.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.rta;\n+\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.paint.Color;\n+\n+public class PrefSizeTester extends Pane {\n+    private final ComboBox prefWidth;\n+    private final ComboBox prefHeight;\n+    private final GridPane p;\n+\n+    public PrefSizeTester() {\n+        setBackground(Background.fill(Color.LIGHTSTEELBLUE));\n+\n+        prefWidth = new ComboBox();\n+        prefWidth.getItems().addAll(\n+            -1.0,\n+            100.0,\n+            200.0,\n+            300.0\n+        );\n+        prefWidth.setOnAction((ev) -> {\n+            updateWidth();\n+        });\n+\n+        prefHeight = new ComboBox();\n+        prefHeight.getItems().addAll(\n+            -1.0,\n+            100.0,\n+            200.0,\n+            300.0\n+        );\n+        prefHeight.setOnAction((ev) -> {\n+            updateHeight();\n+        });\n+\n+        p = new GridPane();\n+        p.add(new Label(\"Pref Width:\"), 0, 0);\n+        p.add(prefWidth, 1, 0);\n+        p.add(new Label(\"Pref Height:\"), 0, 1);\n+        p.add(prefHeight, 1, 1);\n+\n+        getChildren().add(p);\n+        \/\/setCenter(p);\n+    }\n+\n+    private void updateWidth() {\n+        if (prefWidth.getValue() instanceof Number n) {\n+            double w = n.doubleValue();\n+            p.setPrefWidth(w);\n+        }\n+    }\n+\n+    private void updateHeight() {\n+        if (prefHeight.getValue() instanceof Number n) {\n+            double h = n.doubleValue();\n+            p.setPrefHeight(h);\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/PrefSizeTester.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import javafx.geometry.Insets;\n+import javafx.scene.Node;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.Priority;\n+\n+\/**\n+ *\n+ *\/\n+public class ROptionPane extends GridPane {\n+    private int row;\n+    private int column;\n+    private static final Insets MARGIN = new Insets(2, 4, 2, 4);\n+\n+    public ROptionPane() {\n+        \/\/ no such thing\n+        \/\/ https:\/\/stackoverflow.com\/questions\/20454021\/how-to-set-padding-between-columns-of-a-javafx-gridpane\n+        \/\/ setVGap(2);\n+    }\n+\n+    public void label(String text) {\n+        add(new Label(text));\n+    }\n+\n+    public void option(Node n) {\n+        add(n);\n+    }\n+\n+    public void add(Node n) {\n+        add(n, column, row++);\n+        setMargin(n, MARGIN);\n+        setFillHeight(n, Boolean.TRUE);\n+        setFillWidth(n, Boolean.TRUE);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/ROptionPane.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.rta;\n+\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n+import javafx.geometry.VPos;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.layout.Region;\n+\n+\/**\n+ * Content pane for TextCell that shows an arbitrary Region.\n+ * The content gets resized if it cannot fit into available width.\n+ *\/\n+public class RegionCellPane extends Pane {\n+    private final Region content;\n+    private static final Insets PADDING = new Insets(1, 1, 1, 1);\n+\n+    public RegionCellPane(Region n) {\n+        this.content = n;\n+\n+        getChildren().add(n);\n+\n+        setPadding(PADDING);\n+        getStyleClass().add(\"region-cell\");\n+    }\n+\n+    @Override\n+    protected void layoutChildren() {\n+        double width = getWidth() - snappedLeftInset() - snappedRightInset();\n+        double w = content.prefWidth(-1);\n+        if (w < width) {\n+            width = w;\n+        }\n+        double h = content.prefHeight(width);\n+\n+        double x0 = snappedLeftInset();\n+        double y0 = snappedTopInset();\n+        layoutInArea(\n+            content,\n+            x0,\n+            y0,\n+            width,\n+            h,\n+            0,\n+            null,\n+            true,\n+            false,\n+            HPos.CENTER,\n+            VPos.CENTER\n+        );\n+    }\n+\n+    @Override\n+    protected double computePrefHeight(double width) {\n+        return content.prefHeight(width) + snappedTopInset() + snappedBottomInset();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/RegionCellPane.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.scene.Node;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableView;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.text.Text;\n+import javafx.scene.text.TextFlow;\n+\n+public class ResultParagraph extends BorderPane {\n+    SimpleObjectProperty<Object> result = new SimpleObjectProperty<Object>();\n+\n+    public ResultParagraph(SimpleObjectProperty<Object> src) {\n+        result.bind(src);\n+        result.addListener((s, p, c) -> {\n+            update();\n+        });\n+        update();\n+        setPrefSize(600, 200);\n+    }\n+\n+    protected void update() {\n+        Node n = getNode();\n+        setCenter(n);\n+    }\n+\n+    protected Node getNode() {\n+        Object r = result.get();\n+        if (r instanceof String s) {\n+            Text t = new Text(s);\n+            t.setStyle(\"-fx-fill:red;\");\n+\n+            TextFlow f = new TextFlow();\n+            f.getChildren().add(t);\n+            return f;\n+        } else if (r instanceof String[] ss) {\n+            DataFrame f = DataFrame.parse(ss);\n+            TableView<String[]> t = new TableView<>();\n+\n+            String[] cols = f.getColumnNames();\n+            for (int i=0; i<cols.length; i++) {\n+                String col = cols[i];\n+                TableColumn<String[], String> c = new TableColumn<>(col);\n+                int ix = i;\n+                c.setCellValueFactory((d) -> {\n+                    String[] row = d.getValue();\n+                    String s = row[ix];\n+                    return new SimpleStringProperty(s);\n+                });\n+                t.getColumns().add(c);\n+            }\n+            for (int i = 0; i < f.getRowCount(); i++) {\n+                t.getItems().add(f.getRow(i));\n+            }\n+            t.prefWidthProperty().bind(widthProperty());\n+            return t;\n+        }\n+        return null;\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/ResultParagraph.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+.red {\n+    -fx-fill:red;\n+}\n+\n+.green {\n+    -fx-fill:#3e8c25;\n+}\n+\n+.gray {\n+    -fx-fill:gray;\n+}\n+\n+.code {\n+    -fx-font-family:Monospace;\n+}\n+\n+.underline {\n+    -fx-underline:true;\n+}\n+\n+.monospaced {\n+    -fx-font-family:Monospaced;\n+}\n+\n+.bold {\n+    -fx-font-weight: bold;\n+}\n+\n+.italic {\n+    -fx-font-family: serif;\n+    -fx-font-style: italic;\n+}\n+\n+.strikethrough {\n+    -fx-strikethrough: true;\n+}\n+\n+.arabic {\n+    -fx-font-family:Tahoma;\n+    -fx-font-size:200%;\n+}\n+\n+.large {\n+    -fx-font-size:200%;\n+}\n+\n+.equation {\n+    -fx-font-family:serif;\n+}\n+\n+.sub {\n+    -fx-text-origin:bottom;\n+    -fx-font-size:70%;\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/RichTextAreaDemo.css","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import javafx.application.Application;\n+import javafx.stage.Stage;\n+import com.oracle.demo.richtext.settings.FxSettings;\n+\n+\/**\n+ * RichTextArea Demo Application.\n+ *\/\n+public class RichTextAreaDemoApp extends Application {\n+    public static void main(String[] args) {\n+        Application.launch(RichTextAreaDemoApp.class, args);\n+    }\n+\n+    @Override\n+    public void init() {\n+        FxSettings.useDirectory(\".RichTextAreaDemo\");\n+    }\n+\n+    @Override\n+    public void start(Stage stage) throws Exception {\n+        try {\n+            new RichTextAreaWindow(false).show();\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/RichTextAreaDemoApp.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,753 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.rta;\n+\n+import java.nio.charset.Charset;\n+import java.util.Base64;\n+import java.util.Objects;\n+import javafx.application.Platform;\n+import javafx.collections.ObservableList;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Orientation;\n+import javafx.geometry.Pos;\n+import javafx.scene.AccessibleAttribute;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.canvas.Canvas;\n+import javafx.scene.canvas.GraphicsContext;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.CheckBox;\n+import javafx.scene.control.CheckMenuItem;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.Menu;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.ScrollPane;\n+import javafx.scene.control.ScrollPane.ScrollBarPolicy;\n+import javafx.scene.control.SeparatorMenuItem;\n+import javafx.scene.control.SplitPane;\n+import javafx.scene.input.Clipboard;\n+import javafx.scene.input.DataFormat;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.paint.Color;\n+import javafx.scene.text.TextAlignment;\n+import javafx.stage.Window;\n+import javafx.util.Duration;\n+import javafx.util.StringConverter;\n+import com.oracle.demo.richtext.util.FX;\n+import jfx.incubator.scene.control.input.KeyBinding;\n+import jfx.incubator.scene.control.richtext.LineNumberDecorator;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.SideDecorator;\n+import jfx.incubator.scene.control.richtext.StyleHandlerRegistry;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.ParagraphDirection;\n+import jfx.incubator.scene.control.richtext.model.RichTextModel;\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+import jfx.incubator.scene.control.richtext.skin.RichTextAreaSkin;\n+\n+\/**\n+ * Main Panel contains RichTextArea, split panes for quick size adjustment, and an option pane.\n+ *\/\n+public class RichTextAreaDemoPane extends BorderPane {\n+    enum Decorator {\n+        NULL,\n+        LINE_NUMBERS,\n+        COLORS\n+    }\n+\n+    private static StyledTextModel globalModel;\n+    public final ROptionPane op;\n+    public final RichTextArea control;\n+    public final ComboBox<ModelChoice> modelField;\n+\n+    public RichTextAreaDemoPane(boolean useContentSize) {\n+        FX.name(this, \"RichTextAreaDemoPane\");\n+\n+        control = new RichTextArea() {\n+            private static final StyleHandlerRegistry registry = init();\n+\n+            private static StyleHandlerRegistry init() {\n+                \/\/ brings in the handlers from the base class\n+                StyleHandlerRegistry.Builder b = StyleHandlerRegistry.builder(RichTextArea.styleHandlerRegistry);\n+                \/\/ adds a handler for the new attribute\n+                b.setParHandler(NotebookModel.OUTLINE, (c, cx, v) -> {\n+                    if (v) {\n+                        cx.addStyle(\"-fx-border-color:LIGHTPINK;\");\n+                        cx.addStyle(\"-fx-border-width:1;\");\n+                    }\n+                });\n+                return b.build();\n+            }\n+\n+            @Override\n+            public StyleHandlerRegistry getStyleHandlerRegistry() {\n+                return registry;\n+            }\n+        };\n+        control.setUseContentHeight(useContentSize);\n+        control.setUseContentWidth(useContentSize);\n+        control.setHighlightCurrentParagraph(true);\n+\n+        \/\/ custom functions\n+        System.out.println(\n+            \"\"\"\n+            F2: dump model\n+            F3: dump accessibility attributes at cursor\n+            \"\"\");\n+        control.getInputMap().register(KeyBinding.of(KeyCode.F2), () -> {\n+            RichTextModel.dump(control.getModel(), System.out);\n+        });\n+        control.getInputMap().register(KeyBinding.of(KeyCode.F3), () -> {\n+            dumpAccessibilityAttributes();\n+        });\n+\n+        Node contentNode;\n+        if (useContentSize) {\n+            contentNode = new ScrollPane(control);\n+        } else {\n+            contentNode = control;\n+        }\n+\n+        SplitPane hsplit = new SplitPane(contentNode, pane());\n+        FX.name(hsplit, \"hsplit\");\n+        hsplit.setBorder(null);\n+        hsplit.setDividerPositions(1.0);\n+        hsplit.setOrientation(Orientation.HORIZONTAL);\n+\n+        SplitPane vsplit = new SplitPane(hsplit, pane());\n+        FX.name(vsplit, \"vsplit\");\n+        vsplit.setBorder(null);\n+        vsplit.setDividerPositions(1.0);\n+        vsplit.setOrientation(Orientation.VERTICAL);\n+\n+        modelField = new ComboBox<>();\n+        FX.name(modelField, \"modelField\");\n+        modelField.getItems().setAll(ModelChoice.values());\n+\n+        CheckBox editable = new CheckBox(\"editable\");\n+        FX.name(editable, \"editable\");\n+        editable.selectedProperty().bindBidirectional(control.editableProperty());\n+\n+        CheckBox wrapText = new CheckBox(\"wrap text\");\n+        FX.name(wrapText, \"wrapText\");\n+        wrapText.selectedProperty().bindBidirectional(control.wrapTextProperty());\n+\n+        CheckBox displayCaret = new CheckBox(\"display caret\");\n+        FX.name(displayCaret, \"displayCaret\");\n+        displayCaret.selectedProperty().bindBidirectional(control.displayCaretProperty());\n+\n+        CheckBox fatCaret = new CheckBox(\"fat caret\");\n+        FX.name(fatCaret, \"fatCaret\");\n+        fatCaret.selectedProperty().addListener((s, p, on) -> {\n+            Node n = control.lookup(\".caret\");\n+            if (n != null) {\n+                if (on) {\n+                    n.setStyle(\"-fx-stroke-width:2; -fx-stroke:red; -fx-effect:dropshadow(gaussian,rgba(0,0,0,.5),5,0,1,1);\");\n+                } else {\n+                    n.setStyle(null);\n+                }\n+            }\n+        });\n+\n+        CheckBox fastBlink = new CheckBox(\"blink fast\");\n+        FX.name(fastBlink, \"fastBlink\");\n+        fastBlink.selectedProperty().addListener((s,p,on) -> {\n+            control.setCaretBlinkPeriod(on ? Duration.millis(200) : Duration.millis(500));\n+        });\n+\n+        CheckBox highlightCurrentLine = new CheckBox(\"highlight current line\");\n+        FX.name(highlightCurrentLine, \"highlightCurrentLine\");\n+        highlightCurrentLine.selectedProperty().bindBidirectional(control.highlightCurrentParagraphProperty());\n+\n+        Button reloadModelButton = new Button(\"Reload Model\");\n+        reloadModelButton.setOnAction((ev) -> reloadModel());\n+\n+        CheckBox customPopup = new CheckBox(\"custom popup menu\");\n+        FX.name(customPopup, \"customPopup\");\n+        customPopup.selectedProperty().addListener((s, p, v) -> {\n+            setCustomPopup(v);\n+        });\n+\n+        ComboBox<Insets> contentPadding = contentPaddingOption();\n+\n+        ComboBox<Decorator> leftDecorator = new ComboBox<>();\n+        FX.name(leftDecorator, \"leftDecorator\");\n+        leftDecorator.getItems().setAll(Decorator.values());\n+        leftDecorator.getSelectionModel().selectedItemProperty().addListener((s,p,v) -> {\n+            control.setLeftDecorator(createDecorator(v));\n+        });\n+\n+        ComboBox<Decorator> rightDecorator = new ComboBox<>();\n+        FX.name(rightDecorator, \"rightDecorator\");\n+        rightDecorator.getItems().setAll(Decorator.values());\n+        rightDecorator.getSelectionModel().selectedItemProperty().addListener((s,p,v) -> {\n+            control.setRightDecorator(createDecorator(v));\n+        });\n+\n+        CheckBox trackWidth = new CheckBox(\"use content width\");\n+        FX.name(trackWidth, \"trackWidth\");\n+        trackWidth.selectedProperty().bindBidirectional(control.useContentWidthProperty());\n+\n+        CheckBox trackHeight = new CheckBox(\"use content height\");\n+        FX.name(trackHeight, \"trackHeight\");\n+        trackHeight.selectedProperty().bindBidirectional(control.useContentHeightProperty());\n+\n+        Button appendButton = new Button(\"Append\");\n+        FX.tooltip(appendButton, \"appends text to the end of the document\");\n+        appendButton.setOnAction((ev) -> {\n+            StyleAttributeMap heading = StyleAttributeMap.builder().setBold(true).setFontSize(24).build();\n+            StyleAttributeMap plain = StyleAttributeMap.builder().setFontFamily(\"Monospaced\").build();\n+            control.appendText(\"Heading\\n\", heading);\n+            control.appendText(\"Plain monospaced text.\\n\", plain);\n+        });\n+\n+        Button insertButton = new Button(\"Insert\");\n+        FX.tooltip(insertButton, \"inserts text to the start of the document\");\n+        insertButton.setOnAction((ev) -> {\n+            StyleAttributeMap heading = StyleAttributeMap.builder().setBold(true).setFontSize(24).build();\n+            StyleAttributeMap plain = StyleAttributeMap.builder().setFontFamily(\"Monospaced\").build();\n+            control.insertText(TextPos.ZERO, \"Plain monospaced text.\\n\", plain);\n+            control.insertText(TextPos.ZERO, \"Heading\\n\", heading);\n+        });\n+\n+        Button replaceSkin = new Button(\"Replace Skin\");\n+        replaceSkin.setOnAction((ev) -> {\n+            control.setSkin(new RichTextAreaSkin(control));\n+        });\n+\n+        op = new ROptionPane();\n+        op.label(\"Model:\");\n+        op.option(modelField);\n+        op.option(new HBox(insertButton, appendButton));\n+        op.option(editable);\n+        op.option(reloadModelButton);\n+        op.option(wrapText);\n+        op.option(displayCaret);\n+        op.option(fatCaret);\n+        op.option(fastBlink);\n+        op.option(highlightCurrentLine);\n+        op.option(customPopup);\n+        op.label(\"Content Padding:\");\n+        op.option(contentPadding);\n+        op.label(\"Decorators:\");\n+        op.option(leftDecorator);\n+        op.option(rightDecorator);\n+        op.option(trackWidth);\n+        op.option(trackHeight);\n+        op.option(replaceSkin);\n+\n+        setCenter(vsplit);\n+\n+        ScrollPane sp = new ScrollPane(op);\n+        sp.setVbarPolicy(ScrollBarPolicy.AS_NEEDED);\n+        sp.setHbarPolicy(ScrollBarPolicy.NEVER);\n+        setRight(sp);\n+\n+        modelField.getSelectionModel().selectFirst();\n+        leftDecorator.getSelectionModel().selectFirst();\n+        rightDecorator.getSelectionModel().selectFirst();\n+\n+        Platform.runLater(() -> {\n+            \/\/ all this to make sure restore settings works correctly with second window loading the same model\n+            if (globalModel == null) {\n+                globalModel = createModel();\n+            }\n+            control.setModel(globalModel);\n+\n+            modelField.getSelectionModel().selectedItemProperty().addListener((s, p, c) -> {\n+                updateModel();\n+            });\n+        });\n+    }\n+\n+    protected SideDecorator createDecorator(Decorator d) {\n+        if (d != null) {\n+            switch (d) {\n+            case COLORS:\n+                return new DemoColorSideDecorator();\n+            case LINE_NUMBERS:\n+                return new LineNumberDecorator();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected void updateModel() {\n+        globalModel = createModel();\n+        control.setModel(globalModel);\n+    }\n+\n+    protected void reloadModel() {\n+        control.setModel(null);\n+        updateModel();\n+    }\n+\n+    private StyledTextModel createModel() {\n+        ModelChoice m = modelField.getSelectionModel().getSelectedItem();\n+        return ModelChoice.create(m);\n+    }\n+\n+    protected static Pane pane() {\n+        Pane p = new Pane();\n+        SplitPane.setResizableWithParent(p, false);\n+        p.setStyle(\"-fx-background-color:#dddddd;\");\n+        return p;\n+    }\n+\n+    public Button addButton(String name, Runnable action) {\n+        Button b = new Button(name);\n+        b.setOnAction((ev) -> {\n+            action.run();\n+        });\n+\n+        toolbar().add(b);\n+        return b;\n+    }\n+\n+    public TBar toolbar() {\n+        if (getTop() instanceof TBar) {\n+            return (TBar)getTop();\n+        }\n+\n+        TBar t = new TBar();\n+        setTop(t);\n+        return t;\n+    }\n+\n+    public Window getWindow() {\n+        Scene s = getScene();\n+        if (s != null) {\n+            return s.getWindow();\n+        }\n+        return null;\n+    }\n+\n+    public void setOptions(Node n) {\n+        setRight(n);\n+    }\n+\n+    protected String generateStylesheet(boolean fat) {\n+        String s = \".rich-text-area .caret { -fx-stroke-width:\" + (fat ? 2 : 1) + \"; }\";\n+        return \"data:text\/css;base64,\" + Base64.getEncoder().encodeToString(s.getBytes(Charset.forName(\"utf-8\")));\n+    }\n+\n+    protected void setCustomPopup(boolean on) {\n+        if (on) {\n+            ContextMenu m = new ContextMenu();\n+            m.getItems().add(new MenuItem(\"Dummy\")); \/\/ otherwise no popup is shown\n+            m.addEventFilter(Menu.ON_SHOWING, (ev) -> {\n+                m.getItems().clear();\n+                populateCustomPopupMenu(m.getItems());\n+            });\n+            control.setContextMenu(m);\n+        } else {\n+            control.setContextMenu(null);\n+        }\n+    }\n+\n+    protected void populateCustomPopupMenu(ObservableList<MenuItem> items) {\n+        boolean sel = control.hasNonEmptySelection();\n+        boolean paste = true; \/\/ would be easier with Actions (findFormatForPaste() != null);\n+        boolean styled = (control.getModel() instanceof RichTextModel);\n+\n+        items.add(new MenuItem(\"★ Custom Context Menu\"));\n+\n+        items.add(new SeparatorMenuItem());\n+\n+        Menu m2;\n+        MenuItem m;\n+        CheckMenuItem cm;\n+        items.add(m = new MenuItem(\"Undo\"));\n+        m.setOnAction((ev) -> control.undo());\n+        m.setDisable(!control.isUndoable());\n+\n+        items.add(m = new MenuItem(\"Redo\"));\n+        m.setOnAction((ev) -> control.redo());\n+        m.setDisable(!control.isRedoable());\n+\n+        items.add(new SeparatorMenuItem());\n+\n+        items.add(m = new MenuItem(\"Cut\"));\n+        m.setOnAction((ev) -> control.cut());\n+        m.setDisable(!sel);\n+\n+        items.add(m = new MenuItem(\"Copy\"));\n+        m.setOnAction((ev) -> control.copy());\n+        m.setDisable(!sel);\n+\n+        items.add(m = m2 = new Menu(\"Copy Special...\"));\n+        {\n+            DataFormat[] fs = control.getModel().getSupportedDataFormats(true);\n+            for (DataFormat f : fs) {\n+                String name = f.toString();\n+                m2.getItems().add(m = new MenuItem(name));\n+                m.setOnAction((ev) -> control.copy(f));\n+            }\n+        }\n+\n+        items.add(m = new MenuItem(\"Paste\"));\n+        m.setOnAction((ev) -> control.paste());\n+        m.setDisable(!paste);\n+\n+        items.add(m = m2 = new Menu(\"Paste Special...\"));\n+        m.setDisable(!paste);\n+        {\n+            DataFormat[] fs = control.getModel().getSupportedDataFormats(false);\n+            for (DataFormat f : fs) {\n+                if (Clipboard.getSystemClipboard().hasContent(f)) {\n+                    String name = f.toString();\n+                    m2.getItems().add(m = new MenuItem(name));\n+                    m2.setOnAction((ev) -> control.paste(f));\n+                    m2.setDisable(!paste);\n+                }\n+            }\n+        }\n+\n+        items.add(m = new MenuItem(\"Paste and Match Style\"));\n+        m.setOnAction((ev) -> control.pastePlainText());\n+        m.setDisable(!paste);\n+\n+        if (styled) {\n+            StyleAttributeMap a = control.getActiveStyleAttributeMap();\n+            items.add(new SeparatorMenuItem());\n+\n+            items.add(m = new MenuItem(\"Bold\"));\n+            m.setOnAction((ev) -> applyStyle(StyleAttributeMap.BOLD, !a.getBoolean(StyleAttributeMap.BOLD)));\n+            m.setDisable(!sel);\n+\n+            items.add(m = new MenuItem(\"Italic\"));\n+            m.setOnAction((ev) -> applyStyle(StyleAttributeMap.ITALIC, !a.getBoolean(StyleAttributeMap.ITALIC)));\n+            m.setDisable(!sel);\n+\n+            items.add(m = new MenuItem(\"Strike Through\"));\n+            m.setOnAction((ev) -> applyStyle(StyleAttributeMap.STRIKE_THROUGH, !a.getBoolean(StyleAttributeMap.STRIKE_THROUGH)));\n+            m.setDisable(!sel);\n+\n+            items.add(m = new MenuItem(\"Underline\"));\n+            m.setOnAction((ev) -> applyStyle(StyleAttributeMap.UNDERLINE, !a.getBoolean(StyleAttributeMap.UNDERLINE)));\n+            m.setDisable(!sel);\n+\n+            items.add(m2 = new Menu(\"Text Color\"));\n+            colorMenu(m2, sel, Color.BLACK);\n+            colorMenu(m2, sel, Color.DARKGRAY);\n+            colorMenu(m2, sel, Color.GRAY);\n+            colorMenu(m2, sel, Color.LIGHTGRAY);\n+            colorMenu(m2, sel, Color.GREEN);\n+            colorMenu(m2, sel, Color.RED);\n+            colorMenu(m2, sel, Color.BLUE);\n+            colorMenu(m2, sel, null);\n+\n+            items.add(m2 = new Menu(\"Text Size\"));\n+            sizeMenu(m2, sel, 96);\n+            sizeMenu(m2, sel, 72);\n+            sizeMenu(m2, sel, 48);\n+            sizeMenu(m2, sel, 36);\n+            sizeMenu(m2, sel, 24);\n+            sizeMenu(m2, sel, 18);\n+            sizeMenu(m2, sel, 16);\n+            sizeMenu(m2, sel, 14);\n+            sizeMenu(m2, sel, 12);\n+            sizeMenu(m2, sel, 10);\n+            sizeMenu(m2, sel, 9);\n+            sizeMenu(m2, sel, 8);\n+            sizeMenu(m2, sel, 6);\n+\n+            items.add(m2 = new Menu(\"Font Family\"));\n+            fontMenu(m2, sel, \"System\");\n+            fontMenu(m2, sel, \"Serif\");\n+            fontMenu(m2, sel, \"Sans-serif\");\n+            fontMenu(m2, sel, \"Cursive\");\n+            fontMenu(m2, sel, \"Fantasy\");\n+            fontMenu(m2, sel, \"Monospaced\");\n+            m2.getItems().add(new SeparatorMenuItem());\n+            fontMenu(m2, sel, \"Arial\");\n+            fontMenu(m2, sel, \"Courier New\");\n+            fontMenu(m2, sel, \"Times New Roman\");\n+            fontMenu(m2, sel, \"null\");\n+        }\n+\n+        if (styled) {\n+            StyleAttributeMap a = control.getActiveStyleAttributeMap();\n+            items.add(new SeparatorMenuItem());\n+\n+            items.add(m2 = new Menu(\"Alignment\"));\n+            alignmentMenu(m2, \"Left\", TextAlignment.LEFT);\n+            alignmentMenu(m2, \"Center\", TextAlignment.CENTER);\n+            alignmentMenu(m2, \"Right\", TextAlignment.RIGHT);\n+            alignmentMenu(m2, \"Justify\", TextAlignment.JUSTIFY);\n+\n+            items.add(m2 = new Menu(\"Line Spacing\"));\n+            lineSpacingMenu(m2, 0);\n+            lineSpacingMenu(m2, 1);\n+            lineSpacingMenu(m2, 10);\n+            lineSpacingMenu(m2, 30);\n+\n+            items.add(m2 = new Menu(\"Space\"));\n+            spaceMenu(m2, \"All\", 30, 30, 30, 30);\n+            spaceMenu(m2, \"Above\", 30, 0, 0, 0);\n+            spaceMenu(m2, \"Below\", 0, 0, 30, 0);\n+            spaceMenu(m2, \"Left\", 0, 0, 0, 30);\n+            spaceMenu(m2, \"Right\", 0, 30, 0, 0);\n+            spaceMenu(m2, \"None\", 0, 0, 0, 0);\n+\n+            items.add(m2 = new Menu(\"Paragraph Direction\"));\n+            directionMenu(m2, \"Left-to-Right\", ParagraphDirection.LEFT_TO_RIGHT);\n+            directionMenu(m2, \"Right-to-Left\", ParagraphDirection.RIGHT_TO_LEFT);\n+            directionMenu(m2, \"<null>\", null);\n+\n+            items.add(m2 = new Menu(\"Background Color\"));\n+            backgroundMenu(m2, \"Red\", Color.RED, 0.2);\n+            backgroundMenu(m2, \"Green\", Color.GREEN, 0.2);\n+            backgroundMenu(m2, \"Blue\", Color.BLUE, 0.2);\n+            backgroundMenu(m2, \"Gray\", Color.GRAY, 1.0);\n+            backgroundMenu(m2, \"Gray 10%\", Color.GRAY, 0.1);\n+            backgroundMenu(m2, \"Gray 20%\", Color.GRAY, 0.2);\n+            backgroundMenu(m2, \"Yellow\", Color.YELLOW, 1.0);\n+\n+            items.add(m2 = new Menu(\"Bullet\"));\n+            bulletMenu(m2, a, \"None\", null);\n+            bulletMenu(m2, a, \"●\", \"●\");\n+            bulletMenu(m2, a, \"○\", \"○\");\n+            bulletMenu(m2, a, \"♣\", \"♣\");\n+\n+            items.add(m2 = new Menu(\"First Line Indent\"));\n+            firstLineIndentMenu(m2, a, 0);\n+            firstLineIndentMenu(m2, a, 10);\n+            firstLineIndentMenu(m2, a, 50);\n+            firstLineIndentMenu(m2, a, 100);\n+        }\n+\n+        items.add(new SeparatorMenuItem());\n+\n+        items.add(m = new MenuItem(\"Select All\"));\n+        m.setOnAction((ev) -> control.selectAll());\n+    }\n+\n+    private void bulletMenu(Menu menu, StyleAttributeMap a, String name, String bullet) {\n+        CheckMenuItem m = new CheckMenuItem(name);\n+        menu.getItems().add(m);\n+        m.setSelected(Objects.equals(bullet, a.getBullet()));\n+        m.setOnAction((ev) -> {\n+            applyStyle(StyleAttributeMap.BULLET, bullet);\n+        });\n+    }\n+\n+    private void firstLineIndentMenu(Menu menu, StyleAttributeMap a, int value) {\n+        CheckMenuItem m = new CheckMenuItem(String.valueOf(value));\n+        menu.getItems().add(m);\n+        Double v = a.getFirstLineIndent();\n+        if (v != null) {\n+            m.setSelected(Objects.equals(value, v.intValue()));\n+        }\n+        m.setOnAction((ev) -> {\n+            applyStyle(StyleAttributeMap.FIRST_LINE_INDENT, (double)value);\n+        });\n+    }\n+\n+    private void alignmentMenu(Menu menu, String name, TextAlignment a) {\n+        MenuItem m = new MenuItem(name);\n+        menu.getItems().add(m);\n+        m.setOnAction((ev) -> {\n+            applyStyle(StyleAttributeMap.TEXT_ALIGNMENT, a);\n+        });\n+    }\n+\n+    private void lineSpacingMenu(Menu menu, double value) {\n+        MenuItem m = new MenuItem(String.valueOf(value));\n+        menu.getItems().add(m);\n+        m.setOnAction((ev) -> {\n+            applyStyle(StyleAttributeMap.LINE_SPACING, value);\n+        });\n+    }\n+\n+    private void directionMenu(Menu menu, String text, ParagraphDirection d) {\n+        MenuItem m = new MenuItem(text);\n+        menu.getItems().add(m);\n+        m.setOnAction((ev) -> {\n+            applyStyle(StyleAttributeMap.PARAGRAPH_DIRECTION, d);\n+        });\n+    }\n+\n+    private void spaceMenu(Menu menu, String name, double top, double right, double bottom, double left) {\n+        MenuItem m = new MenuItem(name);\n+        menu.getItems().add(m);\n+        m.setOnAction((ev) -> {\n+            applyStyle(StyleAttributeMap.SPACE_ABOVE, top);\n+            applyStyle(StyleAttributeMap.SPACE_BELOW, bottom);\n+            applyStyle(StyleAttributeMap.SPACE_LEFT, left);\n+            applyStyle(StyleAttributeMap.SPACE_RIGHT, right);\n+        });\n+    }\n+\n+    private void backgroundMenu(Menu menu, String name, Color color, double alpha) {\n+        Color c = FX.alpha(color, alpha);\n+        MenuItem m = new MenuItem(name);\n+        menu.getItems().add(m);\n+        m.setOnAction((ev) -> {\n+            applyStyle(StyleAttributeMap.BACKGROUND, c);\n+        });\n+    }\n+\n+    private void fontMenu(Menu menu, boolean selected, String family) {\n+        MenuItem m = new MenuItem(family);\n+        m.setDisable(!selected);\n+        m.setOnAction((ev) -> applyStyle(StyleAttributeMap.FONT_FAMILY, family));\n+        menu.getItems().add(m);\n+    }\n+\n+    private void sizeMenu(Menu menu, boolean selected, double size) {\n+        MenuItem m = new MenuItem(String.valueOf(size));\n+        m.setDisable(!selected);\n+        m.setOnAction((ev) -> applyStyle(StyleAttributeMap.FONT_SIZE, size));\n+        menu.getItems().add(m);\n+    }\n+\n+    private void colorMenu(Menu menu, boolean selected, Color color) {\n+        int w = 16;\n+        int h = 16;\n+        Canvas c = new Canvas(w, h);\n+        GraphicsContext g = c.getGraphicsContext2D();\n+        if (color != null) {\n+            g.setFill(color);\n+            g.fillRect(0, 0, w, h);\n+        }\n+        g.setStroke(Color.DARKGRAY);\n+        g.strokeRect(0, 0, w, h);\n+\n+        MenuItem m = new MenuItem(null, c);\n+        m.setDisable(!selected);\n+        m.setOnAction((ev) -> applyStyle(StyleAttributeMap.TEXT_COLOR, color));\n+        menu.getItems().add(m);\n+    }\n+\n+    private <T> void applyStyle(StyleAttribute<T> a, T val) {\n+        TextPos ca = control.getCaretPosition();\n+        TextPos an = control.getAnchorPosition();\n+        StyleAttributeMap m = StyleAttributeMap.of(a, val);\n+        control.applyStyle(ca, an, m);\n+    }\n+\n+    void dumpAccessibilityAttributes() {\n+        TextPos caret = control.getCaretPosition();\n+        if (caret == null) {\n+            return;\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        Object x;\n+        x = control.queryAccessibleAttribute(AccessibleAttribute.LINE_FOR_OFFSET, caret.charIndex());\n+        sb.append(x).append(\"\\n\");\n+        System.out.println(sb.toString());\n+    }\n+\n+    \/** Tool Bar *\/\n+    public static class TBar extends HBox {\n+        public TBar() {\n+            setFillHeight(true);\n+            setAlignment(Pos.CENTER_LEFT);\n+            setSpacing(2);\n+        }\n+\n+        public <T extends Node> T add(T n) {\n+            getChildren().add(n);\n+            return n;\n+        }\n+\n+        public void addAll(Node... nodes) {\n+            for (Node n : nodes) {\n+                add(n);\n+            }\n+        }\n+    }\n+\n+    private ComboBox<Insets> contentPaddingOption() {\n+        ComboBox<Insets> op = new ComboBox<>();\n+        FX.name(op, \"contentPadding\");\n+        op.setConverter(new StringConverter<Insets>() {\n+            @Override\n+            public String toString(Insets x) {\n+                if (x == null) {\n+                    return \"null\";\n+                }\n+                return String.format(\n+                    \"T%d, B%d, L%d, R%d\",\n+                    (int)x.getTop(),\n+                    (int)x.getBottom(),\n+                    (int)x.getLeft(),\n+                    (int)x.getRight()\n+                );\n+            }\n+    \n+            @Override\n+            public Insets fromString(String s) {\n+                return null;\n+            }\n+        });\n+        op.getItems().setAll(\n+            null,\n+            new Insets(1),\n+            new Insets(2),\n+            new Insets(10),\n+            new Insets(22.22),\n+            new Insets(50),\n+            new Insets(100),\n+            new Insets(5, 10, 15, 20)\n+        );\n+\n+        selectValue(op, control.getContentPadding());\n+        control.contentPaddingProperty().addListener((s,p,v) -> {\n+            selectValue(op, v);\n+        });\n+\n+        op.getSelectionModel().selectedItemProperty().addListener((s,p,v) -> {\n+            control.setContentPadding(v);\n+        });\n+\n+        return op;\n+    }\n+\n+    private <T> void selectValue(ComboBox<T> c, T value) {\n+        int ix = -1;\n+        for (int i = c.getItems().size() - 1; i >= 0; i--) {\n+            T v = c.getItems().get(i);\n+            if (Objects.equals(v, value)) {\n+                ix = i;\n+                break;\n+            }\n+        }\n+        if (ix < 0) {\n+            ix = c.getItems().size();\n+            c.getItems().add(value);\n+        }\n+        c.getSelectionModel().select(ix);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/RichTextAreaDemoPane.java","additions":753,"deletions":0,"binary":false,"changes":753,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import javafx.application.Platform;\n+import javafx.geometry.Insets;\n+import javafx.geometry.NodeOrientation;\n+import javafx.scene.Scene;\n+import javafx.scene.control.CheckMenuItem;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.MenuBar;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.VBox;\n+import javafx.stage.Stage;\n+import com.oracle.demo.richtext.util.FX;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * Rich Text Area Demo window\n+ *\/\n+public class RichTextAreaWindow extends Stage {\n+    public final RichTextAreaDemoPane demoPane;\n+    public final Label status;\n+\n+    public RichTextAreaWindow(boolean useContentSize) {\n+        demoPane = new RichTextAreaDemoPane(useContentSize);\n+\n+        CheckMenuItem orientation = new CheckMenuItem(\"Orientation: RTL\");\n+        orientation.setOnAction((ev) -> {\n+            NodeOrientation v = (orientation.isSelected()) ?\n+                NodeOrientation.RIGHT_TO_LEFT :\n+                NodeOrientation.LEFT_TO_RIGHT;\n+            getScene().setNodeOrientation(v);\n+        });\n+        \/\/ TODO save orientation in settings\n+\n+        MenuBar mb = new MenuBar();\n+        \/\/ file\n+        FX.menu(mb, \"_File\");\n+        FX.item(mb, \"New Window\", () -> newWindow(false));\n+        FX.item(mb, \"New Window, Use Content Size\", () -> newWindow(true));\n+        FX.separator(mb);\n+        FX.item(mb, \"Close Window\", this::hide);\n+        FX.separator(mb);\n+        FX.item(mb, \"Quit\", Platform::exit);\n+        \/\/ tools\n+        FX.menu(mb, \"T_ools\");\n+        FX.item(mb, \"CSS Tool\", this::openCssTool);\n+        \/\/ window\n+        FX.menu(mb, \"_Window\");\n+        FX.item(mb, \"Stacked Vertically\", () -> openMultipeStacked(true));\n+        FX.item(mb, \"Stacked Horizontally\", () -> openMultipeStacked(false));\n+        FX.item(mb, \"In a VBox\", this::openInVBox);\n+        FX.separator(mb);\n+        FX.item(mb, orientation);\n+\n+        status = new Label();\n+        status.setPadding(new Insets(2, 10, 2, 10));\n+\n+        BorderPane bp = new BorderPane();\n+        bp.setTop(mb);\n+        bp.setCenter(demoPane);\n+        bp.setBottom(status);\n+\n+        Scene scene = new Scene(bp);\n+        scene.getStylesheets().addAll(\n+            RichTextAreaWindow.class.getResource(\"RichTextAreaDemo.css\").toExternalForm()\n+        );\n+\n+        setScene(scene);\n+        setTitle(\n+            \"RichTextArea Tester FX:\" +\n+            System.getProperty(\"javafx.runtime.version\") +\n+            \"  JDK:\" +\n+            System.getProperty(\"java.version\")\n+        );\n+        setWidth(1200);\n+        setHeight(600);\n+\n+        demoPane.control.caretPositionProperty().addListener((x) -> updateStatus());\n+    }\n+\n+    protected void updateStatus() {\n+        RichTextArea t = demoPane.control;\n+        TextPos p = t.getCaretPosition();\n+\n+        StringBuilder sb = new StringBuilder();\n+\n+        if (p != null) {\n+            sb.append(\" line=\").append(p.index());\n+            sb.append(\" col=\").append(p.offset());\n+            sb.append(p.isLeading() ? \" (leading)\" : \"\");\n+        }\n+\n+        status.setText(sb.toString());\n+    }\n+\n+    protected void newWindow(boolean useContentSize) {\n+        double offset = 20;\n+\n+        RichTextAreaWindow w = new RichTextAreaWindow(useContentSize);\n+        w.setX(getX() + offset);\n+        w.setY(getY() + offset);\n+        w.setWidth(getWidth());\n+        w.setHeight(getHeight());\n+        w.show();\n+    }\n+\n+    protected void openMultipeStacked(boolean vertical) {\n+        new MultipleStackedBoxWindow(vertical).show();\n+    }\n+\n+    protected void openInVBox() {\n+        RichTextArea richTextArea = new RichTextArea();\n+\n+        VBox vb = new VBox();\n+        vb.getChildren().add(richTextArea);\n+\n+        Stage w = new Stage();\n+        w.setScene(new Scene(vb));\n+        w.setTitle(\"RichTextArea in a VBox\");\n+        w.show();\n+    }\n+\n+    protected void openCssTool() {\n+        Stage w = new Stage();\n+        w.setScene(new Scene(new CssToolPane()));\n+        w.setTitle(\"CSS Tool\");\n+        w.setWidth(800);\n+        w.setHeight(600);\n+        w.show();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/RichTextAreaWindow.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+import java.util.Random;\n+import jfx.incubator.scene.control.richtext.model.SimpleViewOnlyStyledModel;\n+\n+public class UnevenStyledTextModel extends SimpleViewOnlyStyledModel {\n+    private Random r = new Random();\n+\n+    public UnevenStyledTextModel(int lineCount) {\n+        float longLineProbability = 0.1f;\n+        for (int i = 0; i < lineCount; i++) {\n+            boolean large = (r.nextFloat() < longLineProbability);\n+            addSegment((large ? \"L.\" : \"S.\") + (i + 1));\n+\n+            if (large) {\n+                add(1000);\n+            } else {\n+                add(10);\n+            }\n+            nl();\n+        }\n+    }\n+\n+    private void add(int count) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        for (int i = 0; i < count; i++) {\n+            int len = r.nextInt(10) + 1;\n+            sb.append(' ');\n+            sb.append(i);\n+            sb.append('.');\n+\n+            for (int j = 0; j < len; j++) {\n+                sb.append('*');\n+            }\n+        }\n+\n+        addSegment(sb.toString());\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/UnevenStyledTextModel.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.oracle.demo.richtext.rta;\n+\n+import javafx.application.Application;\n+import javafx.scene.Scene;\n+import javafx.scene.input.KeyCode;\n+import javafx.stage.Stage;\n+import jfx.incubator.scene.control.input.FunctionTag;\n+import jfx.incubator.scene.control.input.KeyBinding;\n+import jfx.incubator.scene.control.richtext.CodeArea;\n+import jfx.incubator.scene.control.richtext.LineNumberDecorator;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.SimpleViewOnlyStyledModel;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * The usage examples used in the documentation.\n+ *\/\n+public class UsageExamples {\n+    void createViewOnly() {\n+        SimpleViewOnlyStyledModel m = new SimpleViewOnlyStyledModel();\n+        \/\/ add text segment using CSS style name (requires a stylesheet)\n+        m.withStyles(\"RichTextArea \", \"HEADER\");\n+        \/\/ add text segment using inline style\n+        m.withInlineStyle(\"Demo\", \"-fx-font-size:200%;\");\n+        \/\/ newline\n+        m.nl();\n+\n+        RichTextArea textArea = new RichTextArea(m);\n+    }\n+\n+    static RichTextArea appendStyledText() {\n+        \/\/ create styles\n+        StyleAttributeMap heading = StyleAttributeMap.builder().setBold(true).setUnderline(true).setFontSize(18).build();\n+        StyleAttributeMap mono = StyleAttributeMap.builder().setFontFamily(\"Monospaced\").build();\n+\n+        RichTextArea textArea = new RichTextArea();\n+        \/\/ build the content\n+        textArea.appendText(\"RichTextArea\\n\", heading);\n+        textArea.appendText(\"Example:\\nText is \", StyleAttributeMap.EMPTY);\n+        textArea.appendText(\"monospaced.\\n\", mono);\n+        return textArea;\n+    }\n+\n+    void richTextAreaExample() {\n+        RichTextArea textArea = new RichTextArea();\n+        \/\/ insert two paragraphs \"A\" and \"B\"\n+        StyleAttributeMap bold = StyleAttributeMap.builder().setBold(true).build();\n+        textArea.appendText(\"A\\nB\", bold);\n+    }\n+\n+    private static CodeArea codeAreaExample() {\n+        CodeArea codeArea = new CodeArea();\n+        codeArea.setWrapText(true);\n+        codeArea.setLineNumbersEnabled(true);\n+        codeArea.setText(\"Lorem\\nIpsum\");\n+        return codeArea;\n+    }\n+\n+    private static final FunctionTag PRINT_TO_CONSOLE = new FunctionTag();\n+\n+    void customNavigation() {\n+        RichTextArea richTextArea = new RichTextArea();\n+\n+        \/\/ creates a new key binding mapped to an external function\n+        richTextArea.getInputMap().register(KeyBinding.shortcut(KeyCode.W), () -> {\n+            System.out.println(\"console!\");\n+        });\n+\n+        \/\/ unbind old key bindings\n+        var old = richTextArea.getInputMap().getKeyBindingsFor(RichTextArea.Tags.PASTE_PLAIN_TEXT);\n+        for (KeyBinding k : old) {\n+            richTextArea.getInputMap().unbind(k);\n+        }\n+        \/\/ map a new key binding\n+        richTextArea.getInputMap().registerKey(KeyBinding.shortcut(KeyCode.W), RichTextArea.Tags.PASTE_PLAIN_TEXT);\n+\n+        \/\/ redefine a function\n+        richTextArea.getInputMap().registerFunction(RichTextArea.Tags.PASTE_PLAIN_TEXT, () -> { });\n+        richTextArea.pastePlainText(); \/\/ becomes a no-op\n+        \/\/ revert back to the default behavior\n+        richTextArea.getInputMap().restoreDefaultFunction(RichTextArea.Tags.PASTE_PLAIN_TEXT);\n+\n+        \/\/ sets a side decorator\n+        richTextArea.setLeftDecorator(new LineNumberDecorator());\n+\n+        richTextArea.getInputMap().registerFunction(PRINT_TO_CONSOLE, () -> {\n+            \/\/ new functionality\n+            System.out.println(\"PRINT_TO_CONSOLE executed\");\n+        });\n+\n+        \/\/ change the functionality of an existing key binding\n+        richTextArea.getInputMap().registerFunction(RichTextArea.Tags.MOVE_WORD_NEXT_START, () -> {\n+            \/\/ refers to custom logic\n+            TextPos p = getCustomNextWordPosition(richTextArea);\n+            richTextArea.select(p);\n+        });\n+    }\n+\n+    void testGeneric() {\n+        MyControl c = new MyControl();\n+        c.getInputMap().registerFunction(MyControl.MY_TAG, () -> {\n+            c.newFunctionImpl();\n+        });\n+    }\n+\n+    private TextPos getCustomNextWordPosition(RichTextArea richTextArea) {\n+        return null;\n+    }\n+\n+    public static class MyControl extends RichTextArea {\n+        \/\/ function tag allows the user to customize key bindings\n+        public static final FunctionTag MY_TAG = new FunctionTag();\n+\n+        public MyControl() {\n+            \/\/ register custom functionality with the input map\n+            getInputMap().registerFunction(MY_TAG, this::newFunctionImpl);\n+            \/\/ create a key binding\n+            getInputMap().registerKey(KeyBinding.shortcut(KeyCode.W), MY_TAG);\n+        }\n+\n+        public void newFunctionImpl() {\n+            \/\/ custom functionality\n+        }\n+    }\n+\n+    public static class App extends Application {\n+        public App() {\n+            System.out.println(\"test app: F1 appends at the end, F2 inserts at the start, F3 clears selection.\");\n+        }\n+\n+        @Override\n+        public void start(Stage stage) throws Exception {\n+            RichTextArea t = true ? appendStyledText() : codeAreaExample();\n+            stage.setScene(new Scene(t));\n+            t.selectionProperty().addListener((s,p,c) -> {\n+                System.out.println(\"selection: \" + c);\n+            });\n+            t.anchorPositionProperty().addListener((s,p,c) -> {\n+                System.out.println(\"anchor: \" + c);\n+            });\n+            t.caretPositionProperty().addListener((s,p,c) -> {\n+                System.out.println(\"caret: \" + c);\n+            });\n+            t.getInputMap().register(KeyBinding.of(KeyCode.F1), () -> {\n+                t.insertText(TextPos.ZERO, \"F1\", StyleAttributeMap.EMPTY);\n+            });\n+            t.getInputMap().register(KeyBinding.of(KeyCode.F2), () -> {\n+                t.insertText(TextPos.ZERO, \"\\n\", StyleAttributeMap.EMPTY);\n+            });\n+            t.getInputMap().register(KeyBinding.of(KeyCode.F3), () -> {\n+                t.clearSelection();\n+            });\n+            stage.show();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        App.launch(App.class, args);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/UsageExamples.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.rta;\n+\n+\/**\n+ * Sample text for testing writing systems support.\n+ * See https:\/\/en.wikipedia.org\/wiki\/List_of_writing_systems\n+ *\/\n+public class WritingSystemsDemo {\n+    public static final String[] PAIRS = {\n+        \"Arabic\", \"العربية\",\n+        \"Aramaic\", \"Classical Syriac: ܐܪܡܝܐ, Old Aramaic: 𐤀𐤓𐤌𐤉𐤀; Imperial Aramaic: 𐡀𐡓𐡌𐡉𐡀; Jewish Babylonian Aramaic: אֲרָמִית‎\",\n+        \"Akkadian\", \"𒀝𒅗𒁺𒌑\",\n+        \"Armenian\", \"հայերէն\/հայերեն\",\n+        \"Assamese\", \"অসমীয়া\",\n+        \"Awadhi\", \"अवधी\/औधी\",\n+        \"Azerbaijanis\", \"آذربایجانلیلار\",\n+        \"Bagheli\", \"बघेली\",\n+        \"Bagri\", \"बागड़ी, باگڑی\",\n+        \"Bengali\", \"বাংলা\",\n+        \"Bhojpuri\", \"𑂦𑂷𑂔𑂣𑂳𑂩𑂲\",\n+        \"Braille\", \"⠃⠗⠇\",\n+        \"Bundeli\", \"बुन्देली\",\n+        \"Burmese\", \"မြန်မာ\",\n+        \"Cherokee\", \"ᏣᎳᎩ ᎦᏬᏂᎯᏍᏗ\",\n+        \"Chhattisgarhi\", \"छत्तीसगढ़ी, ଛତିଶଗଡ଼ି, ଲରିଆ\",\n+        \"Chinese\", \"中文\",\n+        \"Czech\", \"Čeština\",\n+        \"Devanagari\", \"देवनागरी\",\n+        \"Dhivehi\", \"ދިވެހި\",\n+        \"Dhundhari\", \"ढूण्ढाड़ी\/ઢૂણ્ઢાડ઼ી\",\n+        \"Farsi\", \"فارسی\",\n+        \"Garhwali\", \"गढ़वळि\",\n+        \"Geʽez\", \"ግዕዝ\",\n+        \"Greek\", \"Ελληνικά\",\n+        \"Georgian\", \"ქართული\",\n+        \"Gujarati\", \"ગુજરાતી\",\n+        \"Harauti\", \"हाड़ौती, हाड़ोती\",\n+        \"Haryanvi\", \"हरयाणवी\",\n+        \"Hausa\", \"هَرْشٜن هَوْسَ\",\n+        \"Hebrew\", \"עברית\",\n+        \"Hindi\", \"हिन्दी\",\n+        \"Inuktitut\", \"ᐃᓄᒃᑎᑐᑦ\",\n+        \"Japanese\", \"日本語 かな カナ\",\n+        \"Kangri\", \"कांगड़ी\",\n+        \"Kannada\", \"ಕನ್ನಡ\",\n+        \"Kashmiri\", \"كٲشُرकॉशुर𑆑𑆳𑆯𑆶𑆫𑇀\",\n+        \"Khmer\", \"ខ្មែរ\",\n+        \"Khortha\", \"खोरठा\",\n+        \"Khowar\", \"کھووار زبان\",\n+        \"Korean\", \"한국어\",\n+        \"Kumaoni\", \"कुमाऊँनी\",\n+        \"Kurdish\", \"Kurdî \/ کوردی\",\n+        \"Magahi\", \"𑂧𑂏𑂯𑂲\/𑂧𑂏𑂡𑂲\",\n+        \"Maithili\", \"मैथिली\",\n+        \"Malayalam\", \"മലയാളം\",\n+        \"Malvi\", \"माळवी भाषा \/ માળવી ભાષા\",\n+        \"Marathi\", \"मराठी\",\n+        \"Marwari,\", \"मारवाड़ी\",\n+        \"Meitei\", \"ꯃꯩꯇꯩꯂꯣꯟ\",\n+        \"Mewari\", \"मेवाड़ी\/મેવ઼ાડ઼ી\",\n+        \"Mongolian\", \"ᠨᠢᠷᠤᠭᠤ\",\n+        \"Nimadi\", \"निमाड़ी\",\n+        \"Odia\", \"ଓଡ଼ିଆ\",\n+        \"Pahari\", \"पहाड़ी پہاڑی \",\n+        \"Pashto\", \"پښتو\",\n+        \"Punjabi\", \"ਪੰਜਾਬੀپن٘جابی\",\n+        \"Rajasthani\", \"राजस्थानी\",\n+        \"Russian\", \"Русский\",\n+        \"Sanskrit\", \"संस्कृत-, संस्कृतम्\",\n+        \"Santali\", \"ᱥᱟᱱᱛᱟᱲᱤ\",\n+        \"Sindhi\", \"سِنڌِي‎ • सिन्धी\",\n+        \"Suret\", \"ܣܘܪܝܬ\",\n+        \"Surgujia\", \"सरगुजिया\",\n+        \"Surjapuri\", \"सुरजापुरी, সুরজাপুরী\",\n+        \"Tamil\", \"தமிழ்\",\n+        \"Telugu\", \"తెలుగు\",\n+        \"Thaana\", \"ދިވެހި\",\n+        \"Thai\", \"ไทย\",\n+        \"Tibetan\", \"བོད་\",\n+        \"Tulu\", \"ತುಳು\",\n+        \"Turoyo\", \"ܛܘܪܝܐ\",\n+        \"Ukrainian\", \"Українська\",\n+        \"Urdu\", \"اردو\",\n+        \"Vietnamese\", \"Tiếng Việt\",\n+        \"Yiddish\", \"ייִדיש יידיש  אידיש\"\n+    };\n+\n+    public static String getText() {\n+        return getText(false);\n+    }\n+\n+    public static String getText(boolean showUnicode) {\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < PAIRS.length;) {\n+            String a = PAIRS[i++];\n+            String b = PAIRS[i++];\n+            t(sb, a, b, showUnicode);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static void t(StringBuilder sb, String name, String text, boolean showUnicode) {\n+        sb.append(name);\n+        sb.append(\": \");\n+        sb.append(text);\n+        if (showUnicode) {\n+            sb.append(\" (\");\n+            native2ascii(sb, text);\n+            sb.append(\")\");\n+        }\n+        sb.append(\"\\n\");\n+    }\n+\n+    private static void native2ascii(StringBuilder sb, String text) {\n+        for (char c: text.toCharArray()) {\n+            if (c < 0x20) {\n+                escape(sb, c);\n+            } else if (c > 0x7f) {\n+                escape(sb, c);\n+            } else {\n+                sb.append(c);\n+            }\n+        }\n+    }\n+\n+    private static void escape(StringBuilder sb, char c) {\n+        sb.append(\"\\\\u\");\n+        sb.append(h(c >> 12));\n+        sb.append(h(c >> 8));\n+        sb.append(h(c >> 4));\n+        sb.append(h(c));\n+    }\n+\n+    private static char h(int d) {\n+        return \"0123456789abcdef\".charAt(d & 0x000f);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/WritingSystemsDemo.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/animated.gif","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,230 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxDock\n+package com.oracle.demo.richtext.settings;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import javafx.animation.KeyFrame;\n+import javafx.animation.Timeline;\n+import javafx.collections.ListChangeListener;\n+import javafx.scene.Node;\n+import javafx.stage.Modality;\n+import javafx.stage.PopupWindow;\n+import javafx.stage.Stage;\n+import javafx.stage.Window;\n+import javafx.util.Duration;\n+\n+\/**\n+ * This facility coordinates saving UI settings to and from persistent media.\n+ * All the calls, except useProvider(), are expected to happen in an FX application thread.\n+ *\n+ * When using {@link FxSettingsFileProvider}, the settings file \"ui-settings.properties\"\n+ * is placed in the specified directory in the user home.\n+ *\n+ * TODO handle i\/o errors - set handler?\n+ *\/\n+public class FxSettings {\n+    public static final boolean LOG = Boolean.getBoolean(\"FxSettings.LOG\");\n+    private static final Duration SAVE_DELAY = Duration.millis(100);\n+    private static ISettingsProvider provider;\n+    private static boolean save;\n+    private static Timeline saveTimer;\n+\n+    \/** call this in Application.init() *\/\n+    public static synchronized void useProvider(ISettingsProvider p) {\n+        if (provider != null) {\n+            throw new IllegalArgumentException(\"provider is already set\");\n+        }\n+\n+        provider = p;\n+\n+        Window.getWindows().addListener((ListChangeListener.Change<? extends Window> ch) -> {\n+            while (ch.next()) {\n+                if (ch.wasAdded()) {\n+                    for (Window w: ch.getAddedSubList()) {\n+                        handleWindowOpening(w);\n+                    }\n+                } else if (ch.wasRemoved()) {\n+                    for (Window w: ch.getRemoved()) {\n+                        handleWindowClosing(w);\n+                    }\n+                }\n+            }\n+        });\n+\n+        try {\n+            provider.load();\n+        } catch (IOException e) {\n+            throw new Error(e);\n+        }\n+\n+        saveTimer = new Timeline(new KeyFrame(SAVE_DELAY, (ev) -> save()));\n+    }\n+\n+    public static void useDirectory(String dir) {\n+        File d = new File(System.getProperty(\"user.home\"), dir);\n+        useProvider(new FxSettingsFileProvider(d));\n+    }\n+\n+    public static void setName(Window w, String name) {\n+        \/\/ TODO\n+    }\n+\n+    private static void handleWindowOpening(Window w) {\n+        if (w instanceof PopupWindow) {\n+            return;\n+        }\n+\n+        if (w instanceof Stage s) {\n+            if (s.getModality() != Modality.NONE) {\n+                return;\n+            }\n+        }\n+\n+        restoreWindow(w);\n+    }\n+\n+    public static void restoreWindow(Window w) {\n+        WindowMonitor m = WindowMonitor.getFor(w);\n+        if (m != null) {\n+            FxSettingsSchema.restoreWindow(m, w);\n+\n+            Node p = w.getScene().getRoot();\n+            FxSettingsSchema.restoreNode(p);\n+        }\n+    }\n+\n+    private static void handleWindowClosing(Window w) {\n+        if (w instanceof PopupWindow) {\n+            return;\n+        }\n+\n+        storeWindow(w);\n+\n+        boolean last = WindowMonitor.remove(w);\n+        if (last) {\n+            if (saveTimer != null) {\n+                saveTimer.stop();\n+                save();\n+            }\n+        }\n+    }\n+\n+    public static void storeWindow(Window w) {\n+        WindowMonitor m = WindowMonitor.getFor(w);\n+        if (m != null) {\n+            FxSettingsSchema.storeWindow(m, w);\n+\n+            Node p = w.getScene().getRoot();\n+            FxSettingsSchema.storeNode(p);\n+        }\n+    }\n+\n+    public static void set(String key, String value) {\n+        if (provider != null) {\n+            provider.set(key, value);\n+            triggerSave();\n+        }\n+    }\n+\n+    public static String get(String key) {\n+        if (provider == null) {\n+            return null;\n+        }\n+        return provider.get(key);\n+    }\n+\n+    public static void setStream(String key, SStream s) {\n+        if (provider != null) {\n+            provider.set(key, s);\n+            triggerSave();\n+        }\n+    }\n+\n+    public static SStream getStream(String key) {\n+        if (provider == null) {\n+            return null;\n+        }\n+        return provider.getSStream(key);\n+    }\n+\n+    public static void setInt(String key, int value) {\n+        set(key, String.valueOf(value));\n+    }\n+\n+    public static int getInt(String key, int defaultValue) {\n+        String v = get(key);\n+        if (v != null) {\n+            try {\n+                return Integer.parseInt(v);\n+            } catch (NumberFormatException e) {\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    public static void setBoolean(String key, boolean value) {\n+        set(key, String.valueOf(value));\n+    }\n+\n+    public static Boolean getBoolean(String key) {\n+        String v = get(key);\n+        if (v != null) {\n+            if (\"true\".equals(v)) {\n+                return Boolean.TRUE;\n+            } else if (\"false\".equals(v)) {\n+                return Boolean.FALSE;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static synchronized void triggerSave() {\n+        save = true;\n+        if (saveTimer != null) {\n+            saveTimer.stop();\n+            saveTimer.play();\n+        }\n+    }\n+\n+    private static void save() {\n+        try {\n+            save = false;\n+            provider.save();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public static void restore(Node n) {\n+        FxSettingsSchema.restoreNode(n);\n+    }\n+\n+    public static void store(Node n) {\n+        FxSettingsSchema.storeNode(n);\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/settings\/FxSettings.java","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxDock\n+package com.oracle.demo.richtext.settings;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+\n+\/**\n+ * Settings provider stores settings as a single file in the specified directory.\n+ *\/\n+public class FxSettingsFileProvider implements ISettingsProvider {\n+    private static final char SEP = '=';\n+    private static final String DIV = \",\";\n+    private final File file;\n+    private final HashMap<String, Object> data = new HashMap<>();\n+\n+    public FxSettingsFileProvider(File dir) {\n+        file = new File(dir, \"ui-settings.properties\");\n+    }\n+\n+    @Override\n+    public void load() throws IOException {\n+        if (file.exists() && file.isFile()) {\n+            Charset cs = Charset.forName(\"utf-8\");\n+            try (BufferedReader rd = new BufferedReader(new InputStreamReader(new FileInputStream(file), cs))) {\n+                synchronized (data) {\n+                    read(rd);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void save() throws IOException {\n+        if (file.getParentFile() != null) {\n+            file.getParentFile().mkdirs();\n+        }\n+\n+        Charset cs = Charset.forName(\"utf-8\");\n+        try (Writer wr = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), cs))) {\n+            synchronized (data) {\n+                write(wr);\n+            }\n+        }\n+    }\n+\n+    private void read(BufferedReader rd) throws IOException {\n+        String s;\n+        while ((s = rd.readLine()) != null) {\n+            int ix = s.indexOf(SEP);\n+            if (ix <= 0) {\n+                continue;\n+            }\n+            String k = s.substring(0, ix);\n+            String v = s.substring(ix + 1);\n+            data.put(k, v);\n+        }\n+    }\n+\n+    private void write(Writer wr) throws IOException {\n+        ArrayList<String> keys = new ArrayList<>(data.keySet());\n+        Collections.sort(keys);\n+\n+        for (String k: keys) {\n+            Object v = data.get(k);\n+            wr.write(k);\n+            wr.write(SEP);\n+            wr.write(encode(v));\n+            wr.write(\"\\r\\n\");\n+        }\n+    }\n+\n+    @Override\n+    public void set(String key, String value) {\n+        if (FxSettings.LOG) {\n+            System.out.println(\"FxSettingsFileProvider.set key=\" + key + \" value=\" + value);\n+        }\n+        synchronized (data) {\n+            if (value == null) {\n+                data.remove(key);\n+            } else {\n+                data.put(key, value);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void set(String key, SStream stream) {\n+        if (FxSettings.LOG) {\n+            System.out.println(\"FxSettingsFileProvider.set key=\" + key + \" stream=\" + stream);\n+        }\n+        synchronized (data) {\n+            if (stream == null) {\n+                data.remove(key);\n+            } else {\n+                data.put(key, stream.toArray());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String get(String key) {\n+        Object v;\n+        synchronized (data) {\n+            v = data.get(key);\n+        }\n+\n+        String s;\n+        if (v instanceof String) {\n+            s = (String)v;\n+        } else {\n+            s = null;\n+        }\n+\n+        if (FxSettings.LOG) {\n+            System.out.println(\"FxSettingsFileProvider.get key=\" + key + \" value=\" + s);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public SStream getSStream(String key) {\n+        SStream s;\n+        synchronized (data) {\n+            Object v = data.get(key);\n+            if (v instanceof Object[]) {\n+                s = SStream.reader((Object[])v);\n+            } else if (v != null) {\n+                s = parseStream(v.toString());\n+                data.put(key, s.toArray());\n+            } else {\n+                s = null;\n+            }\n+        }\n+\n+        if (FxSettings.LOG) {\n+            System.out.println(\"FxSettingsFileProvider.get key=\" + key + \" stream=\" + s);\n+        }\n+        return s;\n+    }\n+\n+    private static SStream parseStream(String text) {\n+        String[] ss = text.split(DIV);\n+        return SStream.reader(ss);\n+    }\n+\n+    private static String encode(Object x) {\n+        if (x == null) {\n+            return \"\";\n+        } else if (x instanceof Object[] items) {\n+            StringBuilder sb = new StringBuilder();\n+            boolean sep = false;\n+            for (Object item: items) {\n+                if (sep) {\n+                    sb.append(DIV);\n+                } else {\n+                    sep = true;\n+                }\n+                sb.append(item);\n+            }\n+            return sb.toString();\n+        } else {\n+            return x.toString();\n+        }\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/settings\/FxSettingsFileProvider.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,478 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxDock\n+package com.oracle.demo.richtext.settings;\n+\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.Group;\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+import javafx.scene.Scene;\n+import javafx.scene.control.CheckBox;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.DialogPane;\n+import javafx.scene.control.ListView;\n+import javafx.scene.control.MenuBar;\n+import javafx.scene.control.ScrollPane;\n+import javafx.scene.control.SplitPane;\n+import javafx.scene.image.ImageView;\n+import javafx.scene.layout.AnchorPane;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.FlowPane;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.layout.Region;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.layout.TilePane;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.shape.Shape;\n+import javafx.stage.Screen;\n+import javafx.stage.Stage;\n+import javafx.stage.Window;\n+\n+\/**\n+ * Constants and methods used to persist settings.\n+ *\/\n+public class FxSettingsSchema {\n+    private static final String PREFIX = \"FX.\";\n+    private static final String WINDOW_NORMAL = \"N\";\n+    private static final String WINDOW_ICONIFIED = \"I\";\n+    private static final String WINDOW_MAXIMIZED = \"M\";\n+    private static final String WINDOW_FULLSCREEN = \"F\";\n+    private static final Object NAME_PROP = new Object();\n+\n+    public static void storeWindow(WindowMonitor m, Window w) {\n+        SStream ss = SStream.writer();\n+        ss.add(m.getX());\n+        ss.add(m.getY());\n+        ss.add(m.getWidth());\n+        ss.add(m.getHeight());\n+        if (w instanceof Stage s) {\n+            if (s.isIconified()) {\n+                ss.add(WINDOW_ICONIFIED);\n+            } else if (s.isMaximized()) {\n+                ss.add(WINDOW_MAXIMIZED);\n+            } else if (s.isFullScreen()) {\n+                ss.add(WINDOW_FULLSCREEN);\n+            } else {\n+                ss.add(WINDOW_NORMAL);\n+            }\n+        }\n+        FxSettings.setStream(PREFIX + m.getID(), ss);\n+    }\n+\n+    public static void restoreWindow(WindowMonitor m, Window win) {\n+        SStream ss = FxSettings.getStream(PREFIX + m.getID());\n+        if (ss == null) {\n+            return;\n+        }\n+\n+        double x = ss.nextDouble(-1);\n+        double y = ss.nextDouble(-1);\n+        double w = ss.nextDouble(-1);\n+        double h = ss.nextDouble(-1);\n+        String t = ss.nextString(WINDOW_NORMAL);\n+\n+        if ((w > 0) && (h > 0)) {\n+            if (isValid(x, y)) {\n+                win.setX(x);\n+                win.setY(y);\n+            }\n+\n+            if (win instanceof Stage s) {\n+                if (s.isResizable()) {\n+                    s.setWidth(w);\n+                    s.setHeight(h);\n+                }\n+\n+                switch (t) {\n+                case WINDOW_FULLSCREEN:\n+                    s.setFullScreen(true);\n+                    break;\n+                case WINDOW_MAXIMIZED:\n+                    s.setMaximized(true);\n+                    break;\n+                \/\/ TODO iconified?\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean isValid(double x, double y) {\n+        for (Screen s: Screen.getScreens()) {\n+            Rectangle2D r = s.getVisualBounds();\n+            if (r.contains(x, y)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static String computeName(Node n) {\n+        WindowMonitor m = WindowMonitor.getFor(n);\n+        if (m == null) {\n+            return null;\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        if (collectNames(sb, n)) {\n+            return null;\n+        }\n+\n+        String id = m.getID();\n+        return id + sb;\n+    }\n+\n+    \/\/ returns true if Node should be ignored\n+    private static boolean collectNames(StringBuilder sb, Node n) {\n+        if (n instanceof MenuBar) {\n+            return true;\n+        } else if (n instanceof Shape) {\n+            return true;\n+        } else if (n instanceof ImageView) {\n+            return true;\n+        }\n+\n+        Parent p = n.getParent();\n+        if (p != null) {\n+            if (collectNames(sb, p)) {\n+                return true;\n+            }\n+        }\n+\n+        String name = getNodeName(n);\n+        if (name == null) {\n+            return true;\n+        }\n+\n+        sb.append('.');\n+        sb.append(name);\n+        return false;\n+    }\n+\n+    private static String getNodeName(Node n) {\n+        if (n != null) {\n+            String name = getName(n);\n+            if (name != null) {\n+                return name;\n+            }\n+\n+            if (n instanceof Pane) {\n+                if (n instanceof AnchorPane) {\n+                    return \"AnchorPane\";\n+                } else if (n instanceof BorderPane) {\n+                    return \"BorderPane\";\n+                } else if (n instanceof DialogPane) {\n+                    return \"DialogPane\";\n+                } else if (n instanceof FlowPane) {\n+                    return \"FlowPane\";\n+                } else if (n instanceof GridPane) {\n+                    return \"GridPane\";\n+                } else if (n instanceof HBox) {\n+                    return \"HBox\";\n+                } else if (n instanceof StackPane) {\n+                    return \"StackPane\";\n+                } else if (n instanceof TilePane) {\n+                    return \"TilePane\";\n+                } else if (n instanceof VBox) {\n+                    return \"VBox\";\n+                } else {\n+                    return \"Pane\";\n+                }\n+            } else if (n instanceof Group) {\n+                return \"Group\";\n+            } else if (n instanceof Region) {\n+                return \"Region\";\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public static void storeNode(Node n) {\n+        if (n instanceof ListView lv) {\n+            storeListView(lv);\n+            return;\n+        } else if (n instanceof ComboBox cb) {\n+            storeComboBox(cb);\n+            return;\n+        } else if (n instanceof CheckBox cb) {\n+            storeCheckBox(cb);\n+            return;\n+        } else if (n instanceof SplitPane sp) {\n+            storeSplitPane(sp);\n+            return;\n+        } else if (n instanceof ScrollPane sp) {\n+            storeNode(sp.getContent());\n+            return;\n+        }\n+\n+        if (n instanceof Parent p) {\n+            for (Node ch: p.getChildrenUnmodifiable()) {\n+                storeNode(ch);\n+            }\n+        }\n+    }\n+\n+    public static void restoreNode(Node n) {\n+        if (checkNoScene(n)) {\n+            return;\n+        }\n+\n+        if (n instanceof ListView lv) {\n+            restoreListView(lv);\n+        } else if (n instanceof ComboBox cb) {\n+            restoreComboBox(cb);\n+        } else if (n instanceof CheckBox cb) {\n+            restoreCheckBox(cb);\n+        } else if (n instanceof SplitPane sp) {\n+            restoreSplitPane(sp);\n+        } else if (n instanceof ScrollPane sp) {\n+            restoreNode(sp.getContent());\n+        }\n+\n+        if (n instanceof Parent p) {\n+            for (Node ch: p.getChildrenUnmodifiable()) {\n+                restoreNode(ch);\n+            }\n+        }\n+    }\n+\n+    private static void storeSplitPane(SplitPane sp) {\n+        double[] div = sp.getDividerPositions();\n+        SStream ss = SStream.writer();\n+        ss.add(div.length);\n+        for (int i = 0; i < div.length; i++) {\n+            ss.add(div[i]);\n+        }\n+        String name = computeName(sp);\n+        FxSettings.setStream(PREFIX + name, ss);\n+\n+        for (Node ch: sp.getItems()) {\n+            storeNode(ch);\n+        }\n+    }\n+\n+    private static void restoreSplitPane(SplitPane sp) {\n+        for (Node ch: sp.getItems()) {\n+            restoreNode(ch);\n+        }\n+\n+        \/** FIX getting smaller and smaller\n+        String name = getName(m, sp);\n+        SStream ss = FxSettings.getStream(PREFIX + name);\n+        if (ss != null) {\n+            int ct = ss.nextInt(-1);\n+            if (ct > 0) {\n+                for (int i = 0; i < ct; i++) {\n+                    double div = ss.nextDouble(-1);\n+                    if (div < 0) {\n+                        break;\n+                    }\n+                    sp.setDividerPosition(i, div);\n+                }\n+            }\n+        }\n+        *\/\n+    }\n+\n+    private static void storeComboBox(ComboBox n) {\n+        if (n.getSelectionModel() == null) {\n+            return;\n+        }\n+\n+        int ix = n.getSelectionModel().getSelectedIndex();\n+        if (ix < 0) {\n+            return;\n+        }\n+\n+        String name = computeName(n);\n+        if (name == null) {\n+            return;\n+        }\n+\n+        FxSettings.setInt(PREFIX + name, ix);\n+    }\n+\n+    \/\/ TODO perhaps operate with selection model instead\n+    private static void restoreComboBox(ComboBox n) {\n+        if (n.getSelectionModel() == null) {\n+            return;\n+        }\n+\n+        if (checkNoScene(n)) {\n+            return;\n+        }\n+\n+        String name = computeName(n);\n+        if (name == null) {\n+            return;\n+        }\n+\n+        int ix = FxSettings.getInt(PREFIX + name, -1);\n+        if (ix < 0) {\n+            return;\n+        } else if (ix >= n.getItems().size()) {\n+            return;\n+        }\n+\n+        n.getSelectionModel().select(ix);\n+    }\n+\n+    private static boolean checkNoScene(Node node) {\n+        if (node == null) {\n+            return true;\n+        } else if (node.getScene() == null) {\n+            \/\/ delay restore until node becomes a part of the scene\n+            node.sceneProperty().addListener(new ChangeListener<Scene>() {\n+                @Override\n+                public void changed(ObservableValue<? extends Scene> src, Scene old, Scene scene) {\n+                    if (scene != null) {\n+                        Window w = scene.getWindow();\n+                        if (w != null) {\n+                            node.sceneProperty().removeListener(this);\n+                            restoreNode(node);\n+                        }\n+                    }\n+                }\n+            });\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private static void storeListView(ListView n) {\n+        if (n.getSelectionModel() == null) {\n+            return;\n+        }\n+\n+        int ix = n.getSelectionModel().getSelectedIndex();\n+        if (ix < 0) {\n+            return;\n+        }\n+\n+        String name = computeName(n);\n+        if (name == null) {\n+            return;\n+        }\n+\n+        FxSettings.setInt(PREFIX + name, ix);\n+    }\n+\n+    private static void restoreListView(ListView n) {\n+        if (n.getSelectionModel() == null) {\n+            return;\n+        }\n+\n+        if (checkNoScene(n)) {\n+            return;\n+        }\n+\n+        String name = computeName(n);\n+        if (name == null) {\n+            return;\n+        }\n+\n+        int ix = FxSettings.getInt(PREFIX + name, -1);\n+        if (ix < 0) {\n+            return;\n+        } else if (ix >= n.getItems().size()) {\n+            return;\n+        }\n+\n+        n.getSelectionModel().select(ix);\n+    }\n+\n+    private static void storeCheckBox(CheckBox n) {\n+        String name = computeName(n);\n+        if (name == null) {\n+            return;\n+        }\n+\n+        boolean sel = n.isSelected();\n+        FxSettings.setBoolean(PREFIX + name, sel);\n+    }\n+\n+    private static void restoreCheckBox(CheckBox n) {\n+        if (checkNoScene(n)) {\n+            return;\n+        }\n+\n+        String name = computeName(n);\n+        if (name == null) {\n+            return;\n+        }\n+\n+        Boolean sel = FxSettings.getBoolean(PREFIX + name);\n+        if (sel == null) {\n+            return;\n+        }\n+\n+        n.setSelected(sel);\n+    }\n+\n+    \/** sets the name for the purposes of storing user preferences *\/\n+    public static void setName(Node n, String name) {\n+        n.getProperties().put(NAME_PROP, name);\n+    }\n+\n+    \/** sets the name for the purposes of storing user preferences *\/\n+    public static void setName(Window w, String name) {\n+        w.getProperties().put(NAME_PROP, name);\n+    }\n+\n+    \/**\n+     * Returns the name for the purposes of storing user preferences,\n+     * set previously by {@link #setName(Node, String)},\n+     * or null.\n+     *\/\n+    public static String getName(Node n) {\n+        if (n != null) {\n+            Object x = n.getProperties().get(NAME_PROP);\n+            if (x instanceof String s) {\n+                return s;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the name for the purposes of storing user preferences,\n+     * set previously by {@link #setName(Window, String)},\n+     * or null.\n+     *\/\n+    public static String getName(Window w) {\n+        if (w != null) {\n+            Object x = w.getProperties().get(NAME_PROP);\n+            if (x instanceof String s) {\n+                return s;\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/settings\/FxSettingsSchema.java","additions":478,"deletions":0,"binary":false,"changes":478,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxDock\n+package com.oracle.demo.richtext.settings;\n+\n+import java.io.IOException;\n+\n+\/**\n+ * Defines the interface for storing and loading of settings.\n+ *\/\n+public interface ISettingsProvider {\n+    \/**\n+     * Loads settings from persistent storage, if needed.\n+     * @throws IOException\n+     *\/\n+    public void load() throws IOException;\n+\n+    \/**\n+     * Saves the settings to persistent media, if needed.\n+     * @throws IOException\n+     *\/\n+    public void save() throws IOException;\n+\n+    \/**\n+     * Sets a key-value pair.\n+     *\/\n+    public void set(String key, String value);\n+\n+    \/**\n+     * Sets a key-value pair where value is a SStream.\n+     *\/\n+    public void set(String key, SStream s);\n+\n+    \/**\n+     * Retrieves a String value for the specific key\n+     *\/\n+    public String get(String key);\n+\n+    \/**\n+     * Retrieves a SStream value for the specific key\n+     *\/\n+    public SStream getSStream(String key);\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/settings\/ISettingsProvider.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.settings;\n+\n+import java.util.ArrayList;\n+\n+\/**\n+ * Represents a string property as a stream of objects.\n+ *\/\n+public abstract class SStream {\n+\n+    public abstract Object[] toArray();\n+\n+    private SStream() {\n+    }\n+\n+    public static SStream writer() {\n+        return new SStream() {\n+            private ArrayList<Object> items = new ArrayList<>();\n+\n+            @Override\n+            protected void addValue(Object x) {\n+                items.add(x);\n+            }\n+\n+            @Override\n+            public Object[] toArray() {\n+                return items.toArray();\n+            }\n+        };\n+    }\n+\n+    public static SStream reader(Object[] items) {\n+        return new SStream() {\n+            int index;\n+\n+            @Override\n+            protected Object nextValue() {\n+                if (index >= items.length) {\n+                    return null;\n+                }\n+                return items[index++];\n+            }\n+\n+            @Override\n+            public Object[] toArray() {\n+                return items;\n+            }\n+        };\n+    }\n+\n+    public void add(int x) {\n+        addValue(x);\n+    }\n+\n+    public void add(double x) {\n+        addValue(x);\n+    }\n+\n+    public void add(String x) {\n+        addValue(x);\n+    }\n+\n+    protected void addValue(Object x) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    protected Object nextValue() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public final String nextString(String defaultValue) {\n+        Object v = nextValue();\n+        if (v instanceof String s) {\n+            return s;\n+        }\n+        return defaultValue;\n+    }\n+\n+    public final double nextDouble(double defaultValue) {\n+        Object v = nextValue();\n+        if (v instanceof String s) {\n+            try {\n+                return Double.parseDouble(s);\n+            } catch (NumberFormatException e) {\n+                \/\/ ignore\n+            }\n+        } else if (v instanceof Double d) {\n+            return d;\n+        }\n+        return defaultValue;\n+    }\n+\n+    public final int nextInt(int defaultValue) {\n+        Object v = nextValue();\n+        if (v instanceof String s) {\n+            try {\n+                return Integer.parseInt(s);\n+            } catch (NumberFormatException e) {\n+                \/\/ ignore\n+            }\n+        } else if (v instanceof Integer d) {\n+            return d;\n+        }\n+        return defaultValue;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(64);\n+        sb.append(\"[\");\n+        boolean sep = false;\n+        for (Object x: toArray()) {\n+            if (sep) {\n+                sb.append(\",\");\n+            } else {\n+                sep = true;\n+            }\n+            sb.append(x);\n+        }\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/settings\/SStream.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/FxDock\n+package com.oracle.demo.richtext.settings;\n+\n+import java.util.HashSet;\n+import java.util.WeakHashMap;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.stage.Stage;\n+import javafx.stage.Window;\n+\n+\/**\n+ * Stage does not keep track of its normal bounds when minimized, maximized, or switched to full screen.\n+ *\/\n+class WindowMonitor {\n+    private final String id;\n+    private double x;\n+    private double y;\n+    private double width;\n+    private double height;\n+    private double x2;\n+    private double y2;\n+    private double w2;\n+    private double h2;\n+    private static final WeakHashMap<Window, WindowMonitor> monitors = new WeakHashMap<>(4);\n+\n+    public WindowMonitor(Window w, String id) {\n+        this.id = id;\n+\n+        x = w.getX();\n+        y = w.getY();\n+        width = w.getWidth();\n+        height = w.getHeight();\n+\n+        w.xProperty().addListener((p) -> updateX(w));\n+        w.yProperty().addListener((p) -> updateY(w));\n+        w.widthProperty().addListener((p) -> updateWidth(w));\n+        w.heightProperty().addListener((p) -> updateHeight(w));\n+\n+        if (w instanceof Stage s) {\n+            s.iconifiedProperty().addListener((p) -> updateIconified(s));\n+            s.maximizedProperty().addListener((p) -> updateMaximized(s));\n+            s.fullScreenProperty().addListener((p) -> updateFullScreen(s));\n+        }\n+    }\n+\n+    public String getID() {\n+        return id;\n+    }\n+\n+    public double getX() {\n+        return x;\n+    }\n+\n+    public double getY() {\n+        return y;\n+    }\n+\n+    public double getWidth() {\n+        return width;\n+    }\n+\n+    public double getHeight() {\n+        return height;\n+    }\n+\n+    private void updateX(Window w) {\n+        x2 = x;\n+        x = w.getX();\n+    }\n+\n+    private void updateY(Window w) {\n+        y2 = y;\n+        y = w.getY();\n+    }\n+\n+    private void updateWidth(Window w) {\n+        w2 = width;\n+        width = w.getWidth();\n+    }\n+\n+    private void updateHeight(Window w) {\n+        h2 = height;\n+        height = w.getHeight();\n+    }\n+\n+    private void updateIconified(Stage s) {\n+        if (s.isIconified()) {\n+            x = x2;\n+            y = y2;\n+        }\n+    }\n+\n+    private void updateMaximized(Stage s) {\n+        if (s.isMaximized()) {\n+            x = x2;\n+            y = y2;\n+        }\n+    }\n+\n+    private void updateFullScreen(Stage s) {\n+        if (s.isFullScreen()) {\n+            x = x2;\n+            y = y2;\n+            width = w2;\n+            height = h2;\n+        }\n+    }\n+\n+    public static WindowMonitor getFor(Window w) {\n+        if (w == null) {\n+            return null;\n+        }\n+        WindowMonitor m = monitors.get(w);\n+        if (m == null) {\n+            String id = createID(w);\n+            if (id == null) {\n+                return null;\n+            }\n+            m = new WindowMonitor(w, id);\n+            monitors.put(w, m);\n+        }\n+        return m;\n+    }\n+\n+    public static WindowMonitor getFor(Node n) {\n+        Window w = windowFor(n);\n+        if (w != null) {\n+            return getFor(w);\n+        }\n+        return null;\n+    }\n+\n+    private static Window windowFor(Node n) {\n+        Scene sc = n.getScene();\n+        if (sc != null) {\n+            Window w = sc.getWindow();\n+            if (w != null) {\n+                return w;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static String createID(Window win) {\n+        String prefix = FxSettingsSchema.getName(win) + \".\";\n+        HashSet<String> ids = new HashSet<>();\n+        for (Window w: Window.getWindows()) {\n+            if (w == win) {\n+                continue;\n+            }\n+            WindowMonitor m = monitors.get(w);\n+            if (m == null) {\n+                return null;\n+            }\n+            String id = m.getID();\n+            if (id.startsWith(prefix)) {\n+                ids.add(id);\n+            }\n+        }\n+\n+        for (int i = 0; i < 100_000; i++) {\n+            String id = prefix + i;\n+            if (!ids.contains(id)) {\n+                return id;\n+            }\n+        }\n+\n+        \/\/ safeguard measure\n+        throw new Error(\"cannot create id: too many windows?\");\n+    }\n+\n+    public static boolean remove(Window w) {\n+        monitors.remove(w);\n+        return monitors.size() == 0;\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/settings\/WindowMonitor.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,441 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.demo.richtext.util;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javafx.application.Platform;\n+import javafx.css.PseudoClass;\n+import javafx.event.EventHandler;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.CheckMenuItem;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.Control;\n+import javafx.scene.control.Menu;\n+import javafx.scene.control.MenuBar;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.RadioMenuItem;\n+import javafx.scene.control.SeparatorMenuItem;\n+import javafx.scene.control.ToggleButton;\n+import javafx.scene.control.ToggleGroup;\n+import javafx.scene.control.ToolBar;\n+import javafx.scene.control.Tooltip;\n+import javafx.scene.input.KeyCombination;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Stage;\n+import javafx.stage.Window;\n+import com.oracle.demo.richtext.settings.FxSettingsSchema;\n+\n+\/**\n+ * Shortcuts and convenience methods that perhaps could be added to JavaFX.\n+ *\/\n+public class FX {\n+    public static Menu menu(MenuBar b, String text) {\n+        Menu m = new Menu(text);\n+        applyMnemonic(m);\n+        b.getMenus().add(m);\n+        return m;\n+    }\n+\n+    public static Menu menu(ContextMenu b, String text) {\n+        Menu m = new Menu(text);\n+        applyMnemonic(m);\n+        b.getItems().add(m);\n+        return m;\n+    }\n+\n+    public static MenuItem item(MenuBar b, String text, Runnable action) {\n+        MenuItem mi = new MenuItem(text);\n+        applyMnemonic(mi);\n+        mi.setOnAction((ev) -> action.run());\n+        lastMenu(b).getItems().add(mi);\n+        return mi;\n+    }\n+\n+    public static MenuItem item(MenuBar b, MenuItem mi) {\n+        applyMnemonic(mi);\n+        lastMenu(b).getItems().add(mi);\n+        return mi;\n+    }\n+\n+    public static MenuItem item(MenuBar b, String text) {\n+        MenuItem mi = new MenuItem(text);\n+        mi.setDisable(true);\n+        applyMnemonic(mi);\n+        lastMenu(b).getItems().add(mi);\n+        return mi;\n+    }\n+\n+    public static MenuItem item(MenuBar b, String text, FxAction a) {\n+        MenuItem mi = new MenuItem(text);\n+        applyMnemonic(mi);\n+        lastMenu(b).getItems().add(mi);\n+        a.attach(mi);\n+        return mi;\n+    }\n+\n+    public static CheckMenuItem checkItem(MenuBar b, String text, FxAction a) {\n+        CheckMenuItem mi = new CheckMenuItem(text);\n+        applyMnemonic(mi);\n+        lastMenu(b).getItems().add(mi);\n+        a.attach(mi);\n+        return mi;\n+    }\n+\n+    public static MenuItem item(ContextMenu cm, String text, FxAction a) {\n+        MenuItem mi = new MenuItem(text);\n+        applyMnemonic(mi);\n+        cm.getItems().add(mi);\n+        a.attach(mi);\n+        return mi;\n+    }\n+\n+    public static MenuItem item(ContextMenu cm, String text) {\n+        MenuItem mi = new MenuItem(text);\n+        mi.setDisable(true);\n+        applyMnemonic(mi);\n+        cm.getItems().add(mi);\n+        return mi;\n+    }\n+\n+    public static MenuItem item(Menu b, String text) {\n+        MenuItem mi = new MenuItem(text);\n+        mi.setDisable(true);\n+        applyMnemonic(mi);\n+        b.getItems().add(mi);\n+        return mi;\n+    }\n+\n+    public static MenuItem item(Menu b, String text, Runnable r) {\n+        MenuItem mi = new MenuItem(text);\n+        mi.setOnAction((ev) -> r.run());\n+        applyMnemonic(mi);\n+        b.getItems().add(mi);\n+        return mi;\n+    }\n+\n+    public static Menu submenu(MenuBar b, String text) {\n+        Menu m = new Menu(text);\n+        applyMnemonic(m);\n+        lastMenu(b).getItems().add(m);\n+        return m;\n+    }\n+\n+    private static void applyMnemonic(MenuItem m) {\n+        String text = m.getText();\n+        if (text != null) {\n+            if (text.contains(\"_\")) {\n+                m.setMnemonicParsing(true);\n+            }\n+        }\n+    }\n+\n+    private static Menu lastMenu(MenuBar b) {\n+        List<Menu> ms = b.getMenus();\n+        return ms.get(ms.size() - 1);\n+    }\n+\n+    public static SeparatorMenuItem separator(MenuBar b) {\n+        SeparatorMenuItem s = new SeparatorMenuItem();\n+        lastMenu(b).getItems().add(s);\n+        return s;\n+    }\n+\n+    public static SeparatorMenuItem separator(ContextMenu m) {\n+        SeparatorMenuItem s = new SeparatorMenuItem();\n+        m.getItems().add(s);\n+        return s;\n+    }\n+\n+    public static RadioMenuItem radio(MenuBar b, String text, KeyCombination accelerator, ToggleGroup g) {\n+        RadioMenuItem mi = new RadioMenuItem(text);\n+        mi.setAccelerator(accelerator);\n+        mi.setToggleGroup(g);\n+        lastMenu(b).getItems().add(mi);\n+        return mi;\n+    }\n+\n+    public static CheckMenuItem checkItem(ContextMenu c, String name, boolean selected, Consumer<Boolean> client) {\n+        CheckMenuItem m = new CheckMenuItem(name);\n+        m.setSelected(selected);\n+        m.setOnAction((ev) -> {\n+            boolean on = m.isSelected();\n+            client.accept(on);\n+        });\n+        c.getItems().add(m);\n+        return m;\n+    }\n+\n+    public static CheckMenuItem checkItem(Menu c, String name, boolean selected, Consumer<Boolean> client) {\n+        CheckMenuItem m = new CheckMenuItem(name);\n+        m.setSelected(selected);\n+        m.setOnAction((ev) -> {\n+            boolean on = m.isSelected();\n+            client.accept(on);\n+        });\n+        c.getItems().add(m);\n+        return m;\n+    }\n+\n+    public static ToggleButton toggleButton(ToolBar t, String text, FxAction a) {\n+        ToggleButton b = new ToggleButton(text);\n+        a.attach(b);\n+        t.getItems().add(b);\n+        return b;\n+    }\n+\n+    public static ToggleButton toggleButton(ToolBar t, String text, String tooltip, FxAction a) {\n+        ToggleButton b = new ToggleButton(text);\n+        b.setTooltip(new Tooltip(tooltip));\n+        a.attach(b);\n+        t.getItems().add(b);\n+        return b;\n+    }\n+\n+    public static ToggleButton toggleButton(ToolBar t, String text, String tooltip) {\n+        ToggleButton b = new ToggleButton(text);\n+        b.setTooltip(new Tooltip(tooltip));\n+        b.setDisable(true);\n+        t.getItems().add(b);\n+        return b;\n+    }\n+\n+    public static Button button(ToolBar t, String text, String tooltip, FxAction a) {\n+        Button b = new Button(text);\n+        b.setTooltip(new Tooltip(tooltip));\n+        a.attach(b);\n+        t.getItems().add(b);\n+        return b;\n+    }\n+\n+    public static Button button(ToolBar t, String text, String tooltip) {\n+        Button b = new Button(text);\n+        b.setTooltip(new Tooltip(tooltip));\n+        b.setDisable(true);\n+        t.getItems().add(b);\n+        return b;\n+    }\n+\n+    public static <N extends Node> N add(ToolBar t, N child) {\n+        t.getItems().add(child);\n+        return child;\n+    }\n+\n+    public static void space(ToolBar t) {\n+        Pane p = new Pane();\n+        p.setPrefSize(10, 10);\n+        t.getItems().add(p);\n+    }\n+\n+    public static void tooltip(Control c, String text) {\n+        c.setTooltip(new Tooltip(text));\n+    }\n+\n+    public static void add(GridPane p, Node n, int col, int row) {\n+        p.getChildren().add(n);\n+        GridPane.setConstraints(n, col, row);\n+    }\n+\n+    public static <T> void select(ComboBox<T> cb, T value) {\n+        cb.getSelectionModel().select(value);\n+    }\n+\n+    public static <T> void selectFirst(ComboBox<T> cb) {\n+        cb.getSelectionModel().selectFirst();\n+    }\n+\n+    public static <T> T getSelectedItem(ComboBox<T> cb) {\n+        return cb.getSelectionModel().getSelectedItem();\n+    }\n+\n+    public static Window getParentWindow(Object nodeOrWindow) {\n+        if (nodeOrWindow == null) {\n+            return null;\n+        } else if (nodeOrWindow instanceof Window w) {\n+            return w;\n+        } else if (nodeOrWindow instanceof Node n) {\n+            Scene s = n.getScene();\n+            if (s != null) {\n+                return s.getWindow();\n+            }\n+            return null;\n+        } else {\n+            throw new Error(\"Node or Window only\");\n+        }\n+    }\n+\n+    \/** cascades the window relative to its owner, if any *\/\n+    public static void cascade(Stage w) {\n+        if (w != null) {\n+            Window p = w.getOwner();\n+            if (p != null) {\n+                double x = p.getX();\n+                double y = p.getY();\n+                double off = 20;\n+                w.setX(x + off);\n+                w.setY(y + off);\n+            }\n+        }\n+    }\n+\n+    \/** adds a name property to the Node for the purposes of storing the preferences *\/\n+    public static void name(Node n, String name) {\n+        FxSettingsSchema.setName(n, name);\n+    }\n+\n+    \/** adds a name property to the Window for the purposes of storing the preferences *\/\n+    public static void name(Window w, String name) {\n+        FxSettingsSchema.setName(w, name);\n+    }\n+\n+    \/**\n+     * attach a popup menu to a node.\n+     * WARNING: sometimes, as the case is with TableView\/FxTable header,\n+     * the requested node gets created by the skin at some later time.\n+     * In this case, additional dance must be performed, see for example\n+     * FxTable.setHeaderPopupMenu()\n+     *\/\n+    \/\/ https:\/\/github.com\/andy-goryachev\/MP3Player\/blob\/8b0ff12460e19850b783b961f214eacf5e1cdaf8\/src\/goryachev\/fx\/FX.java#L1251\n+    public static void setPopupMenu(Node owner, Supplier<ContextMenu> generator) {\n+        if (owner == null) {\n+            throw new NullPointerException(\"cannot attach popup menu to null\");\n+        }\n+\n+        owner.setOnContextMenuRequested((ev) -> {\n+            if (generator != null) {\n+                ContextMenu m = generator.get();\n+                if (m != null) {\n+                    if (m.getItems().size() > 0) {\n+                        Platform.runLater(() -> {\n+                            \/\/ javafx does not dismiss the popup when the user\n+                            \/\/ clicks on the owner node\n+                            EventHandler<MouseEvent> li = new EventHandler<MouseEvent>() {\n+                                @Override\n+                                public void handle(MouseEvent event) {\n+                                    m.hide();\n+                                    owner.removeEventFilter(MouseEvent.MOUSE_PRESSED, this);\n+                                    event.consume();\n+                                }\n+                            };\n+\n+                            owner.addEventFilter(MouseEvent.MOUSE_PRESSED, li);\n+                            m.show(owner, ev.getScreenX(), ev.getScreenY());\n+                        });\n+                        ev.consume();\n+                    }\n+                }\n+            }\n+            ev.consume();\n+        });\n+    }\n+\n+    \/**\n+     * Sets opacity (alpha) value.\n+     * @param c the initial color\n+     * @param opacity the opacity value\n+     * @return the new Color with specified opacity\n+     *\/\n+    public static Color alpha(Color c, double opacity) {\n+        double r = c.getRed();\n+        double g = c.getGreen();\n+        double b = c.getBlue();\n+        return new Color(r, g, b, opacity);\n+    }\n+\n+    \/**\n+     * Returns the node of type {@code type}, which is either the ancestor or the specified node,\n+     * or the specified node itself.\n+     * @param <N> the class of Node\n+     * @param type the class of Node\n+     * @param n the node to look at\n+     * @return the ancestor of type N, or null\n+     *\/\n+    public static <N extends Node> N findParentOf(Class<N> type, Node n) {\n+        for (;;) {\n+            if (n == null) {\n+                return null;\n+            } else if (type.isAssignableFrom(n.getClass())) {\n+                return (N)n;\n+            }\n+            n = n.getParent();\n+        }\n+    }\n+\n+    \/**\n+     * Adds the specified style name to the Node's style list.\n+     * @param n the node\n+     * @param name the style name to add\n+     *\/\n+    public static void style(Node n, String name) {\n+        if (n != null) {\n+            n.getStyleClass().add(name);\n+        }\n+    }\n+\n+    \/**\n+     * Adds or removes the specified style name to the Node's style list.\n+     * @param n the node\n+     * @param name the style name to add\n+     * @param add whether to add or remove the style\n+     *\/\n+    public static void style(Node n, String name, boolean add) {\n+        if (n != null) {\n+            if (add) {\n+                n.getStyleClass().add(name);\n+            } else {\n+                n.getStyleClass().remove(name);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Adds or removes the specified pseudo class to the Node's style list.\n+     * @param n the node\n+     * @param name the style name to add\n+     * @param on whether to add or remove the pseudo class\n+     *\/\n+    public static void style(Node n, PseudoClass name, boolean on) {\n+        if (n != null) {\n+            n.pseudoClassStateChanged(name, on);\n+        }\n+    }\n+\n+    public static Button button(String text, Runnable r) {\n+        Button b = new Button(text);\n+        if (r == null) {\n+            b.setDisable(true);\n+        } else {\n+            b.setOnAction((ev) -> r.run());\n+        }\n+        return b;\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/util\/FX.java","additions":441,"deletions":0,"binary":false,"changes":441,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/\/ This code borrows heavily from the following project, with permission from the author:\n+\/\/ https:\/\/github.com\/andy-goryachev\/AppFramework\n+package com.oracle.demo.richtext.util;\n+\n+import java.util.function.Consumer;\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.event.ActionEvent;\n+import javafx.event.EventHandler;\n+import javafx.scene.control.ButtonBase;\n+import javafx.scene.control.CheckMenuItem;\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.Menu;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.RadioMenuItem;\n+import javafx.scene.control.ToggleButton;\n+\n+\/**\n+ * An AbstractAction equivalent for FX, using method references.\n+ * <p>\n+ * Usage:\n+ * <pre>\n+ *    public final FxAction backAction = new FxAction(this::actionBack);\n+ * <\/pre>\n+ *\/\n+public class FxAction implements EventHandler<ActionEvent> {\n+    private final SimpleBooleanProperty selectedProperty = new SimpleBooleanProperty();\n+    private final SimpleBooleanProperty disabledProperty = new SimpleBooleanProperty();\n+    private Runnable onAction;\n+    private Consumer<Boolean> onSelected;\n+\n+    public FxAction(Runnable onAction, Consumer<Boolean> onSelected, boolean enabled) {\n+        this.onAction = onAction;\n+        this.onSelected = onSelected;\n+        setEnabled(enabled);\n+\n+        if (onSelected != null) {\n+            selectedProperty.addListener((src, prev, cur) -> fireSelected(cur));\n+        }\n+    }\n+\n+    public FxAction(Runnable onAction, Consumer<Boolean> onSelected) {\n+        this(onAction, onSelected, true);\n+    }\n+\n+    public FxAction(Runnable onAction, boolean enabled) {\n+        this(onAction, null, enabled);\n+    }\n+\n+    public FxAction(Runnable onAction) {\n+        this.onAction = onAction;\n+    }\n+\n+    public FxAction() {\n+    }\n+\n+    public void setOnAction(Runnable r) {\n+        onAction = r;\n+    }\n+\n+    protected final void invokeAction() {\n+        if (onAction != null) {\n+            try {\n+                onAction.run();\n+            } catch (Throwable e) {\n+                \/\/log.error(e);\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    public void attach(ButtonBase b) {\n+        b.setOnAction(this);\n+        b.disableProperty().bind(disabledProperty());\n+\n+        if (b instanceof ToggleButton) {\n+            ((ToggleButton)b).selectedProperty().bindBidirectional(selectedProperty());\n+        }\n+    }\n+\n+    public void attach(MenuItem m) {\n+        m.setOnAction(this);\n+        m.disableProperty().bind(disabledProperty());\n+\n+        if (m instanceof CheckMenuItem) {\n+            ((CheckMenuItem)m).selectedProperty().bindBidirectional(selectedProperty());\n+        } else if (m instanceof RadioMenuItem) {\n+            ((RadioMenuItem)m).selectedProperty().bindBidirectional(selectedProperty());\n+        }\n+    }\n+\n+    public final BooleanProperty selectedProperty() {\n+        return selectedProperty;\n+    }\n+\n+    public final boolean isSelected() {\n+        return selectedProperty.get();\n+    }\n+\n+    public final void setSelected(boolean on, boolean fire) {\n+        if (selectedProperty.get() != on) {\n+            selectedProperty.set(on);\n+            if (fire) {\n+                fire();\n+            }\n+        }\n+    }\n+\n+    public final BooleanProperty disabledProperty() {\n+        return disabledProperty;\n+    }\n+\n+    public final boolean isDisabled() {\n+        return disabledProperty.get();\n+    }\n+\n+    public final void setDisabled(boolean on) {\n+        disabledProperty.set(on);\n+    }\n+\n+    public final boolean isEnabled() {\n+        return !isDisabled();\n+    }\n+\n+    public final void setEnabled(boolean on) {\n+        disabledProperty.set(!on);\n+    }\n+\n+    public final void enable() {\n+        setEnabled(true);\n+    }\n+\n+    public final void disable() {\n+        setEnabled(false);\n+    }\n+\n+    \/** fire onAction handler only if this action is enabled *\/\n+    public void fire() {\n+        if (isEnabled()) {\n+            handle(null);\n+        }\n+    }\n+\n+    \/** execute an action regardless of whether its enabled or not *\/\n+    public void execute() {\n+        try {\n+            invokeAction();\n+        } catch (Throwable e) {\n+            \/\/log.error(e);\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    protected void fireSelected(boolean on) {\n+        try {\n+            onSelected.accept(on);\n+        } catch (Throwable e) {\n+            \/\/log.error(e);\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    \/** override to obtain the ActionEvent *\/\n+    @Override\n+    public void handle(ActionEvent ev) {\n+        if (isEnabled()) {\n+            if (ev != null) {\n+                if (ev.getSource() instanceof Menu) {\n+                    if (ev.getSource() != ev.getTarget()) {\n+                        \/\/ selection of a cascading child menu triggers action event for the parent\n+                        \/\/ for some unknown reason.  ignore this.\n+                        return;\n+                    }\n+                }\n+\n+                ev.consume();\n+            }\n+\n+            execute();\n+\n+            \/\/ close popup menu, if applicable\n+            if (ev != null) {\n+                Object src = ev.getSource();\n+                if (src instanceof Menu) {\n+                    ContextMenu p = ((Menu)src).getParentPopup();\n+                    if (p != null) {\n+                        p.hide();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/util\/FxAction.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * RichTextArea Control demo.\n+ *\n+ * <BR><b><a href=\"https:\/\/openjdk.org\/jeps\/11\">Incubating Feature.<\/a>\n+ * Will be removed in a future release.<\/b>\n+ *\n+ * @moduleGraph\n+ *\/\n+\n+module RichTextAreaDemo {\n+    exports com.oracle.demo.richtext.codearea;\n+    exports com.oracle.demo.richtext.editor;\n+    exports com.oracle.demo.richtext.notebook;\n+    exports com.oracle.demo.richtext.rta;\n+\n+    requires javafx.base;\n+    requires javafx.controls;\n+    requires javafx.graphics;\n+    requires jfx.incubator.input;\n+    requires jfx.incubator.richtext;\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/module-info.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.oracle.demo.richtext.codearea;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import com.oracle.demo.richtext.codearea.JavaSyntaxAnalyzer;\n+\n+\/**\n+ * Tests JavaSyntaxDecorator.\n+ *\/\n+public class TestJavaSyntaxDecorator {\n+    private static final JavaSyntaxAnalyzer.Type H = JavaSyntaxAnalyzer.Type.CHARACTER;\n+    private static final JavaSyntaxAnalyzer.Type C = JavaSyntaxAnalyzer.Type.COMMENT;\n+    private static final JavaSyntaxAnalyzer.Type K = JavaSyntaxAnalyzer.Type.KEYWORD;\n+    private static final JavaSyntaxAnalyzer.Type N = JavaSyntaxAnalyzer.Type.NUMBER;\n+    private static final JavaSyntaxAnalyzer.Type T = JavaSyntaxAnalyzer.Type.OTHER;\n+    private static final JavaSyntaxAnalyzer.Type S = JavaSyntaxAnalyzer.Type.STRING;\n+    private static final Object NL = new Object();\n+\n+    @Test\n+    public void specialCases() {\n+        t(T, \"print(x);\");\n+        t(K, \"new\", T, \" StringPropertyBase(\", S, \"\\\"\\\"\", T, \") {\");\n+        t(K, \"import\", T, \" javafx.geometry.BoundingBox;\");\n+        t(T, \"tempState.point.y = \");\n+        t(T, \"FX.checkItem(m, \", S, \"\\\"1\\\"\", T, \" \", K, \"new\", T, \" Insets(\", N, \"1\", T, \").equals(t.getContentPadding()), (on) -> {\", NL);\n+        t(K, \"import\", T, \" atry.a;\");\n+    }\n+\n+    private void someExamplesOfValidCode() {\n+        \/\/ text block\n+        var s = \"\"\"\n+        ---\/** *\/ -- \/\/ return ;\n+        \"\"\"  ;\n+\n+        \/\/ numbers\n+        double x = .1e15;\n+        x = 1.5e2;\n+        x = 1e3f;\n+        x = 1.1f;\n+        x = 5_0.1e2_3;\n+        x = 1_000_000;\n+        x = -1_000e-1;\n+        x = +1_000e+1;\n+        x = 1__1e-1_______________________________1;\n+        x = 0b10100001010001011010000101000101;\n+        x = 0b1010_0001_0100_0_1011_________01000010100010___1;\n+        x = 0x0_000__00;\n+    }\n+\n+    @Test\n+    public void tests() {\n+        \/\/ hex\n+        t(N, \"0x0123456789abcdefL\");\n+        t(N, \"0x00\", NL, N, \"0x0123456789abcdefL\");\n+        t(N, \"0xeFeF\", NL, N, \"0x0123__4567__89ab_cdefL\");\n+\n+        \/\/ binary\n+        t(N, \"0b00000\");\n+        t(N, \"0b1010101010L\");\n+\n+        \/\/ doubles\n+        t(N, \"1___2e-3___6\");\n+        t(N, \".15e2\");\n+        t(N, \"3.141592\");\n+        t(N, \".12345\");\n+        t(N, \"1.5e2\");\n+        t(N, \"1.5e2_2\");\n+        t(N, \"1.5E-2\");\n+        t(N, \"1_2.5E-2\");\n+        t(N, \".57E22\");\n+        t(N, \".75E-5\");\n+        t(N, \"1D\");\n+        t(N, \"1___2e-3___6d\");\n+        t(N, \".15e2d\");\n+        t(N, \"3.141592d\");\n+        t(N, \".12345d\");\n+        t(N, \"1.5e2d\");\n+        t(N, \"1.5e2_2d\");\n+        t(N, \"1.5E-2d\");\n+        t(N, \"1_2.5E-2d\");\n+        t(N, \".57E22d\");\n+        t(N, \".75E-5d\");\n+        t(N, \"1D\", NL, N, \"1d\", NL, N, \"1.1D\", NL, N, \"1.1d\", NL, N, \"1.2e-3d\", NL, N, \"1.2e-3D\", NL, N, \"1.2E+3d\");\n+\n+        \/\/ floats\n+        t(N, \"1f\");\n+        t(N, \"1___2e-3___6f\");\n+        t(N, \".15e2f\");\n+        t(N, \"3.141592f\");\n+        t(N, \".12345f\");\n+        t(N, \"1.5e2f\");\n+        t(N, \"1.5e2_2f\");\n+        t(N, \"1.5E-2f\");\n+        t(N, \"1_2.5E-2f\");\n+        t(N, \".57E22f\");\n+        t(N, \".75E-5f\");\n+        t(N, \"1F\", NL, N, \"1f\", NL, N, \"1.1F\", NL, N, \"1.1f\", NL, N, \"1.2e-3f\", NL, N, \"1.2e-3F\", NL, N, \"1.2E+3f\");\n+\n+        \/\/ longs\n+        t(N, \"1L\", NL, N, \"1l\", NL);\n+        t(N, \"2_2L\", NL, N, \"2_2l\", NL);\n+        t(N, \"2____2L\", NL, N, \"2___2l\", NL);\n+        t(T, \"-\", N, \"99999L\", NL);\n+        t(T, \"5.L\");\n+\n+        \/\/ integers\n+        t(N, \"1\");\n+        t(N, \"1_0\");\n+        t(N, \"1_000_000_000\");\n+        t(N, \"1______000___000_____000\");\n+        \/\/ negative scenarios with integers\n+        t(T, \"_1\");\n+        t(T, \"1_\");\n+        t(T, \"-\", N, \"9999\");\n+\n+        \/\/ text blocks\n+        t(T, \"String s =\", S, \"\\\"\\\"\\\"   \", NL, S, \" yo \/* \/\/ *\/ *\/ \\\"\\\" \\\"  \", NL, S, \"a  \\\"\\\"\\\"   \", T, \";\");\n+\n+        \/\/ strings\n+        t(T, \" \", S, \"\\\"\\\\\\\"\/*\\\\\\\"\\\"\", NL);\n+        t(S, \"\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\"\", T, \" {\", NL);\n+        t(S, \"\\\"abc\\\"\", NL, T, \"s = \", S, \"\\\"\\\"\");\n+\n+        \/\/ comments\n+        t(T, \" \", C, \"\/* yo\", NL, C, \"yo yo\", NL, C, \" *\/\", T, \" \");\n+        t(T, \" \", C, \"\/\/ yo yo\", NL, K, \"int\", T, \" c;\");\n+        t(C, \"\/* \/\/ yo\", NL, C, \"\/\/ *\/\", T, \" \");\n+\n+        \/\/ chars\n+        t(H, \"'\\\\b'\");\n+        t(H, \"'\\\\b'\", NL);\n+        t(H, \"'\\\\u0000'\", NL, H, \"'\\\\uFf9a'\", NL);\n+        t(H, \"'a'\", NL, H, \"'\\\\b'\", NL, H, \"'\\\\f'\", NL, H, \"'\\\\n'\", NL, H, \"'\\\\r'\", NL);\n+        t(H, \"'\\\\''\", NL, H, \"'\\\\\\\"'\", NL, H, \"'\\\\\\\\'\", NL);\n+\n+        \/\/ keywords\n+        t(K, \"package\", T, \" java.com;\", NL);\n+        t(K, \"import\", T, \" java.util.ArrayList;\", NL);\n+        t(K, \"import\", T, \" java.util.ArrayList;\", NL, K, \"import\", T, \" java.util.ArrayList;\", NL);\n+        t(K, \"import\", T, \" com.oracle.demo\");\n+\n+        \/\/ misc\n+        t(K, \"if\", T, \"(\", S, \"\\\"\/*\\\"\", T, \" == null) {\", NL);\n+        t(C, \"\/\/ test\", NL, T, \"--\", NL);\n+        t(T, \"S_0,\");\n+    }\n+\n+    private void t(Object... items) {\n+        StringBuilder sb = new StringBuilder();\n+        ArrayList<JavaSyntaxAnalyzer.Line> expected = new ArrayList<>();\n+        JavaSyntaxAnalyzer.Line line = null;\n+\n+        \/\/ builds the input string and the expected result array\n+        for (int i = 0; i < items.length; ) {\n+            Object x = items[i++];\n+            if (x == NL) {\n+                sb.append(\"\\n\");\n+                if (line == null) {\n+                    line = new JavaSyntaxAnalyzer.Line();\n+                }\n+                expected.add(line);\n+                line = null;\n+            } else {\n+                JavaSyntaxAnalyzer.Type t = (JavaSyntaxAnalyzer.Type)x;\n+                String text = (String)items[i++];\n+                if (line == null) {\n+                    line = new JavaSyntaxAnalyzer.Line();\n+                }\n+                line.addSegment(t, text);\n+                sb.append(text);\n+            }\n+        }\n+\n+        if (line != null) {\n+            expected.add(line);\n+        }\n+\n+        String input = sb.toString();\n+        List<JavaSyntaxAnalyzer.Line> res = new JavaSyntaxAnalyzer(input).analyze();\n+        Assertions.assertArrayEquals(expected.toArray(), res.toArray());\n+    }\n+}\n","filename":"tests\/manual\/RichTextAreaDemo\/test\/test\/com\/oracle\/demo\/richtext\/codearea\/TestJavaSyntaxDecorator.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"}]}