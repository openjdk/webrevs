{"files":[{"patch":"@@ -32,1 +32,0 @@\n-import javafx.geometry.Insets;\n@@ -47,0 +46,2 @@\n+ * <p>\n+ * Uses {@code Vflow.content} coordinates.\n@@ -53,1 +54,2 @@\n-    private final Insets contentPadding;\n+    private final double contentPaddingLeft; \/\/ snapped\n+    private final double contentPaddingTop; \/\/ snapped\n@@ -63,1 +65,1 @@\n-    public CellArrangement(VFlow f) {\n+    public CellArrangement(VFlow f, double contentPaddingLeft, double contentPaddingTop) {\n@@ -68,1 +70,2 @@\n-        this.contentPadding = f.contentPadding();\n+        this.contentPaddingLeft = contentPaddingLeft;\n+        this.contentPaddingTop = contentPaddingTop;\n@@ -72,1 +75,1 @@\n-    public boolean isValid(VFlow f) {\n+    public boolean isValid(VFlow f, double padLeft, double padTop) {\n@@ -77,1 +80,2 @@\n-            (RichUtils.equals(f.contentPadding(), contentPadding));\n+            (contentPaddingLeft == padLeft) &&\n+            (contentPaddingTop == padTop);\n@@ -84,1 +88,1 @@\n-            origin +\n+            \"origin=\" + origin +\n@@ -131,2 +135,1 @@\n-            Insets pad = r.getPadding();\n-            double y = cellY - cell.getY() - pad.getTop();\n+            double y = cellY - cell.getY() - r.snappedTopInset();\n@@ -136,2 +139,2 @@\n-                if (r instanceof TextFlow t) {\n-                    double x = cellX - pad.getLeft();\n+                if (r instanceof TextFlow f) {\n+                    double x = cellX - f.snappedLeftInset();\n@@ -139,1 +142,1 @@\n-                    HitInfo h = t.hitTest(p);\n+                    HitInfo h = f.hitTest(p);\n@@ -143,1 +146,0 @@\n-                    \/\/System.out.println(\"CellArrangmenet.getTextPos ix=\" + ii + \" ci=\" + ci + \" leading=\" + leading); \/\/ FIX\n@@ -192,0 +194,6 @@\n+    \/**\n+     * Creates a CaretInfo.\n+     * @param target the target region (vflow.content)\n+     * @param p the text position\n+     * @return the new CaretInfo\n+     *\/\n@@ -199,4 +207,4 @@\n-                double dx = -contentPadding.getLeft();\n-                PathElement[] path = cell.getCaretShape(target, charIndex, leading, dx, 0.0);\n-                if (path == null) {\n-                    return null;\n+                PathElement[] path = cell.getCaretShape(target, charIndex, leading);\n+                if (path != null) {\n+                    double lineSpacing = cell.getLineSpacing();\n+                    return CaretInfo.create(lineSpacing, path);\n@@ -204,5 +212,0 @@\n-\n-                double lineSpacing = cell.getLineSpacing();\n-                double top = cell.getContent().snappedTopInset();\n-                double bottom = cell.getContent().snappedBottomInset();\n-                return CaretInfo.create(lineSpacing, path);\n@@ -333,2 +336,1 @@\n-                    double topPadding = contentPadding.getTop();\n-                    y = Math.max(y, -topPadding);\n+                    y = Math.max(y, -contentPaddingTop);\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/CellArrangement.java","additions":26,"deletions":24,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import javafx.scene.shape.LineTo;\n+import javafx.scene.shape.MoveTo;\n+import javafx.scene.shape.PathElement;\n+\n+\/**\n+ * Represents the text geometry as a sequence of bounding rectangles.\n+ *\/\n+public class RangeInfo {\n+    \/** the sequence of rectangles encoded as [xmin, ymin, xmax, ymax], ... *\/\n+    private final double[] data;\n+    private final double ymin;\n+    private final double ymax;\n+\n+    private RangeInfo(double[] data, double ymin, double ymax) {\n+        this.data = data;\n+        this.ymin = ymin;\n+        this.ymax = ymax;\n+    }\n+\n+    public static RangeInfo of(double width, double height) {\n+        double[] d = { 0.0, 0.0, width, height };\n+        return new RangeInfo(d, 0.0, height);\n+    }\n+\n+    public static RangeInfo of(PathElement[] elements, double lineSpacing) {\n+        \/\/ this code depends on the current implementation (see PrismLayout::getRange)\n+        \/\/ which generates path elements with the following pattern:\n+        \/\/   result.add(new MoveTo(x + l,  y + top));\n+        \/\/   result.add(new LineTo(x + r, y + top));\n+        \/\/   result.add(new LineTo(x + r, y + bottom));\n+        \/\/   result.add(new LineTo(x + l,  y + bottom));\n+        \/\/   result.add(new LineTo(x + l,  y + top));\n+        int sz = (elements.length \/ 5);\n+        double[] d = new double[sz * 4];\n+        int srcIndex = 0;\n+        int tgtIndex = 0;\n+        double ymin = Double.POSITIVE_INFINITY;\n+        double ymax = Double.NEGATIVE_INFINITY;\n+        for (int i = 0; i < sz; i++) {\n+            \/\/ we could do extra checking here, but the hope is that we will create a new API\n+            \/\/ for the caret info and text range which would contain information we need.\n+            MoveTo m = (MoveTo)elements[srcIndex];\n+            double x = m.getX();\n+            double y = m.getY();\n+            d[tgtIndex++] = x;\n+            d[tgtIndex++] = y;\n+            if (y < ymin) {\n+                ymin = y;\n+            }\n+            if (y > ymax) {\n+                ymax = y;\n+            }\n+\n+            LineTo t = (LineTo)elements[srcIndex + 2];\n+            x = t.getX();\n+            y = t.getY() + lineSpacing;\n+            d[tgtIndex++] = x;\n+            d[tgtIndex++] = y;\n+            if (y < ymin) {\n+                ymin = y;\n+            }\n+            if (y > ymax) {\n+                ymax = y;\n+            }\n+\n+            srcIndex += 5;\n+        }\n+        return new RangeInfo(d, ymin, ymax);\n+    }\n+\n+    public int getSegmentCount() {\n+        return data.length \/ 4;\n+    }\n+\n+    public boolean contains(int ix, double x, double y) {\n+        ix *= 4;\n+        if (data[ix++] <= x) {\n+            if (data[ix++] <= y) {\n+                if (data[ix++] >= x) {\n+                    if (data[ix] >= y) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean containsX(int ix, double x) {\n+        ix *= 4;\n+        return (data[ix] <= x) && (data[ix + 2] >= x);\n+    }\n+\n+    public double midPointY(int ix) {\n+        ix *= 4;\n+        return (data[ix + 1] + data[ix + 3]) \/ 2.0;\n+    }\n+\n+    public double getMinY(int ix) {\n+        return data[ix * 4 + 1];\n+    }\n+\n+    public double getMaxY(int ix) {\n+        return data[ix * 4 + 3];\n+    }\n+\n+    public boolean insideY(double y) {\n+        return (ymin <= y) && (y <= ymax);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/RangeInfo.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -76,0 +76,1 @@\n+    \/** horizontal cursor position preserved during up\/down movement, in vflow.content coordinates *\/\n@@ -520,1 +521,1 @@\n-        double x = Math.max(0.0, phantomX + vflow.getOffsetX());\n+        double x = Math.max(0.0, phantomX);\n@@ -649,0 +650,8 @@\n+    \/**\n+     * Moves the caret {@code deltaPixels} up (negative) or down (positive) from its current position.\n+     * Extends existing selection when {@code extendSelection} is true.\n+     * Does nothing if the current caret position is null.\n+     *\n+     * @param deltaPixels the number of pixels to move\n+     * @param extendSelection whether to extend selection\n+     *\/\n@@ -650,2 +659,7 @@\n-        CaretInfo c = vflow.getCaretInfo();\n-        if (c == null) {\n+        TextPos caret = getControl().getCaretPosition();\n+        if (caret == null) {\n+            return;\n+        }\n+\n+        CaretInfo ci = vflow.getCaretInfo(caret);\n+        if (ci == null) {\n@@ -655,3 +669,1 @@\n-        double sp = c.getLineSpacing();\n-        \/\/ TODO split caret?\n-        double x = (c.getMinX() + c.getMaxX()) \/ 2.0;\n+        double x = (ci.getMinX() + ci.getMaxX()) \/ 2.0;\n@@ -660,0 +672,1 @@\n+            \/\/ TODO possibly use effectiveOrientation to determine which side we should use\n@@ -665,5 +678,4 @@\n-        boolean up = (deltaPixels < 0);\n-        double y0 = up ? c.getMinY() : c.getMaxY();\n-        double y = up ?\n-            c.getMinY() + deltaPixels - sp - 0.5:\n-            c.getMaxY() + deltaPixels + sp + 0.5;\n+        boolean down = (deltaPixels > 0);\n+        double y = down ?\n+            ci.getMaxY() + deltaPixels + 0.5 :\n+            ci.getMinY() + deltaPixels - 0.5;\n@@ -671,4 +683,1 @@\n-        \/\/ TODO\n-        \/\/ check whether the new caret y position changed, unless it's TextPos.ZERO when going up, or EOF if going down\n-\n-        TextPos p = vflow.getTextPosLocal(x, y);\n+        TextPos p = vflow.moveLine(caret.index(), x, y, down);\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/RichTextAreaBehavior.java","additions":24,"deletions":15,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -171,2 +171,0 @@\n-     * @param dx the additional X offset\n-     * @param dy the additional Y offset\n@@ -175,1 +173,1 @@\n-    public PathElement[] getCaretShape(Region target, int charIndex, boolean leading, double dx, double dy) {\n+    public PathElement[] getCaretShape(Region target, int charIndex, boolean leading) {\n@@ -177,0 +175,2 @@\n+        double dx;\n+        double dy;\n@@ -178,2 +178,2 @@\n-            dx += f.snappedLeftInset(); \/\/ TODO RTL?\n-            dy += f.snappedTopInset();\n+            dx = f.snappedLeftInset(); \/\/ TODO RTL?\n+            dy = f.snappedTopInset();\n@@ -197,0 +197,2 @@\n+            dx = 0.0;\n+            dy = 0.0;\n@@ -212,2 +214,0 @@\n-     * @param dx the additional X offset\n-     * @param dy the additional Y offset\n@@ -216,1 +216,1 @@\n-    public PathElement[] getRangeShape(Region target, int start, int end, double dx, double dy) {\n+    public PathElement[] getRangeShape(Region target, int start, int end) {\n@@ -218,0 +218,2 @@\n+        double dx;\n+        double dy;\n@@ -219,2 +221,2 @@\n-            dx += f.snappedLeftInset(); \/\/ TODO RTL?\n-            dy += f.snappedTopInset();\n+            dx = f.snappedLeftInset(); \/\/ TODO RTL?\n+            dy = f.snappedTopInset();\n@@ -231,0 +233,2 @@\n+            dx = 0.0;\n+            dy = 0.0;\n@@ -352,0 +356,62 @@\n+\n+    private RangeInfo getTextRange() {\n+        if (content instanceof TextFlow f) {\n+            int len = getTextLength();\n+            PathElement[] pe = f.rangeShape(0, len);\n+            if (pe.length > 0) {\n+                double sp = f.getLineSpacing();\n+                return RangeInfo.of(pe, sp);\n+            }\n+        }\n+        return RangeInfo.of(width, height);\n+    }\n+\n+    public boolean isInsideText(double x, double y, boolean down) {\n+        y -= snappedTopInset();\n+        y -= content.snappedTopInset();\n+\n+        RangeInfo ri = getTextRange();\n+        int sz = ri.getSegmentCount();\n+        for (int i = 0; i < sz; i++) {\n+            if(ri.contains(i, x, y)) {\n+                return true;\n+            }\n+        }\n+        if (ri.insideY(y)) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public double findHitCandidate(double py, boolean down) {\n+        double dy = snappedTopInset() + content.snappedTopInset();\n+        double y = py - dy;\n+\n+        RangeInfo ri = getTextRange();\n+        int sz = ri.getSegmentCount();\n+        if (down) {\n+            for (int i = 0; i < sz; i++) {\n+                if (ri.getMaxY(i) >= y) {\n+                    return ri.midPointY(i) + dy;\n+                }\n+            }\n+            if (insideY(py)) {\n+                return ri.midPointY(0) + dy;\n+            }\n+        } else {\n+            for (int i = sz - 1; i >= 0; i--) {\n+                if (ri.getMinY(i) <= y) {\n+                    return ri.midPointY(i) + dy;\n+                }\n+            }\n+            if (insideY(py)) {\n+                int ix = ri.getSegmentCount() - 1;\n+                return ri.midPointY(ix) + dy;\n+            }\n+        }\n+        return Double.NaN;\n+    }\n+\n+    private boolean insideY(double y) {\n+        return (y < getHeight()) && (y >= 0.0);\n+    }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/TextCell.java","additions":76,"deletions":10,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -444,1 +444,0 @@\n-        selectionHighlight.setTranslateX(contentPaddingLeft);\n@@ -450,1 +449,0 @@\n-        caretPath.setTranslateX(contentPaddingLeft);\n@@ -593,1 +591,1 @@\n-            pe = cell.getCaretShape(content, startOffset, true, -contentPaddingLeft, 0.0);\n+            pe = cell.getCaretShape(content, startOffset, true);\n@@ -595,1 +593,1 @@\n-            pe = cell.getRangeShape(content, startOffset, endOffset, -contentPaddingLeft, 0.0);\n+            pe = cell.getRangeShape(content, startOffset, endOffset);\n@@ -1097,0 +1095,52 @@\n+    \/**\n+     * Computes the new TextPos for the target coordinates.  This method takes into account\n+     * the geometry of text as determined by the layout, thus taking into account\n+     * line spacing and paragraph padding and borders.\n+     *\n+     * @param caretIndex the current caret index\n+     * @param x the target x coordinate\n+     * @param y the target y coordinate\n+     * @param down direction of the movement relative to the caret\n+     * @return the new text position, or null if no movement should occur\n+     *\/\n+    public TextPos moveLine(int caretIndex, double x, double y, boolean down) {\n+        TextCell cell = getCell(caretIndex);\n+        \/\/ account for line spacing\n+        if (down) {\n+            y += cell.getLineSpacing();\n+        }\n+\n+        double cy = y - cell.getY();\n+        boolean inside = cell.isInsideText(x - contentPaddingLeft, cy, down);\n+        TextPos p = getTextPosLocal(x, y);\n+        if (p == null) {\n+            return null; \/\/ should not happen\n+        } else if (inside) {\n+            return p;\n+        }\n+\n+        int ix = p.index();\n+        if (ix == caretIndex) {\n+            if (down) {\n+                ix++;\n+                if (ix >= skin.getSkinnable().getParagraphCount()) {\n+                    return skin.getSkinnable().getDocumentEnd();\n+                }\n+            } else {\n+                ix--;\n+                if (ix < 0) {\n+                    return TextPos.ZERO;\n+                }\n+            }\n+        }\n+\n+        cell = getCell(ix);\n+        double py = cell.findHitCandidate(y - cell.getY(), down);\n+        if (Double.isNaN(py)) {\n+            return null; \/\/ should not happen\n+        }\n+\n+        p = getTextPosLocal(x, py + cell.getY());\n+        return p;\n+    }\n+\n@@ -1216,1 +1266,1 @@\n-        arrangement = new CellArrangement(this);\n+        arrangement = new CellArrangement(this, contentPaddingLeft, contentPaddingTop);\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/VFlow.java","additions":55,"deletions":5,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -628,0 +628,33 @@\n+\n+    \/**\n+     * Computes y midpoint of MoveTo and LineTo path elements.\n+     *\n+     * @param path the PathElements\n+     * @return the midpoint\n+     *\/\n+    public static double computeMidPointY(PathElement[] path) {\n+        double ymin = Double.POSITIVE_INFINITY;\n+        double ymax = Double.NEGATIVE_INFINITY;\n+        int sz = path.length;\n+        for (int i = 0; i < sz; i++) {\n+            PathElement em = path[i];\n+            if (em instanceof LineTo m) {\n+                double y = m.getY();\n+                if (ymin > y) {\n+                    ymin = y;\n+                }\n+                if (ymax < y) {\n+                    ymax = y;\n+                }\n+            } else if (em instanceof MoveTo m) {\n+                double y = m.getY();\n+                if (ymin > y) {\n+                    ymin = y;\n+                }\n+                if (ymax < y) {\n+                    ymax = y;\n+                }\n+            }\n+        }\n+        return (ymin == Double.POSITIVE_INFINITY) ? 0.0 : (ymax + ymin) \/ 2.0;\n+    }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/util\/RichUtils.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"}]}