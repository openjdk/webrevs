{"files":[{"patch":"@@ -3507,0 +3507,1 @@\n+    -fx-padding: 0 1 0 1;\n","filename":"modules\/javafx.controls\/src\/main\/resources\/com\/sun\/javafx\/scene\/control\/skin\/modena\/modena.css","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -451,1 +451,1 @@\n-          <li>jfx.incubator.scene.control.rich\n+          <li>jfx.incubator.scene.control.richtext\n@@ -6391,1 +6391,1 @@\n-          <td>jfx.incubator.scene.control.rich<\/td>\n+          <td>jfx.incubator.scene.control.richtext<\/td>\n","filename":"modules\/javafx.graphics\/src\/main\/docs\/javafx\/scene\/doc-files\/cssref.html","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * Captures the caret position and bounds in the content view coordinates.\n+ * Captures the caret position and bounds in the {@code VFlow.content} coordinates.\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/CaretInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-    private double totalHeight;\n@@ -66,1 +65,1 @@\n-        this.flowHeight = f.getViewHeight();\n+        this.flowHeight = f.getViewPortHeight();\n@@ -193,1 +192,1 @@\n-    public CaretInfo getCaretInfo(Region target, double xoffset, TextPos p) {\n+    public CaretInfo getCaretInfo(Region target, TextPos p) {\n@@ -207,0 +206,2 @@\n+                double top = cell.getContent().snappedTopInset();\n+                double bottom = cell.getContent().snappedBottomInset();\n@@ -376,13 +377,0 @@\n-\n-    \/**\n-     * Returns the total height of all cells that intersect the viewport, or Double.POSITIVE_INFINITY if there\n-     * are at least one cell lays beyond the viewport.\n-     * @return the total width\n-     *\/\n-    public double getTotalHeight() {\n-        return totalHeight;\n-    }\n-\n-    void setTotalHeight(double h) {\n-        totalHeight = h;\n-    }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/CellArrangement.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import javafx.geometry.HPos;\n-import javafx.geometry.Insets;\n-import javafx.geometry.VPos;\n-import javafx.scene.Node;\n@@ -46,0 +42,1 @@\n+        clip.setSmooth(false);\n@@ -48,2 +45,0 @@\n-        setClip(clip);\n-    }\n@@ -51,2 +46,1 @@\n-    public void layoutInArea(Node n, double x, double y, double w, double h) {\n-        layoutInArea(n, x, y, w, h, 0.0, Insets.EMPTY, HPos.LEFT, VPos.TOP);\n+        setClip(clip);\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/ClippedPane.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-    \/** small space between the end of last character and the right edge when typing, in pixels. *\/\n-    public static final double HORIZONTAL_GUARD = 10;\n+    \/** ensures the caret is always visible when reaching the edge of screen in unwrapped mode, in pixels. *\/\n+    public static final double HORIZONTAL_GUARD = 0; \/\/10; FIX restore\n@@ -97,0 +97,3 @@\n+\n+    \/** minimum viewport width prevents extra tall text flows *\/\n+    public static final double MIN_VIEWPORT_WIDTH = 10;\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/Params.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -407,1 +407,1 @@\n-        vflow.scrollCaretToVisible();\n+        \/\/vflow.scrollCaretToVisible();\n@@ -422,1 +422,1 @@\n-        } else if (y > vflow.getViewHeight()) {\n+        } else if (y > vflow.getViewPortHeight()) {\n@@ -424,1 +424,1 @@\n-            autoScroll(y - vflow.getViewHeight());\n+            autoScroll(y - vflow.getViewPortHeight());\n@@ -521,1 +521,1 @@\n-        double y = autoScrollUp ? 0.0 : vflow.getViewHeight();\n+        double y = autoScrollUp ? 0.0 : vflow.getViewPortHeight();\n@@ -530,1 +530,1 @@\n-        moveLine(vflow.getViewHeight(), false);\n+        moveLine(vflow.getViewPortHeight(), false);\n@@ -534,1 +534,1 @@\n-        moveLine(-vflow.getViewHeight(), false);\n+        moveLine(-vflow.getViewPortHeight(), false);\n@@ -654,0 +654,1 @@\n+\n@@ -655,0 +656,1 @@\n+        \/\/ TODO split caret?\n@@ -656,2 +658,0 @@\n-        double y = (deltaPixels < 0) ? c.getMinY() + deltaPixels - sp - 0.5 : c.getMaxY() + deltaPixels + sp;\n-\n@@ -659,1 +659,1 @@\n-            \/\/ phantom x is unclear in the case of split caret\n+            \/\/ phantomX is unclear in the case of split caret\n@@ -665,1 +665,10 @@\n-        TextPos p = vflow.getTextPosLocal(x + vflow.leftPadding(), y);\n+        boolean up = (deltaPixels < 0);\n+        double y0 = up ? c.getMinY() : c.getMaxY();\n+        double y = up ?\n+            c.getMinY() + deltaPixels - sp - 0.5:\n+            c.getMaxY() + deltaPixels + sp + 0.5;\n+\n+        \/\/ TODO\n+        \/\/ check whether the new caret y position changed, unless it's TextPos.ZERO when going up, or EOF if going down\n+\n+        TextPos p = vflow.getTextPosLocal(x, y);\n@@ -790,1 +799,1 @@\n-        moveLine(vflow.getViewHeight(), true);\n+        moveLine(vflow.getViewPortHeight(), true);\n@@ -794,1 +803,1 @@\n-        moveLine(-vflow.getViewHeight(), true);\n+        moveLine(-vflow.getViewPortHeight(), true);\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/RichTextAreaBehavior.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -85,7 +85,9 @@\n-        for (PathElement em : elements) {\n-            if (em instanceof LineTo p) {\n-                h.processPoint(p.getX(), p.getY());\n-            } else if (em instanceof MoveTo p) {\n-                h.processPoint(p.getX(), p.getY());\n-            } else {\n-                throw new Error(\"?\" + em);\n+        if (elements != null) {\n+            for (PathElement em : elements) {\n+                if (em instanceof LineTo p) {\n+                    h.processPoint(p.getX(), p.getY());\n+                } else if (em instanceof MoveTo p) {\n+                    h.processPoint(p.getX(), p.getY());\n+                } else {\n+                    throw new Error(\"?\" + em);\n+                }\n@@ -186,20 +188,22 @@\n-        for (PathElement em : elements) {\n-            if (em instanceof LineTo p) {\n-                double x = p.getX();\n-                if (isNear(x, px)) {\n-                    \/\/p.setX(x - dx);\n-                }\n-\n-                double y = p.getY();\n-                if (isNear(y, py)) {\n-                    p.setY(y + dy);\n-                }\n-            } else if (em instanceof MoveTo p) {\n-                double x = p.getX();\n-                if (isNear(x, px)) {\n-                    \/\/p.setX(x - dx);\n-                }\n-\n-                double y = p.getY();\n-                if (isNear(y, py)) {\n-                    p.setY(y + dy);\n+        if (elements != null) {\n+            for (PathElement em : elements) {\n+                if (em instanceof LineTo p) {\n+                    double x = p.getX();\n+                    if (isNear(x, px)) {\n+                        \/\/p.setX(x - dx);\n+                    }\n+\n+                    double y = p.getY();\n+                    if (isNear(y, py)) {\n+                        p.setY(y + dy);\n+                    }\n+                } else if (em instanceof MoveTo p) {\n+                    double x = p.getX();\n+                    if (isNear(x, px)) {\n+                        \/\/p.setX(x - dx);\n+                    }\n+\n+                    double y = p.getY();\n+                    if (isNear(y, py)) {\n+                        p.setY(y + dy);\n+                    }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/SelectionHelper.java","additions":31,"deletions":27,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+    private double width;\n@@ -140,0 +141,8 @@\n+    public void setCellWidth(double w) {\n+        width = w;\n+    }\n+\n+    public double getCellWidth() {\n+        return width;\n+    }\n+\n@@ -169,0 +178,3 @@\n+            dx += f.snappedLeftInset(); \/\/ TODO RTL?\n+            dy += f.snappedTopInset();\n+\n@@ -170,0 +182,1 @@\n+\n@@ -206,0 +219,3 @@\n+            dx += f.snappedLeftInset(); \/\/ TODO RTL?\n+            dy += f.snappedTopInset();\n+\n@@ -207,0 +223,1 @@\n+\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/TextCell.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import javafx.beans.property.DoubleProperty;\n@@ -44,2 +43,0 @@\n-import javafx.geometry.Bounds;\n-import javafx.geometry.HPos;\n@@ -48,1 +45,0 @@\n-import javafx.geometry.VPos;\n@@ -56,1 +52,0 @@\n-import javafx.scene.layout.StackPane;\n@@ -61,1 +56,0 @@\n-import javafx.scene.shape.Rectangle;\n@@ -65,0 +59,1 @@\n+import com.sun.jfx.incubator.scene.control.richtext.util.RichUtils;\n@@ -78,2 +73,17 @@\n- * Virtual text flow deals with TextCells, scroll bars, and conversion\n- * between the model and the screen coordinates.\n+ * Contains all the parts representing the visuals of the RichTextAreaSkin.\n+ *\n+ * Component hierarchy (all the way to the top):\n+ * <pre>\n+ *  RichTextArea (Region) .rich-text-area\n+ *    └─ VFlow (Pane) .flow\n+ *        ├─ left gutter (ClippedPane) .left-side\n+ *        ├─ right gutter (ClippedPane) .right-side\n+ *        ├─ vertical ScrollBar\n+ *        ├─ horizontal ScrollBar\n+ *        └─ view port (ClippedPane) .vport\n+ *            └─ content (StackPane) .content\n+ *                ├─ caret (Path) .caret\n+ *                ├─ cells[]\n+ *                ├─ selection highlight (Path) .selection-highlight\n+ *                └─ caret line highlight (Path) .caret-line\n+ * <\/pre>\n@@ -88,2 +98,2 @@\n-    private final StackPane content;\n-    private final ClippedPane flow;\n+    private final Pane content;\n+    private final ClippedPane vport;\n@@ -105,4 +115,4 @@\n-    private double topPadding;\n-    private double bottomPadding;\n-    private double leftPadding;\n-    private double rightPadding;\n+    private double contentPaddingTop;\n+    private double contentPaddingBottom;\n+    private double contentPaddingLeft;\n+    private double contentPaddingRight;\n@@ -113,0 +123,2 @@\n+    private double viewPortWidth;\n+    private double viewPortHeight;\n@@ -116,1 +128,1 @@\n-    public VFlow(RichTextAreaSkin skin, ScrollBar vscroll, ScrollBar hscroll) {\n+    public VFlow(RichTextAreaSkin skin, ScrollBar vsb, ScrollBar hsb) {\n@@ -119,2 +131,14 @@\n-        this.vscroll = vscroll;\n-        this.hscroll = hscroll;\n+        this.vscroll = vsb;\n+        this.hscroll = hsb;\n+\n+        vscroll.setManaged(false);\n+        vscroll.setMin(0.0);\n+        vscroll.setMax(1.0);\n+        vscroll.setUnitIncrement(Params.SCROLL_BARS_UNIT_INCREMENT);\n+        vscroll.setBlockIncrement(Params.SCROLL_BARS_BLOCK_INCREMENT);\n+\n+        hscroll.setManaged(false);\n+        hscroll.setMin(0.0);\n+        hscroll.setMax(1.0);\n+        hscroll.setUnitIncrement(Params.SCROLL_BARS_UNIT_INCREMENT);\n+        hscroll.setBlockIncrement(Params.SCROLL_BARS_BLOCK_INCREMENT);\n@@ -125,0 +149,1 @@\n+        setPadding(new Insets(Params.LAYOUT_FOCUS_BORDER));\n@@ -133,1 +158,4 @@\n-        content = new StackPane();\n+        vport = new ClippedPane(\"vport\");\n+        vport.setManaged(false);\n+\n+        content = new Pane();\n@@ -137,3 +165,0 @@\n-        flow = new ClippedPane(\"flow\");\n-        flow.setManaged(true);\n-\n@@ -152,5 +177,0 @@\n-        \/\/ make sure these are clipped by flow clip rectangle\n-        bindClipRectangle(caretLineHighlight, flow);\n-        bindClipRectangle(selectionHighlight, flow);\n-        bindClipRectangle(caretPath, flow);\n-\n@@ -158,2 +178,7 @@\n-        content.getChildren().addAll(caretLineHighlight, selectionHighlight, flow, caretPath);\n-        getChildren().addAll(content, leftGutter, rightGutter);\n+        getChildren().addAll(leftGutter, rightGutter, vscroll, hscroll, vport);\n+        vport.getChildren().addAll(content);\n+        content.getChildren().addAll(caretLineHighlight, selectionHighlight, caretPath);\n+        \/\/ caret on top, then the cells (visual order = 0), then the selection highlight, then the caret line\n+        caretPath.setViewOrder(-10);\n+        selectionHighlight.setViewOrder(10);\n+        caretLineHighlight.setViewOrder(20);\n@@ -189,0 +214,1 @@\n+        heightProperty().addListener((p) -> handleHeightChange());\n@@ -201,1 +227,1 @@\n-        return flow;\n+        return content;\n@@ -210,13 +236,0 @@\n-    private void bindClipRectangle(Node target, Node source) {\n-        Rectangle r = new Rectangle();\n-        target.setClip(r);\n-        source.boundsInParentProperty().addListener((s,p,sb) -> {\n-            Bounds b = target.parentToLocal(sb);\n-            r.setX(b.getMinX());\n-            r.setY(b.getMinY());\n-            r.setWidth(b.getWidth());\n-            r.setHeight(b.getHeight());\n-        });\n-        Rectangle sr = (Rectangle)source.getClip();\n-    }\n-\n@@ -224,27 +237,6 @@\n-        setUnwrappedContentWidth(0.0);\n-        setOrigin(new Origin(0, -topPadding));\n-        setOffsetX(-leftPadding);\n-        requestControlLayout(true);\n-        control.select(TextPos.ZERO);\n-    }\n-\n-    \/** width of the area available for text cells. *\/\n-    private double viewPortWidth() {\n-        double w = flow.getWidth();\n-        if (w == 0.0) {\n-            return Params.MAX_WIDTH_FOR_LAYOUT;\n-        }\n-        w -= leftPadding - rightPadding - snapSpaceX(Params.LAYOUT_FOCUS_BORDER) - snapSpaceX(Params.LAYOUT_FOCUS_BORDER);\n-        if (w < 0.0) {\n-            w = 0.0;\n-        }\n-        return snapSpaceX(w);\n-    }\n-\n-    \/** height of the area available for text cells. *\/\n-    private double viewPortHeight() {\n-        double h = flow.getHeight() - snapSpaceX(Params.LAYOUT_FOCUS_BORDER) - snapSpaceX(Params.LAYOUT_FOCUS_BORDER);\n-        if (h < 0.0) {\n-            h = 0.0;\n-        }\n-        return h;\n+        setOrigin(new Origin(0, -contentPaddingTop));\n+        handleWrapText();\n+\/\/        setUnwrappedContentWidth(0.0);\n+\/\/        setOffsetX(0.0);\n+\/\/        requestControlLayout(true);\n+\/\/        control.select(TextPos.ZERO);\n@@ -253,1 +245,1 @@\n-    public final void handleWrapText() {\n+    public void handleWrapText() {\n@@ -255,1 +247,1 @@\n-            double w = viewPortWidth();\n+            double w = viewPortWidth;\n@@ -260,1 +252,1 @@\n-        setOffsetX(-leftPadding);\n+        setOffsetX(0.0);\n@@ -262,0 +254,1 @@\n+        layoutChildren();\n@@ -296,1 +289,9 @@\n-        updateContentPadding();\n+        Insets m = control.getContentPadding();\n+        if (m == null) {\n+            m = Insets.EMPTY;\n+        }\n+\n+        contentPaddingLeft = snapPositionX(m.getLeft());\n+        contentPaddingRight = snapPositionX(m.getRight());\n+        contentPaddingTop = snapPositionY(m.getTop());\n+        contentPaddingBottom = snapPositionY(m.getBottom());\n@@ -298,1 +299,1 @@\n-        setOffsetX(-leftPadding);\n+        setOffsetX(0.0);\n@@ -301,1 +302,1 @@\n-            setOrigin(new Origin(0, -topPadding));\n+            setOrigin(new Origin(0, -contentPaddingTop));\n@@ -309,12 +310,0 @@\n-    public void updateContentPadding() {\n-        Insets m = control.getContentPadding();\n-        if (m == null) {\n-            m = Insets.EMPTY;\n-        }\n-\n-        leftPadding = snapPositionX(m.getLeft());\n-        rightPadding = snapPositionX(m.getRight());\n-        topPadding = snapPositionY(m.getTop());\n-        bottomPadding = snapPositionY(m.getBottom());\n-    }\n-\n@@ -322,1 +311,1 @@\n-        return leftPadding;\n+        return contentPaddingLeft;\n@@ -340,1 +329,1 @@\n-            or = new Origin(0, -topPadding);\n+            or = new Origin(0, -contentPaddingTop);\n@@ -355,1 +344,1 @@\n-    public double getOffsetX() {\n+    public final double getOffsetX() {\n@@ -359,1 +348,1 @@\n-    public void setOffsetX(double x) {\n+    private final void setOffsetX(double x) {\n@@ -362,1 +351,3 @@\n-            x = -leftPadding;\n+            x = 0.0;\n+        } else {\n+            x = Math.max(0.0, snapPositionX(x));\n@@ -365,10 +356,1 @@\n-    }\n-\n-    \/** horizontal scroll offset *\/\n-    public DoubleProperty offsetXProperty() {\n-        return offsetX;\n-    }\n-\n-    \/** max width of all visible text cells (cells within the viewport), excluding content padding *\/\n-    private double unwrappedContentWidth() {\n-        return unwrappedContentWidth;\n+        content.setTranslateX(-x);\n@@ -378,2 +360,8 @@\n-        if (w < Params.LAYOUT_MIN_WIDTH) {\n-            w = Params.LAYOUT_MIN_WIDTH;\n+        \/\/ TODO remove this check later\n+        if (Math.abs(w - snapPositionX(w)) > 0.0001) {\n+            System.err.println(\"unwrapped position is not snapped!\");\n+        }\n+\n+        double min = snapPositionX(Params.LAYOUT_MIN_WIDTH);\n+        if (w < min) {\n+            w = min;\n@@ -384,0 +372,5 @@\n+    \/** returns the content width, including padding and horizontal guard, snapped *\/\n+    private double contentWidth() {\n+        return unwrappedContentWidth + contentPaddingLeft + contentPaddingRight + snapPositionX(Params.HORIZONTAL_GUARD);\n+    }\n+\n@@ -393,11 +386,2 @@\n-    protected void handleWidthChange() {\n-        if (control.isWrapText()) {\n-            double w = viewPortWidth();\n-            setUnwrappedContentWidth(w);\n-        } else {\n-            double w = getOffsetX() + flow.getWidth();\n-            double uw = arrangement.getUnwrappedWidth();\n-            if (uw > w) {\n-                w = uw;\n-            }\n-\n+    void handleWidthChange() {\n+        if (!control.isWrapText()) {\n@@ -405,1 +389,1 @@\n-            double delta = unwrappedContentWidth() + rightPadding - getOffsetX() - viewPortWidth();\n+            double delta = unwrappedContentWidth + contentPaddingRight - getOffsetX() - viewPortWidth;\n@@ -408,1 +392,1 @@\n-                if (off > -leftPadding) {\n+                if (off > -contentPaddingLeft) {\n@@ -413,1 +397,0 @@\n-            \/\/ TODO set visibility\n@@ -416,0 +399,6 @@\n+        requestLayout();\n+    }\n+\n+    \/** reacts to height changes *\/\n+    void handleHeightChange() {\n+        requestLayout();\n@@ -455,1 +444,1 @@\n-        selectionHighlight.setTranslateX(leftPadding);\n+        selectionHighlight.setTranslateX(contentPaddingLeft);\n@@ -461,1 +450,1 @@\n-        caretPath.setTranslateX(leftPadding);\n+        caretPath.setTranslateX(contentPaddingLeft);\n@@ -521,3 +510,2 @@\n-        double left = -leftPadding;\n-        double right = unwrappedContentWidth() + leftPadding + rightPadding;\n-        \/\/ TODO\n+        double left = -contentPaddingLeft;\n+        double right = contentWidth();\n@@ -529,1 +517,1 @@\n-        new SelectionHelper(b, left, right).generate(top, bottom, topLTR, bottomLTR, leftPadding, lineSpacing);\n+        new SelectionHelper(b, left, right).generate(top, bottom, topLTR, bottomLTR, contentPaddingLeft, lineSpacing);\n@@ -540,1 +528,1 @@\n-                w = Math.max(getWidth(), unwrappedContentWidth());\n+                w = Math.max(getWidth(), contentWidth());\n@@ -548,3 +536,1 @@\n-        \/\/ convert to cell coordinates\n-        double x = localX + getOffsetX();\n-        return arrangement().getTextPos(x, localY);\n+        return arrangement().getTextPos(localX - contentPaddingLeft, localY);\n@@ -553,2 +539,1 @@\n-    \/** in vflow.flow coordinates *\/\n-    \/\/ TODO vflow.flow? or content?\n+    \/** in vflow.content coordinates *\/\n@@ -556,1 +541,1 @@\n-        return arrangement().getCaretInfo(flow, getOffsetX() + leftPadding, p);\n+        return arrangement().getCaretInfo(content, p);\n@@ -563,1 +548,1 @@\n-            return null; \/\/ TODO check\n+            return null;\n@@ -605,4 +590,0 @@\n-        Insets m = contentPadding();\n-        double dx = -m.getLeft();\n-        double dy = 0.0;\n-\n@@ -612,1 +593,1 @@\n-            pe = cell.getCaretShape(flow, startOffset, true, dx, dy);\n+            pe = cell.getCaretShape(content, startOffset, true, -contentPaddingLeft, 0.0);\n@@ -614,1 +595,1 @@\n-            pe = cell.getRangeShape(flow, startOffset, endOffset, dx, dy);\n+            pe = cell.getRangeShape(content, startOffset, endOffset, -contentPaddingLeft, 0.0);\n@@ -680,4 +661,0 @@\n-        vscroll.setMin(0.0);\n-        vscroll.setMax(1.0);\n-        vscroll.setUnitIncrement(Params.SCROLL_BARS_UNIT_INCREMENT);\n-        vscroll.setBlockIncrement(Params.SCROLL_BARS_BLOCK_INCREMENT);\n@@ -709,2 +686,1 @@\n-        boolean wrap = control.isWrapText();\n-        if (wrap) {\n+        if (control.isWrapText()) {\n@@ -714,3 +690,3 @@\n-        double max = unwrappedContentWidth() + leftPadding + rightPadding;\n-        double w = flow.getWidth();\n-        double off = getOffsetX() + leftPadding;\n+        double max = contentWidth();\n+        double w = vport.getWidth();\n+        double off = getOffsetX();\n@@ -722,4 +698,0 @@\n-        hscroll.setMin(0.0);\n-        hscroll.setMax(1.0);\n-        hscroll.setUnitIncrement(Params.SCROLL_BARS_UNIT_INCREMENT);\n-        hscroll.setBlockIncrement(Params.SCROLL_BARS_BLOCK_INCREMENT);\n@@ -735,3 +707,1 @@\n-            if (arrangement == null) {\n-                return;\n-            } else if (control.isWrapText()) {\n+            if ((arrangement == null) || control.isWrapText()) {\n@@ -741,2 +711,2 @@\n-            double max = unwrappedContentWidth() + leftPadding + rightPadding;\n-            double visible = flow.getWidth();\n+            double max = contentWidth();\n+            double visible = vport.getWidth();\n@@ -744,1 +714,1 @@\n-            double off = fromScrollBarValue(val, visible, max) - leftPadding;\n+            double off = fromScrollBarValue(val, visible, max);\n@@ -746,4 +716,1 @@\n-            setOffsetX(snapPositionX(off));\n-            \/\/ no need to recompute the flow\n-            placeCells();\n-            updateCaretAndSelection();\n+            setOffsetX(off);\n@@ -883,1 +850,1 @@\n-                flow.getChildren().add(n);\n+                content.getChildren().add(n);\n@@ -891,1 +858,1 @@\n-                    flow.getChildren().remove(n);\n+                    content.getChildren().remove(n);\n@@ -902,31 +869,0 @@\n-    @Override\n-    protected void layoutChildren() {\n-        reflow();\n-    }\n-\n-    protected void reflow() {\n-        inReflow = true;\n-        try {\n-            \/\/ remove old nodes, if any\n-            if (arrangement != null) {\n-                arrangement.removeNodesFrom(flow);\n-                arrangement = null;\n-            }\n-\n-            arrangement = new CellArrangement(this);\n-            layoutCells();\n-\n-            checkForExcessiveWhitespaceAtTheEnd();\n-            updateCaretAndSelection();\n-\n-            \/\/ eliminate VSB during scrolling with a mouse\n-            \/\/ the VSB will finally get updated on mouse released event\n-            if (!vsbPressed) {\n-                updateVerticalScrollBar();\n-            }\n-        } finally {\n-            dirty = false;\n-            inReflow = false;\n-        }\n-    }\n-\n@@ -936,1 +872,1 @@\n-            reflow();\n+            layoutChildren();\n@@ -941,6 +877,3 @@\n-    \/** recomputes sliding window *\/\n-    protected void layoutCells() {\n-        if (control.getModel() == null) {\n-            leftGutter.setVisible(false);\n-            rightGutter.setVisible(false);\n-            return;\n+    private double getLineSpacing(Region r) {\n+        if (r instanceof TextFlow f) {\n+            return f.getLineSpacing();\n@@ -948,0 +881,2 @@\n+        return 0.0;\n+    }\n@@ -949,4 +884,3 @@\n-        double width = getWidth();\n-        if(width == 0.0) {\n-            return;\n-        }\n+    public double getViewPortHeight() {\n+        return viewPortHeight;\n+    }\n@@ -954,5 +888,3 @@\n-        \/\/ sides\n-        SideDecorator leftDecorator = control.getLeftDecorator();\n-        SideDecorator rightDecorator = control.getRightDecorator();\n-        leftSide = computeSideWidth(leftDecorator);\n-        rightSide = computeSideWidth(rightDecorator);\n+    public void pageUp() {\n+        scrollVerticalPixels(-getViewPortHeight());\n+    }\n@@ -960,5 +892,3 @@\n-        int paragraphCount = getParagraphCount();\n-        boolean useContentHeight = control.isUseContentHeight();\n-        boolean useContentWidth = control.isUseContentWidth();\n-        boolean wrap = control.isWrapText() && !useContentWidth;\n-        double height = useContentHeight ? 0.0 : getHeight();\n+    public void pageDown() {\n+        scrollVerticalPixels(getViewPortHeight());\n+    }\n@@ -966,8 +896,17 @@\n-        double forWidth;\n-        double maxWidth;\n-        if (wrap) {\n-            forWidth = viewPortWidth();\n-            maxWidth = forWidth;\n-        } else {\n-            forWidth = -1.0;\n-            maxWidth = Params.MAX_WIDTH_FOR_LAYOUT;\n+    public void scrollVerticalFraction(double fractionOfHeight) {\n+        scrollVerticalPixels(getViewPortHeight() * fractionOfHeight);\n+    }\n+\n+    \/** scroll by a number of pixels, delta must not exceed the view height in absolute terms *\/\n+    public void scrollVerticalPixels(double delta) {\n+        scrollVerticalPixels(delta, false);\n+    }\n+\n+    \/** scroll by a number of pixels, delta must not exceed the view height in absolute terms *\/\n+    public void scrollVerticalPixels(double delta, boolean forceLayout) {\n+        Origin or = arrangement().computeOrigin(delta);\n+        if (or != null) {\n+            setOrigin(or);\n+            if (forceLayout) {\n+                layoutChildren();\n+            }\n@@ -975,0 +914,1 @@\n+    }\n@@ -976,11 +916,4 @@\n-        double ytop = snapPositionY(-getOrigin().offset());\n-        double y = ytop;\n-        double unwrappedWidth = 0.0;\n-        double total = 0.0;\n-        double margin = Params.SLIDING_WINDOW_EXTENT * height;\n-        int topMarginCount = 0;\n-        int bottomMarginCount = 0;\n-        int count = 0;\n-        boolean visible = true;\n-        \/\/ TODO if topCount < marginCount, increase bottomCount correspondingly\n-        \/\/ also, update Origin if layout hit the beginning\/end of the document\n+    public void scrollHorizontalFraction(double delta) {\n+        double w = content.getWidth() + contentPaddingLeft + contentPaddingRight;\n+        scrollHorizontalPixels(delta * w);\n+    }\n@@ -988,9 +921,7 @@\n-        \/\/ populating visible part of the sliding window + bottom margin\n-        int i = topCellIndex();\n-        for ( ; i < paragraphCount; i++) {\n-            TextCell cell = getCell(i);\n-            \/\/ TODO skip computation if layout width is the same\n-            Region r = cell.getContent();\n-            flow.getChildren().add(cell);\n-            cell.setMaxWidth(maxWidth);\n-            cell.setMaxHeight(USE_COMPUTED_SIZE);\n+    public void scrollHorizontalPixels(double delta) {\n+        double x = getOffsetX() + delta;\n+        if ((x + vport.getWidth()) > contentWidth()) {\n+            x = contentWidth() - vport.getWidth();\n+        }\n+        setOffsetX(x);\n+    }\n@@ -998,2 +929,11 @@\n-            cell.applyCss();\n-            cell.layout();\n+    \/** x in vflow.content coordinate *\/\n+    private void scrollHorizontalToVisible(double x) {\n+        if (!control.isWrapText()) {\n+            double off;\n+            if (x < getOffsetX()) {\n+                off = x - Params.HORIZONTAL_GUARD;\n+            } else if (x > (getOffsetX() + vport.getWidth())) {\n+                off = x + Params.HORIZONTAL_GUARD - vport.getWidth();\n+            } else {\n+                return;\n+            }\n@@ -1001,1 +941,3 @@\n-            arrangement.addCell(cell);\n+            setOffsetX(off);\n+        }\n+    }\n@@ -1003,3 +945,9 @@\n-            double h = cell.prefHeight(forWidth) + getLineSpacing(r);\n-            h = snapSizeY(h); \/\/ is this right?  or snap(y + h) - snap(y) ?\n-            cell.setPosition(y, h\/*, forWidth*\/);\n+    \/** scrolls to visible area, using vflow.content coordinates *\/\n+    public void scrollToVisible(double x, double y) {\n+        if (y < 0.0) {\n+            \/\/ above viewport\n+            scrollVerticalPixels(y);\n+        } else if (y >= getViewPortHeight()) {\n+            \/\/ below viewport\n+            scrollVerticalPixels(y - getViewPortHeight());\n+        }\n@@ -1007,6 +955,17 @@\n-            if (!wrap) {\n-                if (visible) {\n-                    double w = cell.prefWidth(-1);\n-                    if (w > unwrappedWidth) {\n-                        unwrappedWidth = w;\n-                    }\n+        scrollHorizontalToVisible(x);\n+    }\n+\n+    public void scrollCaretToVisible() {\n+        CaretInfo c = getCaretInfo();\n+        if (c == null) {\n+            \/\/ caret is outside of the layout; let's set the origin first to the caret position\n+            \/\/ and then block scroll to avoid scrolling past the document end, if needed\n+            TextPos p = control.getCaretPosition();\n+            if (p != null) {\n+                int ix = p.index();\n+                Origin or = new Origin(ix, 0.0);\n+                boolean moveDown = (ix > getOrigin().index());\n+                setOrigin(or);\n+                c = getCaretInfo();\n+                if (moveDown) {\n+                    scrollVerticalPixels(c.getMaxY() - c.getMinY() - getViewPortHeight());\n@@ -1014,0 +973,8 @@\n+                checkForExcessiveWhitespaceAtTheEnd();\n+            }\n+        } else {\n+            \/\/ block scroll, if needed\n+            if (c.getMinY() < 0.0) {\n+                scrollVerticalPixels(c.getMinY());\n+            } else if (c.getMaxY() > getViewPortHeight()) {\n+                scrollVerticalPixels(c.getMaxY() - getViewPortHeight());\n@@ -1016,19 +983,5 @@\n-            y = snapPositionY(y + h);\n-            total += h;\n-            count++;\n-\n-            if (useContentHeight) {\n-                height = y;\n-                if (y > Params.MAX_HEIGHT_SAFEGUARD) {\n-                    break;\n-                }\n-            } else {\n-                \/\/ stop populating the bottom part of the sliding window\n-                \/\/ when exceeded both pixel and line count margins\n-                if (visible) {\n-                    if (y > height) {\n-                        topMarginCount = (int)Math.ceil(count * Params.SLIDING_WINDOW_EXTENT);\n-                        bottomMarginCount = count + topMarginCount;\n-                        arrangement.setVisibleCellCount(count);\n-                        visible = false;\n-                    }\n+            if (!control.isWrapText()) {\n+                \/\/ FIX primary caret\n+                double x = c.getMinX();\n+                if (x + contentPaddingLeft < 0.0) {\n+                    scrollHorizontalToVisible(x);\n@@ -1036,6 +989,1 @@\n-                    \/\/ remove invisible cell from layout after sizing\n-                    flow.getChildren().remove(cell);\n-\n-                    if ((y > (height + margin)) && (count > bottomMarginCount)) {\n-                        break;\n-                    }\n+                    scrollHorizontalToVisible(c.getMaxX());\n@@ -1045,0 +993,1 @@\n+    }\n@@ -1046,3 +995,9 @@\n-        \/\/ in case there are less paragraphs than can fit in the view\n-        if (visible) {\n-            arrangement.setVisibleCellCount(count);\n+    protected void checkForExcessiveWhitespaceAtTheEnd() {\n+        double delta = arrangement().bottomHeight() - getViewPortHeight();\n+        if (delta < 0) {\n+            if (getOrigin().index() == 0) {\n+                if (getOrigin().offset() <= -contentPaddingTop) {\n+                    return;\n+                }\n+            }\n+            scrollVerticalPixels(delta);\n@@ -1050,0 +1005,1 @@\n+    }\n@@ -1051,47 +1007,7 @@\n-        if (i == paragraphCount) {\n-            y += bottomPadding;\n-        }\n-\n-        \/\/ populate side nodes\n-        if (leftDecorator != null) {\n-            if (leftCache == null) {\n-                leftCache = updateSideCache(leftDecorator, null);\n-            }\n-\n-            for (i = 0; i < arrangement.getVisibleCellCount(); i++) {\n-                TextCell cell = arrangement.getCellAt(i);\n-                int ix = cell.getIndex();\n-                Node n = leftCache.get(ix);\n-                if (n == null) {\n-                    n = leftDecorator.getNode(ix, false);\n-                    if (n != null) {\n-                        n.setManaged(false);\n-                        leftCache.add(ix, n);\n-                    }\n-                }\n-                if (n != null) {\n-                    arrangement.addLeftNode(i, n);\n-                }\n-            }\n-        }\n-\n-        if (rightDecorator != null) {\n-            if (rightCache == null) {\n-                rightCache = updateSideCache(rightDecorator, null);\n-            }\n-\n-            for (i = 0; i < arrangement.getVisibleCellCount(); i++) {\n-                TextCell cell = arrangement.getCellAt(i);\n-                int ix = cell.getIndex();\n-                Node n = rightCache.get(ix);\n-                if (n == null) {\n-                    n = rightDecorator.getNode(cell.getIndex(), false);\n-                    if (n != null) {\n-                        n.setManaged(false);\n-                        rightCache.add(ix, n);\n-                    }\n-                }\n-                if (n != null) {\n-                    arrangement.addRightNode(i, n);\n-                }\n-            }\n+    @Override\n+    public void onContentChange(ContentChange ch) {\n+        if (ch.isEdit()) {\n+            Origin newOrigin = computeNewOrigin(ch);\n+            if (newOrigin != null) {\n+                setOrigin(newOrigin);\n+            }\n@@ -1099,0 +1015,6 @@\n+        \/\/ TODO this could be more advanced to reduce the amount of re-computation and re-flow\n+        \/\/ TODO clear cache >= start, update layout\n+        cellCache.clear();\n+        \/\/ TODO rebuild from start.lineIndex()\n+        requestLayout();\n+    }\n@@ -1100,1 +1022,6 @@\n-        unwrappedWidth = snapSizeX(unwrappedWidth);\n+    private Origin computeNewOrigin(ContentChange ch) {\n+        int startIndex = ch.getStart().index();\n+        int endIndex = ch.getEnd().index();\n+        \/\/ TODO store position of the last visible symbol, use that to compare with 'start' to avoid reflow\n+        Origin or = getOrigin();\n+        int lineDelta = endIndex - startIndex + ch.getLinesAdded();\n@@ -1102,2 +1029,3 @@\n-        if(topCellIndex() > 0) {\n-            total = Double.POSITIVE_INFINITY;\n+        \/\/ jump to start if the old origin is within the changed range\n+        if ((startIndex <= or.index()) && (or.index() < (startIndex + lineDelta))) {\n+            return new Origin(startIndex, 0);\n@@ -1106,35 +1034,11 @@\n-        arrangement.setBottomCount(count);\n-        arrangement.setBottomHeight(y);\n-        arrangement.setUnwrappedWidth(unwrappedWidth);\n-        arrangement.setTotalHeight(total);\n-        count = 0;\n-        y = ytop;\n-\n-        \/\/ populate top margin, going backwards from topCellIndex\n-        \/\/ TODO populate more, if bottom ended prematurely\n-        for (i = topCellIndex() - 1; i >= 0; i--) {\n-            TextCell cell = getCell(i);\n-            \/\/ TODO maybe skip computation if layout width is the same\n-            Region r = cell.getContent();\n-            flow.getChildren().add(cell);\n-            cell.setMaxWidth(maxWidth);\n-            cell.setMaxHeight(USE_COMPUTED_SIZE);\n-\n-            cell.applyCss();\n-            cell.layout();\n-\n-            arrangement.addCell(cell);\n-\n-            double h = cell.prefHeight(forWidth) + getLineSpacing(r);\n-            h = snapSizeY(h); \/\/ is this right?  or snap(y + h) - snap(y) ?\n-            y = snapPositionY(y - h);\n-            count++;\n-\n-            cell.setPosition(y, h\/*, forWidth*\/);\n-\n-            flow.getChildren().remove(cell);\n-\n-            \/\/ stop populating the top part of the sliding window\n-            \/\/ when exceeded both pixel and line count margins\n-            if ((-y > margin) && (count > topMarginCount)) {\n-                break;\n+        \/\/ adjust index only if the end precedes the origin\n+        if (lineDelta != 0) {\n+            if (\n+                (endIndex < or.index()) ||\n+                (\n+                    (endIndex == or.index()) &&\n+                    (ch.getEnd().offset() < or.offset())\n+                )\n+            )\n+            {\n+                return new Origin(or.index() + lineDelta, or.offset());\n@@ -1144,5 +1048,2 @@\n-        arrangement.setTopHeight(-y);\n-\n-        if (useContentWidth) {\n-            width = unwrappedWidth + leftSide + rightSide + leftPadding + rightPadding;\n-        }\n+        return null;\n+    }\n@@ -1150,6 +1051,4 @@\n-        \/\/ lay out gutters\n-        if (leftDecorator == null) {\n-            leftGutter.setVisible(false); \/\/ TODO perhaps use bindings, and rely on .isVisible() here?\n-        } else {\n-            leftGutter.setVisible(true);\n-            layoutInArea(leftGutter, 0.0, 0.0, leftSide, height, 0.0, HPos.CENTER, VPos.CENTER);\n+    @Override\n+    public StyleAttributeMap resolveStyles(StyleAttributeMap attrs) {\n+        if (attrs == null) {\n+            return attrs;\n@@ -1157,6 +1056,4 @@\n-\n-        if (rightDecorator == null) {\n-            rightGutter.setVisible(false);\n-        } else {\n-            rightGutter.setVisible(true);\n-            layoutInArea(rightGutter, width - rightSide, 0.0, rightSide, height, 0.0, HPos.CENTER, VPos.CENTER);\n+        CssStyles css = attrs.get(CssStyles.CSS);\n+        if (css == null) {\n+            \/\/ no conversion is needed\n+            return attrs;\n@@ -1165,8 +1062,2 @@\n-        layoutInArea(content, leftSide, 0.0, width - leftSide - rightSide, height, 0.0, HPos.CENTER, VPos.CENTER);\n-\n-        if (wrap) {\n-            double w = viewPortWidth();\n-            setUnwrappedContentWidth(w);\n-        } else {\n-            if (unwrappedContentWidth() != unwrappedWidth) {\n-                setUnwrappedContentWidth(unwrappedWidth);\n+        String directStyle = css.style();\n+        String[] names = css.names();\n@@ -1174,3 +1065,7 @@\n-                if (useContentWidth) {\n-                    requestControlLayout(false);\n-                }\n+        getChildren().add(measurer);\n+        try {\n+            measurer.setStyle(directStyle);\n+            if (names == null) {\n+                measurer.getStyleClass().clear();\n+            } else {\n+                measurer.getStyleClass().setAll(names);\n@@ -1178,0 +1073,4 @@\n+            measurer.applyCss();\n+            return StyleAttributeMap.fromTextNode(measurer);\n+        } finally {\n+            getChildren().remove(measurer);\n@@ -1179,0 +1078,1 @@\n+    }\n@@ -1180,2 +1080,14 @@\n-        if (useContentWidth) {\n-            updatePrefWidth();\n+    @Override\n+    public WritableImage snapshot(Node n) {\n+        n.setManaged(false);\n+        getChildren().add(n);\n+        try {\n+            n.applyCss();\n+            if (n instanceof Region r) {\n+                double w = unwrappedContentWidth;\n+                double h = r.prefHeight(w);\n+                RichUtils.layoutInArea(r, 0, -h, w, h);\n+            }\n+            return n.snapshot(null, null);\n+        } finally {\n+            getChildren().remove(n);\n@@ -1183,0 +1095,1 @@\n+    }\n@@ -1184,8 +1097,6 @@\n-        boolean vsbVisible = useContentHeight ?\n-            false :\n-            (arrangement().getTotalHeight() + topPadding + bottomPadding) > viewPortHeight();\n-\n-        if (vsbVisible != vscroll.isVisible()) {\n-            vscroll.setVisible(vsbVisible);\n-            requestParentLayout();\n-            \/\/System.out.println(\"vsb visible=\" + vsbVisible); \/\/ FIX\n+    public void handleUseContentHeight() {\n+        boolean on = control.isUseContentHeight();\n+        if (on) {\n+            setUnwrappedContentWidth(0.0);\n+            setOrigin(new Origin(0, -contentPaddingTop));\n+            setOffsetX(0.0);\n@@ -1193,0 +1104,2 @@\n+        requestControlLayout(false);\n+    }\n@@ -1194,8 +1107,6 @@\n-        boolean hsbVisible = (wrap || useContentWidth) ?\n-            false :\n-            (unwrappedWidth + leftPadding + rightPadding) > viewPortWidth();\n-\n-        if (hscroll.isVisible() != hsbVisible) {\n-            hscroll.setVisible(hsbVisible);\n-            requestParentLayout();\n-            \/\/System.out.println(\"hsb visible=\" + hsbVisible); \/\/ FIX\n+    public void handleUseContentWidth() {\n+        boolean on = control.isUseContentWidth();\n+        if (on) {\n+            setUnwrappedContentWidth(0.0);\n+            setOrigin(new Origin(0, -contentPaddingTop));\n+            setOffsetX(0.0);\n@@ -1203,0 +1114,2 @@\n+        requestControlLayout(false);\n+    }\n@@ -1204,8 +1117,5 @@\n-        if (useContentHeight) {\n-            double h = getFlowHeight();\n-            double prev = getPrefHeight();\n-            setPrefHeight(h);\n-            \/\/System.out.println(\"vflow.setPrefHeight=\" + h + \" prev=\" + prev); \/\/ FIX\n-\n-            \/\/ this \"works\" except for change model\n-            requestParentLayout();\n+    @Override\n+    public void requestLayout() {\n+        dirty = true;\n+        super.requestLayout();\n+    }\n@@ -1213,10 +1123,7 @@\n-            \/\/ avoids infinite layout loop in MultipleStackedBoxWindow but ... why?\n-            if (h != prev) {\n-                requestLayout();\n-                \/\/ weird, need this to make sure the reflow happens when changing models\n-                Platform.runLater(() -> layoutChildren());\n-            }\n-        } else {\n-            if (getPrefHeight() != USE_COMPUTED_SIZE) {\n-                setPrefHeight(USE_COMPUTED_SIZE);\n-            }\n+    \/**\n+     * Requests full layout with optional clearing of the cached cells.\n+     * @param clearCache if true, clears the cell cache\n+     *\/\n+    public void requestControlLayout(boolean clearCache) {\n+        if (clearCache) {\n+            cellCache.clear();\n@@ -1224,2 +1131,2 @@\n-\n-        placeCells();\n+        requestParentLayout();\n+        requestLayout();\n@@ -1228,20 +1135,9 @@\n-    protected void placeCells() {\n-        boolean wrap = control.isWrapText() && !control.isUseContentWidth();\n-        double w = wrap ? viewPortWidth() : Params.MAX_WIDTH_FOR_LAYOUT;\n-        double x = snapPositionX(-getOffsetX());\n-\n-        leftGutter.getChildren().clear();\n-        rightGutter.getChildren().clear();\n-\n-        boolean addLeft = control.getLeftDecorator() != null;\n-        boolean addRight = control.getRightDecorator() != null;\n-\n-        int sz = arrangement.getVisibleCellCount();\n-        for (int i = 0; i < sz; i++) {\n-            TextCell cell = arrangement.getCellAt(i);\n-            double h = cell.getCellHeight();\n-            double y = cell.getY();\n-            flow.layoutInArea(cell, x, y, w, h);\n-\n-            \/\/ this step is needed to get the correct caret path afterwards\n-            cell.layout();\n+    private void updatePrefWidth() {\n+        if (!control.prefWidthProperty().isBound()) {\n+            double w =\n+                arrangement().getUnwrappedWidth() +\n+                snapSizeX(leftSide) +\n+                snapSizeX(rightSide) +\n+                contentPaddingLeft +\n+                contentPaddingRight +\n+                snapSizeX(Params.HORIZONTAL_GUARD);\n@@ -1249,7 +1145,3 @@\n-            \/\/ place side nodes\n-            if (addLeft) {\n-                Node n = arrangement.getLeftNodeAt(i);\n-                if (n != null) {\n-                    leftGutter.getChildren().add(n);\n-                    n.applyCss();\n-                    leftGutter.layoutInArea(n, 0.0, y, leftGutter.getWidth(), h);\n+            if (w >= 0.0) {\n+                if (vscroll.isVisible()) {\n+                    w += vscroll.getWidth();\n@@ -1259,6 +1151,6 @@\n-            if (addRight) {\n-                Node n = arrangement.getRightNodeAt(i);\n-                if (n != null) {\n-                    rightGutter.getChildren().add(n);\n-                    n.applyCss();\n-                    rightGutter.layoutInArea(n, 0.0, y, rightGutter.getWidth(), h);\n+            Parent parent = getParent();\n+            if (parent instanceof Region r) {\n+                if (r.getPrefWidth() != w) {\n+                    r.setPrefWidth(w);\n+                    control.getParent().requestLayout();\n+                    requestControlLayout(false);\n@@ -1270,3 +1162,8 @@\n-    private double getLineSpacing(Region r) {\n-        if (r instanceof TextFlow f) {\n-            return f.getLineSpacing();\n+    @Override\n+    protected double computePrefHeight(double width) {\n+        if (control.isUseContentHeight()) {\n+            double h = snapSizeY(Math.max(Params.LAYOUT_MIN_HEIGHT, arrangement().bottomHeight())) + snappedTopInset() + snappedBottomInset();\n+            if (hscroll.isVisible()) {\n+                h += hscroll.prefHeight(width);\n+            }\n+            return h;\n@@ -1274,1 +1171,1 @@\n-        return 0.0;\n+        return super.computePrefHeight(width);\n@@ -1277,2 +1174,10 @@\n-    public double getViewHeight() {\n-        return flow.getHeight();\n+    @Override\n+    protected double computePrefWidth(double height) {\n+        if (control.isUseContentWidth()) {\n+            double w = contentWidth() + leftSide + rightSide + snappedLeftInset() + snappedRightInset();\n+            if (vscroll.isVisible()) {\n+                w += vscroll.prefWidth(height);\n+            }\n+            return w;\n+        }\n+        return super.computePrefWidth(height);\n@@ -1281,3 +1186,5 @@\n-    public void pageUp() {\n-        scrollVerticalPixels(-getViewHeight());\n-    }\n+    @Override\n+    protected void layoutChildren() {\n+        inReflow = true;\n+        try {\n+            layoutCells();\n@@ -1285,3 +1192,2 @@\n-    public void pageDown() {\n-        scrollVerticalPixels(getViewHeight());\n-    }\n+            checkForExcessiveWhitespaceAtTheEnd();\n+            updateCaretAndSelection();\n@@ -1289,2 +1195,9 @@\n-    public void scrollVerticalFraction(double fractionOfHeight) {\n-        scrollVerticalPixels(getViewHeight() * fractionOfHeight);\n+            \/\/ eliminate VSB jitter during scrolling with a mouse\n+            \/\/ the VSB will finally get updated on mouse released event\n+            if (!vsbPressed) {\n+                updateVerticalScrollBar();\n+            }\n+        } finally {\n+            dirty = false;\n+            inReflow = false;\n+        }\n@@ -1293,4 +1206,11 @@\n-    \/** scroll by a number of pixels, delta must not exceed the view height in absolute terms *\/\n-    public void scrollVerticalPixels(double delta) {\n-        scrollVerticalPixels(delta, false);\n-    }\n+    \/**\n+     * Recomputes sliding window and lays out scrollbars, left\/right sides, and viewport.\n+     * This process might be repeated if one of the scroll bars changes its visibility as a result.\n+     * (up to 4 times worst case)\n+     *\/\n+    protected void layoutCells() {\n+        if (arrangement != null) {\n+            arrangement.removeNodesFrom(content);\n+            arrangement = null;\n+        }\n+        arrangement = new CellArrangement(this);\n@@ -1298,8 +1218,3 @@\n-    \/** scroll by a number of pixels, delta must not exceed the view height in absolute terms *\/\n-    public void scrollVerticalPixels(double delta, boolean forceLayout) {\n-        Origin or = arrangement().computeOrigin(delta);\n-        if (or != null) {\n-            setOrigin(or);\n-            if (forceLayout) {\n-                layoutChildren();\n-            }\n+        double width = getWidth();\n+        if (width == 0.0) {\n+            return;\n@@ -1307,1 +1222,0 @@\n-    }\n@@ -1309,4 +1223,4 @@\n-    public void scrollHorizontalFraction(double delta) {\n-        double w = flow.getWidth() + leftPadding + rightPadding;\n-        scrollHorizontalPixels(delta * w);\n-    }\n+        double padTop = snappedTopInset();\n+        double padBottom = snappedBottomInset();\n+        double padLeft = snappedLeftInset();\n+        double padRight = snappedRightInset();\n@@ -1314,13 +1228,5 @@\n-    public void scrollHorizontalPixels(double delta) {\n-        double off = getOffsetX() + delta;\n-        double w = flow.getWidth();\n-        if (off < -leftPadding) {\n-            off = -leftPadding;\n-        } else if (off + w > (unwrappedContentWidth() + leftPadding)) {\n-            off = Math.max(0.0, unwrappedContentWidth() + leftPadding - w);\n-        }\n-        setOffsetX(off);\n-        \/\/ no need to recompute the flow\n-        placeCells();\n-        updateCaretAndSelection();\n-    }\n+        \/\/ sides\n+        SideDecorator leftDecorator = control.getLeftDecorator();\n+        SideDecorator rightDecorator = control.getRightDecorator();\n+        leftSide = computeSideWidth(leftDecorator);\n+        rightSide = computeSideWidth(rightDecorator);\n@@ -1328,8 +1234,18 @@\n-    \/** scrolls to visible area, using vflow.content coordinates *\/\n-    public void scrollToVisible(double x, double y) {\n-        if (y < 0.0) {\n-            \/\/ above viewport\n-            scrollVerticalPixels(y);\n-        } else if (y >= getViewHeight()) {\n-            \/\/ below viewport\n-            scrollVerticalPixels(y - getViewHeight());\n+        int paragraphCount = getParagraphCount();\n+        boolean useContentHeight = control.isUseContentHeight();\n+        boolean useContentWidth = control.isUseContentWidth();\n+        boolean wrap = control.isWrapText() && !useContentWidth;\n+        \/\/ FIX height as in component height vs. contentHeight in useContentHeight!\n+        \/\/double height = useContentHeight ? (padTop + padBottom + contentPaddingTop + contentPaddingBottom) : getHeight();\n+        double height = getHeight();\n+        double vsbWidth = vscroll.isVisible() ? vscroll.prefWidth(-1) : 0.0;\n+        double hsbHeight = hscroll.isVisible() ? hscroll.prefHeight(-1) : 0.0;\n+\n+        double forWidth; \/\/ to be used for cell sizing in prefHeight()\n+        double maxWidth; \/\/ TODO what is it?  replace with cell's preferred width (in unwrapped mode)\n+        if (wrap) {\n+            forWidth = width - leftSide - rightSide - contentPaddingLeft - contentPaddingRight - vsbWidth - padLeft - padRight;\n+            maxWidth = forWidth;\n+        } else {\n+            forWidth = -1.0;\n+            maxWidth = Params.MAX_WIDTH_FOR_LAYOUT;\n@@ -1338,2 +1254,3 @@\n-        scrollHorizontalToVisible(x);\n-    }\n+        double unwrappedWidth = 0.0;\n+        \/\/ total height of visible cells for the purpose of determining vsb visibility\n+        double arrangementHeight = 0.0;\n@@ -1341,15 +1258,34 @@\n-    public void scrollCaretToVisible() {\n-        CaretInfo c = getCaretInfo();\n-        if (c == null) {\n-            \/\/ caret is outside of the layout; let's set the origin first to the caret position\n-            \/\/ and then block scroll to avoid scrolling past the document end, if needed\n-            TextPos p = control.getCaretPosition();\n-            if (p != null) {\n-                int ix = p.index();\n-                Origin or = new Origin(ix, 0.0);\n-                boolean moveDown = (ix > getOrigin().index());\n-                setOrigin(or);\n-                \/\/ TODO this can be null?\n-                c = getCaretInfo();\n-                if (moveDown) {\n-                    scrollVerticalPixels(c.getMaxY() - c.getMinY() - getViewHeight());\n+        double ytop = snapPositionY(-getOrigin().offset());\n+        double y = ytop;\n+        double margin = Params.SLIDING_WINDOW_EXTENT * height;\n+        int topMarginCount = 0;\n+        int bottomMarginCount = 0;\n+        int count = 0;\n+        boolean cellOnScreen = true;\n+        \/\/ TODO if topCount < marginCount, increase bottomCount correspondingly\n+\n+        \/\/ populating visible part of the sliding window + bottom margin\n+        int i = topCellIndex();\n+        for ( ; i < paragraphCount; i++) {\n+            TextCell cell = getCell(i);\n+            \/\/ TODO skip computation if layout width is the same\n+            Region r = cell.getContent();\n+            content.getChildren().add(cell);\n+            cell.setMaxWidth(maxWidth);\n+            cell.setMaxHeight(USE_COMPUTED_SIZE);\n+            cell.applyCss();\n+            cell.layout();\n+\n+            arrangement.addCell(cell);\n+\n+            double h = cell.prefHeight(forWidth) + getLineSpacing(r);\n+            h = snapSizeY(h);\n+            cell.setPosition(y, h);\n+\n+            if (!wrap) {\n+                if (cellOnScreen) {\n+                    double w = cell.prefWidth(-1);\n+                    cell.setCellWidth(w);\n+                    if (w > unwrappedWidth) {\n+                        unwrappedWidth = w;\n+                    }\n@@ -1357,8 +1293,0 @@\n-                checkForExcessiveWhitespaceAtTheEnd();\n-            }\n-        } else {\n-            \/\/ block scroll, if needed\n-            if (c.getMinY() < 0.0) {\n-                scrollVerticalPixels(c.getMinY());\n-            } else if (c.getMaxY() > getViewHeight()) {\n-                scrollVerticalPixels(c.getMaxY() - getViewHeight());\n@@ -1367,5 +1295,19 @@\n-            if (!control.isWrapText()) {\n-                \/\/ FIX primary caret\n-                double x = c.getMinX();\n-                if (x + leftPadding < 0.0) {\n-                    scrollHorizontalToVisible(x);\n+            y = snapPositionY(y + h);\n+            arrangementHeight += h;\n+            count++;\n+\n+            if (useContentHeight) {\n+                \/\/ avoid laying out millions of invisible cells\n+                if (y > Params.MAX_HEIGHT_SAFEGUARD) {\n+                    break;\n+                }\n+            } else {\n+                \/\/ stop populating the bottom part of the sliding window\n+                \/\/ when exceeded both pixel and line count margins\n+                if (cellOnScreen) {\n+                    if (y > height) {\n+                        topMarginCount = (int)Math.ceil(count * Params.SLIDING_WINDOW_EXTENT);\n+                        bottomMarginCount = count + topMarginCount;\n+                        arrangement.setVisibleCellCount(count);\n+                        cellOnScreen = false;\n+                    }\n@@ -1373,1 +1315,6 @@\n-                    scrollHorizontalToVisible(c.getMaxX());\n+                    \/\/ remove invisible cell from layout after sizing\n+                    content.getChildren().remove(cell);\n+\n+                    if ((y > (height + margin)) && (count > bottomMarginCount)) {\n+                        break;\n+                    }\n@@ -1377,1 +1324,0 @@\n-    }\n@@ -1379,12 +1325,29 @@\n-    \/** x - vflow.content coordinate *\/\n-    private void scrollHorizontalToVisible(double x) {\n-        if (!control.isWrapText()) {\n-            x += leftPadding;\n-            double cw = flow.getWidth();\n-            double off;\n-            if (x < 0.0) {\n-                off = Math.max(getOffsetX() + x - Params.HORIZONTAL_GUARD, 0.0);\n-            } else if (x > cw) {\n-                off = getOffsetX() + x - cw + Params.HORIZONTAL_GUARD;\n-            } else {\n-                return;\n+        \/\/ in case there are less paragraphs than can fit in the view\n+        if (cellOnScreen) {\n+            arrangement.setVisibleCellCount(count);\n+        }\n+\n+        if (i == paragraphCount) {\n+            y += contentPaddingBottom;\n+        }\n+\n+        \/\/ populate side nodes\n+        if (leftDecorator != null) {\n+            if (leftCache == null) {\n+                leftCache = updateSideCache(leftDecorator, null);\n+            }\n+\n+            for (i = 0; i < arrangement.getVisibleCellCount(); i++) {\n+                TextCell cell = arrangement.getCellAt(i);\n+                int ix = cell.getIndex();\n+                Node n = leftCache.get(ix);\n+                if (n == null) {\n+                    n = leftDecorator.getNode(ix, false);\n+                    if (n != null) {\n+                        n.setManaged(false);\n+                        leftCache.add(ix, n);\n+                    }\n+                }\n+                if (n != null) {\n+                    arrangement.addLeftNode(i, n);\n+                }\n@@ -1392,4 +1355,0 @@\n-\n-            setOffsetX(off);\n-            placeCells();\n-            updateCaretAndSelection();\n@@ -1397,1 +1356,0 @@\n-    }\n@@ -1399,6 +1357,18 @@\n-    protected void checkForExcessiveWhitespaceAtTheEnd() {\n-        double delta = arrangement().bottomHeight() - getViewHeight();\n-        if (delta < 0) {\n-            if (getOrigin().index() == 0) {\n-                if (getOrigin().offset() <= -topPadding) {\n-                    return;\n+        if (rightDecorator != null) {\n+            if (rightCache == null) {\n+                rightCache = updateSideCache(rightDecorator, null);\n+            }\n+\n+            for (i = 0; i < arrangement.getVisibleCellCount(); i++) {\n+                TextCell cell = arrangement.getCellAt(i);\n+                int ix = cell.getIndex();\n+                Node n = rightCache.get(ix);\n+                if (n == null) {\n+                    n = rightDecorator.getNode(cell.getIndex(), false);\n+                    if (n != null) {\n+                        n.setManaged(false);\n+                        rightCache.add(ix, n);\n+                    }\n+                }\n+                if (n != null) {\n+                    arrangement.addRightNode(i, n);\n@@ -1407,1 +1377,0 @@\n-            scrollVerticalPixels(delta);\n@@ -1409,1 +1378,0 @@\n-    }\n@@ -1411,6 +1379,36 @@\n-    @Override\n-    public void onContentChange(ContentChange ch) {\n-        if (ch.isEdit()) {\n-            Origin newOrigin = computeNewOrigin(ch);\n-            if (newOrigin != null) {\n-                setOrigin(newOrigin);\n+        unwrappedWidth = snapSizeX(unwrappedWidth);\n+\n+        arrangement.setBottomCount(count);\n+        arrangement.setBottomHeight(y);\n+        arrangement.setUnwrappedWidth(unwrappedWidth);\n+        count = 0;\n+        y = ytop;\n+\n+        \/\/ populate top margin, going backwards from topCellIndex\n+        \/\/ TODO populate more, if bottom ended prematurely\n+        for (i = topCellIndex() - 1; i >= 0; i--) {\n+            TextCell cell = getCell(i);\n+            \/\/ TODO maybe skip computation if layout width is the same\n+            Region r = cell.getContent();\n+            content.getChildren().add(cell);\n+            cell.setMaxWidth(maxWidth);\n+            cell.setMaxHeight(USE_COMPUTED_SIZE);\n+\n+            cell.applyCss();\n+\/\/            cell.layout();\n+\n+            arrangement.addCell(cell);\n+\n+            double h = cell.prefHeight(forWidth) + getLineSpacing(r);\n+            h = snapSizeY(h);\n+            y = snapPositionY(y - h);\n+            count++;\n+\n+            cell.setPosition(y, h);\n+\n+            content.getChildren().remove(cell);\n+\n+            \/\/ stop populating the top part of the sliding window\n+            \/\/ when exceeded both pixel and line count margins\n+            if ((-y > margin) && (count > topMarginCount)) {\n+                break;\n@@ -1419,6 +1417,0 @@\n-        \/\/ TODO this could be more advanced to reduce the amount of re-computation and re-flow\n-        \/\/ TODO clear cache >= start, update layout\n-        cellCache.clear();\n-        \/\/ TODO rebuild from start.lineIndex()\n-        requestLayout();\n-    }\n@@ -1426,6 +1418,1 @@\n-    private Origin computeNewOrigin(ContentChange ch) {\n-        int startIndex = ch.getStart().index();\n-        int endIndex = ch.getEnd().index();\n-        \/\/ TODO store position of the last visible symbol, use that to compare with 'start' to avoid reflow\n-        Origin or = getOrigin();\n-        int lineDelta = endIndex - startIndex + ch.getLinesAdded();\n+        arrangement.setTopHeight(-y);\n@@ -1433,3 +1420,2 @@\n-        \/\/ jump to start if the old origin is within the changed range\n-        if ((startIndex <= or.index()) && (or.index() < (startIndex + lineDelta))) {\n-            return new Origin(startIndex, 0);\n+        if (useContentWidth) {\n+            width = unwrappedWidth + leftSide + rightSide + contentPaddingLeft + contentPaddingRight + padLeft + padRight;\n@@ -1438,12 +1424,3 @@\n-        \/\/ adjust index only if the end precedes the origin\n-        if (lineDelta != 0) {\n-            if (\n-                (endIndex < or.index()) ||\n-                (\n-                    (endIndex == or.index()) &&\n-                    (ch.getEnd().offset() < or.offset())\n-                )\n-            )\n-            {\n-                return new Origin(or.index() + lineDelta, or.offset());\n-            }\n+        viewPortWidth = width - leftSide - rightSide - vsbWidth - padLeft - padRight;\n+        if (viewPortWidth < Params.MIN_VIEWPORT_WIDTH) {\n+            viewPortWidth = Params.MIN_VIEWPORT_WIDTH;\n@@ -1451,0 +1428,1 @@\n+        viewPortHeight = height - hsbHeight - padTop - padBottom;\n@@ -1452,2 +1430,1 @@\n-        return null;\n-    }\n+        \/\/ layout\n@@ -1455,4 +1432,12 @@\n-    @Override\n-    public StyleAttributeMap resolveStyles(StyleAttributeMap attrs) {\n-        if (attrs == null) {\n-            return attrs;\n+        \/\/ scroll bars\n+        boolean vsbVisible = useContentHeight ?\n+            false :\n+            (topCellIndex() > 0) ?\n+                true :\n+                (arrangementHeight + contentPaddingTop + contentPaddingBottom) > viewPortHeight;\n+\n+        if (vsbVisible != vscroll.isVisible()) {\n+            vscroll.setVisible(vsbVisible);\n+            \/\/ do another layout pass with the scrollbar updated\n+            layoutCells();\n+            return;\n@@ -1460,4 +1445,2 @@\n-        CssStyles css = attrs.get(CssStyles.CSS);\n-        if (css == null) {\n-            \/\/ no conversion is needed\n-            return attrs;\n+        if (vsbVisible) {\n+            width -= vsbWidth; \/\/ TODO or use viewportwidth?\n@@ -1466,2 +1449,3 @@\n-        String directStyle = css.style();\n-        String[] names = css.names();\n+        boolean hsbVisible = (wrap || useContentWidth) ?\n+            false :\n+            (unwrappedWidth + contentPaddingLeft + contentPaddingRight) > viewPortWidth;\n@@ -1469,12 +1453,5 @@\n-        getChildren().add(measurer);\n-        try {\n-            measurer.setStyle(directStyle);\n-            if (names == null) {\n-                measurer.getStyleClass().clear();\n-            } else {\n-                measurer.getStyleClass().setAll(names);\n-            }\n-            measurer.applyCss();\n-            return StyleAttributeMap.fromTextNode(measurer);\n-        } finally {\n-            getChildren().remove(measurer);\n+        if (hscroll.isVisible() != hsbVisible) {\n+            hscroll.setVisible(hsbVisible);\n+            \/\/ do another layout pass with the scrollbar updated\n+            layoutCells();\n+            return;\n@@ -1482,1 +1459,0 @@\n-    }\n@@ -1484,14 +1460,5 @@\n-    @Override\n-    public WritableImage snapshot(Node n) {\n-        n.setManaged(false);\n-        getChildren().add(n);\n-        try {\n-            n.applyCss();\n-            if (n instanceof Region r) {\n-                double w = unwrappedContentWidth();\n-                double h = r.prefHeight(w);\n-                layoutInArea(r, 0, -h, w, h, 0, HPos.CENTER, VPos.CENTER);\n-            }\n-            return n.snapshot(null, null);\n-        } finally {\n-            getChildren().remove(n);\n+        double h;\n+        if (useContentHeight) {\n+            h = contentPaddingTop + contentPaddingBottom + arrangementHeight;\n+        } else {\n+            h = height - hsbHeight - padTop - padBottom;\n@@ -1499,1 +1466,0 @@\n-    }\n@@ -1501,6 +1467,2 @@\n-    public void handleUseContentHeight() {\n-        boolean on = control.isUseContentHeight();\n-        if (on) {\n-            setUnwrappedContentWidth(0.0);\n-            setOrigin(new Origin(0, -topPadding));\n-            setOffsetX(-leftPadding);\n+        if (vsbVisible) {\n+            RichUtils.layoutInArea(vscroll, width - padRight, padTop, vsbWidth, h);\n@@ -1508,9 +1470,2 @@\n-        requestControlLayout(false);\n-    }\n-\n-    public void handleUseContentWidth() {\n-        boolean on = control.isUseContentWidth();\n-        if (on) {\n-            setUnwrappedContentWidth(0.0);\n-            setOrigin(new Origin(0, -topPadding));\n-            setOffsetX(-leftPadding);\n+        if (hsbVisible) {\n+            RichUtils.layoutInArea(hscroll, padLeft, h, width - padLeft - padRight, hsbHeight);\n@@ -1518,2 +1473,0 @@\n-        requestControlLayout(false);\n-    }\n@@ -1521,5 +1474,7 @@\n-    @Override\n-    public void requestLayout() {\n-        dirty = true;\n-        super.requestLayout();\n-    }\n+        \/\/ gutters\n+        if (leftDecorator == null) {\n+            leftGutter.setVisible(false);\n+        } else {\n+            leftGutter.setVisible(true);\n+            RichUtils.layoutInArea(leftGutter, padLeft, padTop, leftSide, h);\n+        }\n@@ -1527,7 +1482,5 @@\n-    \/**\n-     * Requests full layout with optional clearing of the cached cells.\n-     * @param clearCache if true, clears the cell cache\n-     *\/\n-    public void requestControlLayout(boolean clearCache) {\n-        if (clearCache) {\n-            cellCache.clear();\n+        if (rightDecorator == null) {\n+            rightGutter.setVisible(false);\n+        } else {\n+            rightGutter.setVisible(true);\n+            RichUtils.layoutInArea(rightGutter, width - rightSide - padRight, padTop, rightSide, h);\n@@ -1535,3 +1488,0 @@\n-        requestParentLayout();\n-        requestLayout();\n-    }\n@@ -1539,9 +1489,3 @@\n-    \/\/ FIX same treatment as with usePrefHeight\n-    private void updatePrefWidth() {\n-        if (!control.prefWidthProperty().isBound()) {\n-            double w = getFlowWidth();\n-            if (w >= 0.0) {\n-                if (vscroll.isVisible()) {\n-                    w += vscroll.getWidth();\n-                }\n-            }\n+        RichUtils.layoutInArea(vport, leftSide + padLeft, padTop, viewPortWidth, h);\n+        \/\/ vport is a child of content\n+        RichUtils.layoutInArea(content, 0.0, 0.0, viewPortWidth, h);\n@@ -1549,1 +1493,6 @@\n-            \/\/D.p(\"w=\", w); \/\/ FIX\n+        if (wrap) {\n+            double w = viewPortWidth;\n+            setUnwrappedContentWidth(w);\n+        } else {\n+            if (unwrappedContentWidth != unwrappedWidth) {\n+                setUnwrappedContentWidth(unwrappedWidth);\n@@ -1551,5 +1500,1 @@\n-            Parent parent = getParent();\n-            if (parent instanceof Region r) {\n-                if (r.getPrefWidth() != w) {\n-                    r.setPrefWidth(w);\n-                    control.getParent().requestLayout();\n+                if (useContentWidth) {\n@@ -1560,1 +1505,0 @@\n-    }\n@@ -1562,4 +1506,2 @@\n-    @Override\n-    protected double computePrefHeight(double width) {\n-        if (control.isUseContentHeight()) {\n-            return getFlowHeight();\n+        if (useContentWidth) {\n+            updatePrefWidth();\n@@ -1567,2 +1509,0 @@\n-        return super.computePrefHeight(width);\n-    }\n@@ -1570,3 +1510,52 @@\n-    public double getFlowHeight() {\n-        return snapSizeY(Math.max(Params.LAYOUT_MIN_HEIGHT, arrangement().bottomHeight()));\n-    }\n+        if (useContentHeight) {\n+            double ph = computePrefHeight(-1);\n+            double prev = getPrefHeight();\n+\n+            \/\/ necessary for vertical stacking\n+            setPrefHeight(ph);\n+            requestParentLayout();\n+\n+            \/\/ avoids infinite layout loop in MultipleStackedBoxWindow but ... why?\n+            if (ph != prev) {\n+                requestLayout();\n+                \/\/ FIX perhaps create a boolean for 'reflow is required' and layoutCells again at the end?\n+                \/\/ weird, need this to make sure the reflow happens when changing models\n+                Platform.runLater(() -> layoutChildren());\n+            }\n+        } else {\n+            if (getPrefHeight() != USE_COMPUTED_SIZE) {\n+                setPrefHeight(USE_COMPUTED_SIZE);\n+            }\n+        }\n+\n+        \/\/ position cells\n+\n+        leftGutter.getChildren().clear();\n+        rightGutter.getChildren().clear();\n+\n+        boolean addLeft = control.getLeftDecorator() != null;\n+        boolean addRight = control.getRightDecorator() != null;\n+\n+        \/\/ FIX weird, it should be contentPaddingLeft always...\n+        double x = wrap ? 0.0 : contentPaddingLeft;\n+\n+        int sz = arrangement.getVisibleCellCount();\n+        for (i = 0; i < sz; i++) {\n+            TextCell cell = arrangement.getCellAt(i);\n+            double ch = cell.getCellHeight();\n+            double cy = cell.getY();\n+            double cw = wrap ? viewPortWidth : cell.getCellWidth();\n+            RichUtils.layoutInArea(cell, x, cy, cw, ch);\n+\n+            \/\/ needed to get the correct caret path afterwards\n+            cell.layout();\n+\n+            \/\/ place side nodes\n+            if (addLeft) {\n+                Node n = arrangement.getLeftNodeAt(i);\n+                if (n != null) {\n+                    leftGutter.getChildren().add(n);\n+                    n.applyCss();\n+                    RichUtils.layoutInArea(n, 0.0, cy, leftGutter.getWidth(), ch);\n+                }\n+            }\n@@ -1574,8 +1563,9 @@\n-    public double getFlowWidth() {\n-        return\n-            arrangement().getUnwrappedWidth() +\n-            snapSizeX(leftSide) +\n-            snapSizeX(rightSide) +\n-            leftPadding +\n-            rightPadding +\n-            snapSizeX(Params.HORIZONTAL_GUARD);\n+            if (addRight) {\n+                Node n = arrangement.getRightNodeAt(i);\n+                if (n != null) {\n+                    rightGutter.getChildren().add(n);\n+                    n.applyCss();\n+                    RichUtils.layoutInArea(n, 0.0, cy, rightGutter.getWidth(), ch);\n+                }\n+            }\n+        }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/VFlow.java","additions":704,"deletions":714,"binary":false,"changes":1418,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n@@ -44,1 +46,1 @@\n-import javafx.scene.AccessibleAttribute;\n+import javafx.geometry.VPos;\n@@ -46,0 +48,1 @@\n+import javafx.scene.Parent;\n@@ -55,1 +58,0 @@\n-import com.sun.javafx.scene.text.GlyphList;\n@@ -59,1 +61,0 @@\n-import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n@@ -61,1 +62,0 @@\n-import jfx.incubator.scene.control.richtext.model.StyleAttributeMap.Builder;\n@@ -611,0 +611,17 @@\n+\n+    \/**\n+     * Convenience method for laying out the node within its parent, filling the available area.\n+     * This method is equivalent to calling\n+     * {@code Region.layoutInArea(n, x, y, w, h, 0.0, Insets.EMPTY, true, true, HPos.CENTER, VPos.CENTER, snap);}\n+     *\n+     * @param n the node to lay out\n+     * @param x the horizontal offset of the layout area\n+     * @param y the vertical offset of the layout area\n+     * @param w the width of the layout area\n+     * @param h the height of the layout area\n+     *\/\n+    public static void layoutInArea(Node n, double x, double y, double w, double h) {\n+        Parent p = n.getParent();\n+        boolean snap = (p instanceof Region r) ? r.isSnapToPixel() : false;\n+        Region.layoutInArea(n, x, y, w, h, 0.0, Insets.EMPTY, true, true, HPos.CENTER, VPos.CENTER, snap);\n+    }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/util\/RichUtils.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -36,2 +36,11 @@\n-     * Creates a {@link RichParagraph} from the paragraph plain text.\n-     * The text string is guaranteed to contain neither newline nor carriage return symbols.\n+     * Creates a {@link RichParagraph} with syntax decoration for the given paragraph index.\n+     * <p>\n+     * For simple cases, when decorations can be generated using the paragraph text,\n+     * it can be obtained by calling {@link CodeTextModel#getPlainText(int)}.\n+     * This string is guaranteed to contain no control symbols except for TAB.\n+     * <p>\n+     * Alternatively, the syntax decorator may cache the syntax information,\n+     * or create {@link Marker}s at critical points in the model, or even perform processing in the background\n+     * (provided the model supports concurrent access), culminating in sending a refresh even in the FX\n+     * application thread by calling\n+     * {@link CodeTextModel#fireChangeEvent(TextPos, TextPos, int, int, int)} method.\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/SyntaxDecorator.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    protected void fireChangeEvent(TextPos start, TextPos end, int charsTop, int linesAdded, int charsBottom) {\n+    public void fireChangeEvent(TextPos start, TextPos end, int charsTop, int linesAdded, int charsBottom) {\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/CodeTextModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -230,0 +231,1 @@\n+         * This convenience method is equivalent to calling {@code addSegment(text, StyleAttributeMap.EMPTY);}\n@@ -231,1 +233,1 @@\n-         * @param text segment text\n+         * @param text the text to append, must not contain {@code \\n}, cannot be null\n@@ -240,0 +242,15 @@\n+        \/**\n+         * Adds a styled text segment.\n+         *\n+         * @param text non-null text string\n+         * @param css array of style names, cannot be null\n+         * @return this {@code Builder} instance\n+         *\/\n+        public Builder withStyles(String text, String ... css) {\n+            Objects.nonNull(text);\n+            Objects.nonNull(css);\n+            StyleAttributeMap a = StyleAttributeMap.fromStyles(null, css);\n+            addSegment(text, a);\n+            return this;\n+        }\n+\n@@ -248,1 +265,2 @@\n-        public Builder addSegment(String text, String style, String[] css) {\n+        public Builder withInlineAndExternalStyles(String text, String style, String ... css) {\n+            Objects.nonNull(text);\n@@ -254,0 +272,14 @@\n+        \/**\n+         * Adds a styled text segment, styled with the inline style.\n+         *\n+         * @param text non-null text string\n+         * @param style the inline style (example {@code \"-fx-fill:red;\"}), or null\n+         * @return this {@code Builder} instance\n+         *\/\n+        public Builder withInlineStyle(String text, String style) {\n+            Objects.nonNull(text);\n+            StyleAttributeMap a = StyleAttributeMap.fromStyles(style);\n+            addSegment(text, a);\n+            return this;\n+        }\n+\n@@ -256,2 +288,3 @@\n-         * @param text the non-null text string\n-         * @param attrs the styled attributes\n+         *\n+         * @param text the text to append, must not contain {@code \\n}, cannot be null\n+         * @param attrs the styled attributes, cannot be null\n@@ -261,0 +294,2 @@\n+            Objects.nonNull(text);\n+            Objects.nonNull(attrs);\n@@ -275,0 +310,1 @@\n+            Objects.nonNull(text);\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/RichParagraph.java","additions":40,"deletions":4,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-     * The {@code text} cannot contain newline (\\n) symbols.\n+     * The {@code text} cannot contain newline ({@code \\n}) symbols.\n+     * This convenience method is equivalent to calling {@code addSegment(text, StyleAttributeMap.EMPTY);}\n@@ -96,1 +97,1 @@\n-     * @param text the text to append, must not contain \\n\n+     * @param text the text to append, must not contain {@code \\n}, cannot be null\n@@ -100,0 +101,1 @@\n+        Objects.requireNonNull(text);\n@@ -105,1 +107,1 @@\n-     * The {@code text} cannot contain newline (\\n) symbols.\n+     * The {@code text} cannot contain newline ({@code \\n}) symbols.\n@@ -107,1 +109,1 @@\n-     * @param text the text to append, must not contain \\n\n+     * @param text the text to append, must not contain {@code \\n}, cannot be null\n@@ -109,1 +111,1 @@\n-     * @param css external style names\n+     * @param css the external style names\n@@ -112,1 +114,3 @@\n-    public SimpleViewOnlyStyledModel addSegment(String text, String style, String... css) {\n+    public SimpleViewOnlyStyledModel withInlineAndExternalStyles(String text, String style, String... css) {\n+        Objects.requireNonNull(text);\n+        StyleAttributeMap a = StyleAttributeMap.fromStyles(style, css);\n@@ -114,1 +118,33 @@\n-        p.addSegment(text, style, css);\n+        p.addSegment(text, a);\n+        return this;\n+    }\n+\n+    \/**\n+     * Appends a text segment styled with external (stylesheet) style names.\n+     * The {@code text} cannot contain newline ({@code \\n}) symbols.\n+     *\n+     * @param text the text to append, must not contain {@code \\n}, cannot be null\n+     * @param css the external style names\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel withStyles(String text, String... css) {\n+        Objects.requireNonNull(text);\n+        StyleAttributeMap a = StyleAttributeMap.fromStyles(null, css);\n+        Paragraph p = lastParagraph();\n+        p.addSegment(text, a);\n+        return this;\n+    }\n+\n+    \/**\n+     * Appends a text segment styled with external (stylesheet) style names.\n+     * The {@code text} cannot contain newline ({@code \\n}) symbols.\n+     *\n+     * @param text the text to append, must not contain {@code \\n}, cannot be null\n+     * @param style the inline style (example {@code \"-fx-fill:red;\"}), or null\n+     * @return this model instance\n+     *\/\n+    public SimpleViewOnlyStyledModel withInlineStyle(String text, String style) {\n+        Objects.requireNonNull(text);\n+        StyleAttributeMap a = StyleAttributeMap.fromInlineStyle(style);\n+        Paragraph p = lastParagraph();\n+        p.addSegment(text, a);\n@@ -334,12 +370,0 @@\n-        \/**\n-         * Adds a styled text segment.\n-         *\n-         * @param text non-null text string\n-         * @param style direct style (such as {@code -fx-fill:red;}), or null\n-         * @param css array of style names, or null\n-         *\/\n-        void addSegment(String text, String style, String[] css) {\n-            StyleAttributeMap a = StyleAttributeMap.fromStyles(style, css);\n-            addSegment(text, a);\n-        }\n-\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/SimpleViewOnlyStyledModel.java","additions":43,"deletions":19,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.Objects;\n+\n@@ -30,0 +32,1 @@\n+ *\n@@ -31,0 +34,1 @@\n+ * @see StyleAttributeMap\n@@ -40,1 +44,1 @@\n-     * @param name the attribute name\n+     * @param name the attribute name (cannot be null)\n@@ -45,0 +49,1 @@\n+        Objects.requireNonNull(name, \"name cannot be null\");\n@@ -81,0 +86,2 @@\n+\n+    \/\/ TODO maybe it should override equals() and hashCode()\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/StyleAttribute.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+    private static final String[] EMPTY_ARRAY = new String[0];\n+\n@@ -131,1 +133,1 @@\n-            names = new String[0];\n+            names = EMPTY_ARRAY;\n@@ -136,0 +138,13 @@\n+    \/**\n+     * This convenience method creates an instance from an inline style.\n+     *\n+     * @param style the inline style, can be null\n+     * @return the new instance\n+     *\/\n+    public static StyleAttributeMap fromInlineStyle(String style) {\n+        if (style == null) {\n+            return StyleAttributeMap.EMPTY;\n+        }\n+        return new Builder().set(CssStyles.CSS, new CssStyles(style, null)).build();\n+    }\n+\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/StyleAttributeMap.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-    protected void fireChangeEvent(TextPos start, TextPos end, int charsTop, int linesAdded, int charsBottom) {\n+    public void fireChangeEvent(TextPos start, TextPos end, int charsTop, int linesAdded, int charsBottom) {\n@@ -408,1 +408,1 @@\n-    protected void fireStyleChangeEvent(TextPos start, TextPos end) {\n+    public void fireStyleChangeEvent(TextPos start, TextPos end) {\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/model\/StyledTextModel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import javafx.geometry.HPos;\n-import javafx.geometry.Insets;\n@@ -35,1 +33,0 @@\n-import javafx.geometry.VPos;\n@@ -45,1 +42,0 @@\n-import javafx.scene.layout.Pane;\n@@ -76,1 +72,0 @@\n-    private final Pane mainPane;\n@@ -111,3 +106,0 @@\n-        vscroll.setMin(0.0);\n-        vscroll.setMax(1.0);\n-        vscroll.setUnitIncrement(Params.SCROLL_BARS_UNIT_INCREMENT);\n@@ -118,3 +110,0 @@\n-        hscroll.setMin(0.0);\n-        hscroll.setMax(1.0);\n-        hscroll.setUnitIncrement(Params.SCROLL_BARS_UNIT_INCREMENT);\n@@ -124,60 +113,1 @@\n-\n-        mainPane = new Pane(vflow, vscroll, hscroll) {\n-            @Override\n-            protected double computePrefHeight(double width) {\n-                if (control.isUseContentHeight()) {\n-                    double h = vflow.prefHeight(width);\n-                    if (hscroll.isVisible()) {\n-                        h += hscroll.prefHeight(width);\n-                    }\n-                    Insets m = getInsets();\n-                    return h + m.getTop() + m.getBottom();\n-                }\n-                return super.computePrefHeight(width);\n-            }\n-\n-            @Override\n-            protected double computePrefWidth(double height) {\n-                if (control.isUseContentWidth()) {\n-                    double w = vflow.prefWidth(height); \/\/ or use unwrapped width + left + right?\n-                    if (vscroll.isVisible()) {\n-                        w += vscroll.prefWidth(height);\n-                    }\n-                    w += (Params.LAYOUT_FOCUS_BORDER * 2);\n-                    Insets m = getInsets();\n-                    return w + m.getLeft() + m.getRight();\n-                }\n-                return super.computePrefWidth(height);\n-            }\n-\n-            @Override\n-            protected void layoutChildren() {\n-                double x0 = snappedLeftInset() + snapSizeX(Params.LAYOUT_FOCUS_BORDER);\n-                double y0 = snappedTopInset() + snapSizeY(Params.LAYOUT_FOCUS_BORDER);\n-                double width = getWidth();\n-                double height = getHeight();\n-\n-                double vsbWidth = vscroll.isVisible() ? vscroll.prefWidth(height) : 0.0;\n-                double hsbHeight = hscroll.isVisible() ? snapSizeY(hscroll.prefHeight(width)) : 0.0;\n-\n-                double w;\n-                if (control.isUseContentWidth()) {\n-                    w = vflow.getFlowWidth();\n-                } else {\n-                    w = snapSizeX(width - x0 - snappedRightInset() - snapSizeX(vsbWidth) - snapSizeX(Params.LAYOUT_FOCUS_BORDER));\n-                }\n-\n-                double h;\n-                if (control.isUseContentHeight()) {\n-                    h = vflow.prefHeight(width);\n-                } else {\n-                    h = height - y0 - snappedBottomInset() - snapSizeY(Params.LAYOUT_FOCUS_BORDER) - hsbHeight;\n-                }\n-\n-                layoutInArea(vscroll, w, y0, vsbWidth, h + hsbHeight, -1, null, true, true, HPos.RIGHT, VPos.TOP);\n-                layoutInArea(hscroll, x0, y0 + h, w, hsbHeight, -1, null, true, true, HPos.LEFT, VPos.BOTTOM);\n-                layoutInArea(vflow, x0, y0, w, h, -1, null, true, true, HPos.LEFT, VPos.TOP);\n-            }\n-        };\n-        mainPane.getStyleClass().add(\"main-pane\");\n-        getChildren().add(mainPane);\n+        getChildren().add(vflow);\n@@ -254,1 +184,1 @@\n-            getChildren().remove(mainPane);\n+            getChildren().remove(vflow);\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/skin\/RichTextAreaSkin.java","additions":2,"deletions":72,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        addSegment(\"RichTextArea Control\", \"-fx-font-size:200%;\", UNDERLINE);\n+        withInlineAndExternalStyles(\"RichTextArea Control\", \"-fx-font-size:200%;\", UNDERLINE);\n@@ -69,1 +69,1 @@\n-        addSegment(\"\/**\", null, RED, CODE);\n+        withStyles(\"\/**\", RED, CODE);\n@@ -71,1 +71,1 @@\n-        addSegment(\" * Syntax Highlight Demo.\", null, RED, CODE);\n+        withStyles(\" * Syntax Highlight Demo.\", RED, CODE);\n@@ -73,1 +73,1 @@\n-        addSegment(\" *\/\", null, RED, CODE);\n+        withStyles(\" *\/\", RED, CODE);\n@@ -75,4 +75,4 @@\n-        addSegment(\"public class \", null, GREEN, CODE);\n-        addSegment(\"SyntaxHighlightDemo \", null, CODE);\n-        addSegment(\"extends \", null, GREEN, CODE);\n-        addSegment(\"Application {\", null, CODE);\n+        withStyles(\"public class \", GREEN, CODE);\n+        withStyles(\"SyntaxHighlightDemo \", CODE);\n+        withStyles(\"extends \", GREEN, CODE);\n+        withStyles(\"Application {\", CODE);\n@@ -80,2 +80,2 @@\n-        addSegment(\"\\tpublic static void\", null, GREEN, CODE);\n-        addSegment(\" main(String[] args) {\", null, CODE);\n+        withStyles(\"\\tpublic static void\", GREEN, CODE);\n+        withStyles(\" main(String[] args) {\", CODE);\n@@ -83,3 +83,3 @@\n-        addSegment(\"\\t\\tApplication.launch(SyntaxHighlightDemo.\", null, CODE);\n-        addSegment(\"class\", null, CODE, GREEN);\n-        addSegment(\", args);\", null, CODE);\n+        withStyles(\"\\t\\tApplication.launch(SyntaxHighlightDemo.\", CODE);\n+        withStyles(\"class\", CODE, GREEN);\n+        withStyles(\", args);\", CODE);\n@@ -87,1 +87,1 @@\n-        addSegment(\"\\t}\", null, CODE);\n+        withStyles(\"\\t}\", CODE);\n@@ -89,1 +89,1 @@\n-        addSegment(\"}\", null, CODE);\n+        withStyles(\"}\", CODE);\n@@ -92,5 +92,5 @@\n-        addSegment(\"BOLD \", null, BOLD);\n-        addSegment(\"ITALIC \", null, ITALIC);\n-        addSegment(\"STRIKETHROUGH \", null, STRIKETHROUGH);\n-        addSegment(\"UNDERLINE \", null, UNDERLINE);\n-        addSegment(\"ALL OF THEM \", null, BOLD, ITALIC, STRIKETHROUGH, UNDERLINE);\n+        withStyles(\"BOLD \", BOLD);\n+        withStyles(\"ITALIC \", ITALIC);\n+        withStyles(\"STRIKETHROUGH \", STRIKETHROUGH);\n+        withStyles(\"UNDERLINE \", UNDERLINE);\n+        withStyles(\"ALL OF THEM \", BOLD, ITALIC, STRIKETHROUGH, UNDERLINE);\n@@ -110,2 +110,2 @@\n-        addSegment(\"A regular Arabic verb, كَتَبَ‎ kataba (to write).\", null, ARABIC).nl();\n-        addSegment(\"Emojis: [🔥🦋😀😃😄😁😆😅🤣😂🙂🙃😉😊😇]\", null, LARGE).nl();\n+        withStyles(\"A regular Arabic verb, كَتَبَ‎ kataba (to write).\", ARABIC).nl();\n+        withStyles(\"Emojis: [🔥🦋😀😃😄😁😆😅🤣😂🙂🙃😉😊😇]\", LARGE).nl();\n@@ -113,4 +113,4 @@\n-        addSegment(\"Halfwidth and FullWidth Forms\", null, UNDERLINE).nl();\n-        addSegment(\"ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯ\", \"-fx-font-family:monospaced;\").nl();\n-        addSegment(\"ABCDEFGHIJKLMNO\", \"-fx-font-family:monospaced;\").nl();\n-        addSegment(\"        leading and trailing whitespace         \", null, CODE).nl();\n+        withStyles(\"Halfwidth and FullWidth Forms\", UNDERLINE).nl();\n+        withInlineStyle(\"ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯ\", \"-fx-font-family:monospaced;\").nl();\n+        withInlineStyle(\"ABCDEFGHIJKLMNO\", \"-fx-font-family:monospaced;\").nl();\n+        withStyles(\"        leading and trailing whitespace         \", CODE).nl();\n@@ -118,1 +118,1 @@\n-        addSegment(\"Behold various types of highlights, including overlapping highlights.\", null, LARGE);\n+        withStyles(\"Behold various types of highlights, including overlapping highlights.\", LARGE);\n@@ -145,1 +145,1 @@\n-        addSegment(\"  Fig. 1 Embedded animated GIF image.\", null, GRAY, ITALIC);\n+        withStyles(\"  Fig. 1 Embedded animated GIF image.\", GRAY, ITALIC);\n@@ -173,1 +173,1 @@\n-        addSegment(\"\\t\\t終 The End.\", \"-fx-font-size:200%;\");\n+        withInlineStyle(\"\\t\\t終 The End.\", \"-fx-font-size:200%;\");\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/DemoModel.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        String[] css = monospaced ? new String[] { \"monospaced\" } : null;\n+        String[] css = monospaced ? new String[] { \"monospaced\" } : new String[0];\n@@ -84,3 +84,3 @@\n-        b.addSegment(s, \"-fx-fill:darkgreen;\", css);\n-        b.addSegment(\" \/ \", null, css);\n-        b.addSegment(sz, \"-fx-fill:black;\", css);\n+        b.withInlineAndExternalStyles(s, \"-fx-fill:darkgreen;\", css);\n+        b.withStyles(\" \/ \", css);\n+        b.withInlineAndExternalStyles(sz, \"-fx-fill:black;\", css);\n@@ -88,1 +88,1 @@\n-            b.addSegment(\" (monospaced)\", null, css);\n+            b.withStyles(\" (monospaced)\", css);\n@@ -93,1 +93,1 @@\n-            b.addSegment(words, null, css);\n+            b.withStyles(words, css);\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/DemoStyledTextModel.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        addSegment(\"Inline Nodes\", null, UNDER, LARGE);\n+        withStyles(\"Inline Nodes\", UNDER, LARGE);\n@@ -56,1 +56,1 @@\n-        addSegment(\" \", null, LARGE);\n+        withStyles(\" \", LARGE);\n@@ -58,1 +58,1 @@\n-        addSegment(\" trailing segment.\", null, LARGE); \/\/ FIX cannot navigate over this segment\n+        withStyles(\" trailing segment.\", LARGE); \/\/ FIX cannot navigate over this segment\n@@ -62,1 +62,1 @@\n-        addSegment(\"Leading text\", null, LARGE);\n+        withStyles(\"Leading text\", LARGE);\n@@ -69,1 +69,1 @@\n-        addSegment(\"- in between text-\", null, LARGE);\n+        withStyles(\"- in between text-\", LARGE);\n@@ -74,1 +74,1 @@\n-        addSegment(\"Leading text\", null, LARGE);\n+        withStyles(\"Leading text\", LARGE);\n@@ -81,1 +81,1 @@\n-        addSegment(\"- in between text-\", null, LARGE);\n+        withStyles(\"- in between text-\", LARGE);\n@@ -83,1 +83,1 @@\n-        addSegment(\" trailing segment.\", null, LARGE);\n+        withStyles(\" trailing segment.\", LARGE);\n@@ -93,1 +93,1 @@\n-        addSegment(\"\", null, LARGE);\n+        withStyles(\"\", LARGE);\n@@ -96,1 +96,1 @@\n-        addSegment(\"A regular text segment for reference.\", null, LARGE);\n+        withStyles(\"A regular text segment for reference.\", LARGE);\n@@ -98,1 +98,1 @@\n-        addSegment(\"The End █\", null, LARGE);\n+        withStyles(\"The End █\", LARGE);\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/InlineNodesModel.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        addSegment(sb.toString(), STYLE);\n+        withStyles(sb.toString(), STYLE);\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/LargeTextModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-    NOTEBOOK_STACK(\"Notebook: Embedded Rich Text Areas\"),\n@@ -110,1 +109,1 @@\n-                                    b.addSegment(s, style, null);\n+                                    b.withInlineStyle(s, style);\n@@ -119,1 +118,1 @@\n-                            b.addSegment(s, style, null);\n+                            b.withInlineStyle(s, style);\n@@ -144,2 +143,0 @@\n-        case NOTEBOOK_STACK:\n-            return new NotebookModelStacked();\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/ModelChoice.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import javafx.scene.control.Label;\n@@ -48,0 +49,1 @@\n+        a1.setHighlightCurrentParagraph(true);\n@@ -53,0 +55,1 @@\n+        t1.setPrefHeight(50);\n@@ -54,2 +57,1 @@\n-        TextArea t2 = new TextArea(\"This TextArea has wrap text property set to true.\");\n-        t2.setWrapText(true);\n+        Label t2 = new Label(\"Label\");\n@@ -58,0 +60,1 @@\n+        a2.setHighlightCurrentParagraph(true);\n@@ -161,0 +164,5 @@\n+            FX.checkItem(m, \"2\", new Insets(1).equals(t.getContentPadding()), (on) -> {\n+                if (on) {\n+                    t.setContentPadding(new Insets(2));\n+                }\n+            });\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/MultipleStackedBoxWindow.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        addSegment(\"Bifurcation Diagram\", \"-fx-font-size:200%;\", UNDER);\n+        withInlineAndExternalStyles(\"Bifurcation Diagram\", \"-fx-font-size:200%;\", UNDER);\n@@ -44,3 +44,3 @@\n-        addSegment(\"In mathematics, particularly in dynamical systems, a \", null, GRAY);\n-        addSegment(\"bifurcation diagram \", \"-fx-font-weight:bold;\"); \/\/ FIX does not work on mac\n-        addSegment(\"shows the values visited or approached asymptotically (fixed points, periodic orbits, or chaotic attractors) of a system as a function of a bifurcation parameter in the system. It is usual to represent stable values with a solid line and unstable values with a dotted line, although often the unstable points are omitted. Bifurcation diagrams enable the visualization of bifurcation theory.\", null, GRAY);\n+        withStyles(\"In mathematics, particularly in dynamical systems, a \", GRAY);\n+        withStyles(\"bifurcation diagram \", \"-fx-font-weight:bold;\"); \/\/ FIX does not work on mac\n+        withStyles(\"shows the values visited or approached asymptotically (fixed points, periodic orbits, or chaotic attractors) of a system as a function of a bifurcation parameter in the system. It is usual to represent stable values with a solid line and unstable values with a dotted line, although often the unstable points are omitted. Bifurcation diagrams enable the visualization of bifurcation theory.\", GRAY);\n@@ -48,1 +48,1 @@\n-        addSegment(\"An example is the bifurcation diagram of the logistic map:\", null, GRAY);\n+        withStyles(\"An example is the bifurcation diagram of the logistic map:\", GRAY);\n@@ -50,7 +50,7 @@\n-        addSegment(\"   x\", EQ);\n-        addSegment(\"n+1\", null, EQ, SUB);\n-        addSegment(\" = λx\", EQ);\n-        addSegment(\"n\", EQ, SUB);\n-        addSegment(\"(1 - x\", EQ);\n-        addSegment(\"n\", EQ, SUB);\n-        addSegment(\")\", null, EQ);\n+        withStyles(\"   x\", EQ);\n+        withStyles(\"n+1\", EQ, SUB);\n+        withStyles(\" = λx\", EQ);\n+        withStyles(\"n\", EQ, SUB);\n+        withStyles(\"(1 - x\", EQ);\n+        withStyles(\"n\", EQ, SUB);\n+        withStyles(\")\", EQ);\n@@ -59,1 +59,1 @@\n-        addSegment(\"The bifurcation parameter λ is shown on the horizontal axis of the plot and the vertical axis shows the set of values of the logistic function visited asymptotically from almost all initial conditions.\", null, GRAY);\n+        withStyles(\"The bifurcation parameter λ is shown on the horizontal axis of the plot and the vertical axis shows the set of values of the logistic function visited asymptotically from almost all initial conditions.\", GRAY);\n@@ -61,1 +61,1 @@\n-        addSegment(\"The bifurcation diagram shows the forking of the periods of stable orbits from 1 to 2 to 4 to 8 etc. Each of these bifurcation points is a period-doubling bifurcation. The ratio of the lengths of successive intervals between values of r for which bifurcation occurs converges to the first Feigenbaum constant.\", null, GRAY);\n+        withStyles(\"The bifurcation diagram shows the forking of the periods of stable orbits from 1 to 2 to 4 to 8 etc. Each of these bifurcation points is a period-doubling bifurcation. The ratio of the lengths of successive intervals between values of r for which bifurcation occurs converges to the first Feigenbaum constant.\", GRAY);\n@@ -63,1 +63,1 @@\n-        addSegment(\"The diagram also shows period doublings from 3 to 6 to 12 etc., from 5 to 10 to 20 etc., and so forth.\", null, GRAY);\n+        withStyles(\"The diagram also shows period doublings from 3 to 6 to 12 etc., from 5 to 10 to 20 etc., and so forth.\", GRAY);\n@@ -69,1 +69,1 @@\n-        addSegment(\"https:\/\/en.wikipedia.org\/wiki\/Bifurcation_diagram\", null, GREEN, UNDER);\n+        withStyles(\"https:\/\/en.wikipedia.org\/wiki\/Bifurcation_diagram\", GREEN, UNDER);\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/NotebookModel.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        addSegment(\"SQL Select\", \"-fx-font-size:200%;\", UNDER);\n+        withInlineAndExternalStyles(\"SQL Select\", \"-fx-font-size:200%;\", UNDER);\n@@ -54,3 +54,3 @@\n-        addSegment(\"The SQL \", null, GRAY);\n-        addSegment(\"SELECT \", \"-fx-font-weight:bold;\"); \/\/ FIX does not work on mac\n-        addSegment(\"statement returns a result set of records, from one or more tables.\", null, GRAY);\n+        withStyles(\"The SQL \", GRAY);\n+        withInlineStyle(\"SELECT \", \"-fx-font-weight:bold;\"); \/\/ FIX does not work on mac\n+        withStyles(\"statement returns a result set of records, from one or more tables.\", GRAY);\n@@ -58,1 +58,1 @@\n-        addSegment(\"A SELECT statement retrieves zero or more rows from one or more database tables or database views. In most applications, SELECT is the most commonly used data manipulation language (DML) command. As SQL is a declarative programming language, SELECT queries specify a result set, but do not specify how to calculate it. The database translates the query into a \\\"query plan\\\" which may vary between executions, database versions and database software. This functionality is called the \\\"query optimizer\\\" as it is responsible for finding the best possible execution plan for the query, within applicable constraints.\", null, GRAY);\n+        withStyles(\"A SELECT statement retrieves zero or more rows from one or more database tables or database views. In most applications, SELECT is the most commonly used data manipulation language (DML) command. As SQL is a declarative programming language, SELECT queries specify a result set, but do not specify how to calculate it. The database translates the query into a \\\"query plan\\\" which may vary between executions, database versions and database software. This functionality is called the \\\"query optimizer\\\" as it is responsible for finding the best possible execution plan for the query, within applicable constraints.\", GRAY);\n@@ -60,1 +60,1 @@\n-        addSegment(QUERY, \"-fx-font-weight:bold;\"); \/\/ FIX does not work on mac\n+        withInlineStyle(QUERY, \"-fx-font-weight:bold;\"); \/\/ FIX does not work on mac\n@@ -68,1 +68,1 @@\n-        addSegment(\" \", null, GRAY);\n+        withStyles(\" \", GRAY);\n@@ -75,1 +75,1 @@\n-        addSegment(\"Result:\", null, GRAY);\n+        withStyles(\"Result:\", GRAY);\n@@ -81,1 +81,1 @@\n-        addSegment(\"https:\/\/en.wikipedia.org\/wiki\/Select_(SQL)\", null, GREEN, UNDER);\n+        withStyles(\"https:\/\/en.wikipedia.org\/wiki\/Select_(SQL)\", GREEN, UNDER);\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/NotebookModel2.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        return create(Type.COMMENT, \"This is\\na comment cell.\");\n+        return create(Type.COMMENT, \"██This is\\na comment cell.██p\");\n@@ -72,1 +72,1 @@\n-                    b.addSegment(text, \"-fx-text-fill:darkgreen; -fx-font-family:Monospace;\", null);\n+                    b.withInlineStyle(text, \"-fx-text-fill:darkgreen; -fx-font-family:Monospace;\");\n@@ -83,1 +83,1 @@\n-                    b.addSegment(text, \"-fx-text-fill:gray;\", null);\n+                    b.withInlineStyle(text, \"-fx-text-fill:gray;\");\n@@ -117,0 +117,1 @@\n+                t.setHighlightCurrentParagraph(true);\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/NotebookModelStacked.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -200,35 +200,1 @@\n-        ComboBox<Insets> contentPadding = new ComboBox<>();\n-        FX.name(contentPadding, \"contentPadding\");\n-        contentPadding.setConverter(new StringConverter<Insets>() {\n-            @Override\n-            public String toString(Insets x) {\n-                if (x == null) {\n-                    return \"null\";\n-                }\n-                return String.format(\n-                    \"T%d, B%d, L%d, R%d\",\n-                    (int)x.getTop(),\n-                    (int)x.getBottom(),\n-                    (int)x.getLeft(),\n-                    (int)x.getRight()\n-                );\n-            }\n-\n-            @Override\n-            public Insets fromString(String s) {\n-                return null;\n-            }\n-        });\n-        contentPadding.getItems().setAll(\n-            null,\n-            new Insets(1),\n-            new Insets(2),\n-            new Insets(10),\n-            new Insets(22.22),\n-            new Insets(50),\n-            new Insets(100),\n-            new Insets(5, 10, 15, 20)\n-        );\n-        contentPadding.getSelectionModel().selectedItemProperty().addListener((s,p,v) -> {\n-            control.setContentPadding(v);\n-        });\n+        ComboBox<Insets> contentPadding = contentPaddingOption();\n@@ -310,1 +276,0 @@\n-        contentPadding.getSelectionModel().selectFirst();\n@@ -726,0 +691,62 @@\n+\n+    private ComboBox<Insets> contentPaddingOption() {\n+        ComboBox<Insets> op = new ComboBox<>();\n+        FX.name(op, \"contentPadding\");\n+        op.setConverter(new StringConverter<Insets>() {\n+            @Override\n+            public String toString(Insets x) {\n+                if (x == null) {\n+                    return \"null\";\n+                }\n+                return String.format(\n+                    \"T%d, B%d, L%d, R%d\",\n+                    (int)x.getTop(),\n+                    (int)x.getBottom(),\n+                    (int)x.getLeft(),\n+                    (int)x.getRight()\n+                );\n+            }\n+    \n+            @Override\n+            public Insets fromString(String s) {\n+                return null;\n+            }\n+        });\n+        op.getItems().setAll(\n+            null,\n+            new Insets(1),\n+            new Insets(2),\n+            new Insets(10),\n+            new Insets(22.22),\n+            new Insets(50),\n+            new Insets(100),\n+            new Insets(5, 10, 15, 20)\n+        );\n+\n+        selectValue(op, control.getContentPadding());\n+        control.contentPaddingProperty().addListener((s,p,v) -> {\n+            selectValue(op, v);\n+        });\n+\n+        op.getSelectionModel().selectedItemProperty().addListener((s,p,v) -> {\n+            control.setContentPadding(v);\n+        });\n+\n+        return op;\n+    }\n+\n+    private <T> void selectValue(ComboBox<T> c, T value) {\n+        int ix = -1;\n+        for (int i = c.getItems().size() - 1; i >= 0; i--) {\n+            T v = c.getItems().get(i);\n+            if (Objects.equals(v, value)) {\n+                ix = i;\n+                break;\n+            }\n+        }\n+        if (ix < 0) {\n+            ix = c.getItems().size();\n+            c.getItems().add(value);\n+        }\n+        c.getSelectionModel().select(ix);\n+    }\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/RichTextAreaDemoPane.java","additions":63,"deletions":36,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -69,2 +69,5 @@\n-        \/\/ tests\n-        FX.menu(mb, \"_Tests\");\n+        \/\/ tools\n+        FX.menu(mb, \"T_ools\");\n+        FX.item(mb, \"CSS Tool\", this::openCssTool);\n+        \/\/ window\n+        FX.menu(mb, \"_Window\");\n@@ -74,2 +77,1 @@\n-        \/\/ window\n-        FX.menu(mb, \"_Window\");\n+        FX.separator(mb);\n@@ -77,3 +79,0 @@\n-        \/\/ tools\n-        FX.menu(mb, \"T_ools\");\n-        FX.item(mb, \"CSS Tool\", this::openCssTool);\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/RichTextAreaWindow.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -47,4 +47,4 @@\n-        \/\/ add text segment using CSS style name (requires a style sheet)\n-        m.addSegment(\"RichTextArea \", null, \"HEADER\");\n-        \/\/ add text segment using direct style\n-        m.addSegment(\"Demo\", \"-fx-font-size:200%;\");\n+        \/\/ add text segment using CSS style name (requires a stylesheet)\n+        m.withStyles(\"RichTextArea \", \"HEADER\");\n+        \/\/ add text segment using inline style\n+        m.withInlineStyle(\"Demo\", \"-fx-font-size:200%;\");\n","filename":"tests\/manual\/RichTextAreaDemo\/src\/com\/oracle\/demo\/richtext\/rta\/UsageExamples.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}