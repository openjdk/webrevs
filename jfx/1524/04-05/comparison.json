{"files":[{"patch":"@@ -28,0 +28,2 @@\n+|MOVE_TO_LINE_END          |Moves the caret to the end of the visual text line at caret\n+|MOVE_TO_LINE_START        |Moves the caret to the beginning of the visual text line at caret\n@@ -54,0 +56,2 @@\n+|SELECT_TO_LINE_END        |Extends selection to the end of the visual text line at caret\n+|SELECT_TO_LINE_START      |Extends selection to the start of the visual text line at caret\n@@ -91,4 +95,4 @@\n-|END                   |           |MOVE_TO_PARAGRAPH_END     |4\n-|ctrl-END              |linux, win |MOVE_TO_DOCUMENT_END      |\n-|ctrl-shift-END        |linux, win |SELECT_TO_DOCUMENT_END    |\n-|shift-END             |linux, win |SELECT_PARAGRAPH_END      |\n+|END                   |           |MOVE_TO_LINE_END          |4\n+|ctrl-END              |           |MOVE_TO_DOCUMENT_END      |\n+|ctrl-shift-END        |           |SELECT_TO_DOCUMENT_END    |\n+|shift-END             |           |SELECT_LINE_END           |\n@@ -97,4 +101,4 @@\n-|HOME                  |           |MOVE_TO_PARAGRAPH_START   |3\n-|ctrl-HOME             |linux, win |MOVE_TO_DOCUMENT_START    |\n-|ctrl-shift-HOME       |linux, win |SELECT_TO_DOCUMENT_START  |\n-|shift-HOME            |linux, win |SELECT_PARAGRAPH_START    |\n+|HOME                  |           |MOVE_TO_LINE_START        |3\n+|ctrl-HOME             |           |MOVE_TO_DOCUMENT_START    |\n+|ctrl-shift-HOME       |           |SELECT_TO_DOCUMENT_START  |\n+|shift-HOME            |           |SELECT_TO_LINE_START      |3\n@@ -107,2 +111,2 @@\n-|shift-shortcut-LEFT   |mac        |SELECT_PARAGRAPH_START    |\n-|shortcut-LEFT         |mac        |MOVE_TO_PARAGRAPH_START   |\n+|shift-shortcut-LEFT   |mac        |SELECT_TO_LINE_START      |3\n+|shortcut-LEFT         |mac        |MOVE_TO_LINE_START        |3\n@@ -120,2 +124,2 @@\n-|shift-shortcut-RIGHT  |mac        |SELECT_PARAGRAPH_END      |\n-|shortcut-RIGHT        |mac        |MOVE_TO_PARAGRAPH_END     |\n+|shift-shortcut-RIGHT  |mac        |SELECT_LINE_END           |\n+|shortcut-RIGHT        |mac        |MOVE_TO_LINE_END          |\n@@ -159,6 +163,6 @@\n-3. On macOS, Home = `command` left arrow key\n-4. On macOS, End = `command` right arrow key\n-5. On macOS, PgUp = `fn` + `up arrow` key\n-6. On macOS, PgDn = `fn` + `down arrow` key\n-7. On macOS, BACKSPACE = `delete` key\n-8. On macOS, DELETE = `fn` + `delete` key\n+3. On macOS, Home is represented by the `command` + left arrow keys\n+4. On macOS, End is represented by the `command` + right arrow keys\n+5. On macOS, PgUp is represented by the `fn` + `up arrow` keys\n+6. On macOS, PgDn is represented by the `fn` + `down arrow` keys\n+7. On macOS, BACKSPACE is represented by the `delete` key\n+8. On macOS, DELETE is represented by the `fn` + `delete` keys\n","filename":"doc-files\/behavior\/RichTextAreaBehavior.md","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-    private final double contentPaddingLeft; \/\/ snapped\n@@ -56,0 +55,1 @@\n+    private final double contentPaddingBottom; \/\/ snapped\n@@ -65,1 +65,1 @@\n-    public CellArrangement(VFlow f, double contentPaddingLeft, double contentPaddingTop) {\n+    public CellArrangement(VFlow f, double contentPaddingTop, double contentPaddingBottom) {\n@@ -70,1 +70,0 @@\n-        this.contentPaddingLeft = contentPaddingLeft;\n@@ -72,0 +71,1 @@\n+        this.contentPaddingBottom = contentPaddingBottom;\n@@ -75,0 +75,1 @@\n+    \/\/ (may need to include left and right content padding or a sum thereof *\/\n@@ -80,2 +81,2 @@\n-            (contentPaddingLeft == padLeft) &&\n-            (contentPaddingTop == padTop);\n+            (contentPaddingTop == padTop) &&\n+            (contentPaddingBottom == contentPaddingBottom);\n@@ -90,1 +91,0 @@\n-            \", visible=\" + getVisibleCellCount() +\n@@ -92,0 +92,1 @@\n+            \", visible=\" + getVisibleCellCount() +\n@@ -96,1 +97,0 @@\n-            \", estMax=\" + estimatedMax() +\n@@ -229,0 +229,1 @@\n+    \/** visible + bottom margin cells *\/\n@@ -233,0 +234,4 @@\n+    public int cellCount() {\n+        return cells.size();\n+    }\n+\n@@ -237,0 +242,1 @@\n+    \/** in pixels from the first visible cell to the last cell in the arrangement *\/\n@@ -254,1 +260,5 @@\n-        return (topHeight + bottomHeight) \/ (topCount() + bottomCount);\n+        int sz = cells.size();\n+        if (sz == 0) {\n+            return 20;\n+        }\n+        return (topHeight + bottomHeight) \/ sz;\n@@ -267,1 +277,0 @@\n-        \/\/System.err.println(\"    binarySearch off=\" + off + \", high=\" + high + \", low=\" + low); \/\/ FIX\n@@ -269,1 +278,0 @@\n-            \/\/ TODO might be a problem for 2B-rows models\n@@ -307,20 +315,2 @@\n-    \/** creates a new Origin from the absolute position [0.0 ... (1.0-normalized.visible.amount)] *\/\n-    public Origin fromAbsolutePosition(double pos) {\n-        int topIx = topIndex();\n-        int btmIx = bottomIndex();\n-        int ix = (int)(pos * lineCount);\n-        if ((ix >= topIx) && (ix < btmIx)) {\n-            \/\/ inside the layout\n-            double top = topIx \/ (double)lineCount;\n-            double btm = btmIx \/ (double)lineCount;\n-            double f = (pos - top) \/ (btm - top); \/\/ TODO check for dvi0\/infinity\/NaN\n-            double localY = f * (topHeight + bottomHeight) - topHeight;\n-\n-            ix = binarySearch(localY, topIx, btmIx - 1);\n-            TextCell cell = getCell(ix);\n-            return new Origin(cell.getIndex(), localY - cell.getY());\n-        }\n-        return new Origin(ix, 0.0);\n-    }\n-\n-    public Origin computeOrigin(double delta) {\n+    \/** returns the new origin after scrolling for delta pixels within the arrangement *\/\n+    public Origin moveOrigin(double delta) {\n@@ -331,12 +321,2 @@\n-        if (delta < 0) {\n-            \/\/ do not scroll above the top edge\n-            double top = -origin.offset() - topHeight;\n-            if (y < top) {\n-                if (topIx == 0) {\n-                    y = Math.max(y, -contentPaddingTop);\n-                    return new Origin(0, y);\n-                }\n-                return new Origin(topIx, 0.0);\n-            }\n-        } else {\n-            \/\/ do not scroll past (bottom edge - visible area)\n+        if (delta > 0) {\n+            \/\/ do not scroll beyond the bottom edge\n@@ -355,0 +335,8 @@\n+\n+        \/\/ do not scroll beyond the top edge\n+        if (delta < 0) {\n+            if (ix == 0) {\n+                off = Math.max(off, -contentPaddingTop);\n+            }\n+        }\n+\n@@ -379,0 +367,8 @@\n+\n+    \/** last cell at the bottom of the arrangement *\/\n+    private TextCell lastBottomCell() {\n+        if (bottomCount == 0) {\n+            return null;\n+        }\n+        return cells.get(bottomCount - 1);\n+    }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/CellArrangement.java","additions":38,"deletions":42,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -119,5 +119,2 @@\n-    \/**\n-     * VFlow TextLayout sliding window extent before and after the visible area.\n-     * Must be > 1.0f for the relative navigation to work.\n-     *\/\n-    public static final float SLIDING_WINDOW_EXTENT = 3.0f;\n+    \/** The number of paragraphs to lay out before and after the view point in VFlow. *\/\n+    public static final int SLIDING_WINDOW_EXTENT = 100;\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/Params.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -118,0 +118,2 @@\n+        registerFunction(RichTextArea.Tags.MOVE_TO_LINE_END, this::moveLineEnd);\n+        registerFunction(RichTextArea.Tags.MOVE_TO_LINE_START, this::moveLineStart);\n@@ -144,0 +146,2 @@\n+        registerFunction(RichTextArea.Tags.SELECT_TO_LINE_END, this::selectLineEnd);\n+        registerFunction(RichTextArea.Tags.SELECT_TO_LINE_START, this::selectLineStart);\n@@ -163,2 +167,4 @@\n-        registerKey(KeyCode.END, RichTextArea.Tags.MOVE_TO_PARAGRAPH_END);\n-        registerKey(KeyBinding.shift(KeyCode.END), RichTextArea.Tags.SELECT_PARAGRAPH_END);\n+        registerKey(KeyCode.END, RichTextArea.Tags.MOVE_TO_LINE_END);\n+        registerKey(KeyBinding.ctrl(KeyCode.END), RichTextArea.Tags.MOVE_TO_DOCUMENT_END);\n+        registerKey(KeyBinding.ctrlShift(KeyCode.END), RichTextArea.Tags.SELECT_TO_DOCUMENT_END);\n+        registerKey(KeyBinding.shift(KeyCode.END), RichTextArea.Tags.SELECT_TO_LINE_END);\n@@ -166,2 +172,4 @@\n-        registerKey(KeyCode.HOME, RichTextArea.Tags.MOVE_TO_PARAGRAPH_START);\n-        registerKey(KeyBinding.shift(KeyCode.HOME), RichTextArea.Tags.SELECT_PARAGRAPH_START);\n+        registerKey(KeyCode.HOME, RichTextArea.Tags.MOVE_TO_LINE_START);\n+        registerKey(KeyBinding.ctrl(KeyCode.HOME), RichTextArea.Tags.MOVE_TO_DOCUMENT_START);\n+        registerKey(KeyBinding.ctrlShift(KeyCode.HOME), RichTextArea.Tags.SELECT_TO_DOCUMENT_START);\n+        registerKey(KeyBinding.shift(KeyCode.HOME), RichTextArea.Tags.SELECT_TO_LINE_START);\n@@ -201,2 +209,2 @@\n-            registerKey(KeyBinding.shiftShortcut(KeyCode.LEFT), RichTextArea.Tags.SELECT_PARAGRAPH_START);\n-            registerKey(KeyBinding.shortcut(KeyCode.LEFT), RichTextArea.Tags.MOVE_TO_PARAGRAPH_START);\n+            registerKey(KeyBinding.shiftShortcut(KeyCode.LEFT), RichTextArea.Tags.SELECT_TO_LINE_START);\n+            registerKey(KeyBinding.shortcut(KeyCode.LEFT), RichTextArea.Tags.MOVE_TO_LINE_START);\n@@ -205,2 +213,2 @@\n-            registerKey(KeyBinding.shiftShortcut(KeyCode.RIGHT), RichTextArea.Tags.SELECT_PARAGRAPH_END);\n-            registerKey(KeyBinding.shortcut(KeyCode.RIGHT), RichTextArea.Tags.MOVE_TO_PARAGRAPH_END);\n+            registerKey(KeyBinding.shiftShortcut(KeyCode.RIGHT), RichTextArea.Tags.SELECT_TO_LINE_END);\n+            registerKey(KeyBinding.shortcut(KeyCode.RIGHT), RichTextArea.Tags.MOVE_TO_LINE_END);\n@@ -220,6 +228,0 @@\n-            registerKey(KeyBinding.ctrl(KeyCode.HOME), RichTextArea.Tags.MOVE_TO_DOCUMENT_START);\n-            registerKey(KeyBinding.ctrlShift(KeyCode.HOME), RichTextArea.Tags.SELECT_TO_DOCUMENT_START);\n-            registerKey(KeyBinding.shift(KeyCode.HOME), RichTextArea.Tags.SELECT_PARAGRAPH_START);\n-            registerKey(KeyBinding.ctrl(KeyCode.END), RichTextArea.Tags.MOVE_TO_DOCUMENT_END);\n-            registerKey(KeyBinding.ctrlShift(KeyCode.END), RichTextArea.Tags.SELECT_TO_DOCUMENT_END);\n-            registerKey(KeyBinding.shift(KeyCode.END), RichTextArea.Tags.SELECT_PARAGRAPH_END);\n@@ -519,1 +521,2 @@\n-        vflow.scrollVerticalPixels(delta, true);\n+        vflow.scrollVerticalPixels(delta);\n+        vflow.layoutChildren();\n@@ -531,1 +534,1 @@\n-        moveLine(vflow.getViewPortHeight(), false);\n+        moveVertically(vflow.getViewPortHeight(), false);\n@@ -535,1 +538,1 @@\n-        moveLine(-vflow.getViewPortHeight(), false);\n+        moveVertically(-vflow.getViewPortHeight(), false);\n@@ -626,1 +629,1 @@\n-        moveLine(-1.0, false);\n+        moveVertically(-1.0, false);\n@@ -630,1 +633,1 @@\n-        moveLine(1.0, false);\n+        moveVertically(1.0, false);\n@@ -658,1 +661,1 @@\n-    protected void moveLine(double deltaPixels, boolean extendSelection) {\n+    protected void moveVertically(double deltaPixels, boolean extendSelection) {\n@@ -664,0 +667,2 @@\n+        vflow.scrollCaretToVisible();\n+\n@@ -683,1 +688,17 @@\n-        TextPos p = vflow.moveLine(caret.index(), x, y, down);\n+        TextPos p = vflow.moveVertically(caret.index(), x, y, down);\n+        if (p != null) {\n+            moveCaret(p, extendSelection);\n+        }\n+    }\n+\n+    protected void moveHorizontally(boolean start, boolean extendSelection) {\n+        TextPos caret = getControl().getCaretPosition();\n+        if (caret == null) {\n+            return;\n+        }\n+\n+        vflow.scrollCaretToVisible();\n+\n+        int ix = caret.index();\n+        int off = caret.charIndex();\n+        TextPos p = vflow.moveHorizontally(start, ix, off);\n@@ -685,0 +706,1 @@\n+            clearPhantomX();\n@@ -689,0 +711,8 @@\n+    protected void moveLineEnd() {\n+        moveHorizontally(false, false);\n+    }\n+\n+    protected void moveLineStart() {\n+        moveHorizontally(true, false);\n+    }\n+\n@@ -800,1 +830,1 @@\n-        moveLine(-1.0, true);\n+        moveVertically(-1.0, true);\n@@ -804,1 +834,9 @@\n-        moveLine(1.0, true);\n+        moveVertically(1.0, true);\n+    }\n+\n+    protected void selectLineEnd() {\n+        moveHorizontally(false, true);\n+    }\n+\n+    protected void selectLineStart() {\n+        moveHorizontally(true, true);\n@@ -808,1 +846,1 @@\n-        moveLine(vflow.getViewPortHeight(), true);\n+        moveVertically(vflow.getViewPortHeight(), true);\n@@ -812,1 +850,1 @@\n-        moveLine(-vflow.getViewPortHeight(), true);\n+        moveVertically(-vflow.getViewPortHeight(), true);\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/RichTextAreaBehavior.java","additions":63,"deletions":25,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -416,1 +416,13 @@\n-        return (y < getHeight()) && (y >= 0.0);\n+        return (y < height) && (y >= 0.0);\n+    }\n+\n+    public Integer lineEdge(boolean start, int caretIndex, int caretOffset) {\n+        if (content instanceof TextFlow f) {\n+            int line = RichUtils.lineForOffset(f, caretOffset);\n+            if (start) {\n+                return RichUtils.lineStart(f, line);\n+            } else {\n+                return RichUtils.lineEnd(f, line);\n+            }\n+        }\n+        return null;\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/TextCell.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -210,1 +210,0 @@\n-        \/\/ FIX contentWidth.addListener((p) -> updateHorizontalScrollBar());\n@@ -360,5 +359,0 @@\n-        \/\/ TODO remove this check later\n-        if (Math.abs(w - snapPositionX(w)) > 0.0001) {\n-            System.err.println(\"unwrapped position is not snapped!\");\n-        }\n-\n@@ -652,1 +646,1 @@\n-            double h = getHeight();\n+            double h = getViewPortHeight();\n@@ -672,0 +666,17 @@\n+            \/\/ When scrolling virtualized views, we cannot rely on caching of cell heights as it's being done\n+            \/\/ in the VirtualFlow.  Instead, we must approximate using the information provided to us by the\n+            \/\/ sliding window.\n+            \/\/\n+            \/\/ 1. rough positioning by using index = pos * (lineCount - 1)\n+            \/\/ 2. compute resulting position' based on (estimated) pixel counts\n+            \/\/      pos' = topPixels \/ (topPixels + bottomPixels - viewportH)\n+            \/\/    where\n+            \/\/      topPixels = topPad + (topIndex)*av + topHeight\n+            \/\/      bottomPixels = bottomPad + bottomHeight + (lineCount - origin.ix - bottomCount)*av\n+            \/\/ 3. then adjust by scrolling by pixels\n+            \/\/      dy = (pos - pos') * totalPixels\n+            \/\/    where\n+            \/\/      totalPixels = topPixels + bottomPixels - viewportH\n+            \/\/\n+            \/\/ there might still be some flicker due to the hsb appearing and disappearing\n+\n@@ -673,0 +684,1 @@\n+            double min = vscroll.getMin();\n@@ -674,2 +686,1 @@\n-            double visible = vscroll.getVisibleAmount();\n-            double pos = fromScrollBarValue(val, visible, max); \/\/ max is 1.0\n+            double pos = (val - min) \/ max;\n@@ -677,1 +688,3 @@\n-            Origin p = arrangement().fromAbsolutePosition(pos);\n+            int lineCount = getParagraphCount();\n+            int ix = Math.max(0, (int)Math.round(pos * (lineCount - 1)));\n+            Origin p = new Origin(ix, 0.0);\n@@ -679,0 +692,19 @@\n+            layoutCells();\n+\n+            CellArrangement a = arrangement();\n+            int topIx = a.topIndex();\n+            double topH = a.topHeight();\n+            double bottomH = a.bottomHeight();\n+            int cellCount = a.cellCount();\n+            double av = a.averageHeight();\n+            int originIx = getOrigin().index();\n+            double viewH = getViewPortHeight();\n+\n+            double topPixels = contentPaddingTop + (topIx * av) + topH;\n+            double bottomPixels = bottomH + (lineCount - topIx - cellCount) * av + contentPaddingBottom;\n+            double totalScroll = Math.max(0.0, (topPixels + bottomPixels - viewH));\n+            double pos1 = topPixels \/ totalScroll;\n+            double dy = (pos - pos1) * totalScroll;\n+\n+            scrollVerticalPixels(dy);\n+            layoutChildren();\n@@ -900,6 +932,1 @@\n-        scrollVerticalPixels(delta, false);\n-    }\n-\n-    \/** scroll by a number of pixels, delta must not exceed the view height in absolute terms *\/\n-    public void scrollVerticalPixels(double delta, boolean forceLayout) {\n-        Origin or = arrangement().computeOrigin(delta);\n+        Origin or = arrangement().moveOrigin(delta);\n@@ -908,3 +935,0 @@\n-            if (forceLayout) {\n-                layoutChildren();\n-            }\n@@ -945,1 +969,1 @@\n-        if (y < 0.0) {\n+        if (y < snappedTopInset()) {\n@@ -947,1 +971,1 @@\n-            scrollVerticalPixels(y);\n+            scrollVerticalPixels(y - snappedTopInset());\n@@ -957,0 +981,7 @@\n+        TextPos caret = control.getCaretPosition();\n+        if (caret == null) {\n+            \/\/ no caret\n+            return;\n+        }\n+\n+        boolean reflow = false;\n@@ -961,11 +992,7 @@\n-            TextPos p = control.getCaretPosition();\n-            if (p != null) {\n-                int ix = p.index();\n-                Origin or = new Origin(ix, 0.0);\n-                boolean moveDown = (ix > getOrigin().index());\n-                setOrigin(or);\n-                c = getCaretInfo();\n-                if (moveDown) {\n-                    scrollVerticalPixels(c.getMaxY() - c.getMinY() - getViewPortHeight());\n-                }\n-                checkForExcessiveWhitespaceAtTheEnd();\n+            int ix = caret.index();\n+            Origin or = new Origin(ix, 0.0);\n+            boolean moveDown = (ix > getOrigin().index());\n+            setOrigin(or);\n+            c = getCaretInfo();\n+            if (moveDown) {\n+                scrollVerticalPixels(c.getMaxY() - c.getMinY() - getViewPortHeight());\n@@ -973,0 +1000,2 @@\n+            checkForExcessiveWhitespaceAtTheEnd();\n+            reflow = true;\n@@ -975,2 +1004,3 @@\n-            if (c.getMinY() < 0.0) {\n-                scrollVerticalPixels(c.getMinY());\n+            if (c.getMinY() < snappedTopInset()) {\n+                scrollVerticalPixels(c.getMinY() - snappedTopInset());\n+                reflow = true;\n@@ -979,0 +1009,1 @@\n+                reflow = true;\n@@ -991,0 +1022,4 @@\n+\n+        if (reflow) {\n+            layout();\n+        }\n@@ -1095,0 +1130,12 @@\n+    public TextPos moveHorizontally(boolean start, int caretIndex, int caretOffset) {\n+        TextCell cell = getCell(caretIndex);\n+        Integer off = cell.lineEdge(start, caretIndex, caretOffset);\n+        if (off == null) {\n+            return null;\n+        } else if(start || off == 0) {\n+            return new TextPos(caretIndex, off);\n+        } else {\n+            return new TextPos(caretIndex, off, off - 1, false);\n+        }\n+    }\n+\n@@ -1106,1 +1153,1 @@\n-    public TextPos moveLine(int caretIndex, double x, double y, boolean down) {\n+    public TextPos moveVertically(int caretIndex, double x, double y, boolean down) {\n@@ -1140,1 +1187,5 @@\n-            return null; \/\/ should not happen\n+            if (down) {\n+                return skin.getSkinnable().getDocumentEnd();\n+            } else {\n+                return TextPos.ZERO;\n+            }\n@@ -1266,1 +1317,1 @@\n-        arrangement = new CellArrangement(this, contentPaddingLeft, contentPaddingTop);\n+        arrangement = new CellArrangement(this, contentPaddingTop, contentPaddingBottom);\n@@ -1288,2 +1339,0 @@\n-        \/\/ FIX height as in component height vs. contentHeight in useContentHeight!\n-        \/\/double height = useContentHeight ? (padTop + padBottom + contentPaddingTop + contentPaddingBottom) : getHeight();\n@@ -1295,1 +1344,1 @@\n-        double maxWidth; \/\/ TODO what is it?  replace with cell's preferred width (in unwrapped mode)\n+        double maxWidth; \/\/ max width to apply before the layout (or replace with cell's preferred width?)\n@@ -1304,1 +1353,0 @@\n-        double unwrappedWidth = 0.0;\n@@ -1307,1 +1355,1 @@\n-\n+        double unwrappedWidth = 0.0;\n@@ -1310,3 +1358,2 @@\n-        double margin = Params.SLIDING_WINDOW_EXTENT * height;\n-        int topMarginCount = 0;\n-        int bottomMarginCount = 0;\n+        int topMarginCount = Params.SLIDING_WINDOW_EXTENT;\n+        int bottomMargin = 0;;\n@@ -1315,1 +1362,0 @@\n-        \/\/ TODO if topCount < marginCount, increase bottomCount correspondingly\n@@ -1359,2 +1405,1 @@\n-                        topMarginCount = (int)Math.ceil(count * Params.SLIDING_WINDOW_EXTENT);\n-                        bottomMarginCount = count + topMarginCount;\n+                        \/\/ reached the cell below the last visible cell at the bottom\n@@ -1363,0 +1408,7 @@\n+\n+                        bottomMargin = count + Params.SLIDING_WINDOW_EXTENT;\n+                        int less = bottomMargin - getParagraphCount();\n+                        if (less > 0) {\n+                            \/\/ more cells on top\n+                            topMarginCount += less;\n+                        }\n@@ -1368,1 +1420,1 @@\n-                    if ((y > (height + margin)) && (count > bottomMarginCount)) {\n+                    if (count > bottomMargin) {\n@@ -1438,1 +1490,0 @@\n-        \/\/ TODO populate more, if bottom ended prematurely\n@@ -1448,1 +1499,0 @@\n-\/\/            cell.layout();\n@@ -1455,0 +1505,1 @@\n+            cell.setPosition(y, h);\n@@ -1463,1 +1514,1 @@\n-            if ((-y > margin) && (count > topMarginCount)) {\n+            if (count > topMarginCount) {\n@@ -1496,1 +1547,1 @@\n-            width -= vsbWidth; \/\/ TODO or use viewportwidth?\n+            width -= vsbWidth;\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/VFlow.java","additions":104,"deletions":53,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -208,0 +208,4 @@\n+        \/** Moves the caret to the end of the visual text line at caret. *\/\n+        public static final FunctionTag MOVE_TO_LINE_END = new FunctionTag();\n+        \/** Moves the caret to the beginning of the visual text line at caret. *\/\n+        public static final FunctionTag MOVE_TO_LINE_START = new FunctionTag();\n@@ -260,0 +264,4 @@\n+        \/** Extends selection to the end of the visual text line at caret. *\/\n+        public static final FunctionTag SELECT_TO_LINE_END = new FunctionTag();\n+        \/** Extends selection to the start of the visual text line at caret. *\/\n+        public static final FunctionTag SELECT_TO_LINE_START = new FunctionTag();\n@@ -1498,0 +1506,24 @@\n+    \/**\n+     * Moves the caret to the end of the visual text line at caret, clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_TO_LINE_END\n+     *\/\n+    public void moveLineEnd() {\n+        execute(Tags.MOVE_TO_LINE_END);\n+    }\n+\n+    \/**\n+     * Moves the caret to the start of the visual text line at caret, clearing an existing selection.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#MOVE_TO_LINE_START\n+     *\/\n+    public void moveLineStart() {\n+        execute(Tags.MOVE_TO_LINE_START);\n+    }\n+\n@@ -1963,0 +1995,22 @@\n+    \/**\n+     * Extends selection to the end of the visual text line at caret.\n+     * <p>\n+     * This method does nothing when the caret position is {@code null}.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_TO_LINE_END\n+     *\/\n+    public void selectToLineEnd() {\n+        execute(Tags.SELECT_TO_LINE_END);\n+    }\n+\n+    \/**\n+     * Extends selection to the start of the visual text line at caret.\n+     * <p>\n+     * This action can be changed by remapping the default behavior via {@link InputMap}.\n+     * @see RichTextArea.Tags#SELECT_TO_LINE_START\n+     *\/\n+    public void selectToLineStart() {\n+        execute(Tags.SELECT_TO_LINE_START);\n+    }\n+\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/RichTextArea.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"}]}