{"files":[{"patch":"@@ -173,0 +173,2 @@\n+            \/\/ The new loop will prevent the current loop from leaving.\n+            leavingNestedEventLoop = false;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/InvokeLaterDispatcher.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    glass_maybe_leave_nested_event_loop();\n+\n@@ -307,0 +309,1 @@\n+    glass_set_leave_nested_event_loop(false);\n@@ -321,1 +324,1 @@\n-    gtk_main_quit();\n+    glass_set_leave_nested_event_loop(true);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassApplication.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+\n+        glass_maybe_leave_nested_event_loop();\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassTimer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -465,0 +465,13 @@\n+static bool should_leave_nested_event_loop = false;\n+\n+void glass_set_leave_nested_event_loop(bool v) {\n+    should_leave_nested_event_loop = v;\n+}\n+\n+void glass_maybe_leave_nested_event_loop() {\n+    if (should_leave_nested_event_loop) {\n+        gtk_main_quit();\n+        should_leave_nested_event_loop = false;\n+    }\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -280,0 +280,3 @@\n+    void glass_set_leave_nested_event_loop(bool v);\n+    void glass_maybe_leave_nested_event_loop();\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -778,0 +778,8 @@\n+\/\/ The OS may invoke a GlassRunnable either in the runMode:beforeDate: call or\n+\/\/ the nextEventMatchingMask call. If a runnable invoked during\n+\/\/ runMode:beforeDate: schedules a new runnable it will be invoked by\n+\/\/ nextEventMatchingMask. If a runnable invoked during nextEventMatchingMask\n+\/\/ schedules a new runnable it may be invoked in the same nextEventMatchingMask\n+\/\/ call or it may be deferred to the next loop iteration. So we can't guarantee\n+\/\/ that a newly scheduled runnable will be invoked in the next event loop\n+\/\/ cycle, it may happen in the current cycle.\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassApplication.m","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -307,0 +307,48 @@\n+\n+    \/\/ Test the case where we begin exiting the innermost loop but don't wait\n+    \/\/ for it to fully exit before entering a new loop.\n+    @Test(timeout=3000)\n+    public void testCanExitAndThenEnterNewLoop() {\n+        final long key1 = 1024L;\n+        final long key2 = 1025L;\n+        final long result1 = 2048L;\n+        final long result2 = 2049L;\n+        final AtomicLong returnedValue1 = new AtomicLong();\n+        final AtomicLong returnedValue2 = new AtomicLong();\n+        final AtomicBoolean loopOneRunning = new AtomicBoolean(false);\n+        final AtomicBoolean loopTwoRunning = new AtomicBoolean(false);\n+\n+        Util.runAndWait(\n+                () -> {\n+                    \/\/ enter loop one\n+                    assertFalse(Platform.isNestedLoopRunning());\n+                    loopOneRunning.set(true);\n+                    Long actual = (Long) Platform.enterNestedEventLoop(key1);\n+                    loopOneRunning.set(false);\n+                    returnedValue1.set(actual);\n+                },\n+                () -> {\n+                    \/\/ exit loop one and enter loop two\n+                    assertTrue(Platform.isNestedLoopRunning());\n+                    Platform.exitNestedEventLoop(key1, result1);\n+                    loopTwoRunning.set(true);\n+                    Long actual = (Long) Platform.enterNestedEventLoop(key2);\n+                    loopTwoRunning.set(false);\n+                    returnedValue2.set(actual);\n+                },\n+                () -> {\n+                    \/\/ exit loop two\n+                    assertTrue(Platform.isNestedLoopRunning());\n+                    assertTrue(loopOneRunning.get());\n+                    assertTrue(loopTwoRunning.get());\n+                    Platform.exitNestedEventLoop(key2, result2);\n+                });\n+        \/\/ check that loops are done\n+        Util.runAndWait(() -> {\n+            assertFalse(Platform.isNestedLoopRunning());\n+            assertFalse(loopOneRunning.get());\n+            assertFalse(loopTwoRunning.get());\n+            assertEquals(result1, returnedValue1.get());\n+            assertEquals(result2, returnedValue2.get());\n+        });\n+    }\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/NestedEventLoopTest.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"}]}