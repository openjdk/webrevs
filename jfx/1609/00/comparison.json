{"files":[{"patch":"@@ -43,0 +43,1 @@\n+import javafx.geometry.NodeOrientation;\n@@ -65,0 +66,1 @@\n+import com.sun.javafx.scene.shape.TextHelper;\n@@ -387,1 +389,1 @@\n-                HitInfo hit = textNode.hitTest(translateCaretPosition(p));\n+                HitInfo hit = hitTest(p);\n@@ -398,1 +400,1 @@\n-                HitInfo hit = textNode.hitTest(translateCaretPosition(p));\n+                HitInfo hit = hitTest(p);\n@@ -419,1 +421,1 @@\n-                HitInfo hit = textNode.hitTest(translateCaretPosition(p));\n+                HitInfo hit = hitTest(p);\n@@ -478,2 +480,14 @@\n-        HitInfo hit = textNode.hitTest(translateCaretPosition(p));\n-        return hit;\n+        return hitTest(p);\n+    }\n+\n+    private HitInfo hitTest(Point2D p) {\n+        Text textNode = getTextNode();\n+        if (getSkinnable().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {\n+            double w = textNode.getWrappingWidth();\n+            if (w == 0.0) {\n+                w = TextHelper.getVisualWidth(textNode);\n+            }\n+            double x = w - p.getX();\n+            p = new Point2D(x, p.getY());\n+        }\n+        return textNode.hitTest(p);\n@@ -569,1 +583,1 @@\n-        HitInfo hit = textNode.hitTest(new Point2D(hitX, hitY));\n+        HitInfo hit = hitTest(new Point2D(hitX, hitY));\n@@ -608,1 +622,1 @@\n-        HitInfo hit = textNode.hitTest(translateCaretPosition(new Point2D(x, targetLineMidY)));\n+        HitInfo hit = hitTest(new Point2D(x, targetLineMidY));\n@@ -817,1 +831,1 @@\n-        Text paragraphNode = getTextNode();\n+        Text n = getTextNode();\n@@ -822,1 +836,1 @@\n-            return (textArea.getLength() - paragraphNode.getText().length());\n+            return (textArea.getLength() - n.getText().length());\n@@ -824,7 +838,5 @@\n-            Bounds bounds = paragraphNode.getBoundsInLocal();\n-            double paragraphViewY = paragraphNode.getLayoutY() + bounds.getMinY();\n-            if (y >= paragraphViewY\n-                    && y < paragraphViewY + paragraphNode.getBoundsInLocal().getHeight()) {\n-                return getInsertionPoint(paragraphNode,\n-                        x - paragraphNode.getLayoutX(),\n-                        y - paragraphNode.getLayoutY());\n+            Bounds bounds = n.getBoundsInLocal();\n+            double dy = n.getLayoutY() + bounds.getMinY();\n+            if ((y >= dy) && (y < dy + n.getBoundsInLocal().getHeight())) {\n+                Point2D p = new Point2D(x - n.getLayoutX(), y - n.getLayoutY());\n+                return hitTest(p).getInsertionIndex();\n@@ -833,1 +845,0 @@\n-\n@@ -956,5 +967,0 @@\n-    private int getInsertionPoint(Text paragraphNode, double x, double y) {\n-        HitInfo hitInfo = paragraphNode.hitTest(new Point2D(x, y));\n-        return hitInfo.getInsertionIndex();\n-    }\n-\n@@ -1050,8 +1056,0 @@\n-    private double getTextLeft() {\n-        return 0;\n-    }\n-\n-    private Point2D translateCaretPosition(Point2D p) {\n-        return p;\n-    }\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TextAreaSkin.java","additions":28,"deletions":30,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -29,5 +29,0 @@\n-\n-import com.sun.javafx.scene.control.behavior.PasswordFieldBehavior;\n-import com.sun.javafx.scene.control.behavior.TextFieldBehavior;\n-import com.sun.javafx.scene.control.behavior.TextInputControlBehavior;\n-\n@@ -45,0 +40,1 @@\n+import javafx.geometry.NodeOrientation;\n@@ -63,0 +59,4 @@\n+import com.sun.javafx.scene.control.behavior.PasswordFieldBehavior;\n+import com.sun.javafx.scene.control.behavior.TextFieldBehavior;\n+import com.sun.javafx.scene.control.behavior.TextInputControlBehavior;\n+import com.sun.javafx.scene.shape.TextHelper;\n@@ -334,1 +334,1 @@\n-                HitInfo hit = textNode.hitTest(p);\n+                HitInfo hit = hitTest(p);\n@@ -345,1 +345,1 @@\n-                    HitInfo hit = textNode.hitTest(p);\n+                    HitInfo hit = hitTest(p);\n@@ -367,1 +367,1 @@\n-                    HitInfo hit = textNode.hitTest(p);\n+                    HitInfo hit = hitTest(p);\n@@ -488,3 +488,2 @@\n-        Point2D p = new Point2D(x - textTranslateX.get() - snappedLeftInset(),\n-                                y - snappedTopInset());\n-        return textNode.hitTest(p);\n+        Point2D p = new Point2D(x - textTranslateX.get() - snappedLeftInset(), y - snappedTopInset());\n+        return hitTest(p);\n@@ -599,1 +598,1 @@\n-        HitInfo hit = textNode.hitTest(new Point2D(hitX, hitY));\n+        HitInfo hit = hitTest(new Point2D(hitX, hitY));\n@@ -942,0 +941,7 @@\n+    private final HitInfo hitTest(Point2D p) {\n+        if (getSkinnable().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {\n+            double x = TextHelper.getVisualWidth(getTextNode()) - p.getX();\n+            p = new Point2D(x, p.getY());\n+        }\n+        return textNode.hitTest(p);\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TextFieldSkin.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -67,0 +67,4 @@\n+    public static float getVisualWidth(Text t) {\n+        return textAccessor.getVisualWidth(t);\n+    }\n+\n@@ -130,0 +134,1 @@\n+        public float getVisualWidth(Text t);\n@@ -131,1 +136,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/shape\/TextHelper.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -167,0 +167,5 @@\n+\n+            @Override\n+            public float getVisualWidth(Text t) {\n+                return t.getVisualBounds().getWidth();\n+            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/Text.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,0 +118,2 @@\n+    exports com.sun.javafx.scene.shape to\n+        javafx.controls;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/module-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import javafx.geometry.Point2D;\n@@ -38,0 +39,1 @@\n+import javafx.scene.input.MouseButton;\n@@ -54,0 +56,4 @@\n+    protected static final int STAGE_WIDTH = 400;\n+    protected static final int STAGE_HEIGHT = 300;\n+    \/** causes the execute() function to wait for idle *\/\n+    protected static final Object PULSE = new Object();\n@@ -59,1 +65,1 @@\n-    private static BorderPane content;\n+    protected static BorderPane content;\n@@ -64,1 +70,1 @@\n-    protected C control;\n+    protected final C control;\n@@ -79,2 +85,2 @@\n-            stage.setWidth(400);\n-            stage.setHeight(300);\n+            stage.setWidth(STAGE_WIDTH);\n+            stage.setHeight(STAGE_HEIGHT);\n@@ -121,1 +127,1 @@\n-     * <li> if a Runnable, runs it\n+     * <li> if a Runnable, runs it in the FX application thread\n@@ -126,2 +132,4 @@\n-        for (Object x : items) {\n-            if (x instanceof Runnable r) {\n+        for (Object x: items) {\n+            if (x == PULSE) {\n+                Util.waitForIdle(scene);\n+            } else if (x instanceof Runnable r) {\n@@ -227,0 +235,5 @@\n+    \/**\n+     * Returns the Runnable argument.  This method simplifies construction of execute() vararg.\n+     * @param r the runnable to return\n+     * @return the runnable\n+     *\/\n@@ -339,0 +352,76 @@\n+\n+    \/**\n+     * Performs the mouse click with the {@code MouseButton.PRIMARY} via Robot.\n+     * Must be called from the FX Application thread.\n+     *\/\n+    protected void mouseClick() {\n+        mouseClick(MouseButton.PRIMARY);\n+    }\n+\n+    \/**\n+     * Performs the mouse click with the specified button via Robot.\n+     * Must be called from the FX Application thread.\n+     * @param b the button\n+     *\/\n+    protected void mouseClick(MouseButton b) {\n+        robot.mouseClick(b);\n+    }\n+\n+    \/**\n+     * Performs the mouse press with the {@code MouseButton.PRIMARY} via Robot.\n+     * Must be called from the FX Application thread.\n+     *\/\n+    protected void mousePress() {\n+        mousePress(MouseButton.PRIMARY);\n+    }\n+\n+    \/**\n+     * Performs the mouse press with the specified button via Robot.\n+     * Must be called from the FX Application thread.\n+     * @param b the button\n+     *\/\n+    protected void mousePress(MouseButton b) {\n+        robot.mousePress(b);\n+    }\n+\n+    \/**\n+     * Performs the mouse release with the {@code MouseButton.PRIMARY} via Robot.\n+     * Must be called from the FX Application thread.\n+     *\/\n+    protected void mouseRelease() {\n+        mouseRelease(MouseButton.PRIMARY);\n+    }\n+\n+    \/**\n+     * Performs the mouse release with the specified button via Robot.\n+     * Must be called from the FX Application thread.\n+     * @param b the button\n+     *\/\n+    protected void mouseRelease(MouseButton b) {\n+        robot.mouseRelease(b);\n+    }\n+\n+    protected void mouseMove(double x, double y) {\n+        Point2D p = control.localToScreen(x, y);\n+        robot.mouseMove(p.getX(), p.getY());\n+    }\n+\n+    \/**\n+     * To be used only for debugging, to be able to observe the intermediate state of the UI.\n+     * Please do not use this method in the actual tests.\n+     * @param seconds the number of seconds to sleep\n+     * @return the Runnable\n+     *\/\n+    protected Runnable sleep(int seconds) {\n+        return exe(() -> {\n+            try {\n+                Thread.sleep(seconds * 1000L);\n+            } catch (Exception e) {\n+            }\n+        });\n+    }\n+\n+    \/\/ debugging aid\n+    protected void p(Object v) {\n+        System.out.println(v);\n+    }\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/control\/behavior\/BehaviorRobotTestBase.java","additions":96,"deletions":7,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.robot.javafx.scene.control.behavior;\n+\n+import java.awt.image.BufferedImage;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Base64;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.imageio.ImageIO;\n+import javafx.embed.swing.SwingFXUtils;\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.image.WritableImage;\n+import javafx.scene.robot.Robot;\n+import javafx.stage.Screen;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.TestWatcher;\n+import test.util.Util;\n+\n+\/**\n+ * Takes a screenshot of any failed test, then outputs it to {@code stderr}\n+ * in a base-64-encoded data URL.  This string can be copied to a browser address bar\n+ * to see the image (the image might be truncated by the browser, so try different browsers\n+ * or use a dedicated program).\n+ * <p>\n+ * To use, simply add the following annotation to your class:\n+ * <pre>{@code\n+ * @ExtendWith(ScreenshotFailedTestWatcher.class)\n+ * }<\/pre>\n+ * <p>\n+ * For Eclipse users, override dependencies with the following entries:\n+ * <pre>{@code\n+ * --add-modules=javafx.base,javafx.graphics,javafx.controls,javafx.swing\n+ * --add-opens javafx.controls\/test.com.sun.javafx.scene.control.test=javafx.base\n+ * --add-exports javafx.base\/com.sun.javafx=ALL-UNNAMED\n+ * -Djava.library.path=\"..\/..\/..\/..\/build\/sdk\/lib\"\n+ * -ea\n+ * }<\/pre>\n+ * <p>\n+ * WARNING: using this utility may significantly increase the size of your logs!\n+ * Make sure there is plenty of free disk space.\n+ *\/\n+public class ScreenshotFailedTestWatcher implements TestWatcher {\n+    @Override\n+    public void testFailed(ExtensionContext cx, Throwable e) {\n+        System.err.println(generateScreenshot(\"Screenshot:\\ndata:image\/png;base64,\", \"\\n\"));\n+    }\n+\n+    private String generateScreenshot(String prefix, String postfix) {\n+        AtomicReference<String> ref = new AtomicReference<>();\n+        Util.runAndWait(() -> {\n+            String s = generateScreenshotFX(prefix, postfix);\n+            ref.set(s);\n+        });\n+        return ref.get();\n+    }\n+\n+    private String generateScreenshotFX(String prefix, String postfix) {\n+        try {\n+            \/\/ there should be a JavaFX way to create images without requiring ImageIO and Swing!\n+            ImageIO.setUseCache(false);\n+\n+            Rectangle2D bounds = Screen.getPrimary().getBounds();\n+            Robot r = new Robot();\n+            \/\/ do not scale to fit, capture all pixels\n+            WritableImage im = r.getScreenCapture(null, bounds, false);\n+            ByteArrayOutputStream os = new ByteArrayOutputStream();\n+            BufferedImage im2 = SwingFXUtils.fromFXImage(im, null);\n+            ImageIO.write(im2, \"PNG\", os);\n+            byte[] b = os.toByteArray();\n+            String b64 = Base64.getEncoder().encodeToString(b);\n+\n+            int len0 = (prefix == null) ? 0 : prefix.length();\n+            int len1 = (postfix == null) ? 0 : postfix.length();\n+\n+            if ((len0 + len1) == 0) {\n+                return b64;\n+            }\n+\n+            int sz = b64.length() + len0 + len1;\n+            StringBuilder sb = new StringBuilder(sz);\n+            if (prefix != null) {\n+                sb.append(prefix);\n+            }\n+            sb.append(b64);\n+            if (postfix != null) {\n+                sb.append(postfix);\n+            }\n+            return sb.toString();\n+        } catch (IOException e) {\n+            return \"error generating screenshot: \" + e;\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/control\/behavior\/ScreenshotFailedTestWatcher.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.robot.javafx.scene.control.behavior;\n+\n+import java.util.Set;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.Point2D;\n+import javafx.scene.Node;\n+import javafx.scene.control.IndexRange;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.image.WritableImage;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.paint.Color;\n+import javafx.scene.shape.LineTo;\n+import javafx.scene.shape.MoveTo;\n+import javafx.scene.shape.PathElement;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.Text;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import test.util.Util;\n+\n+\/**\n+ * Tests TextArea RTL\/LTR behavior.\n+ *\/\n+@ExtendWith(ScreenshotFailedTestWatcher.class)\n+public class TextAreaRTLTest extends TextInputBehaviorRobotTest<TextArea> {\n+    private Color selectionColor;\n+\n+    public TextAreaRTLTest() {\n+        super(new TextArea());\n+    }\n+\n+    @BeforeEach\n+    @Override\n+    public void beforeEach() {\n+        super.beforeEach();\n+        \/\/ set good initial conditions\n+        Util.runAndWait(() -> {\n+            control.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);\n+            control.setFont(Font.font(\"System\", 24));\n+            control.setText(null);\n+            control.deselect();\n+            Util.parkCursor(robot);\n+        });\n+    }\n+\n+    @Test\n+    public void testSelectionLTR() throws Exception {\n+        execute(\n+            setText(\"______\\n______\"),\n+            exe(() -> {\n+                mouseMove(5, 12);\n+                mousePress();\n+            }),\n+            exe(() -> {\n+                mouseMove(100, 100);\n+                mouseRelease();\n+            }),\n+            checkSelection(0, 13),\n+            exe(() -> {\n+                Rect r = charBounds(0);\n+                \/\/ check that caret position at index 0 is near 0,0 and is selected\n+                Assertions.assertTrue(r.x < 50);\n+                Assertions.assertTrue(r.y < 50);\n+                Assertions.assertTrue(isCellSelected(r));\n+            })\n+        );\n+    }\n+\n+    \/\/ TODO the test does not work due to JDK-8189167\n+    @Disabled(\"JDK-8189167\")\n+    @Test\n+    public void testSelectionRTL() throws Exception {\n+        \/\/ class for ease of accessing variables passed between individual Runnables in execute()\n+        new Runnable() {\n+            volatile double x;\n+\n+            @Override\n+            public void run() {\n+                execute(\n+                    exe(() -> {\n+                        control.setNodeOrientation(NodeOrientation.RIGHT_TO_LEFT);\n+                        control.setText(\"______\\n______\");\n+                    }),\n+                    PULSE,\n+                    exe(() -> {\n+                        int len = control.getText().length();\n+                        for(int i=0; i<=len; i++) {\n+                            Rect r = charBounds(i);\n+                            p(\"cell[\" + i + \"]=\" + r);\n+                        }\n+                        Rect r = charBounds(0);\n+                        p(\"cell[0]=\" + r);\n+\n+                        \/\/ check that caret position at index 0 is in the right side and not selected\n+                        Assertions.assertTrue(r.x > (STAGE_WIDTH \/ 3));\n+                        Assertions.assertTrue(r.y < 50);\n+                        Assertions.assertFalse(isCellSelected(r));\n+\n+                        \/\/ start with index 3\n+                        r = charBounds(3);\n+                        p(\"cell[3]=\" + r);\n+                        x = r.x;\n+                    }),\n+                    exe(() -> {\n+                        mouseMove(x, 12);\n+                        mouseClick();\n+                        p(\"selection=\" + control.getSelection()); \/\/ FIX\n+                    }),\n+                    PULSE,\n+                    \"a\",\n+                    exe(() -> {\n+                        mousePress();\n+                        mouseMove(x, 100);\n+                    }),\n+                    exe(() -> {\n+                        mouseRelease();\n+                    }),\n+                    PULSE,\n+                    exe(() -> {\n+                        IndexRange sel = control.getSelection();\n+                        Assertions.assertTrue(sel.getStart() > 0);\n+                        int ix = sel.getStart();\n+\n+                        \/\/ check if the first selected cell is indeed highlighted\n+                        Rect r = charBounds(ix);\n+                        p(r);\n+                        Assertions.assertTrue(isCellSelected(r));\n+                        \/\/ but the previous one isn't\n+                        r = charBounds(ix - 1);\n+                        p(r);\n+                        Assertions.assertFalse(isCellSelected(r));\n+                    })\n+                );\n+            }\n+        }.run();\n+        \/\/Thread.sleep(100_000); \/\/ FIX\n+    }\n+\n+    private Rect charBounds(int index) {\n+        \/\/ there should be a method in TextArea to convert between screen coordinates and content indexes\n+        \/\/ similar to what was asked in JDK-8092278\n+        Set<Node> nodes = control.lookupAll(\".text\");\n+        if(nodes.size() != 1) {\n+            throw new AssertionError(\"expectng a single Text child with CSS class '.text'\");\n+        }\n+        Text t = (Text)nodes.iterator().next();\n+        PathElement[] pe = t.rangeShape(index, index + 1);\n+        \/\/ translate to the control's coordinates\n+        Point2D p = t.localToScreen(0.0, 0.0);\n+        p = control.screenToLocal(p);\n+        return Rect.of(pe, p.getX(), p.getY());\n+    }\n+\n+    \/\/ TODO maybe extract into a separate @Test, the first to get executed\n+    private boolean isCellSelected(Rect r) {\n+        if(selectionColor == null) {\n+            \/\/ initialize the selection color\n+            TextArea t = new TextArea();\n+            t.setText(\"____________________________\");\n+            t.selectAll();\n+            t.setMinWidth(100);\n+            t.setMinHeight(100);\n+            t.setWrapText(true);\n+            BorderPane pp = new BorderPane(t);\n+            pp.setManaged(false);\n+\n+            content.getChildren().add(pp);\n+\n+            pp.layout();\n+            t.applyCss();\n+            pp.applyCss();\n+            t.requestFocus();\n+\n+            try {\n+                WritableImage im = pp.snapshot(null, null);\n+                selectionColor = im.getPixelReader().getColor(30, 8);\n+                content.layout();\n+            } finally {\n+                content.getChildren().remove(pp);\n+            }\n+        }\n+\n+        control.requestFocus();\n+\n+        \/\/System.out.println(\"insets=\" + control.getInsets());\n+        Point2D p = control.localToScreen(r.midX(), r.midY());\n+        \/\/System.out.println(\"r=\" + r);\n+        \/\/System.out.println(\"p=\" + p);\n+        Color c = robot.getPixelColor(p);\n+        \/\/System.out.println(\"color=\" + c);\n+        double tolerance = 0.05;\n+        return\n+            (Math.abs(selectionColor.getRed() - c.getRed()) < tolerance) &&\n+            (Math.abs(selectionColor.getGreen() - c.getGreen()) < tolerance) &&\n+            (Math.abs(selectionColor.getBlue() - c.getBlue()) < tolerance);\n+    }\n+\n+    \/** Rectangle enveloping a single character *\/\n+    static record Rect(double x, double y, double w, double h) {\n+        public double midX() {\n+            return x + (w \/ 2.0);\n+        }\n+\n+        public double midY() {\n+            return y + (h \/ 2.0);\n+        }\n+\n+        public static Rect of(PathElement[] pe, double dx, double dy) {\n+            double xmin = Double.NaN;\n+            double xmax = Double.NaN;\n+            double ymin = Double.NaN;\n+            double ymax = Double.NaN;\n+\n+            for (PathElement em: pe) {\n+                if (em instanceof MoveTo t) {\n+                    if (Double.isNaN(xmin)) {\n+                        xmin = t.getX();\n+                    } else {\n+                        if (xmin > t.getX()) {\n+                            xmin = t.getX();\n+                        }\n+                    }\n+\n+                    if (Double.isNaN(xmax)) {\n+                        xmax = t.getX();\n+                    } else {\n+                        if (xmax < t.getX()) {\n+                            xmax = t.getX();\n+                        }\n+                    }\n+\n+                    if (Double.isNaN(ymin)) {\n+                        ymin = t.getY();\n+                    } else {\n+                        if (ymin > t.getY()) {\n+                            ymin = t.getY();\n+                        }\n+                    }\n+\n+                    if (Double.isNaN(ymax)) {\n+                        ymax = t.getY();\n+                    } else {\n+                        if (ymax < t.getY()) {\n+                            ymax = t.getY();\n+                        }\n+                    }\n+                } else if (em instanceof LineTo t) {\n+                    if (Double.isNaN(xmin)) {\n+                        xmin = t.getX();\n+                    } else {\n+                        if (xmin > t.getX()) {\n+                            xmin = t.getX();\n+                        }\n+                    }\n+\n+                    if (Double.isNaN(xmax)) {\n+                        xmax = t.getX();\n+                    } else {\n+                        if (xmax < t.getX()) {\n+                            xmax = t.getX();\n+                        }\n+                    }\n+\n+                    if (Double.isNaN(ymin)) {\n+                        ymin = t.getY();\n+                    } else {\n+                        if (ymin > t.getY()) {\n+                            ymin = t.getY();\n+                        }\n+                    }\n+\n+                    if (Double.isNaN(ymax)) {\n+                        ymax = t.getY();\n+                    } else {\n+                        if (ymax < t.getY()) {\n+                            ymax = t.getY();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (Double.isNaN(xmin)) {\n+                return null;\n+            } else {\n+                return new Rect(xmin + dx, ymin + dy, xmax - xmin, ymax - ymin);\n+            }\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/control\/behavior\/TextAreaRTLTest.java","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"}]}