{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.javafx.scene.ScenePreferences;\n+import com.sun.javafx.tk.Toolkit;\n@@ -30,1 +32,0 @@\n-import javafx.beans.InvalidationListener;\n@@ -37,1 +38,0 @@\n-import javafx.beans.value.ChangeListener;\n@@ -45,0 +45,6 @@\n+ * <p>\n+ * All properties in this class can be read from any thread in order to allow {@link ScenePreferences} to safely\n+ * initialize its values on a background thread (creating and configuring a {@code Scene} on a background thread\n+ * is allowed by its specification). This is not a specified capability for users, it is an implementation detail.\n+ * <p>\n+ * Importantly, even though properties can be read from any thread, changes always happen on the FX thread.\n@@ -61,0 +67,1 @@\n+    private final Object mutex = new Object();\n@@ -66,1 +73,1 @@\n-        reducedMotionFlag = new ReadOnlyBooleanPropertyImpl(bean, reducedMotion.getName());\n+        reducedMotionFlag = new ReadOnlyBooleanWrapper(bean, reducedMotion.getName());\n@@ -69,1 +76,1 @@\n-        reducedTransparencyFlag = new ReadOnlyBooleanPropertyImpl(bean, reducedTransparency.getName());\n+        reducedTransparencyFlag = new ReadOnlyBooleanWrapper(bean, reducedTransparency.getName());\n@@ -72,1 +79,1 @@\n-        reducedDataFlag = new ReadOnlyBooleanPropertyImpl(bean, reducedData.getName());\n+        reducedDataFlag = new ReadOnlyBooleanWrapper(bean, reducedData.getName());\n@@ -75,1 +82,1 @@\n-        persistentScrollBarsFlag = new ReadOnlyBooleanPropertyImpl(bean, persistentScrollBars.getName());\n+        persistentScrollBarsFlag = new ReadOnlyBooleanWrapper(bean, persistentScrollBars.getName());\n@@ -177,4 +184,6 @@\n-        for (Map.Entry<String, ChangedValue> entry : changedPreferences.entrySet()) {\n-            if (platformKeyMappings.get(entry.getKey()) instanceof PreferenceMapping<?, ?> mapping\n-                    && deferredProperties.get(mapping.keyName()) instanceof DeferredProperty<?> property) {\n-                property.setPlatformValue(mapping.map(entry.getValue().newValue()));\n+        synchronized (mutex) {\n+            for (Map.Entry<String, ChangedValue> entry : changedPreferences.entrySet()) {\n+                if (platformKeyMappings.get(entry.getKey()) instanceof PreferenceMapping<?, ?> mapping\n+                        && deferredProperties.get(mapping.keyName()) instanceof DeferredProperty<?> property) {\n+                    property.setPlatformValue(mapping.map(entry.getValue().newValue()));\n+                }\n@@ -182,1 +191,0 @@\n-        }\n@@ -184,2 +192,5 @@\n-        for (DeferredProperty<?> property : deferredProperties.values()) {\n-            property.fireValueChangedIfNecessary();\n+            colorScheme.update();\n+\n+            for (DeferredProperty<?> property : deferredProperties.values()) {\n+                property.fireValueChangedIfNecessary();\n+            }\n@@ -225,2 +236,4 @@\n-        public synchronized T get() {\n-            return effectiveValue;\n+        public T get() {\n+            synchronized (mutex) {\n+                return effectiveValue;\n+            }\n@@ -234,1 +247,3 @@\n-        public synchronized void setPlatformValue(Object value) {\n+        public void setPlatformValue(Object value) {\n+            \/\/ No need to synchronize here, because the update() method already synchronizes on 'mutex'.\n+            Toolkit.getToolkit().checkFxUserThread();\n@@ -236,1 +251,1 @@\n-            this.platformValue = expectedType.isInstance(value) ? (T)value : null;\n+            this.platformValue = expectedType.isInstance(value) ? (T) value : null;\n@@ -240,4 +255,8 @@\n-        public synchronized void setValueOverride(T value) {\n-            this.overrideValue = value;\n-            updateEffectiveValue();\n-            fireValueChangedEvent();\n+        public void setValueOverride(T value) {\n+            Toolkit.getToolkit().checkFxUserThread();\n+\n+            synchronized (mutex) {\n+                this.overrideValue = value;\n+                updateEffectiveValue();\n+                fireValueChangedIfNecessary();\n+            }\n@@ -246,1 +265,2 @@\n-        public synchronized void fireValueChangedIfNecessary() {\n+        \/\/ This method must only be called when synchronized on 'mutex'.\n+        public void fireValueChangedIfNecessary() {\n@@ -253,0 +273,1 @@\n+        \/\/ This method must only be called when synchronized on 'mutex'.\n@@ -266,9 +287,0 @@\n-            InvalidationListener listener = observable -> update();\n-            backgroundColor.addListener(listener);\n-            foregroundColor.addListener(listener);\n-            update();\n-        }\n-\n-        public synchronized void setValueOverride(ColorScheme colorScheme) {\n-            colorSchemeOverride = colorScheme;\n-            update();\n@@ -277,8 +289,4 @@\n-        private synchronized void update() {\n-            if (colorSchemeOverride != null) {\n-                set(colorSchemeOverride);\n-            } else {\n-                Color background = backgroundColor.get();\n-                Color foreground = foregroundColor.get();\n-                boolean isDark = Utils.calculateBrightness(background) < Utils.calculateBrightness(foreground);\n-                set(isDark ? ColorScheme.DARK : ColorScheme.LIGHT);\n+        public void setValueOverride(ColorScheme colorScheme) {\n+            synchronized (mutex) {\n+                colorSchemeOverride = colorScheme;\n+                update();\n@@ -288,59 +296,11 @@\n-        @Override\n-        public synchronized ReadOnlyObjectProperty<ColorScheme> getReadOnlyProperty() {\n-            return super.getReadOnlyProperty();\n-        }\n-\n-        @Override\n-        public synchronized ColorScheme get() {\n-            return super.get();\n-        }\n-\n-        @Override\n-        protected synchronized void fireValueChangedEvent() {\n-            super.fireValueChangedEvent();\n-        }\n-\n-        @Override\n-        public synchronized void addListener(ChangeListener<? super ColorScheme> listener) {\n-            super.addListener(listener);\n-        }\n-\n-        @Override\n-        public synchronized void removeListener(ChangeListener<? super ColorScheme> listener) {\n-            super.removeListener(listener);\n-        }\n-\n-        @Override\n-        public synchronized void addListener(InvalidationListener listener) {\n-            super.addListener(listener);\n-        }\n-\n-        @Override\n-        public synchronized void removeListener(InvalidationListener listener) {\n-            super.removeListener(listener);\n-        }\n-    }\n-\n-    private static class ReadOnlyBooleanPropertyImpl extends ReadOnlyBooleanWrapper {\n-        ReadOnlyBooleanPropertyImpl(Object bean, String name) {\n-            super(bean, name);\n-        }\n-\n-        @Override\n-        public synchronized ReadOnlyBooleanProperty getReadOnlyProperty() {\n-            return super.getReadOnlyProperty();\n-        }\n-\n-        @Override\n-        public synchronized boolean get() {\n-            return super.get();\n-        }\n-\n-        @Override\n-        protected synchronized void fireValueChangedEvent() {\n-            super.fireValueChangedEvent();\n-        }\n-\n-        @Override\n-        public synchronized void addListener(ChangeListener<? super Boolean> listener) {\n-            super.addListener(listener);\n+        public void update() {\n+            synchronized (mutex) {\n+                if (colorSchemeOverride != null) {\n+                    super.set(colorSchemeOverride);\n+                } else {\n+                    Color background = backgroundColor.get();\n+                    Color foreground = foregroundColor.get();\n+                    boolean isDark = Utils.calculateBrightness(background) < Utils.calculateBrightness(foreground);\n+                    super.set(isDark ? ColorScheme.DARK : ColorScheme.LIGHT);\n+                }\n+            }\n@@ -350,2 +310,4 @@\n-        public synchronized void removeListener(ChangeListener<? super Boolean> listener) {\n-            super.removeListener(listener);\n+        public ReadOnlyObjectProperty<ColorScheme> getReadOnlyProperty() {\n+            synchronized (mutex) {\n+                return super.getReadOnlyProperty();\n+            }\n@@ -355,2 +317,4 @@\n-        public synchronized void addListener(InvalidationListener listener) {\n-            super.addListener(listener);\n+        public ColorScheme get() {\n+            synchronized (mutex) {\n+                return super.get();\n+            }\n@@ -360,2 +324,3 @@\n-        public synchronized void removeListener(InvalidationListener listener) {\n-            super.removeListener(listener);\n+        public void set(ColorScheme newValue) {\n+            \/\/ Make sure that we only set the value in the update() method.\n+            throw new UnsupportedOperationException();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/application\/preferences\/PreferenceProperties.java","additions":69,"deletions":104,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    private final WeakChangeListener<T> weakListener = new WeakChangeListener<>(listener);\n@@ -60,1 +61,16 @@\n-        baseObservable.addListener(new WeakChangeListener<>(listener));\n+    }\n+\n+    \/**\n+     * Connects this property to the base observable and starts observing.\n+     *\/\n+    public final void connect() {\n+        baseObservable.addListener(weakListener);\n+        invalidated();\n+        fireValueChangedEvent();\n+    }\n+\n+    \/**\n+     * Disconnects this property from the base observable and stops observing.\n+     *\/\n+    public final void disconnect() {\n+        baseObservable.removeListener(weakListener);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/beans\/property\/NullCoalescingPropertyBase.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.List;\n@@ -36,0 +37,1 @@\n+import javafx.stage.Window;\n@@ -43,0 +45,5 @@\n+\n+        scene.windowProperty()\n+            .flatMap(Window::showingProperty)\n+            .orElse(false)\n+            .subscribe(this::onShowingChanged);\n@@ -45,1 +52,1 @@\n-    private final ObjectProperty<ColorScheme> colorScheme = new MediaProperty<>(\n+    private final MediaProperty<ColorScheme> colorScheme = new MediaProperty<>(\n@@ -63,1 +70,1 @@\n-    private final ObjectProperty<Boolean> persistentScrollBars = new MediaProperty<>(\n+    private final MediaProperty<Boolean> persistentScrollBars = new MediaProperty<>(\n@@ -81,1 +88,1 @@\n-    private final ObjectProperty<Boolean> reducedMotion = new MediaProperty<>(\n+    private final MediaProperty<Boolean> reducedMotion = new MediaProperty<>(\n@@ -99,1 +106,1 @@\n-    private final ObjectProperty<Boolean> reducedTransparency = new MediaProperty<>(\n+    private final MediaProperty<Boolean> reducedTransparency = new MediaProperty<>(\n@@ -117,1 +124,1 @@\n-    private final ObjectProperty<Boolean> reducedData = new MediaProperty<>(\n+    private final MediaProperty<Boolean> reducedData = new MediaProperty<>(\n@@ -135,0 +142,11 @@\n+    private void onShowingChanged(Boolean showing) {\n+        for (var property : List.of(colorScheme, persistentScrollBars, reducedData,\n+                                    reducedMotion, reducedTransparency)) {\n+            if (showing) {\n+                property.connect();\n+            } else {\n+                property.disconnect();\n+            }\n+        }\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/ScenePreferences.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        var property = new NullCoalescingPropertyImpl<>(base);\n+        var property = new NullCoalescingPropertyImpl<>(base, true);\n@@ -51,1 +51,1 @@\n-        var property = new NullCoalescingPropertyImpl<>(base);\n+        var property = new NullCoalescingPropertyImpl<>(base, true);\n@@ -60,1 +60,1 @@\n-        var property = new NullCoalescingPropertyImpl<>(base);\n+        var property = new NullCoalescingPropertyImpl<>(base, true);\n@@ -70,2 +70,2 @@\n-        var property1 = new NullCoalescingPropertyImpl<>(base);\n-        var property2 = new NullCoalescingPropertyImpl<>(property1);\n+        var property1 = new NullCoalescingPropertyImpl<>(base, true);\n+        var property2 = new NullCoalescingPropertyImpl<>(property1, true);\n@@ -86,1 +86,1 @@\n-        var property = new NullCoalescingPropertyImpl<>(base);\n+        var property = new NullCoalescingPropertyImpl<>(base, true);\n@@ -100,1 +100,1 @@\n-        var property = new NullCoalescingPropertyImpl<>(base);\n+        var property = new NullCoalescingPropertyImpl<>(base, true);\n@@ -113,1 +113,1 @@\n-        var property = new NullCoalescingPropertyImpl<>(base) {\n+        var property = new NullCoalescingPropertyImpl<>(base, true) {\n@@ -135,1 +135,1 @@\n-        var property = new NullCoalescingPropertyImpl<>(base) {\n+        var property = new NullCoalescingPropertyImpl<>(base, true) {\n@@ -161,0 +161,35 @@\n+    @Test\n+    void baseChangedNotificationsAreNotFiredWhenPropertyIsDisconnected() {\n+        var invalidatedCount = new int[1];\n+        var base = new SimpleStringProperty();\n+        var property = new NullCoalescingPropertyImpl<>(base, false) {\n+            @Override\n+            protected void onInvalidated() {\n+                invalidatedCount[0]++;\n+            }\n+        };\n+\n+        base.set(\"foo\");\n+        assertEquals(0, invalidatedCount[0]);\n+\n+        base.set(\"bar\");\n+        assertEquals(0, invalidatedCount[0]);\n+\n+        property.connect();\n+        assertEquals(1, invalidatedCount[0]);\n+\n+        base.set(\"baz\");\n+        assertEquals(2, invalidatedCount[0]);\n+    }\n+\n+    @Test\n+    void connectingPropertyUpdatesCurrentValue() {\n+        var base = new SimpleStringProperty(\"foo\");\n+        var property = new NullCoalescingPropertyImpl<>(base, false);\n+        assertEquals(\"foo\", property.getValue());\n+        base.set(\"bar\");\n+        assertEquals(\"foo\", property.getValue());\n+        property.connect();\n+        assertEquals(\"bar\", property.getValue());\n+    }\n+\n@@ -162,1 +197,1 @@\n-        public NullCoalescingPropertyImpl(ObservableValue<T> baseValue) {\n+        public NullCoalescingPropertyImpl(ObservableValue<T> baseValue, boolean connected) {\n@@ -164,0 +199,4 @@\n+\n+            if (connected) {\n+                connect();\n+            }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/beans\/property\/NullCoalescingPropertyBaseTest.java","additions":49,"deletions":10,"binary":false,"changes":59,"status":"modified"}]}