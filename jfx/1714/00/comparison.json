{"files":[{"patch":"@@ -94,0 +94,14 @@\n+    \/**\n+     * Provides an immutable list of CSS meta data that a parent may contribute\n+     * to any of its direct children.\n+     * <p>\n+     * Note: this method does not provide CSS meta data for <b>this<\/b> Styleable,\n+     * only for its direct children!\n+     *\n+     * @return an immutable list of CSS meta data, never {@code null}\n+     * @since 25\n+     *\/\n+    default List<CssMetaData<Styleable, ?>> getChildCssMetaData() {\n+        return List.of();\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/Styleable.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -67,3 +67,8 @@\n-     * This method is called from CSS code to set the value of the property.\n-     * @param origin the origin\n-     * @param value the value\n+     * Applies a value to this property and track its origin. This allows for\n+     * selectively overriding properties depending on origin priority.\n+     * <p>\n+     * Note: the provided origin can be {@code null}, indicating that the value is\n+     * being reset to its default, and was not specifically set for any origin.\n+     *\n+     * @param origin the origin, can be {@code null}\n+     * @param value the value, can be {@code null}\n@@ -74,3 +79,7 @@\n-     * Tells the origin of the value of the property. This is needed to\n-     * determine whether or not CSS can override the value.\n-     * @return the style origin\n+     * Returns the origin of the value of the property. This is used by the\n+     * CSS engine to determine when values can be overridden.\n+     * <p>\n+     * Note: the returned origin can be {@code null}, indicating that this value\n+     * was never set for any origin, or was reset to this state.\n+     *\n+     * @return the style origin, can be {@code null}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/StyleableProperty.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -150,1 +150,2 @@\n-            final List<CssMetaData<? extends Styleable, ?>> props = node.getCssMetaData();\n+            \/\/ Contextual properties are not checked here as they don't support inheritance\n+            List<CssMetaData<Styleable, ?>> props = getCssMetaData(node);\n@@ -152,2 +153,2 @@\n-            final int pMax = props != null ? props.size() : 0;\n-            for (int p=0; p<pMax; p++) {\n+            for (int p = 0, max = props.size(); p < max; p++) {\n+                CssMetaData<Styleable, ?> prop = props.get(p);\n@@ -155,1 +156,0 @@\n-                final CssMetaData<? extends Styleable, ?> prop = props.get(p);\n@@ -409,4 +409,5 @@\n-            final List<CssMetaData<? extends Styleable, ?>> props = node.getCssMetaData();\n-            final int pMax = props != null ? props.size() : 0;\n-            for (int p=0; p<pMax; p++) {\n-                final CssMetaData<? extends Styleable, ?> prop = props.get(p);\n+            \/\/ Contextual properties are not checked here as -fx-font is not allowed to be one\n+            List<CssMetaData<Styleable, ?>> props = getCssMetaData(node);\n+\n+            for (int p = 0, max = props.size(); p < max; p++) {\n+                final CssMetaData<Styleable, ?> prop = props.get(p);\n@@ -464,0 +465,2 @@\n+    private record StylingContext(Node node, CalculatedValue font, StyleMap styleMap, Set<PseudoClass> pseudoClasses) {}\n+\n@@ -637,0 +640,1 @@\n+        StylingContext context = new StylingContext(node, cachedFont, styleMap, transitionStates[0]);\n@@ -638,1 +642,2 @@\n-        final List<CssMetaData<? extends Styleable,  ?>> styleables = node.getCssMetaData();\n+        \/\/ Contextual properties are not checked here as they don't support relative values (for now)\n+        final List<CssMetaData<Styleable, ?>> styleables = getCssMetaData(node);\n@@ -693,2 +698,1 @@\n-            CalculatedValue calculatedValue = lookup(node, cssMetaData, styleMap, transitionStates[0],\n-                        node, cachedFont);\n+            CalculatedValue calculatedValue = lookup(context, node, cssMetaData, node);\n@@ -812,2 +816,1 @@\n-        \/\/ if the cacheEntry already exists, take the fastpath\n-        final boolean fastpath = cacheEntry != null;\n+        final boolean cachePresent = cacheEntry != null;\n@@ -820,1 +823,2 @@\n-        final List<CssMetaData<? extends Styleable,  ?>> styleables = node.getCssMetaData();\n+        final List<CssMetaData<Styleable, ?>> styleables = getCssMetaData(node);\n+        final List<CssMetaData<Styleable, ?>> contextualStyleables = getParentContextualCssMetaData(node);\n@@ -822,2 +826,2 @@\n-        \/\/ Used in the for loop below, and a convenient place to stop when debugging.\n-        final int max = styleables.size();\n+        StylingContext context = new StylingContext(node, cachedFont, styleMap, transitionStates[0]);\n+        boolean forceSlowPath = cacheContainer.forceSlowpath;\n@@ -825,1 +829,0 @@\n-        final boolean isForceSlowpath = cacheContainer.forceSlowpath;\n@@ -832,7 +835,25 @@\n-        for (int n = -1; n < max; n++) {\n-            \/\/ The 'transition' property is a special pseudo-property that is always processed\n-            \/\/ before other CSS properties, as its value might affect the transitions that are\n-            \/\/ applied to other properties.\n-            final CssMetaData<Styleable, ?> cssMetaData = n < 0 ?\n-                    (CssMetaData<Styleable, ?>)(CssMetaData<?, ?>)TransitionDefinitionCssMetaData.getInstance() :\n-                    (CssMetaData<Styleable, ?>)styleables.get(n);\n+        \/\/ The StyleCacheEntry (cache), when filled, holds previously calculated values\n+        \/\/ for each property. Missing values in this cache indicate no style affected\n+        \/\/ the value and should lead to a reset of the property to its previous value.\n+        \/\/\n+        \/\/ If there was no cache present, then a new cache is created which will have\n+        \/\/ all values missing (null). In that case the missing values cannot be assumed\n+        \/\/ to indicate that no style affected the property; they must still be calculated\n+        \/\/ first.\n+        \/\/\n+        \/\/ The variable forceSlowPath (JDK-8116341) indicates that the style helper was\n+        \/\/ reused. If true any missing (null) values in the cache should be re-evaluated,\n+        \/\/ but any present values or SKIP values should be handled normally.\n+        \/\/\n+        \/\/ This culminates into a single flag, which controls whether missing values\n+        \/\/ should be either recalculated and added, or lead to the property being reset\n+        \/\/ to its previous value.\n+        \/\/\n+        \/\/ | cachePresent | forceSlowPath | calculateMissingValues |\n+        \/\/ |--------------|---------------|------------------------|\n+        \/\/ |     false    |     false     |          true          |\n+        \/\/ |     true     |     false     |          false         |\n+        \/\/ |     false    |     true      |          true          |\n+        \/\/ |     true     |     true      |          true          |\n+        \/\/\n+        final boolean calculateMissingValues = forceSlowPath || !cachePresent;\n@@ -840,4 +861,8 @@\n-            \/\/ Don't bother looking up styles that don't inherit.\n-            if (inheritOnly && cssMetaData.isInherits() == false) {\n-                continue;\n-            }\n+        \/\/ The 'transition' property is a special pseudo-property that is always processed\n+        \/\/ before other CSS properties, as its value might affect the transitions that are\n+        \/\/ applied to other properties.\n+        applyStyle(\n+            context,\n+            (CssMetaData<Styleable, ?>)(CssMetaData<?, ?>)TransitionDefinitionCssMetaData.getInstance(),\n+            cacheEntry, calculateMissingValues, inheritOnly\n+        );\n@@ -845,3 +870,3 @@\n-            \/\/ Skip the lookup if we know there isn't a chance for this property\n-            \/\/ to be set (usually due to a \"bind\").\n-            if (!cssMetaData.isSettable(node)) continue;\n+        for (int n = 0, max = styleables.size(); n < max; n++) {\n+            applyStyle(context, styleables.get(n), cacheEntry, calculateMissingValues, inheritOnly);\n+        }\n@@ -849,1 +874,3 @@\n-            final String property = cssMetaData.getProperty();\n+        for (int n = 0, max = contextualStyleables.size(); n < max; n++) {\n+            applyStyle(context, contextualStyleables.get(n), cacheEntry, calculateMissingValues, inheritOnly);\n+        }\n@@ -851,1 +878,2 @@\n-            CalculatedValue calculatedValue = cacheEntry.get(property);\n+        transitionStateInProgress = false;\n+    }\n@@ -853,4 +881,41 @@\n-            \/\/ If there is no calculatedValue and we're on the fast path,\n-            \/\/ take the slow path if cssFlags is REAPPLY (JDK-8116341)\n-            final boolean forceSlowpath =\n-                    fastpath && calculatedValue == null && isForceSlowpath;\n+    \/**\n+     * This method will update a single property according to the looked up calculated value\n+     * based on its styles. If there is no value to apply, its previous value and style origin\n+     * will be restored. If the style origin of the calculated value has lower precedence\n+     * than its current value, then the property will be left untouched.\n+     * <p>\n+     * This method has two primary code paths. A path where it will recalculate the\n+     * value and update the cache if the cache returned a {@code null} ({@code calculateMissingValues} is\n+     * {@code true}), and a path where the cache is known to be correct, in which case\n+     * a returned {@code null} from the cache results in the property to be restored\n+     * to its previous value.\n+     * <p>\n+     * Note: the supplied {@code cacheEntry} is shared among all nodes at the same\n+     * level in the hierarchy (often siblings) that have the same styles and pseudo class\n+     * state for themselves and all its ancestors. A calculated value, even if not applicable\n+     * to the current node (due to a binding or user-set value) must still be cached for\n+     * other compatible nodes. Likewise, setting a cache value to SKIP will affect\n+     * all compatible nodes -- this may be a bug in the current implementation.\n+     *\n+     * @param context a styling context, cannot be {@code null}\n+     * @param cssMetaData a CSS meta data holder identifying the property, cannot be {@code null}\n+     * @param cacheEntry a shared style cache entry, cannot be {@code null}\n+     * @param calculateMissingValues {@code true} to indicate missing values should be calculated and\n+     *     added to the cache, or {@code false} to indicate values should only be applied (or\n+     *     restored if they were missing from the cache)\n+     * @param processInheritedStylesOnly {@code true} to only process inherited styles, otherwise\n+     *     {@code false}; this is useful when no styles are applied to this node and so only\n+     *     inherited styles could possibly affect it\n+     * @throws NullPointerException when any argument is {@code null}\n+     *\/\n+    private void applyStyle(\n+        final StylingContext context,\n+        final CssMetaData<Styleable, ?> cssMetaData,\n+        final StyleCacheEntry cacheEntry,\n+        final boolean calculateMissingValues,\n+        final boolean processInheritedStylesOnly\n+    ) {\n+        \/\/ Don't bother looking up styles that don't inherit IF processInheritedStylesOnly was set.\n+        if (processInheritedStylesOnly && cssMetaData.isInherits() == false) {\n+            return;\n+        }\n@@ -858,2 +923,1 @@\n-            final boolean addToCache =\n-                    (!fastpath && calculatedValue == null) || forceSlowpath;\n+        Node node = context.node;\n@@ -861,1 +925,3 @@\n-            if (fastpath && !forceSlowpath) {\n+        \/\/ Skip the lookup if we know there isn't a change for this property\n+        \/\/ to be set (usually due to a \"bind\").\n+        if (!cssMetaData.isSettable(node)) return;\n@@ -863,5 +929,1 @@\n-                \/\/ If the cache contains SKIP, then there was an\n-                \/\/ exception thrown from applyStyle\n-                if (calculatedValue == SKIP) {\n-                    continue;\n-                }\n+        final String property = cssMetaData.getProperty();\n@@ -869,1 +931,13 @@\n-            } else if (calculatedValue == null) {\n+        \/\/ This can return either:\n+        \/\/ - CalculatedValue -- previously calculated by this method via lookup()\n+        \/\/ - SKIP -- indicates applying the value was attempted before, but failed due to an exception\n+        \/\/ - null -- indicates it was not cached yet OR there was no value found previously\n+        \/\/ How the last case is to be interpreted depends on the calculateMissingValues parameter.\n+        CalculatedValue calculatedValue = cacheEntry.get(property);\n+\n+        \/\/ This is correct in all cases. In the case where styles need to be calculated\n+        \/\/ because there was no cache, the provided cache will contain only nulls. In the case\n+        \/\/ there already was a cache, then SKIP should always skip updating the property.\n+        if (calculatedValue == SKIP) {\n+            return;\n+        }\n@@ -871,3 +945,1 @@\n-                \/\/ slowpath!\n-                calculatedValue = lookup(node, cssMetaData, styleMap, transitionStates[0],\n-                        node, cachedFont);\n+        final boolean fillCache = calculatedValue == null && calculateMissingValues;\n@@ -875,5 +947,3 @@\n-                \/\/ lookup is not supposed to return null.\n-                if (calculatedValue == null) {\n-                    assert false : \"lookup returned null for \" + property;\n-                    continue;\n-                }\n+        if (fillCache) {  \/\/ This would be the \"slow\" path\n+            calculatedValue = lookup(context, node, cssMetaData, node);\n+        }\n@@ -881,1 +951,3 @@\n-            }\n+        \/\/ StyleableProperty#applyStyle might throw an exception and it is called\n+        \/\/ from two places in this try block.\n+        try {\n@@ -883,3 +955,8 @@\n-            \/\/ StyleableProperty#applyStyle might throw an exception and it is called\n-            \/\/ from two places in this try block.\n-            try {\n+            \/\/\n+            \/\/ JDK-8127435\n+            \/\/ If the current value of the property was set by CSS\n+            \/\/ and there is no style for the property, then reset this\n+            \/\/ property to its initial value. If it was not set by CSS\n+            \/\/ then leave the property alone.\n+            \/\/\n+            if (calculatedValue == null || calculatedValue == SKIP) {\n@@ -887,27 +964,17 @@\n-                \/\/\n-                \/\/ JDK-8127435\n-                \/\/ If the current value of the property was set by CSS\n-                \/\/ and there is no style for the property, then reset this\n-                \/\/ property to its initial value. If it was not set by CSS\n-                \/\/ then leave the property alone.\n-                \/\/\n-                if (calculatedValue == null || calculatedValue == SKIP) {\n-\n-                    \/\/ cssSetProperties keeps track of the StyleableProperty's that were set by CSS in the previous state.\n-                    \/\/ If this property is not in cssSetProperties map, then the property was not set in the previous state.\n-                    \/\/ This accomplishes two things. First, it lets us know if the property was set in the previous state\n-                    \/\/ so it can be reset in this state if there is no value for it. Second, it calling\n-                    \/\/ CssMetaData#getStyleableProperty which is rather expensive as it may cause expansion of lazy\n-                    \/\/ properties.\n-                    CalculatedValue initialValue = cacheContainer.cssSetProperties.get(cssMetaData);\n-\n-                    \/\/ if the current value was set by CSS and there\n-                    \/\/ is no calculated value for the property, then\n-                    \/\/ there was no style for the property in the current\n-                    \/\/ state, so reset the property to its initial value.\n-                    if (initialValue != null) {\n-\n-                        StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);\n-                        if (styleableProperty.getStyleOrigin() != StyleOrigin.USER) {\n-                            styleableProperty.applyStyle(initialValue.getOrigin(), initialValue.getValue());\n-                        }\n+                \/\/ cssSetProperties keeps track of the StyleableProperty's that were set by CSS in the previous state.\n+                \/\/ If this property is not in cssSetProperties map, then the property was not set in the previous state.\n+                \/\/ This accomplishes two things. First, it lets us know if the property was set in the previous state\n+                \/\/ so it can be reset in this state if there is no value for it. Second, it avoids calling\n+                \/\/ CssMetaData#getStyleableProperty which is rather expensive as it may cause expansion of lazy\n+                \/\/ properties.\n+                CalculatedValue initialValue = cacheContainer.cssSetProperties.get(cssMetaData);\n+\n+                \/\/ if the current value was set by CSS and there\n+                \/\/ is no calculated value for the property, then\n+                \/\/ there was no style for the property in the current\n+                \/\/ state, so reset the property to its initial value.\n+                if (initialValue != null) {\n+\n+                    StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);\n+                    if (styleableProperty.getStyleOrigin() != StyleOrigin.USER) {\n+                        styleableProperty.applyStyle(initialValue.getOrigin(), initialValue.getValue());\n@@ -915,0 +982,1 @@\n+                }\n@@ -916,1 +984,1 @@\n-                    continue;\n+                return;\n@@ -918,1 +986,1 @@\n-                }\n+            }\n@@ -920,1 +988,1 @@\n-                if (addToCache) {\n+            if (fillCache) {\n@@ -922,4 +990,4 @@\n-                    \/\/ If we're not on the fastpath, then add the calculated\n-                    \/\/ value to cache.\n-                    cacheEntry.put(property, calculatedValue);\n-                }\n+                \/\/ If we're not on the fastpath, then add the calculated\n+                \/\/ value to cache.\n+                cacheEntry.put(property, calculatedValue);\n+            }\n@@ -927,1 +995,1 @@\n-                StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);\n+            StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);\n@@ -929,2 +997,2 @@\n-                \/\/ need to know who set the current value - CSS, the user, or init\n-                final StyleOrigin originOfCurrentValue = styleableProperty.getStyleOrigin();\n+            \/\/ need to know who set the current value - CSS, the user, or init\n+            final StyleOrigin originOfCurrentValue = styleableProperty.getStyleOrigin();\n@@ -933,11 +1001,11 @@\n-                \/\/ JDK-8110994:\n-                \/\/ If the user set the property and there is a style and\n-                \/\/ the style came from the user agent stylesheet, then\n-                \/\/ skip the value. A style from a user agent stylesheet should\n-                \/\/ not override the user set style.\n-                \/\/\n-                \/\/ Note: this check should be after the value was added to the cache\n-                \/\/ as the cache is shared between all properties with the same pseudo states,\n-                \/\/ and not all of the nodes will have the property set manually.\n-                \/\/\n-                final StyleOrigin originOfCalculatedValue = calculatedValue.getOrigin();\n+            \/\/ JDK-8110994:\n+            \/\/ If the user set the property and there is a style and\n+            \/\/ the style came from the user agent stylesheet, then\n+            \/\/ skip the value. A style from a user agent stylesheet should\n+            \/\/ not override the user set style.\n+            \/\/\n+            \/\/ Note: this check should be after the value was added to the cache\n+            \/\/ as the cache is shared between all properties with the same pseudo states,\n+            \/\/ and not all of the nodes will have the property set manually.\n+            \/\/\n+            final StyleOrigin originOfCalculatedValue = calculatedValue.getOrigin();\n@@ -945,6 +1013,6 @@\n-                \/\/ A calculated value should never have a null style origin since that would\n-                \/\/ imply the style didn't come from a stylesheet or in-line style.\n-                if (originOfCalculatedValue == null) {\n-                    assert false : styleableProperty.toString();\n-                    continue;\n-                }\n+            \/\/ A calculated value should never have a null style origin since that would\n+            \/\/ imply the style didn't come from a stylesheet or in-line style.\n+            if (originOfCalculatedValue == null) {\n+                assert false : styleableProperty.toString();\n+                return;\n+            }\n@@ -952,4 +1020,3 @@\n-                if (originOfCurrentValue == StyleOrigin.USER) {\n-                    if (originOfCalculatedValue == StyleOrigin.USER_AGENT) {\n-                        continue;\n-                    }\n+            if (originOfCurrentValue == StyleOrigin.USER) {\n+                if (originOfCalculatedValue == StyleOrigin.USER_AGENT) {\n+                    return;\n@@ -957,0 +1024,1 @@\n+            }\n@@ -958,2 +1026,2 @@\n-                final Object value = calculatedValue.getValue();\n-                final Object currentValue = styleableProperty.getValue();\n+            final Object value = calculatedValue.getValue();\n+            final Object currentValue = styleableProperty.getValue();\n@@ -961,5 +1029,5 @@\n-                \/\/ JDK-8102176: Only apply the style if something has changed.\n-                if ((originOfCurrentValue != originOfCalculatedValue)\n-                        || (currentValue != null\n-                        ? currentValue.equals(value) == false\n-                        : value != null)) {\n+            \/\/ JDK-8102176: Only apply the style if something has changed.\n+            if ((originOfCurrentValue != originOfCalculatedValue)\n+                    || (currentValue != null\n+                    ? currentValue.equals(value) == false\n+                    : value != null)) {\n@@ -967,6 +1035,4 @@\n-                    if (LOGGER.isLoggable(Level.FINER)) {\n-                        LOGGER.finer(property + \", call applyStyle: \" + styleableProperty + \", value =\" +\n-                                String.valueOf(value) + \", originOfCalculatedValue=\" + originOfCalculatedValue);\n-                    }\n-\n-                    styleableProperty.applyStyle(originOfCalculatedValue, value);\n+                if (LOGGER.isLoggable(Level.FINER)) {\n+                    LOGGER.finer(property + \", call applyStyle: \" + styleableProperty + \", value =\" +\n+                            String.valueOf(value) + \", originOfCalculatedValue=\" + originOfCalculatedValue);\n+                }\n@@ -974,5 +1040,1 @@\n-                    if (cacheContainer.cssSetProperties.containsKey(cssMetaData) == false) {\n-                        \/\/ track this property\n-                        CalculatedValue initialValue = new CalculatedValue(currentValue, originOfCurrentValue, false);\n-                        cacheContainer.cssSetProperties.put(cssMetaData, initialValue);\n-                    }\n+                styleableProperty.applyStyle(originOfCalculatedValue, value);\n@@ -980,0 +1042,4 @@\n+                if (cacheContainer.cssSetProperties.containsKey(cssMetaData) == false) {\n+                    \/\/ track this property\n+                    CalculatedValue initialValue = new CalculatedValue(currentValue, originOfCurrentValue, false);\n+                    cacheContainer.cssSetProperties.put(cssMetaData, initialValue);\n@@ -982,1 +1048,1 @@\n-            } catch (Exception e) {\n+            }\n@@ -984,1 +1050,1 @@\n-                StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);\n+        } catch (Exception e) {\n@@ -986,2 +1052,1 @@\n-                final String msg = String.format(\"Failed to set css [%s] on [%s] due to '%s'\\n\",\n-                        cssMetaData.getProperty(), styleableProperty, e.getMessage());\n+            StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);\n@@ -989,5 +1054,2 @@\n-                List<CssParser.ParseError> errors = null;\n-                if ((errors = StyleManager.getErrors()) != null) {\n-                    final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, node, msg);\n-                    errors.add(error);\n-                }\n+            final String msg = String.format(\"Failed to set css [%s] on [%s] due to '%s'\\n\",\n+                    cssMetaData.getProperty(), styleableProperty, e.getMessage());\n@@ -995,4 +1057,5 @@\n-                PlatformLogger logger = Logging.getCSSLogger();\n-                if (logger.isLoggable(Level.WARNING)) {\n-                    logger.warning(msg);\n-                }\n+            List<CssParser.ParseError> errors = null;\n+            if ((errors = StyleManager.getErrors()) != null) {\n+                final CssParser.ParseError error = new CssParser.ParseError.PropertySetError(cssMetaData, node, msg);\n+                errors.add(error);\n+            }\n@@ -1000,3 +1063,4 @@\n-                \/\/ JDK-8125956: if setting value raises exception, reset value\n-                \/\/ the value to initial and thereafter skip setting the property\n-                cacheEntry.put(property, SKIP);\n+            PlatformLogger logger = Logging.getCSSLogger();\n+            if (logger.isLoggable(Level.WARNING)) {\n+                logger.warning(msg);\n+            }\n@@ -1004,15 +1068,2 @@\n-                CalculatedValue cachedValue = null;\n-                if (cacheContainer != null && cacheContainer.cssSetProperties != null) {\n-                    cachedValue = cacheContainer.cssSetProperties.get(cssMetaData);\n-                }\n-                Object value = (cachedValue != null) ? cachedValue.getValue() : cssMetaData.getInitialValue(node);\n-                StyleOrigin origin = (cachedValue != null) ? cachedValue.getOrigin() : null;\n-                try {\n-                    styleableProperty.applyStyle(origin, value);\n-                } catch (Exception ebad) {\n-                    \/\/ This would be bad.\n-                    if (logger.isLoggable(Level.SEVERE)) {\n-                        logger.severe(String.format(\"Could not reset [%s] on [%s] due to %s\\n\" ,\n-                                cssMetaData.getProperty(), styleableProperty, e.getMessage()));\n-                    }\n-                }\n+            \/\/ (!!!) Cache entries are shared, setting it to skip means other nodes sharing\n+            \/\/ the same entry will also skip setting this property...\n@@ -1020,0 +1071,18 @@\n+            \/\/ JDK-8125956: if setting value raises exception, reset value\n+            \/\/ the value to initial and thereafter skip setting the property\n+            cacheEntry.put(property, SKIP);\n+\n+            CalculatedValue cachedValue = null;\n+            if (cacheContainer != null && cacheContainer.cssSetProperties != null) {\n+                cachedValue = cacheContainer.cssSetProperties.get(cssMetaData);\n+            }\n+            Object value = (cachedValue != null) ? cachedValue.getValue() : cssMetaData.getInitialValue(node);\n+            StyleOrigin origin = (cachedValue != null) ? cachedValue.getOrigin() : null;\n+            try {\n+                styleableProperty.applyStyle(origin, value);\n+            } catch (Exception ebad) {\n+                \/\/ This would be bad.\n+                if (logger.isLoggable(Level.SEVERE)) {\n+                    logger.severe(String.format(\"Could not reset [%s] on [%s] due to %s\\n\" ,\n+                            cssMetaData.getProperty(), styleableProperty, e.getMessage()));\n+                }\n@@ -1023,1 +1092,0 @@\n-        transitionStateInProgress = false;\n@@ -1075,3 +1143,1 @@\n-     *\n-     *\n-     *\n+     * @param context a {@link StylingContext}, cannot be {@code null}\n@@ -1079,1 +1145,1 @@\n-     * @param states\n+     * @param cssMetaData\n@@ -1081,1 +1147,1 @@\n-     * @return\n+     * @return a CalculatedValue, never {@code null}, but can be the placeholder SKIP\n@@ -1083,1 +1149,2 @@\n-    private CalculatedValue lookup(final Styleable styleable,\n+    private CalculatedValue lookup(final StylingContext context,\n+                                   final Styleable styleable,\n@@ -1085,4 +1152,1 @@\n-                                   final StyleMap styleMap,\n-                                   final Set<PseudoClass> states,\n-                                   final Styleable originatingStyleable,\n-                                   final CalculatedValue cachedFont) {\n+                                   final Styleable originatingStyleable) {\n@@ -1091,1 +1155,1 @@\n-            return lookupFont(styleable, cssMetaData.getProperty(), styleMap, cachedFont);\n+            return lookupFont(styleable, cssMetaData.getProperty(), context.styleMap, context.font);  \/\/ Verified not null\n@@ -1097,1 +1161,1 @@\n-        CascadingStyle style = getStyle(styleable, property, styleMap, states);\n+        CascadingStyle style = getStyle(styleable, property, context.styleMap, context.pseudoClasses);\n@@ -1109,2 +1173,1 @@\n-                return handleNoStyleFound(styleable, cssMetaData,\n-                        styleMap, states, originatingStyleable, cachedFont);\n+                return handleNoStyleFound(context, styleable, cssMetaData, originatingStyleable);  \/\/ Verified not null\n@@ -1132,2 +1195,1 @@\n-                        lookup(styleable, subkey, styleMap, states,\n-                                originatingStyleable, cachedFont);\n+                        lookup(context, styleable, subkey, originatingStyleable);\n@@ -1156,2 +1218,1 @@\n-                    return handleNoStyleFound(styleable, cssMetaData,\n-                            styleMap, states, originatingStyleable, cachedFont);\n+                    return handleNoStyleFound(context, styleable, cssMetaData, originatingStyleable);\n@@ -1202,2 +1263,2 @@\n-        return calculateValue(style, styleable, cssMetaData, styleMap, states,\n-                originatingStyleable, cachedFont);\n+        return calculateValue(style, styleable, cssMetaData, context.styleMap, context.pseudoClasses,\n+                originatingStyleable, context.font);  \/\/ Verified not null\n@@ -1209,1 +1270,2 @@\n-    private CalculatedValue handleNoStyleFound(final Styleable styleable,\n+    private CalculatedValue handleNoStyleFound(final StylingContext context,\n+                                               final Styleable styleable,\n@@ -1211,2 +1273,1 @@\n-                                               final StyleMap styleMap, Set<PseudoClass> pseudoClassStates, Styleable originatingStyleable,\n-                                               final CalculatedValue cachedFont) {\n+                                               final Styleable originatingStyleable) {\n@@ -1233,2 +1294,2 @@\n-                            styleMap, pseudoClassStates, originatingStyleable,\n-                                   cachedFont);\n+                            context.styleMap, context.pseudoClasses, originatingStyleable,\n+                                   context.font);  \/\/ Verified not null\n@@ -2179,1 +2240,2 @@\n-            for (CssMetaData metaData : node.getCssMetaData()) {\n+\n+            for (CssMetaData<Styleable, ?> metaData : getCssMetaData(node)) {\n@@ -2181,0 +2243,1 @@\n+\n@@ -2182,1 +2245,10 @@\n-                    StyleableProperty prop = metaData.getStyleableProperty(node);\n+                    StyleableProperty<?> prop = metaData.getStyleableProperty(node);\n+                    map.put(prop, styleList);\n+                }\n+            }\n+\n+            for (CssMetaData<Styleable, ?> metaData : getParentContextualCssMetaData(node)) {\n+                List<Style> styleList = helper.getMatchingStyles(node, metaData, true);\n+\n+                if (styleList != null && !styleList.isEmpty()) {\n+                    StyleableProperty<?> prop = metaData.getStyleableProperty(node);\n@@ -2352,0 +2424,12 @@\n+    static List<CssMetaData<Styleable, ?>> getCssMetaData(Node node) {\n+        @SuppressWarnings(\"unchecked\")  \/\/ Safe because first type parameter of CssMetaData is not used for modifications\n+        List<CssMetaData<Styleable, ?>> cssMetaData = (List<CssMetaData<Styleable, ?>>)(List<?>)node.getCssMetaData();\n+\n+        \/\/ Styleable interface doesn't specify that getCssMetaData should not be null, fix that here:\n+        return cssMetaData == null ? List.of() : cssMetaData;\n+    }\n+\n+    \/\/ Returns CSS properties that a node may have when in the context of a specific parent\n+    static List<CssMetaData<Styleable, ?>> getParentContextualCssMetaData(Node node) {\n+        return node.getParent() instanceof Node parent ? parent.getChildCssMetaData() : List.of();\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/CssStyleHelper.java","additions":277,"deletions":193,"binary":false,"changes":470,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import javafx.css.StyleConverter;\n@@ -164,2 +165,0 @@\n-    private static final String MARGIN_CONSTRAINT = \"hbox-margin\";\n-    private static final String HGROW_CONSTRAINT = \"hbox-hgrow\";\n@@ -181,1 +180,1 @@\n-        setConstraint(child, HGROW_CONSTRAINT, value);\n+        setChildConstraint(child, StyleableProperties.CHILD_HGROW, value);\n@@ -190,1 +189,1 @@\n-        return (Priority)getConstraint(child, HGROW_CONSTRAINT);\n+        return getChildConstraint(child, StyleableProperties.CHILD_HGROW);\n@@ -201,1 +200,1 @@\n-        setConstraint(child, MARGIN_CONSTRAINT, value);\n+        setChildConstraint(child, StyleableProperties.CHILD_MARGIN, value);\n@@ -210,1 +209,1 @@\n-        return (Insets)getConstraint(child, MARGIN_CONSTRAINT);\n+        return getChildConstraint(child, StyleableProperties.CHILD_MARGIN);\n@@ -743,0 +742,28 @@\n+\n+         private static final CssMetaData<Styleable, Priority> CHILD_HGROW = new CssMetaData<>(\"-fx-hbox-hgrow\", StyleConverter.getEnumConverter(Priority.class)) {\n+             @Override\n+             public boolean isSettable(Styleable styleable) {\n+                 return true;\n+             }\n+\n+             @Override\n+             public StyleableProperty<Priority> getStyleableProperty(Styleable styleable) {\n+                 return childConstraintProperty((Node)styleable, this);\n+             }\n+         };\n+\n+         private static final CssMetaData<Styleable, Insets> CHILD_MARGIN = new CssMetaData<>(\"-fx-hbox-margin\", StyleConverter.getInsetsConverter()) {\n+             @Override\n+             public boolean isSettable(Styleable styleable) {\n+                 return true;\n+             }\n+\n+             @Override\n+             public StyleableProperty<Insets> getStyleableProperty(Styleable styleable) {\n+                 return childConstraintProperty((Node)styleable, this);\n+             }\n+         };\n+\n+         private static final List<CssMetaData<Styleable, ?>> CHILD_STYLEABLES = List.of(\n+             CHILD_HGROW, CHILD_MARGIN\n+         );\n@@ -767,0 +794,4 @@\n+    @Override\n+    public List<CssMetaData<Styleable, ?>> getChildCssMetaData() {\n+        return StyleableProperties.CHILD_STYLEABLES;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HBox.java","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+\n+import java.util.Objects;\n+\n@@ -31,0 +34,4 @@\n+import javafx.css.CssMetaData;\n+import javafx.css.StyleOrigin;\n+import javafx.css.Styleable;\n+import javafx.css.StyleableObjectProperty;\n@@ -32,0 +39,1 @@\n+import javafx.scene.Parent;\n@@ -107,0 +115,130 @@\n+    \/**\n+     * Gets the property for a child constraint.\n+     *\n+     * @param <T> type of the constraint\n+     * @param child a child node, cannot be {@code null}\n+     * @param cssMetaData a CSS meta data instance, cannot be {@code null}\n+     * @throws NullPointerException when any argument is {@code null}\n+     *\/\n+    static <T> StyleableObjectProperty<T> childConstraintProperty(Node child, CssMetaData<Styleable, T> cssMetaData) {\n+        Objects.requireNonNull(cssMetaData, \"cssMetaData\");\n+\n+        @SuppressWarnings(\"unchecked\")\n+        StyleableObjectProperty<T> castProperty = (StyleableObjectProperty<T>) child.getProperties()\n+            .computeIfAbsent(cssMetaData, k -> createChildConstraintProperty(child, cssMetaData));\n+\n+        return castProperty;\n+    }\n+\n+    private static <T> StyleableObjectProperty<T> createChildConstraintProperty(Node node, CssMetaData<Styleable, T> cssMetaData) {\n+        String name = cssMetaData.getProperty();\n+\n+        if (name.startsWith(\"-fx-\")) {\n+            name = name.substring(4);\n+        }\n+\n+        String propertyName = name + \" (parent property)\";\n+\n+        return new StyleableObjectProperty<>() {\n+\n+            \/*\n+             * If in the future these properties are made available to the user,\n+             * consider carefully the life cycle surrounding bindings\/listeners\n+             * as these properties should only exist while its Node lives under\n+             * a specific Parent.\n+             *\/\n+\n+            @Override\n+            public void applyStyle(StyleOrigin origin, T newValue) {\n+                super.applyStyle(origin, newValue);\n+\n+                if (origin == null && Objects.equals(cssMetaData.getInitialValue(node), newValue)) {\n+\n+                    \/*\n+                     * The property was fully reset to its initial state. This happens when the\n+                     * property was set only by CSS, and the style that set it no longer applies.\n+                     * The CSS engine will restore the property to its initial value then,\n+                     * including setting origin to null.\n+                     *\n+                     * Note that users can't do this with the current API's; if a user sets a\n+                     * property to a value, the style origin will be USER, even if reset to\n+                     * its initial value. So in cases where the property was manually set the\n+                     * property will never be removed from the properties map.\n+                     *\/\n+\n+                    node.getProperties().remove(cssMetaData);\n+                }\n+            }\n+\n+            @Override\n+            public void invalidated() {\n+                if (node.getParent() instanceof Parent p) {\n+                    p.requestLayout();\n+                }\n+            }\n+\n+            @Override\n+            public CssMetaData<Styleable, T> getCssMetaData() {\n+                return cssMetaData;\n+            }\n+\n+            @Override\n+            public Object getBean() {\n+                return node;\n+            }\n+\n+            @Override\n+            public String getName() {\n+                return propertyName;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Set the value of a child constraint.\n+     *\n+     * @param <T> type of the constraint\n+     * @param child a child node, cannot be {@code null}\n+     * @param cssMetaData a CSS meta data instance, cannot be {@code null}\n+     * @param value a value to set, can be {@code null}\n+     * @throws NullPointerException when {@code node} or {@cssMetaData} is {@code null}\n+     *\/\n+    static <T> void setChildConstraint(Node child, CssMetaData<Styleable, T> cssMetaData, T value) {\n+        childConstraintProperty(child, cssMetaData).set(value);\n+    }\n+\n+    \/**\n+     * Get the value of a child constraint. If the constraint was unset, returns\n+     * a default value based on the initial value specified in the CSS meta data.\n+     *\n+     * @param <T> type of the constraint\n+     * @param child a child node, cannot be {@code null}\n+     * @param cssMetaData a CSS meta data instance, cannot be {@code null}\n+     * @return the current value of the child constraint, can be {@code null} if\n+     *     it was unset and the default value was {@code null}\n+     * @throws NullPointerException when any argument is {@code null}\n+     *\/\n+    static <T> T getChildConstraint(Node child, CssMetaData<Styleable, T> cssMetaData) {\n+        Objects.requireNonNull(cssMetaData, \"cssMetaData\");\n+\n+        if (child.hasProperties()) {  \/\/ implicit null check for child\n+            Object value = child.getProperties().get(cssMetaData);\n+\n+            if (value instanceof StyleableObjectProperty<?> p) {\n+                @SuppressWarnings(\"unchecked\")\n+                StyleableObjectProperty<T> castProperty = (StyleableObjectProperty<T>) p;\n+\n+                return castProperty.getValue();\n+            }\n+\n+            if (value != null) {\n+                @SuppressWarnings(\"unchecked\")\n+                T castValue = (T) value;\n+\n+                return castValue;\n+            }\n+        }\n+\n+        return cssMetaData.getInitialValue(child);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Pane.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import javafx.css.StyleConverter;\n@@ -153,2 +154,0 @@\n-    private static final String MARGIN_CONSTRAINT = \"vbox-margin\";\n-    private static final String VGROW_CONSTRAINT = \"vbox-vgrow\";\n@@ -170,1 +169,1 @@\n-        setConstraint(child, VGROW_CONSTRAINT, value);\n+        setChildConstraint(child, StyleableProperties.CHILD_VGROW, value);\n@@ -179,1 +178,1 @@\n-        return (Priority)getConstraint(child, VGROW_CONSTRAINT);\n+        return getChildConstraint(child, StyleableProperties.CHILD_VGROW);\n@@ -190,1 +189,1 @@\n-        setConstraint(child, MARGIN_CONSTRAINT, value);\n+        setChildConstraint(child, StyleableProperties.CHILD_MARGIN, value);\n@@ -199,1 +198,1 @@\n-        return (Insets)getConstraint(child, MARGIN_CONSTRAINT);\n+        return getChildConstraint(child, StyleableProperties.CHILD_MARGIN);\n@@ -663,0 +662,28 @@\n+\n+         private static final CssMetaData<Styleable, Priority> CHILD_VGROW = new CssMetaData<>(\"-fx-vbox-vgrow\", StyleConverter.getEnumConverter(Priority.class)) {\n+             @Override\n+             public boolean isSettable(Styleable styleable) {\n+                 return true;\n+             }\n+\n+             @Override\n+             public StyleableProperty<Priority> getStyleableProperty(Styleable styleable) {\n+                 return childConstraintProperty((Node)styleable, this);\n+             }\n+         };\n+\n+         private static final CssMetaData<Styleable, Insets> CHILD_MARGIN = new CssMetaData<>(\"-fx-vbox-margin\", StyleConverter.getInsetsConverter()) {\n+             @Override\n+             public boolean isSettable(Styleable styleable) {\n+                 return true;\n+             }\n+\n+             @Override\n+             public StyleableProperty<Insets> getStyleableProperty(Styleable styleable) {\n+                 return childConstraintProperty((Node)styleable, this);\n+             }\n+         };\n+\n+         private static final List<CssMetaData<Styleable, ?>> CHILD_STYLEABLES = List.of(\n+             CHILD_VGROW, CHILD_MARGIN\n+         );\n@@ -687,0 +714,4 @@\n+    @Override\n+    public List<CssMetaData<Styleable, ?>> getChildCssMetaData() {\n+        return StyleableProperties.CHILD_STYLEABLES;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/VBox.java","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"}]}