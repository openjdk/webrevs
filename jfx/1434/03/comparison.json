{"files":[{"patch":"@@ -42,1 +42,0 @@\n-import javafx.collections.FXCollections;\n@@ -79,0 +78,1 @@\n+import javafx.stage.WindowEvent;\n@@ -97,0 +97,6 @@\n+    \/**\n+     * The overflow logic needs properly calculated prefWidth(..)\/prefHeight(..) values.\n+     * These values are valid if the elements have been added to the scene and the CSS has been applied properly.\n+     * To ensure this, we add the overflow items to this pane if they are not currently visible in the overflow menu.\n+     *\/\n+    private Pane overflowBox;\n@@ -99,0 +105,1 @@\n+    private int overflowNodeIndex = Integer.MAX_VALUE;\n@@ -103,1 +110,0 @@\n-    private ObservableList<MenuItem> overflowMenuItems;\n@@ -130,1 +136,0 @@\n-        overflowMenuItems = FXCollections.observableArrayList();\n@@ -248,0 +253,1 @@\n+                    overflowBox.getChildren().remove(n);\n@@ -470,1 +476,1 @@\n-                correctOverflow(toolbarLength);\n+                organizeOverflow(toolbarLength);\n@@ -479,1 +485,1 @@\n-                correctOverflow(toolbarLength);\n+                organizeOverflow(toolbarLength);\n@@ -555,0 +561,1 @@\n+            overflowBox = new VBox();\n@@ -557,0 +564,1 @@\n+            overflowBox = new HBox();\n@@ -560,1 +568,6 @@\n-        overflowMenu = new ToolBarOverflowMenu(overflowMenuItems);\n+        \/\/ The overflowBox must have the same style classes, otherwise the overflow items may get wrong values.\n+        overflowBox.setId(box.getId());\n+        overflowBox.getStyleClass().addAll(box.getStyleClass());\n+        overflowBox.setManaged(false);\n+        overflowBox.setVisible(false);\n+        overflowMenu = new ToolBarOverflowMenu(overflowBox.getChildren());\n@@ -566,0 +579,1 @@\n+        getChildren().add(overflowBox);\n@@ -576,6 +590,3 @@\n-    private void correctOverflow(double length) {\n-        boolean overflowed = isOverflowed(length);\n-        if (overflowed != overflow) {\n-            organizeOverflow(length, overflow);\n-        }\n-    }\n+    private void organizeOverflow(double length) {\n+        \/\/ Determine the index of the first node to be moved to the overflow menu\n+        int newOverflowNodeIndex = getOverflowNodeIndex(length);\n@@ -583,2 +594,3 @@\n-    private void organizeOverflow(double length, boolean hasOverflow) {\n-        if (hasOverflow) {\n+        \/\/ If the overflow button is displayed, the length must be corrected\n+        \/\/ and the overflow index recalculated.\n+        if (newOverflowNodeIndex < getSkinnable().getItems().size()) {\n@@ -591,0 +603,7 @@\n+            newOverflowNodeIndex = getOverflowNodeIndex(length);\n+        }\n+\n+        \/\/ Optimization: Skip moving nodes if the node list has not been changed\n+        \/\/ and the overflow index has remained the same.\n+        if (!needsUpdate && newOverflowNodeIndex == overflowNodeIndex) {\n+            return;\n@@ -594,0 +613,1 @@\n+        ObservableList<Node> nodes = getSkinnable().getItems();\n@@ -595,2 +615,0 @@\n-        double x = 0;\n-        overflowMenuItems.clear();\n@@ -598,1 +616,3 @@\n-        for (Node node : getSkinnable().getItems()) {\n+        overflowBox.getChildren().clear();\n+        for (int i = 0; i < nodes.size(); i++) {\n+            Node node = nodes.get(i);\n@@ -602,9 +622,1 @@\n-            if (node.isManaged()) {\n-                if (getSkinnable().getOrientation() == Orientation.VERTICAL) {\n-                    x += snapSizeY(node.prefHeight(-1)) + getSpacing();\n-                } else {\n-                    x += snapSizeX(node.prefWidth(-1)) + getSpacing();\n-                }\n-            }\n-\n-            if (x <= length) {\n+            if (i < newOverflowNodeIndex) {\n@@ -613,0 +625,1 @@\n+                overflowBox.getChildren().add(node);\n@@ -623,45 +636,0 @@\n-                if (node instanceof Separator) {\n-                    overflowMenuItems.add(new SeparatorMenuItem());\n-                } else {\n-                    CustomMenuItem customMenuItem = new CustomMenuItem(node);\n-\n-                    \/\/ RT-36455:\n-                    \/\/ We can't be totally certain of all nodes, but for the\n-                    \/\/ most common nodes we can check to see whether we should\n-                    \/\/ hide the menu when the node is clicked on. The common\n-                    \/\/ case is for TextField or Slider.\n-                    \/\/ This list won't be exhaustive (there is no point really\n-                    \/\/ considering the ListView case), but it should try to\n-                    \/\/ include most common control types that find themselves\n-                    \/\/ placed in menus.\n-                    final String nodeType = node.getTypeSelector();\n-                    switch (nodeType) {\n-                        case \"Button\":\n-                        case \"Hyperlink\":\n-                        case \"Label\":\n-                            customMenuItem.setHideOnClick(true);\n-                            break;\n-                        case \"CheckBox\":\n-                        case \"ChoiceBox\":\n-                        case \"ColorPicker\":\n-                        case \"ComboBox\":\n-                        case \"DatePicker\":\n-                        case \"MenuButton\":\n-                        case \"PasswordField\":\n-                        case \"RadioButton\":\n-                        case \"ScrollBar\":\n-                        case \"ScrollPane\":\n-                        case \"Slider\":\n-                        case \"SplitMenuButton\":\n-                        case \"SplitPane\":\n-                        case \"TextArea\":\n-                        case \"TextField\":\n-                        case \"ToggleButton\":\n-                        case \"ToolBar\":\n-                        default:\n-                            customMenuItem.setHideOnClick(false);\n-                            break;\n-                    }\n-\n-                    overflowMenuItems.add(customMenuItem);\n-                }\n@@ -672,1 +640,2 @@\n-        overflow = overflowMenuItems.size() > 0;\n+        overflow = !overflowBox.getChildren().isEmpty();\n+        overflowNodeIndex = newOverflowNodeIndex;\n@@ -687,4 +656,3 @@\n-        \/\/ Is there overflow ?\n-        boolean hasOverflow = isOverflowed(toolbarLength);\n-\n-        organizeOverflow(toolbarLength, hasOverflow);\n+        \/\/ Reset overflowNodeIndex. This causes the overflow menu to be reorganized.\n+        overflowNodeIndex = Integer.MAX_VALUE;\n+        organizeOverflow(toolbarLength);\n@@ -703,1 +671,9 @@\n-    private boolean isOverflowed(double length) {\n+    \/**\n+     * Calculate the index of the node that does not fit in the toolbar and must be moved to the overflow menu.\n+     *\n+     * @param length the length of the toolbar\n+     * @return the index of the first node that does not fit in the toolbar, or the size of the items list else\n+     *\/\n+    private int getOverflowNodeIndex(double length) {\n+        ObservableList<Node> items = getSkinnable().getItems();\n+        int overflowIndex = items.size();\n@@ -705,7 +681,9 @@\n-        boolean hasOverflow = false;\n-        for (Node node : getSkinnable().getItems()) {\n-            if (!node.isManaged()) continue;\n-            if (getSkinnable().getOrientation() == Orientation.VERTICAL) {\n-                x += snapSizeY(node.prefHeight(-1)) + getSpacing();\n-            } else {\n-                x += snapSizeX(node.prefWidth(-1)) + getSpacing();\n+        for (int i = 0; i < items.size(); i++) {\n+            Node node = items.get(i);\n+\n+            if (node.isManaged()) {\n+                if (getSkinnable().getOrientation() == Orientation.VERTICAL) {\n+                    x += snapSizeY(node.prefHeight(-1)) + getSpacing();\n+                } else {\n+                    x += snapSizeX(node.prefWidth(-1)) + getSpacing();\n+                }\n@@ -713,0 +691,1 @@\n+\n@@ -714,1 +693,1 @@\n-                hasOverflow = true;\n+                overflowIndex = i;\n@@ -718,1 +697,1 @@\n-        return hasOverflow;\n+        return overflowIndex;\n@@ -730,1 +709,1 @@\n-        private ObservableList<MenuItem> menuItems;\n+        private ObservableList<Node> overflowItems;\n@@ -732,1 +711,1 @@\n-        public ToolBarOverflowMenu(ObservableList<MenuItem> items) {\n+        public ToolBarOverflowMenu(ObservableList<Node> items) {\n@@ -737,1 +716,1 @@\n-            this.menuItems = items;\n+            this.overflowItems = items;\n@@ -748,1 +727,1 @@\n-                        popup.getItems().addAll(menuItems);\n+                        popup.getItems().addAll(createMenuItems());\n@@ -771,0 +750,10 @@\n+            popup.addEventHandler(WindowEvent.WINDOW_HIDDEN, e -> {\n+                \/\/ Put the overflowed items back to the list,\n+                \/\/ otherwise subsequent prefWidth(..)\/prefHeight(..) may return wrong values.\n+                overflowItems.clear();\n+                for (Node item : getSkinnable().getItems()) {\n+                    if (!box.getChildren().contains(item)) {\n+                        overflowItems.add(item);\n+                    }\n+                }\n+            });\n@@ -781,1 +770,1 @@\n-                popup.getItems().addAll(menuItems);\n+                popup.getItems().addAll(createMenuItems());\n@@ -786,0 +775,53 @@\n+        private List<MenuItem> createMenuItems() {\n+            List<MenuItem> menuItems = new ArrayList<>();\n+            for (Node node : overflowItems) {\n+                if (node instanceof Separator) {\n+                    menuItems.add(new SeparatorMenuItem());\n+                } else {\n+                    CustomMenuItem customMenuItem = new CustomMenuItem(node);\n+\n+                    \/\/ RT-36455:\n+                    \/\/ We can't be totally certain of all nodes, but for the\n+                    \/\/ most common nodes we can check to see whether we should\n+                    \/\/ hide the menu when the node is clicked on. The common\n+                    \/\/ case is for TextField or Slider.\n+                    \/\/ This list won't be exhaustive (there is no point really\n+                    \/\/ considering the ListView case), but it should try to\n+                    \/\/ include most common control types that find themselves\n+                    \/\/ placed in menus.\n+                    final String nodeType = node.getTypeSelector();\n+                    switch (nodeType) {\n+                        case \"Button\":\n+                        case \"Hyperlink\":\n+                        case \"Label\":\n+                            customMenuItem.setHideOnClick(true);\n+                            break;\n+                        case \"CheckBox\":\n+                        case \"ChoiceBox\":\n+                        case \"ColorPicker\":\n+                        case \"ComboBox\":\n+                        case \"DatePicker\":\n+                        case \"MenuButton\":\n+                        case \"PasswordField\":\n+                        case \"RadioButton\":\n+                        case \"ScrollBar\":\n+                        case \"ScrollPane\":\n+                        case \"Slider\":\n+                        case \"SplitMenuButton\":\n+                        case \"SplitPane\":\n+                        case \"TextArea\":\n+                        case \"TextField\":\n+                        case \"ToggleButton\":\n+                        case \"ToolBar\":\n+                        default:\n+                            customMenuItem.setHideOnClick(false);\n+                            break;\n+                    }\n+\n+                    menuItems.add(customMenuItem);\n+                }\n+\n+            }\n+            return menuItems;\n+        }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ToolBarSkin.java","additions":133,"deletions":91,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -255,0 +255,63 @@\n+    @Test\n+    public void overflowDoesNotOverlapWithItems() {\n+        Rectangle node3 = new Rectangle(2.0, 4.0);\n+        Rectangle node4 = new Rectangle(2.0, 4.0);\n+\n+        node1.setId(\"node1\");\n+        node2.setId(\"node2\");\n+        node3.setId(\"node3\");\n+        node4.setId(\"node4\");\n+\n+        \/\/ Make the width of the node dependent on whether it is added to the scene\n+        node1.sceneProperty().addListener((ov, o, n) -> {\n+            if (n == null) {\n+                setFixSize(node1, 0);\n+            } else {\n+                setFixSize(node1, ORIGINAL_CHILDREN_SIZE);\n+            }\n+        });\n+\n+        initializeToolBar();\n+        toolBar.getItems().addAll(node3, node4);\n+\n+        setFixSize(toolBar, ORIGINAL_CHILDREN_SIZE * 4 + 50);\n+        setFixSize(node1, ORIGINAL_CHILDREN_SIZE);\n+        setFixSize(node2, ORIGINAL_CHILDREN_SIZE);\n+        setFixSize(node3, ORIGINAL_CHILDREN_SIZE);\n+        setFixSize(node4, ORIGINAL_CHILDREN_SIZE);\n+\n+        \/\/ Resize toolbar\n+        setFixSize(toolBar, ORIGINAL_CHILDREN_SIZE * 3);\n+\n+        checkNodeBoundsWithinToolbar(node1);\n+        checkNodeBoundsWithinToolbar(node2);\n+        checkNodeBoundsWithinToolbar(node3);\n+        checkNodeBoundsWithinToolbar(node4);\n+    }\n+\n+\n+    private void checkNodeBoundsWithinToolbar(Node node) {\n+        if (node.getScene() != toolBar.getScene()) {\n+            \/\/ Currently, a node that does not fit into the toolbar is removed from the toolbar and from the the scene.\n+            \/\/ Although this is an implementation detail, we use it here to check whether the node is visible in the toolbar or has been moved behind the overflow button.\n+            return;\n+        }\n+\n+        double nodeX = node.getLayoutX();\n+        double nodeWidth = node.prefWidth(-1);\n+\n+        Pane overflowButton = getOverflowButton();\n+        if (overflowButton.getScene() != null && overflowButton.isVisible()) {\n+            assertTrue(\"'\" + node.getId() + \"' is overlapping the overflowButton.\" +\n+                            \" The node \" + \"<\" + nodeX + \"..\" + (nodeX + nodeWidth) + \">.\"\n+                            + \" The overflow button \" + \"<\" + overflowButton.getLayoutX() + \"..\" + (overflowButton.getLayoutX() + overflowButton.getWidth()) + \">\",\n+                    nodeX + nodeWidth < overflowButton.getLayoutX());\n+        }\n+\n+        assertTrue(\"'\" + node.getId() + \"' bounds are outside the toolbar.\" +\n+                        \" The node \" + \"<\" + nodeX + \"..\" + (nodeX + nodeWidth) + \">.\"\n+                        + \" The toolbar width \" + toolBar.getWidth(),\n+                nodeX + nodeWidth < toolBar.getWidth());\n+\n+    }\n+\n@@ -298,1 +361,1 @@\n-        Pane pane = (Pane) toolBar.queryAccessibleAttribute(AccessibleAttribute.OVERFLOW_BUTTON);\n+        Pane pane = getOverflowButton();\n@@ -304,1 +367,1 @@\n-        Pane pane = (Pane) toolBar.queryAccessibleAttribute(AccessibleAttribute.OVERFLOW_BUTTON);\n+        Pane pane = getOverflowButton();\n@@ -308,0 +371,4 @@\n+\n+    private Pane getOverflowButton() {\n+        return (Pane) toolBar.queryAccessibleAttribute(AccessibleAttribute.OVERFLOW_BUTTON);\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ToolbarTest.java","additions":69,"deletions":2,"binary":false,"changes":71,"status":"modified"}]}