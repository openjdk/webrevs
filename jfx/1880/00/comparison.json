{"files":[{"patch":"@@ -28,8 +28,14 @@\n-\/**\n- * Converter defines conversion behavior between strings and objects.\n- * The type of objects and formats of strings are defined by the subclasses\n- * of Converter.\n- *\n- * @param <T> the type of the object being converted\n- * @since JavaFX 2.0\n- *\/\n+\/\/\/ Defines conversion behaviors between `String` and other types. Each subclass defines a formatting (type to string)\n+\/\/\/ and a parsing (string to type) behaviors. `StringConverter`s are usually used in controls for converting between the\n+\/\/\/ underlying model (represented by type `T`) and the visual `String` representation.\n+\/\/\/\n+\/\/\/ Subclasses are provided for primitive wrapper types, numbers, dates and times, and custom formats.\n+\/\/\/\n+\/\/\/ @implNote\n+\/\/\/ JavaFX's implementations follow these behaviors, which are not required by implementing classes:\n+\/\/\/ - Except for `DefaultStringConverter`, formatting `null` returns an empty string, otherwise the type's `toString` is\n+\/\/\/ used if it is suitable; parsing `null` or an empty string returns `null`.\n+\/\/\/ - Immutable (the same converter can be reused).\n+\/\/\/\n+\/\/\/ @param <T> the type associated with the string conversions\n+\/\/\/ @since JavaFX 2.0\n@@ -38,3 +44,1 @@\n-    \/**\n-     * Creates a default {@code StringConverter}.\n-     *\/\n+    \/\/\/ Creates a default {@code StringConverter}.\n@@ -44,6 +48,4 @@\n-    \/**\n-    * Converts the object provided into its string form.\n-    * Format of the returned string is defined by the specific converter.\n-    * @param object the object of type {@code T} to convert\n-    * @return a string representation of the object passed in\n-    *\/\n+    \/\/\/ Converts an object to a string form. The format of the returned string is defined by the specific converter.\n+    \/\/\/\n+    \/\/\/ @param object the object of type `T` to convert\n+    \/\/\/ @return a string representation of the object passed in\n@@ -52,6 +54,4 @@\n-    \/**\n-    * Converts the string provided into an object defined by the specific converter.\n-    * Format of the string and type of the resulting object is defined by the specific converter.\n-    * @param string the {@code String} to convert\n-    * @return an object representation of the string passed in.\n-    *\/\n+    \/\/\/ Converts a string to an object. The parsing mechanism is defined by the specific converter.\n+    \/\/\/\n+    \/\/\/ @param string the `String` to convert\n+    \/\/\/ @return an object of type `T` created from the string passed in.\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/StringConverter.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.util.converter;\n+\n+import javafx.util.StringConverter;\n+\n+\/\/\/ A base class containing common implementations for `StringConverter`s as noted in the @implNote of `StringConverter`.\n+abstract class BaseStringConverter<T> extends StringConverter<T> {\n+\n+    @Override\n+    public T fromString(String string) {\n+        if (string == null) {\n+            return null;\n+        }\n+        string = string.trim();\n+        if (string.isEmpty()) {\n+            return null;\n+        }\n+        return fromNonEmptyString(string);\n+    }\n+\n+    \/\/\/ Returns an object parsed from a non-{@code null} non-empty string.\n+    \/\/\/\n+    \/\/\/ Treat as protected (implementing classes are public so they can't add a new protected method).\n+    abstract T fromNonEmptyString(String string);\n+\n+    @Override\n+    public String toString(T object) {\n+        return object == null ? \"\" : toStringFromNonNull(object);\n+    }\n+\n+    \/\/\/ Returns a string from a non-`null` reference.\n+    \/\/\/\n+    \/\/\/ Treat as protected (implementing classes are public so they can't add a new protected method).\n+    String toStringFromNonNull(T object) {\n+        return object.toString();\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/BaseStringConverter.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.util.converter;\n+\n+import java.time.chrono.Chronology;\n+import java.time.chrono.IsoChronology;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.time.format.DecimalStyle;\n+import java.time.format.FormatStyle;\n+import java.time.temporal.Temporal;\n+import java.time.temporal.TemporalQuery;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+\/\/\/ Base class for the java.time types converters.\n+abstract class BaseTemporalStringConverter<T extends Temporal> extends BaseStringConverter<T> {\n+\n+    private static final Locale DEFAULT_LOCALE = Locale.getDefault(Locale.Category.FORMAT);\n+    private static final Chronology DEFAULT_CHRONO = IsoChronology.INSTANCE;\n+\n+    private final DateTimeFormatter formatter;\n+    private final DateTimeFormatter parser;\n+\n+    protected BaseTemporalStringConverter(FormatStyle dateStyle, FormatStyle timeStyle, Locale locale, Chronology chrono) {\n+        locale = Objects.requireNonNullElse(locale, DEFAULT_LOCALE);\n+        chrono = Objects.requireNonNullElse(chrono, DEFAULT_CHRONO);\n+        formatter = createFormatter(dateStyle, timeStyle, locale, chrono);\n+        parser = createParser(dateStyle, timeStyle, locale, chrono);\n+    }\n+\n+    protected BaseTemporalStringConverter(DateTimeFormatter formatter, DateTimeFormatter parser,\n+            FormatStyle dateStyle, FormatStyle timeStyle) {\n+        this.formatter = formatter != null ? formatter : createFormatter(dateStyle, timeStyle, DEFAULT_LOCALE, DEFAULT_CHRONO);\n+        this.parser = parser != null ? parser :\n+                formatter != null ? formatter : createParser(dateStyle, timeStyle, DEFAULT_LOCALE, DEFAULT_CHRONO);\n+    }\n+\n+    private final DateTimeFormatter createParser(FormatStyle dateStyle, FormatStyle timeStyle, Locale locale, Chronology chrono) {\n+        String pattern = DateTimeFormatterBuilder.getLocalizedDateTimePattern(dateStyle, timeStyle, chrono, locale);\n+        return new DateTimeFormatterBuilder().parseLenient()\n+                                             .appendPattern(pattern)\n+                                             .toFormatter()\n+                                             .withChronology(chrono)\n+                                             .withDecimalStyle(DecimalStyle.of(locale));\n+    }\n+\n+    \/\/\/ To satisfy the requirements of date formatters as described in, e.g.,\n+    \/\/\/ [LocalDateStringConverter#LocalDateStringConverter()], the method checks if there's a need to modify the pattern.\n+    private final DateTimeFormatter createFormatter(FormatStyle dateStyle, FormatStyle timeStyle, Locale locale, Chronology chrono) {\n+        if (dateStyle != null) {\n+            String pattern = DateTimeFormatterBuilder.getLocalizedDateTimePattern(dateStyle, timeStyle, chrono, locale);\n+            if (pattern.contains(\"yy\") && !pattern.contains(\"yyy\")) {\n+                \/\/ Modify pattern to show four-digit year, including leading zeros.\n+                String newPattern = pattern.replace(\"yy\", \"yyyy\");\n+                return DateTimeFormatter.ofPattern(newPattern).withDecimalStyle(DecimalStyle.of(locale));\n+            }\n+        }\n+        return getLocalizedFormatter(dateStyle, timeStyle)\n+                            .withLocale(locale)\n+                            .withChronology(chrono)\n+                            .withDecimalStyle(DecimalStyle.of(locale));\n+    }\n+\n+    abstract DateTimeFormatter getLocalizedFormatter(FormatStyle dateStyle, FormatStyle timeStyle);\n+\n+    @Override\n+    String toStringFromNonNull(T value) {\n+        return formatter.format(value);\n+    }\n+\n+    @Override\n+    T fromNonEmptyString(String string) {\n+        return parser.parse(string, getTemporalQuery());\n+    }\n+\n+    abstract TemporalQuery<T> getTemporalQuery();\n+\n+    \/\/\/ For tests only\n+    DateTimeFormatter getFormatter() {\n+        return formatter;\n+    }\n+\n+    \/\/\/ For tests only\n+    DateTimeFormatter getParser() {\n+        return parser;\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/BaseTemporalStringConverter.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import javafx.util.StringConverter;\n@@ -31,5 +30,4 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link BigDecimal} values.<\/p>\n- * @since JavaFX 2.1\n- *\/\n-public class BigDecimalStringConverter extends StringConverter<BigDecimal> {\n+\/\/\/ A `StringConverter` implementation for [BigDecimal] values.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n+public class BigDecimalStringConverter extends BaseStringConverter<BigDecimal> {\n@@ -37,3 +35,1 @@\n-    \/**\n-     * Creates a default {@code BigDecimalStringConverter}.\n-     *\/\n+    \/\/\/ Creates a default `BigDecimalStringConverter`.\n@@ -43,24 +39,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public BigDecimal fromString(String value) {\n-        \/\/ If the specified value is null or zero-length, return null\n-        if (value == null) {\n-            return null;\n-        }\n-\n-        value = value.trim();\n-\n-        if (value.length() < 1) {\n-            return null;\n-        }\n-\n-        return new BigDecimal(value);\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(BigDecimal value) {\n-        \/\/ If the specified value is null, return a zero-length String\n-        if (value == null) {\n-            return \"\";\n-        }\n-\n-        return value.toString();\n+    @Override\n+    BigDecimal fromNonEmptyString(String string) {\n+        return new BigDecimal(string);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/BigDecimalStringConverter.java","additions":8,"deletions":33,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import javafx.util.StringConverter;\n@@ -31,5 +30,4 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link BigInteger} values.<\/p>\n- * @since JavaFX 2.1\n- *\/\n-public class BigIntegerStringConverter extends StringConverter<BigInteger> {\n+\/\/\/ A `StringConverter` implementation for [BigInteger] values.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n+public class BigIntegerStringConverter extends BaseStringConverter<BigInteger> {\n@@ -37,3 +35,1 @@\n-    \/**\n-     * Creates a default {@code BigIntegerStringConverter}.\n-     *\/\n+    \/\/\/ Creates a default `BigIntegerStringConverter`.\n@@ -43,24 +39,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public BigInteger fromString(String value) {\n-        \/\/ If the specified value is null or zero-length, return null\n-        if (value == null) {\n-            return null;\n-        }\n-\n-        value = value.trim();\n-\n-        if (value.length() < 1) {\n-            return null;\n-        }\n-\n-        return new BigInteger(value);\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(BigInteger value) {\n-        \/\/ If the specified value is null, return a zero-length String\n-        if (value == null) {\n-            return \"\";\n-        }\n-\n-        return value.toString();\n+    @Override\n+    BigInteger fromNonEmptyString(String string) {\n+        return new BigInteger(string);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/BigIntegerStringConverter.java","additions":8,"deletions":33,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -28,1 +28,5 @@\n-import javafx.util.StringConverter;\n+\/\/\/ A `StringConverter` implementation for `Boolean` (and `boolean`) values. Formatting is done by [Boolean#toString()]\n+\/\/\/ for non-`null` values, and parsing with [Boolean#valueOf(String)] for non-`null` non-empty strings.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n+public class BooleanStringConverter extends BaseStringConverter<Boolean> {\n@@ -30,10 +34,1 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link Boolean}\n- * (and boolean primitive) values.<\/p>\n- * @since JavaFX 2.1\n- *\/\n-public class BooleanStringConverter extends StringConverter<Boolean> {\n-\n-    \/**\n-     * Creates a default {@code BooleanStringConverter}.\n-     *\/\n+    \/\/\/ Creates a default `BooleanStringConverter`.\n@@ -43,24 +38,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public Boolean fromString(String value) {\n-        \/\/ If the specified value is null or zero-length, return null\n-        if (value == null) {\n-            return null;\n-        }\n-\n-        value = value.trim();\n-\n-        if (value.length() < 1) {\n-            return null;\n-        }\n-\n-        return Boolean.valueOf(value);\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(Boolean value) {\n-        \/\/ If the specified value is null, return a zero-length String\n-        if (value == null) {\n-            return \"\";\n-        }\n-\n-        return value.toString();\n+    @Override\n+    Boolean fromNonEmptyString(String string) {\n+        return Boolean.valueOf(string);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/BooleanStringConverter.java","additions":9,"deletions":35,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -28,1 +28,5 @@\n-import javafx.util.StringConverter;\n+\/\/\/ A `StringConverter` implementation for `Byte` (and `byte`) values. Formatting is done by [Byte#toString()] for\n+\/\/\/ non-`null` values, and parsing with [Byte#valueOf(String)] for non-`null` non-empty strings.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n+public class ByteStringConverter extends BaseStringConverter<Byte> {\n@@ -30,10 +34,1 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link Byte}\n- * (and byte primitive) values.<\/p>\n- * @since JavaFX 2.1\n- *\/\n-public class ByteStringConverter extends StringConverter<Byte> {\n-\n-    \/**\n-     * Creates a default {@code ByteStringConverter}.\n-     *\/\n+    \/\/\/ Creates a default {@code ByteStringConverter}.\n@@ -43,24 +38,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public Byte fromString(String value) {\n-        \/\/ If the specified value is null or zero-length, return null\n-        if (value == null) {\n-            return null;\n-        }\n-\n-        value = value.trim();\n-\n-        if (value.length() < 1) {\n-            return null;\n-        }\n-\n-        return Byte.valueOf(value);\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(Byte value) {\n-        \/\/ If the specified value is null, return a zero-length String\n-        if (value == null) {\n-            return \"\";\n-        }\n-\n-        return Byte.toString(value.byteValue());\n+    @Override\n+    Byte fromNonEmptyString(String string) {\n+        return Byte.valueOf(string);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/ByteStringConverter.java","additions":9,"deletions":35,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -28,12 +28,8 @@\n-import javafx.util.StringConverter;\n-\n-\/**\n- * <p>{@link StringConverter} implementation for {@link Character}\n- * (and char primitive) values.<\/p>\n- * @since JavaFX 2.1\n- *\/\n-public class CharacterStringConverter extends StringConverter<Character> {\n-\n-    \/**\n-     * Creates a default {@code CharacterStringConverter}.\n-     *\/\n+\/\/\/ A `StringConverter` implementation for `Character` (and `character`) values. Formatting is done by\n+\/\/\/ [Character#toString()] for non-`null` values, and parsing with [Character#valueOf(char)] for non-`null` non-empty\n+\/\/\/ strings.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n+public class CharacterStringConverter extends BaseStringConverter<Character> {\n+\n+    \/\/\/ Creates a default `CharacterStringConverter`.\n@@ -43,24 +39,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public Character fromString(String value) {\n-        \/\/ If the specified value is null or zero-length, return null\n-        if (value == null) {\n-            return null;\n-        }\n-\n-        value = value.trim();\n-\n-        if (value.length() < 1) {\n-            return null;\n-        }\n-\n-        return Character.valueOf(value.charAt(0));\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(Character value) {\n-        \/\/ If the specified value is null, return a zero-length String\n-        if (value == null) {\n-            return \"\";\n-        }\n-\n-        return value.toString();\n+    @Override\n+    Character fromNonEmptyString(String string) {\n+        return Character.valueOf(string.charAt(0));\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/CharacterStringConverter.java","additions":11,"deletions":36,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.text.DecimalFormat;\n-import java.text.DecimalFormatSymbols;\n@@ -32,1 +30,0 @@\n-import javafx.util.StringConverter;\n@@ -34,8 +31,3 @@\n-\/**\n- * A {@link StringConverter} implementation for {@link Number} values that represent currency. Instances of this class are immutable.\n- *\n- * @see PercentageStringConverter\n- * @see NumberStringConverter\n- * @see StringConverter\n- * @since JavaFX 2.1\n- *\/\n+\/\/\/ A `StringConverter` implementation for `Number` values that represent currency.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n@@ -44,3 +36,1 @@\n-    \/**\n-     * Constructs a {@code CurrencyStringConverter} with the default locale and format.\n-     *\/\n+    \/\/\/ Creates a `CurrencyStringConverter` that uses a formatter\/parser based on the user's [Locale].\n@@ -48,1 +38,1 @@\n-        this(Locale.getDefault());\n+        super();\n@@ -51,5 +41,3 @@\n-    \/**\n-     * Constructs a {@code CurrencyStringConverter} with the given locale and the default format.\n-     *\n-     * @param locale the locale used in determining the number format used to format the string\n-     *\/\n+    \/\/\/ Creates a `CurrencyStringConverter` that uses a formatter\/parser based on the given locale.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n@@ -57,1 +45,1 @@\n-        this(locale, null);\n+        super(locale);\n@@ -60,7 +48,5 @@\n-    \/**\n-     * Constructs a {@code CurrencyStringConverter} with the default locale and the given decimal format pattern.\n-     *\n-     * @param pattern the string pattern used in determining the number format used to format the string\n-     *\n-     * @see java.text.DecimalFormat\n-     *\/\n+    \/\/\/ Creates a `CurrencyStringConverter` that uses a formatter\/parser based on the user's [Locale] and the given\n+    \/\/\/ decimal format pattern.\n+    \/\/\/\n+    \/\/\/ @param pattern the pattern describing the number format. If `null`, a default formatter\/parser will be used.\n+    \/\/\/ @see java.text.DecimalFormat\n@@ -68,1 +54,1 @@\n-        this(Locale.getDefault(), pattern);\n+        super(pattern);\n@@ -71,8 +57,6 @@\n-    \/**\n-     * Constructs a {@code CurrencyStringConverter} with the given locale and decimal format pattern.\n-     *\n-     * @param locale the locale used in determining the number format used to format the string\n-     * @param pattern the string pattern used in determining the number format used to format the string\n-     *\n-     * @see java.text.DecimalFormat\n-     *\/\n+    \/\/\/ Creates a `CurrencyStringConverter` that uses a formatter\/parser based on the given `Locale` and decimal format\n+    \/\/\/ pattern.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n+    \/\/\/ @param pattern the pattern describing the number format. If `null`, a default formatter\/parser will be used.\n+    \/\/\/ @see java.text.DecimalFormat\n@@ -80,1 +64,1 @@\n-        super(locale, pattern, null);\n+        super(locale, pattern);\n@@ -83,5 +67,4 @@\n-    \/**\n-     * Constructs a {@code CurrencyStringConverter} with the given number format.\n-     *\n-     * @param numberFormat the number format used to format the string\n-     *\/\n+    \/\/\/ Creates a `CurrencyStringConverter` that uses the given formatter\/parser.\n+    \/\/\/\n+    \/\/\/ @param numberFormat the formatter\/parser that will be used by the `toString()` and `fromString()` methods. If\n+    \/\/\/        `null`, a default formatter\/parser will be used.\n@@ -89,1 +72,1 @@\n-        super(null, null, numberFormat);\n+        super(numberFormat);\n@@ -92,5 +75,0 @@\n-    \/**\n-    * @deprecated This method was exposed erroneously and will be removed in a future version.\n-    *\/\n-    @Deprecated(forRemoval = true, since = \"22\")\n-    @SuppressWarnings(\"removal\")\n@@ -98,11 +76,2 @@\n-    protected NumberFormat getNumberFormat() {\n-        Locale _locale = locale == null ? Locale.getDefault() : locale;\n-\n-        if (numberFormat != null) {\n-            return numberFormat;\n-        } else if (pattern != null) {\n-            DecimalFormatSymbols symbols = new DecimalFormatSymbols(_locale);\n-            return new DecimalFormat(pattern, symbols);\n-        } else {\n-            return NumberFormat.getCurrencyInstance(_locale);\n-        }\n+    NumberFormat getSpecializedNumberFormat(Locale locale) {\n+        return NumberFormat.getCurrencyInstance(locale);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/CurrencyStringConverter.java","additions":29,"deletions":60,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.text.SimpleDateFormat;\n@@ -32,1 +31,0 @@\n-import javafx.util.StringConverter;\n@@ -34,7 +32,6 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link Date} values.<\/p>\n- *\n- * @see TimeStringConverter\n- * @see DateTimeStringConverter\n- * @since JavaFX 2.1\n- *\/\n+\/\/\/ A `StringConverter` implementation for [Date] values that represent dates.\n+\/\/\/\n+\/\/\/ Note that using `Date` is not recommended in JDK versions where [java.time.LocalDate] is available, in which case\n+\/\/\/ [LocalDateStringConverter] should be used.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n@@ -43,6 +40,2 @@\n-    \/\/ ------------------------------------------------------------ Constructors\n-\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * {@link DateFormat#DEFAULT} date style.\n-     *\/\n+    \/\/\/ Creates a `DateStringConverter` that uses a formatter\/parser based on [DateFormat#DEFAULT] for the date style,\n+    \/\/\/ and the user's [Locale].\n@@ -50,1 +43,1 @@\n-        this(null, null, null, DateFormat.DEFAULT);\n+        super();\n@@ -53,9 +46,5 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified {@link DateFormat} date style.\n-     *\n-     * @param dateStyle the given formatting style. For example,\n-     * {@link DateFormat#SHORT} for \"M\/d\/yy\" in the US locale.\n-     *\n-     * @since JavaFX 8u40\n-     *\/\n+    \/\/\/ Creates a `DateStringConverter` that uses a formatter\/parser based on the given date style, and the user's\n+    \/\/\/ [Locale].\n+    \/\/\/\n+    \/\/\/ @param dateStyle the formatting style for dates. For example, [DateFormat#SHORT] for \"M\/d\/yy\" in the US locale.\n+    \/\/\/ @since JavaFX 8u40\n@@ -63,1 +52,1 @@\n-        this(null, null, null, dateStyle);\n+        super(dateStyle, DateFormat.DEFAULT);\n@@ -66,6 +55,4 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified locale and the {@link DateFormat#DEFAULT} date style.\n-     *\n-     * @param locale the given locale.\n-     *\/\n+    \/\/\/ Creates a `DateStringConverter` that uses a formatter\/parser based on [DateFormat#DEFAULT] for the date style,\n+    \/\/\/ and the given `Locale`.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n@@ -73,1 +60,1 @@\n-        this(locale, null, null, DateFormat.DEFAULT);\n+        super(locale);\n@@ -76,10 +63,6 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified locale and {@link DateFormat} date style.\n-     *\n-     * @param locale the given locale.\n-     * @param dateStyle the given formatting style. For example,\n-     * {@link DateFormat#SHORT} for \"M\/d\/yy\" in the US locale.\n-     *\n-     * @since JavaFX 8u40\n-     *\/\n+    \/\/\/ Creates a `DateStringConverter` that uses a formatter\/parser based on the given date style and `Locale`.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n+    \/\/\/ @param dateStyle the formatting style for dates. For example, [DateFormat#SHORT] for \"M\/d\/yy\" in the US locale.\n+    \/\/\/\n+    \/\/\/ @since JavaFX 8u40\n@@ -87,1 +70,1 @@\n-        this(locale, null, null, dateStyle);\n+        super(locale, dateStyle, DateFormat.DEFAULT);\n@@ -90,6 +73,4 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified pattern.\n-     *\n-     * @param pattern the pattern describing the date format.\n-     *\/\n+    \/\/\/ Creates a `DateStringConverter` that uses a formatter\/parser based on the given pattern, and the user's [Locale].\n+    \/\/\/\n+    \/\/\/ @param pattern the pattern describing the date format. If `null`, [DateFormat#DEFAULT] will be used for the date\n+    \/\/\/        style.\n@@ -97,1 +78,1 @@\n-        this(null, pattern, null, DateFormat.DEFAULT);\n+        super(pattern);\n@@ -100,7 +81,5 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified locale and pattern.\n-     *\n-     * @param locale the given locale.\n-     * @param pattern the pattern describing the date format.\n-     *\/\n+    \/\/\/ Creates a `DateStringConverter` that uses a formatter\/parser based on the given pattern and `Locale`.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n+    \/\/\/ @param pattern the pattern describing the date format. If `null`, [DateFormat#DEFAULT] will be used for the date\n+    \/\/\/        style.\n@@ -108,1 +87,1 @@\n-        this(locale, pattern, null, DateFormat.DEFAULT);\n+        super(locale, pattern);\n@@ -111,7 +90,4 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified {@link DateFormat} formatter.\n-     *\n-     * @param dateFormat the {@link DateFormat} to be used for formatting and\n-     * parsing.\n-     *\/\n+    \/\/\/ Creates a `DateStringConverter` that uses the given formatter\/parser.\n+    \/\/\/\n+    \/\/\/ @param dateFormat the formatter\/parser that will be used by the `toString()` and `fromString()` methods. If\n+    \/\/\/        `null`, a default formatter\/parser will be used.\n@@ -119,5 +95,1 @@\n-        this(null, null, dateFormat, DateFormat.DEFAULT);\n-    }\n-\n-    private DateStringConverter(Locale locale, String pattern, DateFormat dateFormat, int dateStyle) {\n-        super(locale, pattern, dateFormat, dateStyle, DateFormat.DEFAULT);\n+        super(dateFormat);\n@@ -126,7 +98,0 @@\n-\n-    \/\/ --------------------------------------------------------- Private Methods\n-\n-    \/**\n-     * @deprecated This method was exposed erroneously and will be removed in a future version.\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"22\")\n@@ -134,14 +99,2 @@\n-    protected DateFormat getDateFormat() {\n-        DateFormat df = null;\n-\n-        if (dateFormat != null) {\n-            return dateFormat;\n-        } else if (pattern != null) {\n-            df = new SimpleDateFormat(pattern, locale);\n-        } else {\n-            df = DateFormat.getDateInstance(dateStyle, locale);\n-        }\n-\n-        df.setLenient(false);\n-\n-        return df;\n+    DateFormat getSpecialziedDateFormat(int dateStyle, int timeStyle, Locale locale) {\n+        return DateFormat.getDateInstance(dateStyle, locale);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/DateStringConverter.java","additions":45,"deletions":92,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import javafx.util.StringConverter;\n+import java.util.Objects;\n@@ -35,17 +35,7 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link Date} values that\n- * represent a date and time.<\/p>\n- *\n- * @see DateStringConverter\n- * @see TimeStringConverter\n- * @since JavaFX 2.1\n- *\/\n-public class DateTimeStringConverter extends StringConverter<Date> {\n-\n-    \/\/ ------------------------------------------------------ Private properties\n-\n-    final Locale locale;\n-\n-    final String pattern;\n-\n-    final DateFormat dateFormat;\n+\/\/\/ A `StringConverter` implementation for [Date] values that represent dates and times.\n+\/\/\/\n+\/\/\/ Note that using `Date` is not recommended in JDK versions where [java.time.LocalDateTime] is available, in which\n+\/\/\/ case [LocalDateTimeStringConverter] should be used.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n+public class DateTimeStringConverter extends BaseStringConverter<Date> {\n@@ -53,1 +43,1 @@\n-    final int dateStyle;\n+    private static final Locale DEFAULT_LOCALE = Locale.getDefault(Locale.Category.FORMAT);\n@@ -55,1 +45,1 @@\n-    final int timeStyle;\n+    private final DateFormat dateFormat;\n@@ -57,7 +47,2 @@\n-\n-    \/\/ ------------------------------------------------------------ Constructors\n-\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using\n-     * {@link DateFormat#DEFAULT} styles for date and time.\n-     *\/\n+    \/\/\/ Creates a `DateTimeStringConverter` that uses a formatter\/parser based on [DateFormat#DEFAULT] for both date and\n+    \/\/\/ time styles, and the user's [Locale].\n@@ -65,1 +50,1 @@\n-        this(null, null, null, DateFormat.DEFAULT, DateFormat.DEFAULT);\n+        this(DEFAULT_LOCALE, DateFormat.DEFAULT, DateFormat.DEFAULT);\n@@ -68,11 +53,7 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using specified\n-     * {@link DateFormat} styles for date and time.\n-     *\n-     * @param dateStyle the given formatting style. For example,\n-     * {@link DateFormat#SHORT} for \"M\/d\/yy\" in the US locale.\n-     * @param timeStyle the given formatting style. For example,\n-     * {@link DateFormat#SHORT} for \"h:mm a\" in the US locale.\n-     *\n-     * @since JavaFX 8u40\n-     *\/\n+    \/\/\/ Creates a `DateTimeStringConverter` that uses a formatter\/parser based on the given date and time styles, and\n+    \/\/\/ the user's [Locale].\n+    \/\/\/\n+    \/\/\/ @param dateStyle the formatting style for dates. For example, [DateFormat#SHORT] for \"M\/d\/yy\" in the US locale.\n+    \/\/\/ @param timeStyle the formatting style for times. For example, `DateFormat.SHORT` for \"h:mm a\" in the US locale.\n+    \/\/\/\n+    \/\/\/ @since JavaFX 8u40\n@@ -80,1 +61,1 @@\n-        this(null, null, null, dateStyle, timeStyle);\n+        this(DEFAULT_LOCALE, dateStyle, timeStyle);\n@@ -83,6 +64,4 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified locale and {@link DateFormat#DEFAULT} styles for date and time.\n-     *\n-     * @param locale the given locale.\n-     *\/\n+    \/\/\/ Creates a `DateTimeStringConverter` that uses a formatter\/parser based on [DateFormat#DEFAULT] for both date and\n+    \/\/\/ time styles, and the given `Locale`.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n@@ -90,1 +69,1 @@\n-        this(locale, null, null, DateFormat.DEFAULT, DateFormat.DEFAULT);\n+        this(locale, DateFormat.DEFAULT, DateFormat.DEFAULT);\n@@ -93,12 +72,8 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using specified\n-     * locale and {@link DateFormat} styles for date and time.\n-     *\n-     * @param locale the given locale.\n-     * @param dateStyle the given formatting style. For example,\n-     * {@link DateFormat#SHORT} for \"M\/d\/yy\" in the US locale.\n-     * @param timeStyle the given formatting style. For example,\n-     * {@link DateFormat#SHORT} for \"h:mm a\" in the US locale.\n-     *\n-     * @since JavaFX 8u40\n-     *\/\n+    \/\/\/ Creates a `DateTimeStringConverter` that uses a formatter\/parser based on the given date and time styles, and\n+    \/\/\/ `Locale`.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n+    \/\/\/ @param dateStyle the formatting style for dates. For example, [DateFormat#SHORT] for \"M\/d\/yy\" in the US locale.\n+    \/\/\/ @param timeStyle the formatting style for times. For example, `DateFormat.SHORT` for \"h:mm a\" in the US locale.\n+    \/\/\/\n+    \/\/\/ @since JavaFX 8u40\n@@ -106,1 +81,1 @@\n-        this(locale, null, null, dateStyle, timeStyle);\n+        dateFormat = create(locale, dateStyle, timeStyle, null);\n@@ -109,6 +84,5 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified pattern.\n-     *\n-     * @param pattern the pattern describing the date and time format.\n-     *\/\n+    \/\/\/ Creates a `DateTimeStringConverter` that uses a formatter\/parser based on the given pattern, and the user's\n+    \/\/\/ [Locale].\n+    \/\/\/\n+    \/\/\/ @param pattern the pattern describing the date and time format. If `null`, [DateFormat#DEFAULT] will be used for\n+    \/\/\/        both date and time.\n@@ -116,1 +90,1 @@\n-        this(null, pattern, null, DateFormat.DEFAULT, DateFormat.DEFAULT);\n+        this(DEFAULT_LOCALE, pattern);\n@@ -119,7 +93,5 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified locale and pattern.\n-     *\n-     * @param locale the given locale.\n-     * @param pattern the pattern describing the date and time format.\n-     *\/\n+    \/\/\/ Creates a `DateTimeStringConverter` that uses a formatter\/parser based on the given pattern and `Locale`.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n+    \/\/\/ @param pattern the pattern describing the date and time format. If `null`, [DateFormat#DEFAULT] will be used for\n+    \/\/\/        both date and time styles.\n@@ -127,1 +99,1 @@\n-        this(locale, pattern, null, DateFormat.DEFAULT, DateFormat.DEFAULT);\n+        dateFormat = create(locale, DateFormat.DEFAULT, DateFormat.DEFAULT, pattern);\n@@ -130,7 +102,4 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified {@link DateFormat} formatter.\n-     *\n-     * @param dateFormat the {@link DateFormat} to be used for formatting and\n-     * parsing.\n-     *\/\n+    \/\/\/ Creates a `DateTimeStringConverter` that uses the given formatter\/parser.\n+    \/\/\/\n+    \/\/\/ @param dateFormat the formatter\/parser that will be used by the `toString()` and `fromString()` methods. If\n+    \/\/\/        `null`, a default formatter\/parser will be used.\n@@ -138,1 +107,2 @@\n-        this(null, null, dateFormat, DateFormat.DEFAULT, DateFormat.DEFAULT);\n+        this.dateFormat = Objects.requireNonNullElseGet(dateFormat,\n+                () -> create(DEFAULT_LOCALE, DateFormat.DEFAULT, DateFormat.DEFAULT, null));\n@@ -141,7 +111,6 @@\n-    DateTimeStringConverter(Locale locale, String pattern, DateFormat dateFormat,\n-                            int dateStyle, int timeStyle) {\n-        this.locale = (locale != null) ? locale : Locale.getDefault(Locale.Category.FORMAT);\n-        this.pattern = pattern;\n-        this.dateFormat = dateFormat;\n-        this.dateStyle = dateStyle;\n-        this.timeStyle = timeStyle;\n+    private DateFormat create(Locale locale, int dateStyle, int timeStyle, String pattern) {\n+        locale = Objects.requireNonNullElse(locale, DEFAULT_LOCALE);\n+        DateFormat dateFormat = pattern == null ? getSpecialziedDateFormat(dateStyle, timeStyle, locale)\n+                                                : new SimpleDateFormat(pattern, locale);\n+        dateFormat.setLenient(false);\n+        return dateFormat;\n@@ -150,0 +119,4 @@\n+    \/\/ treat as protected\n+    DateFormat getSpecialziedDateFormat(int dateStyle, int timeStyle, Locale locale) {\n+        return DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);\n+    }\n@@ -151,4 +124,2 @@\n-    \/\/ ------------------------------------------------------- Converter Methods\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public Date fromString(String value) {\n+    @Override\n+    Date fromNonEmptyString(String string) {\n@@ -156,18 +127,3 @@\n-            \/\/ If the specified value is null or zero-length, return null\n-            if (value == null) {\n-                return (null);\n-            }\n-\n-            value = value.trim();\n-\n-            if (value.length() < 1) {\n-                return (null);\n-            }\n-\n-            \/\/ Create and configure the parser to be used\n-            DateFormat parser = getDateFormat();\n-\n-            \/\/ Perform the requested parsing\n-            return parser.parse(value);\n-        } catch (ParseException ex) {\n-            throw new RuntimeException(ex);\n+            return dateFormat.parse(string);\n+        } catch (ParseException e) {\n+            throw new RuntimeException(e);\n@@ -177,12 +133,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(Date value) {\n-        \/\/ If the specified value is null, return a zero-length String\n-        if (value == null) {\n-            return \"\";\n-        }\n-\n-        \/\/ Create and configure the formatter to be used\n-        DateFormat formatter = getDateFormat();\n-\n-        \/\/ Perform the requested formatting\n-        return formatter.format(value);\n+    @Override\n+    String toStringFromNonNull(Date data) {\n+        return dateFormat.format(data);\n@@ -191,9 +138,3 @@\n-    \/\/ --------------------------------------------------------- Private Methods\n-\n-    \/**\n-     * <p>Returns a <code>DateFormat<\/code> instance to use for formatting\n-     * and parsing in this {@link StringConverter}.<\/p>\n-     *\n-     * @return a {@code DateFormat} instance for formatting and parsing in this\n-     * {@link StringConverter}\n-     *\/\n+    \/\/\/ {@return the `DateFormat` used for formatting and parsing in this `DateTimeStringConverter`}\n+    \/\/\/\n+    \/\/\/ Used in tests only.\n@@ -201,13 +142,1 @@\n-        DateFormat df = null;\n-\n-        if (dateFormat != null) {\n-            return dateFormat;\n-        } else if (pattern != null) {\n-            df = new SimpleDateFormat(pattern, locale);\n-        } else {\n-            df = DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);\n-        }\n-\n-        df.setLenient(false);\n-\n-        return df;\n+        return dateFormat;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/DateTimeStringConverter.java","additions":75,"deletions":146,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -30,4 +30,3 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link String} values.<\/p>\n- * @since JavaFX 2.1\n- *\/\n+\/\/\/ A `StringConverter` implementation for `String` values.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n@@ -36,3 +35,1 @@\n-    \/**\n-     * Creates a default {@code DefaultStringConverter}.\n-     *\/\n+    \/\/\/ Creates a default {@code DefaultStringConverter}.\n@@ -42,3 +39,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(String value) {\n-        return (value != null) ? value : \"\";\n+    @Override\n+    public String toString(String string) {\n+        return string == null ? \"\" : string;\n@@ -47,3 +44,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public String fromString(String value) {\n-        return value;\n+    @Override\n+    public String fromString(String string) {\n+        return string;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/DefaultStringConverter.java","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,1 +28,5 @@\n-import javafx.util.StringConverter;\n+\/\/\/ A `StringConverter` implementation for `Double` (and `double`) values. Formatting is done by [Double#toString()] for\n+\/\/\/ non-`null` values, and parsing with [Double#valueOf(String)] for non-`null` non-empty strings.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n+public class DoubleStringConverter extends BaseStringConverter<Double> {\n@@ -30,10 +34,1 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link Double}\n- * (and double primitive) values.<\/p>\n- * @since JavaFX 2.1\n- *\/\n-public class DoubleStringConverter extends StringConverter<Double> {\n-\n-    \/**\n-     * Creates a default {@code DoubleStringConverter}.\n-     *\/\n+    \/\/\/ Creates a default `DoubleStringConverter`.\n@@ -43,24 +38,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public Double fromString(String value) {\n-        \/\/ If the specified value is null or zero-length, return null\n-        if (value == null) {\n-            return null;\n-        }\n-\n-        value = value.trim();\n-\n-        if (value.length() < 1) {\n-            return null;\n-        }\n-\n-        return Double.valueOf(value);\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(Double value) {\n-        \/\/ If the specified value is null, return a zero-length String\n-        if (value == null) {\n-            return \"\";\n-        }\n-\n-        return Double.toString(value.doubleValue());\n+    @Override\n+    Double fromNonEmptyString(String string) {\n+        return Double.valueOf(string);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/DoubleStringConverter.java","additions":9,"deletions":35,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -28,1 +28,5 @@\n-import javafx.util.StringConverter;\n+\/\/\/ A `StringConverter` implementation for `Float` (and `float`) values. Formatting is done by [Float#toString()] for\n+\/\/\/ non-`null` values, and parsing with [Float#valueOf(String)] for non-`null` non-empty strings.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n+public class FloatStringConverter extends BaseStringConverter<Float> {\n@@ -30,10 +34,1 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link Float}\n- * (and float primitive) values.<\/p>\n- * @since JavaFX 2.1\n- *\/\n-public class FloatStringConverter extends StringConverter<Float> {\n-\n-    \/**\n-     * Creates a default {@code FloatStringConverter}.\n-     *\/\n+    \/\/\/ Creates a default {@code FloatStringConverter}.\n@@ -43,24 +38,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public Float fromString(String value) {\n-        \/\/ If the specified value is null or zero-length, return null\n-        if (value == null) {\n-            return null;\n-        }\n-\n-        value = value.trim();\n-\n-        if (value.length() < 1) {\n-            return null;\n-        }\n-\n-        return Float.valueOf(value);\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(Float value) {\n-        \/\/ If the specified value is null, return a zero-length String\n-        if (value == null) {\n-            return \"\";\n-        }\n-\n-        return Float.toString(value.floatValue());\n+    @Override\n+    Float fromNonEmptyString(String string) {\n+        return Float.valueOf(string);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/FloatStringConverter.java","additions":9,"deletions":35,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -28,12 +28,3 @@\n-import java.text.*;\n-import javafx.beans.NamedArg;\n-import javafx.util.StringConverter;\n-\n-\/**\n- * <p>{@link StringConverter} implementation that can use a {@link Format}\n- * instance.<\/p>\n- *\n- * @param <T> the type of the object being converted\n- * @since JavaFX 2.2\n- *\/\n-public class FormatStringConverter<T> extends StringConverter<T> {\n+import java.text.Format;\n+import java.text.ParsePosition;\n+import java.util.Objects;\n@@ -41,1 +32,1 @@\n-    \/\/ ------------------------------------------------------ Private properties\n+import javafx.beans.NamedArg;\n@@ -43,1 +34,5 @@\n-    final Format format;\n+\/\/\/ A `StringConverter` implementation that can use a [Format] instance to convert arbitrary types to and from a string.\n+\/\/\/\n+\/\/\/ @param <T> the type converted to\/from a string\n+\/\/\/ @since JavaFX 2.2\n+public class FormatStringConverter<T> extends BaseStringConverter<T> {\n@@ -45,1 +40,1 @@\n-    \/\/ ------------------------------------------------------------ Constructors\n+    private final Format format;\n@@ -47,4 +42,4 @@\n-    \/**\n-     * Creates a {@code FormatStringConverter} for the given {@code Format} instance.\n-     * @param format the {@code Format} instance\n-     *\/\n+    \/\/\/ Creates a `StringConverter` for arbitrary types that uses the given `Format`.\n+    \/\/\/\n+    \/\/\/ @param format the formatter\/parser that will be used by the `toString()` and `fromString()` methods. Must not be\n+    \/\/\/        `null`.\n@@ -52,0 +47,1 @@\n+        Objects.requireNonNull(format);\n@@ -55,23 +51,6 @@\n-    \/\/ ------------------------------------------------------- Converter Methods\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public T fromString(String value) {\n-        \/\/ If the specified value is null or zero-length, return null\n-        if (value == null) {\n-            return null;\n-        }\n-\n-        value = value.trim();\n-\n-        if (value.length() < 1) {\n-            return null;\n-        }\n-\n-        \/\/ Create and configure the parser to be used\n-        Format _format = getFormat();\n-\n-        \/\/ Perform the requested parsing, and attempt to conver the output\n-        \/\/ back to T\n-        final ParsePosition pos = new ParsePosition(0);\n-        T result = (T) _format.parseObject(value, pos);\n-        if (pos.getIndex() != value.length()) {\n+    @Override\n+    T fromNonEmptyString(String string) {\n+        var pos = new ParsePosition(0);\n+        @SuppressWarnings(\"unchecked\")\n+        T result = (T) format.parseObject(string, pos);\n+        if (pos.getIndex() != string.length()) {\n@@ -83,12 +62,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(T value) {\n-        \/\/ If the specified value is null, return a zero-length String\n-        if (value == null) {\n-            return \"\";\n-        }\n-\n-        \/\/ Create and configure the formatter to be used\n-        Format _format = getFormat();\n-\n-        \/\/ Perform the requested formatting\n-        return _format.format(value);\n+    @Override\n+    String toStringFromNonNull(T object) {\n+        return format.format(object);\n@@ -97,6 +67,1 @@\n-    \/**\n-     * <p>Return a <code>Format<\/code> instance to use for formatting\n-     * and parsing in this {@link StringConverter}.<\/p>\n-     *\n-     * @return a {@code Format} instance for formatting and parsing in this {@link StringConverter}\n-     *\/\n+    \/\/\/ {@return the `Format` instance for formatting and parsing in this `StringConverter`}\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/FormatStringConverter.java","additions":25,"deletions":60,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -28,1 +28,5 @@\n-import javafx.util.StringConverter;\n+\/\/\/ A `StringConverter` implementation for `Integer` (and `int`) values. Formatting is done by [Integer#toString()] for\n+\/\/\/ non-`null` values, and parsing with [Integer#valueOf(String)] for non-`null` non-empty strings.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n+public class IntegerStringConverter extends BaseStringConverter<Integer> {\n@@ -30,10 +34,1 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link Integer}\n- * (and int primitive) values.<\/p>\n- * @since JavaFX 2.1\n- *\/\n-public class IntegerStringConverter extends StringConverter<Integer> {\n-\n-    \/**\n-     * Creates a default {@code IntegerStringConverter}.\n-     *\/\n+    \/\/\/ Creates a default `IntegerStringConverter`.\n@@ -43,24 +38,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public Integer fromString(String value) {\n-        \/\/ If the specified value is null or zero-length, return null\n-        if (value == null) {\n-            return null;\n-        }\n-\n-        value = value.trim();\n-\n-        if (value.length() < 1) {\n-            return null;\n-        }\n-\n-        return Integer.valueOf(value);\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(Integer value) {\n-        \/\/ If the specified value is null, return a zero-length String\n-        if (value == null) {\n-            return \"\";\n-        }\n-\n-        return (Integer.toString(value.intValue()));\n+    @Override\n+    Integer fromNonEmptyString(String string) {\n+        return Integer.valueOf(string);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/IntegerStringConverter.java","additions":9,"deletions":35,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.time.temporal.TemporalQuery;\n@@ -34,0 +35,1 @@\n+import java.util.Objects;\n@@ -35,2 +37,6 @@\n-import javafx.util.StringConverter;\n-import javafx.util.converter.LocalDateTimeStringConverter.LdtConverter;\n+\/\/\/ A `StringConverter` implementation for [LocalDate] values.\n+\/\/\/\n+\/\/\/ @see LocalTimeStringConverter\n+\/\/\/ @see LocalDateTimeStringConverter\n+\/\/\/ @since JavaFX 8u40\n+public class LocalDateStringConverter extends BaseTemporalStringConverter<LocalDate> {\n@@ -38,27 +44,11 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link LocalDate} values.<\/p>\n- *\n- * @see LocalTimeStringConverter\n- * @see LocalDateTimeStringConverter\n- * @since JavaFX 8u40\n- *\/\n-public class LocalDateStringConverter extends StringConverter<LocalDate> {\n-\n-    LdtConverter<LocalDate> ldtConverter;\n-\n-    \/\/ ------------------------------------------------------------ Constructors\n-\n-    \/**\n-     * Create a {@link StringConverter} for {@link LocalDate} values, using a\n-     * default formatter and parser based on {@link IsoChronology},\n-     * {@link FormatStyle#SHORT}, and the user's {@link Locale}.\n-     *\n-     * <p>This converter ensures symmetry between the toString() and\n-     * fromString() methods. Many of the default locale based patterns used by\n-     * {@link DateTimeFormatter} will display only two digits for the year when\n-     * formatting to a string. This would cause a value like 1955 to be\n-     * displayed as 55, which in turn would be parsed back as 2055. This\n-     * converter modifies two-digit year patterns to always use four digits. The\n-     * input parsing is not affected, so two digit year values can still be\n-     * parsed leniently as expected in these locales.<\/p>\n-     *\/\n+    \/\/\/ Creates a `LocalDateStringConverter` that uses a formatter and parser based on [IsoChronology],\n+    \/\/\/ [FormatStyle#SHORT], and the user's [Locale].\n+    \/\/\/\n+    \/\/\/ This converter ensures symmetry between the `toString()` and\n+    \/\/\/ `fromString()` methods. Many of the default locale based patterns used by\n+    \/\/\/ [DateTimeFormatter] will display only two digits for the year when\n+    \/\/\/ formatting to a string. This would cause a value like 1955 to be\n+    \/\/\/ displayed as 55, which in turn would be parsed back as 2055. This\n+    \/\/\/ converter modifies two-digit year patterns to always use four digits. The\n+    \/\/\/ input parsing is not affected, so two digit year values can still be\n+    \/\/\/ parsed leniently as expected in these locales.\n@@ -66,2 +56,1 @@\n-        ldtConverter = new LdtConverter<>(LocalDate.class, null, null,\n-                                                  null, null, null, null);\n+        this(null);\n@@ -70,8 +59,5 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link LocalDate} values, using a\n-     * default formatter and parser based on {@link IsoChronology},\n-     * the specified {@link FormatStyle}, and the user's {@link Locale}.\n-     *\n-     * @param dateStyle The {@link FormatStyle} that will be used by the default\n-     * formatter and parser. If null then {@link FormatStyle#SHORT} will be used.\n-     *\/\n+    \/\/\/ Creates a `LocalDateStringConverter` that uses a formatter and parser based on [IsoChronology], the specified\n+    \/\/\/ `FormatStyle`, and the user's [Locale].\n+    \/\/\/\n+    \/\/\/ @param dateStyle the `FormatStyle` that will be used by the formatter and parser. If `null`, [FormatStyle#SHORT]\n+    \/\/\/        will be used.\n@@ -79,30 +65,1 @@\n-        ldtConverter = new LdtConverter<>(LocalDate.class, null, null,\n-                                                  dateStyle, null, null, null);\n-    }\n-\n-    \/**\n-     * Create a {#link StringConverter} for {@link LocalDate} values using the supplied\n-     * formatter and parser.\n-     *\n-     * <p>For example, to use a fixed pattern for converting both ways:<\/p>\n-     * <blockquote><pre>\n-     * String pattern = \"yyyy-MM-dd\";\n-     * DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);\n-     * StringConverter&lt;LocalDate&gt; converter =\n-     *     DateTimeStringConverter.getLocalDateStringConverter(formatter, null);\n-     * <\/pre><\/blockquote>\n-     *\n-     * Note that the formatter and parser can be created to handle non-default\n-     * {@link Locale} and {@link Chronology} as needed.\n-     *\n-     * @param formatter An instance of {@link DateTimeFormatter} that will be\n-     * used for formatting by the toString() method. If null then a default\n-     * formatter will be used.\n-     * @param parser An instance of {@link DateTimeFormatter} that will be used\n-     * for parsing by the fromString() method. This can be identical to\n-     * formatter. If null then formatter will be used, and if that is also null,\n-     * then a default parser will be used.\n-     *\/\n-    public LocalDateStringConverter(DateTimeFormatter formatter, DateTimeFormatter parser) {\n-        ldtConverter = new LdtConverter<>(LocalDate.class, formatter, parser,\n-                                                   null, null, null, null);\n+        this(dateStyle, null, null);\n@@ -111,14 +68,9 @@\n-\n-    \/**\n-     * Create a StringConverter for {@link LocalDate} values using a default\n-     * formatter and parser, which will be based on the supplied\n-     * {@link FormatStyle}, {@link Locale}, and {@link Chronology}.\n-     *\n-     * @param dateStyle The {@link FormatStyle} that will be used by the default\n-     * formatter and parser. If null then {@link FormatStyle#SHORT} will be used.\n-     * @param locale The {@link Locale} that will be used by the default\n-     * formatter and parser. If null then\n-     * {@code Locale.getDefault(Locale.Category.FORMAT)} will be used.\n-     * @param chronology The {@link Chronology} that will be used by the default\n-     * formatter and parser. If null then {@link IsoChronology#INSTANCE} will be used.\n-     *\/\n+    \/\/\/ Creates a `LocalDateStringConverter` that uses a formatter and parser based on the given `FormatStyle`, `Locale`,\n+    \/\/\/ and `Chronology`.\n+    \/\/\/\n+    \/\/\/ @param dateStyle the `FormatStyle` that will be used by the formatter and parser. If `null`, [FormatStyle#SHORT]\n+    \/\/\/        will be used.\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter and parser. If `null`, the user's locale will be\n+    \/\/\/        used.\n+    \/\/\/ @param chronology the `Chronology` that will be used by the formatter and parser. If `null`,\n+    \/\/\/        [IsoChronology#INSTANCE] will be used.\n@@ -126,2 +78,1 @@\n-        ldtConverter = new LdtConverter<>(LocalDate.class, null, null,\n-                                                  dateStyle, null, locale, chronology);\n+        super(Objects.requireNonNullElse(dateStyle, FormatStyle.SHORT), null, locale, chronology);\n@@ -130,5 +81,17 @@\n-    \/\/ ------------------------------------------------------- Converter Methods\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public LocalDate fromString(String value) {\n-        return ldtConverter.fromString(value);\n+    \/\/\/ Creates a `LocalDateStringConverter` that uses the given formatter and parser.\n+    \/\/\/\n+    \/\/\/ For example, to use a fixed pattern for converting both ways:\n+    \/\/\/ {@snippet :\n+    \/\/\/ String pattern = \"yyyy-MM-dd\";\n+    \/\/\/ DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);\n+    \/\/\/ StringConverter<LocalDate> converter = DateTimeStringConverter.getLocalDateStringConverter(formatter, null);\n+    \/\/\/ }\n+    \/\/\/\n+    \/\/\/ Note that the formatter and parser can be created to handle non-default [Locale] and [Chronology] as needed.\n+    \/\/\/\n+    \/\/\/ @param formatter the formatter that will be used by the `toString()` method. If `null`, a default formatter will\n+    \/\/\/        be used.\n+    \/\/\/ @param parser the parser that will be used by the `fromString()` method. This can be identical to formatter. If\n+    \/\/\/        `null`, `formatter` will be used, and if that is also `null`, a default parser will be used.\n+    public LocalDateStringConverter(DateTimeFormatter formatter, DateTimeFormatter parser) {\n+        super(formatter, parser, FormatStyle.SHORT, null);\n@@ -137,3 +100,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(LocalDate value) {\n-        return ldtConverter.toString(value);\n+    @Override\n+    DateTimeFormatter getLocalizedFormatter(FormatStyle dateStyle, FormatStyle timeStyle) {\n+        return DateTimeFormatter.ofLocalizedDate(dateStyle);\n@@ -142,0 +105,4 @@\n+    @Override\n+    TemporalQuery<LocalDate> getTemporalQuery() {\n+        return LocalDate::from;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/LocalDateStringConverter.java","additions":60,"deletions":93,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.time.LocalDate;\n-import java.time.LocalTime;\n@@ -34,2 +32,0 @@\n-import java.time.format.DateTimeFormatterBuilder;\n-import java.time.format.DecimalStyle;\n@@ -37,2 +33,1 @@\n-import java.time.temporal.Temporal;\n-import java.time.temporal.TemporalAccessor;\n+import java.time.temporal.TemporalQuery;\n@@ -40,33 +35,20 @@\n-\n-import javafx.util.StringConverter;\n-\n-\/**\n- * <p>{@link StringConverter} implementation for {@link LocalDateTime} values.<\/p>\n- *\n- * @see LocalDateStringConverter\n- * @see LocalTimeStringConverter\n- * @since JavaFX 8u40\n- *\/\n-public class LocalDateTimeStringConverter extends StringConverter<LocalDateTime> {\n-\n-    LdtConverter<LocalDateTime> ldtConverter;\n-\n-\n-\n-   \/\/ ------------------------------------------------------------ Constructors\n-\n-    \/**\n-     * Create a {@link StringConverter} for {@link LocalDateTime} values, using a\n-     * default formatter and parser based on {@link IsoChronology},\n-     * {@link FormatStyle#SHORT} for both date and time, and the user's\n-     * {@link Locale}.\n-     *\n-     * <p>This converter ensures symmetry between the toString() and\n-     * fromString() methods. Many of the default locale based patterns used by\n-     * {@link DateTimeFormatter} will display only two digits for the year when\n-     * formatting to a string. This would cause a value like 1955 to be\n-     * displayed as 55, which in turn would be parsed back as 2055. This\n-     * converter modifies two-digit year patterns to always use four digits. The\n-     * input parsing is not affected, so two digit year values can still be\n-     * parsed as expected in these locales.<\/p>\n-     *\/\n+import java.util.Objects;\n+\n+\/\/\/ A `StringConverter` implementation for [LocalDateTime] values.\n+\/\/\/\n+\/\/\/ @see LocalDateStringConverter\n+\/\/\/ @see LocalTimeStringConverter\n+\/\/\/ @since JavaFX 8u40\n+public class LocalDateTimeStringConverter extends BaseTemporalStringConverter<LocalDateTime> {\n+\n+    \/\/\/ Creates a `LocalDateTimeStringConverter` that uses a formatter and parser based on [IsoChronology],\n+    \/\/\/ [FormatStyle#SHORT] for both date and time, and the user's [Locale].\n+    \/\/\/\n+    \/\/\/ This converter ensures symmetry between the `toString()` and\n+    \/\/\/ `fromString()` methods. Many of the default locale based patterns used by\n+    \/\/\/ [DateTimeFormatter] will display only two digits for the year when\n+    \/\/\/ formatting to a string. This would cause a value like 1955 to be\n+    \/\/\/ displayed as 55, which in turn would be parsed back as 2055. This\n+    \/\/\/ converter modifies two-digit year patterns to always use four digits. The\n+    \/\/\/ input parsing is not affected, so two digit year values can still be\n+    \/\/\/ parsed as expected in these locales.\n@@ -74,2 +56,1 @@\n-        ldtConverter = new LdtConverter<>(LocalDateTime.class, null, null,\n-                                                       null, null, null, null);\n+        this(null, null, null, null);\n@@ -78,13 +59,7 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link LocalDateTime} values, using\n-     * a default formatter and parser based on {@link IsoChronology}, the\n-     * specified {@link FormatStyle} values for date and time, and the user's\n-     * {@link Locale}.\n-     *\n-     * @param dateStyle The {@link FormatStyle} that will be used by the default\n-     * formatter and parser for the date. If null then {@link FormatStyle#SHORT}\n-     * will be used.\n-     * @param timeStyle The {@link FormatStyle} that will be used by the default\n-     * formatter and parser for the time. If null then {@link FormatStyle#SHORT}\n-     * will be used.\n-     *\/\n+    \/\/\/ Creates a `LocalDateTimeStringConverter` that uses a formatter and parser based on [IsoChronology], the given\n+    \/\/\/ `FormatStyle` values for date and time, and the user's [Locale].\n+    \/\/\/\n+    \/\/\/ @param dateStyle the `FormatStyle` that will be used by the formatter and parser for the date. If `null`,\n+    \/\/\/        [FormatStyle#SHORT] will be used.\n+    \/\/\/ @param timeStyle the `FormatStyle` that will be used by the formatter and parser for the time. If `null`,\n+    \/\/\/        `FormatStyle.SHORT` will be used.\n@@ -92,30 +67,1 @@\n-        ldtConverter = new LdtConverter<>(LocalDateTime.class, null, null,\n-                                                       dateStyle, timeStyle, null, null);\n-    }\n-\n-    \/**\n-     * Create a {@link StringConverter} for {@link LocalDateTime} values using\n-     * the supplied formatter and parser.\n-     *\n-     * <p>For example, to use a fixed pattern for converting both ways:<\/p>\n-     * <blockquote><pre>\n-     * String pattern = \"yyyy-MM-dd HH:mm\";\n-     * DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);\n-     * StringConverter&lt;LocalDateTime&gt; converter =\n-     *     DateTimeStringConverter.getLocalDateTimeConverter(formatter, null);\n-     * <\/pre><\/blockquote>\n-     *\n-     * Note that the formatter and parser can be created to handle non-default\n-     * {@link Locale} and {@link Chronology} as needed.\n-     *\n-     * @param formatter An instance of {@link DateTimeFormatter} which will be\n-     * used for formatting by the toString() method. If null then a default\n-     * formatter will be used.\n-     * @param parser An instance of {@link DateTimeFormatter} which will be used\n-     * for parsing by the fromString() method. This can be identical to\n-     * formatter. If null then formatter will be used, and if that is also null,\n-     * then a default parser will be used.\n-     *\/\n-    public LocalDateTimeStringConverter(DateTimeFormatter formatter, DateTimeFormatter parser) {\n-        ldtConverter = new LdtConverter<>(LocalDateTime.class, formatter, parser,\n-                                                       null, null, null, null);\n+        this(dateStyle, timeStyle, null, null);\n@@ -124,22 +70,15 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link LocalDateTime} values using a\n-     * default formatter and parser, which will be based on the supplied\n-     * {@link FormatStyle}s, {@link Locale}, and {@link Chronology}.\n-     *\n-     * @param dateStyle The {@link FormatStyle} that will be used by the default\n-     * formatter and parser for the date. If null then {@link FormatStyle#SHORT}\n-     * will be used.\n-     * @param timeStyle The {@link FormatStyle} that will be used by the default\n-     * formatter and parser for the time. If null then {@link FormatStyle#SHORT}\n-     * will be used.\n-     * @param locale The {@link Locale} that will be used by the\n-     * default formatter and parser. If null then\n-     * {@code Locale.getDefault(Locale.Category.FORMAT)} will be used.\n-     * @param chronology The {@link Chronology} that will be used by the default\n-     * formatter and parser. If null then {@link IsoChronology#INSTANCE} will be\n-     * used.\n-     *\/\n-    public LocalDateTimeStringConverter(FormatStyle dateStyle, FormatStyle timeStyle,\n-                                        Locale locale, Chronology chronology) {\n-        ldtConverter = new LdtConverter<>(LocalDateTime.class, null, null,\n-                                                       dateStyle, timeStyle, locale, chronology);\n+    \/\/\/ Creates a `LocalDateTimeStringConverter` that uses a formatter and parser based on the given `FormatStyle`s,\n+    \/\/\/ `Locale`, and `Chronology`.\n+    \/\/\/\n+    \/\/\/ @param dateStyle the `FormatStyle` that will be used by the formatter and parser for the date. If `null`,\n+    \/\/\/        [FormatStyle#SHORT] will be used.\n+    \/\/\/ @param timeStyle the `FormatStyle` that will be used by the formatter and parser for the time. If `null`,\n+    \/\/\/        `FormatStyle.SHORT` will be used.\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter and parser. If `null`, the user's locale will be\n+    \/\/\/        used.\n+    \/\/\/ @param chronology the `Chronology` that will be used by the formatter and parser. If `null`,\n+    \/\/\/        [IsoChronology#INSTANCE] will be used.\n+    public LocalDateTimeStringConverter(FormatStyle dateStyle, FormatStyle timeStyle, Locale locale, Chronology chronology) {\n+        \/\/ JEP-513 could make this look better by moving the null checks before super\n+        super(Objects.requireNonNullElse(dateStyle, FormatStyle.SHORT),\n+              Objects.requireNonNullElse(timeStyle, FormatStyle.SHORT), locale, chronology);\n@@ -148,7 +87,17 @@\n-\n-\n-    \/\/ ------------------------------------------------------- Converter Methods\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public LocalDateTime fromString(String value) {\n-        return ldtConverter.fromString(value);\n+    \/\/\/ Creates a `LocalDateTimeStringConverter` that uses the given formatter and parser.\n+    \/\/\/\n+    \/\/\/ For example, to use a fixed pattern for converting both ways:\n+    \/\/\/ {@snippet :\n+    \/\/\/ String pattern = \"yyyy-MM-dd HH:mm\";\n+    \/\/\/ DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);\n+    \/\/\/ StringConverter<LocalDateTime> converter = DateTimeStringConverter.getLocalDateTimeConverter(formatter, null);\n+    \/\/\/ }\n+    \/\/\/\n+    \/\/\/ Note that the formatter and parser can be created to handle non-default [Locale] and [Chronology] as needed.\n+    \/\/\/\n+    \/\/\/ @param formatter the formatter that will be used by the `toString()` method. If `null`, a default formatter will\n+    \/\/\/        be used.\n+    \/\/\/ @param parser the parser that will be used by the `fromString()` method. This can be identical to formatter. If\n+    \/\/\/        `null`, `formatter` will be used, and if that is also `null`, a default parser will be used.\n+    public LocalDateTimeStringConverter(DateTimeFormatter formatter, DateTimeFormatter parser) {\n+        super(formatter, parser, FormatStyle.SHORT, FormatStyle.SHORT);\n@@ -157,3 +106,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(LocalDateTime value) {\n-        return ldtConverter.toString(value);\n+    @Override\n+    DateTimeFormatter getLocalizedFormatter(FormatStyle dateStyle, FormatStyle timeStyle) {\n+        return DateTimeFormatter.ofLocalizedDateTime(dateStyle, timeStyle);\n@@ -162,121 +111,3 @@\n-\n-\n-    static class LdtConverter<T extends Temporal> extends StringConverter<T> {\n-        private Class<T> type;\n-        Locale locale;\n-        Chronology chronology;\n-        DateTimeFormatter formatter;\n-        DateTimeFormatter parser;\n-        FormatStyle dateStyle;\n-        FormatStyle timeStyle;\n-\n-        LdtConverter(Class<T> type, DateTimeFormatter formatter, DateTimeFormatter parser,\n-                     FormatStyle dateStyle, FormatStyle timeStyle, Locale locale, Chronology chronology) {\n-            this.type = type;\n-            this.formatter = formatter;\n-            this.parser = (parser != null) ? parser : formatter;\n-            this.locale = (locale != null) ? locale : Locale.getDefault(Locale.Category.FORMAT);\n-            this.chronology = (chronology != null) ? chronology : IsoChronology.INSTANCE;\n-\n-            if (type == LocalDate.class || type == LocalDateTime.class) {\n-                this.dateStyle = (dateStyle != null) ? dateStyle : FormatStyle.SHORT;\n-            }\n-\n-            if (type == LocalTime.class || type == LocalDateTime.class) {\n-                this.timeStyle = (timeStyle != null) ? timeStyle : FormatStyle.SHORT;\n-            }\n-        }\n-\n-        \/** {@inheritDoc} *\/\n-        @SuppressWarnings({\"unchecked\"})\n-        @Override public T fromString(String text) {\n-            if (text == null || text.isEmpty()) {\n-                return null;\n-            }\n-\n-            text = text.trim();\n-\n-            if (parser == null) {\n-                parser = getDefaultParser();\n-            }\n-\n-            TemporalAccessor temporal = parser.parse(text);\n-\n-            if (type == LocalDate.class) {\n-                return (T) LocalDate.from(temporal);\n-            } else if (type == LocalTime.class) {\n-                return (T) LocalTime.from(temporal);\n-            } else {\n-                return (T) LocalDateTime.from(temporal);\n-            }\n-        }\n-\n-\n-        \/** {@inheritDoc} *\/\n-        @Override public String toString(T value) {\n-            \/\/ If the specified value is null, return a zero-length String\n-            if (value == null) {\n-                return \"\";\n-            }\n-\n-            if (formatter == null) {\n-                formatter = getDefaultFormatter();\n-            }\n-\n-            return formatter.format(value);\n-        }\n-\n-\n-        private DateTimeFormatter getDefaultParser() {\n-            String pattern =\n-                DateTimeFormatterBuilder.getLocalizedDateTimePattern(dateStyle, timeStyle,\n-                                                                     chronology, locale);\n-            return new DateTimeFormatterBuilder().parseLenient()\n-                                                 .appendPattern(pattern)\n-                                                 .toFormatter()\n-                                                 .withChronology(chronology)\n-                                                 .withDecimalStyle(DecimalStyle.of(locale));\n-        }\n-\n-        \/**\n-         * <p>Return a default <code>DateTimeFormatter<\/code> instance to use for formatting\n-         * and parsing in this {@link StringConverter}.<\/p>\n-         *\/\n-        private DateTimeFormatter getDefaultFormatter() {\n-            DateTimeFormatter formatter;\n-\n-            if (dateStyle != null && timeStyle != null) {\n-                formatter = DateTimeFormatter.ofLocalizedDateTime(dateStyle, timeStyle);\n-            } else if (dateStyle != null) {\n-                formatter = DateTimeFormatter.ofLocalizedDate(dateStyle);\n-            } else {\n-                formatter = DateTimeFormatter.ofLocalizedTime(timeStyle);\n-            }\n-\n-            formatter = formatter.withLocale(locale)\n-                                 .withChronology(chronology)\n-                                 .withDecimalStyle(DecimalStyle.of(locale));\n-\n-            if (dateStyle != null) {\n-                formatter = fixFourDigitYear(formatter, dateStyle, timeStyle,\n-                                             chronology, locale);\n-            }\n-\n-            return formatter;\n-        }\n-\n-        private DateTimeFormatter fixFourDigitYear(DateTimeFormatter formatter,\n-                                                   FormatStyle dateStyle, FormatStyle timeStyle,\n-                                                   Chronology chronology, Locale locale) {\n-            String pattern =\n-                DateTimeFormatterBuilder.getLocalizedDateTimePattern(dateStyle, timeStyle,\n-                                                                     chronology, locale);\n-            if (pattern.contains(\"yy\") && !pattern.contains(\"yyy\")) {\n-                \/\/ Modify pattern to show four-digit year, including leading zeros.\n-                String newPattern = pattern.replace(\"yy\", \"yyyy\");\n-                formatter = DateTimeFormatter.ofPattern(newPattern)\n-                                             .withDecimalStyle(DecimalStyle.of(locale));\n-            }\n-\n-            return formatter;\n-        }\n+    @Override\n+    TemporalQuery<LocalDateTime> getTemporalQuery() {\n+        return LocalDateTime::from;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/LocalDateTimeStringConverter.java","additions":68,"deletions":237,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.time.temporal.TemporalQuery;\n@@ -32,0 +33,1 @@\n+import java.util.Objects;\n@@ -33,2 +35,6 @@\n-import javafx.util.StringConverter;\n-import javafx.util.converter.LocalDateTimeStringConverter.LdtConverter;\n+\/\/\/ A `StringConverter` implementation for [LocalTime] values.\n+\/\/\/\n+\/\/\/ @see LocalDateStringConverter\n+\/\/\/ @see LocalDateTimeStringConverter\n+\/\/\/ @since JavaFX 8u40\n+public class LocalTimeStringConverter extends BaseTemporalStringConverter<LocalTime> {\n@@ -36,18 +42,2 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link LocalTime} values.<\/p>\n- *\n- * @see LocalDateStringConverter\n- * @see LocalDateTimeStringConverter\n- * @since JavaFX 8u40\n- *\/\n-public class LocalTimeStringConverter extends StringConverter<LocalTime> {\n-\n-    LdtConverter<LocalTime> ldtConverter;\n-\n-    \/\/ ------------------------------------------------------------ Constructors\n-\n-    \/**\n-     * Create a {@link StringConverter} for {@link LocalTime} values, using a\n-     * default formatter and parser with {@link FormatStyle#SHORT}, and the\n-     * user's {@link Locale}.\n-     *\/\n+    \/\/\/ Creates a `LocalTimeStringConverter` that uses a formatter and parser based on [FormatStyle#SHORT], and the\n+    \/\/\/ user's [Locale].\n@@ -55,2 +45,1 @@\n-        ldtConverter = new LdtConverter<>(LocalTime.class, null, null,\n-                                                  null, null, null, null);\n+        this(null);\n@@ -59,8 +48,5 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link LocalTime} values, using a\n-     * default formatter and parser with the specified {@link FormatStyle} and\n-     * based on the user's {@link Locale}.\n-     *\n-     * @param timeStyle The {@link FormatStyle} that will be used by the default\n-     * formatter and parser. If null then {@link FormatStyle#SHORT} will be used.\n-     *\/\n+    \/\/\/ Creates a `LocalTimeStringConverter` that uses a formatter and parser based on the specified `FormatStyle` and\n+    \/\/\/ the user's [Locale].\n+    \/\/\/\n+    \/\/\/ @param timeStyle the `FormatStyle` that will be used by the formatter and parser. If `null`, [FormatStyle#SHORT]\n+    \/\/\/        will be used.\n@@ -68,2 +54,1 @@\n-        ldtConverter = new LdtConverter<>(LocalTime.class, null, null,\n-                                                  null, timeStyle, null, null);\n+        this(timeStyle, null);\n@@ -72,11 +57,7 @@\n-    \/**\n-     * Create a StringConverter for {@link LocalTime} values, using a\n-     * default formatter and parser with the specified {@link FormatStyle}\n-     * and {@link Locale}.\n-     *\n-     * @param timeStyle The {@link FormatStyle} that will be used by the default\n-     * formatter and parser. If null then {@link FormatStyle#SHORT} will be used.\n-     * @param locale The {@link Locale} that will be used by the default\n-     * formatter and parser. If null then\n-     * {@code Locale.getDefault(Locale.Category.FORMAT)} will be used.\n-     *\/\n+    \/\/\/ Creates a `LocalTimeStringConverter` that uses a formatter and parser based on the specified `FormatStyle` and\n+    \/\/\/ `Locale`.\n+    \/\/\/\n+    \/\/\/ @param timeStyle The `FormatStyle` that will be used by the formatter and parser. If `null`, [FormatStyle#SHORT]\n+    \/\/\/        will be used.\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter and parser. If `null`, the user's locale will be\n+    \/\/\/        used.\n@@ -84,2 +65,1 @@\n-        ldtConverter = new LdtConverter<>(LocalTime.class, null, null,\n-                                                  null, timeStyle, locale, null);\n+        super(null, Objects.requireNonNullElse(timeStyle, FormatStyle.SHORT), locale, null);\n@@ -88,22 +68,13 @@\n-    \/**\n-     * Create a StringConverter for {@link LocalTime} values using the\n-     * supplied formatter and parser, which are responsible for\n-     * choosing the desired {@link Locale}.\n-     *\n-     * <p>For example, a fixed pattern can be used for converting both ways:<\/p>\n-     * <blockquote><pre>\n-     * String pattern = \"HH:mm:ss\";\n-     * DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);\n-     * StringConverter&lt;LocalTime&gt; converter =\n-     *     DateTimeStringConverter.getLocalTimeConverter(formatter, null);\n-     * <\/pre><\/blockquote>\n-     *\n-     * @param formatter An instance of {@link DateTimeFormatter} which\n-     * will be used for formatting by the toString() method. If null\n-     * then a default formatter will be used.\n-     * @param parser An instance of {@link DateTimeFormatter} which\n-     * will be used for parsing by the fromString() method. This can\n-     * be identical to formatter. If null, then formatter will be\n-     * used, and if that is also null, then a default parser will be\n-     * used.\n-     *\/\n+    \/\/\/ Creates a `LocalTimeStringConverter` that uses the given formatter and parser.\n+    \/\/\/\n+    \/\/\/ For example, a fixed pattern can be used for converting both ways:\n+    \/\/\/ {@snippet :\n+    \/\/\/ String pattern = \"HH:mm:ss\";\n+    \/\/\/ DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);\n+    \/\/\/ StringConverter<LocalTime> converter = DateTimeStringConverter.getLocalTimeConverter(formatter, null);\n+    \/\/\/ }\n+    \/\/\/\n+    \/\/\/ @param formatter the formatter that will be used by the `toString()` method. If `null`, a default formatter will\n+    \/\/\/        be used.\n+    \/\/\/ @param parser the parser that will be used by the `fromString()` method. This can be identical to formatter. If\n+    \/\/\/        `null`, `formatter` will be used, and if that is also `null`, a default parser will be used.\n@@ -111,2 +82,1 @@\n-        ldtConverter = new LdtConverter<>(LocalTime.class, formatter, parser,\n-                                                   null, null, null, null);\n+        super(formatter, parser, null, FormatStyle.SHORT);\n@@ -115,5 +85,3 @@\n-    \/\/ ------------------------------------------------------- Converter Methods\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public LocalTime fromString(String value) {\n-        return ldtConverter.fromString(value);\n+    @Override\n+    DateTimeFormatter getLocalizedFormatter(FormatStyle dateStyle, FormatStyle timeStyle) {\n+        return DateTimeFormatter.ofLocalizedTime(timeStyle);\n@@ -122,3 +90,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(LocalTime value) {\n-        return ldtConverter.toString(value);\n+    @Override\n+    TemporalQuery<LocalTime> getTemporalQuery() {\n+        return LocalTime::from;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/LocalTimeStringConverter.java","additions":45,"deletions":77,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-import javafx.util.StringConverter;\n+\/\/\/ A `StringConverter` implementation for `Long` (and `long`) values.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n+public class LongStringConverter extends BaseStringConverter<Long> {\n@@ -30,10 +33,1 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link Long}\n- * (and long primitive) values.<\/p>\n- * @since JavaFX 2.1\n- *\/\n-public class LongStringConverter extends StringConverter<Long> {\n-\n-    \/**\n-     * Creates a default {@code LongStringConverter}.\n-     *\/\n+    \/\/\/ Creates a default `LongStringConverter`.\n@@ -43,24 +37,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public Long fromString(String value) {\n-        \/\/ If the specified value is null or zero-length, return null\n-        if (value == null) {\n-            return null;\n-        }\n-\n-        value = value.trim();\n-\n-        if (value.length() < 1) {\n-            return null;\n-        }\n-\n-        return Long.valueOf(value);\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(Long value) {\n-        \/\/ If the specified value is null, return a zero-length String\n-        if (value == null) {\n-            return \"\";\n-        }\n-\n-        return Long.toString(value.longValue());\n+    @Override\n+    Long fromNonEmptyString(String string) {\n+        return Long.valueOf(string);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/LongStringConverter.java","additions":8,"deletions":35,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import javafx.util.StringConverter;\n+import java.util.Objects;\n@@ -35,6 +35,4 @@\n-\/**\n- * A {@link StringConverter} implementation for {@link Number} values. Instances of this class are immutable.\n- *\n- * @since JavaFX 2.1\n- *\/\n-public class NumberStringConverter extends StringConverter<Number> {\n+\/\/\/ A `StringConverter` implementation for `Number` values.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n+public class NumberStringConverter extends BaseStringConverter<Number> {\n@@ -42,3 +40,1 @@\n-    final Locale locale;\n-    final String pattern;\n-    final NumberFormat numberFormat;\n+    private final NumberFormat numberFormat;\n@@ -46,3 +42,1 @@\n-    \/**\n-     * Constructs a {@code NumberStringConverter} with the default locale and format.\n-     *\/\n+    \/\/\/ Creates a `NumberStringConverter` that uses a formatter\/parser based on the user's [Locale].\n@@ -50,1 +44,1 @@\n-        this(Locale.getDefault());\n+        this(null, null);\n@@ -53,5 +47,3 @@\n-    \/**\n-     * Constructs a {@code NumberStringConverter} with the given locale and the default format.\n-     *\n-     * @param locale the locale used in determining the number format used to format the string\n-     *\/\n+    \/\/\/ Creates a `NumberStringConverter` that uses a formatter\/parser based on the given locale.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n@@ -62,7 +54,5 @@\n-    \/**\n-     * Constructs a {@code NumberStringConverter} with the default locale and the given decimal format pattern.\n-     *\n-     * @param pattern the string pattern used in determining the number format used to format the string\n-     *\n-     * @see java.text.DecimalFormat\n-     *\/\n+    \/\/\/ Creates a `NumberStringConverter` that uses a formatter\/parser based on the user's [Locale] and the given\n+    \/\/\/ decimal format pattern.\n+    \/\/\/\n+    \/\/\/ @param pattern the pattern describing the number format. If `null`, a default formatter\/parser will be used.\n+    \/\/\/ @see java.text.DecimalFormat\n@@ -70,1 +60,1 @@\n-        this(Locale.getDefault(), pattern);\n+        this(null, pattern);\n@@ -73,8 +63,6 @@\n-    \/**\n-     * Constructs a {@code NumberStringConverter} with the given locale and decimal format pattern.\n-     *\n-     * @param locale the locale used in determining the number format used to format the string\n-     * @param pattern the string pattern used in determining the number format used to format the string\n-     *\n-     * @see java.text.DecimalFormat\n-     *\/\n+    \/\/\/ Creates a `NumberStringConverter` that uses a formatter\/parser based on the given `Locale` and decimal format\n+    \/\/\/ pattern.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n+    \/\/\/ @param pattern the pattern describing the number format. If `null`, a default formatter\/parser will be used.\n+    \/\/\/ @see java.text.DecimalFormat\n@@ -82,1 +70,1 @@\n-        this(locale, pattern, null);\n+        numberFormat = createFormat(locale, pattern);\n@@ -85,5 +73,4 @@\n-    \/**\n-     * Constructs a {@code NumberStringConverter} with the given number format.\n-     *\n-     * @param numberFormat the number format used to format the string\n-     *\/\n+    \/\/\/ Creates a `NumberStringConverter` that uses the given formatter\/parser.\n+    \/\/\/\n+    \/\/\/ @param numberFormat the formatter\/parser that will be used by the `toString()` and `fromString()` methods. If\n+    \/\/\/        `null`, a default formatter\/parser will be used.\n@@ -91,1 +78,1 @@\n-        this(null, null, numberFormat);\n+        this.numberFormat = Objects.requireNonNullElseGet(numberFormat, () -> createFormat(null, null));\n@@ -94,4 +81,4 @@\n-    NumberStringConverter(Locale locale, String pattern, NumberFormat numberFormat) {\n-        this.locale = locale;\n-        this.pattern = pattern;\n-        this.numberFormat = numberFormat;\n+    private NumberFormat createFormat(Locale locale, String pattern) {\n+        locale = Objects.requireNonNullElse(locale, Locale.getDefault());\n+        return pattern != null ? new DecimalFormat(pattern, new DecimalFormatSymbols(locale))\n+                               : getSpecializedNumberFormat(locale);\n@@ -100,22 +87,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public Number fromString(String value) {\n-        try {\n-            \/\/ If the specified value is null or zero-length, return null\n-            if (value == null) {\n-                return null;\n-            }\n-\n-            value = value.trim();\n-\n-            if (value.length() < 1) {\n-                return null;\n-            }\n-\n-            \/\/ Create and configure the parser to be used\n-            NumberFormat parser = getNumberFormat();\n-\n-            \/\/ Perform the requested parsing\n-            return parser.parse(value);\n-        } catch (ParseException ex) {\n-            throw new RuntimeException(ex);\n-        }\n+    \/\/ treat as protected\n+    NumberFormat getSpecializedNumberFormat(Locale locale) {\n+        return NumberFormat.getNumberInstance(locale);\n@@ -124,5 +92,6 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(Number value) {\n-        \/\/ If the specified value is null, return a zero-length String\n-        if (value == null) {\n-            return \"\";\n+    @Override\n+    Number fromNonEmptyString(String string) {\n+        try {\n+            return numberFormat.parse(string);\n+        } catch (ParseException e) {\n+            throw new RuntimeException(e);\n@@ -130,6 +99,0 @@\n-\n-        \/\/ Create and configure the formatter to be used\n-        NumberFormat formatter = getNumberFormat();\n-\n-        \/\/ Perform the requested formatting\n-        return formatter.format(value);\n@@ -138,11 +101,4 @@\n-    \/**\n-     * Returns a {@code NumberFormat} instance to use for formatting\n-     * and parsing in this {@code StringConverter}.\n-     *\n-     * @return a {@code NumberFormat} instance for formatting and parsing in this\n-     * {@code StringConverter}\n-     * @deprecated This method was exposed erroneously and will be removed in a future version.\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"22\")\n-    protected NumberFormat getNumberFormat() {\n-        Locale _locale = locale == null ? Locale.getDefault() : locale;\n+    @Override\n+    String toStringFromNonNull(Number number) {\n+        return numberFormat.format(number);\n+    }\n@@ -150,8 +106,5 @@\n-        if (numberFormat != null) {\n-            return numberFormat;\n-        } else if (pattern != null) {\n-            DecimalFormatSymbols symbols = new DecimalFormatSymbols(_locale);\n-            return new DecimalFormat(pattern, symbols);\n-        } else {\n-            return NumberFormat.getNumberInstance(_locale);\n-        }\n+    \/\/\/ {@return the `NumberFormat` used for formatting and parsing in this `NumberStringConverter`}\n+    \/\/\/\n+    \/\/\/ Used in tests only.\n+    NumberFormat getNumberFormat() {\n+        return numberFormat;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/NumberStringConverter.java","additions":51,"deletions":98,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import javafx.util.StringConverter;\n@@ -32,9 +31,3 @@\n-\/**\n- * A {@link StringConverter} implementation for {@link Number} values that represent percentages. Instances of this class are\n- * immutable.\n- *\n- * @see CurrencyStringConverter\n- * @see NumberStringConverter\n- * @see StringConverter\n- * @since JavaFX 2.1\n- *\/\n+\/\/\/ A `StringConverter` implementation for `Number` values that represent percentages.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n@@ -43,3 +36,1 @@\n-    \/**\n-     * Constructs a {@code PercentageStringConverter} with the default locale and format.\n-     *\/\n+    \/\/\/ Creates a `PercentageStringConverter` that uses a formatter\/parser based on the user's [Locale].\n@@ -47,1 +38,1 @@\n-        this(Locale.getDefault());\n+        super();\n@@ -50,5 +41,3 @@\n-    \/**\n-     * Constructs a {@code PercentageStringConverter} with the given locale and the default format.\n-     *\n-     * @param locale the locale used in determining the number format used to format the string\n-     *\/\n+    \/\/\/ Creates a `PercentageStringConverter` that uses a formatter\/parser based on the given locale.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n@@ -56,1 +45,1 @@\n-        super(locale, null, null);\n+        super(locale);\n@@ -59,5 +48,4 @@\n-    \/**\n-     * Constructs a {@code PercentageStringConverter} with the given number format.\n-     *\n-     * @param numberFormat the number format used to format the string\n-     *\/\n+    \/\/\/ Creates a `PercentageStringConverter` that uses the given formatter\/parser.\n+    \/\/\/\n+    \/\/\/ @param numberFormat the formatter\/parser that will be used by the `toString()` and `fromString()` methods. If\n+    \/\/\/        `null`, a default formatter\/parser will be used.\n@@ -65,1 +53,1 @@\n-        super(null, null, numberFormat);\n+        super(numberFormat);\n@@ -68,5 +56,0 @@\n-    \/**\n-     * @deprecated This method was exposed erroneously and will be removed in a future version.\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"22\")\n-    @SuppressWarnings(\"removal\")\n@@ -74,8 +57,2 @@\n-    public NumberFormat getNumberFormat() {\n-        Locale _locale = locale == null ? Locale.getDefault() : locale;\n-\n-        if (numberFormat != null) {\n-            return numberFormat;\n-        } else {\n-            return NumberFormat.getPercentInstance(_locale);\n-        }\n+    NumberFormat getSpecializedNumberFormat(Locale locale) {\n+        return NumberFormat.getPercentInstance(locale);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/PercentageStringConverter.java","additions":16,"deletions":39,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -28,1 +28,5 @@\n-import javafx.util.StringConverter;\n+\/\/\/ A `StringConverter` implementation for `Short` (and `short`) values. Formatting is done by [Short#toString()] for\n+\/\/\/ non-`null` values, and parsing with [Short#valueOf(String)] for non-`null` non-empty strings.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n+public class ShortStringConverter extends BaseStringConverter<Short> {\n@@ -30,9 +34,1 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link Short} values.<\/p>\n- * @since JavaFX 2.1\n- *\/\n-public class ShortStringConverter extends StringConverter<Short> {\n-\n-    \/**\n-     * Creates a default {@code ShortStringConverter}.\n-     *\/\n+    \/\/\/ Creates a default `ShortStringConverter`.\n@@ -42,25 +38,3 @@\n-    \/** {@inheritDoc} *\/\n-    @Override public Short fromString(String text) {\n-        \/\/ If the specified value is null or zero-length, return null\n-        if (text == null) {\n-            return null;\n-        }\n-\n-        text = text.trim();\n-\n-        if (text.length() < 1) {\n-            return null;\n-        }\n-\n-        return Short.valueOf(text);\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    @Override public String toString(Short value) {\n-        \/\/ If the specified value is null, return a\n-        \/\/ zero-length String\n-        if (value == null) {\n-            return \"\";\n-        }\n-\n-        return Short.toString(value.shortValue());\n+    @Override\n+    Short fromNonEmptyString(String string) {\n+        return Short.valueOf(string);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/ShortStringConverter.java","additions":9,"deletions":35,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.text.SimpleDateFormat;\n@@ -32,1 +31,0 @@\n-import javafx.util.StringConverter;\n@@ -34,8 +32,6 @@\n-\/**\n- * <p>{@link StringConverter} implementation for {@link Date} values that\n- * represent time.<\/p>\n- *\n- * @see DateStringConverter\n- * @see DateTimeStringConverter\n- * @since JavaFX 2.1\n- *\/\n+\/\/\/ A `StringConverter` implementation for [Date] values that represent time.\n+\/\/\/\n+\/\/\/ Note that using `Date` is not recommended in JDK versions where [java.time.LocalTime] is available, in which case\n+\/\/\/ [LocalTimeStringConverter] should be used.\n+\/\/\/\n+\/\/\/ @since JavaFX 2.1\n@@ -44,6 +40,2 @@\n-    \/\/ ------------------------------------------------------------ Constructors\n-\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * {@link DateFormat#DEFAULT} time style.\n-     *\/\n+    \/\/\/ Creates a `TimeStringConverter` that uses a formatter\/parser based on {@link DateFormat#DEFAULT} for the\n+    \/\/\/ time style, and the user's {@link Locale}.\n@@ -51,1 +43,1 @@\n-        this(null, null, null, DateFormat.DEFAULT);\n+        super();\n@@ -54,9 +46,7 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified {@link DateFormat} time style.\n-     *\n-     * @param timeStyle the given formatting style. For example,\n-     * {@link DateFormat#SHORT} for \"h:mm a\" in the US locale.\n-     *\n-     * @since JavaFX 8u40\n-     *\/\n+    \/\/\/ Creates a `TimeStringConverter` that uses a formatter\/parser based on the given time style, and the user's\n+    \/\/\/ {@link Locale}.\n+    \/\/\/\n+    \/\/\/ @param timeStyle the formatting style for times. For example, {@link DateFormat#SHORT} for \"h:mm a\" in the US\n+    \/\/\/        locale.\n+    \/\/\/\n+    \/\/\/ @since JavaFX 8u40\n@@ -64,1 +54,1 @@\n-        this(null, null, null, timeStyle);\n+        super(DateFormat.DEFAULT, timeStyle);\n@@ -67,6 +57,4 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified locale and the {@link DateFormat#DEFAULT} time style.\n-     *\n-     * @param locale the given locale.\n-     *\/\n+    \/\/\/ Creates a `TimeStringConverter` that uses a formatter\/parser based on [DateFormat#DEFAULT] for the time style,\n+    \/\/\/ and the given `Locale`.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n@@ -74,1 +62,1 @@\n-        this(locale, null, null, DateFormat.DEFAULT);\n+        super(locale);\n@@ -77,10 +65,6 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified locale and {@link DateFormat} time style.\n-     *\n-     * @param locale the given locale.\n-     * @param timeStyle the given formatting style. For example,\n-     * {@link DateFormat#SHORT} for \"h:mm a\" in the US locale.\n-     *\n-     * @since JavaFX 8u40\n-     *\/\n+    \/\/\/ Creates a `TimeStringConverter` that uses a formatter\/parser based on the given time style and `Locale`.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n+    \/\/\/ @param timeStyle the formatting style for times. For example, [DateFormat#SHORT] for \"h:mm a\" in the US locale.\n+    \/\/\/\n+    \/\/\/ @since JavaFX 8u40\n@@ -88,1 +72,1 @@\n-        this(locale, null, null, timeStyle);\n+        super(locale, DateFormat.DEFAULT, timeStyle);\n@@ -91,6 +75,4 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified pattern.\n-     *\n-     * @param pattern the pattern describing the time format.\n-     *\/\n+    \/\/\/ Creates a `TimeStringConverter` that uses a formatter\/parser based on the given pattern, and the user's [Locale].\n+    \/\/\/\n+    \/\/\/ @param pattern the pattern describing the time format. If `null`, [DateFormat#DEFAULT] will be used for the time\n+    \/\/\/        style.\n@@ -98,1 +80,1 @@\n-        this(null, pattern, null, DateFormat.DEFAULT);\n+        super(pattern);\n@@ -101,7 +83,5 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified locale and pattern.\n-     *\n-     * @param locale the given locale.\n-     * @param pattern the pattern describing the time format.\n-     *\/\n+    \/\/\/ Creates a `TimeStringConverter` that uses a formatter\/parser based on the given pattern and `Locale`.\n+    \/\/\/\n+    \/\/\/ @param locale the `Locale` that will be used by the formatter\/parser. If `null`, the user's locale will be used.\n+    \/\/\/ @param pattern the pattern describing the time format. If `null`, [DateFormat#DEFAULT] will be used for the time\n+    \/\/\/        style.\n@@ -109,1 +89,1 @@\n-        this(locale, pattern, null, DateFormat.DEFAULT);\n+        super(locale, pattern);\n@@ -112,7 +92,4 @@\n-    \/**\n-     * Create a {@link StringConverter} for {@link Date} values, using the\n-     * specified {@link DateFormat} formatter.\n-     *\n-     * @param dateFormat the {@link DateFormat} to be used for formatting and\n-     * parsing.\n-     *\/\n+    \/\/\/ Creates a `TimeStringConverter` that uses the given formatter\/parser.\n+    \/\/\/\n+    \/\/\/ @param dateFormat the formatter\/parser that will be used by the `toString()` and `fromString()` methods. If\n+    \/\/\/        `null`, a default formatter\/parser will be used.\n@@ -120,5 +97,1 @@\n-        this(null, null, dateFormat, DateFormat.DEFAULT);\n-    }\n-\n-    private TimeStringConverter(Locale locale, String pattern, DateFormat dateFormat, int timeStyle) {\n-        super(locale, pattern, dateFormat, DateFormat.DEFAULT, timeStyle);\n+        super(dateFormat);\n@@ -127,7 +100,0 @@\n-\n-    \/\/ --------------------------------------------------------- Private Methods\n-\n-    \/**\n-     * @deprecated This method was exposed erroneously and will be removed in a future version.\n-     *\/\n-    @Deprecated(forRemoval = true, since = \"22\")\n@@ -135,14 +101,2 @@\n-    protected DateFormat getDateFormat() {\n-        DateFormat df = null;\n-\n-        if (dateFormat != null) {\n-            return dateFormat;\n-        } else if (pattern != null) {\n-            df = new SimpleDateFormat(pattern, locale);\n-        } else {\n-            df = DateFormat.getTimeInstance(timeStyle, locale);\n-        }\n-\n-        df.setLenient(false);\n-\n-        return df;\n+    DateFormat getSpecialziedDateFormat(int dateStyle, int timeStyle, Locale locale) {\n+        return DateFormat.getTimeInstance(timeStyle, locale);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/util\/converter\/TimeStringConverter.java","additions":48,"deletions":94,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.util.converter;\n+\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.Temporal;\n+\n+public class BaseTemporalStringConverterShim {\n+\n+    public static DateTimeFormatter getParser(BaseTemporalStringConverter<? extends Temporal> converter) {\n+        return converter.getParser();\n+    }\n+\n+    public static DateTimeFormatter getFormatter(BaseTemporalStringConverter<? extends Temporal> converter) {\n+        return converter.getFormatter();\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/shims\/java\/javafx\/util\/converter\/BaseTemporalStringConverterShim.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.Locale;\n@@ -33,12 +32,0 @@\n-    public static int getTimeStyle(DateTimeStringConverter tsc) {\n-        return tsc.timeStyle;\n-    }\n-\n-    public static String getPattern(DateTimeStringConverter tsc) {\n-        return tsc.pattern;\n-    }\n-\n-    public static int getDateStyle(DateTimeStringConverter tsc) {\n-        return tsc.dateStyle;\n-    }\n-\n@@ -48,9 +35,0 @@\n-\n-    public static DateFormat getDateFormatVar(DateTimeStringConverter tsc) {\n-        return tsc.dateFormat;\n-    }\n-\n-    public static Locale getLocale(DateTimeStringConverter tsc) {\n-        return tsc.locale;\n-    }\n-\n","filename":"modules\/javafx.base\/src\/shims\/java\/javafx\/util\/converter\/DateTimeStringConverterShim.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javafx.util.converter;\n-\n-import java.time.format.DateTimeFormatter;\n-import java.time.format.FormatStyle;\n-import java.util.Locale;\n-\n-public class LocalDateStringConverterShim {\n-\n-    public static DateTimeFormatter getldtConverterFormatter(LocalDateStringConverter c) {\n-        return c.ldtConverter.formatter;\n-    }\n-    \/\/-----------------------------------------------------\n-\n-    \/\/---------\n-    public static Locale getldtConverterLocale(LocalDateStringConverter c) {\n-        return c.ldtConverter.locale;\n-    }\n-\n-    public static DateTimeFormatter getldtConverterParser(LocalDateStringConverter c) {\n-        return c.ldtConverter.parser;\n-    }\n-\n-    public static FormatStyle getldtConverterTimeStyle(LocalDateStringConverter c) {\n-        return c.ldtConverter.timeStyle;\n-    }\n-\n-    public static FormatStyle getldtConverterDateStyle(LocalDateStringConverter c) {\n-        return c.ldtConverter.dateStyle;\n-    }\n-\n-}\n","filename":"modules\/javafx.base\/src\/shims\/java\/javafx\/util\/converter\/LocalDateStringConverterShim.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javafx.util.converter;\n-\n-import java.time.format.DateTimeFormatter;\n-import java.time.format.FormatStyle;\n-import java.util.Locale;\n-\n-public class LocalDateTimeStringConverterShim {\n-\n-    public static DateTimeFormatter getldtConverterParser(LocalDateTimeStringConverter c) {\n-        return c.ldtConverter.parser;\n-    }\n-\n-    public static DateTimeFormatter getldtConverterFormatter(LocalDateTimeStringConverter c) {\n-        return c.ldtConverter.formatter;\n-    }\n-\n-    public static Locale getldtConverterLocale(LocalDateTimeStringConverter c) {\n-        return c.ldtConverter.locale;\n-    }\n-\n-    public static FormatStyle getldtConverterTimeStyle(LocalDateTimeStringConverter c) {\n-        return c.ldtConverter.timeStyle;\n-    }\n-\n-    public static FormatStyle getldtConverterDateStyle(LocalDateTimeStringConverter c) {\n-        return c.ldtConverter.dateStyle;\n-    }\n-\n-}\n","filename":"modules\/javafx.base\/src\/shims\/java\/javafx\/util\/converter\/LocalDateTimeStringConverterShim.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javafx.util.converter;\n-\n-import java.time.format.DateTimeFormatter;\n-import java.time.format.FormatStyle;\n-import java.util.Locale;\n-\n-public class LocalTimeStringConverterShim {\n-\n-    public static Locale getldtConverterLocale(LocalTimeStringConverter c) {\n-        return c.ldtConverter.locale;\n-    }\n-\n-    public static FormatStyle getldtConverterDateStyle(LocalTimeStringConverter c) {\n-        return c.ldtConverter.dateStyle;\n-    }\n-\n-    public static FormatStyle getldtConverterTimeStyle(LocalTimeStringConverter c) {\n-        return c.ldtConverter.timeStyle;\n-    }\n-\n-    public static DateTimeFormatter getldtConverterParser(LocalTimeStringConverter c) {\n-        return c.ldtConverter.parser;\n-    }\n-\n-    public static DateTimeFormatter getldtConverterFormatter(LocalTimeStringConverter c) {\n-        return c.ldtConverter.formatter;\n-    }\n-}\n","filename":"modules\/javafx.base\/src\/shims\/java\/javafx\/util\/converter\/LocalTimeStringConverterShim.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.Locale;\n@@ -33,5 +32,0 @@\n-    public static NumberFormat getNumberFormatVar(NumberStringConverter nsc) {\n-        return nsc.numberFormat;\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n@@ -41,10 +35,0 @@\n-\n-    public static String getPattern(NumberStringConverter nsc) {\n-        return nsc.pattern;\n-    }\n-\n-    \/\/-----------------------------------------------------\n-    public static Locale getLocale(NumberStringConverter nsc) {\n-        return nsc.locale;\n-    }\n-\n","filename":"modules\/javafx.base\/src\/shims\/java\/javafx\/util\/converter\/NumberStringConverterShim.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n@@ -31,1 +29,0 @@\n-import javafx.util.converter.BigDecimalStringConverter;\n@@ -33,1 +30,2 @@\n-import org.junit.jupiter.api.BeforeEach;\n+import java.math.BigDecimal;\n+\n@@ -36,4 +34,1 @@\n-\/**\n- *\/\n-public class BigDecimalStringConverterTest {\n-    private BigDecimalStringConverter converter;\n+import javafx.util.converter.BigDecimalStringConverter;\n@@ -41,1 +36,1 @@\n-    private final BigDecimal bigDecimal = new BigDecimal(BigInteger.TEN);\n+public class BigDecimalStringConverterTest {\n@@ -43,3 +38,1 @@\n-    @BeforeEach public void setup() {\n-        converter = new BigDecimalStringConverter();\n-    }\n+    private final BigDecimalStringConverter converter = new BigDecimalStringConverter();\n@@ -47,2 +40,3 @@\n-    @Test public void fromString_testValidStringInput() {\n-        assertEquals(bigDecimal, converter.fromString(\"10\"));\n+    @Test\n+    void fromString_testValidStringInput() {\n+        assertEquals(BigDecimal.TEN, converter.fromString(\"10\"));\n@@ -51,2 +45,3 @@\n-    @Test public void fromString_testValidStringInputWithWhiteSpace() {\n-        assertEquals(bigDecimal, converter.fromString(\"      10      \"));\n+    @Test\n+    void fromString_testValidStringInputWithWhiteSpace() {\n+        assertEquals(BigDecimal.TEN, converter.fromString(\"      10      \"));\n@@ -55,2 +50,3 @@\n-    @Test public void toString_testStringInput() {\n-        assertEquals(\"10\", converter.toString(bigDecimal));\n+    @Test\n+    void toString_testStringInput() {\n+        assertEquals(\"10\", converter.toString(BigDecimal.TEN));\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/BigDecimalStringConverterTest.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.math.BigInteger;\n-import javafx.util.converter.BigIntegerStringConverter;\n@@ -32,1 +30,2 @@\n-import org.junit.jupiter.api.BeforeEach;\n+import java.math.BigInteger;\n+\n@@ -35,2 +34,2 @@\n-\/**\n- *\/\n+import javafx.util.converter.BigIntegerStringConverter;\n+\n@@ -38,1 +37,0 @@\n-    private BigIntegerStringConverter converter;\n@@ -40,3 +38,1 @@\n-    @BeforeEach public void setup() {\n-        converter = new BigIntegerStringConverter();\n-    }\n+    private final BigIntegerStringConverter converter = new BigIntegerStringConverter();\n@@ -44,1 +40,2 @@\n-    @Test public void fromString_testValidStringInput() {\n+    @Test\n+    void fromString_testValidStringInput() {\n@@ -48,1 +45,2 @@\n-    @Test public void fromString_testValidStringInputWithWhiteSpace() {\n+    @Test\n+    void fromString_testValidStringInputWithWhiteSpace() {\n@@ -52,1 +50,2 @@\n-    @Test public void toString_testStringInput() {\n+    @Test\n+    void toString_testStringInput() {\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/BigIntegerStringConverterTest.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import javafx.util.converter.BooleanStringConverter;\n@@ -31,1 +30,0 @@\n-import org.junit.jupiter.api.BeforeEach;\n@@ -34,0 +32,2 @@\n+import javafx.util.converter.BooleanStringConverter;\n+\n@@ -35,1 +35,0 @@\n-    private BooleanStringConverter converter;\n@@ -37,3 +36,1 @@\n-    @BeforeEach public void setup() {\n-        converter = new BooleanStringConverter();\n-    }\n+    private final BooleanStringConverter converter = new BooleanStringConverter();\n@@ -41,1 +38,2 @@\n-    @Test public void fromString_testValidStringInput_lowercase_true() {\n+    @Test\n+    void fromString_testValidStringInput_lowercase_true() {\n@@ -45,1 +43,2 @@\n-    @Test public void fromString_testValidStringInput_uppercase_true() {\n+    @Test\n+    void fromString_testValidStringInput_uppercase_true() {\n@@ -49,1 +48,2 @@\n-    @Test public void fromString_testValidStringInput_mixedCase_true() {\n+    @Test\n+    void fromString_testValidStringInput_mixedCase_true() {\n@@ -53,1 +53,2 @@\n-    @Test public void fromString_testValidStringInput_lowercase_false() {\n+    @Test\n+    void fromString_testValidStringInput_lowercase_false() {\n@@ -57,1 +58,2 @@\n-    @Test public void fromString_testValidStringInput_uppercase_false() {\n+    @Test\n+    void fromString_testValidStringInput_uppercase_false() {\n@@ -61,1 +63,2 @@\n-    @Test public void fromString_testValidStringInput_mixedCase_false() {\n+    @Test\n+    void fromString_testValidStringInput_mixedCase_false() {\n@@ -65,1 +68,2 @@\n-    @Test public void fromString_testValidStringInputWithWhiteSpace_true() {\n+    @Test\n+    void fromString_testValidStringInputWithWhiteSpace_true() {\n@@ -69,1 +73,2 @@\n-    @Test public void fromString_testValidStringInputWithWhiteSpace_false() {\n+    @Test\n+    void fromString_testValidStringInputWithWhiteSpace_false() {\n@@ -73,1 +78,2 @@\n-    @Test public void toString_true() {\n+    @Test\n+    void toString_true() {\n@@ -77,1 +83,2 @@\n-    @Test public void toString_false() {\n+    @Test\n+    void toString_false() {\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/BooleanStringConverterTest.java","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import javafx.util.converter.ByteStringConverter;\n@@ -31,1 +30,0 @@\n-import org.junit.jupiter.api.BeforeEach;\n@@ -34,2 +32,2 @@\n-\/**\n- *\/\n+import javafx.util.converter.ByteStringConverter;\n+\n@@ -37,1 +35,0 @@\n-    private ByteStringConverter converter;\n@@ -39,1 +36,1 @@\n-    private final byte byteValue_10 = 10;\n+    private static final byte BYTE_VALUE_10 = 10;\n@@ -41,3 +38,1 @@\n-    @BeforeEach public void setup() {\n-        converter = new ByteStringConverter();\n-    }\n+    private final ByteStringConverter converter = new ByteStringConverter();\n@@ -45,2 +40,3 @@\n-    @Test public void fromString_testValidStringInput() {\n-        assertEquals((Object)byteValue_10, converter.fromString(\"10\"));\n+    @Test\n+    void fromString_testValidStringInput() {\n+        assertEquals(BYTE_VALUE_10, converter.fromString(\"10\"));\n@@ -49,2 +45,3 @@\n-    @Test public void fromString_testValidStringInputWithWhiteSpace() {\n-        assertEquals((Object)byteValue_10, converter.fromString(\"     10     \"));\n+    @Test\n+    void fromString_testValidStringInputWithWhiteSpace() {\n+        assertEquals(BYTE_VALUE_10, converter.fromString(\"     10     \"));\n@@ -53,2 +50,3 @@\n-    @Test public void toString_testStringInput() {\n-        assertEquals(\"10\", converter.toString(byteValue_10));\n+    @Test\n+    void toString_testStringInput() {\n+        assertEquals(\"10\", converter.toString(BYTE_VALUE_10));\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/ByteStringConverterTest.java","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import javafx.util.converter.CharacterStringConverter;\n@@ -31,1 +30,0 @@\n-import org.junit.jupiter.api.BeforeEach;\n@@ -34,4 +32,1 @@\n-\/**\n- *\/\n-public class CharacterStringConverterTest {\n-    private CharacterStringConverter converter;\n+import javafx.util.converter.CharacterStringConverter;\n@@ -39,2 +34,1 @@\n-    private final char char_c = 'c';\n-    private final char char_C = 'C';\n+public class CharacterStringConverterTest {\n@@ -42,3 +36,1 @@\n-    @BeforeEach public void setup() {\n-        converter = new CharacterStringConverter();\n-    }\n+    private final CharacterStringConverter converter = new CharacterStringConverter();\n@@ -46,2 +38,3 @@\n-    @Test public void fromString_testValidStringInput_lowercase() {\n-        assertEquals((Object)char_c, converter.fromString(\"c\"));\n+    @Test\n+    void fromString_testValidStringInput_lowercase() {\n+        assertEquals('c', converter.fromString(\"c\"));\n@@ -50,2 +43,3 @@\n-    @Test public void fromString_testValidStringInput_uppercase() {\n-        assertEquals((Object)char_C, converter.fromString(\"C\"));\n+    @Test\n+    void fromString_testValidStringInput_uppercase() {\n+        assertEquals('C', converter.fromString(\"C\"));\n@@ -54,2 +48,3 @@\n-    @Test public void fromString_testValidStringInput_differentCase_one() {\n-        assertNotSame(char_C, converter.fromString(\"c\"));\n+    @Test\n+    void fromString_testValidStringInput_differentCase_one() {\n+        assertNotSame('C', converter.fromString(\"c\"));\n@@ -58,2 +53,3 @@\n-    @Test public void fromString_testValidStringInput_differentCase_two() {\n-        assertNotSame(char_c, converter.fromString(\"C\"));\n+    @Test\n+    void fromString_testValidStringInput_differentCase_two() {\n+        assertNotSame('c', converter.fromString(\"C\"));\n@@ -62,2 +58,3 @@\n-    @Test public void fromString_testValidStringInputWithWhiteSpace_lowercase() {\n-        assertEquals((Object)char_c, converter.fromString(\"     c     \"));\n+    @Test\n+    void fromString_testValidStringInputWithWhiteSpace_lowercase() {\n+        assertEquals('c', converter.fromString(\"     c     \"));\n@@ -66,2 +63,3 @@\n-    @Test public void fromString_testValidStringInputWithWhiteSpace_uppercase() {\n-        assertEquals((Object)char_C, converter.fromString(\"     C     \"));\n+    @Test\n+    void fromString_testValidStringInputWithWhiteSpace_uppercase() {\n+        assertEquals('C', converter.fromString(\"     C     \"));\n@@ -70,2 +68,3 @@\n-    @Test public void toString_lowercase() {\n-        assertEquals(\"c\", converter.toString(char_c));\n+    @Test\n+    void toString_lowercase() {\n+        assertEquals(\"c\", converter.toString('c'));\n@@ -74,2 +73,3 @@\n-    @Test public void toString_uppercase() {\n-        assertEquals(\"C\", converter.toString(char_C));\n+    @Test\n+    void toString_uppercase() {\n+        assertEquals(\"C\", converter.toString('C'));\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/CharacterStringConverterTest.java","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static test.javafx.util.converter.NumberStringConverterTest.numberFormatOf;\n+\n@@ -29,0 +32,1 @@\n+import java.text.DecimalFormatSymbols;\n@@ -31,4 +35,1 @@\n-import javafx.util.converter.CurrencyStringConverter;\n-import javafx.util.converter.NumberStringConverterShim;\n-import static org.junit.jupiter.api.Assertions.*;\n-import org.junit.jupiter.api.BeforeEach;\n+\n@@ -37,0 +38,2 @@\n+import javafx.util.converter.CurrencyStringConverter;\n+\n@@ -38,1 +41,0 @@\n-    private CurrencyStringConverter converter;\n@@ -40,4 +42,3 @@\n-    @BeforeEach\n-    void setup() {\n-        converter = new CurrencyStringConverter(Locale.US);\n-    }\n+    private static final String PATTERN = \"#,##,###,####\";\n+\n+    private final CurrencyStringConverter usLocaleConverter = new CurrencyStringConverter(Locale.US);\n@@ -47,4 +48,5 @@\n-        CurrencyStringConverter c = new CurrencyStringConverter();\n-        assertEquals(Locale.getDefault(), NumberStringConverterShim.getLocale(c));\n-        assertNull(NumberStringConverterShim.getPattern(c));\n-        assertNull(NumberStringConverterShim.getNumberFormatVar(c));\n+        NumberFormat numberFormat = NumberFormat.getCurrencyInstance(Locale.getDefault());\n+\n+        var csc = new CurrencyStringConverter();\n+\n+        assertEquals(numberFormat, numberFormatOf(csc));\n@@ -55,4 +57,5 @@\n-        CurrencyStringConverter c = new CurrencyStringConverter(Locale.CANADA);\n-        assertEquals(Locale.CANADA, NumberStringConverterShim.getLocale(c));\n-        assertNull(NumberStringConverterShim.getPattern(c));\n-        assertNull(NumberStringConverterShim.getNumberFormatVar(c));\n+        NumberFormat numberFormat = NumberFormat.getCurrencyInstance(Locale.CANADA);\n+\n+        var csc = new CurrencyStringConverter(Locale.CANADA);\n+\n+        assertEquals(numberFormat, numberFormatOf(csc));\n@@ -63,4 +66,6 @@\n-        CurrencyStringConverter c = new CurrencyStringConverter(\"#,##,###,####\");\n-        assertEquals(Locale.getDefault(), NumberStringConverterShim.getLocale(c));\n-        assertEquals(\"#,##,###,####\", NumberStringConverterShim.getPattern(c));\n-        assertNull(NumberStringConverterShim.getNumberFormatVar(c));\n+        var symbols = new DecimalFormatSymbols(Locale.getDefault());\n+        var numberFormat = new DecimalFormat(PATTERN, symbols);\n+\n+        var csc = new CurrencyStringConverter(PATTERN);\n+\n+        assertEquals(numberFormat, numberFormatOf(csc));\n@@ -71,5 +76,2 @@\n-        CurrencyStringConverter c = new CurrencyStringConverter(Locale.CANADA, \"#,##,###,####\");\n-        assertEquals(Locale.CANADA, NumberStringConverterShim.getLocale(c));\n-        assertEquals(\"#,##,###,####\", NumberStringConverterShim.getPattern(c));\n-        assertNull(NumberStringConverterShim.getNumberFormatVar(c));\n-    }\n+        var symbols = new DecimalFormatSymbols(Locale.CANADA);\n+        var numberFormat = new DecimalFormat(PATTERN, symbols);\n@@ -77,8 +79,1 @@\n-    @Test\n-    void testConstructor_numberFormat() {\n-        NumberFormat format = NumberFormat.getCurrencyInstance(Locale.JAPAN);\n-        CurrencyStringConverter c = new CurrencyStringConverter(format);\n-        assertNull(NumberStringConverterShim.getLocale(c));\n-        assertNull(NumberStringConverterShim.getPattern(c));\n-        assertEquals(format, NumberStringConverterShim.getNumberFormatVar(c));\n-    }\n+        var csc = new CurrencyStringConverter(Locale.CANADA, PATTERN);\n@@ -86,3 +81,1 @@\n-    @Test\n-    void getNumberFormat_default() {\n-        assertNotNull(NumberStringConverterShim.getNumberFormat(converter));\n+        assertEquals(numberFormat, numberFormatOf(csc));\n@@ -92,4 +85,2 @@\n-    void getNumberFormat_nonNullPattern() {\n-        converter = new CurrencyStringConverter(\"#,##,###,####\");\n-        assertTrue(NumberStringConverterShim.getNumberFormat(converter) instanceof DecimalFormat);\n-    }\n+    void testConstructor_numberFormat() {\n+        NumberFormat numberFormat = NumberFormat.getCurrencyInstance(Locale.JAPAN);\n@@ -97,5 +88,3 @@\n-    @Test\n-    void getNumberFormat_nonNullNumberFormat() {\n-        NumberFormat nf = NumberFormat.getCurrencyInstance();\n-        converter = new CurrencyStringConverter(nf);\n-        assertEquals(nf, NumberStringConverterShim.getNumberFormat(converter));\n+        var csc = new CurrencyStringConverter(numberFormat);\n+\n+        assertEquals(numberFormat, numberFormatOf(csc));\n@@ -106,1 +95,1 @@\n-        assertEquals(10.32, converter.fromString(\"$10.32\"));\n+        assertEquals(10.32, usLocaleConverter.fromString(\"$10.32\"));\n@@ -111,1 +100,1 @@\n-        assertEquals(10.32, converter.fromString(\"      $10.32      \"));\n+        assertEquals(10.32, usLocaleConverter.fromString(\"      $10.32      \"));\n@@ -116,1 +105,1 @@\n-        assertEquals(\"$10.32\", converter.toString(10.32));\n+        assertEquals(\"$10.32\", usLocaleConverter.toString(10.32));\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/CurrencyStringConverterTest.java","additions":38,"deletions":49,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -30,1 +32,0 @@\n-import java.util.Arrays;\n@@ -34,0 +35,1 @@\n+import java.util.List;\n@@ -36,3 +38,0 @@\n-import javafx.util.converter.DateStringConverter;\n-import javafx.util.converter.DateTimeStringConverterShim;\n-import static org.junit.jupiter.api.Assertions.*;\n@@ -40,0 +39,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -43,2 +43,3 @@\n-\/**\n- *\/\n+import javafx.util.converter.DateStringConverter;\n+import javafx.util.converter.DateTimeStringConverterShim;\n+\n@@ -46,0 +47,2 @@\n+\n+    private static final Locale DEFALUT_LOCALE = Locale.getDefault(Locale.Category.FORMAT);\n@@ -61,26 +64,12 @@\n-    private static Collection implementations() {\n-        return Arrays.asList(new Object[][] {\n-                { new DateStringConverter(),\n-                        Locale.getDefault(Locale.Category.FORMAT), DateFormat.DEFAULT,\n-                        VALID_DATE, null, null },\n-\n-                { new DateStringConverter(DateFormat.SHORT),\n-                        Locale.getDefault(Locale.Category.FORMAT), DateFormat.SHORT,\n-                        VALID_DATE, null, null },\n-\n-                { new DateStringConverter(Locale.UK),\n-                        Locale.UK, DateFormat.DEFAULT,\n-                        VALID_DATE, null, null },\n-\n-                { new DateStringConverter(Locale.UK, DateFormat.SHORT),\n-                        Locale.UK, DateFormat.SHORT,\n-                        VALID_DATE, null, null },\n-\n-                { new DateStringConverter(\"dd MM yyyy\"),\n-                        Locale.getDefault(Locale.Category.FORMAT), DateFormat.DEFAULT,\n-                        VALID_DATE, \"dd MM yyyy\", null },\n-\n-                { new DateStringConverter(DateFormat.getDateInstance(DateFormat.LONG)),\n-                        Locale.getDefault(Locale.Category.FORMAT), DateFormat.DEFAULT,\n-                        VALID_DATE, null, DateFormat.getDateInstance(DateFormat.LONG) },\n-        });\n+    private record TestCase(DateStringConverter converter, Locale locale, int dateStyle, String pattern, DateFormat dateFormat) {}\n+\n+    private static Collection<TestCase> implementations() {\n+        return List.of(\n+                new TestCase(new DateStringConverter(), DEFALUT_LOCALE, DateFormat.DEFAULT, null, null),\n+                new TestCase(new DateStringConverter(DateFormat.SHORT), DEFALUT_LOCALE, DateFormat.SHORT, null, null),\n+                new TestCase(new DateStringConverter(Locale.UK), Locale.UK, DateFormat.DEFAULT, null, null),\n+                new TestCase(new DateStringConverter(Locale.UK, DateFormat.SHORT), Locale.UK, DateFormat.SHORT, null, null),\n+                new TestCase(new DateStringConverter(\"dd MM yyyy\"), DEFALUT_LOCALE, DateFormat.DEFAULT, \"dd MM yyyy\", null),\n+                new TestCase(new DateStringConverter(DateFormat.getDateInstance(DateFormat.LONG)),\n+                        DEFALUT_LOCALE, DateFormat.DEFAULT, null, DateFormat.getDateInstance(DateFormat.LONG))\n+                );\n@@ -89,20 +78,7 @@\n-    private DateStringConverter converter;\n-    private Locale locale;\n-    private int dateStyle;\n-    private String pattern;\n-    private DateFormat dateFormat;\n-    private Date validDate;\n-    private DateFormat validFormatter;\n-\n-    private void setUp(DateStringConverter converter, Locale locale, int dateStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        this.converter = converter;\n-        this.locale = locale;\n-        this.dateStyle = dateStyle;\n-        this.validDate = validDate;\n-        this.pattern = pattern;\n-        this.dateFormat = dateFormat;\n-\n-        if (dateFormat != null) {\n-            validFormatter = dateFormat;\n-        } else if (pattern != null) {\n-            validFormatter = new SimpleDateFormat(pattern);\n+    private static DateFormat createFormatter(TestCase testCase) {\n+        if (testCase.dateFormat() != null) {\n+            return testCase.dateFormat();\n+        }\n+        DateFormat validFormatter;\n+        if (testCase.pattern() != null) {\n+            validFormatter = new SimpleDateFormat(testCase.pattern(), testCase.locale());\n@@ -110,1 +86,1 @@\n-            validFormatter = DateFormat.getDateInstance(dateStyle, locale);\n+            validFormatter = DateFormat.getDateInstance(testCase.dateStyle(), testCase.locale());\n@@ -112,0 +88,2 @@\n+        validFormatter.setLenient(false);\n+        return validFormatter;\n@@ -114,4 +92,0 @@\n-    \/*********************************************************************\n-     * Test constructors\n-     ********************************************************************\/\n-\n@@ -120,6 +94,3 @@\n-    public void testConstructor(DateStringConverter converter, Locale locale, int dateStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, validDate, pattern, dateFormat);\n-        assertEquals(locale, DateTimeStringConverterShim.getLocale(converter));\n-        assertEquals(dateStyle, DateTimeStringConverterShim.getDateStyle(converter));\n-        assertEquals(pattern, DateTimeStringConverterShim.getPattern(converter));\n-        assertEquals(dateFormat, DateTimeStringConverterShim.getDateFormatVar(converter));\n+    void testConstructor(TestCase testCase) {\n+        DateFormat validFormatter = createFormatter(testCase);\n+        assertEquals(validFormatter, DateTimeStringConverterShim.getDateFormat(testCase.converter()));\n@@ -128,20 +99,4 @@\n-\n-    \/*********************************************************************\n-     * Test methods\n-     ********************************************************************\/\n-\n-    @ParameterizedTest\n-    @MethodSource(\"implementations\")\n-    public void getDateFormat(DateStringConverter converter, Locale locale, int dateStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, validDate, pattern, dateFormat);\n-        assertNotNull(DateTimeStringConverterShim.getDateFormat(converter));\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"implementations\")\n-    public void getDateFormat_nonNullPattern(DateStringConverter converter, Locale locale, int dateStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, validDate, pattern, dateFormat);\n-        converter = new DateStringConverter(\"yyyy\");\n-        assertTrue(\n-                DateTimeStringConverterShim.getDateFormat(converter)\n-                        instanceof SimpleDateFormat);\n+    @Test\n+    void getDateFormat_nonNullPattern() {\n+        var converter = new DateStringConverter(\"yyyy\");\n+        assertTrue(DateTimeStringConverterShim.getDateFormat(converter) instanceof SimpleDateFormat);\n@@ -150,4 +105,0 @@\n-    \/*********************************************************************\n-     * Test toString \/ fromString methods\n-     ********************************************************************\/\n-\n@@ -156,4 +107,4 @@\n-    public void fromString_testValidInput(DateStringConverter converter, Locale locale, int dateStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, validDate, pattern, dateFormat);\n-        String input = validFormatter.format(validDate);\n-        assertEquals(validDate, converter.fromString(input), \"Input = \" + input);\n+    public void fromString_testValidInput(TestCase testCase) {\n+        DateFormat validFormatter = createFormatter(testCase);\n+        String input = validFormatter.format(VALID_DATE);\n+        assertEquals(VALID_DATE, testCase.converter().fromString(input), \"Input = \" + input);\n@@ -164,4 +115,4 @@\n-    public void fromString_testValidInputWithWhiteSpace(DateStringConverter converter, Locale locale, int dateStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, validDate, pattern, dateFormat);\n-        String input = validFormatter.format(validDate);\n-        assertEquals(validDate, converter.fromString(\"      \" + input + \"      \"), \"Input = \" + input);\n+    public void fromString_testValidInputWithWhiteSpace(TestCase testCase) {\n+        DateFormat validFormatter = createFormatter(testCase);\n+        String input = validFormatter.format(VALID_DATE);\n+        assertEquals(VALID_DATE, testCase.converter().fromString(\"      \" + input + \"      \"), \"Input = \" + input);\n@@ -172,3 +123,2 @@\n-    public void fromString_testInvalidInput(DateStringConverter converter, Locale locale, int dateStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, validDate, pattern, dateFormat);\n-        assertThrows(RuntimeException.class, () -> converter.fromString(\"abcdefg\"));\n+    public void fromString_testInvalidInput(TestCase testCase) {\n+        assertThrows(RuntimeException.class, () -> testCase.converter().fromString(\"abcdefg\"));\n@@ -179,3 +129,3 @@\n-    public void toString_validOutput(DateStringConverter converter, Locale locale, int dateStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, validDate, pattern, dateFormat);\n-        assertEquals(validFormatter.format(validDate), converter.toString(validDate));\n+    public void toString_validOutput(TestCase testCase) {\n+        DateFormat validFormatter = createFormatter(testCase);\n+        assertEquals(validFormatter.format(VALID_DATE), testCase.converter().toString(VALID_DATE));\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/DateStringConverterTest.java","additions":51,"deletions":101,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -30,1 +32,0 @@\n-import java.util.Arrays;\n@@ -34,0 +35,1 @@\n+import java.util.List;\n@@ -36,3 +38,0 @@\n-import javafx.util.converter.DateTimeStringConverter;\n-import javafx.util.converter.DateTimeStringConverterShim;\n-import static org.junit.jupiter.api.Assertions.*;\n@@ -44,2 +43,3 @@\n-\/**\n- *\/\n+import javafx.util.converter.DateTimeStringConverter;\n+import javafx.util.converter.DateTimeStringConverterShim;\n+\n@@ -47,0 +47,1 @@\n+\n@@ -65,3 +66,6 @@\n-    private static Collection implementations() {\n-        return Arrays.asList(new Object[][] {\n-                { new DateTimeStringConverter(),\n+    private record TestCase(DateTimeStringConverter converter, Locale locale, int dateStyle, int timetyle, String pattern,\n+            DateFormat dateFormat, Date validDate) {}\n+\n+    private static Collection<TestCase> implementations() {\n+        return List.of(\n+                new TestCase(new DateTimeStringConverter(),\n@@ -69,1 +73,1 @@\n-                        VALID_DATE_WITH_SECONDS, null, null },\n+                        null, null, VALID_DATE_WITH_SECONDS),\n@@ -71,1 +75,1 @@\n-                { new DateTimeStringConverter(DateFormat.SHORT, DateFormat.SHORT),\n+                new TestCase(new DateTimeStringConverter(DateFormat.SHORT, DateFormat.SHORT),\n@@ -73,1 +77,1 @@\n-                        VALID_DATE_WITHOUT_SECONDS, null, null },\n+                        null, null, VALID_DATE_WITHOUT_SECONDS),\n@@ -75,1 +79,1 @@\n-                { new DateTimeStringConverter(Locale.UK),\n+                new TestCase(new DateTimeStringConverter(Locale.UK),\n@@ -77,1 +81,1 @@\n-                        VALID_DATE_WITH_SECONDS, null, null },\n+                        null, null, VALID_DATE_WITH_SECONDS),\n@@ -79,1 +83,1 @@\n-                { new DateTimeStringConverter(Locale.UK, DateFormat.SHORT, DateFormat.SHORT),\n+                new TestCase(new DateTimeStringConverter(Locale.UK, DateFormat.SHORT, DateFormat.SHORT),\n@@ -81,1 +85,1 @@\n-                        VALID_DATE_WITHOUT_SECONDS, null, null },\n+                        null, null, VALID_DATE_WITHOUT_SECONDS),\n@@ -83,1 +87,1 @@\n-                { new DateTimeStringConverter(\"dd MM yyyy HH mm ss\"),\n+                new TestCase(new DateTimeStringConverter(\"dd MM yyyy HH mm ss\"),\n@@ -85,1 +89,1 @@\n-                        VALID_DATE_WITH_SECONDS, \"dd MM yyyy HH mm ss\", null },\n+                        \"dd MM yyyy HH mm ss\", null, VALID_DATE_WITH_SECONDS),\n@@ -87,1 +91,1 @@\n-                { new DateTimeStringConverter(DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.FULL)),\n+                new TestCase(new DateTimeStringConverter(DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.FULL)),\n@@ -89,2 +93,2 @@\n-                        VALID_DATE_WITH_SECONDS, null, DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.FULL) },\n-        });\n+                        null, DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.FULL), VALID_DATE_WITH_SECONDS)\n+                );\n@@ -93,22 +97,7 @@\n-    private DateTimeStringConverter converter;\n-    private Locale locale;\n-    private int dateStyle;\n-    private int timeStyle;\n-    private String pattern;\n-    private DateFormat dateFormat;\n-    private Date validDate;\n-    private DateFormat validFormatter;\n-\n-    private void setUp(DateTimeStringConverter converter, Locale locale, int dateStyle, int timeStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        this.converter = converter;\n-        this.locale = locale;\n-        this.dateStyle = dateStyle;\n-        this.timeStyle = timeStyle;\n-        this.validDate = validDate;\n-        this.pattern = pattern;\n-        this.dateFormat = dateFormat;\n-\n-        if (dateFormat != null) {\n-            validFormatter = dateFormat;\n-        } else if (pattern != null) {\n-            validFormatter = new SimpleDateFormat(pattern);\n+    private static DateFormat create(TestCase testCase) {\n+        if (testCase.dateFormat() != null) {\n+            return testCase.dateFormat();\n+        }\n+        DateFormat validFormatter;\n+        if (testCase.pattern() != null) {\n+            validFormatter = new SimpleDateFormat(testCase.pattern(), testCase.locale());\n@@ -116,1 +105,1 @@\n-            validFormatter = DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);\n+            validFormatter = DateFormat.getDateTimeInstance(testCase.dateStyle(), testCase.timetyle(), testCase.locale());\n@@ -118,0 +107,2 @@\n+        validFormatter.setLenient(false);\n+        return validFormatter;\n@@ -120,19 +111,0 @@\n-    \/*********************************************************************\n-     * Test constructors\n-     ********************************************************************\/\n-\n-    @ParameterizedTest\n-    @MethodSource(\"implementations\")\n-    public void testConstructor(DateTimeStringConverter converter, Locale locale, int dateStyle, int timeStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, timeStyle, validDate, pattern, dateFormat);\n-        assertEquals(locale, DateTimeStringConverterShim.getLocale(converter));\n-        assertEquals(dateStyle, DateTimeStringConverterShim.getDateStyle(converter));\n-        assertEquals(pattern, DateTimeStringConverterShim.getPattern(converter));\n-        assertEquals(dateFormat, DateTimeStringConverterShim.getDateFormatVar(converter));\n-        assertEquals(timeStyle, DateTimeStringConverterShim.getTimeStyle(converter));\n-    }\n-\n-    \/*********************************************************************\n-     * Test methods\n-     ********************************************************************\/\n-\n@@ -141,3 +113,3 @@\n-    public void getDateFormat_default(DateTimeStringConverter converter, Locale locale, int dateStyle, int timeStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, timeStyle, validDate, pattern, dateFormat);\n-        assertNotNull(DateTimeStringConverterShim.getDateFormat(converter));\n+    void testConstructor(TestCase testCase) {\n+        DateFormat validFormatter = create(testCase);\n+        assertEquals(validFormatter, DateTimeStringConverterShim.getDateFormat(testCase.converter()));\n@@ -146,7 +118,4 @@\n-    @ParameterizedTest\n-    @MethodSource(\"implementations\")\n-    public void getDateFormat_nonNullPattern(DateTimeStringConverter converter, Locale locale, int dateStyle, int timeStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, timeStyle, validDate, pattern, dateFormat);\n-        converter = new DateTimeStringConverter(\"yyyy\/MM\/dd HH:mm:ss\");\n-        assertTrue(DateTimeStringConverterShim.getDateFormat(converter)\n-                instanceof SimpleDateFormat);\n+    @Test\n+    void getDateFormat_nonNullPattern() {\n+        var converter = new DateTimeStringConverter(\"yyyy\/MM\/dd HH:mm:ss\");\n+        assertTrue(DateTimeStringConverterShim.getDateFormat(converter) instanceof SimpleDateFormat);\n@@ -155,4 +124,0 @@\n-    \/*********************************************************************\n-     * Test toString \/ fromString methods\n-     ********************************************************************\/\n-\n@@ -161,4 +126,4 @@\n-    public void fromString_testValidInput(DateTimeStringConverter converter, Locale locale, int dateStyle, int timeStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, timeStyle, validDate, pattern, dateFormat);\n-        String input = validFormatter.format(validDate);\n-        assertEquals(validDate, converter.fromString(input), \"Input = \" + input);\n+    void fromString_testValidInput(TestCase testCase) {\n+        DateFormat validFormatter = create(testCase);\n+        String input = validFormatter.format(testCase.validDate());\n+        assertEquals(testCase.validDate(), testCase.converter().fromString(input), \"Input = \" + input);\n@@ -169,4 +134,4 @@\n-    public void fromString_testValidInputWithWhiteSpace(DateTimeStringConverter converter, Locale locale, int dateStyle, int timeStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, timeStyle, validDate, pattern, dateFormat);\n-        String input = validFormatter.format(validDate);\n-        assertEquals(validDate, converter.fromString(\"      \" + input + \"      \"), \"Input = \" + input);\n+    void fromString_testValidInputWithWhiteSpace(TestCase testCase) {\n+        DateFormat validFormatter = create(testCase);\n+        String input = validFormatter.format(testCase.validDate());\n+        assertEquals(testCase.validDate(), testCase.converter().fromString(\"      \" + input + \"      \"), \"Input = \" + input);\n@@ -177,3 +142,2 @@\n-    public void fromString_testInvalidInput(DateTimeStringConverter converter, Locale locale, int dateStyle, int timeStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, timeStyle, validDate, pattern, dateFormat);\n-        assertThrows(RuntimeException.class, () -> converter.fromString(\"abcdefg\"));\n+    void fromString_testInvalidInput(TestCase testCase) {\n+        assertThrows(RuntimeException.class, () -> testCase.converter().fromString(\"abcdefg\"));\n@@ -184,3 +148,3 @@\n-    public void toString_validOutput(DateTimeStringConverter converter, Locale locale, int dateStyle, int timeStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        setUp(converter, locale, dateStyle, timeStyle, validDate, pattern, dateFormat);\n-        assertEquals(validFormatter.format(validDate), converter.toString(validDate));\n+    void toString_validOutput(TestCase testCase) {\n+        DateFormat validFormatter = create(testCase);\n+        assertEquals(validFormatter.format(testCase.validDate()), testCase.converter().toString(testCase.validDate()));\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/DateTimeStringConverterTest.java","additions":55,"deletions":91,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import javafx.util.converter.DefaultStringConverter;\n@@ -31,1 +30,0 @@\n-import org.junit.jupiter.api.BeforeEach;\n@@ -34,2 +32,2 @@\n-\/**\n- *\/\n+import javafx.util.converter.DefaultStringConverter;\n+\n@@ -37,1 +35,0 @@\n-    private DefaultStringConverter converter;\n@@ -39,3 +36,1 @@\n-    @BeforeEach public void setup() {\n-        converter = new DefaultStringConverter();\n-    }\n+    private final DefaultStringConverter converter = new DefaultStringConverter();\n@@ -43,1 +38,2 @@\n-    @Test public void fromString_testValidStringInput() {\n+    @Test\n+    public void fromString_testValidStringInput() {\n@@ -47,1 +43,2 @@\n-    @Test public void fromString_testEmptytringInput() {\n+    @Test\n+    public void fromString_testEmptytringInput() {\n@@ -51,1 +48,2 @@\n-    @Test public void toString_testValidStringInput() {\n+    @Test\n+    public void toString_testValidStringInput() {\n@@ -55,1 +53,2 @@\n-    @Test public void toString_testEmptyStringInput() {\n+    @Test\n+    public void toString_testEmptyStringInput() {\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/DefaultStringConverterTest.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import javafx.util.converter.DoubleStringConverter;\n@@ -31,1 +30,0 @@\n-import org.junit.jupiter.api.BeforeEach;\n@@ -34,2 +32,2 @@\n-\/**\n- *\/\n+import javafx.util.converter.DoubleStringConverter;\n+\n@@ -37,1 +35,0 @@\n-    private DoubleStringConverter converter;\n@@ -39,3 +36,1 @@\n-    @BeforeEach public void setup() {\n-        converter = new DoubleStringConverter();\n-    }\n+    private final DoubleStringConverter converter = new DoubleStringConverter();\n@@ -43,2 +38,3 @@\n-    @Test public void fromString_testValidStringInput() {\n-        assertEquals(Double.valueOf(10), converter.fromString(\"10\"));\n+    @Test\n+    void fromString_testValidStringInput() {\n+        assertEquals(10, converter.fromString(\"10\"));\n@@ -47,2 +43,3 @@\n-    @Test public void fromString_testValidStringInputWithWhiteSpace() {\n-        assertEquals(Double.valueOf(10), converter.fromString(\"      10      \"));\n+    @Test\n+    void fromString_testValidStringInputWithWhiteSpace() {\n+        assertEquals(10, converter.fromString(\"      10      \"));\n@@ -51,1 +48,2 @@\n-    @Test public void toString_validInput() {\n+    @Test\n+    void toString_validInput() {\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/DoubleStringConverterTest.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import javafx.util.converter.FloatStringConverter;\n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -31,1 +30,0 @@\n-import org.junit.jupiter.api.BeforeEach;\n@@ -34,2 +32,2 @@\n-\/**\n- *\/\n+import javafx.util.converter.FloatStringConverter;\n+\n@@ -37,1 +35,0 @@\n-    private FloatStringConverter converter;\n@@ -39,3 +36,1 @@\n-    @BeforeEach public void setup() {\n-        converter = new FloatStringConverter();\n-    }\n+    private final FloatStringConverter converter = new FloatStringConverter();\n@@ -43,2 +38,3 @@\n-    @Test public void fromString_testValidStringInput() {\n-        assertEquals((Float)10.3521f, converter.fromString(\"10.3521\"));\n+    @Test\n+    void fromString_testValidStringInput() {\n+        assertEquals(10.3521f, converter.fromString(\"10.3521\"));\n@@ -47,2 +43,3 @@\n-    @Test public void fromString_testValidStringInputWithWhiteSpace() {\n-        assertEquals((Float)10.3521f, converter.fromString(\"      10.3521     \"));\n+    @Test\n+    void fromString_testValidStringInputWithWhiteSpace() {\n+        assertEquals(10.3521f, converter.fromString(\"      10.3521     \"));\n@@ -51,1 +48,2 @@\n-    @Test public void toString_validInput() {\n+    @Test\n+    void toString_validInput() {\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/FloatStringConverterTest.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import javafx.util.converter.IntegerStringConverter;\n@@ -31,1 +30,0 @@\n-import org.junit.jupiter.api.BeforeEach;\n@@ -34,2 +32,2 @@\n-\/**\n- *\/\n+import javafx.util.converter.IntegerStringConverter;\n+\n@@ -37,1 +35,0 @@\n-    private IntegerStringConverter converter;\n@@ -39,3 +36,1 @@\n-    @BeforeEach public void setup() {\n-        converter = new IntegerStringConverter();\n-    }\n+    private final IntegerStringConverter converter = new IntegerStringConverter();\n@@ -43,2 +38,3 @@\n-    @Test public void fromString_testValidStringInput() {\n-        assertEquals((Integer) 10, converter.fromString(\"10\"));\n+    @Test\n+    void fromString_testValidStringInput() {\n+        assertEquals(10, converter.fromString(\"10\"));\n@@ -47,2 +43,3 @@\n-    @Test public void fromString_testValidStringInputWithWhiteSpace() {\n-        assertEquals((Integer) 10, converter.fromString(\"      10      \"));\n+    @Test\n+    void fromString_testValidStringInputWithWhiteSpace() {\n+        assertEquals(10, converter.fromString(\"      10      \"));\n@@ -51,1 +48,2 @@\n-    @Test public void toString_validInput() {\n+    @Test\n+    void toString_validInput() {\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/IntegerStringConverterTest.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -35,4 +37,0 @@\n-import javafx.util.converter.LocalDateStringConverter;\n-import javafx.util.converter.LocalDateStringConverterShim;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n@@ -42,1 +40,0 @@\n-import org.junit.jupiter.params.provider.Arguments;\n@@ -45,2 +42,2 @@\n-public class LocalDateStringConverterTest {\n-    private static final LocalDate VALID_DATE = LocalDate.of(1985, 1, 12);\n+import javafx.util.converter.BaseTemporalStringConverterShim;\n+import javafx.util.converter.LocalDateStringConverter;\n@@ -48,3 +45,1 @@\n-    private static Locale oldLocale = null;\n-    private static DateTimeFormatter aFormatter = null;\n-    private static DateTimeFormatter aParser = null;\n+public class LocalDateStringConverterTest {\n@@ -52,5 +47,1 @@\n-    private enum LocalDateStringConverterVariant {\n-        NO_PARAM,\n-        WITH_FORMATTER_PARSER,\n-        WITH_FORMAT_STYLES,\n-    }\n+    private static final LocalDate VALID_DATE = LocalDate.of(1985, 1, 12);\n@@ -58,7 +49,3 @@\n-    static Stream<Arguments> provideTestParameters() {\n-        return Stream.of(\n-                Arguments.of(LocalDateStringConverterVariant.NO_PARAM, FormatStyle.SHORT, VALID_DATE),\n-                Arguments.of(LocalDateStringConverterVariant.WITH_FORMATTER_PARSER, null, VALID_DATE),\n-                Arguments.of(LocalDateStringConverterVariant.WITH_FORMAT_STYLES, FormatStyle.SHORT, VALID_DATE)\n-        );\n-    }\n+    private static Locale oldLocale;\n+    private static DateTimeFormatter aFormatter;\n+    private static DateTimeFormatter aParser;\n@@ -69,0 +56,1 @@\n+        \/\/ Tests require that default locale is en_US\n@@ -70,1 +58,1 @@\n-\n+        \/\/ DateTimeFormatter uses default locale, so we can init this after updating locale\n@@ -77,0 +65,1 @@\n+        \/\/ Restore VM's old locale\n@@ -80,12 +69,19 @@\n-    private record ConverterSetup(\n-            LocalDateStringConverter converter,\n-            Locale locale,\n-            DateTimeFormatter formatter,\n-            DateTimeFormatter parser\n-    ) {}\n-\n-    private ConverterSetup setupConverter(\n-            LocalDateStringConverterVariant converterVariant,\n-            FormatStyle dateStyle,\n-            LocalDate validDate\n-    ) {\n+    private enum LocalDateStringConverterVariant {\n+        NO_PARAM,\n+        WITH_FORMATTER_PARSER,\n+        WITH_FORMAT_STYLES,\n+    }\n+\n+    private record TestCase(LocalDateStringConverterVariant variant, LocalDate validDate) {}\n+\n+    private static Stream<TestCase> provideTestParameters() {\n+        return Stream.of(\n+                new TestCase(LocalDateStringConverterVariant.NO_PARAM, VALID_DATE),\n+                new TestCase(LocalDateStringConverterVariant.WITH_FORMATTER_PARSER, VALID_DATE),\n+                new TestCase(LocalDateStringConverterVariant.WITH_FORMAT_STYLES, VALID_DATE)\n+        );\n+    }\n+\n+    private record ConverterSetup(LocalDateStringConverter converter, DateTimeFormatter formatter, DateTimeFormatter parser) {}\n+\n+    private ConverterSetup setupConverter(LocalDateStringConverterVariant converterVariant) {\n@@ -94,3 +90,2 @@\n-                LocalDateStringConverter converter = new LocalDateStringConverter();\n-                Locale locale = Locale.getDefault(Locale.Category.FORMAT);\n-                yield new ConverterSetup(converter, locale, null, null);\n+                var converter = new LocalDateStringConverter();\n+                yield new ConverterSetup(converter, null, null);\n@@ -99,3 +94,2 @@\n-                LocalDateStringConverter converter = new LocalDateStringConverter(aFormatter, aParser);\n-                Locale locale = Locale.getDefault(Locale.Category.FORMAT);\n-                yield new ConverterSetup(converter, locale, aFormatter, aParser);\n+                var converter = new LocalDateStringConverter(aFormatter, aParser);\n+                yield new ConverterSetup(converter, aFormatter, aParser);\n@@ -104,4 +98,2 @@\n-                LocalDateStringConverter converter = new LocalDateStringConverter(\n-                        FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE\n-                );\n-                yield new ConverterSetup(converter, Locale.UK, null, null);\n+                var converter = new LocalDateStringConverter(FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE);\n+                yield new ConverterSetup(converter, null, null);\n@@ -109,1 +101,0 @@\n-            default -> throw new IllegalArgumentException(\"Invalid converter variant: \" + converterVariant);\n@@ -115,6 +106,2 @@\n-    void testConstructor(\n-            LocalDateStringConverterVariant converterVariant,\n-            FormatStyle dateStyle,\n-            LocalDate validDate\n-    ) {\n-        ConverterSetup setup = setupConverter(converterVariant, dateStyle, validDate);\n+    void testConstructor(TestCase testCase) {\n+        ConverterSetup setup = setupConverter(testCase.variant());\n@@ -122,1 +109,0 @@\n-        Locale locale = setup.locale();\n@@ -126,6 +112,0 @@\n-        assertEquals(locale, LocalDateStringConverterShim.getldtConverterLocale(converter));\n-        assertEquals(\n-                (dateStyle != null) ? dateStyle : FormatStyle.SHORT,\n-                LocalDateStringConverterShim.getldtConverterDateStyle(converter)\n-        );\n-        assertNull(LocalDateStringConverterShim.getldtConverterTimeStyle(converter));\n@@ -133,1 +113,1 @@\n-            assertEquals(formatter, LocalDateStringConverterShim.getldtConverterFormatter(converter));\n+            assertEquals(formatter, BaseTemporalStringConverterShim.getFormatter(converter));\n@@ -136,1 +116,1 @@\n-            assertEquals(parser, LocalDateStringConverterShim.getldtConverterParser(converter));\n+            assertEquals(parser, BaseTemporalStringConverterShim.getParser(converter));\n@@ -138,1 +118,1 @@\n-            assertEquals(formatter, LocalDateStringConverterShim.getldtConverterParser(converter));\n+            assertEquals(formatter, BaseTemporalStringConverterShim.getParser(converter));\n@@ -144,6 +124,2 @@\n-    void toString_to_fromString_testRoundtrip(\n-            LocalDateStringConverterVariant converterVariant,\n-            FormatStyle dateStyle,\n-            LocalDate validDate\n-    ) {\n-        ConverterSetup setup = setupConverter(converterVariant, dateStyle, validDate);\n+    void toString_to_fromString_testRoundtrip(TestCase testCase) {\n+        ConverterSetup setup = setupConverter(testCase.variant());\n@@ -154,1 +130,1 @@\n-            assertEquals(validDate, converter.fromString(converter.toString(validDate)));\n+            assertEquals(testCase.validDate(), converter.fromString(converter.toString(testCase.validDate())));\n@@ -160,6 +136,2 @@\n-    void fromString_testInvalidInput(\n-            LocalDateStringConverterVariant converterVariant,\n-            FormatStyle dateStyle,\n-            LocalDate validDate\n-    ) {\n-        ConverterSetup setup = setupConverter(converterVariant, dateStyle, validDate);\n+    void fromString_testInvalidInput(TestCase testCase) {\n+        ConverterSetup setup = setupConverter(testCase.variant());\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/LocalDateStringConverterTest.java","additions":47,"deletions":75,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-\/\/ Imports remain the same, except JUnit 4 imports are replaced with JUnit 5\n@@ -30,1 +29,0 @@\n-import static org.junit.jupiter.params.provider.Arguments.arguments;\n@@ -41,4 +39,0 @@\n-import javafx.util.StringConverter;\n-import javafx.util.converter.LocalDateTimeStringConverter;\n-import javafx.util.converter.LocalDateTimeStringConverterShim;\n-\n@@ -49,1 +43,0 @@\n-import org.junit.jupiter.params.provider.Arguments;\n@@ -52,0 +45,4 @@\n+import javafx.util.StringConverter;\n+import javafx.util.converter.BaseTemporalStringConverterShim;\n+import javafx.util.converter.LocalDateTimeStringConverter;\n+\n@@ -54,1 +51,1 @@\n-    private static final String JAPANESE_DATE_STRING = \"Saturday, January 12, 60 Shōwa, 12:34:56\\u202fPM\";;\n+    private static final String JAPANESE_DATE_STRING = \"Saturday, January 12, 60 Shōwa, 12:34:56\\u202fPM\";\n@@ -58,2 +55,0 @@\n-    private static DateTimeFormatter aFormatter;\n-    private static DateTimeFormatter aParser;\n@@ -61,18 +56,2 @@\n-\n-    public enum LocalDateTimeStringConverterVariant {\n-        NO_PARAM,\n-        WITH_FORMATTER_PARSER,\n-        WITH_FORMAT_STYLES,\n-    }\n-\n-    \/\/ Parameter source method\n-    public static Stream<Arguments> implementations() {\n-        return Stream.of(\n-                arguments(LocalDateTimeStringConverterVariant.NO_PARAM,\n-                        FormatStyle.SHORT, FormatStyle.SHORT, VALID_LDT_WITHOUT_SECONDS),\n-                arguments(LocalDateTimeStringConverterVariant.WITH_FORMATTER_PARSER,\n-                        null, null, VALID_LDT_WITH_SECONDS),\n-                arguments(LocalDateTimeStringConverterVariant.WITH_FORMAT_STYLES,\n-                        FormatStyle.SHORT, FormatStyle.SHORT, VALID_LDT_WITHOUT_SECONDS)\n-        );\n-    }\n+    private static DateTimeFormatter aFormatter = DateTimeFormatter.ofPattern(\"dd MM yyyy HH mm ss\");\n+    private static DateTimeFormatter aParser = DateTimeFormatter.ofPattern(\"yyyy MM dd hh mm ss a\");\n@@ -96,0 +75,17 @@\n+    public enum LocalDateTimeStringConverterVariant {\n+        NO_PARAM,\n+        WITH_FORMATTER_PARSER,\n+        WITH_FORMAT_STYLES,\n+    }\n+\n+    private record TestCase(LocalDateTimeStringConverterVariant variant, LocalDateTime validDateTime) {}\n+\n+    \/\/ Parameter source method\n+    private static Stream<TestCase> provideTestParameters() {\n+        return Stream.of(\n+                new TestCase(LocalDateTimeStringConverterVariant.NO_PARAM, VALID_LDT_WITHOUT_SECONDS),\n+                new TestCase(LocalDateTimeStringConverterVariant.WITH_FORMATTER_PARSER, VALID_LDT_WITH_SECONDS),\n+                new TestCase(LocalDateTimeStringConverterVariant.WITH_FORMAT_STYLES, VALID_LDT_WITHOUT_SECONDS)\n+        );\n+    }\n+\n@@ -98,15 +94,6 @@\n-    @MethodSource(\"implementations\")\n-    void testConstructor(LocalDateTimeStringConverterVariant converterVariant,\n-                         FormatStyle dateStyle,\n-                         FormatStyle timeStyle,\n-                         LocalDateTime validDateTime) {\n-        LocalDateTimeStringConverter converter = createConverter(converterVariant);\n-        Locale locale = getLocale(converterVariant);\n-        DateTimeFormatter formatter = getFormatter(converterVariant);\n-        DateTimeFormatter parser = getParser(converterVariant);\n-\n-        assertEquals(locale, LocalDateTimeStringConverterShim.getldtConverterLocale(converter));\n-        assertEquals((dateStyle != null) ? dateStyle : FormatStyle.SHORT,\n-                LocalDateTimeStringConverterShim.getldtConverterDateStyle(converter));\n-        assertEquals((timeStyle != null) ? timeStyle : FormatStyle.SHORT,\n-                LocalDateTimeStringConverterShim.getldtConverterTimeStyle(converter));\n+    @MethodSource(\"provideTestParameters\")\n+    void testConstructor(TestCase testCase) {\n+        LocalDateTimeStringConverter converter = createConverter(testCase.variant());\n+        DateTimeFormatter formatter = getFormatter(testCase.variant());\n+        DateTimeFormatter parser = getParser(testCase.variant());\n+\n@@ -114,2 +101,1 @@\n-            assertEquals(formatter,\n-                    LocalDateTimeStringConverterShim.getldtConverterFormatter(converter));\n+            assertEquals(formatter, BaseTemporalStringConverterShim.getFormatter(converter));\n@@ -118,2 +104,1 @@\n-            assertEquals(parser,\n-                    LocalDateTimeStringConverterShim.getldtConverterParser(converter));\n+            assertEquals(parser, BaseTemporalStringConverterShim.getParser(converter));\n@@ -121,2 +106,1 @@\n-            assertEquals(formatter,\n-                    LocalDateTimeStringConverterShim.getldtConverterFormatter(converter));\n+            assertEquals(formatter, BaseTemporalStringConverterShim.getParser(converter));\n@@ -127,7 +111,4 @@\n-    @MethodSource(\"implementations\")\n-    void toString_to_fromString_testRoundtrip(LocalDateTimeStringConverterVariant converterVariant,\n-                                              FormatStyle dateStyle,\n-                                              FormatStyle timeStyle,\n-                                              LocalDateTime validDateTime) {\n-        LocalDateTimeStringConverter converter = createConverter(converterVariant);\n-        DateTimeFormatter formatter = getFormatter(converterVariant);\n+    @MethodSource(\"provideTestParameters\")\n+    void toString_to_fromString_testRoundtrip(TestCase testCase) {\n+        LocalDateTimeStringConverter converter = createConverter(testCase.variant());\n+        DateTimeFormatter formatter = getFormatter(testCase.variant());\n@@ -136,1 +117,1 @@\n-            assertEquals(validDateTime, converter.fromString(converter.toString(validDateTime)));\n+            assertEquals(testCase.validDateTime(), converter.fromString(converter.toString(testCase.validDateTime())));\n@@ -141,6 +122,3 @@\n-    @MethodSource(\"implementations\")\n-    void fromString_testInvalidInput(LocalDateTimeStringConverterVariant converterVariant,\n-                                     FormatStyle dateStyle,\n-                                     FormatStyle timeStyle,\n-                                     LocalDateTime validDateTime) {\n-        LocalDateTimeStringConverter converter = createConverter(converterVariant);\n+    @MethodSource(\"provideTestParameters\")\n+    void fromString_testInvalidInput(TestCase testCase) {\n+        LocalDateTimeStringConverter converter = createConverter(testCase.variant());\n@@ -152,15 +130,0 @@\n-        switch (variant) {\n-            case NO_PARAM:\n-                return new LocalDateTimeStringConverter();\n-            case WITH_FORMATTER_PARSER:\n-                return new LocalDateTimeStringConverter(aFormatter, aParser);\n-            case WITH_FORMAT_STYLES:\n-                return new LocalDateTimeStringConverter(FormatStyle.SHORT, FormatStyle.SHORT,\n-                        Locale.UK, IsoChronology.INSTANCE);\n-            default:\n-                fail(\"Invalid converter variant: \" + variant);\n-                return null;\n-        }\n-    }\n-\n-    private Locale getLocale(LocalDateTimeStringConverterVariant variant) {\n@@ -168,6 +131,4 @@\n-            case NO_PARAM, WITH_FORMATTER_PARSER -> Locale.getDefault(Locale.Category.FORMAT);\n-            case WITH_FORMAT_STYLES -> Locale.UK;\n-            default -> {\n-                fail(\"Invalid converter variant: \" + variant);\n-                yield null;\n-            }\n+            case NO_PARAM -> new LocalDateTimeStringConverter();\n+            case WITH_FORMATTER_PARSER -> new LocalDateTimeStringConverter(aFormatter, aParser);\n+            case WITH_FORMAT_STYLES -> new LocalDateTimeStringConverter(FormatStyle.SHORT, FormatStyle.SHORT,\n+                                Locale.UK, IsoChronology.INSTANCE);\n@@ -218,1 +179,1 @@\n-        } catch (DateTimeException e) {}\n+        } catch (DateTimeException _) {}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/LocalDateTimeStringConverterTest.java","additions":46,"deletions":85,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -34,4 +36,0 @@\n-import javafx.util.converter.LocalTimeStringConverter;\n-import javafx.util.converter.LocalTimeStringConverterShim;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n@@ -41,1 +39,0 @@\n-import org.junit.jupiter.params.provider.Arguments;\n@@ -44,8 +41,2 @@\n-public class LocalTimeStringConverterTest {\n-    private static final LocalTime VALID_TIME_WITH_SECONDS;\n-    private static final LocalTime VALID_TIME_WITHOUT_SECONDS;\n-\n-    static {\n-        VALID_TIME_WITH_SECONDS = LocalTime.of(12, 34, 56);\n-        VALID_TIME_WITHOUT_SECONDS = LocalTime.of(12, 34, 0);\n-    }\n+import javafx.util.converter.BaseTemporalStringConverterShim;\n+import javafx.util.converter.LocalTimeStringConverter;\n@@ -53,3 +44,1 @@\n-    private static Locale oldLocale = null;\n-    private static DateTimeFormatter aFormatter = null;\n-    private static DateTimeFormatter aParser = null;\n+public class LocalTimeStringConverterTest {\n@@ -57,5 +46,2 @@\n-    private enum LocalTimeStringConverterVariant {\n-        NO_PARAM,\n-        WITH_FORMATTER_PARSER,\n-        WITH_FORMAT_STYLES,\n-    }\n+    private static final LocalTime VALID_TIME_WITH_SECONDS = LocalTime.of(12, 34, 56);\n+    private static final LocalTime VALID_TIME_WITHOUT_SECONDS = LocalTime.of(12, 34, 0);\n@@ -63,7 +49,3 @@\n-    static Stream<Arguments> provideTestParameters() {\n-        return Stream.of(\n-                Arguments.of(LocalTimeStringConverterVariant.NO_PARAM, FormatStyle.SHORT, VALID_TIME_WITHOUT_SECONDS),\n-                Arguments.of(LocalTimeStringConverterVariant.WITH_FORMATTER_PARSER, null, VALID_TIME_WITH_SECONDS),\n-                Arguments.of(LocalTimeStringConverterVariant.WITH_FORMAT_STYLES, FormatStyle.SHORT, VALID_TIME_WITHOUT_SECONDS)\n-        );\n-    }\n+    private static Locale oldLocale;\n+    private static DateTimeFormatter aFormatter;\n+    private static DateTimeFormatter aParser;\n@@ -74,0 +56,1 @@\n+        \/\/ Tests require that default locale is en_US\n@@ -75,1 +58,1 @@\n-\n+        \/\/ DateTimeFormatter uses default locale, so we can init this after updating locale\n@@ -82,0 +65,1 @@\n+        \/\/ Restore VM's old locale\n@@ -85,12 +69,19 @@\n-    private record ConverterSetup(\n-            LocalTimeStringConverter converter,\n-            Locale locale,\n-            DateTimeFormatter formatter,\n-            DateTimeFormatter parser\n-    ) {}\n-\n-    private ConverterSetup setupConverter(\n-            LocalTimeStringConverterVariant converterVariant,\n-            FormatStyle timeStyle,\n-            LocalTime validTime\n-    ) {\n+    private enum LocalTimeStringConverterVariant {\n+        NO_PARAM,\n+        WITH_FORMATTER_PARSER,\n+        WITH_FORMAT_STYLES,\n+    }\n+\n+    private record TestCase(LocalTimeStringConverterVariant variant, LocalTime validTime) {}\n+\n+    private static Stream<TestCase> provideTestParameters() {\n+        return Stream.of(\n+                new TestCase(LocalTimeStringConverterVariant.NO_PARAM, VALID_TIME_WITHOUT_SECONDS),\n+                new TestCase(LocalTimeStringConverterVariant.WITH_FORMATTER_PARSER, VALID_TIME_WITH_SECONDS),\n+                new TestCase(LocalTimeStringConverterVariant.WITH_FORMAT_STYLES, VALID_TIME_WITHOUT_SECONDS)\n+        );\n+    }\n+\n+    private record ConverterSetup(LocalTimeStringConverter converter, DateTimeFormatter formatter, DateTimeFormatter parser) {}\n+\n+    private ConverterSetup setupConverter(LocalTimeStringConverterVariant converterVariant) {\n@@ -99,3 +90,2 @@\n-                LocalTimeStringConverter converter = new LocalTimeStringConverter();\n-                Locale locale = Locale.getDefault(Locale.Category.FORMAT);\n-                yield new ConverterSetup(converter, locale, null, null);\n+                var converter = new LocalTimeStringConverter();\n+                yield new ConverterSetup(converter, null, null);\n@@ -104,3 +94,2 @@\n-                LocalTimeStringConverter converter = new LocalTimeStringConverter(aFormatter, aParser);\n-                Locale locale = Locale.getDefault(Locale.Category.FORMAT);\n-                yield new ConverterSetup(converter, locale, aFormatter, aParser);\n+                var converter = new LocalTimeStringConverter(aFormatter, aParser);\n+                yield new ConverterSetup(converter, aFormatter, aParser);\n@@ -109,2 +98,2 @@\n-                LocalTimeStringConverter converter = new LocalTimeStringConverter(FormatStyle.SHORT, Locale.UK);\n-                yield new ConverterSetup(converter, Locale.UK, null, null);\n+                var converter = new LocalTimeStringConverter(FormatStyle.SHORT, Locale.UK);\n+                yield new ConverterSetup(converter, null, null);\n@@ -112,1 +101,0 @@\n-            default -> throw new IllegalArgumentException(\"Invalid converter variant: \" + converterVariant);\n@@ -118,6 +106,2 @@\n-    void testConstructor(\n-            LocalTimeStringConverterVariant converterVariant,\n-            FormatStyle timeStyle,\n-            LocalTime validTime\n-    ) {\n-        ConverterSetup setup = setupConverter(converterVariant, timeStyle, validTime);\n+    void testConstructor(TestCase testCase) {\n+        ConverterSetup setup = setupConverter(testCase.variant());\n@@ -125,1 +109,0 @@\n-        Locale locale = setup.locale();\n@@ -129,6 +112,0 @@\n-        assertEquals(locale, LocalTimeStringConverterShim.getldtConverterLocale(converter));\n-        assertNull(LocalTimeStringConverterShim.getldtConverterDateStyle(converter));\n-        assertEquals(\n-                (timeStyle != null) ? timeStyle : FormatStyle.SHORT,\n-                LocalTimeStringConverterShim.getldtConverterTimeStyle(converter)\n-        );\n@@ -136,1 +113,1 @@\n-            assertEquals(formatter, LocalTimeStringConverterShim.getldtConverterFormatter(converter));\n+            assertEquals(formatter, BaseTemporalStringConverterShim.getFormatter(converter));\n@@ -139,1 +116,1 @@\n-            assertEquals(parser, LocalTimeStringConverterShim.getldtConverterParser(converter));\n+            assertEquals(parser, BaseTemporalStringConverterShim.getParser(converter));\n@@ -141,1 +118,1 @@\n-            assertEquals(formatter, LocalTimeStringConverterShim.getldtConverterFormatter(converter));\n+            assertEquals(formatter, BaseTemporalStringConverterShim.getParser(converter));\n@@ -147,6 +124,2 @@\n-    void toString_to_fromString_testRoundtrip(\n-            LocalTimeStringConverterVariant converterVariant,\n-            FormatStyle timeStyle,\n-            LocalTime validTime\n-    ) {\n-        ConverterSetup setup = setupConverter(converterVariant, timeStyle, validTime);\n+    void toString_to_fromString_testRoundtrip(TestCase testCase) {\n+        ConverterSetup setup = setupConverter(testCase.variant());\n@@ -157,1 +130,1 @@\n-            assertEquals(validTime, converter.fromString(converter.toString(validTime)));\n+            assertEquals(testCase.validTime(), converter.fromString(converter.toString(testCase.validTime())));\n@@ -163,6 +136,2 @@\n-    void fromString_testInvalidInput(\n-            LocalTimeStringConverterVariant converterVariant,\n-            FormatStyle timeStyle,\n-            LocalTime validTime\n-    ) {\n-        ConverterSetup setup = setupConverter(converterVariant, timeStyle, validTime);\n+    void fromString_testInvalidInput(TestCase testCase) {\n+        ConverterSetup setup = setupConverter(testCase.variant());\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/LocalTimeStringConverterTest.java","additions":48,"deletions":79,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import javafx.util.converter.LongStringConverter;\n@@ -31,1 +30,0 @@\n-import org.junit.jupiter.api.BeforeEach;\n@@ -34,2 +32,2 @@\n-\/**\n- *\/\n+import javafx.util.converter.LongStringConverter;\n+\n@@ -37,1 +35,0 @@\n-    private LongStringConverter converter;\n@@ -39,3 +36,1 @@\n-    @BeforeEach public void setup() {\n-        converter = new LongStringConverter();\n-    }\n+    private final LongStringConverter converter = new LongStringConverter();\n@@ -43,2 +38,3 @@\n-    @Test public void fromString_testValidStringInput() {\n-        assertEquals(Long.valueOf(10), converter.fromString(\"10\"));\n+    @Test\n+    void fromString_testValidStringInput() {\n+        assertEquals(10, converter.fromString(\"10\"));\n@@ -47,2 +43,3 @@\n-    @Test public void fromString_testValidStringInputWithWhiteSpace() {\n-        assertEquals(Long.valueOf(10), converter.fromString(\"      10      \"));\n+    @Test\n+    void fromString_testValidStringInputWithWhiteSpace() {\n+        assertEquals(10, converter.fromString(\"      10      \"));\n@@ -51,1 +48,2 @@\n-    @Test public void toString_validInput() {\n+    @Test\n+    void toString_validInput() {\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/LongStringConverterTest.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -29,0 +31,1 @@\n+import java.text.DecimalFormatSymbols;\n@@ -31,3 +34,0 @@\n-import javafx.util.converter.NumberStringConverter;\n-import javafx.util.converter.NumberStringConverterShim;\n-import static org.junit.jupiter.api.Assertions.*;\n@@ -35,1 +35,0 @@\n-import org.junit.jupiter.api.BeforeEach;\n@@ -38,0 +37,3 @@\n+import javafx.util.converter.NumberStringConverter;\n+import javafx.util.converter.NumberStringConverterShim;\n+\n@@ -39,1 +41,0 @@\n-    private NumberStringConverter converter;\n@@ -41,4 +42,1 @@\n-    @BeforeEach\n-    public void setup() {\n-        converter = new NumberStringConverter();\n-    }\n+    private static final String PATTERN = \"#,##,###,####\";\n@@ -46,7 +44,1 @@\n-    @Test\n-    public void testDefaultConstructor() {\n-        NumberStringConverter c = new NumberStringConverter();\n-        assertEquals(Locale.getDefault(), NumberStringConverterShim.getLocale(c));\n-        assertNull(NumberStringConverterShim.getPattern(c));\n-        assertNull(NumberStringConverterShim.getNumberFormatVar(c));\n-    }\n+    private final NumberStringConverter usLocaleConverter = new NumberStringConverter(Locale.US);\n@@ -55,6 +47,2 @@\n-    public void testConstructor_locale() {\n-        NumberStringConverter c = new NumberStringConverter(Locale.CANADA);\n-        assertEquals(Locale.CANADA, NumberStringConverterShim.getLocale(c));\n-        assertNull(NumberStringConverterShim.getPattern(c));\n-        assertNull(NumberStringConverterShim.getNumberFormatVar(c));\n-    }\n+    void testDefaultConstructor() {\n+        NumberFormat numberFormat = NumberFormat.getNumberInstance(Locale.getDefault());\n@@ -62,6 +50,3 @@\n-    @Test\n-    public void testConstructor_pattern() {\n-        NumberStringConverter c = new NumberStringConverter(\"#,##,###,####\");\n-        assertEquals(Locale.getDefault(), NumberStringConverterShim.getLocale(c));\n-        assertEquals(\"#,##,###,####\", NumberStringConverterShim.getPattern(c));\n-        assertNull(NumberStringConverterShim.getNumberFormatVar(c));\n+        var nsc = new NumberStringConverter();\n+\n+        assertEquals(numberFormat, numberFormatOf(nsc));\n@@ -71,5 +56,6 @@\n-    public void testConstructor_locale_pattern() {\n-        NumberStringConverter c = new NumberStringConverter(Locale.CANADA, \"#,##,###,####\");\n-        assertEquals(Locale.CANADA, NumberStringConverterShim.getLocale(c));\n-        assertEquals(\"#,##,###,####\", NumberStringConverterShim.getPattern(c));\n-        assertNull(NumberStringConverterShim.getNumberFormatVar(c));\n+    void testConstructor_locale() {\n+        NumberFormat numberFormat = NumberFormat.getNumberInstance(Locale.CANADA);\n+\n+        var nsc = new NumberStringConverter(Locale.CANADA);\n+\n+        assertEquals(numberFormat, numberFormatOf(nsc));\n@@ -79,6 +65,7 @@\n-    public void testConstructor_numberFormat() {\n-        NumberFormat format = NumberFormat.getCurrencyInstance(Locale.JAPAN);\n-        NumberStringConverter c = new NumberStringConverter(format);\n-        assertNull(NumberStringConverterShim.getLocale(c));\n-        assertNull(NumberStringConverterShim.getPattern(c));\n-        assertEquals(format, NumberStringConverterShim.getNumberFormatVar(c));\n+    void testConstructor_pattern() {\n+        var symbols = new DecimalFormatSymbols(Locale.getDefault());\n+        var numberFormat = new DecimalFormat(PATTERN, symbols);\n+\n+        var nsc = new NumberStringConverter(PATTERN);\n+\n+        assertEquals(numberFormat, numberFormatOf(nsc));\n@@ -88,2 +75,7 @@\n-    public void getNumberFormat_default() {\n-        assertNotNull(NumberStringConverterShim.getNumberFormat(converter));\n+    void testConstructor_locale_pattern() {\n+        var symbols = new DecimalFormatSymbols(Locale.CANADA);\n+        var numberFormat = new DecimalFormat(PATTERN, symbols);\n+\n+        var nsc = new NumberStringConverter(Locale.CANADA, PATTERN);\n+\n+        assertEquals(numberFormat, numberFormatOf(nsc));\n@@ -93,3 +85,6 @@\n-    public void getNumberFormat_nonNullPattern() {\n-        converter = new NumberStringConverter(\"#,##,###,####\");\n-        assertTrue(NumberStringConverterShim.getNumberFormat(converter) instanceof DecimalFormat);\n+    void testConstructor_numberFormat() {\n+        NumberFormat numberFormat = NumberFormat.getNumberInstance(Locale.JAPAN);\n+\n+        var nsc = new NumberStringConverter(numberFormat);\n+\n+        assertEquals(numberFormat, numberFormatOf(nsc));\n@@ -98,5 +93,2 @@\n-    @Test\n-    public void getNumberFormat_nonNullNumberFormat() {\n-        NumberFormat nf = NumberFormat.getCurrencyInstance();\n-        converter = new NumberStringConverter(nf);\n-        assertEquals(nf, NumberStringConverterShim.getNumberFormat(converter));\n+    static NumberFormat numberFormatOf(NumberStringConverter csc) {\n+        return NumberStringConverterShim.getNumberFormat(csc);\n@@ -106,2 +98,2 @@\n-    public void fromString_testValidInput() {\n-        assertEquals(10L, converter.fromString(\"10\"));\n+    void fromString_testValidInput() {\n+        assertEquals(10L, usLocaleConverter.fromString(\"10\"));\n@@ -111,2 +103,2 @@\n-    public void fromString_testValidInputWithWhiteSpace() {\n-        assertEquals(10L, converter.fromString(\"      10      \"));\n+    void fromString_testValidInputWithWhiteSpace() {\n+        assertEquals(10L, usLocaleConverter.fromString(\"      10      \"));\n@@ -116,2 +108,2 @@\n-    public void fromString_testInvalidInput() {\n-        assertThrows(RuntimeException.class, () -> converter.fromString(\"abcdefg\"));\n+    void fromString_testInvalidInput() {\n+        assertThrows(RuntimeException.class, () -> usLocaleConverter.fromString(\"abcdefg\"));\n@@ -121,2 +113,2 @@\n-    public void toString_validInput() {\n-        assertEquals(\"10\", converter.toString(10L));\n+    void toString_validInput() {\n+        assertEquals(\"10\", usLocaleConverter.toString(10L));\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/NumberStringConverterTest.java","additions":49,"deletions":57,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static test.javafx.util.converter.NumberStringConverterTest.numberFormatOf;\n+\n@@ -30,3 +33,0 @@\n-import javafx.util.converter.NumberStringConverterShim;\n-import javafx.util.converter.PercentageStringConverter;\n-import static org.junit.jupiter.api.Assertions.*;\n@@ -34,1 +34,0 @@\n-import org.junit.jupiter.api.BeforeEach;\n@@ -37,4 +36,1 @@\n-\/**\n- *\/\n-public class PercentageStringConverterTest {\n-    private PercentageStringConverter converter;\n+import javafx.util.converter.PercentageStringConverter;\n@@ -42,3 +38,1 @@\n-    @BeforeEach public void setup() {\n-        converter = new PercentageStringConverter(Locale.US);\n-    }\n+public class PercentageStringConverterTest {\n@@ -46,3 +40,1 @@\n-    \/*********************************************************************\n-     * Test constructors\n-     ********************************************************************\/\n+    private final PercentageStringConverter usLocaleConverter = new PercentageStringConverter(Locale.US);\n@@ -50,6 +42,3 @@\n-    @Test public void testDefaultConstructor() {\n-        PercentageStringConverter c = new PercentageStringConverter();\n-        assertEquals(Locale.getDefault(), NumberStringConverterShim.getLocale(c));\n-        assertNull(NumberStringConverterShim.getPattern(c));\n-        assertNull(NumberStringConverterShim.getNumberFormatVar(c));\n-    }\n+    @Test\n+    void testDefaultConstructor() {\n+        NumberFormat numberFormat = NumberFormat.getPercentInstance(Locale.getDefault());\n@@ -57,6 +46,1 @@\n-    @Test public void testConstructor_locale() {\n-        PercentageStringConverter c = new PercentageStringConverter(Locale.CANADA);\n-        assertEquals(Locale.CANADA, NumberStringConverterShim.getLocale(c));\n-        assertNull(NumberStringConverterShim.getPattern(c));\n-        assertNull(NumberStringConverterShim.getNumberFormatVar(c));\n-    }\n+        var psc = new PercentageStringConverter();\n@@ -64,6 +48,1 @@\n-    @Test public void testConstructor_numberFormat() {\n-        NumberFormat format = NumberFormat.getCurrencyInstance(Locale.JAPAN);\n-        PercentageStringConverter c = new PercentageStringConverter(format);\n-        assertNull(NumberStringConverterShim.getLocale(c));\n-        assertNull(NumberStringConverterShim.getPattern(c));\n-        assertEquals(format, NumberStringConverterShim.getNumberFormatVar(c));\n+        assertEquals(numberFormat, numberFormatOf(psc));\n@@ -72,0 +51,3 @@\n+    @Test\n+    void testConstructor_locale() {\n+        NumberFormat numberFormat = NumberFormat.getPercentInstance(Locale.CANADA);\n@@ -73,3 +55,1 @@\n-    \/*********************************************************************\n-     * Test methods\n-     ********************************************************************\/\n+        var psc = new PercentageStringConverter(Locale.CANADA);\n@@ -77,2 +57,1 @@\n-    @Test public void getNumberFormat_default() {\n-        assertNotNull(NumberStringConverterShim.getNumberFormat(converter));\n+        assertEquals(numberFormat, numberFormatOf(psc));\n@@ -81,5 +60,3 @@\n-    @Test public void getNumberFormat_nonNullNumberFormat() {\n-        NumberFormat nf = NumberFormat.getCurrencyInstance();\n-        converter = new PercentageStringConverter(nf);\n-        assertEquals(nf, NumberStringConverterShim.getNumberFormat(converter));\n-    }\n+    @Test\n+    void testConstructor_numberFormat() {\n+        NumberFormat numberFormat = NumberFormat.getPercentInstance(Locale.JAPAN);\n@@ -87,0 +64,1 @@\n+        var csc = new PercentageStringConverter(numberFormat);\n@@ -88,3 +66,2 @@\n-    \/*********************************************************************\n-     * Test toString \/ fromString methods\n-     ********************************************************************\/\n+        assertEquals(numberFormat, numberFormatOf(csc));\n+    }\n@@ -92,2 +69,3 @@\n-    @Test public void fromString_testValidStringInput() {\n-        assertEquals(.1032, converter.fromString(\"10.32%\"));\n+    @Test\n+    void fromString_testValidStringInput() {\n+        assertEquals(.1032, usLocaleConverter.fromString(\"10.32%\"));\n@@ -96,2 +74,3 @@\n-    @Test public void fromString_testValidStringInputWithWhiteSpace() {\n-        assertEquals(.1032, converter.fromString(\"      10.32%      \"));\n+    @Test\n+    void fromString_testValidStringInputWithWhiteSpace() {\n+        assertEquals(.1032, usLocaleConverter.fromString(\"      10.32%      \"));\n@@ -100,2 +79,3 @@\n-    @Test public void toString_validInput() {\n-        assertEquals(\"10%\", converter.toString(.10));\n+    @Test\n+    void toString_validInput() {\n+        assertEquals(\"10%\", usLocaleConverter.toString(.10));\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/PercentageStringConverterTest.java","additions":31,"deletions":51,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import javafx.util.converter.ShortStringConverter;\n@@ -31,1 +30,0 @@\n-import org.junit.jupiter.api.BeforeEach;\n@@ -34,2 +32,2 @@\n-\/**\n- *\/\n+import javafx.util.converter.ShortStringConverter;\n+\n@@ -37,1 +35,0 @@\n-    private ShortStringConverter converter;\n@@ -39,1 +36,1 @@\n-    private final short shortValue_10 = 10;\n+    private static final short SHORT_VALUE_10 = 10;\n@@ -41,3 +38,1 @@\n-    @BeforeEach public void setup() {\n-        converter = new ShortStringConverter();\n-    }\n+    private final ShortStringConverter converter = new ShortStringConverter();\n@@ -45,2 +40,3 @@\n-    @Test public void fromString_testValidStringInput() {\n-        assertEquals((Object)shortValue_10, converter.fromString(\"10\"));\n+    @Test\n+    void fromString_testValidStringInput() {\n+        assertEquals(SHORT_VALUE_10, converter.fromString(\"10\"));\n@@ -49,2 +45,3 @@\n-    @Test public void fromString_testValidStringInputWithWhiteSpace() {\n-        assertEquals((Object)shortValue_10, converter.fromString(\"     10     \"));\n+    @Test\n+    void fromString_testValidStringInputWithWhiteSpace() {\n+        assertEquals(SHORT_VALUE_10, converter.fromString(\"     10     \"));\n@@ -53,2 +50,3 @@\n-    @Test public void toString_testStringInput() {\n-        assertEquals(\"10\", converter.toString(shortValue_10));\n+    @Test\n+    void toString_testStringInput() {\n+        assertEquals(\"10\", converter.toString(SHORT_VALUE_10));\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/ShortStringConverterTest.java","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -32,0 +33,1 @@\n+import java.util.Collection;\n@@ -33,0 +35,1 @@\n+import java.util.List;\n@@ -35,4 +38,0 @@\n-import java.util.stream.Stream;\n-\n-import javafx.util.converter.DateTimeStringConverterShim;\n-import javafx.util.converter.TimeStringConverter;\n@@ -42,1 +41,0 @@\n-import org.junit.jupiter.params.provider.Arguments;\n@@ -45,0 +43,3 @@\n+import javafx.util.converter.DateTimeStringConverterShim;\n+import javafx.util.converter.TimeStringConverter;\n+\n@@ -46,0 +47,1 @@\n+\n@@ -61,52 +63,2 @@\n-    private static Stream<Arguments> provideAllConverters() {\n-        return Stream.of(\n-                createTestCase(\n-                        new TimeStringConverter(),\n-                        Locale.getDefault(Locale.Category.FORMAT),\n-                        DateFormat.DEFAULT,\n-                        VALID_TIME_WITH_SECONDS,\n-                        null,\n-                        null\n-                ),\n-                createTestCase(\n-                        new TimeStringConverter(DateFormat.SHORT),\n-                        Locale.getDefault(Locale.Category.FORMAT),\n-                        DateFormat.SHORT,\n-                        VALID_TIME_WITHOUT_SECONDS,\n-                        null,\n-                        null\n-                ),\n-                createTestCase(\n-                        new TimeStringConverter(Locale.UK),\n-                        Locale.UK,\n-                        DateFormat.DEFAULT,\n-                        VALID_TIME_WITH_SECONDS,\n-                        null,\n-                        null\n-                ),\n-                createTestCase(\n-                        new TimeStringConverter(Locale.UK, DateFormat.SHORT),\n-                        Locale.UK,\n-                        DateFormat.SHORT,\n-                        VALID_TIME_WITHOUT_SECONDS,\n-                        null,\n-                        null\n-                ),\n-                createTestCase(\n-                        new TimeStringConverter(\"HH mm ss\"),\n-                        Locale.getDefault(Locale.Category.FORMAT),\n-                        DateFormat.DEFAULT,\n-                        VALID_TIME_WITH_SECONDS,\n-                        \"HH mm ss\",\n-                        null\n-                ),\n-                createTestCase(\n-                        new TimeStringConverter(DateFormat.getTimeInstance(DateFormat.FULL)),\n-                        Locale.getDefault(Locale.Category.FORMAT),\n-                        DateFormat.DEFAULT,\n-                        VALID_TIME_WITH_SECONDS,\n-                        null,\n-                        DateFormat.getTimeInstance(DateFormat.FULL)\n-                )\n-        );\n-    }\n+    private record TestCase(TimeStringConverter converter, Locale locale, int timetyle, String pattern,\n+            DateFormat dateFormat, Date validDate) {}\n@@ -114,4 +66,4 @@\n-    private static Arguments createTestCase(TimeStringConverter converter, Locale locale, int timeStyle, Date validDate, String pattern, DateFormat dateFormat) {\n-        DateFormat validFormatter = computeValidFormatter(pattern, dateFormat, timeStyle, locale);\n-        return Arguments.of(converter, locale, timeStyle, validDate, pattern, dateFormat, validFormatter);\n-    }\n+    private static Collection<TestCase> implementations() {\n+        return List.of(\n+                new TestCase(new TimeStringConverter(), Locale.getDefault(Locale.Category.FORMAT),\n+                        DateFormat.DEFAULT, null, null, VALID_TIME_WITH_SECONDS),\n@@ -119,9 +71,2 @@\n-    private static DateFormat computeValidFormatter(String pattern, DateFormat dateFormat, int timeStyle, Locale locale) {\n-        if (dateFormat != null) {\n-            return dateFormat;\n-        } else if (pattern != null) {\n-            return new SimpleDateFormat(pattern);\n-        } else {\n-            return DateFormat.getTimeInstance(timeStyle, locale);\n-        }\n-    }\n+                new TestCase(new TimeStringConverter(DateFormat.SHORT), Locale.getDefault(Locale.Category.FORMAT),\n+                        DateFormat.SHORT, null, null, VALID_TIME_WITHOUT_SECONDS),\n@@ -129,4 +74,2 @@\n-    private static Stream<Arguments> provideConvertersForConstructor() {\n-        return provideAllConverters()\n-                .map(args -> Arguments.of(args.get()[0], args.get()[1], args.get()[2], args.get()[4], args.get()[5]));\n-    }\n+                new TestCase(new TimeStringConverter(Locale.UK), Locale.UK,\n+                        DateFormat.DEFAULT, null, null, VALID_TIME_WITH_SECONDS),\n@@ -134,7 +77,10 @@\n-    @ParameterizedTest\n-    @MethodSource(\"provideConvertersForConstructor\")\n-    void testConstructor(TimeStringConverter converter, Locale locale, int timeStyle, String pattern, DateFormat dateFormat) {\n-        assertEquals(locale, DateTimeStringConverterShim.getLocale(converter));\n-        assertEquals(timeStyle, DateTimeStringConverterShim.getTimeStyle(converter));\n-        assertEquals(pattern, DateTimeStringConverterShim.getPattern(converter));\n-        assertEquals(dateFormat, DateTimeStringConverterShim.getDateFormatVar(converter));\n+                new TestCase(new TimeStringConverter(Locale.UK, DateFormat.SHORT), Locale.UK,\n+                        DateFormat.SHORT, null, null, VALID_TIME_WITHOUT_SECONDS),\n+\n+                new TestCase(new TimeStringConverter(\"HH mm ss\"), Locale.getDefault(Locale.Category.FORMAT),\n+                        DateFormat.DEFAULT, \"HH mm ss\", null, VALID_TIME_WITH_SECONDS),\n+\n+                new TestCase(new TimeStringConverter(DateFormat.getTimeInstance(DateFormat.FULL)),\n+                        Locale.getDefault(Locale.Category.FORMAT), DateFormat.DEFAULT, null,\n+                        DateFormat.getTimeInstance(DateFormat.FULL), VALID_TIME_WITH_SECONDS)\n+                );\n@@ -143,3 +89,12 @@\n-    private static Stream<Arguments> provideConvertersForGetDateFormat() {\n-        return provideAllConverters()\n-                .map(args -> Arguments.of(args.get()[0]));\n+    private static DateFormat computeValidFormatter(TestCase testCase) {\n+        if (testCase.dateFormat() != null) {\n+            return testCase.dateFormat();\n+        }\n+        DateFormat validFormatter;\n+        if (testCase.pattern() != null) {\n+            validFormatter = new SimpleDateFormat(testCase.pattern(), testCase.locale());\n+        } else {\n+            validFormatter = DateFormat.getTimeInstance(testCase.timetyle(), testCase.locale());\n+        }\n+        validFormatter.setLenient(false);\n+        return validFormatter;\n@@ -149,3 +104,4 @@\n-    @MethodSource(\"provideConvertersForGetDateFormat\")\n-    void getDateFormat(TimeStringConverter converter) {\n-        assertNotNull(DateTimeStringConverterShim.getDateFormat(converter));\n+    @MethodSource(\"implementations\")\n+    void testConstructor(TestCase testCase) {\n+        DateFormat validFormatter = computeValidFormatter(testCase);\n+        assertEquals(validFormatter, DateTimeStringConverterShim.getDateFormat(testCase.converter()));\n@@ -160,5 +116,0 @@\n-    private static Stream<Arguments> provideConvertersForFromString() {\n-        return provideAllConverters()\n-                .map(args -> Arguments.of(args.get()[0], args.get()[3], args.get()[6]));\n-    }\n-\n@@ -166,4 +117,5 @@\n-    @MethodSource(\"provideConvertersForFromString\")\n-    void fromString_testValidInput(TimeStringConverter converter, Date validDate, DateFormat validFormatter) {\n-        String input = validFormatter.format(validDate);\n-        assertEquals(validDate, converter.fromString(input), \"Input = \" + input);\n+    @MethodSource(\"implementations\")\n+    void fromString_testValidInput(TestCase testCase) {\n+        DateFormat validFormatter = computeValidFormatter(testCase);\n+        String input = validFormatter.format(testCase.validDate());\n+        assertEquals(testCase.validDate(), testCase.converter().fromString(input), \"Input = \" + input);\n@@ -173,9 +125,5 @@\n-    @MethodSource(\"provideConvertersForFromString\")\n-    void fromString_testValidInputWithWhiteSpace(TimeStringConverter converter, Date validDate, DateFormat validFormatter) {\n-        String input = validFormatter.format(validDate);\n-        assertEquals(validDate, converter.fromString(\"      \" + input + \"      \"), \"Input = \" + input);\n-    }\n-\n-    private static Stream<Arguments> provideConvertersForException() {\n-        return provideAllConverters()\n-                .map(args -> Arguments.of(args.get()[0]));\n+    @MethodSource(\"implementations\")\n+    void fromString_testValidInputWithWhiteSpace(TestCase testCase) {\n+        DateFormat validFormatter = computeValidFormatter(testCase);\n+        String input = validFormatter.format(testCase.validDate());\n+        assertEquals(testCase.validDate(), testCase.converter().fromString(\"      \" + input + \"      \"), \"Input = \" + input);\n@@ -185,7 +133,3 @@\n-    @MethodSource(\"provideConvertersForException\")\n-    void fromString_testInvalidInput(TimeStringConverter converter) {\n-        assertThrows(RuntimeException.class, () -> converter.fromString(\"abcdefg\"));\n-    }\n-\n-    private static Stream<Arguments> provideConvertersForToString() {\n-        return provideConvertersForFromString();\n+    @MethodSource(\"implementations\")\n+    void fromString_testInvalidInput(TestCase testCase) {\n+        assertThrows(RuntimeException.class, () -> testCase.converter().fromString(\"abcdefg\"));\n@@ -195,3 +139,4 @@\n-    @MethodSource(\"provideConvertersForToString\")\n-    void toString_validOutput(TimeStringConverter converter, Date validDate, DateFormat validFormatter) {\n-        assertEquals(validFormatter.format(validDate), converter.toString(validDate));\n+    @MethodSource(\"implementations\")\n+    void toString_validOutput(TestCase testCase) {\n+        DateFormat validFormatter = computeValidFormatter(testCase);\n+        assertEquals(validFormatter.format(testCase.validDate()), testCase.converter().toString(testCase.validDate()));\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/TimeStringConverterTest.java","additions":60,"deletions":115,"binary":false,"changes":175,"status":"modified"}]}