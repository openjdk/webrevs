{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Optional;\n@@ -31,0 +32,1 @@\n+import javafx.collections.ListChangeListener;\n@@ -38,0 +40,1 @@\n+import javafx.scene.control.ToggleButton;\n@@ -39,0 +42,1 @@\n+import javafx.scene.control.Tooltip;\n@@ -41,0 +45,1 @@\n+import javafx.stage.Screen;\n@@ -56,1 +61,0 @@\n-\n@@ -69,0 +73,18 @@\n+        \/\/ Setup AlwaysOnTop checker\n+        final CheckBox onTopChecker = new CheckBox(\"AlwaysOnTop\");\n+        onTopChecker.setSelected(false);\n+        onTopChecker.setLayoutX(25);\n+        onTopChecker.setLayoutY(65);\n+        root.getChildren().add(onTopChecker);\n+\n+        \/\/ Setup secondary screen checker\n+        final CheckBox secondaryScreenChecker = new CheckBox(\"2nd Screen\");\n+        secondaryScreenChecker.setSelected(false);\n+        secondaryScreenChecker.setDisable(Screen.getScreens().size() < 2);\n+        secondaryScreenChecker.setLayoutX(25);\n+        secondaryScreenChecker.setLayoutY(90);\n+        Screen.getScreens().addListener((ListChangeListener.Change<? extends Screen> change) -> {\n+            secondaryScreenChecker.setDisable(Screen.getScreens().size() < 2);\n+        });\n+        root.getChildren().add(secondaryScreenChecker);\n+\n@@ -114,1 +136,2 @@\n-        Button button = new Button(\"Create Dialog\");\n+        Button button = new Button(\"Create Stage\");\n+        button.setTooltip(new Tooltip(\"Creates a new stage\"));\n@@ -124,0 +147,3 @@\n+                boolean alwaysOnTop = onTopChecker.isSelected();\n+                dialog.setAlwaysOnTop(alwaysOnTop);\n+\n@@ -156,1 +182,2 @@\n-                dialogButton.setLayoutX(275);\n+                dialogButton.setTooltip(new Tooltip(\"Hides (closes) this stage\"));\n+                dialogButton.setLayoutX(375);\n@@ -165,1 +192,0 @@\n-\n@@ -167,0 +193,16 @@\n+\n+                if (secondaryScreenChecker.isSelected()) {\n+                    Optional<Screen> otherScreen = Screen.getScreens()\n+                            .stream()\n+                            .filter(scr -> !Screen.getPrimary().equals(scr))\n+                            .findFirst();\n+                    otherScreen.ifPresent(scr -> {\n+                        double x = (scr.getVisualBounds().getWidth() - scene.getWidth()) \/ 2.0 +\n+                                scr.getVisualBounds().getMinX();\n+                        double y = (scr.getVisualBounds().getHeight()- scene.getHeight()) \/ 2.0 +\n+                                scr.getVisualBounds().getMinY();\n+                        dialog.setX(x);\n+                        dialog.setY(y);\n+                    });\n+                }\n+\n@@ -173,0 +215,1 @@\n+        button2.setTooltip(new Tooltip(\"Prints a message\"));\n@@ -182,0 +225,12 @@\n+        ToggleButton onTopButton = new ToggleButton(\"AlwaysOnTop\");\n+        onTopButton.setTooltip(new Tooltip(\"Toggles the alwaysOnTop property\"));\n+        onTopButton.setSelected(stage.isAlwaysOnTop());\n+        onTopButton.setLayoutX(275);\n+        onTopButton.setLayoutY(200);\n+        onTopButton.setOnAction(new EventHandler<ActionEvent>() {\n+            @Override public void handle(ActionEvent e) {\n+                stage.setAlwaysOnTop(onTopButton.isSelected());\n+            }\n+        });\n+        root.getChildren().add(onTopButton);\n+\n","filename":"apps\/toys\/Hello\/src\/main\/java\/hello\/HelloModality.java","additions":60,"deletions":5,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -194,2 +194,2 @@\n-    for (NSWindow * window = self->nsWindow; window; window = [window parentWindow]) {\n-        if (window == s_grabWindow) {\n+    for (GlassWindow * window = self; window; window = window->owner) {\n+        if (window->nsWindow == s_grabWindow) {\n@@ -285,1 +285,2 @@\n-    if ((self->owner != nil) && ([self->nsWindow parentWindow] == nil))\n+    \/\/ Fix up window stacking order\n+    if (self->owner != nil)\n@@ -287,1 +288,1 @@\n-        [self->owner addChildWindow:self->nsWindow ordered:NSWindowAbove];\n+        [self->owner reorderChildWindows];\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow+Java.m","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -62,0 +62,8 @@\n+- (void)windowDidChangeScreen:(NSNotification *)notification\n+{\n+    \/\/NSLog(@\"windowDidChangeScreen: %p  screen: %p\", self, [self->nsWindow screen]);\n+\n+    \/\/ Fix up window stacking order\n+    [self reorderChildWindows];\n+}\n+\n@@ -64,0 +72,1 @@\n+    \/\/NSLog(@\"windowDidBecomeKey: %p\", self);\n@@ -79,0 +88,3 @@\n+\n+    \/\/ Fix up window stacking order\n+    [self reorderChildWindows];\n@@ -83,0 +95,1 @@\n+    \/\/NSLog(@\"windowDidResignKey: %p\", self);\n@@ -93,4 +106,4 @@\n-    \/\/ Unparent self. Otherwise the code hangs\n-    if ([self->nsWindow parentWindow])\n-    {\n-        [[self->nsWindow parentWindow] removeChildWindow:self->nsWindow];\n+    \/\/NSLog(@\"windowWillClose\");\n+    \/\/ Remove self from list of owner's child windows\n+    if (self->owner != nil) {\n+        [self->owner removeChildWindow:self];\n@@ -100,5 +113,12 @@\n-    NSArray *children = [self->nsWindow childWindows];\n-    for (NSUInteger i=0; i<[children count]; i++)\n-    {\n-        NSWindow *child = (NSWindow*)[children objectAtIndex:i];\n-        [child close];\n+    if (self->childWindows != nil) {\n+        \/\/ Iterate over an immutable copy\n+        NSArray *children = [[NSArray alloc] initWithArray:self->childWindows];\n+        for (GlassWindow *child in children) {\n+            [child->nsWindow close];\n+        }\n+        [children release];\n+    }\n+\n+    \/\/ If we have an owner, reorder its remaining children\n+    if (self->owner != nil) {\n+        [self->owner reorderChildWindows];\n@@ -163,0 +183,5 @@\n+- (void)windowWillMiniaturize:(NSNotification *)notification\n+{\n+    \/\/NSLog(@\"windowWillMiniaturize: %p\", self);\n+}\n+\n@@ -165,0 +190,1 @@\n+    \/\/NSLog(@\"windowDidMiniaturize: %p\", self);\n@@ -166,0 +192,1 @@\n+    [self minimizeChildWindows:YES];\n@@ -170,0 +197,1 @@\n+    \/\/NSLog(@\"windowDidDeminiaturize: %p\", self);\n@@ -171,0 +199,2 @@\n+    [self minimizeChildWindows:NO];\n+    [self reorderChildWindows];\n@@ -203,0 +233,2 @@\n+    \/\/ Allow child windows to move to the same space as this full-screen window\n+    [self setMoveToActiveSpaceChildWindows:YES];\n@@ -210,0 +242,4 @@\n+\n+    \/\/ Fix up window stacking order then disable moving child windows to active space\n+    [self reorderChildWindows];\n+    [self setMoveToActiveSpaceChildWindows:NO];\n@@ -237,0 +273,3 @@\n+\n+    \/\/ Fix up window stacking order\n+    [self reorderChildWindows];\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow+Overrides.m","additions":48,"deletions":9,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -42,1 +42,5 @@\n-    NSWindow            *owner;\n+    \/\/ Owner glass window and list of owned \"child\" glass windows\n+    \/\/ (we don't create NSWindow children)\n+    GlassWindow         *owner;\n+    NSMutableArray<GlassWindow*> *childWindows;\n+\n@@ -62,0 +66,2 @@\n+    NSWindowLevel       prefLevel; \/\/ Preferred level for this window\n+\n@@ -72,0 +78,7 @@\n+\/\/ Helper methods for owned windows\n+- (void) addChildWindow:(GlassWindow*)childWindow;\n+- (void) removeChildWindow:(GlassWindow*)childWindow;\n+- (void) reorderChildWindows;\n+- (void) minimizeChildWindows:(BOOL)minimize;\n+- (void) setMoveToActiveSpaceChildWindows:(BOOL)moveToActiveSpace;\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow.h","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -312,0 +312,1 @@\n+        [self reorderChildWindows];\n@@ -348,0 +349,83 @@\n+- (void) addChildWindow:(GlassWindow*)childWindow\n+{\n+    LOG(\"addChildWindow: %p  child: %p\", self, childWindow);\n+    if (self->childWindows == nil) {\n+        self->childWindows = [[NSMutableArray alloc] init];\n+    }\n+    [self->childWindows addObject:childWindow];\n+}\n+\n+- (void) removeChildWindow:(GlassWindow*)childWindow\n+{\n+    LOG(\"removeChildWindow: %p  child: %p\", self, childWindow);\n+    if (self->childWindows != nil) {\n+        [self->childWindows removeObject:childWindow];\n+    }\n+}\n+\n+\/\/\n+\/\/ Recursively orders all child windows so that they are above their owner.\n+\/\/\n+- (void) reorderChildWindows\n+{\n+    LOG(\"reorderChildWindows: %p\", self);\n+    if (self->childWindows != nil) {\n+        for (GlassWindow *child in self->childWindows)\n+        {\n+            \/\/ Owned windows must set their level to at least the level of their owner\n+            NSWindowLevel level = MAX(child->prefLevel, [self->nsWindow level]);\n+            [child->nsWindow setLevel:level];\n+            \/\/ Order child above the owner window\n+            [child->nsWindow orderWindow:NSWindowAbove relativeTo:[self->nsWindow windowNumber]];\n+\n+            [child reorderChildWindows];\n+        }\n+    }\n+}\n+\n+\/\/\n+\/\/ Recursively minimize or unminimize all child windows.\n+\/\/\n+- (void) minimizeChildWindows:(BOOL)minimize\n+{\n+    LOG(\"minimizeChildWindows: %p  minimize:%d\", self, minimize);\n+    if (self->childWindows != nil) {\n+        for (GlassWindow *child in self->childWindows)\n+        {\n+            if (minimize) {\n+                [child->nsWindow orderOut:child];\n+            } else {\n+                [child->nsWindow orderFront:child];\n+            }\n+\n+            [child minimizeChildWindows:minimize];\n+        }\n+    }\n+}\n+\n+\/\/\n+\/\/ Recursively set the collection behavior for the child windows to enable or\n+\/\/ disable the \"move to active space\" behavior. This is used when the owner\n+\/\/ enters full-screen, so that the children will follow the owner to the\n+\/\/ full-screen space. It is called with \"true\" when first entering full screen\n+\/\/ and \"false\" once the transition to full-screen is complete.\n+\/\/\n+- (void) setMoveToActiveSpaceChildWindows:(BOOL)moveToActiveSpace\n+{\n+    LOG(\"setMoveToActiveSpaceChildWindows: %p  moveToActiveSpace:%d\", self, moveToActiveSpace);\n+    if (self->childWindows != nil) {\n+        for (GlassWindow *child in self->childWindows)\n+        {\n+            NSWindowCollectionBehavior behavior = [child->nsWindow collectionBehavior];\n+            if (moveToActiveSpace) {\n+                behavior |= NSWindowCollectionBehaviorMoveToActiveSpace;\n+            } else {\n+                behavior &= ~NSWindowCollectionBehaviorMoveToActiveSpace;\n+            }\n+            [child->nsWindow setCollectionBehavior: behavior];\n+\n+            [child setMoveToActiveSpaceChildWindows:moveToActiveSpace];\n+        }\n+    }\n+}\n+\n@@ -465,3 +549,1 @@\n-            if (!jOwnerPtr) {\n-                [window->nsWindow setLevel:NSNormalWindowLevel];\n-            }\n+            [window->nsWindow setLevel:NSNormalWindowLevel];\n@@ -470,0 +552,1 @@\n+        window->prefLevel = [window->nsWindow level];\n@@ -472,1 +555,7 @@\n-            window->owner = getGlassWindow(env, jOwnerPtr)->nsWindow; \/\/ not retained (use weak reference?)\n+            \/\/ Get owner glass window and add this window as a child window\n+            window->owner = getGlassWindow(env, jOwnerPtr);\n+            [window->owner addChildWindow:window];\n+\n+            \/\/ Owned windows must set their level to at least the level of their owner\n+            NSWindowLevel level = MAX(window->prefLevel, [window->owner->nsWindow level]);\n+            [window->nsWindow setLevel:level];\n@@ -683,0 +772,5 @@\n+        window->prefLevel = level; \/\/ Save preferred level\n+        if (window->owner != nil) {\n+            \/\/ Owned windows must set their level to at least the level of their owner\n+            level = MAX(level, [window->owner->nsWindow level]);\n+        }\n@@ -684,0 +778,1 @@\n+        [window reorderChildWindows];\n@@ -1227,5 +1322,0 @@\n-            if (window->owner != nil)\n-            {\n-                LOG(\"   removeChildWindow: %p\", window);\n-                [window->owner removeChildWindow:window->nsWindow];\n-            }\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow.m","additions":99,"deletions":9,"binary":false,"changes":108,"status":"modified"}]}