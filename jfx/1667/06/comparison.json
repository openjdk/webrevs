{"files":[{"patch":"@@ -37,0 +37,1 @@\n+--add-exports=javafx.graphics\/com.sun.javafx.text=ALL-UNNAMED\n","filename":"modules\/javafx.controls\/src\/test\/addExports","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,1 +191,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(series1).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(series1, lineChart);\n@@ -213,1 +213,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -235,1 +235,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -258,1 +258,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -281,1 +281,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -303,1 +303,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -325,1 +325,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -347,1 +347,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -369,1 +369,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -393,1 +393,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -417,1 +417,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -441,1 +441,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -465,1 +465,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -488,1 +488,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -511,1 +511,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -533,1 +533,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -556,1 +556,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -580,1 +580,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -603,1 +603,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -626,1 +626,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -649,1 +649,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -672,1 +672,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -695,1 +695,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -718,1 +718,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -741,1 +741,1 @@\n-        assertArrayEquals(convertSeriesDataToPoint2D(expectedSeries).toArray(), findDataPointsFromPathLine(lineChart).toArray());\n+        eq(expectedSeries, lineChart);\n@@ -780,0 +780,13 @@\n+\n+    private void eq(XYChart.Series<Number, Number> expected, LineChart<Number, Number> ch) {\n+        List<Point2D> exp = convertSeriesDataToPoint2D(expected);\n+        List<Point2D> res = findDataPointsFromPathLine(lineChart);\n+\n+        assertEquals(exp.size(), res.size());\n+        for (int i = 0; i < exp.size(); i++) {\n+            Point2D pe = exp.get(i);\n+            Point2D pr = res.get(i);\n+            assertEquals(pe.getX(), pr.getX(), 1e-9, \"at index \" + i + \" expected=\" + pe + \" actual=\" + pr);\n+            assertEquals(pe.getY(), pr.getY(), 1e-9, \"at index \" + i + \" expected=\" + pe + \" actual=\" + pr);\n+        }\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/chart\/LineChartTest.java","additions":39,"deletions":26,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,1 +116,1 @@\n-        assertEquals(\"10 453 218 35 238 409 218 79 465 355 218 133 \", bounds);\n+        assertEquals(\"10 440 216 34 236 397 216 77 461 345 216 129 \", bounds);\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/chart\/StackedBarChartTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,1 +188,1 @@\n-        assertEquals(60, accordion.prefHeight(-1), 1e-100);\n+        assertEquals(78, accordion.prefHeight(-1), 1e-100);\n@@ -198,1 +198,1 @@\n-                                          PlatformImpl.isModena()  ? 161 :\n+                                          PlatformImpl.isModena()  ? 179 :\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/AccordionTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1820,3 +1820,3 @@\n-        assertEquals(6, leadSelectedIndex);\n-        assertEquals(6, fm.getFocusedIndex());\n-        assertEquals(7, selectedIndicesCount);\n+        assertEquals(4, leadSelectedIndex);\n+        assertEquals(4, fm.getFocusedIndex());\n+        assertEquals(5, selectedIndicesCount);\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ListViewKeyInputTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,1 @@\n+import javafx.scene.text.Font;\n@@ -99,0 +100,6 @@\n+\/**\n+ * NOTE: these tests contain magic numbers which depend on the default font size,\n+ * meaning they are guaranteed to break when\/if the default size changes.\n+ * A possible improvement might be to get the default font size and derive the expected\n+ * numbers and preferred sizes.\n+ *\/\n@@ -706,1 +713,1 @@\n-        assertTrue(scrollBar.getVisibleAmount() > 0.15);\n+        assertTrue(scrollBar.getVisibleAmount() > 0.10);\n@@ -829,1 +836,1 @@\n-        assertEquals(24, rt_31200_count);\n+        assertEquals(22, rt_31200_count);\n@@ -836,1 +843,1 @@\n-        assertEquals(24, rt_31200_count);\n+        assertEquals(22, rt_31200_count);\n@@ -1139,1 +1146,2 @@\n-    private int rt_35395_counter;\n+    private class Counter {\n+        public int updateCount;\n@@ -1141,2 +1149,5 @@\n-    private void test_rt_35395(boolean useFixedCellSize) {\n-        rt_35395_counter = 0;\n+        public static void reset(List<Counter> items) {\n+            for (Counter c : items) {\n+                c.updateCount = 0;\n+            }\n+        }\n@@ -1144,1 +1155,14 @@\n-        ObservableList<String> items = FXCollections.observableArrayList();\n+        \/\/ verifies problem of JDK-8091726: that an update() method is not called more than once\n+        public static void verify(List<Counter> items) {\n+            for (int i = 0; i < items.size(); i++) {\n+                Counter c = items.get(i);\n+                int count = c.updateCount;\n+                c.updateCount = 0;\n+                assertTrue(c.updateCount < 2, \"index=\" + i + \" updateCount=\" + count);\n+            }\n+        }\n+    }\n+\n+    \/\/ JDK-8091726\n+    private void test_rt_35395(boolean useFixedCellSize) {\n+        ObservableList<Counter> items = FXCollections.observableArrayList();\n@@ -1146,1 +1170,1 @@\n-            items.addAll(\"red\", \"green\", \"blue\", \"purple\");\n+            items.addAll(new Counter(), new Counter(), new Counter(), new Counter());\n@@ -1149,1 +1173,1 @@\n-        ListView<String> listView = new ListView<>(items);\n+        ListView<Counter> listView = new ListView<>(items);\n@@ -1151,1 +1175,1 @@\n-            listView.setFixedCellSize(24);\n+            listView.setFixedCellSize(18);\n@@ -1155,3 +1179,5 @@\n-            public void updateItem(String color, boolean empty) {\n-                rt_35395_counter += 1;\n-                super.updateItem(color, empty);\n+            public void updateItem(Counter item, boolean empty) {\n+                if (item != null) {\n+                    item.updateCount++;\n+                }\n+                super.updateItem(item, empty);\n@@ -1163,1 +1189,1 @@\n-                    rect.setStyle(\"-fx-fill: \" + color);\n+                    rect.setStyle(\"-fx-fill: red\");\n@@ -1172,2 +1198,2 @@\n-            rt_35395_counter = 0;\n-            items.set(10, \"yellow\");\n+            Counter.reset(items);\n+            items.set(10, new Counter());\n@@ -1176,3 +1202,3 @@\n-                assertEquals(1, rt_35395_counter);\n-                rt_35395_counter = 0;\n-                items.set(30, \"yellow\");\n+                Counter.verify(items);\n+\n+                items.set(30, new Counter());\n@@ -1181,2 +1207,2 @@\n-                    assertTrue(rt_35395_counter < 7);\n-                    rt_35395_counter = 0;\n+                    Counter.verify(items);\n+\n@@ -1186,3 +1212,3 @@\n-                        assertEquals(useFixedCellSize ? 5 : 7, rt_35395_counter);\n-                        rt_35395_counter = 0;\n-                        items.add(12, \"yellow\");\n+                        Counter.verify(items);\n+\n+                        items.add(12, new Counter());\n@@ -1191,2 +1217,2 @@\n-                            assertEquals(useFixedCellSize ? 5 : 7, rt_35395_counter);\n-                            rt_35395_counter = 0;\n+                            Counter.verify(items);\n+\n@@ -1196,2 +1222,2 @@\n-                                assertTrue(rt_35395_counter < 30);\n-                                rt_35395_counter = 0;\n+                                Counter.verify(items);\n+\n@@ -1201,1 +1227,2 @@\n-                                    assertEquals(useFixedCellSize ? 17 : 101, rt_35395_counter);\n+                                    Counter.verify(items);\n+\n@@ -2389,1 +2416,4 @@\n-        final ObservableList<Integer> items = FXCollections.observableArrayList(300, 300, 70, 20);\n+        int S = 25;\n+        int M = 26;\n+        int L = 70;\n+        final ObservableList<Integer> items = FXCollections.observableArrayList(300, 300, L, S);\n@@ -2391,2 +2421,3 @@\n-        listView.setPrefHeight(400);\n-        double viewportLength = 398; \/\/ it would be better to calculate this from listView but there is no API for this\n+        double prefHeight = 400;\n+        listView.setPrefHeight(prefHeight);\n+        double viewportLength = toViewportLength(prefHeight);\n@@ -2407,2 +2438,2 @@\n-        boolean got70 = false;\n-        boolean got20 = false;\n+        boolean gotLarge = false;\n+        boolean gotSmall = false;\n@@ -2411,3 +2442,3 @@\n-            if ((cell != null) && (cell.getItem() == 20)) {\n-                assertEquals(viewportLength - 20, cell.getLayoutY(), 1., \"Last cell doesn't end at listview end\");\n-                got20 = true;\n+            if ((cell != null) && (cell.getItem() == S)) {\n+                assertEquals(viewportLength - S, cell.getLayoutY(), 1., \"Last cell doesn't end at listview end\");\n+                gotSmall = true;\n@@ -2415,3 +2446,3 @@\n-            if ((cell != null) && (cell.getItem() == 70)) {\n-                assertEquals(viewportLength - 20 - 70, cell.getLayoutY(), 1., \"Secondlast cell doesn't end properly\");\n-                got70 = true;\n+            if ((cell != null) && (cell.getItem() == L)) {\n+                assertEquals(viewportLength - S - L, cell.getLayoutY(), 1., \"Secondlast cell doesn't end properly\");\n+                gotLarge = true;\n@@ -2420,2 +2451,2 @@\n-        assertTrue(got20);\n-        assertTrue(got70);\n+        assertTrue(gotSmall);\n+        assertTrue(gotLarge);\n@@ -2424,1 +2455,1 @@\n-        list.addAll(300, 300, 20, 21);\n+        list.addAll(300, 300, S, M);\n@@ -2428,2 +2459,2 @@\n-        got20 = false;\n-        boolean got21 = false;\n+        gotSmall = false;\n+        boolean gotMedium = false;\n@@ -2432,3 +2463,3 @@\n-            if ((cell != null) && (cell.getItem() == 21)) {\n-                assertEquals(viewportLength - 21, cell.getLayoutY(), 1., \"Last cell doesn't end at listview end\");\n-                got21 = true;\n+            if ((cell != null) && (cell.getItem() == M)) {\n+                assertEquals(viewportLength - M, cell.getLayoutY(), 1., \"Last cell doesn't end at listview end\");\n+                gotMedium = true;\n@@ -2436,3 +2467,3 @@\n-            if ((cell != null) && (cell.getItem() == 20)) {\n-                assertEquals(viewportLength - 21 - 20, cell.getLayoutY(), 1., \"Secondlast cell doesn't end properly\");\n-                got20 = true;\n+            if ((cell != null) && (cell.getItem() == S)) {\n+                assertEquals(viewportLength - M - S, cell.getLayoutY(), 1., \"Secondlast cell doesn't end properly\");\n+                gotSmall = true;\n@@ -2441,2 +2472,2 @@\n-        assertTrue(got20);\n-        assertTrue(got21);\n+        assertTrue(gotSmall);\n+        assertTrue(gotMedium);\n@@ -2447,1 +2478,3 @@\n-        final ObservableList<Integer> items = FXCollections.observableArrayList(200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20);\n+        int S = 25;\n+        int L = 200;\n+        final ObservableList<Integer> items = FXCollections.observableArrayList(L, L, L, L, L, L, L, L, S, S, S, S, S, S, S);\n@@ -2449,2 +2482,3 @@\n-        listView.setPrefHeight(400);\n-        double viewportLength = 398;\n+        double prefHeight = 400;\n+        listView.setPrefHeight(prefHeight);\n+        double viewportLength = toViewportLength(prefHeight);\n@@ -2466,1 +2500,0 @@\n-        boolean got70 = false;\n@@ -2471,1 +2504,1 @@\n-            double exp = 398 - 20 * tens - 200 * hundreds;\n+            double exp = viewportLength - S * tens - L * hundreds;\n@@ -2474,1 +2507,1 @@\n-                assertEquals(exp, real, 0.1);\n+                assertEquals(exp, real, 0.1, \"index=\" + i);\n@@ -2481,0 +2514,1 @@\n+        Integer S = 25;\n@@ -2483,4 +2517,4 @@\n-        testScrollTo(360, 3, new Integer[]{20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20});\n-        testScrollTo(360, 3, new Integer[]{20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20});\n-        testScrollTo(360, 1, new Integer[]{20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20});\n-        testScrollTo(360, -1, new Integer[]{20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20});\n+        testScrollTo(360, 3, new Integer[] { S, S, S, S, S, S, S, S, S, S, S, S });\n+        testScrollTo(360, 3, new Integer[] { S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S });\n+        testScrollTo(360, 1, new Integer[] { S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S });\n+        testScrollTo(360, -1, new Integer[] { S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S });\n@@ -2493,21 +2527,20 @@\n-        testScrollTo(360, 2, new Integer[]{300, 300, 70, 20});\n-        testScrollTo(400, 2, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20});\n-        testScrollTo(400, -1, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20});\n-        testScrollTo(400, 3, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20});\n-        testScrollTo(400, -1, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 500, 20, 500, 20, 500});\n-        testScrollTo(400, -1, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 400, 20, 400, 20, 400});\n-        testScrollTo(400, 2, new Integer[]{500, 500, 20, 20, 100, 100, 100, 100, 100, 100});\n-        testScrollTo(400, 8, new Integer[]{500, 500, 20, 20, 100, 100, 100, 100, 100, 100, 300, 300, 300, 300});\n-\n-        testScrollTo(400, 2, new Integer[]{300, 300, 20, 20});\n-        testScrollTo(400, 2, new Integer[]{300, 300, 20, 20, 200, 200});\n-        testScrollTo(400, 2, new Integer[]{20, 20, 20, 500, 500});\n-\n-        testScrollTo(400, 2, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20});\n-        testScrollTo(400, -1, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20});\n-        testScrollTo(400, 3, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 20});\n-        testScrollTo(400, -1, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 500, 20, 500, 20, 500});\n-        testScrollTo(400, -1, new Integer[]{200, 200, 200, 200, 200, 200, 200, 200, 20, 20, 20, 20, 20, 20, 400, 20, 400, 20, 400});\n-        testScrollTo(400, 2, new Integer[]{500, 500, 20, 20, 100, 100, 100, 100, 100, 100});\n-        testScrollTo(400, 2, new Integer[]{500, 500, 500, 500, 500});\n-\n+        testScrollTo(360, 2, new Integer[] { 300, 300, 70, S });\n+        testScrollTo(410, 2, new Integer[] { 200, 200, 200, 200, 200, 200, 200, 200, S, S, S, S, S, S, S });\n+        testScrollTo(400, -1, new Integer[] { 200, 200, 200, 200, 200, 200, 200, 200, S, S, S, S, S, S, S });\n+        testScrollTo(420, 3, new Integer[] { 200, 200, 200, 200, 200, 200, 200, 200, S, S, S, S, S, S, S });\n+        testScrollTo(400, -1, new Integer[] { 200, 200, 200, 200, 200, 200, 200, 200, S, S, S, S, S, S, 500, S, 500, S, 500 });\n+        testScrollTo(400, -1, new Integer[] { 200, 200, 200, 200, 200, 200, 200, 200, S, S, S, S, S, S, 400, S, 400, S, 400 });\n+        testScrollTo(420, 2, new Integer[] { 500, 500, S, S, 100, 100, 100, 100, 100, 100 });\n+        testScrollTo(420, 8, new Integer[] { 500, 500, S, S, 100, 100, 100, 100, 100, 100, 300, 300, 300, 300 });\n+\n+        testScrollTo(400, 2, new Integer[] { 300, 300, S, S });\n+        testScrollTo(400, 2, new Integer[] { 300, 300, S, S, 200, 200 });\n+        testScrollTo(400, 2, new Integer[] { S, S, S, 500, 500 });\n+\n+        testScrollTo(400, 2, new Integer[] { 200, 200, 200, 200, 200, 200, 200, 200, S, S, S, S, S, S, S });\n+        testScrollTo(400, -1, new Integer[] { 200, 200, 200, 200, 200, 200, 200, 200, S, S, S, S, S, S, S });\n+        testScrollTo(420, 3, new Integer[] { 200, 200, 200, 200, 200, 200, 200, 200, S, S, S, S, S, S, S });\n+        testScrollTo(400, -1, new Integer[] { 200, 200, 200, 200, 200, 200, 200, 200, S, S, S, S, S, S, 500, S, 500, S, 500 });\n+        testScrollTo(400, -1, new Integer[] { 200, 200, 200, 200, 200, 200, 200, 200, S, S, S, S, S, S, 400, S, 400, S, 400 });\n+        testScrollTo(420, 2, new Integer[] { 500, 500, S, S, 100, 100, 100, 100, 100, 100 });\n+        testScrollTo(400, 2, new Integer[] { 500, 500, 500, 500, 500 });\n@@ -2572,1 +2605,1 @@\n-        double viewportLength = listViewHeight - 2; \/\/ it would be better to calculate this from listView but there is no API for this\n+        double viewportLength = toViewportLength(listViewHeight);\n@@ -2668,0 +2701,5 @@\n+\n+    private static double toViewportLength(double prefHeight) {\n+        \/\/ it would be better to calculate this from listView but there is no API for this\n+        return prefHeight - 2;\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ListViewTest.java","additions":124,"deletions":86,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2028,3 +2028,3 @@\n-        assertEquals(6, leadSelectedIndex);\n-        assertEquals(6, fm.getFocusedIndex());\n-        assertEquals(7, selectedIndicesCount);\n+        assertEquals(4, leadSelectedIndex);\n+        assertEquals(4, fm.getFocusedIndex());\n+        assertEquals(5, selectedIndicesCount);\n@@ -2071,1 +2071,1 @@\n-        final int diff = 4;\/\/99 - leadSelectedIndex;\n+        final int diff = 2;\/\/99 - leadSelectedIndex;\n@@ -2074,1 +2074,1 @@\n-        assertEquals(5, selectedIndicesCount);\n+        assertEquals(3, selectedIndicesCount);\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeViewKeyInputTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1004,1 +1004,1 @@\n-        assertTrue(scrollBar.getVisibleAmount() > 0.15);\n+        assertTrue(scrollBar.getVisibleAmount() > 0.10);\n@@ -1212,1 +1212,1 @@\n-        assertEquals(24, rt_31200_count);\n+        assertEquals(22, rt_31200_count);\n@@ -1219,1 +1219,1 @@\n-        assertEquals(24, rt_31200_count);\n+        assertEquals(22, rt_31200_count);\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeViewTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -18,0 +18,1 @@\n+--add-exports=javafx.graphics\/com.sun.javafx.text=ALL-UNNAMED\n","filename":"modules\/javafx.fxml\/src\/test\/addExports","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import com.sun.javafx.text.GlyphLayoutManager;\n@@ -162,0 +163,5 @@\n+\n+    @Override\n+    public void dispose() {\n+        GlyphLayoutManager.dispose(this);\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/coretext\/CTGlyphLayout.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-\n@@ -37,0 +36,1 @@\n+import com.sun.javafx.text.GlyphLayoutManager;\n@@ -410,0 +410,5 @@\n+\n+    @Override\n+    public void dispose() {\n+        GlyphLayoutManager.dispose(this);\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/directwrite\/DWGlyphLayout.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-\n@@ -39,0 +38,1 @@\n+import com.sun.javafx.text.GlyphLayoutManager;\n@@ -94,1 +94,1 @@\n-        return new StubGlyphLayout();\n+        return new FTStubGlyphLayout();\n@@ -122,1 +122,1 @@\n-    private static class StubGlyphLayout extends GlyphLayout {\n+    private static class FTStubGlyphLayout extends GlyphLayout {\n@@ -124,1 +124,1 @@\n-        public StubGlyphLayout() {\n+        public FTStubGlyphLayout() {\n@@ -130,0 +130,5 @@\n+\n+        @Override\n+        public void dispose() {\n+            GlyphLayoutManager.dispose(this);\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/freetype\/FTFactory.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import com.sun.javafx.text.GlyphLayoutManager;\n@@ -40,0 +41,4 @@\n+    @Override\n+    public void dispose() {\n+        GlyphLayoutManager.dispose(this);\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/freetype\/HBGlyphLayout.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n@@ -35,0 +38,1 @@\n+import com.sun.javafx.text.GlyphLayoutManager;\n@@ -37,4 +41,0 @@\n-import java.util.Arrays;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-\n@@ -208,1 +208,2 @@\n-        super.dispose();\n+        GlyphLayoutManager.dispose(this);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/freetype\/PangoGlyphLayout.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -96,0 +97,20 @@\n+\n+    \/**\n+     * Returns true if this GlyphList is a line break.\n+     * @return whether this GlyphList is a line break\n+     *\/\n+    public boolean isLinebreak();\n+\n+    \/**\n+     * Returns the start offset.\n+     * @return the start offset\n+     *\/\n+    public int getStart();\n+\n+    \/**\n+     * Gets the glyph offset at the specified x coordinate.\n+     * @param x the x coordinate\n+     * @param trailing the reference to hold the trailing flag\n+     * @return the glyph offset\n+     *\/\n+    public int getOffsetAtX(float x, AtomicBoolean trailing);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/text\/GlyphList.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-     * The bounds for embedded object, only used the font returns null.\n+     * The bounds for embedded object, only used when the font returns null.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/text\/TextSpan.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import javafx.geometry.VPos;\n-import javafx.scene.text.Font;\n@@ -31,0 +29,1 @@\n+import java.util.LinkedList;\n@@ -33,1 +32,3 @@\n-import java.util.LinkedList;\n+import javafx.geometry.VPos;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.FontSmoothingType;\n@@ -49,0 +50,1 @@\n+import com.sun.javafx.scene.text.TextLayout;\n@@ -50,0 +52,1 @@\n+import com.sun.javafx.text.PrismTextLayoutFactory;\n@@ -75,1 +78,0 @@\n-import javafx.scene.text.FontSmoothingType;\n@@ -335,1 +337,1 @@\n-    private PrismTextLayout textLayout;\n+    private TextLayout textLayout;\n@@ -371,1 +373,1 @@\n-        textLayout = new PrismTextLayout();\n+        textLayout = PrismTextLayoutFactory.getFactory().createLayout();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGCanvas.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -387,46 +387,1 @@\n-    \/* This scheme creates a singleton GlyphLayout which is checked out\n-     * for use. Callers who find its checked out create one that after use\n-     * is discarded. This means that in a MT-rendering environment,\n-     * there's no need to synchronise except for that one instance.\n-     * Fewer threads will then need to synchronise, perhaps helping\n-     * throughput on a MP system. If for some reason the reusable\n-     * GlyphLayout is checked out for a long time (or never returned?) then\n-     * we would end up always creating new ones. That situation should not\n-     * occur and if if did, it would just lead to some extra garbage being\n-     * created.\n-     *\/\n-    private static GlyphLayout reusableGL = newInstance();\n-    private static boolean inUse;\n-\n-    private static GlyphLayout newInstance() {\n-        PrismFontFactory factory = PrismFontFactory.getFontFactory();\n-        return factory.createGlyphLayout();\n-    }\n-\n-    public static GlyphLayout getInstance() {\n-        \/* The following heuristic is that if the reusable instance is\n-         * in use, it probably still will be in a micro-second, so avoid\n-         * synchronising on the class and just allocate a new instance.\n-         * The cost is one extra boolean test for the normal case, and some\n-         * small number of cases where we allocate an extra object when\n-         * in fact the reusable one would be freed very soon.\n-         *\/\n-        if (inUse) {\n-            return newInstance();\n-        } else {\n-            synchronized(GlyphLayout.class) {\n-                if (inUse) {\n-                    return newInstance();\n-                } else {\n-                    inUse = true;\n-                    return reusableGL;\n-                }\n-            }\n-        }\n-    }\n-\n-    public void dispose() {\n-        if (this == reusableGL) {\n-            inUse = false;\n-        }\n-    }\n+    public abstract void dispose();\n@@ -444,1 +399,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/GlyphLayout.java","additions":2,"deletions":48,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.javafx.text;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import com.sun.javafx.font.PrismFontFactory;\n+\n+\/* This class creates a singleton GlyphLayout which is checked out\n+ * for use. Callers who find its checked out create one that after use\n+ * is discarded. This means that in a MT-rendering environment,\n+ * there's no need to synchronise except for that one instance.\n+ * Fewer threads will then need to synchronise, perhaps helping\n+ * throughput on a MP system. If for some reason the reusable\n+ * GlyphLayout is checked out for a long time (or never returned?) then\n+ * we would end up always creating new ones. That situation should not\n+ * occur and if if did, it would just lead to some extra garbage being\n+ * created.\n+ *\/\n+public class GlyphLayoutManager {\n+    private static GlyphLayout REUSABLE_INSTANCE = newInstance();\n+    private static final AtomicBoolean GUARD = new AtomicBoolean(false);\n+\n+    private static GlyphLayout newInstance() {\n+        PrismFontFactory factory = PrismFontFactory.getFontFactory();\n+        return factory.createGlyphLayout();\n+    }\n+\n+    public static GlyphLayout getInstance() {\n+        if (GUARD.compareAndSet(false, true)) {\n+            return REUSABLE_INSTANCE;\n+        } else {\n+            return newInstance();\n+        }\n+    }\n+\n+    public static void dispose(GlyphLayout la) {\n+        if (la == REUSABLE_INSTANCE) {\n+            GUARD.set(false);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/GlyphLayoutManager.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -41,1 +42,0 @@\n-import com.sun.javafx.font.PrismFontFactory;\n@@ -54,1 +54,4 @@\n-public class PrismTextLayout implements TextLayout {\n+\/**\n+ * Prism TextLayout\n+ *\/\n+public abstract class PrismTextLayout implements TextLayout {\n@@ -65,1 +68,0 @@\n-    private static final int MAX_CACHE_SIZE = PrismFontFactory.cacheLayoutSize;\n@@ -67,0 +69,1 @@\n+    private final int maxCacheSize;\n@@ -84,1 +87,2 @@\n-    public PrismTextLayout() {\n+    public PrismTextLayout(int maxCacheSize) {\n+        this.maxCacheSize = maxCacheSize;\n@@ -141,1 +145,1 @@\n-        if (MAX_CACHE_SIZE > 0) {\n+        if (maxCacheSize > 0) {\n@@ -451,1 +455,1 @@\n-                int[] trailing = new int[1];\n+                AtomicBoolean trailing = new AtomicBoolean();\n@@ -453,1 +457,1 @@\n-                leading = (trailing[0] == 0);\n+                leading = !trailing.get();\n@@ -822,1 +826,1 @@\n-        GlyphLayout layout = GlyphLayout.getInstance();\n+        GlyphLayout layout = glyphLayout();\n@@ -830,0 +834,2 @@\n+    protected abstract GlyphLayout glyphLayout();\n+\n@@ -1202,1 +1208,1 @@\n-            layout = GlyphLayout.getInstance();\n+            layout = glyphLayout();\n@@ -1478,1 +1484,1 @@\n-                    if (cacheSize + charCount > MAX_CACHE_SIZE) {\n+                    if (cacheSize + charCount > maxCacheSize) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismTextLayout.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import com.sun.javafx.font.PrismFontFactory;\n+import com.sun.javafx.scene.text.TextLayout;\n@@ -31,1 +34,1 @@\n-\n+    private static final PrismTextLayoutFactory FACTORY = new PrismTextLayoutFactory();\n@@ -33,2 +36,2 @@\n-    private static final PrismTextLayout reusableTL = new PrismTextLayout();\n-    private static boolean inUse;\n+    private static final TextLayout REUSABLE_INSTANCE = FACTORY.createLayout();\n+    private static final AtomicBoolean GUARD = new AtomicBoolean(false);\n@@ -40,2 +43,7 @@\n-    public com.sun.javafx.scene.text.TextLayout createLayout() {\n-        return new PrismTextLayout();\n+    public TextLayout createLayout() {\n+        return new PrismTextLayout(PrismFontFactory.cacheLayoutSize) {\n+            @Override\n+            protected GlyphLayout glyphLayout() {\n+                return GlyphLayoutManager.getInstance();\n+            }\n+        };\n@@ -45,3 +53,7 @@\n-    public com.sun.javafx.scene.text.TextLayout getLayout() {\n-        if (inUse) {\n-            return new PrismTextLayout();\n+    public TextLayout getLayout() {\n+        if (GUARD.compareAndSet(false, true)) {\n+            REUSABLE_INSTANCE.setAlignment(0);\n+            REUSABLE_INSTANCE.setWrapWidth(0);\n+            REUSABLE_INSTANCE.setDirection(0);\n+            REUSABLE_INSTANCE.setContent(null);\n+            return REUSABLE_INSTANCE;\n@@ -49,12 +61,1 @@\n-            synchronized(PrismTextLayoutFactory.class) {\n-                if (inUse) {\n-                    return new PrismTextLayout();\n-                } else {\n-                    inUse = true;\n-                    reusableTL.setAlignment(0);\n-                    reusableTL.setWrapWidth(0);\n-                    reusableTL.setDirection(0);\n-                    reusableTL.setContent(null);\n-                    return reusableTL;\n-                }\n-            }\n+            return createLayout();\n@@ -65,3 +66,3 @@\n-    public void disposeLayout(com.sun.javafx.scene.text.TextLayout layout) {\n-        if (layout == reusableTL) {\n-            inUse = false;\n+    public void disposeLayout(TextLayout layout) {\n+        if (layout == REUSABLE_INSTANCE) {\n+            GUARD.set(false);\n@@ -71,1 +72,0 @@\n-    private static final PrismTextLayoutFactory factory = new PrismTextLayoutFactory();\n@@ -73,1 +73,1 @@\n-        return factory;\n+        return FACTORY;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismTextLayoutFactory.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -44,1 +45,1 @@\n-    TextLine line;\n+    com.sun.javafx.scene.text.TextLine line;\n@@ -81,0 +82,1 @@\n+    @Override\n@@ -101,1 +103,1 @@\n-    public void setLine(TextLine line) {\n+    public void setLine(com.sun.javafx.scene.text.TextLine line) {\n@@ -117,0 +119,1 @@\n+    @Override\n@@ -404,1 +407,1 @@\n-    public int getGlyphAtX(float x, int[] trailing) {\n+    public int getGlyphAtX(float x, AtomicBoolean trailing) {\n@@ -410,7 +413,5 @@\n-                if (trailing != null) {\n-                    \/\/TODO handle clusters\n-                    if (x - runX > advance \/ 2) {\n-                        trailing[0] = ltr ? 1 : 0;\n-                    } else {\n-                        trailing[0] = ltr ? 0 : 1;\n-                    }\n+                \/\/TODO handle clusters\n+                if (x - runX > advance \/ 2) {\n+                    trailing.set(ltr ? true : false);\n+                } else {\n+                    trailing.set(ltr ? false : true);\n@@ -422,1 +423,1 @@\n-        if (trailing != null) trailing[0] = ltr ? 1 : 0;\n+        trailing.set(ltr ? true : false);\n@@ -426,1 +427,2 @@\n-    public int getOffsetAtX(float x, int[] trailing) {\n+    @Override\n+    public int getOffsetAtX(float x, AtomicBoolean trailing) {\n@@ -433,4 +435,2 @@\n-            if (trailing != null) {\n-                if (x > width \/ 2) {\n-                    trailing[0] = 1;\n-                }\n+            if (x > width \/ 2) {\n+                trailing.set(true);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/TextRun.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1050,1 +1050,1 @@\n-            int runStart = ((TextRun) r).getStart();\n+            int runStart = r.getStart();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/Text.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,3 +53,1 @@\n-        StubFont stub = new StubFont();\n-        stub.font = font;\n-\n+        StubFont stub = new StubFont(font);\n@@ -204,1 +202,5 @@\n-        public Font font;\n+        private final Font font;\n+\n+        public StubFont(Font font) {\n+            this.font = font;\n+        }\n@@ -228,1 +230,1 @@\n-            return null;\n+            return new StubFontResource(font);\n@@ -233,1 +235,1 @@\n-            return null;\n+            return new StubFontStrike(getFontResource(), getSize(), transform);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/pgstub\/StubFontLoader.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.com.sun.javafx.pgstub;\n+\n+import com.sun.javafx.font.Metrics;\n+\n+\/**\n+ * Stubbed FontMetrics, some numbers are still arbitrary.\n+ *\/\n+public class StubFontMetrics implements Metrics {\n+    public static final float BASELINE = 0.8f;\n+    public static final float BOLD_FONT_EXTRA_WIDTH = 1.0f;\n+    private final float size;\n+\n+    public StubFontMetrics(float size) {\n+        this.size = size;\n+    }\n+\n+    @Override\n+    public float getAscent() {\n+        return -size * BASELINE;\n+    }\n+\n+    @Override\n+    public float getDescent() {\n+        return size * (1.0f - BASELINE);\n+    }\n+\n+    @Override\n+    public float getLineGap() {\n+        return 0f;\n+    }\n+\n+    @Override\n+    public float getLineHeight() {\n+        return size;\n+    }\n+\n+    @Override\n+    public float getTypoAscent() {\n+        return getAscent();\n+    }\n+\n+    @Override\n+    public float getTypoDescent() {\n+        return getDescent();\n+    }\n+\n+    @Override\n+    public float getTypoLineGap() {\n+        return getLineGap();\n+    }\n+\n+    @Override\n+    public float getXHeight() {\n+        return size;\n+    }\n+\n+    @Override\n+    public float getCapHeight() {\n+        return size;\n+    }\n+\n+    @Override\n+    public float getStrikethroughOffset() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public float getStrikethroughThickness() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public float getUnderLineOffset() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public float getUnderLineThickness() {\n+        return 1;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/pgstub\/StubFontMetrics.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.com.sun.javafx.pgstub;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Locale;\n+import java.util.Map;\n+import javafx.scene.text.Font;\n+import com.sun.javafx.font.CharToGlyphMapper;\n+import com.sun.javafx.font.FontResource;\n+import com.sun.javafx.font.FontStrike;\n+import com.sun.javafx.font.FontStrikeDesc;\n+import com.sun.javafx.geom.transform.BaseTransform;\n+\n+\/**\n+ *\n+ *\/\n+public class StubFontResource implements FontResource {\n+    private final Font font;\n+    private Boolean bold;\n+    private static final CharToGlyphMapper glyphMapper = initCharToGlyphMapper();\n+\n+    public StubFontResource(Font font) {\n+        this.font = font;\n+    }\n+\n+    @Override\n+    public String getFullName() {\n+        return font.getName();\n+    }\n+\n+    @Override\n+    public String getPSName() {\n+        return font.getName();\n+    }\n+\n+    @Override\n+    public String getFamilyName() {\n+        return font.getFamily();\n+    }\n+\n+    @Override\n+    public String getFileName() {\n+        return font.getName();\n+    }\n+\n+    @Override\n+    public String getStyleName() {\n+        return font.getName();\n+    }\n+\n+    @Override\n+    public String getLocaleFullName() {\n+        return getFullName();\n+    }\n+\n+    @Override\n+    public String getLocaleFamilyName() {\n+        return getFamilyName();\n+    }\n+\n+    @Override\n+    public String getLocaleStyleName() {\n+        return getStyleName();\n+    }\n+\n+    \/\/ see com.sun.javafx.scene.text.TextLayout flags\n+    @Override\n+    public int getFeatures() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public boolean isBold() {\n+        if (bold == null) {\n+            String name = font.getStyle();\n+            bold = name.toLowerCase(Locale.US).contains(\"bold\");\n+        }\n+        return bold.booleanValue();\n+    }\n+\n+    @Override\n+    public boolean isItalic() {\n+        return false;\n+    }\n+\n+    \/\/ returns glyph width\n+    @Override\n+    public float getAdvance(int gc, float size) {\n+        \/\/ +1 for bold fonts\n+        return isBold() ? size + StubFontMetrics.BOLD_FONT_EXTRA_WIDTH : size;\n+    }\n+\n+    \/\/ returns [xmin, ymin, xmax, ymax]\n+    @Override\n+    public float[] getGlyphBoundingBox(int gc, float size, float[] b) {\n+        if (b == null || b.length < 4) {\n+            b = new float[4];\n+        }\n+\n+        float xmin = 0.0f;\n+        float ymin = 0.0f;\n+        float xmax = getAdvance(gc, size);\n+        float ymax = StubFontMetrics.BASELINE * size;\n+\n+        \/\/ PrismTextLayoutBase:\n+        \/\/private static final int X_MIN_INDEX = 0;\n+        \/\/private static final int Y_MIN_INDEX = 1;\n+        \/\/private static final int X_MAX_INDEX = 2;\n+        \/\/private static final int Y_MAX_INDEX = 3;\n+        b[0] = xmin;\n+        b[1] = ymin;\n+        b[2] = xmax;\n+        b[3] = ymax;\n+        return b;\n+    }\n+\n+    @Override\n+    public int getDefaultAAMode() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public CharToGlyphMapper getGlyphMapper() {\n+        return glyphMapper;\n+    }\n+\n+    @Override\n+    public Map<FontStrikeDesc, WeakReference<FontStrike>> getStrikeMap() {\n+        return null;\n+    }\n+\n+    @Override\n+    public FontStrike getStrike(float size, BaseTransform t) {\n+        return new StubFontStrike(this, size, t);\n+    }\n+\n+    @Override\n+    public FontStrike getStrike(float size, BaseTransform t, int aaMode) {\n+        return new StubFontStrike(this, size, t);\n+    }\n+\n+    @Override\n+    public Object getPeer() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setPeer(Object peer) {\n+    }\n+\n+    @Override\n+    public boolean isEmbeddedFont() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isColorGlyph(int gc) {\n+        return false;\n+    }\n+\n+    private static CharToGlyphMapper initCharToGlyphMapper() {\n+        return new CharToGlyphMapper() {\n+            @Override\n+            public int getGlyphCode(int charCode) {\n+                return charCode;\n+            }\n+        };\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/pgstub\/StubFontResource.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.com.sun.javafx.pgstub;\n+\n+import com.sun.javafx.font.FontResource;\n+import com.sun.javafx.font.FontStrike;\n+import com.sun.javafx.font.Glyph;\n+import com.sun.javafx.font.Metrics;\n+import com.sun.javafx.geom.Point2D;\n+import com.sun.javafx.geom.Shape;\n+import com.sun.javafx.geom.transform.BaseTransform;\n+import com.sun.javafx.scene.text.GlyphList;\n+\n+\/**\n+ *\n+ *\/\n+public class StubFontStrike implements FontStrike {\n+    private final FontResource fontResource;\n+    private final float size;\n+    private final BaseTransform transform;\n+\n+    public StubFontStrike(FontResource r, float size, BaseTransform t) {\n+        this.fontResource = r;\n+        this.size = size;\n+        this.transform = t;\n+    }\n+\n+    @Override\n+    public FontResource getFontResource() {\n+        return fontResource;\n+    }\n+\n+    @Override\n+    public float getSize() {\n+        return size;\n+    }\n+\n+    @Override\n+    public BaseTransform getTransform() {\n+        return transform;\n+    }\n+\n+    @Override\n+    public boolean drawAsShapes() {\n+        return false;\n+    }\n+\n+    @Override\n+    public int getQuantizedPosition(Point2D point) {\n+        point.x = Math.round(point.x);\n+        point.y = Math.round(point.y);\n+        return 0;\n+    }\n+\n+    @Override\n+    public Metrics getMetrics() {\n+        return new StubFontMetrics(size);\n+    }\n+\n+    @Override\n+    public Glyph getGlyph(char symbol) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Glyph getGlyph(int glyphCode) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void clearDesc() {\n+    }\n+\n+    @Override\n+    public int getAAMode() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public float getCharAdvance(char ch) {\n+        int glyphCode = fontResource.getGlyphMapper().charToGlyph((int)ch);\n+        return fontResource.getAdvance(glyphCode, size);\n+    }\n+\n+    @Override\n+    public Shape getOutline(GlyphList gl, BaseTransform transform) {\n+        return null;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/pgstub\/StubFontStrike.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.com.sun.javafx.pgstub;\n+\n+import com.sun.javafx.font.CharToGlyphMapper;\n+import com.sun.javafx.font.FontResource;\n+import com.sun.javafx.font.FontStrike;\n+import com.sun.javafx.font.PGFont;\n+import com.sun.javafx.text.GlyphLayout;\n+import com.sun.javafx.text.TextRun;\n+\n+\/**\n+ *\n+ *\/\n+public class StubGlyphLayout extends GlyphLayout {\n+    public StubGlyphLayout() {\n+    }\n+\n+    @Override\n+    public void dispose() {\n+    }\n+\n+    @Override\n+    public void layout(TextRun run, PGFont font, FontStrike strike, char[] chars) {\n+        FontResource fr = strike.getFontResource();\n+        int start = run.getStart();\n+        int length = run.getLength();\n+\n+        \/\/ simplified code from PrismTextLayout.shape()\n+        float fontSize = strike.getSize();\n+        CharToGlyphMapper mapper = fr.getGlyphMapper();\n+\n+        \/* The text contains complex and non-complex runs *\/\n+        int[] glyphs = new int[length];\n+        mapper.charsToGlyphs(start, length, chars, glyphs);\n+        float[] positions = new float[(length + 1) << 1];\n+        float xadvance = 0;\n+        for (int i = 0; i < length; i++) {\n+            float width = fr.getAdvance(glyphs[i], fontSize);\n+            positions[i << 1] = xadvance;\n+            \/\/yadvance always zero\n+            xadvance += width;\n+        }\n+        positions[length << 1] = xadvance;\n+        run.shape(length, glyphs, positions, null);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/pgstub\/StubGlyphLayout.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,7 +28,2 @@\n-import com.sun.javafx.geom.BaseBounds;\n-import com.sun.javafx.geom.Path2D;\n-import com.sun.javafx.geom.RectBounds;\n-import com.sun.javafx.geom.Shape;\n-import com.sun.javafx.scene.text.*;\n-import javafx.scene.shape.PathElement;\n-import javafx.scene.text.Font;\n+import com.sun.javafx.text.GlyphLayout;\n+import com.sun.javafx.text.PrismTextLayout;\n@@ -37,4 +32,1 @@\n- * Stub implementation of the {@link TextLayout} for testing purposes.\n- * <br>\n- * Can calculate the bounds of text by simply using the size of the font.\n- * If the text is bold, the font will be 1 pixel wider for the calculation.\n+ * Same as PrismTextLayout but with stubbed out fonts.\n@@ -42,1 +34,1 @@\n-public class StubTextLayout implements TextLayout {\n+public class StubTextLayout extends PrismTextLayout {\n@@ -44,38 +36,2 @@\n-    @Override\n-    public boolean setContent(TextSpan[] spans) {\n-        this.spans = spans;\n-        this.text = null; \/* Initialized in getText() *\/\n-        this.nullFontSize = 10; \/\/ need a non-zero size\n-        return true;\n-    }\n-\n-    private TextSpan[] spans;\n-    private String text;\n-    private Font font;\n-    private int tabSize = DEFAULT_TAB_SIZE;\n-    private int nullFontSize = 0;\n-    private float spacing;\n-\n-    @Override\n-    public boolean setContent(String text, Object font) {\n-        this.text = text;\n-        final StubFontLoader.StubFont stub = ((StubFontLoader.StubFont)font);\n-        this.font = stub == null ? null : stub.font;\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean setAlignment(int alignment) {\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean setWrapWidth(float wrapWidth) {\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean setLineSpacing(float spacing) {\n-        this.spacing = spacing;\n-\n-        return true;\n+    public StubTextLayout() {\n+        super(0);\n@@ -85,160 +41,2 @@\n-    public boolean setDirection(int direction) {\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean setBoundsType(int type) {\n-        return true;\n-    }\n-\n-    @Override\n-    public BaseBounds getBounds() {\n-        return getBounds(null, new RectBounds());\n-    }\n-\n-    @Override\n-    public BaseBounds getBounds(TextSpan filter, BaseBounds bounds) {\n-        double fontSizeH = nullFontSize;\n-        double fontSizeW = nullFontSize;\n-        if (font != null) {\n-            fontSizeH = font.getSize();\n-            fontSizeW = font.getSize();\n-\n-            \/\/ For better testing, we make bold text a little bit bigger.\n-            boolean bold = font.getStyle().toLowerCase().contains(\"bold\");\n-            if (bold) {\n-                fontSizeW++;\n-            }\n-        }\n-\n-        final String[] lines = getText().split(\"\\n\");\n-        double width = 0.0;\n-        double height = fontSizeH * lines.length + spacing * (lines.length - 1);\n-        for (String line : lines) {\n-            final int length;\n-            if (line.contains(\"\\t\")) {\n-                \/\/ count chars but when encountering a tab round up to a tabSize boundary\n-                char [] chrs = line.toCharArray();\n-                int spaces = 0;\n-                for (int i = 0; i < chrs.length; i++) {\n-                    if (chrs[i] == '\\t') {\n-                        if (tabSize != 0) {\n-                            while ((++spaces % tabSize) != 0) {}\n-                        }\n-                    } else {\n-                        spaces++;\n-                    }\n-                }\n-                length = spaces;\n-            } else {\n-                length = line.length();\n-            }\n-            width = Math.max(width, fontSizeW * length);\n-        }\n-        return bounds.deriveWithNewBounds(0, (float)-fontSizeH, 0,\n-                (float)width, (float)(height-fontSizeH), 0);\n-    }\n-\n-    class StubTextLine implements TextLine {\n-        @Override public GlyphList[] getRuns() {\n-            return new GlyphList[0];\n-        }\n-        @Override public RectBounds getBounds() {\n-            return new RectBounds();\n-        }\n-        @Override public float getLeftSideBearing() {\n-            return 0;\n-        }\n-        @Override public float getRightSideBearing() {\n-            return 0;\n-        }\n-        @Override public int getStart() {\n-            return 0;\n-        }\n-        @Override public int getLength() {\n-            return 0;\n-        }\n-    }\n-\n-    @Override\n-    public TextLine[] getLines() {\n-        return new TextLine[] {new StubTextLine()};\n-    }\n-\n-    @Override\n-    public GlyphList[] getRuns() {\n-        return new GlyphList[0];\n-    }\n-\n-    @Override\n-    public Shape getShape(int type, TextSpan filter) {\n-        return new Path2D();\n-    }\n-\n-    @Override\n-    public Hit getHitInfo(float x, float y) {\n-        \/\/ TODO this probably needs to be entirely rewritten...\n-        if (getText() == null) {\n-            return new Hit(0, -1, true);\n-        }\n-\n-        final double fontSize = (font == null ? nullFontSize : font.getSize());\n-        final String[] lines = text.split(\"\\n\");\n-        int lineIndex = Math.min(lines.length - 1, (int) (y \/ fontSize));\n-        if (lineIndex >= lines.length) {\n-            throw new IllegalStateException(\"Asked for hit info out of y range: x=\" + x + \"y=\" +\n-                    + y + \"text='\" + text + \"', lineIndex=\" + lineIndex + \", numLines=\" + lines.length +\n-                    \", fontSize=\" + fontSize);\n-        }\n-        int offset = 0;\n-        for (int i=0; i<lineIndex; i++) {\n-            offset += lines[i].length() + 1; \/\/ add in the \\n\n-        }\n-\n-        int charPos = (int) (x \/ lines[lineIndex].length());\n-        if (charPos + offset > text.length()) {\n-            throw new IllegalStateException(\"Asked for hit info out of x range\");\n-        }\n-\n-        return new Hit(offset + charPos, -1, true);\n-    }\n-\n-    @Override\n-    public PathElement[] getCaretShape(int offset, boolean isLeading, float x,\n-            float y) {\n-        return new PathElement[0];\n-    }\n-\n-    @Override\n-    public PathElement[] getRange(int start, int end, int type, float x, float y) {\n-        return new PathElement[0];\n-    }\n-\n-    @Override\n-    public BaseBounds getVisualBounds(int type) {\n-        return new RectBounds();\n-    }\n-\n-    @Override\n-    public boolean setTabSize(int spaces) {\n-        if (spaces < 1) {\n-            spaces = 1;\n-        }\n-        if (tabSize != spaces) {\n-            tabSize = spaces;\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private String getText() {\n-        if (text == null) {\n-            if (spans != null) {\n-                StringBuilder sb = new StringBuilder();\n-                for (TextSpan span : spans) {\n-                    sb.append(span.getText());\n-                }\n-                text = sb.toString();\n-            }\n-        }\n-        return text;\n+    protected GlyphLayout glyphLayout() {\n+        return new StubGlyphLayout();\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/pgstub\/StubTextLayout.java","additions":9,"deletions":211,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -32,1 +34,0 @@\n-\n@@ -34,1 +35,0 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -54,1 +54,1 @@\n-        assertEquals(size, text.getBaselineOffset(),1e-100);\n+        assertTrue(text.getBaselineOffset() > (size \/ 2.0f));\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BaselineTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        stage.setWidth(300);\n+        stage.setWidth(500);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/text\/TextFlowTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        assertEquals(44f, t.getBaselineOffset(), 0);\n+        assertTrue(t.getBaselineOffset() > (f.getSize() \/ 2.0));\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/text\/TextTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -22,0 +22,2 @@\n+# compile additions\n+--add-exports=javafx.graphics\/com.sun.javafx.text=ALL-UNNAMED\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/addExports","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import com.sun.javafx.scene.text.TextLayout;\n@@ -37,1 +38,1 @@\n-import com.sun.javafx.text.PrismTextLayout;\n+import com.sun.javafx.text.PrismTextLayoutFactory;\n@@ -40,1 +41,1 @@\n-    private final PrismTextLayout layout = new PrismTextLayout();\n+    private final TextLayout layout = PrismTextLayoutFactory.getFactory().createLayout();\n","filename":"tests\/system\/src\/test\/java\/test\/com\/sun\/javafx\/text\/TextHitInfoTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import com.sun.javafx.scene.text.TextLayout;\n@@ -47,1 +48,1 @@\n-import com.sun.javafx.text.PrismTextLayout;\n+import com.sun.javafx.text.PrismTextLayoutFactory;\n@@ -55,1 +56,1 @@\n-    private final PrismTextLayout layout = new PrismTextLayout();\n+    private final TextLayout layout = PrismTextLayoutFactory.getFactory().createLayout();\n@@ -76,1 +77,1 @@\n-    private void setContent(PrismTextLayout layout, Object... content) {\n+    private void setContent(TextLayout layout, Object... content) {\n","filename":"tests\/system\/src\/test\/java\/test\/com\/sun\/javafx\/text\/TextLayoutTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}