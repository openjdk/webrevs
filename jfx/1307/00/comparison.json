{"files":[{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef DELETEDMEMDEBUG_H\n+#define DELETEDMEMDEBUG_H\n+\n+#include <cstring>\n+\n+template <int FILL>\n+struct DeletedMemDebug\n+{\n+public:\n+    static void operator delete(void* ptr, std::size_t sz)\n+    {\n+        ::memset(ptr, FILL, sz);\n+        ::operator delete(ptr);\n+    }\n+\n+    static void operator delete[](void* ptr, std::size_t sz)\n+    {\n+        ::memset(ptr, 0xcc, sz);\n+        ::operator delete[](ptr);\n+    }\n+};\n+\n+#endif \/\/ DELETEDMEMDEBUG_H\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/DeletedMemDebug.h","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -483,0 +483,2 @@\n+    EventsCounterHelper helper(ctx);\n+\n@@ -490,1 +492,1 @@\n-        EventsCounterHelper helper(ctx);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassApplication.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,3 @@\n-#define        GLASS_VIEW_H\n+#define GLASS_VIEW_H\n+\n+#include \"DeletedMemDebug.h\"\n@@ -30,1 +32,1 @@\n-struct GlassView {\n+struct GlassView : public DeletedMemDebug<0xCC> {\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_view.h","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+#include \"DeletedMemDebug.h\"\n+\n@@ -95,1 +97,1 @@\n-class WindowContext {\n+class WindowContext : public DeletedMemDebug<0xCC> {\n@@ -344,1 +346,3 @@\n-        ctx->increment_events_counter();\n+        if (ctx != nullptr) {\n+            ctx->increment_events_counter();\n+        }\n@@ -347,3 +351,6 @@\n-        ctx->decrement_events_counter();\n-        if (ctx->is_dead() && ctx->get_events_count() == 0) {\n-            delete ctx;\n+        if (ctx != nullptr) {\n+            ctx->decrement_events_counter();\n+            if (ctx->is_dead() && ctx->get_events_count() == 0) {\n+                delete ctx;\n+            }\n+            ctx = NULL;\n@@ -351,1 +358,0 @@\n-        ctx = NULL;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.javafx.stage;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.scene.Scene;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.robot.Robot;\n+import javafx.stage.Stage;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+\n+import test.util.Util;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+@TestMethodOrder(OrderAnnotation.class)\n+public class KeyEventClosesStageTest {\n+    private static Robot robot;\n+    private static Stage stage;\n+    private static Scene scene;\n+    private static BorderPane borderPane;\n+    private static TextArea textArea;\n+\n+    private static boolean typedEventArrived = false;\n+    private static CountDownLatch startupLatch = new CountDownLatch(1);\n+    private static CountDownLatch pressedEventLatch = new CountDownLatch(1);\n+\n+    @BeforeAll\n+    public static void initFX() throws Exception {\n+        Util.launch(startupLatch, TestApp.class);\n+\n+        \/\/ When run from the command line Windows does not want to\n+        \/\/ activate the window.\n+        Util.runAndWait(() -> {\n+            int mouseX = (int) (scene.getWindow().getX() + scene.getX() +\n+                    textArea.getLayoutX() + textArea.getLayoutBounds().getWidth() \/ 2);\n+            int mouseY = (int) (scene.getWindow().getY() + scene.getY() +\n+                    textArea.getLayoutY() + textArea.getLayoutBounds().getHeight() \/ 2);\n+            robot.mouseMove(mouseX, mouseY);\n+            robot.mouseClick(MouseButton.PRIMARY);\n+        });\n+        Util.runAndWait(() -> {\n+            borderPane.requestFocus();\n+        });\n+    }\n+\n+    @Test\n+    @Order(1)\n+    public void pressedEventClosesStage() throws Exception {\n+        Util.runAndWait(() -> {\n+            robot.keyPress(KeyCode.ESCAPE);\n+            robot.keyRelease(KeyCode.ESCAPE);\n+        });\n+        assertTrue(pressedEventLatch.await(1000, TimeUnit.MILLISECONDS),\n+            \"Pressed event arrived without crash\");\n+    }\n+\n+    @Test\n+    @Order(2)\n+    public void typedEventNeverArrives() throws Exception {\n+        assertFalse(typedEventArrived, \"Unexpected typed event arrived\");\n+    }\n+\n+    public static class TestApp extends Application {\n+        @Override\n+        public void start(Stage primaryStage) {\n+            robot = new Robot();\n+            stage = primaryStage;\n+\n+            textArea = new TextArea();\n+            borderPane = new BorderPane(textArea);\n+            borderPane.setOnKeyPressed(e -> {\n+                if (e.getCode() == KeyCode.ESCAPE) {\n+                    stage.close();\n+                    Platform.runLater(pressedEventLatch::countDown);\n+                }\n+            });\n+            borderPane.setOnKeyTyped(e -> {\n+                typedEventArrived = true;\n+            });\n+\n+            scene = new Scene(borderPane, 200, 200);\n+            stage.setScene(scene);\n+            stage.setOnShown(event -> {\n+                Platform.runLater(startupLatch::countDown);\n+            });\n+            stage.setAlwaysOnTop(true);\n+            stage.show();\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/KeyEventClosesStageTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"}]}