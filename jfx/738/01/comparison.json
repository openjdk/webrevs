{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## LibFFI v3.3\n+## LibFFI v3.4.2\n@@ -6,1 +6,1 @@\n-libffi - Copyright (c) 1996-2019  Anthony Green, Red Hat, Inc and others.\n+libffi - Copyright (c) 1996-2021  Anthony Green, Red Hat, Inc and others.\n","filename":"modules\/javafx.media\/src\/main\/legal\/libffi.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-libffi - Copyright (c) 1996-2019  Anthony Green, Red Hat, Inc and others.\n+libffi - Copyright (c) 1996-2021  Anthony Green, Red Hat, Inc and others.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/LICENSE","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,0 +5,21 @@\n+\n+   Permission is hereby granted, free of charge, to any person\n+   obtaining a copy of this software and associated documentation\n+   files (the ``Software''), to deal in the Software without\n+   restriction, including without limitation the rights to use, copy,\n+   modify, merge, publish, distribute, sublicense, and\/or sell copies\n+   of the Software, and to permit persons to whom the Software is\n+   furnished to do so, subject to the following conditions:\n+\n+   The above copyright notice and this permission notice shall be\n+   included in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+\n@@ -12,2 +33,2 @@\n-# define cfi_startproc          .cfi_startproc\n-# define cfi_endproc            .cfi_endproc\n+# define cfi_startproc              .cfi_startproc\n+# define cfi_endproc                .cfi_endproc\n@@ -22,1 +43,1 @@\n-# define cfi_restore(reg)       .cfi_restore reg\n+# define cfi_restore(reg)           .cfi_restore reg\n@@ -24,4 +45,4 @@\n-# define cfi_undefined(reg)     .cfi_undefined reg\n-# define cfi_remember_state     .cfi_remember_state\n-# define cfi_restore_state      .cfi_restore_state\n-# define cfi_window_save        .cfi_window_save\n+# define cfi_undefined(reg)         .cfi_undefined reg\n+# define cfi_remember_state         .cfi_remember_state\n+# define cfi_restore_state          .cfi_restore_state\n+# define cfi_window_save            .cfi_window_save\n@@ -29,2 +50,2 @@\n-# define cfi_lsda(enc, exp)     .cfi_lsda enc, exp\n-# define cfi_escape(...)        .cfi_escape __VA_ARGS__\n+# define cfi_lsda(enc, exp)         .cfi_lsda enc, exp\n+# define cfi_escape(...)            .cfi_escape __VA_ARGS__\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/include\/ffi_cfi.h","additions":30,"deletions":9,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -8,0 +8,21 @@\n+\n+   Permission is hereby granted, free of charge, to any person\n+   obtaining a copy of this software and associated documentation\n+   files (the ``Software''), to deal in the Software without\n+   restriction, including without limitation the rights to use, copy,\n+   modify, merge, publish, distribute, sublicense, and\/or sell copies\n+   of the Software, and to permit persons to whom the Software is\n+   furnished to do so, subject to the following conditions:\n+\n+   The above copyright notice and this permission notice shall be\n+   included in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+\n@@ -106,0 +127,4 @@\n+\/* The arch code calls this to determine if a given closure has a\n+   static trampoline. *\/\n+int ffi_tramp_is_present (void *closure) FFI_HIDDEN;\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/include\/ffi_common.h","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,2 +2,3 @@\n-   libffi 3.3 - Copyright (c) 2011, 2014, 2019 Anthony Green\n-                    - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.\n+   libffi 3.4.2\n+     - Copyright (c) 2011, 2014, 2019, 2021 Anthony Green\n+     - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.\n@@ -220,1 +221,2 @@\n-  FFI_BAD_ABI\n+  FFI_BAD_ABI,\n+  FFI_BAD_ARGTYPE\n@@ -263,3 +265,3 @@\n-  float     flt;\n-  char      data[FFI_SIZEOF_JAVA_RAW];\n-  void*     ptr;\n+  float         flt;\n+  char          data[FFI_SIZEOF_JAVA_RAW];\n+  void*         ptr;\n@@ -313,1 +315,4 @@\n-  char tramp[FFI_TRAMPOLINE_SIZE];\n+  union {\n+    char tramp[FFI_TRAMPOLINE_SIZE];\n+    void *ftramp;\n+  };\n@@ -333,0 +338,8 @@\n+#if defined(PA_LINUX) || defined(PA_HPUX)\n+#define FFI_CLOSURE_PTR(X) ((void *)((unsigned int)(X) | 2))\n+#define FFI_RESTORE_PTR(X) ((void *)((unsigned int)(X) & ~3))\n+#else\n+#define FFI_CLOSURE_PTR(X) (X)\n+#define FFI_RESTORE_PTR(X) (X)\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/include\/mac\/aarch64\/ffi.h","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -21,0 +21,3 @@\n+\/* Define this if you want statically defined trampolines *\/\n+\/* #undef FFI_EXEC_STATIC_TRAMP *\/\n+\n@@ -80,0 +83,3 @@\n+\/* Define to 1 if you have the `memfd_create' function. *\/\n+\/* #undef HAVE_MEMFD_CREATE *\/\n+\n@@ -86,0 +92,3 @@\n+\/* Define to 1 if you have the `mkstemp' function. *\/\n+\/* #undef HAVE_MKSTEMP *\/\n+\n@@ -98,0 +107,3 @@\n+\/* Define if your compiler supports pointer authentication. *\/\n+\/* #undef HAVE_PTRAUTH *\/\n+\n@@ -113,0 +125,3 @@\n+\/* Define to 1 if you have the <sys\/memfd.h> header file. *\/\n+\/* #undef HAVE_SYS_MEMFD_H *\/\n+\n@@ -141,1 +156,1 @@\n-#define PACKAGE_STRING \"libffi 3.3\"\n+#define PACKAGE_STRING \"libffi 3.4.2\"\n@@ -150,1 +165,1 @@\n-#define PACKAGE_VERSION \"3.3\"\n+#define PACKAGE_VERSION \"3.4.2\"\n@@ -180,1 +195,1 @@\n-#define VERSION \"3.3\"\n+#define VERSION \"3.4.2\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/include\/mac\/aarch64\/fficonfig.h","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,2 +2,3 @@\n-   libffi 3.3 - Copyright (c) 2011, 2014, 2019 Anthony Green\n-                    - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.\n+   libffi 3.4.2\n+     - Copyright (c) 2011, 2014, 2019, 2021 Anthony Green\n+     - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.\n@@ -220,1 +221,2 @@\n-  FFI_BAD_ABI\n+  FFI_BAD_ABI,\n+  FFI_BAD_ARGTYPE\n@@ -263,3 +265,3 @@\n-  float     flt;\n-  char      data[FFI_SIZEOF_JAVA_RAW];\n-  void*     ptr;\n+  float         flt;\n+  char          data[FFI_SIZEOF_JAVA_RAW];\n+  void*         ptr;\n@@ -313,1 +315,4 @@\n-  char tramp[FFI_TRAMPOLINE_SIZE];\n+  union {\n+    char tramp[FFI_TRAMPOLINE_SIZE];\n+    void *ftramp;\n+  };\n@@ -333,0 +338,8 @@\n+#if defined(PA_LINUX) || defined(PA_HPUX)\n+#define FFI_CLOSURE_PTR(X) ((void *)((unsigned int)(X) | 2))\n+#define FFI_RESTORE_PTR(X) ((void *)((unsigned int)(X) & ~3))\n+#else\n+#define FFI_CLOSURE_PTR(X) (X)\n+#define FFI_RESTORE_PTR(X) (X)\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/include\/mac\/x64\/ffi.h","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -21,0 +21,3 @@\n+\/* Define this if you want statically defined trampolines *\/\n+\/* #undef FFI_EXEC_STATIC_TRAMP *\/\n+\n@@ -80,0 +83,3 @@\n+\/* Define to 1 if you have the `memfd_create' function. *\/\n+\/* #undef HAVE_MEMFD_CREATE *\/\n+\n@@ -86,0 +92,3 @@\n+\/* Define to 1 if you have the `mkstemp' function. *\/\n+\/* #undef HAVE_MKSTEMP *\/\n+\n@@ -98,0 +107,3 @@\n+\/* Define if your compiler supports pointer authentication. *\/\n+\/* #undef HAVE_PTRAUTH *\/\n+\n@@ -113,0 +125,3 @@\n+\/* Define to 1 if you have the <sys\/memfd.h> header file. *\/\n+\/* #undef HAVE_SYS_MEMFD_H *\/\n+\n@@ -141,1 +156,1 @@\n-#define PACKAGE_STRING \"libffi 3.3\"\n+#define PACKAGE_STRING \"libffi 3.4.2\"\n@@ -150,1 +165,1 @@\n-#define PACKAGE_VERSION \"3.3\"\n+#define PACKAGE_VERSION \"3.4.2\"\n@@ -180,1 +195,1 @@\n-#define VERSION \"3.3\"\n+#define VERSION \"3.4.2\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/include\/mac\/x64\/fficonfig.h","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/* -----------------------------------------------------------------------\n+   ffi_tramp.h - Copyright (C) 2021  Microsoft, Inc.\n+\n+   Static trampoline definitions.\n+\n+   Permission is hereby granted, free of charge, to any person\n+   obtaining a copy of this software and associated documentation\n+   files (the ``Software''), to deal in the Software without\n+   restriction, including without limitation the rights to use, copy,\n+   modify, merge, publish, distribute, sublicense, and\/or sell copies\n+   of the Software, and to permit persons to whom the Software is\n+   furnished to do so, subject to the following conditions:\n+\n+   The above copyright notice and this permission notice shall be\n+   included in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+\n+   ----------------------------------------------------------------------- *\/\n+\n+#ifndef FFI_TRAMP_H\n+#define FFI_TRAMP_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+int ffi_tramp_is_supported(void);\n+void *ffi_tramp_alloc (int flags);\n+void ffi_tramp_set_parms (void *tramp, void *data, void *code);\n+void *ffi_tramp_get_addr (void *tramp);\n+void ffi_tramp_free (void *tramp);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* FFI_TRAMP_H *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/include\/tramp.h","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -2,2 +2,3 @@\n-   libffi 3.3 - Copyright (c) 2011, 2014, 2019 Anthony Green\n-                    - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.\n+   libffi 3.4.2\n+     - Copyright (c) 2011, 2014, 2019, 2021 Anthony Green\n+     - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.\n@@ -220,1 +221,2 @@\n-  FFI_BAD_ABI\n+  FFI_BAD_ABI,\n+  FFI_BAD_ARGTYPE\n@@ -263,3 +265,3 @@\n-  float     flt;\n-  char      data[FFI_SIZEOF_JAVA_RAW];\n-  void*     ptr;\n+  float         flt;\n+  char          data[FFI_SIZEOF_JAVA_RAW];\n+  void*         ptr;\n@@ -313,1 +315,4 @@\n-  char tramp[FFI_TRAMPOLINE_SIZE];\n+  union {\n+    char tramp[FFI_TRAMPOLINE_SIZE];\n+    void *ftramp;\n+  };\n@@ -333,0 +338,8 @@\n+#if defined(PA_LINUX) || defined(PA_HPUX)\n+#define FFI_CLOSURE_PTR(X) ((void *)((unsigned int)(X) | 2))\n+#define FFI_RESTORE_PTR(X) ((void *)((unsigned int)(X) & ~3))\n+#else\n+#define FFI_CLOSURE_PTR(X) (X)\n+#define FFI_RESTORE_PTR(X) (X)\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/include\/win\/x64\/ffi.h","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -21,0 +21,3 @@\n+\/* Define this if you want statically defined trampolines *\/\n+\/* #undef FFI_EXEC_STATIC_TRAMP *\/\n+\n@@ -80,0 +83,3 @@\n+\/* Define to 1 if you have the `memfd_create' function. *\/\n+\/* #undef HAVE_MEMFD_CREATE *\/\n+\n@@ -86,0 +92,3 @@\n+\/* Define to 1 if you have the `mkstemp' function. *\/\n+\/* #undef HAVE_MKSTEMP *\/\n+\n@@ -98,0 +107,3 @@\n+\/* Define if your compiler supports pointer authentication. *\/\n+\/* #undef HAVE_PTRAUTH *\/\n+\n@@ -113,0 +125,3 @@\n+\/* Define to 1 if you have the <sys\/memfd.h> header file. *\/\n+\/* #undef HAVE_SYS_MEMFD_H *\/\n+\n@@ -141,1 +156,1 @@\n-#define PACKAGE_STRING \"libffi 3.3\"\n+#define PACKAGE_STRING \"libffi 3.4.2\"\n@@ -150,1 +165,1 @@\n-#define PACKAGE_VERSION \"3.3\"\n+#define PACKAGE_VERSION \"3.4.2\"\n@@ -180,1 +195,1 @@\n-#define VERSION \"3.3\"\n+#define VERSION \"3.4.2\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/include\/win\/x64\/fficonfig.h","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,2 +2,3 @@\n-   libffi 3.3 - Copyright (c) 2011, 2014, 2019 Anthony Green\n-                    - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.\n+   libffi 3.4.2\n+     - Copyright (c) 2011, 2014, 2019, 2021 Anthony Green\n+     - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.\n@@ -220,1 +221,2 @@\n-  FFI_BAD_ABI\n+  FFI_BAD_ABI,\n+  FFI_BAD_ARGTYPE\n@@ -263,3 +265,3 @@\n-  float     flt;\n-  char      data[FFI_SIZEOF_JAVA_RAW];\n-  void*     ptr;\n+  float         flt;\n+  char          data[FFI_SIZEOF_JAVA_RAW];\n+  void*         ptr;\n@@ -313,1 +315,4 @@\n-  char tramp[FFI_TRAMPOLINE_SIZE];\n+  union {\n+    char tramp[FFI_TRAMPOLINE_SIZE];\n+    void *ftramp;\n+  };\n@@ -333,0 +338,8 @@\n+#if defined(PA_LINUX) || defined(PA_HPUX)\n+#define FFI_CLOSURE_PTR(X) ((void *)((unsigned int)(X) | 2))\n+#define FFI_RESTORE_PTR(X) ((void *)((unsigned int)(X) & ~3))\n+#else\n+#define FFI_CLOSURE_PTR(X) (X)\n+#define FFI_RESTORE_PTR(X) (X)\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/include\/win\/x86\/ffi.h","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -21,0 +21,3 @@\n+\/* Define this if you want statically defined trampolines *\/\n+\/* #undef FFI_EXEC_STATIC_TRAMP *\/\n+\n@@ -80,0 +83,3 @@\n+\/* Define to 1 if you have the `memfd_create' function. *\/\n+\/* #undef HAVE_MEMFD_CREATE *\/\n+\n@@ -86,0 +92,3 @@\n+\/* Define to 1 if you have the `mkstemp' function. *\/\n+\/* #undef HAVE_MKSTEMP *\/\n+\n@@ -98,0 +107,3 @@\n+\/* Define if your compiler supports pointer authentication. *\/\n+\/* #undef HAVE_PTRAUTH *\/\n+\n@@ -113,0 +125,3 @@\n+\/* Define to 1 if you have the <sys\/memfd.h> header file. *\/\n+\/* #undef HAVE_SYS_MEMFD_H *\/\n+\n@@ -141,1 +156,1 @@\n-#define PACKAGE_STRING \"libffi 3.3\"\n+#define PACKAGE_STRING \"libffi 3.4.2\"\n@@ -150,1 +165,1 @@\n-#define PACKAGE_VERSION \"3.3\"\n+#define PACKAGE_VERSION \"3.4.2\"\n@@ -180,1 +195,1 @@\n-#define VERSION \"3.3\"\n+#define VERSION \"3.4.2\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/include\/win\/x86\/fficonfig.h","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#ifdef _M_ARM64\n+#ifdef _WIN32\n@@ -33,0 +33,1 @@\n+#include <tramp.h>\n@@ -65,0 +66,3 @@\n+#ifdef HAVE_PTRAUTH\n+#include <ptrauth.h>\n+#endif\n@@ -81,1 +85,1 @@\n-#elif defined (_M_ARM64)\n+#elif defined (_WIN32)\n@@ -334,42 +338,42 @@\n-    \"adr    %0, 0f\\n\"\n-\"   add %0, %0, %1\\n\"\n-\"   br  %0\\n\"\n-\"0: ldp s16, s17, [%3]\\n\"   \/* S4 *\/\n-\"   ldp s18, s19, [%3, #8]\\n\"\n-\"   b   4f\\n\"\n-\"   ldp s16, s17, [%3]\\n\"   \/* S3 *\/\n-\"   ldr s18, [%3, #8]\\n\"\n-\"   b   3f\\n\"\n-\"   ldp s16, s17, [%3]\\n\"   \/* S2 *\/\n-\"   b   2f\\n\"\n-\"   nop\\n\"\n-\"   ldr s16, [%3]\\n\"        \/* S1 *\/\n-\"   b   1f\\n\"\n-\"   nop\\n\"\n-\"   ldp d16, d17, [%3]\\n\"   \/* D4 *\/\n-\"   ldp d18, d19, [%3, #16]\\n\"\n-\"   b   4f\\n\"\n-\"   ldp d16, d17, [%3]\\n\"   \/* D3 *\/\n-\"   ldr d18, [%3, #16]\\n\"\n-\"   b   3f\\n\"\n-\"   ldp d16, d17, [%3]\\n\"   \/* D2 *\/\n-\"   b   2f\\n\"\n-\"   nop\\n\"\n-\"   ldr d16, [%3]\\n\"        \/* D1 *\/\n-\"   b   1f\\n\"\n-\"   nop\\n\"\n-\"   ldp q16, q17, [%3]\\n\"   \/* Q4 *\/\n-\"   ldp q18, q19, [%3, #32]\\n\"\n-\"   b   4f\\n\"\n-\"   ldp q16, q17, [%3]\\n\"   \/* Q3 *\/\n-\"   ldr q18, [%3, #32]\\n\"\n-\"   b   3f\\n\"\n-\"   ldp q16, q17, [%3]\\n\"   \/* Q2 *\/\n-\"   b   2f\\n\"\n-\"   nop\\n\"\n-\"   ldr q16, [%3]\\n\"        \/* Q1 *\/\n-\"   b   1f\\n\"\n-\"4: str q19, [%2, #48]\\n\"\n-\"3: str q18, [%2, #32]\\n\"\n-\"2: str q17, [%2, #16]\\n\"\n-\"1: str q16, [%2]\"\n+\"adr    %0, 0f\\n\"\n+\"       add     %0, %0, %1\\n\"\n+\"       br      %0\\n\"\n+\"0:     ldp     s16, s17, [%3]\\n\"       \/* S4 *\/\n+\"       ldp     s18, s19, [%3, #8]\\n\"\n+\"       b       4f\\n\"\n+\"       ldp     s16, s17, [%3]\\n\"       \/* S3 *\/\n+\"       ldr     s18, [%3, #8]\\n\"\n+\"       b       3f\\n\"\n+\"       ldp     s16, s17, [%3]\\n\"       \/* S2 *\/\n+\"       b       2f\\n\"\n+\"       nop\\n\"\n+\"       ldr     s16, [%3]\\n\"            \/* S1 *\/\n+\"       b       1f\\n\"\n+\"       nop\\n\"\n+\"       ldp     d16, d17, [%3]\\n\"       \/* D4 *\/\n+\"       ldp     d18, d19, [%3, #16]\\n\"\n+\"       b       4f\\n\"\n+\"       ldp     d16, d17, [%3]\\n\"       \/* D3 *\/\n+\"       ldr     d18, [%3, #16]\\n\"\n+\"       b       3f\\n\"\n+\"       ldp     d16, d17, [%3]\\n\"       \/* D2 *\/\n+\"       b       2f\\n\"\n+\"       nop\\n\"\n+\"       ldr     d16, [%3]\\n\"            \/* D1 *\/\n+\"       b       1f\\n\"\n+\"       nop\\n\"\n+\"       ldp     q16, q17, [%3]\\n\"       \/* Q4 *\/\n+\"       ldp     q18, q19, [%3, #32]\\n\"\n+\"       b       4f\\n\"\n+\"       ldp     q16, q17, [%3]\\n\"       \/* Q3 *\/\n+\"       ldr     q18, [%3, #32]\\n\"\n+\"       b       3f\\n\"\n+\"       ldp     q16, q17, [%3]\\n\"       \/* Q2 *\/\n+\"       b       2f\\n\"\n+\"       nop\\n\"\n+\"       ldr     q16, [%3]\\n\"            \/* Q1 *\/\n+\"       b       1f\\n\"\n+\"4:     str     q19, [%2, #48]\\n\"\n+\"3:     str     q18, [%2, #32]\\n\"\n+\"2:     str     q17, [%2, #16]\\n\"\n+\"1:     str     q16, [%2]\"\n@@ -564,0 +568,8 @@\n+#else\n+ffi_status FFI_HIDDEN\n+ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs, unsigned int ntotalargs)\n+{\n+  ffi_status status = ffi_prep_cif_machdep (cif);\n+  cif->flags |= AARCH64_FLAG_VARARG;\n+  return status;\n+}\n@@ -580,1 +592,1 @@\n-  int i, nargs, flags;\n+  int i, nargs, flags, isvariadic = 0;\n@@ -588,0 +600,6 @@\n+  if (flags & AARCH64_FLAG_VARARG)\n+  {\n+    isvariadic = 1;\n+    flags &= ~AARCH64_FLAG_VARARG;\n+  }\n+\n@@ -602,2 +620,3 @@\n-  \/* Allocate consectutive stack for everything we'll need.  *\/\n-  context = alloca (sizeof(struct call_context) + stack_bytes + 32 + rsize);\n+  \/* Allocate consectutive stack for everything we'll need.\n+     The frame uses 40 bytes for: lr, fp, rvalue, flags, sp *\/\n+  context = alloca (sizeof(struct call_context) + stack_bytes + 40 + rsize);\n@@ -606,1 +625,1 @@\n-  rvalue = (rsize ? (void*)((uintptr_t)frame + 32) : orig_rvalue);\n+  rvalue = (rsize ? (void*)((uintptr_t)frame + 40) : orig_rvalue);\n@@ -668,2 +687,1 @@\n-#ifdef _M_ARM64 \/* for handling armasm calling convention *\/\n-                if (cif->is_variadic)\n+              if (cif->abi == FFI_WIN64 && isvariadic)\n@@ -683,1 +701,0 @@\n-#endif \/* for handling armasm calling convention *\/\n@@ -693,1 +710,0 @@\n-#ifdef _M_ARM64 \/* for handling armasm calling convention *\/\n@@ -695,1 +711,0 @@\n-#endif \/* for handling armasm calling convention *\/\n@@ -759,0 +774,2 @@\n+#if FFI_CLOSURES\n+\n@@ -772,0 +789,4 @@\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+extern void ffi_closure_SYSV_alt (void) FFI_HIDDEN;\n+extern void ffi_closure_SYSV_V_alt (void) FFI_HIDDEN;\n+#endif\n@@ -780,1 +801,1 @@\n-  if (cif->abi != FFI_SYSV)\n+  if (cif->abi != FFI_SYSV && cif->abi != FFI_WIN64)\n@@ -792,0 +813,3 @@\n+#ifdef HAVE_PTRAUTH\n+  codeloc = ptrauth_auth_data(codeloc, ptrauth_key_function_pointer, 0);\n+#endif\n@@ -798,3 +822,3 @@\n-    0x90, 0x00, 0x00, 0x58, \/* ldr  x16, tramp+16   *\/\n-    0xf1, 0xff, 0xff, 0x10, \/* adr  x17, tramp+0    *\/\n-    0x00, 0x02, 0x1f, 0xd6  \/* br   x16     *\/\n+    0x90, 0x00, 0x00, 0x58,     \/* ldr  x16, tramp+16   *\/\n+    0xf1, 0xff, 0xff, 0x10,     \/* adr  x17, tramp+0    *\/\n+    0x00, 0x02, 0x1f, 0xd6      \/* br   x16             *\/\n@@ -804,0 +828,14 @@\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+  if (ffi_tramp_is_present(closure))\n+    {\n+      \/* Initialize the static trampoline's parameters. *\/\n+      if (start == ffi_closure_SYSV_V)\n+          start = ffi_closure_SYSV_V_alt;\n+      else\n+          start = ffi_closure_SYSV_alt;\n+      ffi_tramp_set_parms (closure->ftramp, start, closure);\n+      goto out;\n+    }\n+#endif\n+\n+  \/* Initialize the dynamic trampoline. *\/\n@@ -811,1 +849,1 @@\n-#ifdef _M_ARM64\n+#ifdef _WIN32\n@@ -819,0 +857,1 @@\n+out:\n@@ -838,1 +877,1 @@\n-  if (cif->abi != FFI_SYSV)\n+  if (cif->abi != FFI_SYSV && cif->abi != FFI_WIN64)\n@@ -878,1 +917,1 @@\n-  int i, h, nargs, flags;\n+  int i, h, nargs, flags, isvariadic = 0;\n@@ -883,0 +922,7 @@\n+  flags = cif->flags;\n+  if (flags & AARCH64_FLAG_VARARG)\n+  {\n+    isvariadic = 1;\n+    flags &= ~AARCH64_FLAG_VARARG;\n+  }\n+\n@@ -917,2 +963,1 @@\n-#ifdef _M_ARM64  \/* for handling armasm calling convention *\/\n-              if (cif->is_variadic)\n+              if (cif->abi == FFI_WIN64 && isvariadic)\n@@ -944,1 +989,0 @@\n-#endif  \/* for handling armasm calling convention *\/\n@@ -957,1 +1001,0 @@\n-#ifdef _M_ARM64  \/* for handling armasm calling convention *\/\n@@ -959,1 +1002,0 @@\n-#endif  \/* for handling armasm calling convention *\/\n@@ -1000,1 +1042,0 @@\n-  flags = cif->flags;\n@@ -1009,0 +1050,14 @@\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+void *\n+ffi_tramp_arch (size_t *tramp_size, size_t *map_size)\n+{\n+  extern void *trampoline_code_table;\n+\n+  *tramp_size = AARCH64_TRAMP_SIZE;\n+  *map_size = AARCH64_TRAMP_MAP_SIZE;\n+  return &trampoline_code_table;\n+}\n+#endif\n+\n+#endif \/* FFI_CLOSURES *\/\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/aarch64\/ffi.c","additions":121,"deletions":66,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -1,28 +1,20 @@\n-\/* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 2012  Anthony Green\n-                 Copyright (c) 2010  CodeSourcery\n-                 Copyright (c) 1996-2003  Red Hat, Inc.\n-\n-   Target configuration macros for ARM.\n-\n-   Permission is hereby granted, free of charge, to any person obtaining\n-   a copy of this software and associated documentation files (the\n-   ``Software''), to deal in the Software without restriction, including\n-   without limitation the rights to use, copy, modify, merge, publish,\n-   distribute, sublicense, and\/or sell copies of the Software, and to\n-   permit persons to whom the Software is furnished to do so, subject to\n-   the following conditions:\n-\n-   The above copyright notice and this permission notice shall be included\n-   in all copies or substantial portions of the Software.\n-\n-   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n-   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n-   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n-   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n-   DEALINGS IN THE SOFTWARE.\n-\n-   ----------------------------------------------------------------------- *\/\n+\/* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.\n+\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+``Software''), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and\/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n+\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  *\/\n@@ -38,2 +30,13 @@\n-typedef unsigned long          ffi_arg;\n-typedef signed long            ffi_sarg;\n+#ifdef __ILP32__\n+#define FFI_SIZEOF_ARG 8\n+#define FFI_SIZEOF_JAVA_RAW  4\n+typedef unsigned long long ffi_arg;\n+typedef signed long long ffi_sarg;\n+#elif defined(_WIN32)\n+#define FFI_SIZEOF_ARG 8\n+typedef unsigned long long ffi_arg;\n+typedef signed long long ffi_sarg;\n+#else\n+typedef unsigned long ffi_arg;\n+typedef signed long ffi_sarg;\n+#endif\n@@ -41,1 +44,2 @@\n-typedef enum ffi_abi {\n+typedef enum ffi_abi\n+  {\n@@ -44,1 +48,1 @@\n-  FFI_VFP,\n+    FFI_WIN64,\n@@ -46,2 +50,2 @@\n-#if defined(__ARM_PCS_VFP) || defined(_M_ARM)\n-  FFI_DEFAULT_ABI = FFI_VFP,\n+#if defined(_WIN32)\n+    FFI_DEFAULT_ABI = FFI_WIN64\n@@ -49,1 +53,1 @@\n-  FFI_DEFAULT_ABI = FFI_SYSV,\n+    FFI_DEFAULT_ABI = FFI_SYSV\n@@ -54,10 +58,0 @@\n-#define FFI_EXTRA_CIF_FIELDS            \\\n-  int vfp_used;                 \\\n-  unsigned short vfp_reg_free, vfp_nargs;   \\\n-  signed char vfp_args[16]          \\\n-\n-#define FFI_TARGET_SPECIFIC_VARIADIC\n-#ifndef _M_ARM\n-#define FFI_TARGET_HAS_COMPLEX_TYPE\n-#endif\n-\n@@ -67,1 +61,0 @@\n-#define FFI_GO_CLOSURES 1\n@@ -73,2 +66,2 @@\n-#define FFI_TRAMPOLINE_SIZE 12\n-#define FFI_TRAMPOLINE_CLOSURE_OFFSET 8\n+#define FFI_TRAMPOLINE_SIZE 16\n+#define FFI_TRAMPOLINE_CLOSURE_OFFSET 16\n@@ -80,6 +73,1 @@\n-#ifdef _MSC_VER\n-#define FFI_TRAMPOLINE_SIZE 16\n-#define FFI_TRAMPOLINE_CLOSURE_FUNCTION 12\n-#else\n-#define FFI_TRAMPOLINE_SIZE 12\n-#endif\n+#define FFI_TRAMPOLINE_SIZE 24\n@@ -89,0 +77,2 @@\n+#ifdef _WIN32\n+#define FFI_EXTRA_CIF_FIELDS unsigned is_variadic\n@@ -90,0 +80,1 @@\n+#define FFI_TARGET_SPECIFIC_VARIADIC\n@@ -105,0 +96,2 @@\n+\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/aarch64\/ffitarget.h","additions":47,"deletions":54,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -21,3 +21,3 @@\n-#define AARCH64_RET_VOID    0\n-#define AARCH64_RET_INT64   1\n-#define AARCH64_RET_INT128  2\n+#define AARCH64_RET_VOID        0\n+#define AARCH64_RET_INT64       1\n+#define AARCH64_RET_INT128      2\n@@ -25,5 +25,5 @@\n-#define AARCH64_RET_UNUSED3 3\n-#define AARCH64_RET_UNUSED4 4\n-#define AARCH64_RET_UNUSED5 5\n-#define AARCH64_RET_UNUSED6 6\n-#define AARCH64_RET_UNUSED7 7\n+#define AARCH64_RET_UNUSED3     3\n+#define AARCH64_RET_UNUSED4     4\n+#define AARCH64_RET_UNUSED5     5\n+#define AARCH64_RET_UNUSED6     6\n+#define AARCH64_RET_UNUSED7     7\n@@ -33,4 +33,4 @@\n-#define AARCH64_RET_S4      8\n-#define AARCH64_RET_S3      9\n-#define AARCH64_RET_S2      10\n-#define AARCH64_RET_S1      11\n+#define AARCH64_RET_S4          8\n+#define AARCH64_RET_S3          9\n+#define AARCH64_RET_S2          10\n+#define AARCH64_RET_S1          11\n@@ -38,4 +38,4 @@\n-#define AARCH64_RET_D4      12\n-#define AARCH64_RET_D3      13\n-#define AARCH64_RET_D2      14\n-#define AARCH64_RET_D1      15\n+#define AARCH64_RET_D4          12\n+#define AARCH64_RET_D3          13\n+#define AARCH64_RET_D2          14\n+#define AARCH64_RET_D1          15\n@@ -43,4 +43,4 @@\n-#define AARCH64_RET_Q4      16\n-#define AARCH64_RET_Q3      17\n-#define AARCH64_RET_Q2      18\n-#define AARCH64_RET_Q1      19\n+#define AARCH64_RET_Q4          16\n+#define AARCH64_RET_Q3          17\n+#define AARCH64_RET_Q2          18\n+#define AARCH64_RET_Q1          19\n@@ -49,3 +49,3 @@\n-#define AARCH64_RET_UINT8   20\n-#define AARCH64_RET_UINT16  22\n-#define AARCH64_RET_UINT32  24\n+#define AARCH64_RET_UINT8       20\n+#define AARCH64_RET_UINT16      22\n+#define AARCH64_RET_UINT32      24\n@@ -53,3 +53,3 @@\n-#define AARCH64_RET_SINT8   26\n-#define AARCH64_RET_SINT16  28\n-#define AARCH64_RET_SINT32  30\n+#define AARCH64_RET_SINT8       26\n+#define AARCH64_RET_SINT16      28\n+#define AARCH64_RET_SINT32      30\n@@ -57,1 +57,1 @@\n-#define AARCH64_RET_MASK    31\n+#define AARCH64_RET_MASK        31\n@@ -59,1 +59,1 @@\n-#define AARCH64_RET_IN_MEM  (1 << 5)\n+#define AARCH64_RET_IN_MEM      (1 << 5)\n@@ -63,1 +63,2 @@\n-#define AARCH64_FLAG_ARG_V  (1 << AARCH64_FLAG_ARG_V_BIT)\n+#define AARCH64_FLAG_ARG_V      (1 << AARCH64_FLAG_ARG_V_BIT)\n+#define AARCH64_FLAG_VARARG     (1 << 8)\n@@ -65,3 +66,35 @@\n-#define N_X_ARG_REG     8\n-#define N_V_ARG_REG     8\n-#define CALL_CONTEXT_SIZE   (N_V_ARG_REG * 16 + N_X_ARG_REG * 8)\n+#define N_X_ARG_REG             8\n+#define N_V_ARG_REG             8\n+#define CALL_CONTEXT_SIZE       (N_V_ARG_REG * 16 + N_X_ARG_REG * 8)\n+\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+\/*\n+ * For the trampoline code table mapping, a mapping size of 16K is chosen to\n+ * cover the base page sizes of 4K and 16K.\n+ *\/\n+#define AARCH64_TRAMP_MAP_SHIFT 14\n+#define AARCH64_TRAMP_MAP_SIZE  (1 << AARCH64_TRAMP_MAP_SHIFT)\n+#define AARCH64_TRAMP_SIZE      32\n+\n+#endif\n+\n+\/* Helpers for writing assembly compatible with arm ptr auth *\/\n+#ifdef LIBFFI_ASM\n+\n+#ifdef HAVE_PTRAUTH\n+#define SIGN_LR pacibsp\n+#define SIGN_LR_WITH_REG(x) pacib lr, x\n+#define AUTH_LR_AND_RET retab\n+#define AUTH_LR_WITH_REG(x) autib lr, x\n+#define BRANCH_AND_LINK_TO_REG blraaz\n+#define BRANCH_TO_REG braaz\n+#else\n+#define SIGN_LR\n+#define SIGN_LR_WITH_REG(x)\n+#define AUTH_LR_AND_RET ret\n+#define AUTH_LR_WITH_REG(x)\n+#define BRANCH_AND_LINK_TO_REG blr\n+#define BRANCH_TO_REG br\n+#endif\n+\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/aarch64\/internal.h","additions":65,"deletions":32,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-# define BE(X)\tX\n+# define BE(X)  X\n@@ -46,1 +46,1 @@\n-# define BE(X)\t0\n+# define BE(X)  0\n@@ -56,1 +56,1 @@\n-#define PTR_SIZE\t4\n+#define PTR_SIZE        4\n@@ -58,1 +58,1 @@\n-#define PTR_SIZE\t8\n+#define PTR_SIZE        8\n@@ -61,2 +61,2 @@\n-\t.text\n-\t.align 4\n+        .text\n+        .align 4\n@@ -66,2 +66,2 @@\n-\t\t\t      void (*fn)(void), void *rvalue,\n-\t\t\t      int flags, void *closure);\n+                              void (*fn)(void), void *rvalue,\n+                              int flags, void *closure);\n@@ -79,1 +79,1 @@\n-\tcfi_startproc\n+        cfi_startproc\n@@ -81,11 +81,24 @@\n-\t\/* Use a stack frame allocated by our caller.  *\/\n-\tcfi_def_cfa(x1, 32);\n-\tstp\tx29, x30, [x1]\n-\tmov\tx29, x1\n-\tmov\tsp, x0\n-\tcfi_def_cfa_register(x29)\n-\tcfi_rel_offset (x29, 0)\n-\tcfi_rel_offset (x30, 8)\n-\n-\tmov\tx9, x2\t\t\t\/* save fn *\/\n-\tmov\tx8, x3\t\t\t\/* install structure return *\/\n+        \/* Sign the lr with x1 since that is where it will be stored *\/\n+        SIGN_LR_WITH_REG(x1)\n+\n+        \/* Use a stack frame allocated by our caller.  *\/\n+#if defined(HAVE_PTRAUTH) && defined(__APPLE__)\n+        \/* darwin's libunwind assumes that the cfa is the sp and that's the data\n+         * used to sign the lr.  In order to allow unwinding through this\n+         * function it is necessary to point the cfa at the signing register.\n+         *\/\n+        cfi_def_cfa(x1, 0);\n+#else\n+        cfi_def_cfa(x1, 40);\n+#endif\n+        stp     x29, x30, [x1]\n+        mov     x9, sp\n+        str     x9, [x1, #32]\n+        mov     x29, x1\n+        mov     sp, x0\n+        cfi_def_cfa_register(x29)\n+        cfi_rel_offset (x29, 0)\n+        cfi_rel_offset (x30, 8)\n+\n+        mov     x9, x2                  \/* save fn *\/\n+        mov     x8, x3                  \/* install structure return *\/\n@@ -93,1 +106,1 @@\n-\tmov\tx18, x5\t\t\t\/* install static chain *\/\n+        mov     x18, x5                 \/* install static chain *\/\n@@ -95,8 +108,8 @@\n-\tstp\tx3, x4, [x29, #16]\t\/* save rvalue and flags *\/\n-\n-\t\/* Load the vector argument passing registers, if necessary.  *\/\n-\ttbz\tw4, #AARCH64_FLAG_ARG_V_BIT, 1f\n-\tldp     q0, q1, [sp, #0]\n-\tldp     q2, q3, [sp, #32]\n-\tldp     q4, q5, [sp, #64]\n-\tldp     q6, q7, [sp, #96]\n+        stp     x3, x4, [x29, #16]      \/* save rvalue and flags *\/\n+\n+        \/* Load the vector argument passing registers, if necessary.  *\/\n+        tbz     w4, #AARCH64_FLAG_ARG_V_BIT, 1f\n+        ldp     q0, q1, [sp, #0]\n+        ldp     q2, q3, [sp, #32]\n+        ldp     q4, q5, [sp, #64]\n+        ldp     q6, q7, [sp, #96]\n@@ -104,99 +117,106 @@\n-\t\/* Load the core argument passing registers, including\n-\t   the structure return pointer.  *\/\n-\tldp     x0, x1, [sp, #16*N_V_ARG_REG + 0]\n-\tldp     x2, x3, [sp, #16*N_V_ARG_REG + 16]\n-\tldp     x4, x5, [sp, #16*N_V_ARG_REG + 32]\n-\tldp     x6, x7, [sp, #16*N_V_ARG_REG + 48]\n-\n-\t\/* Deallocate the context, leaving the stacked arguments.  *\/\n-\tadd\tsp, sp, #CALL_CONTEXT_SIZE\n-\n-\tblr     x9\t\t\t\/* call fn *\/\n-\n-\tldp\tx3, x4, [x29, #16]\t\/* reload rvalue and flags *\/\n-\n-\t\/* Partially deconstruct the stack frame.  *\/\n-\tmov     sp, x29\n-\tcfi_def_cfa_register (sp)\n-\tldp     x29, x30, [x29]\n-\n-\t\/* Save the return value as directed.  *\/\n-\tadr\tx5, 0f\n-\tand\tw4, w4, #AARCH64_RET_MASK\n-\tadd\tx5, x5, x4, lsl #3\n-\tbr\tx5\n-\n-\t\/* Note that each table entry is 2 insns, and thus 8 bytes.\n-\t   For integer data, note that we're storing into ffi_arg\n-\t   and therefore we want to extend to 64 bits; these types\n-\t   have two consecutive entries allocated for them.  *\/\n-\t.align\t4\n-0:\tret\t\t\t\t\/* VOID *\/\n-\tnop\n-1:\tstr\tx0, [x3]\t\t\/* INT64 *\/\n-\tret\n-2:\tstp\tx0, x1, [x3]\t\t\/* INT128 *\/\n-\tret\n-3:\tbrk\t#1000\t\t\t\/* UNUSED *\/\n-\tret\n-4:\tbrk\t#1000\t\t\t\/* UNUSED *\/\n-\tret\n-5:\tbrk\t#1000\t\t\t\/* UNUSED *\/\n-\tret\n-6:\tbrk\t#1000\t\t\t\/* UNUSED *\/\n-\tret\n-7:\tbrk\t#1000\t\t\t\/* UNUSED *\/\n-\tret\n-8:\tst4\t{ v0.s, v1.s, v2.s, v3.s }[0], [x3]\t\/* S4 *\/\n-\tret\n-9:\tst3\t{ v0.s, v1.s, v2.s }[0], [x3]\t\/* S3 *\/\n-\tret\n-10:\tstp\ts0, s1, [x3]\t\t\/* S2 *\/\n-\tret\n-11:\tstr\ts0, [x3]\t\t\/* S1 *\/\n-\tret\n-12:\tst4\t{ v0.d, v1.d, v2.d, v3.d }[0], [x3]\t\/* D4 *\/\n-\tret\n-13:\tst3\t{ v0.d, v1.d, v2.d }[0], [x3]\t\/* D3 *\/\n-\tret\n-14:\tstp\td0, d1, [x3]\t\t\/* D2 *\/\n-\tret\n-15:\tstr\td0, [x3]\t\t\/* D1 *\/\n-\tret\n-16:\tstr\tq3, [x3, #48]\t\t\/* Q4 *\/\n-\tnop\n-17:\tstr\tq2, [x3, #32]\t\t\/* Q3 *\/\n-\tnop\n-18:\tstp\tq0, q1, [x3]\t\t\/* Q2 *\/\n-\tret\n-19:\tstr\tq0, [x3]\t\t\/* Q1 *\/\n-\tret\n-20:\tuxtb\tw0, w0\t\t\t\/* UINT8 *\/\n-\tstr\tx0, [x3]\n-21:\tret\t\t\t\t\/* reserved *\/\n-\tnop\n-22:\tuxth\tw0, w0\t\t\t\/* UINT16 *\/\n-\tstr\tx0, [x3]\n-23:\tret\t\t\t\t\/* reserved *\/\n-\tnop\n-24:\tmov\tw0, w0\t\t\t\/* UINT32 *\/\n-\tstr\tx0, [x3]\n-25:\tret\t\t\t\t\/* reserved *\/\n-\tnop\n-26:\tsxtb\tx0, w0\t\t\t\/* SINT8 *\/\n-\tstr\tx0, [x3]\n-27:\tret\t\t\t\t\/* reserved *\/\n-\tnop\n-28:\tsxth\tx0, w0\t\t\t\/* SINT16 *\/\n-\tstr\tx0, [x3]\n-29:\tret\t\t\t\t\/* reserved *\/\n-\tnop\n-30:\tsxtw\tx0, w0\t\t\t\/* SINT32 *\/\n-\tstr\tx0, [x3]\n-31:\tret\t\t\t\t\/* reserved *\/\n-\tnop\n-\n-\tcfi_endproc\n-\n-\t.globl\tCNAME(ffi_call_SYSV)\n-\tFFI_HIDDEN(CNAME(ffi_call_SYSV))\n+        \/* Load the core argument passing registers, including\n+           the structure return pointer.  *\/\n+        ldp     x0, x1, [sp, #16*N_V_ARG_REG + 0]\n+        ldp     x2, x3, [sp, #16*N_V_ARG_REG + 16]\n+        ldp     x4, x5, [sp, #16*N_V_ARG_REG + 32]\n+        ldp     x6, x7, [sp, #16*N_V_ARG_REG + 48]\n+\n+        \/* Deallocate the context, leaving the stacked arguments.  *\/\n+        add     sp, sp, #CALL_CONTEXT_SIZE\n+\n+        BRANCH_AND_LINK_TO_REG     x9   \/* call fn *\/\n+\n+        ldp     x3, x4, [x29, #16]      \/* reload rvalue and flags *\/\n+\n+        \/* Partially deconstruct the stack frame.  *\/\n+        ldr     x9, [x29, #32]\n+        mov     sp, x9\n+        cfi_def_cfa_register (sp)\n+        mov     x2, x29                 \/* Preserve for auth *\/\n+        ldp     x29, x30, [x29]\n+\n+        \/* Save the return value as directed.  *\/\n+        adr     x5, 0f\n+        and     w4, w4, #AARCH64_RET_MASK\n+        add     x5, x5, x4, lsl #3\n+        br      x5\n+\n+        \/* Note that each table entry is 2 insns, and thus 8 bytes.\n+           For integer data, note that we're storing into ffi_arg\n+           and therefore we want to extend to 64 bits; these types\n+           have two consecutive entries allocated for them.  *\/\n+        .align  4\n+0:      b 99f                           \/* VOID *\/\n+        nop\n+1:      str     x0, [x3]                \/* INT64 *\/\n+        b 99f\n+2:      stp     x0, x1, [x3]            \/* INT128 *\/\n+        b 99f\n+3:      brk     #1000                   \/* UNUSED *\/\n+        b 99f\n+4:      brk     #1000                   \/* UNUSED *\/\n+        b 99f\n+5:      brk     #1000                   \/* UNUSED *\/\n+        b 99f\n+6:      brk     #1000                   \/* UNUSED *\/\n+        b 99f\n+7:      brk     #1000                   \/* UNUSED *\/\n+        b 99f\n+8:      st4     { v0.s, v1.s, v2.s, v3.s }[0], [x3]  \/* S4 *\/\n+        b 99f\n+9:      st3     { v0.s, v1.s, v2.s }[0], [x3]        \/* S3 *\/\n+        b 99f\n+10:     stp     s0, s1, [x3]                         \/* S2 *\/\n+        b 99f\n+11:     str     s0, [x3]                             \/* S1 *\/\n+        b 99f\n+12:     st4     { v0.d, v1.d, v2.d, v3.d }[0], [x3]  \/* D4 *\/\n+        b 99f\n+13:     st3     { v0.d, v1.d, v2.d }[0], [x3]        \/* D3 *\/\n+        b 99f\n+14:     stp     d0, d1, [x3]                         \/* D2 *\/\n+        b 99f\n+15:     str     d0, [x3]                             \/* D1 *\/\n+        b 99f\n+16:     str     q3, [x3, #48]                        \/* Q4 *\/\n+        nop\n+17:     str     q2, [x3, #32]                        \/* Q3 *\/\n+        nop\n+18:     stp     q0, q1, [x3]                         \/* Q2 *\/\n+        b 99f\n+19:     str     q0, [x3]                             \/* Q1 *\/\n+        b 99f\n+20:     uxtb    w0, w0                               \/* UINT8 *\/\n+        str     x0, [x3]\n+21:     b 99f                                        \/* reserved *\/\n+        nop\n+22:     uxth    w0, w0                               \/* UINT16 *\/\n+        str     x0, [x3]\n+23:     b 99f                                        \/* reserved *\/\n+        nop\n+24:     mov     w0, w0                               \/* UINT32 *\/\n+        str     x0, [x3]\n+25:     b 99f                                        \/* reserved *\/\n+        nop\n+26:     sxtb    x0, w0                               \/* SINT8 *\/\n+        str     x0, [x3]\n+27:     b 99f                                        \/* reserved *\/\n+        nop\n+28:     sxth    x0, w0                               \/* SINT16 *\/\n+        str     x0, [x3]\n+29:     b 99f                                        \/* reserved *\/\n+        nop\n+30:     sxtw    x0, w0                               \/* SINT32 *\/\n+        str     x0, [x3]\n+31:     b 99f                                        \/* reserved *\/\n+        nop\n+\n+        \/* Return now that result has been populated. *\/\n+99:\n+        AUTH_LR_WITH_REG(x2)\n+        ret\n+\n+        cfi_endproc\n+\n+        .globl  CNAME(ffi_call_SYSV)\n+        FFI_HIDDEN(CNAME(ffi_call_SYSV))\n@@ -204,2 +224,2 @@\n-\t.type\tCNAME(ffi_call_SYSV), #function\n-\t.size CNAME(ffi_call_SYSV), .-CNAME(ffi_call_SYSV)\n+        .type CNAME(ffi_call_SYSV), #function\n+        .size CNAME(ffi_call_SYSV), .-CNAME(ffi_call_SYSV)\n@@ -208,0 +228,2 @@\n+#if FFI_CLOSURES\n+\n@@ -224,1 +246,1 @@\n-\t.align 4\n+        .align 4\n@@ -226,16 +248,17 @@\n-\tcfi_startproc\n-\tstp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n-\tcfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n-\tcfi_rel_offset (x29, 0)\n-\tcfi_rel_offset (x30, 8)\n-\n-\t\/* Save the argument passing vector registers.  *\/\n-\tstp     q0, q1, [sp, #16 + 0]\n-\tstp     q2, q3, [sp, #16 + 32]\n-\tstp     q4, q5, [sp, #16 + 64]\n-\tstp     q6, q7, [sp, #16 + 96]\n-\tb\t0f\n-\tcfi_endproc\n-\n-\t.globl\tCNAME(ffi_closure_SYSV_V)\n-\tFFI_HIDDEN(CNAME(ffi_closure_SYSV_V))\n+        cfi_startproc\n+        SIGN_LR\n+        stp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n+        cfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n+        cfi_rel_offset (x29, 0)\n+        cfi_rel_offset (x30, 8)\n+\n+        \/* Save the argument passing vector registers.  *\/\n+        stp     q0, q1, [sp, #16 + 0]\n+        stp     q2, q3, [sp, #16 + 32]\n+        stp     q4, q5, [sp, #16 + 64]\n+        stp     q6, q7, [sp, #16 + 96]\n+        b       0f\n+        cfi_endproc\n+\n+        .globl  CNAME(ffi_closure_SYSV_V)\n+        FFI_HIDDEN(CNAME(ffi_closure_SYSV_V))\n@@ -243,2 +266,2 @@\n-\t.type\tCNAME(ffi_closure_SYSV_V), #function\n-\t.size\tCNAME(ffi_closure_SYSV_V), . - CNAME(ffi_closure_SYSV_V)\n+        .type   CNAME(ffi_closure_SYSV_V), #function\n+        .size   CNAME(ffi_closure_SYSV_V), . - CNAME(ffi_closure_SYSV_V)\n@@ -247,2 +270,2 @@\n-\t.align\t4\n-\tcfi_startproc\n+        .align  4\n+        cfi_startproc\n@@ -250,4 +273,5 @@\n-\tstp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n-\tcfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n-\tcfi_rel_offset (x29, 0)\n-\tcfi_rel_offset (x30, 8)\n+        SIGN_LR\n+        stp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n+        cfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n+        cfi_rel_offset (x29, 0)\n+        cfi_rel_offset (x30, 8)\n@@ -255,1 +279,1 @@\n-\tmov     x29, sp\n+        mov     x29, sp\n@@ -257,5 +281,5 @@\n-\t\/* Save the argument passing core registers.  *\/\n-\tstp     x0, x1, [sp, #16 + 16*N_V_ARG_REG + 0]\n-\tstp     x2, x3, [sp, #16 + 16*N_V_ARG_REG + 16]\n-\tstp     x4, x5, [sp, #16 + 16*N_V_ARG_REG + 32]\n-\tstp     x6, x7, [sp, #16 + 16*N_V_ARG_REG + 48]\n+        \/* Save the argument passing core registers.  *\/\n+        stp     x0, x1, [sp, #16 + 16*N_V_ARG_REG + 0]\n+        stp     x2, x3, [sp, #16 + 16*N_V_ARG_REG + 16]\n+        stp     x4, x5, [sp, #16 + 16*N_V_ARG_REG + 32]\n+        stp     x6, x7, [sp, #16 + 16*N_V_ARG_REG + 48]\n@@ -263,3 +287,4 @@\n-\t\/* Load ffi_closure_inner arguments.  *\/\n-\tldp\tPTR_REG(0), PTR_REG(1), [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET]\t\/* load cif, fn *\/\n-\tldr\tPTR_REG(2), [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET+PTR_SIZE*2]\t\/* load user_data *\/\n+        \/* Load ffi_closure_inner arguments.  *\/\n+        ldp     PTR_REG(0), PTR_REG(1), [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET]   \/* load cif, fn *\/\n+        ldr     PTR_REG(2), [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET+PTR_SIZE*2]    \/* load user_data *\/\n+#ifdef FFI_GO_CLOSURES\n@@ -267,87 +292,156 @@\n-\tadd\tx3, sp, #16\t\t\t\t\/* load context *\/\n-\tadd\tx4, sp, #ffi_closure_SYSV_FS\t\t\/* load stack *\/\n-\tadd\tx5, sp, #16+CALL_CONTEXT_SIZE\t\t\/* load rvalue *\/\n-\tmov\tx6, x8\t\t\t\t\t\/* load struct_rval *\/\n-\tbl      CNAME(ffi_closure_SYSV_inner)\n-\n-\t\/* Load the return value as directed.  *\/\n-\tadr\tx1, 0f\n-\tand\tw0, w0, #AARCH64_RET_MASK\n-\tadd\tx1, x1, x0, lsl #3\n-\tadd\tx3, sp, #16+CALL_CONTEXT_SIZE\n-\tbr\tx1\n-\n-\t\/* Note that each table entry is 2 insns, and thus 8 bytes.  *\/\n-\t.align\t4\n-0:\tb\t99f\t\t\t\/* VOID *\/\n-\tnop\n-1:\tldr\tx0, [x3]\t\t\/* INT64 *\/\n-\tb\t99f\n-2:\tldp\tx0, x1, [x3]\t\t\/* INT128 *\/\n-\tb\t99f\n-3:\tbrk\t#1000\t\t\t\/* UNUSED *\/\n-\tnop\n-4:\tbrk\t#1000\t\t\t\/* UNUSED *\/\n-\tnop\n-5:\tbrk\t#1000\t\t\t\/* UNUSED *\/\n-\tnop\n-6:\tbrk\t#1000\t\t\t\/* UNUSED *\/\n-\tnop\n-7:\tbrk\t#1000\t\t\t\/* UNUSED *\/\n-\tnop\n-8:\tldr\ts3, [x3, #12]\t\t\/* S4 *\/\n-\tnop\n-9:\tldr\ts2, [x3, #8]\t\t\/* S3 *\/\n-\tnop\n-10:\tldp\ts0, s1, [x3]\t\t\/* S2 *\/\n-\tb\t99f\n-11:\tldr\ts0, [x3]\t\t\/* S1 *\/\n-\tb\t99f\n-12:\tldr\td3, [x3, #24]\t\t\/* D4 *\/\n-\tnop\n-13:\tldr\td2, [x3, #16]\t\t\/* D3 *\/\n-\tnop\n-14:\tldp\td0, d1, [x3]\t\t\/* D2 *\/\n-\tb\t99f\n-15:\tldr\td0, [x3]\t\t\/* D1 *\/\n-\tb\t99f\n-16:\tldr\tq3, [x3, #48]\t\t\/* Q4 *\/\n-\tnop\n-17:\tldr\tq2, [x3, #32]\t\t\/* Q3 *\/\n-\tnop\n-18:\tldp\tq0, q1, [x3]\t\t\/* Q2 *\/\n-\tb\t99f\n-19:\tldr\tq0, [x3]\t\t\/* Q1 *\/\n-\tb\t99f\n-20:\tldrb\tw0, [x3, #BE(7)]\t\/* UINT8 *\/\n-\tb\t99f\n-21:\tbrk\t#1000\t\t\t\/* reserved *\/\n-\tnop\n-22:\tldrh\tw0, [x3, #BE(6)]\t\/* UINT16 *\/\n-\tb\t99f\n-23:\tbrk\t#1000\t\t\t\/* reserved *\/\n-\tnop\n-24:\tldr\tw0, [x3, #BE(4)]\t\/* UINT32 *\/\n-\tb\t99f\n-25:\tbrk\t#1000\t\t\t\/* reserved *\/\n-\tnop\n-26:\tldrsb\tx0, [x3, #BE(7)]\t\/* SINT8 *\/\n-\tb\t99f\n-27:\tbrk\t#1000\t\t\t\/* reserved *\/\n-\tnop\n-28:\tldrsh\tx0, [x3, #BE(6)]\t\/* SINT16 *\/\n-\tb\t99f\n-29:\tbrk\t#1000\t\t\t\/* reserved *\/\n-\tnop\n-30:\tldrsw\tx0, [x3, #BE(4)]\t\/* SINT32 *\/\n-\tnop\n-31:\t\t\t\t\t\/* reserved *\/\n-99:\tldp     x29, x30, [sp], #ffi_closure_SYSV_FS\n-\tcfi_adjust_cfa_offset (-ffi_closure_SYSV_FS)\n-\tcfi_restore (x29)\n-\tcfi_restore (x30)\n-\tret\n-\tcfi_endproc\n-\n-\t.globl\tCNAME(ffi_closure_SYSV)\n-\tFFI_HIDDEN(CNAME(ffi_closure_SYSV))\n+#endif\n+        add     x3, sp, #16                             \/* load context *\/\n+        add     x4, sp, #ffi_closure_SYSV_FS            \/* load stack *\/\n+        add     x5, sp, #16+CALL_CONTEXT_SIZE           \/* load rvalue *\/\n+        mov     x6, x8                                  \/* load struct_rval *\/\n+        bl      CNAME(ffi_closure_SYSV_inner)\n+\n+        \/* Load the return value as directed.  *\/\n+        adr     x1, 0f\n+        and     w0, w0, #AARCH64_RET_MASK\n+        add     x1, x1, x0, lsl #3\n+        add     x3, sp, #16+CALL_CONTEXT_SIZE\n+        br      x1\n+\n+        \/* Note that each table entry is 2 insns, and thus 8 bytes.  *\/\n+        .align  4\n+0:      b       99f                     \/* VOID *\/\n+        nop\n+1:      ldr     x0, [x3]                \/* INT64 *\/\n+        b       99f\n+2:      ldp     x0, x1, [x3]            \/* INT128 *\/\n+        b       99f\n+3:      brk     #1000                   \/* UNUSED *\/\n+        nop\n+4:      brk     #1000                   \/* UNUSED *\/\n+        nop\n+5:      brk     #1000                   \/* UNUSED *\/\n+        nop\n+6:      brk     #1000                   \/* UNUSED *\/\n+        nop\n+7:      brk     #1000                   \/* UNUSED *\/\n+        nop\n+8:      ldr     s3, [x3, #12]           \/* S4 *\/\n+        nop\n+9:      ldr     s2, [x3, #8]            \/* S3 *\/\n+        nop\n+10:     ldp     s0, s1, [x3]            \/* S2 *\/\n+        b       99f\n+11:     ldr     s0, [x3]                \/* S1 *\/\n+        b       99f\n+12:     ldr     d3, [x3, #24]           \/* D4 *\/\n+        nop\n+13:     ldr     d2, [x3, #16]           \/* D3 *\/\n+        nop\n+14:     ldp     d0, d1, [x3]            \/* D2 *\/\n+        b       99f\n+15:     ldr     d0, [x3]                \/* D1 *\/\n+        b       99f\n+16:     ldr     q3, [x3, #48]           \/* Q4 *\/\n+        nop\n+17:     ldr     q2, [x3, #32]           \/* Q3 *\/\n+        nop\n+18:     ldp     q0, q1, [x3]            \/* Q2 *\/\n+        b       99f\n+19:     ldr     q0, [x3]                \/* Q1 *\/\n+        b       99f\n+20:     ldrb    w0, [x3, #BE(7)]        \/* UINT8 *\/\n+        b       99f\n+21:     brk     #1000                   \/* reserved *\/\n+        nop\n+22:     ldrh    w0, [x3, #BE(6)]        \/* UINT16 *\/\n+        b       99f\n+23:     brk     #1000                   \/* reserved *\/\n+        nop\n+24:     ldr     w0, [x3, #BE(4)]        \/* UINT32 *\/\n+        b       99f\n+25:     brk     #1000                   \/* reserved *\/\n+        nop\n+26:     ldrsb   x0, [x3, #BE(7)]        \/* SINT8 *\/\n+        b       99f\n+27:     brk     #1000                   \/* reserved *\/\n+        nop\n+28:     ldrsh   x0, [x3, #BE(6)]        \/* SINT16 *\/\n+        b       99f\n+29:     brk     #1000                   \/* reserved *\/\n+        nop\n+30:     ldrsw   x0, [x3, #BE(4)]        \/* SINT32 *\/\n+        nop\n+31:                                     \/* reserved *\/\n+99:     ldp     x29, x30, [sp], #ffi_closure_SYSV_FS\n+        cfi_adjust_cfa_offset (-ffi_closure_SYSV_FS)\n+        cfi_restore (x29)\n+        cfi_restore (x30)\n+        AUTH_LR_AND_RET\n+        cfi_endproc\n+\n+        .globl  CNAME(ffi_closure_SYSV)\n+        FFI_HIDDEN(CNAME(ffi_closure_SYSV))\n+#ifdef __ELF__\n+        .type   CNAME(ffi_closure_SYSV), #function\n+        .size   CNAME(ffi_closure_SYSV), . - CNAME(ffi_closure_SYSV)\n+#endif\n+\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+        .align 4\n+CNAME(ffi_closure_SYSV_V_alt):\n+        \/* See the comments above trampoline_code_table. *\/\n+        ldr     x17, [sp, #8]                   \/* Load closure in x17 *\/\n+        add     sp, sp, #16                     \/* Restore the stack *\/\n+        b       CNAME(ffi_closure_SYSV_V)\n+\n+        .globl  CNAME(ffi_closure_SYSV_V_alt)\n+        FFI_HIDDEN(CNAME(ffi_closure_SYSV_V_alt))\n+#ifdef __ELF__\n+        .type   CNAME(ffi_closure_SYSV_V_alt), #function\n+        .size   CNAME(ffi_closure_SYSV_V_alt), . - CNAME(ffi_closure_SYSV_V_alt)\n+#endif\n+\n+        .align 4\n+CNAME(ffi_closure_SYSV_alt):\n+        \/* See the comments above trampoline_code_table. *\/\n+        ldr     x17, [sp, #8]                   \/* Load closure in x17 *\/\n+        add     sp, sp, #16                     \/* Restore the stack *\/\n+        b       CNAME(ffi_closure_SYSV)\n+\n+        .globl  CNAME(ffi_closure_SYSV_alt)\n+        FFI_HIDDEN(CNAME(ffi_closure_SYSV_alt))\n+#ifdef __ELF__\n+        .type   CNAME(ffi_closure_SYSV_alt), #function\n+        .size   CNAME(ffi_closure_SYSV_alt), . - CNAME(ffi_closure_SYSV_alt)\n+#endif\n+\n+\/*\n+ * Below is the definition of the trampoline code table. Each element in\n+ * the code table is a trampoline.\n+ *\/\n+\/*\n+ * The trampoline uses register x17. It saves the original value of x17 on\n+ * the stack.\n+ *\n+ * The trampoline has two parameters - target code to jump to and data for\n+ * the target code. The trampoline extracts the parameters from its parameter\n+ * block (see tramp_table_map()). The trampoline saves the data address on\n+ * the stack. Finally, it jumps to the target code.\n+ *\n+ * The target code can choose to:\n+ *\n+ * - restore the value of x17\n+ * - load the data address in a register\n+ * - restore the stack pointer to what it was when the trampoline was invoked.\n+ *\/\n+        .align  AARCH64_TRAMP_MAP_SHIFT\n+CNAME(trampoline_code_table):\n+        .rept   AARCH64_TRAMP_MAP_SIZE \/ AARCH64_TRAMP_SIZE\n+        sub     sp, sp, #16             \/* Make space on the stack *\/\n+        str     x17, [sp]               \/* Save x17 on stack *\/\n+        adr     x17, #16376             \/* Get data address *\/\n+        ldr     x17, [x17]              \/* Copy data into x17 *\/\n+        str     x17, [sp, #8]           \/* Save data on stack *\/\n+        adr     x17, #16372             \/* Get code address *\/\n+        ldr     x17, [x17]              \/* Load code address into x17 *\/\n+        br      x17                     \/* Jump to code *\/\n+        .endr\n+\n+        .globl CNAME(trampoline_code_table)\n+        FFI_HIDDEN(CNAME(trampoline_code_table))\n@@ -355,2 +449,2 @@\n-\t.type\tCNAME(ffi_closure_SYSV), #function\n-\t.size\tCNAME(ffi_closure_SYSV), . - CNAME(ffi_closure_SYSV)\n+        .type   CNAME(trampoline_code_table), #function\n+        .size   CNAME(trampoline_code_table), . - CNAME(trampoline_code_table)\n@@ -358,0 +452,2 @@\n+        .align  AARCH64_TRAMP_MAP_SHIFT\n+#endif \/* FFI_EXEC_STATIC_TRAMP *\/\n@@ -369,1 +465,1 @@\n-\tnop\t\t\/* each entry in the trampoline config page is 2*sizeof(void*) so the trampoline itself cannot be smaller that 16 bytes *\/\n+        nop           \/* each entry in the trampoline config page is 2*sizeof(void*) so the trampoline itself cannot be smaller than 16 bytes *\/\n@@ -375,2 +471,2 @@\n-    \t.type\tCNAME(ffi_closure_trampoline_table_page), #function\n-    \t.size\tCNAME(ffi_closure_trampoline_table_page), . - CNAME(ffi_closure_trampoline_table_page)\n+        .type   CNAME(ffi_closure_trampoline_table_page), #function\n+        .size   CNAME(ffi_closure_trampoline_table_page), . - CNAME(ffi_closure_trampoline_table_page)\n@@ -383,1 +479,1 @@\n-\t.align 4\n+        .align 4\n@@ -385,16 +481,16 @@\n-\tcfi_startproc\n-\tstp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n-\tcfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n-\tcfi_rel_offset (x29, 0)\n-\tcfi_rel_offset (x30, 8)\n-\n-\t\/* Save the argument passing vector registers.  *\/\n-\tstp     q0, q1, [sp, #16 + 0]\n-\tstp     q2, q3, [sp, #16 + 32]\n-\tstp     q4, q5, [sp, #16 + 64]\n-\tstp     q6, q7, [sp, #16 + 96]\n-\tb\t0f\n-\tcfi_endproc\n-\n-\t.globl\tCNAME(ffi_go_closure_SYSV_V)\n-\tFFI_HIDDEN(CNAME(ffi_go_closure_SYSV_V))\n+        cfi_startproc\n+        stp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n+        cfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n+        cfi_rel_offset (x29, 0)\n+        cfi_rel_offset (x30, 8)\n+\n+        \/* Save the argument passing vector registers.  *\/\n+        stp     q0, q1, [sp, #16 + 0]\n+        stp     q2, q3, [sp, #16 + 32]\n+        stp     q4, q5, [sp, #16 + 64]\n+        stp     q6, q7, [sp, #16 + 96]\n+        b       0f\n+        cfi_endproc\n+\n+        .globl  CNAME(ffi_go_closure_SYSV_V)\n+        FFI_HIDDEN(CNAME(ffi_go_closure_SYSV_V))\n@@ -402,2 +498,2 @@\n-\t.type\tCNAME(ffi_go_closure_SYSV_V), #function\n-\t.size\tCNAME(ffi_go_closure_SYSV_V), . - CNAME(ffi_go_closure_SYSV_V)\n+        .type   CNAME(ffi_go_closure_SYSV_V), #function\n+        .size   CNAME(ffi_go_closure_SYSV_V), . - CNAME(ffi_go_closure_SYSV_V)\n@@ -406,2 +502,2 @@\n-\t.align\t4\n-\tcfi_startproc\n+        .align  4\n+        cfi_startproc\n@@ -409,4 +505,4 @@\n-\tstp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n-\tcfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n-\tcfi_rel_offset (x29, 0)\n-\tcfi_rel_offset (x30, 8)\n+        stp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n+        cfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n+        cfi_rel_offset (x29, 0)\n+        cfi_rel_offset (x30, 8)\n@@ -414,16 +510,16 @@\n-\tmov     x29, sp\n-\n-\t\/* Save the argument passing core registers.  *\/\n-\tstp     x0, x1, [sp, #16 + 16*N_V_ARG_REG + 0]\n-\tstp     x2, x3, [sp, #16 + 16*N_V_ARG_REG + 16]\n-\tstp     x4, x5, [sp, #16 + 16*N_V_ARG_REG + 32]\n-\tstp     x6, x7, [sp, #16 + 16*N_V_ARG_REG + 48]\n-\n-\t\/* Load ffi_closure_inner arguments.  *\/\n-\tldp\tPTR_REG(0), PTR_REG(1), [x18, #PTR_SIZE]\/* load cif, fn *\/\n-\tmov\tx2, x18\t\t\t\t\t\/* load user_data *\/\n-\tb\t.Ldo_closure\n-\tcfi_endproc\n-\n-\t.globl\tCNAME(ffi_go_closure_SYSV)\n-\tFFI_HIDDEN(CNAME(ffi_go_closure_SYSV))\n+        mov     x29, sp\n+\n+        \/* Save the argument passing core registers.  *\/\n+        stp     x0, x1, [sp, #16 + 16*N_V_ARG_REG + 0]\n+        stp     x2, x3, [sp, #16 + 16*N_V_ARG_REG + 16]\n+        stp     x4, x5, [sp, #16 + 16*N_V_ARG_REG + 32]\n+        stp     x6, x7, [sp, #16 + 16*N_V_ARG_REG + 48]\n+\n+        \/* Load ffi_closure_inner arguments.  *\/\n+        ldp     PTR_REG(0), PTR_REG(1), [x18, #PTR_SIZE]\/* load cif, fn *\/\n+        mov     x2, x18                                 \/* load user_data *\/\n+        b       .Ldo_closure\n+        cfi_endproc\n+\n+        .globl  CNAME(ffi_go_closure_SYSV)\n+        FFI_HIDDEN(CNAME(ffi_go_closure_SYSV))\n@@ -431,2 +527,2 @@\n-\t.type\tCNAME(ffi_go_closure_SYSV), #function\n-\t.size\tCNAME(ffi_go_closure_SYSV), . - CNAME(ffi_go_closure_SYSV)\n+        .type   CNAME(ffi_go_closure_SYSV), #function\n+        .size   CNAME(ffi_go_closure_SYSV), . - CNAME(ffi_go_closure_SYSV)\n@@ -435,0 +531,1 @@\n+#endif \/* FFI_CLOSURES *\/\n@@ -438,1 +535,1 @@\n-\t.section .note.GNU-stack,\"\",%progbits\n+        .section .note.GNU-stack,\"\",%progbits\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/aarch64\/sysv.S","additions":397,"deletions":300,"binary":false,"changes":697,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include <tramp.h>\n@@ -48,0 +49,3 @@\n+#ifdef  HAVE_SYS_MEMFD_H\n+#include <sys\/memfd.h>\n+#endif\n@@ -112,0 +116,6 @@\n+\n+int\n+ffi_tramp_is_present (__attribute__((unused)) void *ptr)\n+{\n+  return 0;\n+}\n@@ -126,1 +136,1 @@\n-# if defined(X86_WIN32) || defined(X86_WIN64) || defined(_M_ARM64) || defined(__OS2__)\n+# if defined(_WIN32) || defined(__OS2__)\n@@ -151,0 +161,3 @@\n+#ifdef HAVE_PTRAUTH\n+#include <ptrauth.h>\n+#endif\n@@ -163,1 +176,0 @@\n-  vm_address_t trampoline_page;\n@@ -207,0 +219,4 @@\n+\n+#ifdef HAVE_PTRAUTH\n+  trampoline_page_template = (vm_address_t)(uintptr_t)ptrauth_auth_data((void *)&ffi_closure_trampoline_table_page, ptrauth_key_function_pointer, 0);\n+#else\n@@ -208,0 +224,2 @@\n+#endif\n+\n@@ -215,1 +233,1 @@\n-  if (kt != KERN_SUCCESS)\n+  if (kt != KERN_SUCCESS || !(cur_prot & VM_PROT_EXECUTE))\n@@ -225,1 +243,0 @@\n-  table->trampoline_page = trampoline_page;\n@@ -235,1 +252,4 @@\n-    (void *) (table->trampoline_page + (i * FFI_TRAMPOLINE_SIZE));\n+        (void *) (trampoline_page + (i * FFI_TRAMPOLINE_SIZE));\n+#ifdef HAVE_PTRAUTH\n+      entry->trampoline = ptrauth_sign_unauthenticated(entry->trampoline, ptrauth_key_function_pointer, 0);\n+#endif\n@@ -389,1 +409,1 @@\n-#if !defined(X86_WIN32) && !defined(X86_WIN64) && !defined(_M_ARM64)\n+#if !defined(_WIN32)\n@@ -515,1 +535,1 @@\n-#if !(defined(X86_WIN32) || defined(X86_WIN64) || defined(_M_ARM64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)\n+#if !(defined(_WIN32) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)\n@@ -519,1 +539,1 @@\n-#endif \/* !(defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) *\/\n+#endif \/* !(defined(_WIN32) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) *\/\n@@ -529,1 +549,1 @@\n-#if !(defined(X86_WIN32) || defined(X86_WIN64) || defined(_M_ARM64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)\n+#if !(defined(_WIN32) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)\n@@ -541,0 +561,11 @@\n+#ifdef HAVE_MEMFD_CREATE\n+\/* Open a temporary file name, and immediately unlink it.  *\/\n+static int\n+open_temp_exec_file_memfd (const char *name)\n+{\n+  int fd;\n+  fd = memfd_create (name, MFD_CLOEXEC);\n+  return fd;\n+}\n+#endif\n+\n@@ -668,0 +699,4 @@\n+#ifdef HAVE_MEMFD_CREATE\n+  { open_temp_exec_file_memfd, \"libffi\", 0 },\n+#endif\n+  { open_temp_exec_file_env, \"LIBFFI_TMPDIR\", 0 },\n@@ -840,0 +875,6 @@\n+  if (execfd == -1 && ffi_tramp_is_supported ())\n+    {\n+      ptr = mmap (start, length, prot & ~PROT_EXEC, flags, fd, offset);\n+      return ptr;\n+    }\n+\n@@ -911,1 +952,1 @@\n-#endif \/* !(defined(X86_WIN32) || defined(X86_WIN64) || defined(_M_ARM64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) *\/\n+#endif \/* !(defined(_WIN32) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) *\/\n@@ -919,1 +960,1 @@\n-  void *ptr;\n+  void *ptr, *ftramp;\n@@ -924,1 +965,1 @@\n-  ptr = dlmalloc (size);\n+  ptr = FFI_CLOSURE_PTR (dlmalloc (size));\n@@ -935,0 +976,11 @@\n+      if (!ffi_tramp_is_supported ())\n+        return ptr;\n+\n+      ftramp = ffi_tramp_alloc (0);\n+      if (ftramp == NULL)\n+      {\n+        dlfree (FFI_RESTORE_PTR (ptr));\n+        return NULL;\n+    }\n+      *code = ffi_tramp_get_addr (ftramp);\n+      ((ffi_closure *) ptr)->ftramp = ftramp;\n@@ -949,0 +1001,2 @@\n+    {\n+      if (!ffi_tramp_is_supported ())\n@@ -950,0 +1004,2 @@\n+      return ffi_tramp_get_addr (((ffi_closure *) data)->ftramp);\n+    }\n@@ -967,0 +1023,5 @@\n+  if (ffi_tramp_is_supported ())\n+    ffi_tramp_free (((ffi_closure *) ptr)->ftramp);\n+\n+  dlfree (FFI_RESTORE_PTR (ptr));\n+}\n@@ -968,1 +1029,5 @@\n-  dlfree (ptr);\n+int\n+ffi_tramp_is_present (void *ptr)\n+{\n+  msegmentptr seg = segment_holding (gm, ptr);\n+  return seg != NULL && ffi_tramp_is_supported();\n@@ -984,1 +1049,1 @@\n-  return *code = malloc (size);\n+  return *code = FFI_CLOSURE_PTR (malloc (size));\n@@ -990,1 +1055,1 @@\n-  free (ptr);\n+  free (FFI_RESTORE_PTR (ptr));\n@@ -999,0 +1064,6 @@\n+int\n+ffi_tramp_is_present (__attribute__((unused)) void *ptr)\n+{\n+  return 0;\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/closures.c","additions":86,"deletions":15,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1962,5 +1962,5 @@\n-  (((v) != IS_MMAPPED_BIT) ? (ABORT, (v)) :             \\\n-   (((S)->exec_offset =                         \\\n-     mmap_exec_offset((S)->base, (S)->size)),               \\\n-    (mmap_exec_offset((S)->base + (S)->exec_offset, (S)->size) !=   \\\n-     (S)->exec_offset) ? (ABORT, (v)) :                 \\\n+  (((v) != IS_MMAPPED_BIT) ? (ABORT, (v)) :                             \\\n+   (((S)->exec_offset =                                                 \\\n+     mmap_exec_offset((S)->base, (S)->size)),                           \\\n+    (mmap_exec_offset((S)->base + (S)->exec_offset, (S)->size) !=       \\\n+     (S)->exec_offset) ? (ABORT, (v)) :                                 \\\n@@ -2374,1 +2374,1 @@\n-#define compute_bit2idx(X, I) I = ffs(X)-1\n+#define compute_bit2idx(X, I) I = __builtin_ffs(X)-1\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/dlmalloc.c","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,5 +32,5 @@\n-\/* This defines a Java- and 64-bit specific variant of the raw API. *\/\n-\/* It assumes that \"raw\" argument blocks look like Java stacks on a *\/\n-\/* 64-bit machine.  Arguments that can be stored in a single stack  *\/\n-\/* stack slots (longs, doubles) occupy 128 bits, but only the first *\/\n-\/* 64 bits are actually used.                       *\/\n+\/* This defines a Java- and 64-bit specific variant of the raw API.     *\/\n+\/* It assumes that \"raw\" argument blocks look like Java stacks on a     *\/\n+\/* 64-bit machine.  Arguments that can be stored in a single stack      *\/\n+\/* stack slots (longs, doubles) occupy 128 bits, but only the first     *\/\n+\/* 64 bits are actually used.                                           *\/\n@@ -61,1 +61,1 @@\n-      \/* No structure parameters in Java.   *\/\n+      \/* No structure parameters in Java.  *\/\n@@ -322,1 +322,1 @@\n-#if FFI_CLOSURES        \/* base system provides closures *\/\n+#if FFI_CLOSURES           \/* base system provides closures *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/java_raw_api.c","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-   prep_cif.c - Copyright (c) 2011, 2012  Anthony Green\n+   prep_cif.c - Copyright (c) 2011, 2012, 2021  Anthony Green\n@@ -132,1 +132,1 @@\n-#ifdef _M_ARM64\n+#if (defined(_M_ARM64) || defined(__aarch64__)) && defined(_WIN32)\n@@ -234,1 +234,20 @@\n-  return ffi_prep_cif_core(cif, abi, 1, nfixedargs, ntotalargs, rtype, atypes);\n+  ffi_status rc;\n+  size_t int_size = ffi_type_sint.size;\n+  int i;\n+\n+  rc = ffi_prep_cif_core(cif, abi, 1, nfixedargs, ntotalargs, rtype, atypes);\n+\n+  if (rc != FFI_OK)\n+    return rc;\n+\n+  for (i = 1; i < ntotalargs; i++)\n+    {\n+      ffi_type *arg_type = atypes[i];\n+      if (arg_type == &ffi_type_float\n+          || ((arg_type->type != FFI_TYPE_STRUCT\n+               && arg_type->type != FFI_TYPE_COMPLEX)\n+              && arg_type->size < int_size))\n+        return FFI_BAD_ARGTYPE;\n+}\n+\n+  return FFI_OK;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/prep_cif.c","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-#if FFI_CLOSURES        \/* base system provides closures *\/\n+#if FFI_CLOSURES            \/* base system provides closures *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/raw_api.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,9 +37,9 @@\n-struct struct_align_##name {            \\\n-  char c;                   \\\n-  type x;                   \\\n-};                      \\\n-FFI_EXTERN                  \\\n-maybe_const ffi_type ffi_type_##name = {    \\\n-  sizeof(type),                 \\\n-  offsetof(struct struct_align_##name, x),  \\\n-  id, NULL                  \\\n+struct struct_align_##name {                    \\\n+  char c;                                       \\\n+  type x;                                       \\\n+};                                              \\\n+FFI_EXTERN                                      \\\n+maybe_const ffi_type ffi_type_##name = {        \\\n+  sizeof(type),                                 \\\n+  offsetof(struct struct_align_##name, x),      \\\n+  id, NULL                                      \\\n@@ -50,12 +50,12 @@\n-    (ffi_type *)(&ffi_type_##name), NULL        \\\n-};                          \\\n-struct struct_align_complex_##name {            \\\n-  char c;                       \\\n-  _Complex type x;                  \\\n-};                          \\\n-FFI_EXTERN                      \\\n-maybe_const ffi_type ffi_type_complex_##name = {    \\\n-  sizeof(_Complex type),                \\\n-  offsetof(struct struct_align_complex_##name, x),  \\\n-  FFI_TYPE_COMPLEX,                 \\\n-  (ffi_type **)ffi_elements_complex_##name      \\\n+        (ffi_type *)(&ffi_type_##name), NULL            \\\n+};                                                      \\\n+struct struct_align_complex_##name {                    \\\n+  char c;                                               \\\n+  _Complex type x;                                      \\\n+};                                                      \\\n+FFI_EXTERN                                              \\\n+maybe_const ffi_type ffi_type_complex_##name = {        \\\n+  sizeof(_Complex type),                                \\\n+  offsetof(struct struct_align_complex_##name, x),      \\\n+  FFI_TYPE_COMPLEX,                                     \\\n+  (ffi_type **)ffi_elements_complex_##name              \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/types.c","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include <tramp.h>\n@@ -219,6 +220,6 @@\n-  void *ebp;        \/* 0 *\/\n-  void *retaddr;    \/* 4 *\/\n-  void (*fn)(void); \/* 8 *\/\n-  int flags;        \/* 12 *\/\n-  void *rvalue;     \/* 16 *\/\n-  unsigned regs[3]; \/* 20-28 *\/\n+  void *ebp;            \/* 0 *\/\n+  void *retaddr;        \/* 4 *\/\n+  void (*fn)(void);     \/* 8 *\/\n+  int flags;            \/* 12 *\/\n+  void *rvalue;         \/* 16 *\/\n+  unsigned regs[3];     \/* 20-28 *\/\n@@ -229,3 +230,3 @@\n-  int dir;      \/* parameter growth direction *\/\n-  int static_chain; \/* the static chain register used by gcc *\/\n-  int nregs;        \/* number of register parameters *\/\n+  int dir;              \/* parameter growth direction *\/\n+  int static_chain;     \/* the static chain register used by gcc *\/\n+  int nregs;            \/* number of register parameters *\/\n@@ -258,0 +259,7 @@\n+\/* We perform some black magic here to use some of the parent's stack frame in\n+ * ffi_call_i386() that breaks with the MSVC compiler with the \/RTCs or \/GZ\n+ * flags.  Disable the 'Stack frame run time error checking' for this function\n+ * so we don't hit weird exceptions in debug builds. *\/\n+#if defined(_MSC_VER)\n+#pragma runtime_checks(\"s\", off)\n+#endif\n@@ -356,1 +364,1 @@\n-         as 64-bit integer or struct, all following integer paramters\n+         as 64-bit integer or struct, all following integer parameters\n@@ -393,0 +401,3 @@\n+#if defined(_MSC_VER)\n+#pragma runtime_checks(\"s\", restore)\n+#endif\n@@ -400,0 +411,1 @@\n+#ifdef FFI_GO_CLOSURES\n@@ -406,0 +418,1 @@\n+#endif\n@@ -412,0 +425,5 @@\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+void FFI_HIDDEN ffi_closure_i386_alt(void);\n+void FFI_HIDDEN ffi_closure_STDCALL_alt(void);\n+void FFI_HIDDEN ffi_closure_REGISTER_alt(void);\n+#endif\n@@ -415,5 +433,5 @@\n-  unsigned rettemp[4];              \/* 0 *\/\n-  unsigned regs[3];             \/* 16-24 *\/\n-  ffi_cif *cif;                 \/* 28 *\/\n-  void (*fun)(ffi_cif*,void*,void**,void*); \/* 32 *\/\n-  void *user_data;              \/* 36 *\/\n+  unsigned rettemp[4];                          \/* 0 *\/\n+  unsigned regs[3];                             \/* 16-24 *\/\n+  ffi_cif *cif;                                 \/* 28 *\/\n+  void (*fun)(ffi_cif*,void*,void**,void*);     \/* 32 *\/\n+  void *user_data;                              \/* 36 *\/\n@@ -495,1 +513,1 @@\n-         as 64-bit integer or struct, all following integer paramters\n+         as 64-bit integer or struct, all following integer parameters\n@@ -523,5 +541,12 @@\n-  if (cabi == FFI_STDCALL)\n-    return flags + (cif->bytes << X86_RET_POP_SHIFT);\n-  else\n-    return flags;\n- }\n+  switch (cabi)\n+    {\n+    case FFI_STDCALL:\n+      return flags | (cif->bytes << X86_RET_POP_SHIFT);\n+    case FFI_THISCALL:\n+    case FFI_FASTCALL:\n+      return flags | ((cif->bytes - (narg_reg * FFI_SIZEOF_ARG))\n+          << X86_RET_POP_SHIFT);\n+    default:\n+      return flags;\n+    }\n+}\n@@ -543,2 +568,0 @@\n-    case FFI_THISCALL:\n-    case FFI_FASTCALL:\n@@ -549,0 +572,2 @@\n+    case FFI_THISCALL:\n+    case FFI_FASTCALL:\n@@ -560,0 +585,19 @@\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+  if (ffi_tramp_is_present(closure))\n+    {\n+      \/* Initialize the static trampoline's parameters. *\/\n+      if (dest == ffi_closure_i386)\n+        dest = ffi_closure_i386_alt;\n+      else if (dest == ffi_closure_STDCALL)\n+        dest = ffi_closure_STDCALL_alt;\n+      else\n+        dest = ffi_closure_REGISTER_alt;\n+      ffi_tramp_set_parms (closure->ftramp, dest, closure);\n+      goto out;\n+    }\n+#endif\n+\n+  \/* Initialize the dynamic trampoline. *\/\n+  \/* endbr32.  *\/\n+  *(UINT32 *) tramp = 0xfb1e0ff3;\n+\n@@ -561,2 +605,2 @@\n-  tramp[0] = op;\n-  *(void **)(tramp + 1) = codeloc;\n+  tramp[4] = op;\n+  *(void **)(tramp + 5) = codeloc;\n@@ -565,2 +609,2 @@\n-  tramp[5] = 0xe9;\n-  *(unsigned *)(tramp + 6) = (unsigned)dest - ((unsigned)codeloc + 10);\n+  tramp[9] = 0xe9;\n+  *(unsigned *)(tramp + 10) = (unsigned)dest - ((unsigned)codeloc + 14);\n@@ -568,0 +612,1 @@\n+out:\n@@ -575,0 +620,2 @@\n+#ifdef FFI_GO_CLOSURES\n+\n@@ -611,0 +658,2 @@\n+#endif \/* FFI_GO_CLOSURES *\/\n+\n@@ -638,1 +687,1 @@\n-    return FFI_BAD_TYPEDEF;\n+        return FFI_BAD_TYPEDEF;\n@@ -720,5 +769,5 @@\n-    {\n-      frame->regs[pabi->regs[0]] = (unsigned)rvalue;\n-      narg_reg = 1;\n-      break;\n-}\n+        {\n+          frame->regs[pabi->regs[0]] = (unsigned)rvalue;\n+          narg_reg = 1;\n+          break;\n+        }\n@@ -735,1 +784,1 @@\n-{\n+    {\n@@ -741,11 +790,11 @@\n-    {\n-      ffi_arg val = extend_basic_type (avalue, t);\n-      frame->regs[pabi->regs[narg_reg++]] = val;\n-      z = FFI_SIZEOF_ARG;\n-    }\n-  else\n-    {\n-      memcpy (argp, avalue, z);\n-      z = FFI_ALIGN (z, FFI_SIZEOF_ARG);\n-      argp += z;\n-    }\n+        {\n+          ffi_arg val = extend_basic_type (avalue, t);\n+          frame->regs[pabi->regs[narg_reg++]] = val;\n+          z = FFI_SIZEOF_ARG;\n+        }\n+      else\n+        {\n+          memcpy (argp, avalue, z);\n+          z = FFI_ALIGN (z, FFI_SIZEOF_ARG);\n+          argp += z;\n+        }\n@@ -754,1 +803,1 @@\n-}\n+    }\n@@ -761,0 +810,13 @@\n+\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+void *\n+ffi_tramp_arch (size_t *tramp_size, size_t *map_size)\n+{\n+  extern void *trampoline_code_table;\n+\n+  *map_size = X86_TRAMP_MAP_SIZE;\n+  *tramp_size = X86_TRAMP_SIZE;\n+  return &trampoline_code_table;\n+}\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/x86\/ffi.c","additions":108,"deletions":46,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include <tramp.h>\n@@ -102,1 +103,1 @@\n-#define SSE_CLASS_P(X)  ((X) >= X86_64_SSE_CLASS && X <= X86_64_SSEUP_CLASS)\n+#define SSE_CLASS_P(X) ((X) >= X86_64_SSE_CLASS && X <= X86_64_SSEUP_CLASS)\n@@ -220,1 +221,2 @@\n-    size_t words = (type->size + UNITS_PER_WORD - 1) \/ UNITS_PER_WORD;\n+        size_t words = (type->size + byte_offset + UNITS_PER_WORD - 1)\n+                       \/ UNITS_PER_WORD;\n@@ -244,1 +246,1 @@\n-        size_t num;\n+        size_t num, pos;\n@@ -251,1 +253,2 @@\n-        for (i = 0; i < num; i++)\n+            pos = byte_offset \/ 8;\n+            for (i = 0; i < num && (i + pos) < words; i++)\n@@ -691,0 +694,2 @@\n+#ifdef FFI_GO_CLOSURES\n+\n@@ -711,0 +716,1 @@\n+#endif \/* FFI_GO_CLOSURES *\/\n@@ -714,0 +720,4 @@\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+extern void ffi_closure_unix64_alt(void) FFI_HIDDEN;\n+extern void ffi_closure_unix64_sse_alt(void) FFI_HIDDEN;\n+#endif\n@@ -731,7 +741,9 @@\n-  static const unsigned char trampoline[16] = {\n-    \/* leaq  -0x7(%rip),%r10   # 0x0  *\/\n-    0x4c, 0x8d, 0x15, 0xf9, 0xff, 0xff, 0xff,\n-    \/* jmpq  *0x3(%rip)        # 0x10 *\/\n-    0xff, 0x25, 0x03, 0x00, 0x00, 0x00,\n-    \/* nopl  (%rax) *\/\n-    0x0f, 0x1f, 0x00\n+  static const unsigned char trampoline[24] = {\n+    \/* endbr64 *\/\n+    0xf3, 0x0f, 0x1e, 0xfa,\n+    \/* leaq  -0xb(%rip),%r10   # 0x0  *\/\n+    0x4c, 0x8d, 0x15, 0xf5, 0xff, 0xff, 0xff,\n+    \/* jmpq  *0x7(%rip)        # 0x18 *\/\n+    0xff, 0x25, 0x07, 0x00, 0x00, 0x00,\n+    \/* nopl  0(%rax) *\/\n+    0x0f, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00\n@@ -754,0 +766,14 @@\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+  if (ffi_tramp_is_present(closure))\n+    {\n+      \/* Initialize the static trampoline's parameters. *\/\n+      if (dest == ffi_closure_unix64_sse)\n+        dest = ffi_closure_unix64_sse_alt;\n+      else\n+        dest = ffi_closure_unix64_alt;\n+      ffi_tramp_set_parms (closure->ftramp, dest, closure);\n+      goto out;\n+    }\n+#endif\n+\n+  \/* Initialize the dynamic trampoline. *\/\n@@ -755,1 +781,1 @@\n-  *(UINT64 *)(tramp + 16) = (uintptr_t)dest;\n+  *(UINT64 *)(tramp + sizeof (trampoline)) = (uintptr_t)dest;\n@@ -757,0 +783,1 @@\n+out:\n@@ -857,0 +884,2 @@\n+#ifdef FFI_GO_CLOSURES\n+\n@@ -886,0 +915,14 @@\n+#endif \/* FFI_GO_CLOSURES *\/\n+\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+void *\n+ffi_tramp_arch (size_t *tramp_size, size_t *map_size)\n+{\n+  extern void *trampoline_code_table;\n+\n+  *map_size = UNIX64_TRAMP_MAP_SIZE;\n+  *tramp_size = UNIX64_TRAMP_SIZE;\n+  return &trampoline_code_table;\n+}\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/x86\/ffi64.c","additions":55,"deletions":12,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -139,1 +139,3 @@\n-# define FFI_TRAMPOLINE_SIZE 24\n+\/* 4 bytes of ENDBR64 + 7 bytes of LEA + 6 bytes of JMP + 7 bytes of NOP\n+   + 8 bytes of pointer.  *\/\n+# define FFI_TRAMPOLINE_SIZE 32\n@@ -142,1 +144,3 @@\n-# define FFI_TRAMPOLINE_SIZE 12\n+\/* 4 bytes of ENDBR32 + 5 bytes of MOV + 5 bytes of JMP + 2 unused\n+   bytes.  *\/\n+# define FFI_TRAMPOLINE_SIZE 16\n@@ -146,0 +150,11 @@\n+#if !defined(GENERATE_LIBFFI_MAP) && defined(__CET__)\n+# include <cet.h>\n+# if (__CET__ & 1) != 0\n+#   define ENDBR_PRESENT\n+# endif\n+# define _CET_NOTRACK notrack\n+#else\n+# define _CET_ENDBR\n+# define _CET_NOTRACK\n+#endif\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/x86\/ffitarget.h","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include <tramp.h>\n@@ -42,5 +43,5 @@\n-  UINT64 rbp;       \/* 0 *\/\n-  UINT64 retaddr;   \/* 8 *\/\n-  UINT64 fn;        \/* 16 *\/\n-  UINT64 flags;     \/* 24 *\/\n-  UINT64 rvalue;    \/* 32 *\/\n+  UINT64 rbp;           \/* 0 *\/\n+  UINT64 retaddr;       \/* 8 *\/\n+  UINT64 fn;            \/* 16 *\/\n+  UINT64 flags;         \/* 24 *\/\n+  UINT64 rvalue;        \/* 32 *\/\n@@ -110,0 +111,7 @@\n+\/* We perform some black magic here to use some of the parent's stack frame in\n+ * ffi_call_win64() that breaks with the MSVC compiler with the \/RTCs or \/GZ\n+ * flags.  Disable the 'Stack frame run time error checking' for this function\n+ * so we don't hit weird exceptions in debug builds. *\/\n+#if defined(_MSC_VER)\n+#pragma runtime_checks(\"s\", off)\n+#endif\n@@ -174,0 +182,3 @@\n+#if defined(_MSC_VER)\n+#pragma runtime_checks(\"s\", restore)\n+#endif\n@@ -190,0 +201,5 @@\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+extern void ffi_closure_win64_alt(void) FFI_HIDDEN;\n+#endif\n+\n+#ifdef FFI_GO_CLOSURES\n@@ -191,0 +207,1 @@\n+#endif\n@@ -199,7 +216,9 @@\n-  static const unsigned char trampoline[16] = {\n-    \/* leaq  -0x7(%rip),%r10   # 0x0  *\/\n-    0x4c, 0x8d, 0x15, 0xf9, 0xff, 0xff, 0xff,\n-    \/* jmpq  *0x3(%rip)        # 0x10 *\/\n-    0xff, 0x25, 0x03, 0x00, 0x00, 0x00,\n-    \/* nopl  (%rax) *\/\n-    0x0f, 0x1f, 0x00\n+  static const unsigned char trampoline[FFI_TRAMPOLINE_SIZE - 8] = {\n+    \/* endbr64 *\/\n+    0xf3, 0x0f, 0x1e, 0xfa,\n+    \/* leaq  -0xb(%rip),%r10   # 0x0  *\/\n+    0x4c, 0x8d, 0x15, 0xf5, 0xff, 0xff, 0xff,\n+    \/* jmpq  *0x7(%rip)        # 0x18 *\/\n+    0xff, 0x25, 0x07, 0x00, 0x00, 0x00,\n+    \/* nopl  0(%rax) *\/\n+    0x0f, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00\n@@ -218,0 +237,10 @@\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+  if (ffi_tramp_is_present(closure))\n+    {\n+      \/* Initialize the static trampoline's parameters. *\/\n+      ffi_tramp_set_parms (closure->ftramp, ffi_closure_win64_alt, closure);\n+      goto out;\n+    }\n+#endif\n+\n+  \/* Initialize the dynamic trampoline. *\/\n@@ -219,1 +248,1 @@\n-  *(UINT64 *)(tramp + 16) = (uintptr_t)ffi_closure_win64;\n+  *(UINT64 *)(tramp + sizeof (trampoline)) = (uintptr_t)ffi_closure_win64;\n@@ -221,0 +250,1 @@\n+out:\n@@ -228,0 +258,1 @@\n+#ifdef FFI_GO_CLOSURES\n@@ -247,0 +278,1 @@\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/x86\/ffiw64.c","additions":45,"deletions":13,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1,11 +1,11 @@\n-#define X86_RET_FLOAT       0\n-#define X86_RET_DOUBLE      1\n-#define X86_RET_LDOUBLE     2\n-#define X86_RET_SINT8       3\n-#define X86_RET_SINT16      4\n-#define X86_RET_UINT8       5\n-#define X86_RET_UINT16      6\n-#define X86_RET_INT64       7\n-#define X86_RET_INT32       8\n-#define X86_RET_VOID        9\n-#define X86_RET_STRUCTPOP   10\n+#define X86_RET_FLOAT           0\n+#define X86_RET_DOUBLE          1\n+#define X86_RET_LDOUBLE         2\n+#define X86_RET_SINT8           3\n+#define X86_RET_SINT16          4\n+#define X86_RET_UINT8           5\n+#define X86_RET_UINT16          6\n+#define X86_RET_INT64           7\n+#define X86_RET_INT32           8\n+#define X86_RET_VOID            9\n+#define X86_RET_STRUCTPOP       10\n@@ -13,4 +13,4 @@\n-#define X86_RET_STRUCT_1B   12\n-#define X86_RET_STRUCT_2B   13\n-#define X86_RET_UNUSED14    14\n-#define X86_RET_UNUSED15    15\n+#define X86_RET_STRUCT_1B       12\n+#define X86_RET_STRUCT_2B       13\n+#define X86_RET_UNUSED14        14\n+#define X86_RET_UNUSED15        15\n@@ -18,2 +18,2 @@\n-#define X86_RET_TYPE_MASK   15\n-#define X86_RET_POP_SHIFT   4\n+#define X86_RET_TYPE_MASK       15\n+#define X86_RET_POP_SHIFT       4\n@@ -30,0 +30,14 @@\n+\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+\/*\n+ * For the trampoline code table mapping, a mapping size of 4K (base page size)\n+ * is chosen.\n+ *\/\n+#define X86_TRAMP_MAP_SHIFT     12\n+#define X86_TRAMP_MAP_SIZE      (1 << X86_TRAMP_MAP_SHIFT)\n+#ifdef ENDBR_PRESENT\n+#define X86_TRAMP_SIZE          44\n+#else\n+#define X86_TRAMP_SIZE          40\n+#endif\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/x86\/internal.h","additions":31,"deletions":17,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1,12 +1,12 @@\n-#define UNIX64_RET_VOID     0\n-#define UNIX64_RET_UINT8    1\n-#define UNIX64_RET_UINT16   2\n-#define UNIX64_RET_UINT32   3\n-#define UNIX64_RET_SINT8    4\n-#define UNIX64_RET_SINT16   5\n-#define UNIX64_RET_SINT32   6\n-#define UNIX64_RET_INT64    7\n-#define UNIX64_RET_XMM32    8\n-#define UNIX64_RET_XMM64    9\n-#define UNIX64_RET_X87      10\n-#define UNIX64_RET_X87_2    11\n+#define UNIX64_RET_VOID         0\n+#define UNIX64_RET_UINT8        1\n+#define UNIX64_RET_UINT16       2\n+#define UNIX64_RET_UINT32       3\n+#define UNIX64_RET_SINT8        4\n+#define UNIX64_RET_SINT16       5\n+#define UNIX64_RET_SINT32       6\n+#define UNIX64_RET_INT64        7\n+#define UNIX64_RET_XMM32        8\n+#define UNIX64_RET_XMM64        9\n+#define UNIX64_RET_X87          10\n+#define UNIX64_RET_X87_2        11\n@@ -18,1 +18,1 @@\n-#define UNIX64_RET_LAST     15\n+#define UNIX64_RET_LAST         15\n@@ -22,1 +22,15 @@\n-#define UNIX64_SIZE_SHIFT   12\n+#define UNIX64_SIZE_SHIFT       12\n+\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+\/*\n+ * For the trampoline code table mapping, a mapping size of 4K (base page size)\n+ * is chosen.\n+ *\/\n+#define UNIX64_TRAMP_MAP_SHIFT  12\n+#define UNIX64_TRAMP_MAP_SIZE   (1 << UNIX64_TRAMP_MAP_SHIFT)\n+#ifdef ENDBR_PRESENT\n+#define UNIX64_TRAMP_SIZE       40\n+#else\n+#define UNIX64_TRAMP_SIZE       32\n+#endif\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/x86\/internal64.h","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -5,2 +5,2 @@\n-   \n-   X86 Foreign Function Interface \n+\n+   X86 Foreign Function Interface\n@@ -32,1 +32,1 @@\n-#define LIBFFI_ASM\t\n+#define LIBFFI_ASM\n@@ -52,1 +52,1 @@\n-# define ENDF(X)  .type\tX,@function; .size X, . - X\n+# define ENDF(X)  .type X,@function; .size X, . - X\n@@ -59,2 +59,2 @@\n-# define ffi_call_i386\t\t\"@ffi_call_i386@8\"\n-# define ffi_closure_inner\t\"@ffi_closure_inner@8\"\n+# define ffi_call_i386          \"@ffi_call_i386@8\"\n+# define ffi_closure_inner      \"@ffi_closure_inner@8\"\n@@ -62,2 +62,2 @@\n-# define ffi_call_i386\t\tC(ffi_call_i386)\n-# define ffi_closure_inner\tC(ffi_closure_inner)\n+# define ffi_call_i386          C(ffi_call_i386)\n+# define ffi_closure_inner      C(ffi_closure_inner)\n@@ -71,1 +71,1 @@\n-# define E(BASE, X)\t.balign 8\n+# define E(BASE, X)     .balign 8\n@@ -73,1 +73,1 @@\n-# define E(BASE, X)\t.balign 8; .org BASE + X * 8\n+# define E(BASE, X)     .balign 8; .org BASE + X * 8\n@@ -76,4 +76,4 @@\n-\t.text\n-\t.balign\t16\n-\t.globl\tffi_call_i386\n-\tFFI_HIDDEN(ffi_call_i386)\n+        .text\n+        .balign 16\n+        .globl  ffi_call_i386\n+        FFI_HIDDEN(ffi_call_i386)\n@@ -94,2 +94,2 @@\n-\t# cfi_startproc\n-\t_CET_ENDBR\n+        # cfi_startproc\n+        _CET_ENDBR\n@@ -97,2 +97,2 @@\n-\tmovl\t4(%esp), %ecx\n-\tmovl\t8(%esp), %edx\n+        movl    4(%esp), %ecx\n+        movl    8(%esp), %edx\n@@ -100,12 +100,12 @@\n-\tmovl\t(%esp), %eax\t\t\/* move the return address *\/\n-\tmovl\t%ebp, (%ecx)\t\t\/* store %ebp into local frame *\/\n-\tmovl\t%eax, 4(%ecx)\t\t\/* store retaddr into local frame *\/\n-\n-\t\/* New stack frame based off ebp.  This is a itty bit of unwind\n-\t   trickery in that the CFA *has* changed.  There is no easy way\n-\t   to describe it correctly on entry to the function.  Fortunately,\n-\t   it doesn't matter too much since at all points we can correctly\n-\t   unwind back to ffi_call.  Note that the location to which we\n-\t   moved the return address is (the new) CFA-4, so from the\n-\t   perspective of the unwind info, it hasn't moved.  *\/\n-\tmovl\t%ecx, %ebp\n+        movl    (%esp), %eax            \/* move the return address *\/\n+        movl    %ebp, (%ecx)            \/* store %ebp into local frame *\/\n+        movl    %eax, 4(%ecx)           \/* store retaddr into local frame *\/\n+\n+        \/* New stack frame based off ebp.  This is a itty bit of unwind\n+           trickery in that the CFA *has* changed.  There is no easy way\n+           to describe it correctly on entry to the function.  Fortunately,\n+           it doesn't matter too much since at all points we can correctly\n+           unwind back to ffi_call.  Note that the location to which we\n+           moved the return address is (the new) CFA-4, so from the\n+           perspective of the unwind info, it hasn't moved.  *\/\n+        movl    %ecx, %ebp\n@@ -113,2 +113,2 @@\n-\t# cfi_def_cfa(%ebp, 8)\n-\t# cfi_rel_offset(%ebp, 0)\n+        # cfi_def_cfa(%ebp, 8)\n+        # cfi_rel_offset(%ebp, 0)\n@@ -116,4 +116,4 @@\n-\tmovl\t%edx, %esp\t\t\/* set outgoing argument stack *\/\n-\tmovl\t20+R_EAX*4(%ebp), %eax\t\/* set register arguments *\/\n-\tmovl\t20+R_EDX*4(%ebp), %edx\n-\tmovl\t20+R_ECX*4(%ebp), %ecx\n+        movl    %edx, %esp              \/* set outgoing argument stack *\/\n+        movl    20+R_EAX*4(%ebp), %eax  \/* set register arguments *\/\n+        movl    20+R_EDX*4(%ebp), %edx\n+        movl    20+R_ECX*4(%ebp), %ecx\n@@ -121,1 +121,1 @@\n-\tcall\t*8(%ebp)\n+        call    *8(%ebp)\n@@ -123,2 +123,2 @@\n-\tmovl\t12(%ebp), %ecx\t\t\/* load return type code *\/\n-\tmovl\t%ebx, 8(%ebp)\t\t\/* preserve %ebx *\/\n+        movl    12(%ebp), %ecx          \/* load return type code *\/\n+        movl    %ebx, 8(%ebp)           \/* preserve %ebx *\/\n@@ -126,1 +126,1 @@\n-\t# cfi_rel_offset(%ebx, 8)\n+        # cfi_rel_offset(%ebx, 8)\n@@ -128,1 +128,1 @@\n-\tandl\t$X86_RET_TYPE_MASK, %ecx\n+        andl    $X86_RET_TYPE_MASK, %ecx\n@@ -130,1 +130,1 @@\n-\tcall\tC(__x86.get_pc_thunk.bx)\n+        call    C(__x86.get_pc_thunk.bx)\n@@ -132,1 +132,1 @@\n-\tleal\tL(store_table)-L(pc1)(%ebx, %ecx, 8), %ebx\n+        leal    L(store_table)-L(pc1)(%ebx, %ecx, 8), %ebx\n@@ -134,1 +134,1 @@\n-\tleal\tL(store_table)(,%ecx, 8), %ebx\n+        leal    L(store_table)(,%ecx, 8), %ebx\n@@ -136,2 +136,2 @@\n-\tmovl\t16(%ebp), %ecx\t\t\/* load result address *\/\n-\t_CET_NOTRACK jmp *%ebx\n+        movl    16(%ebp), %ecx          \/* load result address *\/\n+        _CET_NOTRACK jmp *%ebx\n@@ -139,1 +139,1 @@\n-\t.balign\t8\n+        .balign 8\n@@ -142,2 +142,2 @@\n-\tfstps\t(%ecx)\n-\tjmp\tL(e1)\n+        fstps   (%ecx)\n+        jmp     L(e1)\n@@ -145,2 +145,2 @@\n-\tfstpl\t(%ecx)\n-\tjmp\tL(e1)\n+        fstpl   (%ecx)\n+        jmp     L(e1)\n@@ -148,2 +148,2 @@\n-\tfstpt\t(%ecx)\n-\tjmp\tL(e1)\n+        fstpt   (%ecx)\n+        jmp     L(e1)\n@@ -151,3 +151,3 @@\n-\tmovsbl\t%al, %eax\n-\tmov\t%eax, (%ecx)\n-\tjmp\tL(e1)\n+        movsbl  %al, %eax\n+        mov     %eax, (%ecx)\n+        jmp     L(e1)\n@@ -155,3 +155,3 @@\n-\tmovswl\t%ax, %eax\n-\tmov\t%eax, (%ecx)\n-\tjmp\tL(e1)\n+        movswl  %ax, %eax\n+        mov     %eax, (%ecx)\n+        jmp     L(e1)\n@@ -159,3 +159,3 @@\n-\tmovzbl\t%al, %eax\n-\tmov\t%eax, (%ecx)\n-\tjmp\tL(e1)\n+        movzbl  %al, %eax\n+        mov     %eax, (%ecx)\n+        jmp     L(e1)\n@@ -163,3 +163,3 @@\n-\tmovzwl\t%ax, %eax\n-\tmov\t%eax, (%ecx)\n-\tjmp\tL(e1)\n+        movzwl  %ax, %eax\n+        mov     %eax, (%ecx)\n+        jmp     L(e1)\n@@ -167,2 +167,2 @@\n-\tmovl\t%edx, 4(%ecx)\n-\t\/* fallthru *\/\n+        movl    %edx, 4(%ecx)\n+        \/* fallthru *\/\n@@ -170,2 +170,2 @@\n-\tmovl\t%eax, (%ecx)\n-\t\/* fallthru *\/\n+        movl    %eax, (%ecx)\n+        \/* fallthru *\/\n@@ -174,3 +174,3 @@\n-\tmovl\t8(%ebp), %ebx\n-\tmovl\t%ebp, %esp\n-\tpopl\t%ebp\n+        movl    8(%ebp), %ebx\n+        movl    %ebp, %esp\n+        popl    %ebp\n@@ -178,5 +178,5 @@\n-\t# cfi_remember_state\n-\t# cfi_def_cfa(%esp, 4)\n-\t# cfi_restore(%ebx)\n-\t# cfi_restore(%ebp)\n-\tret\n+        # cfi_remember_state\n+        # cfi_def_cfa(%esp, 4)\n+        # cfi_restore(%ebx)\n+        # cfi_restore(%ebp)\n+        ret\n@@ -184,1 +184,1 @@\n-\t# cfi_restore_state\n+        # cfi_restore_state\n@@ -187,1 +187,1 @@\n-\tjmp\tL(e1)\n+        jmp     L(e1)\n@@ -189,1 +189,1 @@\n-\tjmp\tL(e1)\n+        jmp     L(e1)\n@@ -191,2 +191,2 @@\n-\tmovb\t%al, (%ecx)\n-\tjmp\tL(e1)\n+        movb    %al, (%ecx)\n+        jmp     L(e1)\n@@ -194,2 +194,2 @@\n-\tmovw\t%ax, (%ecx)\n-\tjmp\tL(e1)\n+        movw    %ax, (%ecx)\n+        jmp     L(e1)\n@@ -197,1 +197,1 @@\n-\t\/* Fill out the table so that bad values are predictable.  *\/\n+        \/* Fill out the table so that bad values are predictable.  *\/\n@@ -199,1 +199,1 @@\n-\tud2\n+        ud2\n@@ -201,1 +201,1 @@\n-\tud2\n+        ud2\n@@ -204,1 +204,1 @@\n-\t# cfi_endproc\n+        # cfi_endproc\n@@ -210,1 +210,1 @@\n-\t__attribute_((fastcall))\n+        __attribute_((fastcall))\n@@ -214,2 +214,2 @@\n-\tecx:\tframe\n-\tedx:\targp\n+        ecx:    frame\n+        edx:    argp\n@@ -221,2 +221,2 @@\n-# define closure_FS\t(40 + 4)\n-# define closure_CF\t0\n+# define closure_FS     (40 + 4)\n+# define closure_CF     0\n@@ -224,2 +224,2 @@\n-# define closure_FS\t(8 + 40 + 12)\n-# define closure_CF\t8\n+# define closure_FS     (8 + 40 + 12)\n+# define closure_CF     8\n@@ -228,4 +228,4 @@\n-#define FFI_CLOSURE_SAVE_REGS\t\t\\\n-\tmovl\t%eax, closure_CF+16+R_EAX*4(%esp);\t\\\n-\tmovl\t%edx, closure_CF+16+R_EDX*4(%esp);\t\\\n-\tmovl\t%ecx, closure_CF+16+R_ECX*4(%esp)\n+#define FFI_CLOSURE_SAVE_REGS                           \\\n+        movl    %eax, closure_CF+16+R_EAX*4(%esp);      \\\n+        movl    %edx, closure_CF+16+R_EDX*4(%esp);      \\\n+        movl    %ecx, closure_CF+16+R_ECX*4(%esp)\n@@ -233,7 +233,7 @@\n-#define FFI_CLOSURE_COPY_TRAMP_DATA\t\t\t\t\t\\\n-\tmovl\tFFI_TRAMPOLINE_SIZE(%eax), %edx;\t\/* copy cif *\/\t\\\n-\tmovl\tFFI_TRAMPOLINE_SIZE+4(%eax), %ecx;\t\/* copy fun *\/\t\\\n-\tmovl\tFFI_TRAMPOLINE_SIZE+8(%eax), %eax;\t\/* copy user_data *\/ \\\n-\tmovl\t%edx, closure_CF+28(%esp);\t\t\t\t\\\n-\tmovl\t%ecx, closure_CF+32(%esp);\t\t\t\t\\\n-\tmovl\t%eax, closure_CF+36(%esp)\n+#define FFI_CLOSURE_COPY_TRAMP_DATA                                     \\\n+        movl    FFI_TRAMPOLINE_SIZE(%eax), %edx;   \/* copy cif *\/       \\\n+        movl    FFI_TRAMPOLINE_SIZE+4(%eax), %ecx; \/* copy fun *\/       \\\n+        movl    FFI_TRAMPOLINE_SIZE+8(%eax), %eax; \/* copy user_data *\/ \\\n+        movl    %edx, closure_CF+28(%esp);                              \\\n+        movl    %ecx, closure_CF+32(%esp);                              \\\n+        movl    %eax, closure_CF+36(%esp)\n@@ -242,3 +242,3 @@\n-# define FFI_CLOSURE_PREP_CALL\t\t\t\t\t\t\\\n-\tmovl\t%esp, %ecx;\t\t\t\/* load closure_data *\/\t\\\n-\tleal\tclosure_FS+4(%esp), %edx;\t\/* load incoming stack *\/\n+# define FFI_CLOSURE_PREP_CALL                                          \\\n+        movl    %esp, %ecx;                   \/* load closure_data *\/   \\\n+        leal    closure_FS+4(%esp), %edx;     \/* load incoming stack *\/\n@@ -246,5 +246,5 @@\n-# define FFI_CLOSURE_PREP_CALL\t\t\t\t\t\t\\\n-\tleal\tclosure_CF(%esp), %ecx;\t\t\/* load closure_data *\/\t\\\n-\tleal\tclosure_FS+4(%esp), %edx;\t\/* load incoming stack *\/ \\\n-\tmovl\t%ecx, (%esp);\t\t\t\t\t\t\\\n-\tmovl\t%edx, 4(%esp)\n+# define FFI_CLOSURE_PREP_CALL                                          \\\n+        leal    closure_CF(%esp), %ecx;       \/* load closure_data *\/   \\\n+        leal    closure_FS+4(%esp), %edx;     \/* load incoming stack *\/ \\\n+        movl    %ecx, (%esp);                                           \\\n+        movl    %edx, 4(%esp)\n@@ -254,1 +254,1 @@\n-\tcall\tffi_closure_inner\n+        call    ffi_closure_inner\n@@ -256,5 +256,5 @@\n-#define FFI_CLOSURE_MASK_AND_JUMP(N, UW)\t\t\t\t\\\n-\tandl\t$X86_RET_TYPE_MASK, %eax;\t\t\t\t\\\n-\tleal\tL(C1(load_table,N))(, %eax, 8), %edx;\t\t\t\\\n-\tmovl\tclosure_CF(%esp), %eax;\t\t\/* optimiztic load *\/\t\\\n-\t_CET_NOTRACK jmp *%edx\n+#define FFI_CLOSURE_MASK_AND_JUMP(N, UW)                                \\\n+        andl    $X86_RET_TYPE_MASK, %eax;                               \\\n+        leal    L(C1(load_table,N))(, %eax, 8), %edx;                   \\\n+        movl    closure_CF(%esp), %eax;         \/* optimiztic load *\/   \\\n+        _CET_NOTRACK jmp *%edx\n@@ -265,7 +265,7 @@\n-#  define FFI_CLOSURE_MASK_AND_JUMP(N, UW)\t\t\t\t\\\n-\tandl\t$X86_RET_TYPE_MASK, %eax;\t\t\t\t\\\n-\tcall\tC(__x86.get_pc_thunk.dx);\t\t\t\t\\\n-L(C1(pc,N)):\t\t\t\t\t\t\t\t\\\n-\tleal\tL(C1(load_table,N))-L(C1(pc,N))(%edx, %eax, 8), %edx;\t\\\n-\tmovl\tclosure_CF(%esp), %eax;\t\t\/* optimiztic load *\/\t\\\n-\t_CET_NOTRACK jmp *%edx\n+#  define FFI_CLOSURE_MASK_AND_JUMP(N, UW)                              \\\n+        andl    $X86_RET_TYPE_MASK, %eax;                               \\\n+        call    C(__x86.get_pc_thunk.dx);                               \\\n+L(C1(pc,N)):                                                            \\\n+        leal    L(C1(load_table,N))-L(C1(pc,N))(%edx, %eax, 8), %edx;   \\\n+        movl    closure_CF(%esp), %eax;         \/* optimiztic load *\/   \\\n+        _CET_NOTRACK jmp *%edx\n@@ -275,7 +275,7 @@\n-#  define FFI_CLOSURE_CALL_INNER(UWN)\t\t\t\t\t\\\n-\tmovl\t%ebx, 40(%esp);\t\t\t\/* save ebx *\/\t\t\\\n-L(C1(UW,UWN)):\t\t\t\t\t\t\t\t\\\n-\t\/* cfi_rel_offset(%ebx, 40); *\/\t\t\t\t\t\\\n-\tcall\tC(__x86.get_pc_thunk.bx);\t\/* load got register *\/\t\\\n-\taddl\t$C(_GLOBAL_OFFSET_TABLE_), %ebx;\t\t\t\\\n-\tcall\tffi_closure_inner@PLT\n+#  define FFI_CLOSURE_CALL_INNER(UWN)                                   \\\n+        movl    %ebx, 40(%esp);                 \/* save ebx *\/          \\\n+L(C1(UW,UWN)):                                                          \\\n+        \/* cfi_rel_offset(%ebx, 40); *\/                                 \\\n+        call    C(__x86.get_pc_thunk.bx);       \/* load got register *\/ \\\n+        addl    $C(_GLOBAL_OFFSET_TABLE_), %ebx;                        \\\n+        call    ffi_closure_inner@PLT\n@@ -283,8 +283,8 @@\n-#  define FFI_CLOSURE_MASK_AND_JUMP(N, UWN)\t\t\t\t\\\n-\tandl\t$X86_RET_TYPE_MASK, %eax;\t\t\t\t\\\n-\tleal\tL(C1(load_table,N))@GOTOFF(%ebx, %eax, 8), %edx;\t\\\n-\tmovl\t40(%esp), %ebx;\t\t\t\/* restore ebx *\/\t\\\n-L(C1(UW,UWN)):\t\t\t\t\t\t\t\t\\\n-\t\/* cfi_restore(%ebx); *\/\t\t\t\t\t\\\n-\tmovl\tclosure_CF(%esp), %eax;\t\t\/* optimiztic load *\/\t\\\n-\t_CET_NOTRACK jmp *%edx\n+#  define FFI_CLOSURE_MASK_AND_JUMP(N, UWN)                             \\\n+        andl    $X86_RET_TYPE_MASK, %eax;                               \\\n+        leal    L(C1(load_table,N))@GOTOFF(%ebx, %eax, 8), %edx;        \\\n+        movl    40(%esp), %ebx;                 \/* restore ebx *\/       \\\n+L(C1(UW,UWN)):                                                          \\\n+        \/* cfi_restore(%ebx); *\/                                        \\\n+        movl    closure_CF(%esp), %eax;         \/* optimiztic load *\/   \\\n+        _CET_NOTRACK jmp *%edx\n@@ -294,3 +294,3 @@\n-\t.balign\t16\n-\t.globl\tC(ffi_go_closure_EAX)\n-\tFFI_HIDDEN(C(ffi_go_closure_EAX))\n+        .balign 16\n+        .globl  C(ffi_go_closure_EAX)\n+        FFI_HIDDEN(C(ffi_go_closure_EAX))\n@@ -299,3 +299,3 @@\n-\t# cfi_startproc\n-\t_CET_ENDBR\n-\tsubl\t$closure_FS, %esp\n+        # cfi_startproc\n+        _CET_ENDBR\n+        subl    $closure_FS, %esp\n@@ -303,8 +303,8 @@\n-\t# cfi_def_cfa_offset(closure_FS + 4)\n-\tFFI_CLOSURE_SAVE_REGS\n-\tmovl\t4(%eax), %edx\t\t\t\/* copy cif *\/\n-\tmovl\t8(%eax), %ecx\t\t\t\/* copy fun *\/\n-\tmovl\t%edx, closure_CF+28(%esp)\n-\tmovl\t%ecx, closure_CF+32(%esp)\n-\tmovl\t%eax, closure_CF+36(%esp)\t\/* closure is user_data *\/\n-\tjmp\tL(do_closure_i386)\n+        # cfi_def_cfa_offset(closure_FS + 4)\n+        FFI_CLOSURE_SAVE_REGS\n+        movl    4(%eax), %edx                   \/* copy cif *\/\n+        movl    8(%eax), %ecx                   \/* copy fun *\/\n+        movl    %edx, closure_CF+28(%esp)\n+        movl    %ecx, closure_CF+32(%esp)\n+        movl    %eax, closure_CF+36(%esp)       \/* closure is user_data *\/\n+        jmp     L(do_closure_i386)\n@@ -312,1 +312,1 @@\n-\t# cfi_endproc\n+        # cfi_endproc\n@@ -315,3 +315,3 @@\n-\t.balign\t16\n-\t.globl\tC(ffi_go_closure_ECX)\n-\tFFI_HIDDEN(C(ffi_go_closure_ECX))\n+        .balign 16\n+        .globl  C(ffi_go_closure_ECX)\n+        FFI_HIDDEN(C(ffi_go_closure_ECX))\n@@ -320,3 +320,3 @@\n-\t# cfi_startproc\n-\t_CET_ENDBR\n-\tsubl\t$closure_FS, %esp\n+        # cfi_startproc\n+        _CET_ENDBR\n+        subl    $closure_FS, %esp\n@@ -324,8 +324,8 @@\n-\t# cfi_def_cfa_offset(closure_FS + 4)\n-\tFFI_CLOSURE_SAVE_REGS\n-\tmovl\t4(%ecx), %edx\t\t\t\/* copy cif *\/\n-\tmovl\t8(%ecx), %eax\t\t\t\/* copy fun *\/\n-\tmovl\t%edx, closure_CF+28(%esp)\n-\tmovl\t%eax, closure_CF+32(%esp)\n-\tmovl\t%ecx, closure_CF+36(%esp)\t\/* closure is user_data *\/\n-\tjmp\tL(do_closure_i386)\n+        # cfi_def_cfa_offset(closure_FS + 4)\n+        FFI_CLOSURE_SAVE_REGS\n+        movl    4(%ecx), %edx                   \/* copy cif *\/\n+        movl    8(%ecx), %eax                   \/* copy fun *\/\n+        movl    %edx, closure_CF+28(%esp)\n+        movl    %eax, closure_CF+32(%esp)\n+        movl    %ecx, closure_CF+36(%esp)       \/* closure is user_data *\/\n+        jmp     L(do_closure_i386)\n@@ -333,1 +333,1 @@\n-\t# cfi_endproc\n+        # cfi_endproc\n@@ -339,3 +339,3 @@\n-\t.balign\t16\n-\t.globl\tC(ffi_closure_i386)\n-\tFFI_HIDDEN(C(ffi_closure_i386))\n+        .balign 16\n+        .globl  C(ffi_closure_i386)\n+        FFI_HIDDEN(C(ffi_closure_i386))\n@@ -345,3 +345,3 @@\n-\t# cfi_startproc\n-\t_CET_ENDBR\n-\tsubl\t$closure_FS, %esp\n+        # cfi_startproc\n+        _CET_ENDBR\n+        subl    $closure_FS, %esp\n@@ -349,1 +349,1 @@\n-\t# cfi_def_cfa_offset(closure_FS + 4)\n+        # cfi_def_cfa_offset(closure_FS + 4)\n@@ -351,2 +351,2 @@\n-\tFFI_CLOSURE_SAVE_REGS\n-\tFFI_CLOSURE_COPY_TRAMP_DATA\n+        FFI_CLOSURE_SAVE_REGS\n+        FFI_CLOSURE_COPY_TRAMP_DATA\n@@ -354,1 +354,1 @@\n-\t\/* Entry point from preceeding Go closures.  *\/\n+        \/* Entry point from preceeding Go closures.  *\/\n@@ -357,3 +357,3 @@\n-\tFFI_CLOSURE_PREP_CALL\n-\tFFI_CLOSURE_CALL_INNER(14)\n-\tFFI_CLOSURE_MASK_AND_JUMP(2, 15)\n+        FFI_CLOSURE_PREP_CALL\n+        FFI_CLOSURE_CALL_INNER(14)\n+        FFI_CLOSURE_MASK_AND_JUMP(2, 15)\n@@ -361,1 +361,1 @@\n-\t.balign\t8\n+        .balign 8\n@@ -364,2 +364,2 @@\n-\tflds\tclosure_CF(%esp)\n-\tjmp\tL(e2)\n+        flds    closure_CF(%esp)\n+        jmp     L(e2)\n@@ -367,2 +367,2 @@\n-\tfldl\tclosure_CF(%esp)\n-\tjmp\tL(e2)\n+        fldl    closure_CF(%esp)\n+        jmp     L(e2)\n@@ -370,2 +370,2 @@\n-\tfldt\tclosure_CF(%esp)\n-\tjmp\tL(e2)\n+        fldt    closure_CF(%esp)\n+        jmp     L(e2)\n@@ -373,2 +373,2 @@\n-\tmovsbl\t%al, %eax\n-\tjmp\tL(e2)\n+        movsbl  %al, %eax\n+        jmp     L(e2)\n@@ -376,2 +376,2 @@\n-\tmovswl\t%ax, %eax\n-\tjmp\tL(e2)\n+        movswl  %ax, %eax\n+        jmp     L(e2)\n@@ -379,2 +379,2 @@\n-\tmovzbl\t%al, %eax\n-\tjmp\tL(e2)\n+        movzbl  %al, %eax\n+        jmp     L(e2)\n@@ -382,2 +382,2 @@\n-\tmovzwl\t%ax, %eax\n-\tjmp\tL(e2)\n+        movzwl  %ax, %eax\n+        jmp     L(e2)\n@@ -385,2 +385,2 @@\n-\tmovl\tclosure_CF+4(%esp), %edx\n-\tjmp\tL(e2)\n+        movl    closure_CF+4(%esp), %edx\n+        jmp     L(e2)\n@@ -388,2 +388,2 @@\n-\tnop\n-\t\/* fallthru *\/\n+        nop\n+        \/* fallthru *\/\n@@ -392,1 +392,1 @@\n-\taddl\t$closure_FS, %esp\n+        addl    $closure_FS, %esp\n@@ -394,2 +394,2 @@\n-\t# cfi_adjust_cfa_offset(-closure_FS)\n-\tret\n+        # cfi_adjust_cfa_offset(-closure_FS)\n+        ret\n@@ -397,1 +397,1 @@\n-\t# cfi_adjust_cfa_offset(closure_FS)\n+        # cfi_adjust_cfa_offset(closure_FS)\n@@ -399,1 +399,1 @@\n-\taddl\t$closure_FS, %esp\n+        addl    $closure_FS, %esp\n@@ -401,2 +401,2 @@\n-\t# cfi_adjust_cfa_offset(-closure_FS)\n-\tret\t$4\n+        # cfi_adjust_cfa_offset(-closure_FS)\n+        ret     $4\n@@ -404,1 +404,1 @@\n-\t# cfi_adjust_cfa_offset(closure_FS)\n+        # cfi_adjust_cfa_offset(closure_FS)\n@@ -406,1 +406,1 @@\n-\tjmp\tL(e2)\n+        jmp     L(e2)\n@@ -408,2 +408,2 @@\n-\tmovzbl\t%al, %eax\n-\tjmp\tL(e2)\n+        movzbl  %al, %eax\n+        jmp     L(e2)\n@@ -411,2 +411,2 @@\n-\tmovzwl\t%ax, %eax\n-\tjmp\tL(e2)\n+        movzwl  %ax, %eax\n+        jmp     L(e2)\n@@ -414,1 +414,1 @@\n-\t\/* Fill out the table so that bad values are predictable.  *\/\n+        \/* Fill out the table so that bad values are predictable.  *\/\n@@ -416,1 +416,1 @@\n-\tud2\n+        ud2\n@@ -418,1 +418,1 @@\n-\tud2\n+        ud2\n@@ -421,1 +421,1 @@\n-\t# cfi_endproc\n+        # cfi_endproc\n@@ -424,3 +424,3 @@\n-\t.balign\t16\n-\t.globl\tC(ffi_go_closure_STDCALL)\n-\tFFI_HIDDEN(C(ffi_go_closure_STDCALL))\n+        .balign 16\n+        .globl  C(ffi_go_closure_STDCALL)\n+        FFI_HIDDEN(C(ffi_go_closure_STDCALL))\n@@ -429,3 +429,3 @@\n-\t# cfi_startproc\n-\t_CET_ENDBR\n-\tsubl\t$closure_FS, %esp\n+        # cfi_startproc\n+        _CET_ENDBR\n+        subl    $closure_FS, %esp\n@@ -433,8 +433,8 @@\n-\t# cfi_def_cfa_offset(closure_FS + 4)\n-\tFFI_CLOSURE_SAVE_REGS\n-\tmovl\t4(%ecx), %edx\t\t\t\/* copy cif *\/\n-\tmovl\t8(%ecx), %eax\t\t\t\/* copy fun *\/\n-\tmovl\t%edx, closure_CF+28(%esp)\n-\tmovl\t%eax, closure_CF+32(%esp)\n-\tmovl\t%ecx, closure_CF+36(%esp)\t\/* closure is user_data *\/\n-\tjmp\tL(do_closure_STDCALL)\n+        # cfi_def_cfa_offset(closure_FS + 4)\n+        FFI_CLOSURE_SAVE_REGS\n+        movl    4(%ecx), %edx                   \/* copy cif *\/\n+        movl    8(%ecx), %eax                   \/* copy fun *\/\n+        movl    %edx, closure_CF+28(%esp)\n+        movl    %eax, closure_CF+32(%esp)\n+        movl    %ecx, closure_CF+36(%esp)       \/* closure is user_data *\/\n+        jmp     L(do_closure_STDCALL)\n@@ -442,1 +442,1 @@\n-\t# cfi_endproc\n+        # cfi_endproc\n@@ -448,3 +448,3 @@\n-\t.balign\t16\n-\t.globl\tC(ffi_closure_REGISTER)\n-\tFFI_HIDDEN(C(ffi_closure_REGISTER))\n+        .balign 16\n+        .globl  C(ffi_closure_REGISTER)\n+        FFI_HIDDEN(C(ffi_closure_REGISTER))\n@@ -453,5 +453,5 @@\n-\t# cfi_startproc\n-\t# cfi_def_cfa(%esp, 8)\n-\t# cfi_offset(%eip, -8)\n-\t_CET_ENDBR\n-\tsubl\t$closure_FS-4, %esp\n+        # cfi_startproc\n+        # cfi_def_cfa(%esp, 8)\n+        # cfi_offset(%eip, -8)\n+        _CET_ENDBR\n+        subl    $closure_FS-4, %esp\n@@ -459,6 +459,6 @@\n-\t# cfi_def_cfa_offset(closure_FS + 4)\n-\tFFI_CLOSURE_SAVE_REGS\n-\tmovl\tclosure_FS-4(%esp), %ecx\t\/* load retaddr *\/\n-\tmovl\tclosure_FS(%esp), %eax\t\t\/* load closure *\/\n-\tmovl\t%ecx, closure_FS(%esp)\t\t\/* move retaddr *\/\n-\tjmp\tL(do_closure_REGISTER)\n+        # cfi_def_cfa_offset(closure_FS + 4)\n+        FFI_CLOSURE_SAVE_REGS\n+        movl    closure_FS-4(%esp), %ecx        \/* load retaddr *\/\n+        movl    closure_FS(%esp), %eax          \/* load closure *\/\n+        movl    %ecx, closure_FS(%esp)          \/* move retaddr *\/\n+        jmp     L(do_closure_REGISTER)\n@@ -466,1 +466,1 @@\n-\t# cfi_endproc\n+        # cfi_endproc\n@@ -473,3 +473,3 @@\n-\t.balign\t16\n-\t.globl\tC(ffi_closure_STDCALL)\n-\tFFI_HIDDEN(C(ffi_closure_STDCALL))\n+        .balign 16\n+        .globl  C(ffi_closure_STDCALL)\n+        FFI_HIDDEN(C(ffi_closure_STDCALL))\n@@ -478,3 +478,3 @@\n-\t# cfi_startproc\n-\t_CET_ENDBR\n-\tsubl\t$closure_FS, %esp\n+        # cfi_startproc\n+        _CET_ENDBR\n+        subl    $closure_FS, %esp\n@@ -482,1 +482,1 @@\n-\t# cfi_def_cfa_offset(closure_FS + 4)\n+        # cfi_def_cfa_offset(closure_FS + 4)\n@@ -484,1 +484,1 @@\n-\tFFI_CLOSURE_SAVE_REGS\n+        FFI_CLOSURE_SAVE_REGS\n@@ -486,1 +486,1 @@\n-\t\/* Entry point from ffi_closure_REGISTER.  *\/\n+        \/* Entry point from ffi_closure_REGISTER.  *\/\n@@ -489,1 +489,1 @@\n-\tFFI_CLOSURE_COPY_TRAMP_DATA\n+        FFI_CLOSURE_COPY_TRAMP_DATA\n@@ -491,1 +491,1 @@\n-\t\/* Entry point from preceeding Go closure.  *\/\n+        \/* Entry point from preceeding Go closure.  *\/\n@@ -494,2 +494,2 @@\n-\tFFI_CLOSURE_PREP_CALL\n-\tFFI_CLOSURE_CALL_INNER(29)\n+        FFI_CLOSURE_PREP_CALL\n+        FFI_CLOSURE_CALL_INNER(29)\n@@ -497,5 +497,5 @@\n-\tmovl\t%eax, %ecx\n-\tshrl\t$X86_RET_POP_SHIFT, %ecx\t\/* isolate pop count *\/\n-\tleal\tclosure_FS(%esp, %ecx), %ecx\t\/* compute popped esp *\/\n-\tmovl\tclosure_FS(%esp), %edx\t\t\/* move return address *\/\n-\tmovl\t%edx, (%ecx)\n+        movl    %eax, %ecx\n+        shrl    $X86_RET_POP_SHIFT, %ecx        \/* isolate pop count *\/\n+        leal    closure_FS(%esp, %ecx), %ecx    \/* compute popped esp *\/\n+        movl    closure_FS(%esp), %edx          \/* move return address *\/\n+        movl    %edx, (%ecx)\n@@ -503,5 +503,5 @@\n-\t\/* From this point on, the value of %esp upon return is %ecx+4,\n-\t   and we've copied the return address to %ecx to make return easy.\n-\t   There's no point in representing this in the unwind info, as\n-\t   there is always a window between the mov and the ret which\n-\t   will be wrong from one point of view or another.  *\/\n+        \/* From this point on, the value of %esp upon return is %ecx+4,\n+           and we've copied the return address to %ecx to make return easy.\n+           There's no point in representing this in the unwind info, as\n+           there is always a window between the mov and the ret which\n+           will be wrong from one point of view or another.  *\/\n@@ -509,1 +509,1 @@\n-\tFFI_CLOSURE_MASK_AND_JUMP(3, 30)\n+        FFI_CLOSURE_MASK_AND_JUMP(3, 30)\n@@ -511,1 +511,1 @@\n-\t.balign\t8\n+        .balign 8\n@@ -514,3 +514,3 @@\n-\tflds    closure_CF(%esp)\n-\tmovl    %ecx, %esp\n-\tret\n+        flds    closure_CF(%esp)\n+        movl    %ecx, %esp\n+        ret\n@@ -518,3 +518,3 @@\n-\tfldl    closure_CF(%esp)\n-\tmovl    %ecx, %esp\n-\tret\n+        fldl    closure_CF(%esp)\n+        movl    %ecx, %esp\n+        ret\n@@ -522,3 +522,3 @@\n-\tfldt    closure_CF(%esp)\n-\tmovl    %ecx, %esp\n-\tret\n+        fldt    closure_CF(%esp)\n+        movl    %ecx, %esp\n+        ret\n@@ -526,3 +526,3 @@\n-\tmovsbl  %al, %eax\n-\tmovl    %ecx, %esp\n-\tret\n+        movsbl  %al, %eax\n+        movl    %ecx, %esp\n+        ret\n@@ -530,3 +530,3 @@\n-\tmovswl  %ax, %eax\n-\tmovl    %ecx, %esp\n-\tret\n+        movswl  %ax, %eax\n+        movl    %ecx, %esp\n+        ret\n@@ -534,3 +534,3 @@\n-\tmovzbl  %al, %eax\n-\tmovl    %ecx, %esp\n-\tret\n+        movzbl  %al, %eax\n+        movl    %ecx, %esp\n+        ret\n@@ -538,3 +538,3 @@\n-\tmovzwl  %ax, %eax\n-\tmovl    %ecx, %esp\n-\tret\n+        movzwl  %ax, %eax\n+        movl    %ecx, %esp\n+        ret\n@@ -542,3 +542,3 @@\n-\tmovl\tclosure_CF+4(%esp), %edx\n-\tmovl    %ecx, %esp\n-\tret\n+        movl    closure_CF+4(%esp), %edx\n+        movl    %ecx, %esp\n+        ret\n@@ -546,2 +546,2 @@\n-\tmovl    %ecx, %esp\n-\tret\n+        movl    %ecx, %esp\n+        ret\n@@ -549,2 +549,2 @@\n-\tmovl    %ecx, %esp\n-\tret\n+        movl    %ecx, %esp\n+        ret\n@@ -552,2 +552,2 @@\n-\tmovl    %ecx, %esp\n-\tret\n+        movl    %ecx, %esp\n+        ret\n@@ -555,2 +555,2 @@\n-\tmovl\t%ecx, %esp\n-\tret\n+        movl    %ecx, %esp\n+        ret\n@@ -558,3 +558,3 @@\n-\tmovzbl\t%al, %eax\n-\tmovl\t%ecx, %esp\n-\tret\n+        movzbl  %al, %eax\n+        movl    %ecx, %esp\n+        ret\n@@ -562,3 +562,3 @@\n-\tmovzwl\t%ax, %eax\n-\tmovl\t%ecx, %esp\n-\tret\n+        movzwl  %ax, %eax\n+        movl    %ecx, %esp\n+        ret\n@@ -566,1 +566,1 @@\n-\t\/* Fill out the table so that bad values are predictable.  *\/\n+        \/* Fill out the table so that bad values are predictable.  *\/\n@@ -568,1 +568,1 @@\n-\tud2\n+        ud2\n@@ -570,1 +570,1 @@\n-\tud2\n+        ud2\n@@ -573,1 +573,1 @@\n-\t# cfi_endproc\n+        # cfi_endproc\n@@ -576,0 +576,88 @@\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+        .balign 16\n+        .globl  C(ffi_closure_i386_alt)\n+        FFI_HIDDEN(C(ffi_closure_i386_alt))\n+C(ffi_closure_i386_alt):\n+        \/* See the comments above trampoline_code_table. *\/\n+        _CET_ENDBR\n+        movl    4(%esp), %eax                   \/* Load closure in eax *\/\n+        add     $8, %esp                        \/* Restore the stack *\/\n+        jmp     C(ffi_closure_i386)\n+ENDF(C(ffi_closure_i386_alt))\n+\n+        .balign 16\n+        .globl  C(ffi_closure_REGISTER_alt)\n+        FFI_HIDDEN(C(ffi_closure_REGISTER_alt))\n+C(ffi_closure_REGISTER_alt):\n+        \/* See the comments above trampoline_code_table. *\/\n+        _CET_ENDBR\n+        movl    (%esp), %eax                    \/* Restore eax *\/\n+        add     $4, %esp                        \/* Leave closure on stack *\/\n+        jmp     C(ffi_closure_REGISTER)\n+ENDF(C(ffi_closure_REGISTER_alt))\n+\n+        .balign 16\n+        .globl  C(ffi_closure_STDCALL_alt)\n+        FFI_HIDDEN(C(ffi_closure_STDCALL_alt))\n+C(ffi_closure_STDCALL_alt):\n+        \/* See the comments above trampoline_code_table. *\/\n+        _CET_ENDBR\n+        movl    4(%esp), %eax                   \/* Load closure in eax *\/\n+        add     $8, %esp                        \/* Restore the stack *\/\n+        jmp     C(ffi_closure_STDCALL)\n+ENDF(C(ffi_closure_STDCALL_alt))\n+\n+\/*\n+ * Below is the definition of the trampoline code table. Each element in\n+ * the code table is a trampoline.\n+ *\n+ * Because we jump to the trampoline, we place a _CET_ENDBR at the\n+ * beginning of the trampoline to mark it as a valid branch target. This is\n+ * part of the the Intel CET (Control Flow Enforcement Technology).\n+ *\/\n+\/*\n+ * The trampoline uses register eax.  It saves the original value of eax on\n+ * the stack.\n+ *\n+ * The trampoline has two parameters - target code to jump to and data for\n+ * the target code. The trampoline extracts the parameters from its parameter\n+ * block (see tramp_table_map()). The trampoline saves the data address on\n+ * the stack. Finally, it jumps to the target code.\n+ *\n+ * The target code can choose to:\n+ *\n+ * - restore the value of eax\n+ * - load the data address in a register\n+ * - restore the stack pointer to what it was when the trampoline was invoked.\n+ *\/\n+#ifdef ENDBR_PRESENT\n+#define X86_DATA_OFFSET         4081\n+#define X86_CODE_OFFSET         4070\n+#else\n+#define X86_DATA_OFFSET         4085\n+#define X86_CODE_OFFSET         4074\n+#endif\n+\n+        .align  X86_TRAMP_MAP_SIZE\n+        .globl  C(trampoline_code_table)\n+        FFI_HIDDEN(C(trampoline_code_table))\n+C(trampoline_code_table):\n+        .rept   X86_TRAMP_MAP_SIZE \/ X86_TRAMP_SIZE\n+        _CET_ENDBR\n+        sub     $8, %esp\n+        movl    %eax, (%esp)                    \/* Save %eax on stack *\/\n+        call    1f                              \/* Get next PC into %eax *\/\n+        movl    X86_DATA_OFFSET(%eax), %eax     \/* Copy data into %eax *\/\n+        movl    %eax, 4(%esp)                   \/* Save data on stack *\/\n+        call    1f                              \/* Get next PC into %eax *\/\n+        movl    X86_CODE_OFFSET(%eax), %eax     \/* Copy code into %eax *\/\n+        jmp     *%eax                           \/* Jump to code *\/\n+1:\n+        mov     (%esp), %eax\n+        ret\n+        .align  4\n+        .endr\n+ENDF(C(trampoline_code_table))\n+        .align  X86_TRAMP_MAP_SIZE\n+#endif \/* FFI_EXEC_STATIC_TRAMP *\/\n+\n@@ -578,1 +666,1 @@\n-#define raw_closure_S_FS\t(16+16+12)\n+#define raw_closure_S_FS        (16+16+12)\n@@ -580,3 +668,3 @@\n-\t.balign\t16\n-\t.globl\tC(ffi_closure_raw_SYSV)\n-\tFFI_HIDDEN(C(ffi_closure_raw_SYSV))\n+        .balign 16\n+        .globl  C(ffi_closure_raw_SYSV)\n+        FFI_HIDDEN(C(ffi_closure_raw_SYSV))\n@@ -585,3 +673,3 @@\n-\t# cfi_startproc\n-\t_CET_ENDBR\n-\tsubl\t$raw_closure_S_FS, %esp\n+        # cfi_startproc\n+        _CET_ENDBR\n+        subl    $raw_closure_S_FS, %esp\n@@ -589,2 +677,2 @@\n-\t# cfi_def_cfa_offset(raw_closure_S_FS + 4)\n-\tmovl\t%ebx, raw_closure_S_FS-4(%esp)\n+        # cfi_def_cfa_offset(raw_closure_S_FS + 4)\n+        movl    %ebx, raw_closure_S_FS-4(%esp)\n@@ -592,14 +680,14 @@\n-\t# cfi_rel_offset(%ebx, raw_closure_S_FS-4)\n-\n-\tmovl\tFFI_TRAMPOLINE_SIZE+8(%eax), %edx\t\/* load cl->user_data *\/\n-\tmovl\t%edx, 12(%esp)\n-\tleal\traw_closure_S_FS+4(%esp), %edx\t\t\/* load raw_args *\/\n-\tmovl\t%edx, 8(%esp)\n-\tleal\t16(%esp), %edx\t\t\t\t\/* load &res *\/\n-\tmovl\t%edx, 4(%esp)\n-\tmovl\tFFI_TRAMPOLINE_SIZE(%eax), %ebx\t\t\/* load cl->cif *\/\n-\tmovl\t%ebx, (%esp)\n-\tcall\t*FFI_TRAMPOLINE_SIZE+4(%eax)\t\t\/* call cl->fun *\/\n-\n-\tmovl\t20(%ebx), %eax\t\t\t\t\/* load cif->flags *\/\n-\tandl\t$X86_RET_TYPE_MASK, %eax\n+        # cfi_rel_offset(%ebx, raw_closure_S_FS-4)\n+\n+        movl    FFI_TRAMPOLINE_SIZE+8(%eax), %edx       \/* load cl->user_data *\/\n+        movl    %edx, 12(%esp)\n+        leal    raw_closure_S_FS+4(%esp), %edx          \/* load raw_args *\/\n+        movl    %edx, 8(%esp)\n+        leal    16(%esp), %edx                          \/* load &res *\/\n+        movl    %edx, 4(%esp)\n+        movl    FFI_TRAMPOLINE_SIZE(%eax), %ebx         \/* load cl->cif *\/\n+        movl    %ebx, (%esp)\n+        call    *FFI_TRAMPOLINE_SIZE+4(%eax)            \/* call cl->fun *\/\n+\n+        movl    20(%ebx), %eax                          \/* load cif->flags *\/\n+        andl    $X86_RET_TYPE_MASK, %eax\n@@ -607,1 +695,1 @@\n-\tcall\tC(__x86.get_pc_thunk.bx)\n+        call    C(__x86.get_pc_thunk.bx)\n@@ -609,1 +697,1 @@\n-\tleal\tL(load_table4)-L(pc4)(%ebx, %eax, 8), %ecx\n+        leal    L(load_table4)-L(pc4)(%ebx, %eax, 8), %ecx\n@@ -611,1 +699,1 @@\n-\tleal\tL(load_table4)(,%eax, 8), %ecx\n+        leal    L(load_table4)(,%eax, 8), %ecx\n@@ -613,1 +701,1 @@\n-\tmovl\traw_closure_S_FS-4(%esp), %ebx\n+        movl    raw_closure_S_FS-4(%esp), %ebx\n@@ -615,3 +703,3 @@\n-\t# cfi_restore(%ebx)\n-\tmovl\t16(%esp), %eax\t\t\t\t\/* Optimistic load *\/\n-\tjmp\t*%ecx\n+        # cfi_restore(%ebx)\n+        movl    16(%esp), %eax                          \/* Optimistic load *\/\n+        jmp     *%ecx\n@@ -619,1 +707,1 @@\n-\t.balign\t8\n+        .balign 8\n@@ -622,2 +710,2 @@\n-\tflds\t16(%esp)\n-\tjmp\tL(e4)\n+        flds    16(%esp)\n+        jmp     L(e4)\n@@ -625,2 +713,2 @@\n-\tfldl\t16(%esp)\n-\tjmp\tL(e4)\n+        fldl    16(%esp)\n+        jmp     L(e4)\n@@ -628,2 +716,2 @@\n-\tfldt\t16(%esp)\n-\tjmp\tL(e4)\n+        fldt    16(%esp)\n+        jmp     L(e4)\n@@ -631,2 +719,2 @@\n-\tmovsbl\t%al, %eax\n-\tjmp\tL(e4)\n+        movsbl  %al, %eax\n+        jmp     L(e4)\n@@ -634,2 +722,2 @@\n-\tmovswl\t%ax, %eax\n-\tjmp\tL(e4)\n+        movswl  %ax, %eax\n+        jmp     L(e4)\n@@ -637,2 +725,2 @@\n-\tmovzbl\t%al, %eax\n-\tjmp\tL(e4)\n+        movzbl  %al, %eax\n+        jmp     L(e4)\n@@ -640,2 +728,2 @@\n-\tmovzwl\t%ax, %eax\n-\tjmp\tL(e4)\n+        movzwl  %ax, %eax\n+        jmp     L(e4)\n@@ -643,2 +731,2 @@\n-\tmovl\t16+4(%esp), %edx\n-\tjmp\tL(e4)\n+        movl    16+4(%esp), %edx\n+        jmp     L(e4)\n@@ -646,2 +734,2 @@\n-\tnop\n-\t\/* fallthru *\/\n+        nop\n+        \/* fallthru *\/\n@@ -650,1 +738,1 @@\n-\taddl\t$raw_closure_S_FS, %esp\n+        addl    $raw_closure_S_FS, %esp\n@@ -652,2 +740,2 @@\n-\t# cfi_adjust_cfa_offset(-raw_closure_S_FS)\n-\tret\n+        # cfi_adjust_cfa_offset(-raw_closure_S_FS)\n+        ret\n@@ -655,1 +743,1 @@\n-\t# cfi_adjust_cfa_offset(raw_closure_S_FS)\n+        # cfi_adjust_cfa_offset(raw_closure_S_FS)\n@@ -657,1 +745,1 @@\n-\taddl\t$raw_closure_S_FS, %esp\n+        addl    $raw_closure_S_FS, %esp\n@@ -659,2 +747,2 @@\n-\t# cfi_adjust_cfa_offset(-raw_closure_S_FS)\n-\tret\t$4\n+        # cfi_adjust_cfa_offset(-raw_closure_S_FS)\n+        ret     $4\n@@ -662,1 +750,1 @@\n-\t# cfi_adjust_cfa_offset(raw_closure_S_FS)\n+        # cfi_adjust_cfa_offset(raw_closure_S_FS)\n@@ -664,1 +752,1 @@\n-\tjmp\tL(e4)\n+        jmp     L(e4)\n@@ -666,2 +754,2 @@\n-\tmovzbl\t%al, %eax\n-\tjmp\tL(e4)\n+        movzbl  %al, %eax\n+        jmp     L(e4)\n@@ -669,2 +757,2 @@\n-\tmovzwl\t%ax, %eax\n-\tjmp\tL(e4)\n+        movzwl  %ax, %eax\n+        jmp     L(e4)\n@@ -672,1 +760,1 @@\n-\t\/* Fill out the table so that bad values are predictable.  *\/\n+        \/* Fill out the table so that bad values are predictable.  *\/\n@@ -674,1 +762,1 @@\n-\tud2\n+        ud2\n@@ -676,1 +764,1 @@\n-\tud2\n+        ud2\n@@ -679,1 +767,1 @@\n-\t# cfi_endproc\n+        # cfi_endproc\n@@ -682,1 +770,1 @@\n-#define raw_closure_T_FS\t(16+16+8)\n+#define raw_closure_T_FS        (16+16+8)\n@@ -684,3 +772,3 @@\n-\t.balign\t16\n-\t.globl\tC(ffi_closure_raw_THISCALL)\n-\tFFI_HIDDEN(C(ffi_closure_raw_THISCALL))\n+        .balign 16\n+        .globl  C(ffi_closure_raw_THISCALL)\n+        FFI_HIDDEN(C(ffi_closure_raw_THISCALL))\n@@ -689,5 +777,5 @@\n-\t# cfi_startproc\n-\t_CET_ENDBR\n-\t\/* Rearrange the stack such that %ecx is the first argument.\n-\t   This means moving the return address.  *\/\n-\tpopl\t%edx\n+        # cfi_startproc\n+        _CET_ENDBR\n+        \/* Rearrange the stack such that %ecx is the first argument.\n+           This means moving the return address.  *\/\n+        popl    %edx\n@@ -695,3 +783,3 @@\n-\t# cfi_def_cfa_offset(0)\n-\t# cfi_register(%eip, %edx)\n-\tpushl\t%ecx\n+        # cfi_def_cfa_offset(0)\n+        # cfi_register(%eip, %edx)\n+        pushl   %ecx\n@@ -699,2 +787,2 @@\n-\t# cfi_adjust_cfa_offset(4)\n-\tpushl\t%edx\n+        # cfi_adjust_cfa_offset(4)\n+        pushl   %edx\n@@ -702,3 +790,3 @@\n-\t# cfi_adjust_cfa_offset(4)\n-\t# cfi_rel_offset(%eip, 0)\n-\tsubl\t$raw_closure_T_FS, %esp\n+        # cfi_adjust_cfa_offset(4)\n+        # cfi_rel_offset(%eip, 0)\n+        subl    $raw_closure_T_FS, %esp\n@@ -706,2 +794,2 @@\n-\t# cfi_adjust_cfa_offset(raw_closure_T_FS)\n-\tmovl\t%ebx, raw_closure_T_FS-4(%esp)\n+        # cfi_adjust_cfa_offset(raw_closure_T_FS)\n+        movl    %ebx, raw_closure_T_FS-4(%esp)\n@@ -709,14 +797,14 @@\n-\t# cfi_rel_offset(%ebx, raw_closure_T_FS-4)\n-\n-\tmovl\tFFI_TRAMPOLINE_SIZE+8(%eax), %edx\t\/* load cl->user_data *\/\n-\tmovl\t%edx, 12(%esp)\n-\tleal\traw_closure_T_FS+4(%esp), %edx\t\t\/* load raw_args *\/\n-\tmovl\t%edx, 8(%esp)\n-\tleal\t16(%esp), %edx\t\t\t\t\/* load &res *\/\n-\tmovl\t%edx, 4(%esp)\n-\tmovl\tFFI_TRAMPOLINE_SIZE(%eax), %ebx\t\t\/* load cl->cif *\/\n-\tmovl\t%ebx, (%esp)\n-\tcall\t*FFI_TRAMPOLINE_SIZE+4(%eax)\t\t\/* call cl->fun *\/\n-\n-\tmovl\t20(%ebx), %eax\t\t\t\t\/* load cif->flags *\/\n-\tandl\t$X86_RET_TYPE_MASK, %eax\n+        # cfi_rel_offset(%ebx, raw_closure_T_FS-4)\n+\n+        movl    FFI_TRAMPOLINE_SIZE+8(%eax), %edx       \/* load cl->user_data *\/\n+        movl    %edx, 12(%esp)\n+        leal    raw_closure_T_FS+4(%esp), %edx          \/* load raw_args *\/\n+        movl    %edx, 8(%esp)\n+        leal    16(%esp), %edx                          \/* load &res *\/\n+        movl    %edx, 4(%esp)\n+        movl    FFI_TRAMPOLINE_SIZE(%eax), %ebx         \/* load cl->cif *\/\n+        movl    %ebx, (%esp)\n+        call    *FFI_TRAMPOLINE_SIZE+4(%eax)            \/* call cl->fun *\/\n+\n+        movl    20(%ebx), %eax                          \/* load cif->flags *\/\n+        andl    $X86_RET_TYPE_MASK, %eax\n@@ -724,1 +812,1 @@\n-\tcall\tC(__x86.get_pc_thunk.bx)\n+        call    C(__x86.get_pc_thunk.bx)\n@@ -726,1 +814,1 @@\n-\tleal\tL(load_table5)-L(pc5)(%ebx, %eax, 8), %ecx\n+        leal    L(load_table5)-L(pc5)(%ebx, %eax, 8), %ecx\n@@ -728,1 +816,1 @@\n-\tleal\tL(load_table5)(,%eax, 8), %ecx\n+        leal    L(load_table5)(,%eax, 8), %ecx\n@@ -730,1 +818,1 @@\n-\tmovl\traw_closure_T_FS-4(%esp), %ebx\n+        movl    raw_closure_T_FS-4(%esp), %ebx\n@@ -732,3 +820,3 @@\n-\t# cfi_restore(%ebx)\n-\tmovl\t16(%esp), %eax\t\t\t\t\/* Optimistic load *\/\n-\tjmp\t*%ecx\n+        # cfi_restore(%ebx)\n+        movl    16(%esp), %eax                          \/* Optimistic load *\/\n+        jmp     *%ecx\n@@ -736,1 +824,1 @@\n-\t.balign\t8\n+        .balign 8\n@@ -739,2 +827,2 @@\n-\tflds\t16(%esp)\n-\tjmp\tL(e5)\n+        flds    16(%esp)\n+        jmp     L(e5)\n@@ -742,2 +830,2 @@\n-\tfldl\t16(%esp)\n-\tjmp\tL(e5)\n+        fldl    16(%esp)\n+        jmp     L(e5)\n@@ -745,2 +833,2 @@\n-\tfldt\t16(%esp)\n-\tjmp\tL(e5)\n+        fldt    16(%esp)\n+        jmp     L(e5)\n@@ -748,2 +836,2 @@\n-\tmovsbl\t%al, %eax\n-\tjmp\tL(e5)\n+        movsbl  %al, %eax\n+        jmp     L(e5)\n@@ -751,2 +839,2 @@\n-\tmovswl\t%ax, %eax\n-\tjmp\tL(e5)\n+        movswl  %ax, %eax\n+        jmp     L(e5)\n@@ -754,2 +842,2 @@\n-\tmovzbl\t%al, %eax\n-\tjmp\tL(e5)\n+        movzbl  %al, %eax\n+        jmp     L(e5)\n@@ -757,2 +845,2 @@\n-\tmovzwl\t%ax, %eax\n-\tjmp\tL(e5)\n+        movzwl  %ax, %eax\n+        jmp     L(e5)\n@@ -760,2 +848,2 @@\n-\tmovl\t16+4(%esp), %edx\n-\tjmp\tL(e5)\n+        movl    16+4(%esp), %edx\n+        jmp     L(e5)\n@@ -763,2 +851,2 @@\n-\tnop\n-\t\/* fallthru *\/\n+        nop\n+        \/* fallthru *\/\n@@ -767,1 +855,1 @@\n-\taddl\t$raw_closure_T_FS, %esp\n+        addl    $raw_closure_T_FS, %esp\n@@ -769,3 +857,3 @@\n-\t# cfi_adjust_cfa_offset(-raw_closure_T_FS)\n-\t\/* Remove the extra %ecx argument we pushed.  *\/\n-\tret\t$4\n+        # cfi_adjust_cfa_offset(-raw_closure_T_FS)\n+        \/* Remove the extra %ecx argument we pushed.  *\/\n+        ret     $4\n@@ -773,1 +861,1 @@\n-\t# cfi_adjust_cfa_offset(raw_closure_T_FS)\n+        # cfi_adjust_cfa_offset(raw_closure_T_FS)\n@@ -775,1 +863,1 @@\n-\taddl\t$raw_closure_T_FS, %esp\n+        addl    $raw_closure_T_FS, %esp\n@@ -777,2 +865,2 @@\n-\t# cfi_adjust_cfa_offset(-raw_closure_T_FS)\n-\tret\t$8\n+        # cfi_adjust_cfa_offset(-raw_closure_T_FS)\n+        ret     $8\n@@ -780,1 +868,1 @@\n-\t# cfi_adjust_cfa_offset(raw_closure_T_FS)\n+        # cfi_adjust_cfa_offset(raw_closure_T_FS)\n@@ -782,1 +870,1 @@\n-\tjmp\tL(e5)\n+        jmp     L(e5)\n@@ -784,2 +872,2 @@\n-\tmovzbl\t%al, %eax\n-\tjmp\tL(e5)\n+        movzbl  %al, %eax\n+        jmp     L(e5)\n@@ -787,2 +875,2 @@\n-\tmovzwl\t%ax, %eax\n-\tjmp\tL(e5)\n+        movzwl  %ax, %eax\n+        jmp     L(e5)\n@@ -790,1 +878,1 @@\n-\t\/* Fill out the table so that bad values are predictable.  *\/\n+        \/* Fill out the table so that bad values are predictable.  *\/\n@@ -792,1 +880,1 @@\n-\tud2\n+        ud2\n@@ -794,1 +882,1 @@\n-\tud2\n+        ud2\n@@ -797,1 +885,1 @@\n-\t# cfi_endproc\n+        # cfi_endproc\n@@ -803,3 +891,3 @@\n-# define COMDAT(X)\t\t\t\t\t\t\t\\\n-        .section __TEXT,__text,coalesced,pure_instructions;\t\t\\\n-        .weak_definition X;\t\t\t\t\t\t\\\n+# define COMDAT(X)                                                      \\\n+        .section __TEXT,__text,coalesced,pure_instructions;             \\\n+        .weak_definition X;                                             \\\n@@ -808,4 +896,4 @@\n-# define COMDAT(X)\t\t\t\t\t\t\t\\\n-\t.section .text.X,\"axG\",@progbits,X,comdat;\t\t\t\\\n-\t.globl\tX;\t\t\t\t\t\t\t\\\n-\tFFI_HIDDEN(X)\n+# define COMDAT(X)                                                      \\\n+        .section .text.X,\"axG\",@progbits,X,comdat;                      \\\n+        .globl  X;                                                      \\\n+        FFI_HIDDEN(X)\n@@ -817,1 +905,1 @@\n-\tCOMDAT(C(__x86.get_pc_thunk.bx))\n+        COMDAT(C(__x86.get_pc_thunk.bx))\n@@ -819,2 +907,2 @@\n-\tmovl\t(%esp), %ebx\n-\tret\n+        movl    (%esp), %ebx\n+        ret\n@@ -823,1 +911,1 @@\n-\tCOMDAT(C(__x86.get_pc_thunk.dx))\n+        COMDAT(C(__x86.get_pc_thunk.dx))\n@@ -825,2 +913,2 @@\n-\tmovl\t(%esp), %edx\n-\tret\n+        movl    (%esp), %edx\n+        ret\n@@ -845,1 +933,1 @@\n-# define PCREL(X)\tX - .\n+# define PCREL(X)       X - .\n@@ -847,1 +935,1 @@\n-# define PCREL(X)\tX@rel\n+# define PCREL(X)       X@rel\n@@ -851,1 +939,1 @@\n-#define ADV(N, P)\t.byte 2, L(N)-L(P)\n+#define ADV(N, P)       .byte 2, L(N)-L(P)\n@@ -853,1 +941,1 @@\n-\t.balign 4\n+        .balign 4\n@@ -855,2 +943,2 @@\n-\t.set\tL(set0),L(ECIE)-L(SCIE)\n-\t.long\tL(set0)\t\t\t\/* CIE Length *\/\n+        .set    L(set0),L(ECIE)-L(SCIE)\n+        .long   L(set0)                 \/* CIE Length *\/\n@@ -858,11 +946,11 @@\n-\t.long\t0\t\t\t\/* CIE Identifier Tag *\/\n-\t.byte\t1\t\t\t\/* CIE Version *\/\n-\t.ascii\t\"zR\\0\"\t\t\t\/* CIE Augmentation *\/\n-\t.byte\t1\t\t\t\/* CIE Code Alignment Factor *\/\n-\t.byte\t0x7c\t\t\t\/* CIE Data Alignment Factor *\/\n-\t.byte\t0x8\t\t\t\/* CIE RA Column *\/\n-\t.byte\t1\t\t\t\/* Augmentation size *\/\n-\t.byte\t0x1b\t\t\t\/* FDE Encoding (pcrel sdata4) *\/\n-\t.byte\t0xc, 4, 4\t\t\/* DW_CFA_def_cfa, %esp offset 4 *\/\n-\t.byte\t0x80+8, 1\t\t\/* DW_CFA_offset, %eip offset 1*-4 *\/\n-\t.balign 4\n+        .long   0                       \/* CIE Identifier Tag *\/\n+        .byte   1                       \/* CIE Version *\/\n+        .ascii  \"zR\\0\"                  \/* CIE Augmentation *\/\n+        .byte   1                       \/* CIE Code Alignment Factor *\/\n+        .byte   0x7c                    \/* CIE Data Alignment Factor *\/\n+        .byte   0x8                     \/* CIE RA Column *\/\n+        .byte   1                       \/* Augmentation size *\/\n+        .byte   0x1b                    \/* FDE Encoding (pcrel sdata4) *\/\n+        .byte   0xc, 4, 4               \/* DW_CFA_def_cfa, %esp offset 4 *\/\n+        .byte   0x80+8, 1               \/* DW_CFA_offset, %eip offset 1*-4 *\/\n+        .balign 4\n@@ -871,2 +959,2 @@\n-\t.set\tL(set1),L(EFDE1)-L(SFDE1)\n-\t.long\tL(set1)\t\t\t\/* FDE Length *\/\n+        .set    L(set1),L(EFDE1)-L(SFDE1)\n+        .long   L(set1)                 \/* FDE Length *\/\n@@ -874,17 +962,17 @@\n-\t.long\tL(SFDE1)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW0))\t\t\/* Initial location *\/\n-\t.long\tL(UW5)-L(UW0)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW1, UW0)\n-\t.byte\t0xc, 5, 8\t\t\/* DW_CFA_def_cfa, %ebp 8 *\/\n-\t.byte\t0x80+5, 2\t\t\/* DW_CFA_offset, %ebp 2*-4 *\/\n-\tADV(UW2, UW1)\n-\t.byte\t0x80+3, 0\t\t\/* DW_CFA_offset, %ebx 0*-4 *\/\n-\tADV(UW3, UW2)\n-\t.byte\t0xa\t\t\t\/* DW_CFA_remember_state *\/\n-\t.byte\t0xc, 4, 4\t\t\/* DW_CFA_def_cfa, %esp 4 *\/\n-\t.byte\t0xc0+3\t\t\t\/* DW_CFA_restore, %ebx *\/\n-\t.byte\t0xc0+5\t\t\t\/* DW_CFA_restore, %ebp *\/\n-\tADV(UW4, UW3)\n-\t.byte\t0xb\t\t\t\/* DW_CFA_restore_state *\/\n-\t.balign\t4\n+        .long   L(SFDE1)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW0))           \/* Initial location *\/\n+        .long   L(UW5)-L(UW0)           \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW1, UW0)\n+        .byte   0xc, 5, 8               \/* DW_CFA_def_cfa, %ebp 8 *\/\n+        .byte   0x80+5, 2               \/* DW_CFA_offset, %ebp 2*-4 *\/\n+        ADV(UW2, UW1)\n+        .byte   0x80+3, 0               \/* DW_CFA_offset, %ebx 0*-4 *\/\n+        ADV(UW3, UW2)\n+        .byte   0xa                     \/* DW_CFA_remember_state *\/\n+        .byte   0xc, 4, 4               \/* DW_CFA_def_cfa, %esp 4 *\/\n+        .byte   0xc0+3                  \/* DW_CFA_restore, %ebx *\/\n+        .byte   0xc0+5                  \/* DW_CFA_restore, %ebp *\/\n+        ADV(UW4, UW3)\n+        .byte   0xb                     \/* DW_CFA_restore_state *\/\n+        .balign 4\n@@ -893,2 +981,2 @@\n-\t.set\tL(set2),L(EFDE2)-L(SFDE2)\n-\t.long\tL(set2)\t\t\t\/* FDE Length *\/\n+        .set    L(set2),L(EFDE2)-L(SFDE2)\n+        .long   L(set2)                 \/* FDE Length *\/\n@@ -896,7 +984,7 @@\n-\t.long\tL(SFDE2)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW6))\t\t\/* Initial location *\/\n-\t.long\tL(UW8)-L(UW6)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW7, UW6)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .long   L(SFDE2)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW6))           \/* Initial location *\/\n+        .long   L(UW8)-L(UW6)           \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW7, UW6)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -905,2 +993,2 @@\n-\t.set\tL(set3),L(EFDE3)-L(SFDE3)\n-\t.long\tL(set3)\t\t\t\/* FDE Length *\/\n+        .set    L(set3),L(EFDE3)-L(SFDE3)\n+        .long   L(set3)                 \/* FDE Length *\/\n@@ -908,7 +996,7 @@\n-\t.long\tL(SFDE3)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW9))\t\t\/* Initial location *\/\n-\t.long\tL(UW11)-L(UW9)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW10, UW9)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .long   L(SFDE3)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW9))           \/* Initial location *\/\n+        .long   L(UW11)-L(UW9)          \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW10, UW9)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -917,2 +1005,2 @@\n-\t.set\tL(set4),L(EFDE4)-L(SFDE4)\n-\t.long\tL(set4)\t\t\t\/* FDE Length *\/\n+        .set    L(set4),L(EFDE4)-L(SFDE4)\n+        .long   L(set4)                 \/* FDE Length *\/\n@@ -920,6 +1008,6 @@\n-\t.long\tL(SFDE4)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW12))\t\t\/* Initial location *\/\n-\t.long\tL(UW20)-L(UW12)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW13, UW12)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n+        .long   L(SFDE4)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW12))          \/* Initial location *\/\n+        .long   L(UW20)-L(UW12)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW13, UW12)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n@@ -927,5 +1015,5 @@\n-\tADV(UW14, UW13)\n-\t.byte\t0x80+3, (40-(closure_FS+4))\/-4  \/* DW_CFA_offset %ebx *\/\n-\tADV(UW15, UW14)\n-\t.byte\t0xc0+3\t\t\t\/* DW_CFA_restore %ebx *\/\n-\tADV(UW16, UW15)\n+        ADV(UW14, UW13)\n+        .byte   0x80+3, (40-(closure_FS+4))\/-4  \/* DW_CFA_offset %ebx *\/\n+        ADV(UW15, UW14)\n+        .byte   0xc0+3                  \/* DW_CFA_restore %ebx *\/\n+        ADV(UW16, UW15)\n@@ -933,1 +1021,1 @@\n-\tADV(UW16, UW13)\n+        ADV(UW16, UW13)\n@@ -935,8 +1023,8 @@\n-\t.byte\t0xe, 4\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW17, UW16)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW18, UW17)\n-\t.byte\t0xe, 4\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW19, UW18)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .byte   0xe, 4                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW17, UW16)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW18, UW17)\n+        .byte   0xe, 4                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW19, UW18)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -945,2 +1033,2 @@\n-\t.set\tL(set5),L(EFDE5)-L(SFDE5)\n-\t.long\tL(set5)\t\t\t\/* FDE Length *\/\n+        .set    L(set5),L(EFDE5)-L(SFDE5)\n+        .long   L(set5)                 \/* FDE Length *\/\n@@ -948,7 +1036,7 @@\n-\t.long\tL(SFDE5)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW21))\t\t\/* Initial location *\/\n-\t.long\tL(UW23)-L(UW21)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW22, UW21)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .long   L(SFDE5)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW21))          \/* Initial location *\/\n+        .long   L(UW23)-L(UW21)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW22, UW21)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -957,2 +1045,2 @@\n-\t.set\tL(set6),L(EFDE6)-L(SFDE6)\n-\t.long\tL(set6)\t\t\t\/* FDE Length *\/\n+        .set    L(set6),L(EFDE6)-L(SFDE6)\n+        .long   L(set6)                 \/* FDE Length *\/\n@@ -960,9 +1048,9 @@\n-\t.long\tL(SFDE6)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW24))\t\t\/* Initial location *\/\n-\t.long\tL(UW26)-L(UW24)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\t.byte\t0xe, 8\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\t.byte\t0x80+8, 2\t\t\/* DW_CFA_offset %eip, 2*-4 *\/\n-\tADV(UW25, UW24)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .long   L(SFDE6)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW24))          \/* Initial location *\/\n+        .long   L(UW26)-L(UW24)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        .byte   0xe, 8                  \/* DW_CFA_def_cfa_offset *\/\n+        .byte   0x80+8, 2               \/* DW_CFA_offset %eip, 2*-4 *\/\n+        ADV(UW25, UW24)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -971,2 +1059,2 @@\n-\t.set\tL(set7),L(EFDE7)-L(SFDE7)\n-\t.long\tL(set7)\t\t\t\/* FDE Length *\/\n+        .set    L(set7),L(EFDE7)-L(SFDE7)\n+        .long   L(set7)                 \/* FDE Length *\/\n@@ -974,6 +1062,6 @@\n-\t.long\tL(SFDE7)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW27))\t\t\/* Initial location *\/\n-\t.long\tL(UW31)-L(UW27)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW28, UW27)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n+        .long   L(SFDE7)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW27))          \/* Initial location *\/\n+        .long   L(UW31)-L(UW27)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW28, UW27)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n@@ -981,4 +1069,4 @@\n-\tADV(UW29, UW28)\n-\t.byte\t0x80+3, (40-(closure_FS+4))\/-4  \/* DW_CFA_offset %ebx *\/\n-\tADV(UW30, UW29)\n-\t.byte\t0xc0+3\t\t\t\/* DW_CFA_restore %ebx *\/\n+        ADV(UW29, UW28)\n+        .byte   0x80+3, (40-(closure_FS+4))\/-4  \/* DW_CFA_offset %ebx *\/\n+        ADV(UW30, UW29)\n+        .byte   0xc0+3                  \/* DW_CFA_restore %ebx *\/\n@@ -986,1 +1074,1 @@\n-\t.balign\t4\n+        .balign 4\n@@ -990,2 +1078,2 @@\n-\t.set\tL(set8),L(EFDE8)-L(SFDE8)\n-\t.long\tL(set8)\t\t\t\/* FDE Length *\/\n+        .set    L(set8),L(EFDE8)-L(SFDE8)\n+        .long   L(set8)                 \/* FDE Length *\/\n@@ -993,19 +1081,19 @@\n-\t.long\tL(SFDE8)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW32))\t\t\/* Initial location *\/\n-\t.long\tL(UW40)-L(UW32)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW33, UW32)\n-\t.byte\t0xe, raw_closure_S_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW34, UW33)\n-\t.byte\t0x80+3, 2\t\t\/* DW_CFA_offset %ebx 2*-4 *\/\n-\tADV(UW35, UW34)\n-\t.byte\t0xc0+3\t\t\t\/* DW_CFA_restore %ebx *\/\n-\tADV(UW36, UW35)\n-\t.byte\t0xe, 4\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW37, UW36)\n-\t.byte\t0xe, raw_closure_S_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW38, UW37)\n-\t.byte\t0xe, 4\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW39, UW38)\n-\t.byte\t0xe, raw_closure_S_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .long   L(SFDE8)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW32))          \/* Initial location *\/\n+        .long   L(UW40)-L(UW32)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW33, UW32)\n+        .byte   0xe, raw_closure_S_FS+4 \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW34, UW33)\n+        .byte   0x80+3, 2               \/* DW_CFA_offset %ebx 2*-4 *\/\n+        ADV(UW35, UW34)\n+        .byte   0xc0+3                  \/* DW_CFA_restore %ebx *\/\n+        ADV(UW36, UW35)\n+        .byte   0xe, 4                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW37, UW36)\n+        .byte   0xe, raw_closure_S_FS+4 \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW38, UW37)\n+        .byte   0xe, 4                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW39, UW38)\n+        .byte   0xe, raw_closure_S_FS+4 \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -1014,2 +1102,2 @@\n-\t.set\tL(set9),L(EFDE9)-L(SFDE9)\n-\t.long\tL(set9)\t\t\t\/* FDE Length *\/\n+        .set    L(set9),L(EFDE9)-L(SFDE9)\n+        .long   L(set9)                 \/* FDE Length *\/\n@@ -1017,27 +1105,27 @@\n-\t.long\tL(SFDE9)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW41))\t\t\/* Initial location *\/\n-\t.long\tL(UW52)-L(UW41)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW42, UW41)\n-\t.byte\t0xe, 0\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\t.byte\t0x9, 8, 2\t\t\/* DW_CFA_register %eip, %edx *\/\n-\tADV(UW43, UW42)\n-\t.byte\t0xe, 4\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW44, UW43)\n-\t.byte\t0xe, 8\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\t.byte\t0x80+8, 2\t\t\/* DW_CFA_offset %eip 2*-4 *\/\n-\tADV(UW45, UW44)\n-\t.byte\t0xe, raw_closure_T_FS+8\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW46, UW45)\n-\t.byte\t0x80+3, 3\t\t\/* DW_CFA_offset %ebx 3*-4 *\/\n-\tADV(UW47, UW46)\n-\t.byte\t0xc0+3\t\t\t\/* DW_CFA_restore %ebx *\/\n-\tADV(UW48, UW47)\n-\t.byte\t0xe, 8\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW49, UW48)\n-\t.byte\t0xe, raw_closure_T_FS+8\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW50, UW49)\n-\t.byte\t0xe, 8\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW51, UW50)\n-\t.byte\t0xe, raw_closure_T_FS+8\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .long   L(SFDE9)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW41))          \/* Initial location *\/\n+        .long   L(UW52)-L(UW41)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW42, UW41)\n+        .byte   0xe, 0                  \/* DW_CFA_def_cfa_offset *\/\n+        .byte   0x9, 8, 2               \/* DW_CFA_register %eip, %edx *\/\n+        ADV(UW43, UW42)\n+        .byte   0xe, 4                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW44, UW43)\n+        .byte   0xe, 8                  \/* DW_CFA_def_cfa_offset *\/\n+        .byte   0x80+8, 2               \/* DW_CFA_offset %eip 2*-4 *\/\n+        ADV(UW45, UW44)\n+        .byte   0xe, raw_closure_T_FS+8 \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW46, UW45)\n+        .byte   0x80+3, 3               \/* DW_CFA_offset %ebx 3*-4 *\/\n+        ADV(UW47, UW46)\n+        .byte   0xc0+3                  \/* DW_CFA_restore %ebx *\/\n+        ADV(UW48, UW47)\n+        .byte   0xe, 8                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW49, UW48)\n+        .byte   0xe, raw_closure_T_FS+8 \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW50, UW49)\n+        .byte   0xe, 8                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW51, UW50)\n+        .byte   0xe, raw_closure_T_FS+8 \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -1048,5 +1136,5 @@\n-\t.def\t @feat.00;\n-\t.scl\t3;\n-\t.type\t0;\n-\t.endef\n-\t.globl\t@feat.00\n+        .def     @feat.00;\n+        .scl    3;\n+        .type   0;\n+        .endef\n+        .globl  @feat.00\n@@ -1134,0 +1222,1 @@\n+\n@@ -1137,1 +1226,1 @@\n-\t.section\t.note.GNU-stack,\"\",@progbits\n+        .section        .note.GNU-stack,\"\",@progbits\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/x86\/sysv.S","additions":728,"deletions":639,"binary":false,"changes":1367,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-# define E(BASE, X)\tALIGN 8\n+# define E(BASE, X)     ALIGN 8\n@@ -50,1 +50,1 @@\n-# define E(BASE, X)\tALIGN 8; ORG BASE + X * 8\n+# define E(BASE, X)     ALIGN 8; ORG BASE + X * 8\n@@ -56,1 +56,1 @@\n-EXTRN\t@ffi_closure_inner@8:PROC\n+EXTRN   @ffi_closure_inner@8:PROC\n@@ -74,1 +74,1 @@\n-\tcfi_startproc\n+        cfi_startproc\n@@ -76,2 +76,2 @@\n-\tmov\t    ecx, [esp+4]\n-\tmov \tedx, [esp+8]\n+        mov         ecx, [esp+4]\n+        mov     edx, [esp+8]\n@@ -79,12 +79,12 @@\n-\tmov\t    eax, [esp]\t\t\/* move the return address *\/\n-\tmov\t    [ecx], ebp\t\t\/* store ebp into local frame *\/\n-\tmov \t[ecx+4], eax\t\/* store retaddr into local frame *\/\n-\n-\t\/* New stack frame based off ebp.  This is a itty bit of unwind\n-\t   trickery in that the CFA *has* changed.  There is no easy way\n-\t   to describe it correctly on entry to the function.  Fortunately,\n-\t   it doesn't matter too much since at all points we can correctly\n-\t   unwind back to ffi_call.  Note that the location to which we\n-\t   moved the return address is (the new) CFA-4, so from the\n-\t   perspective of the unwind info, it hasn't moved.  *\/\n-\tmov \tebp, ecx\n+        mov         eax, [esp]          \/* move the return address *\/\n+        mov         [ecx], ebp          \/* store ebp into local frame *\/\n+        mov     [ecx+4], eax    \/* store retaddr into local frame *\/\n+\n+        \/* New stack frame based off ebp.  This is a itty bit of unwind\n+           trickery in that the CFA *has* changed.  There is no easy way\n+           to describe it correctly on entry to the function.  Fortunately,\n+           it doesn't matter too much since at all points we can correctly\n+           unwind back to ffi_call.  Note that the location to which we\n+           moved the return address is (the new) CFA-4, so from the\n+           perspective of the unwind info, it hasn't moved.  *\/\n+        mov     ebp, ecx\n@@ -92,2 +92,2 @@\n-\t\/\/ cfi_def_cfa(%ebp, 8)\n-\t\/\/ cfi_rel_offset(%ebp, 0)\n+        \/\/ cfi_def_cfa(%ebp, 8)\n+        \/\/ cfi_rel_offset(%ebp, 0)\n@@ -95,4 +95,4 @@\n-\tmov \tesp, edx\t\t\/* set outgoing argument stack *\/\n-\tmov \teax, [20+R_EAX*4+ebp]\t\/* set register arguments *\/\n-\tmov \tedx, [20+R_EDX*4+ebp]\n-\tmov\t    ecx, [20+R_ECX*4+ebp]\n+        mov     esp, edx                \/* set outgoing argument stack *\/\n+        mov     eax, [20+R_EAX*4+ebp]   \/* set register arguments *\/\n+        mov     edx, [20+R_EDX*4+ebp]\n+        mov         ecx, [20+R_ECX*4+ebp]\n@@ -100,1 +100,1 @@\n-\tcall\tdword ptr [ebp+8]\n+        call    dword ptr [ebp+8]\n@@ -102,2 +102,2 @@\n-\tmov\t    ecx, [12+ebp]\t\t\/* load return type code *\/\n-\tmov \t[ebp+8], ebx\t\t\/* preserve %ebx *\/\n+        mov         ecx, [12+ebp]               \/* load return type code *\/\n+        mov     [ebp+8], ebx            \/* preserve %ebx *\/\n@@ -105,1 +105,1 @@\n-\t\/\/ cfi_rel_offset(%ebx, 8)\n+        \/\/ cfi_rel_offset(%ebx, 8)\n@@ -107,4 +107,4 @@\n-\tand \tecx, X86_RET_TYPE_MASK\n-\tlea \tebx, [L(store_table) + ecx * 8]\n-\tmov \tecx, [ebp+16]\t\t\/* load result address *\/\n-\tjmp\t    ebx\n+        and     ecx, X86_RET_TYPE_MASK\n+        lea     ebx, [L(store_table) + ecx * 8]\n+        mov     ecx, [ebp+16]           \/* load result address *\/\n+        jmp         ebx\n@@ -112,1 +112,1 @@\n-\tALIGN\t8\n+        ALIGN   8\n@@ -115,2 +115,2 @@\n-\tfstp\tDWORD PTR [ecx]\n-\tjmp\tL(e1)\n+        fstp    DWORD PTR [ecx]\n+        jmp     L(e1)\n@@ -118,2 +118,2 @@\n-\tfstp\tQWORD PTR [ecx]\n-\tjmp\tL(e1)\n+        fstp    QWORD PTR [ecx]\n+        jmp     L(e1)\n@@ -121,2 +121,2 @@\n-\tfstp\tQWORD PTR [ecx]\n-\tjmp\tL(e1)\n+        fstp    QWORD PTR [ecx]\n+        jmp     L(e1)\n@@ -124,3 +124,3 @@\n-\tmovsx\teax, al\n-\tmov\t[ecx], eax\n-\tjmp\tL(e1)\n+        movsx   eax, al\n+        mov     [ecx], eax\n+        jmp     L(e1)\n@@ -128,3 +128,3 @@\n-\tmovsx\teax, ax\n-\tmov\t[ecx], eax\n-\tjmp\tL(e1)\n+        movsx   eax, ax\n+        mov     [ecx], eax\n+        jmp     L(e1)\n@@ -132,3 +132,3 @@\n-\tmovzx\teax, al\n-\tmov\t[ecx], eax\n-\tjmp\tL(e1)\n+        movzx   eax, al\n+        mov     [ecx], eax\n+        jmp     L(e1)\n@@ -136,3 +136,3 @@\n-\tmovzx\teax, ax\n-\tmov\t[ecx], eax\n-\tjmp\tL(e1)\n+        movzx   eax, ax\n+        mov     [ecx], eax\n+        jmp     L(e1)\n@@ -140,2 +140,2 @@\n-\tmov\t[ecx+4], edx\n-\t\/* fallthru *\/\n+        mov     [ecx+4], edx\n+        \/* fallthru *\/\n@@ -143,2 +143,2 @@\n-\tmov\t[ecx], eax\n-\t\/* fallthru *\/\n+        mov     [ecx], eax\n+        \/* fallthru *\/\n@@ -147,3 +147,3 @@\n-\tmov\t    ebx, [ebp+8]\n-\tmov\t    esp, ebp\n-\tpop \tebp\n+        mov         ebx, [ebp+8]\n+        mov         esp, ebp\n+        pop     ebp\n@@ -151,5 +151,5 @@\n-\t\/\/ cfi_remember_state\n-\t\/\/ cfi_def_cfa(%esp, 4)\n-\t\/\/ cfi_restore(%ebx)\n-\t\/\/ cfi_restore(%ebp)\n-\tret\n+        \/\/ cfi_remember_state\n+        \/\/ cfi_def_cfa(%esp, 4)\n+        \/\/ cfi_restore(%ebx)\n+        \/\/ cfi_restore(%ebp)\n+        ret\n@@ -157,1 +157,1 @@\n-\t\/\/ cfi_restore_state\n+        \/\/ cfi_restore_state\n@@ -160,1 +160,1 @@\n-\tjmp\t    L(e1)\n+        jmp         L(e1)\n@@ -162,1 +162,1 @@\n-\tjmp\t    L(e1)\n+        jmp         L(e1)\n@@ -164,2 +164,2 @@\n-\tmov \t[ecx], al\n-\tjmp\t    L(e1)\n+        mov     [ecx], al\n+        jmp         L(e1)\n@@ -167,2 +167,2 @@\n-\tmov \t[ecx], ax\n-\tjmp\t    L(e1)\n+        mov     [ecx], ax\n+        jmp         L(e1)\n@@ -170,1 +170,1 @@\n-\t\/* Fill out the table so that bad values are predictable.  *\/\n+        \/* Fill out the table so that bad values are predictable.  *\/\n@@ -172,1 +172,1 @@\n-\tint 3\n+        int 3\n@@ -174,1 +174,1 @@\n-\tint 3\n+        int 3\n@@ -177,1 +177,1 @@\n-\t\/\/ cfi_endproc\n+        \/\/ cfi_endproc\n@@ -183,1 +183,1 @@\n-\t__attribute_((fastcall))\n+        __attribute_((fastcall))\n@@ -187,2 +187,2 @@\n-\tecx:\tframe\n-\tedx:\targp\n+        ecx:    frame\n+        edx:    argp\n@@ -194,2 +194,2 @@\n-# define closure_FS\t(40 + 4)\n-# define closure_CF\t0\n+# define closure_FS     (40 + 4)\n+# define closure_CF     0\n@@ -197,2 +197,2 @@\n-# define closure_FS\t(8 + 40 + 12)\n-# define closure_CF\t8\n+# define closure_FS     (8 + 40 + 12)\n+# define closure_CF     8\n@@ -202,3 +202,3 @@\n-\tmov \t[esp + closure_CF+16+R_EAX*4], eax\n-\tmov \t[esp + closure_CF+16+R_EDX*4], edx\n-\tmov \t[esp + closure_CF+16+R_ECX*4], ecx\n+        mov     [esp + closure_CF+16+R_EAX*4], eax\n+        mov     [esp + closure_CF+16+R_EDX*4], edx\n+        mov     [esp + closure_CF+16+R_ECX*4], ecx\n@@ -208,6 +208,6 @@\n-\tmov \tedx, [eax+FFI_TRAMPOLINE_SIZE]      \/* copy cif *\/\n-\tmov \tecx, [eax+FFI_TRAMPOLINE_SIZE+4]    \/* copy fun *\/\n-\tmov \teax, [eax+FFI_TRAMPOLINE_SIZE+8];   \/* copy user_data *\/\n-\tmov \t[esp+closure_CF+28], edx\n-\tmov \t[esp+closure_CF+32], ecx\n-\tmov \t[esp+closure_CF+36], eax\n+        mov     edx, [eax+FFI_TRAMPOLINE_SIZE]      \/* copy cif *\/\n+        mov     ecx, [eax+FFI_TRAMPOLINE_SIZE+4]    \/* copy fun *\/\n+        mov     eax, [eax+FFI_TRAMPOLINE_SIZE+8];   \/* copy user_data *\/\n+        mov     [esp+closure_CF+28], edx\n+        mov     [esp+closure_CF+32], ecx\n+        mov     [esp+closure_CF+36], eax\n@@ -218,2 +218,2 @@\n-\tmov\t    ecx, esp                    \/* load closure_data *\/\n-\tlea \tedx, [esp+closure_FS+4]     \/* load incoming stack *\/\n+        mov         ecx, esp                    \/* load closure_data *\/\n+        lea     edx, [esp+closure_FS+4]     \/* load incoming stack *\/\n@@ -223,4 +223,4 @@\n-\tlea \tecx, [esp+closure_CF]       \/* load closure_data *\/\n-\tlea \tedx, [esp+closure_FS+4]     \/* load incoming stack *\/\n-\tmov \t[esp], ecx\n-\tmov \t[esp+4], edx\n+        lea     ecx, [esp+closure_CF]       \/* load closure_data *\/\n+        lea     edx, [esp+closure_FS+4]     \/* load incoming stack *\/\n+        mov     [esp], ecx\n+        mov     [esp+4], edx\n@@ -231,1 +231,1 @@\n-\tcall\t@ffi_closure_inner@8\n+        call    @ffi_closure_inner@8\n@@ -235,4 +235,4 @@\n-\tand\t    eax, X86_RET_TYPE_MASK\n-\tlea \tedx, [LABEL+eax*8]\n-\tmov \teax, [esp+closure_CF]       \/* optimiztic load *\/\n-\tjmp\t    edx\n+        and         eax, X86_RET_TYPE_MASK\n+        lea     edx, [LABEL+eax*8]\n+        mov     eax, [esp+closure_CF]       \/* optimiztic load *\/\n+        jmp         edx\n@@ -245,2 +245,2 @@\n-\t\/\/ cfi_startproc\n-\tsub\tesp, closure_FS\n+        \/\/ cfi_startproc\n+        sub     esp, closure_FS\n@@ -248,8 +248,8 @@\n-\t\/\/ cfi_def_cfa_offset(closure_FS + 4)\n-\tFFI_CLOSURE_SAVE_REGS\n-\tmov     edx, [eax+4]\t\t\t\/* copy cif *\/\n-\tmov \tecx, [eax +8]\t\t\t\/* copy fun *\/\n-\tmov \t[esp+closure_CF+28], edx\n-\tmov \t[esp+closure_CF+32], ecx\n-\tmov \t[esp+closure_CF+36], eax\t\/* closure is user_data *\/\n-\tjmp\tL(do_closure_i386)\n+        \/\/ cfi_def_cfa_offset(closure_FS + 4)\n+        FFI_CLOSURE_SAVE_REGS\n+        mov     edx, [eax+4]                    \/* copy cif *\/\n+        mov     ecx, [eax +8]                   \/* copy fun *\/\n+        mov     [esp+closure_CF+28], edx\n+        mov     [esp+closure_CF+32], ecx\n+        mov     [esp+closure_CF+36], eax        \/* closure is user_data *\/\n+        jmp     L(do_closure_i386)\n@@ -257,1 +257,1 @@\n-\t\/\/ cfi_endproc\n+        \/\/ cfi_endproc\n@@ -264,2 +264,2 @@\n-\t\/\/ cfi_startproc\n-\tsub \tesp, closure_FS\n+        \/\/ cfi_startproc\n+        sub     esp, closure_FS\n@@ -267,8 +267,8 @@\n-\t\/\/ cfi_def_cfa_offset(closure_FS + 4)\n-\tFFI_CLOSURE_SAVE_REGS\n-\tmov \tedx, [ecx+4]\t\t\t\/* copy cif *\/\n-\tmov \teax, [ecx+8]\t\t\t\/* copy fun *\/\n-\tmov \t[esp+closure_CF+28], edx\n-\tmov \t[esp+closure_CF+32], eax\n-\tmov \t[esp+closure_CF+36], ecx\t\/* closure is user_data *\/\n-\tjmp\tL(do_closure_i386)\n+        \/\/ cfi_def_cfa_offset(closure_FS + 4)\n+        FFI_CLOSURE_SAVE_REGS\n+        mov     edx, [ecx+4]                    \/* copy cif *\/\n+        mov     eax, [ecx+8]                    \/* copy fun *\/\n+        mov     [esp+closure_CF+28], edx\n+        mov     [esp+closure_CF+32], eax\n+        mov     [esp+closure_CF+36], ecx        \/* closure is user_data *\/\n+        jmp     L(do_closure_i386)\n@@ -276,1 +276,1 @@\n-\t\/\/ cfi_endproc\n+        \/\/ cfi_endproc\n@@ -286,2 +286,2 @@\n-\t\/\/ cfi_startproc\n-\tsub\t    esp, closure_FS\n+        \/\/ cfi_startproc\n+        sub         esp, closure_FS\n@@ -289,1 +289,1 @@\n-\t\/\/ cfi_def_cfa_offset(closure_FS + 4)\n+        \/\/ cfi_def_cfa_offset(closure_FS + 4)\n@@ -291,2 +291,2 @@\n-\tFFI_CLOSURE_SAVE_REGS\n-\tFFI_CLOSURE_COPY_TRAMP_DATA\n+        FFI_CLOSURE_SAVE_REGS\n+        FFI_CLOSURE_COPY_TRAMP_DATA\n@@ -294,1 +294,1 @@\n-\t\/* Entry point from preceeding Go closures.  *\/\n+        \/* Entry point from preceeding Go closures.  *\/\n@@ -297,3 +297,3 @@\n-\tFFI_CLOSURE_PREP_CALL\n-\tFFI_CLOSURE_CALL_INNER(14)\n-\tFFI_CLOSURE_MASK_AND_JUMP L(C1(load_table,2))\n+        FFI_CLOSURE_PREP_CALL\n+        FFI_CLOSURE_CALL_INNER(14)\n+        FFI_CLOSURE_MASK_AND_JUMP L(C1(load_table,2))\n@@ -304,2 +304,2 @@\n-\tfld \tdword ptr [esp+closure_CF]\n-\tjmp\tL(e2)\n+        fld     dword ptr [esp+closure_CF]\n+        jmp     L(e2)\n@@ -307,2 +307,2 @@\n-\tfld \tqword ptr [esp+closure_CF]\n-\tjmp\tL(e2)\n+        fld     qword ptr [esp+closure_CF]\n+        jmp     L(e2)\n@@ -310,2 +310,2 @@\n-\tfld \tqword ptr [esp+closure_CF]\n-\tjmp\tL(e2)\n+        fld     qword ptr [esp+closure_CF]\n+        jmp     L(e2)\n@@ -313,2 +313,2 @@\n-\tmovsx\teax, al\n-\tjmp\tL(e2)\n+        movsx   eax, al\n+        jmp     L(e2)\n@@ -316,2 +316,2 @@\n-\tmovsx\teax, ax\n-\tjmp\tL(e2)\n+        movsx   eax, ax\n+        jmp     L(e2)\n@@ -319,2 +319,2 @@\n-\tmovzx\teax, al\n-\tjmp\tL(e2)\n+        movzx   eax, al\n+        jmp     L(e2)\n@@ -322,2 +322,2 @@\n-\tmovzx\teax, ax\n-\tjmp\tL(e2)\n+        movzx   eax, ax\n+        jmp     L(e2)\n@@ -325,2 +325,2 @@\n-\tmov \tedx, [esp+closure_CF+4]\n-\tjmp\tL(e2)\n+        mov     edx, [esp+closure_CF+4]\n+        jmp     L(e2)\n@@ -328,2 +328,2 @@\n-\tnop\n-\t\/* fallthru *\/\n+        nop\n+        \/* fallthru *\/\n@@ -332,1 +332,1 @@\n-\tadd \tesp, closure_FS\n+        add     esp, closure_FS\n@@ -334,2 +334,2 @@\n-\t\/\/ cfi_adjust_cfa_offset(-closure_FS)\n-\tret\n+        \/\/ cfi_adjust_cfa_offset(-closure_FS)\n+        ret\n@@ -337,1 +337,1 @@\n-\t\/\/ cfi_adjust_cfa_offset(closure_FS)\n+        \/\/ cfi_adjust_cfa_offset(closure_FS)\n@@ -339,1 +339,1 @@\n-\tadd \tesp, closure_FS\n+        add     esp, closure_FS\n@@ -341,2 +341,2 @@\n-\t\/\/ cfi_adjust_cfa_offset(-closure_FS)\n-\tret\t4\n+        \/\/ cfi_adjust_cfa_offset(-closure_FS)\n+        ret     4\n@@ -344,1 +344,1 @@\n-\t\/\/ cfi_adjust_cfa_offset(closure_FS)\n+        \/\/ cfi_adjust_cfa_offset(closure_FS)\n@@ -346,1 +346,1 @@\n-\tjmp\tL(e2)\n+        jmp     L(e2)\n@@ -348,2 +348,2 @@\n-\tmovzx\teax, al\n-\tjmp\tL(e2)\n+        movzx   eax, al\n+        jmp     L(e2)\n@@ -351,2 +351,2 @@\n-\tmovzx\teax, ax\n-\tjmp\tL(e2)\n+        movzx   eax, ax\n+        jmp     L(e2)\n@@ -354,1 +354,1 @@\n-\t\/* Fill out the table so that bad values are predictable.  *\/\n+        \/* Fill out the table so that bad values are predictable.  *\/\n@@ -356,1 +356,1 @@\n-\tint 3\n+        int 3\n@@ -358,1 +358,1 @@\n-\tint 3\n+        int 3\n@@ -361,1 +361,1 @@\n-\t\/\/ cfi_endproc\n+        \/\/ cfi_endproc\n@@ -365,1 +365,1 @@\n-PUBLIC\tffi_go_closure_STDCALL\n+PUBLIC  ffi_go_closure_STDCALL\n@@ -368,2 +368,2 @@\n-\t\/\/ cfi_startproc\n-\tsub \tesp, closure_FS\n+        \/\/ cfi_startproc\n+        sub     esp, closure_FS\n@@ -371,8 +371,8 @@\n-\t\/\/ cfi_def_cfa_offset(closure_FS + 4)\n-\tFFI_CLOSURE_SAVE_REGS\n-\tmov \tedx, [ecx+4]\t\t\t\/* copy cif *\/\n-\tmov \teax, [ecx+8]\t\t\t\/* copy fun *\/\n-\tmov \t[esp+closure_CF+28], edx\n-\tmov \t[esp+closure_CF+32], eax\n-\tmov \t[esp+closure_CF+36], ecx\t\/* closure is user_data *\/\n-\tjmp\tL(do_closure_STDCALL)\n+        \/\/ cfi_def_cfa_offset(closure_FS + 4)\n+        FFI_CLOSURE_SAVE_REGS\n+        mov     edx, [ecx+4]                    \/* copy cif *\/\n+        mov     eax, [ecx+8]                    \/* copy fun *\/\n+        mov     [esp+closure_CF+28], edx\n+        mov     [esp+closure_CF+32], eax\n+        mov     [esp+closure_CF+36], ecx        \/* closure is user_data *\/\n+        jmp     L(do_closure_STDCALL)\n@@ -380,1 +380,1 @@\n-\t\/\/ cfi_endproc\n+        \/\/ cfi_endproc\n@@ -390,4 +390,4 @@\n-\t\/\/ cfi_startproc\n-\t\/\/ cfi_def_cfa(%esp, 8)\n-\t\/\/ cfi_offset(%eip, -8)\n-\tsub \tesp, closure_FS-4\n+        \/\/ cfi_startproc\n+        \/\/ cfi_def_cfa(%esp, 8)\n+        \/\/ cfi_offset(%eip, -8)\n+        sub     esp, closure_FS-4\n@@ -395,6 +395,6 @@\n-\t\/\/ cfi_def_cfa_offset(closure_FS + 4)\n-\tFFI_CLOSURE_SAVE_REGS\n-\tmov\tecx, [esp+closure_FS-4] \t\/* load retaddr *\/\n-\tmov\teax, [esp+closure_FS]\t\t\/* load closure *\/\n-\tmov\t[esp+closure_FS], ecx\t\t\/* move retaddr *\/\n-\tjmp\tL(do_closure_REGISTER)\n+        \/\/ cfi_def_cfa_offset(closure_FS + 4)\n+        FFI_CLOSURE_SAVE_REGS\n+        mov     ecx, [esp+closure_FS-4]         \/* load retaddr *\/\n+        mov     eax, [esp+closure_FS]           \/* load closure *\/\n+        mov     [esp+closure_FS], ecx           \/* move retaddr *\/\n+        jmp     L(do_closure_REGISTER)\n@@ -402,1 +402,1 @@\n-\t\/\/ cfi_endproc\n+        \/\/ cfi_endproc\n@@ -413,2 +413,2 @@\n-\t\/\/ cfi_startproc\n-\tsub \tesp, closure_FS\n+        \/\/ cfi_startproc\n+        sub     esp, closure_FS\n@@ -416,1 +416,1 @@\n-\t\/\/ cfi_def_cfa_offset(closure_FS + 4)\n+        \/\/ cfi_def_cfa_offset(closure_FS + 4)\n@@ -418,1 +418,1 @@\n-\tFFI_CLOSURE_SAVE_REGS\n+        FFI_CLOSURE_SAVE_REGS\n@@ -420,1 +420,1 @@\n-\t\/* Entry point from ffi_closure_REGISTER.  *\/\n+        \/* Entry point from ffi_closure_REGISTER.  *\/\n@@ -423,1 +423,1 @@\n-\tFFI_CLOSURE_COPY_TRAMP_DATA\n+        FFI_CLOSURE_COPY_TRAMP_DATA\n@@ -425,1 +425,1 @@\n-\t\/* Entry point from preceeding Go closure.  *\/\n+        \/* Entry point from preceeding Go closure.  *\/\n@@ -428,2 +428,2 @@\n-\tFFI_CLOSURE_PREP_CALL\n-\tFFI_CLOSURE_CALL_INNER(29)\n+        FFI_CLOSURE_PREP_CALL\n+        FFI_CLOSURE_CALL_INNER(29)\n@@ -431,5 +431,5 @@\n-\tmov \tecx, eax\n-\tshr \tecx, X86_RET_POP_SHIFT\t    \/* isolate pop count *\/\n-\tlea \tecx, [esp+closure_FS+ecx]\t\/* compute popped esp *\/\n-\tmov \tedx, [esp+closure_FS]\t\t\/* move return address *\/\n-\tmov \t[ecx], edx\n+        mov     ecx, eax\n+        shr     ecx, X86_RET_POP_SHIFT      \/* isolate pop count *\/\n+        lea     ecx, [esp+closure_FS+ecx]       \/* compute popped esp *\/\n+        mov     edx, [esp+closure_FS]           \/* move return address *\/\n+        mov     [ecx], edx\n@@ -437,5 +437,5 @@\n-\t\/* From this point on, the value of %esp upon return is %ecx+4,\n-\t   and we've copied the return address to %ecx to make return easy.\n-\t   There's no point in representing this in the unwind info, as\n-\t   there is always a window between the mov and the ret which\n-\t   will be wrong from one point of view or another.  *\/\n+        \/* From this point on, the value of %esp upon return is %ecx+4,\n+           and we've copied the return address to %ecx to make return easy.\n+           There's no point in representing this in the unwind info, as\n+           there is always a window between the mov and the ret which\n+           will be wrong from one point of view or another.  *\/\n@@ -443,1 +443,1 @@\n-\tFFI_CLOSURE_MASK_AND_JUMP  L(C1(load_table,3))\n+        FFI_CLOSURE_MASK_AND_JUMP  L(C1(load_table,3))\n@@ -448,3 +448,3 @@\n-\tfld    DWORD PTR [esp+closure_CF]\n-\tmov     esp, ecx\n-\tret\n+        fld    DWORD PTR [esp+closure_CF]\n+        mov     esp, ecx\n+        ret\n@@ -452,3 +452,3 @@\n-\tfld    QWORD PTR [esp+closure_CF]\n-\tmov     esp, ecx\n-\tret\n+        fld    QWORD PTR [esp+closure_CF]\n+        mov     esp, ecx\n+        ret\n@@ -456,3 +456,3 @@\n-\tfld    QWORD PTR [esp+closure_CF]\n-\tmov     esp, ecx\n-\tret\n+        fld    QWORD PTR [esp+closure_CF]\n+        mov     esp, ecx\n+        ret\n@@ -460,3 +460,3 @@\n-\tmovsx   eax, al\n-\tmov     esp, ecx\n-\tret\n+        movsx   eax, al\n+        mov     esp, ecx\n+        ret\n@@ -464,3 +464,3 @@\n-\tmovsx   eax, ax\n-\tmov     esp, ecx\n-\tret\n+        movsx   eax, ax\n+        mov     esp, ecx\n+        ret\n@@ -468,3 +468,3 @@\n-\tmovzx   eax, al\n-\tmov     esp, ecx\n-\tret\n+        movzx   eax, al\n+        mov     esp, ecx\n+        ret\n@@ -472,3 +472,3 @@\n-\tmovzx   eax, ax\n-\tmov     esp, ecx\n-\tret\n+        movzx   eax, ax\n+        mov     esp, ecx\n+        ret\n@@ -476,3 +476,3 @@\n-\tmov \tedx, [esp+closure_CF+4]\n-\tmov     esp, ecx\n-\tret\n+        mov     edx, [esp+closure_CF+4]\n+        mov     esp, ecx\n+        ret\n@@ -480,2 +480,2 @@\n-\tmov     esp, ecx\n-\tret\n+        mov     esp, ecx\n+        ret\n@@ -483,2 +483,2 @@\n-\tmov     esp, ecx\n-\tret\n+        mov     esp, ecx\n+        ret\n@@ -486,2 +486,2 @@\n-\tmov     esp, ecx\n-\tret\n+        mov     esp, ecx\n+        ret\n@@ -489,2 +489,2 @@\n-\tmov \tesp, ecx\n-\tret\n+        mov     esp, ecx\n+        ret\n@@ -492,3 +492,3 @@\n-\tmovzx\teax, al\n-\tmov \tesp, ecx\n-\tret\n+        movzx   eax, al\n+        mov     esp, ecx\n+        ret\n@@ -496,3 +496,3 @@\n-\tmovzx\teax, ax\n-\tmov \tesp, ecx\n-\tret\n+        movzx   eax, ax\n+        mov     esp, ecx\n+        ret\n@@ -500,1 +500,1 @@\n-\t\/* Fill out the table so that bad values are predictable.  *\/\n+        \/* Fill out the table so that bad values are predictable.  *\/\n@@ -502,1 +502,1 @@\n-\tint 3\n+        int 3\n@@ -504,1 +504,1 @@\n-\tint 3\n+        int 3\n@@ -507,1 +507,1 @@\n-\t\/\/ cfi_endproc\n+        \/\/ cfi_endproc\n@@ -512,1 +512,1 @@\n-#define raw_closure_S_FS\t(16+16+12)\n+#define raw_closure_S_FS        (16+16+12)\n@@ -518,2 +518,2 @@\n-\t\/\/ cfi_startproc\n-\tsub \tesp, raw_closure_S_FS\n+        \/\/ cfi_startproc\n+        sub     esp, raw_closure_S_FS\n@@ -521,2 +521,2 @@\n-\t\/\/ cfi_def_cfa_offset(raw_closure_S_FS + 4)\n-\tmov \t[esp+raw_closure_S_FS-4], ebx\n+        \/\/ cfi_def_cfa_offset(raw_closure_S_FS + 4)\n+        mov     [esp+raw_closure_S_FS-4], ebx\n@@ -524,14 +524,14 @@\n-\t\/\/ cfi_rel_offset(%ebx, raw_closure_S_FS-4)\n-\n-\tmov \tedx, [eax+FFI_TRAMPOLINE_SIZE+8]\t\/* load cl->user_data *\/\n-\tmov \t[esp+12], edx\n-\tlea \tedx, [esp+raw_closure_S_FS+4]\t\t\/* load raw_args *\/\n-\tmov \t[esp+8], edx\n-\tlea \tedx, [esp+16]\t\t\t\t\/* load &res *\/\n-\tmov \t[esp+4], edx\n-\tmov \tebx, [eax+FFI_TRAMPOLINE_SIZE]\t\t\/* load cl->cif *\/\n-\tmov \t[esp], ebx\n-\tcall\tDWORD PTR [eax+FFI_TRAMPOLINE_SIZE+4]\t\t\/* call cl->fun *\/\n-\n-\tmov \teax, [ebx+20]\t\t\t\/* load cif->flags *\/\n-\tand \teax, X86_RET_TYPE_MASK\n+        \/\/ cfi_rel_offset(%ebx, raw_closure_S_FS-4)\n+\n+        mov     edx, [eax+FFI_TRAMPOLINE_SIZE+8]        \/* load cl->user_data *\/\n+        mov     [esp+12], edx\n+        lea     edx, [esp+raw_closure_S_FS+4]           \/* load raw_args *\/\n+        mov     [esp+8], edx\n+        lea     edx, [esp+16]                           \/* load &res *\/\n+        mov     [esp+4], edx\n+        mov     ebx, [eax+FFI_TRAMPOLINE_SIZE]          \/* load cl->cif *\/\n+        mov     [esp], ebx\n+        call    DWORD PTR [eax+FFI_TRAMPOLINE_SIZE+4]           \/* call cl->fun *\/\n+\n+        mov     eax, [ebx+20]                   \/* load cif->flags *\/\n+        and     eax, X86_RET_TYPE_MASK\n@@ -539,1 +539,1 @@\n-\/\/ \tcall\t__x86.get_pc_thunk.bx\n+\/\/      call    __x86.get_pc_thunk.bx\n@@ -541,1 +541,1 @@\n-\/\/ \tlea \tecx, L(load_table4)-L(pc4)(%ebx, %eax, 8), %ecx\n+\/\/      lea     ecx, L(load_table4)-L(pc4)(%ebx, %eax, 8), %ecx\n@@ -543,1 +543,1 @@\n-\tlea \tecx, [L(load_table4)+eax+8]\n+        lea     ecx, [L(load_table4)+eax+8]\n@@ -545,1 +545,1 @@\n-\tmov \tebx, [esp+raw_closure_S_FS-4]\n+        mov     ebx, [esp+raw_closure_S_FS-4]\n@@ -547,3 +547,3 @@\n-\t\/\/ cfi_restore(%ebx)\n-\tmov \teax, [esp+16]\t\t\t\t\/* Optimistic load *\/\n-\tjmp\t    dword ptr [ecx]\n+        \/\/ cfi_restore(%ebx)\n+        mov     eax, [esp+16]                           \/* Optimistic load *\/\n+        jmp         dword ptr [ecx]\n@@ -551,1 +551,1 @@\n-\tALIGN 8\n+        ALIGN 8\n@@ -554,2 +554,2 @@\n-\tfld \tDWORD PTR [esp +16]\n-\tjmp\tL(e4)\n+        fld     DWORD PTR [esp +16]\n+        jmp     L(e4)\n@@ -557,2 +557,2 @@\n-\tfld \tQWORD PTR [esp +16]\n-\tjmp\tL(e4)\n+        fld     QWORD PTR [esp +16]\n+        jmp     L(e4)\n@@ -560,2 +560,2 @@\n-\tfld \tQWORD PTR [esp +16]\n-\tjmp\tL(e4)\n+        fld     QWORD PTR [esp +16]\n+        jmp     L(e4)\n@@ -563,2 +563,2 @@\n-\tmovsx\teax, al\n-\tjmp\tL(e4)\n+        movsx   eax, al\n+        jmp     L(e4)\n@@ -566,2 +566,2 @@\n-\tmovsx\teax, ax\n-\tjmp\tL(e4)\n+        movsx   eax, ax\n+        jmp     L(e4)\n@@ -569,2 +569,2 @@\n-\tmovzx\teax, al\n-\tjmp\tL(e4)\n+        movzx   eax, al\n+        jmp     L(e4)\n@@ -572,2 +572,2 @@\n-\tmovzx\teax, ax\n-\tjmp\tL(e4)\n+        movzx   eax, ax\n+        jmp     L(e4)\n@@ -575,2 +575,2 @@\n-\tmov \tedx, [esp+16+4]\n-\tjmp\tL(e4)\n+        mov     edx, [esp+16+4]\n+        jmp     L(e4)\n@@ -578,2 +578,2 @@\n-\tnop\n-\t\/* fallthru *\/\n+        nop\n+        \/* fallthru *\/\n@@ -582,1 +582,1 @@\n-\tadd \tesp, raw_closure_S_FS\n+        add     esp, raw_closure_S_FS\n@@ -584,2 +584,2 @@\n-\t\/\/ cfi_adjust_cfa_offset(-raw_closure_S_FS)\n-\tret\n+        \/\/ cfi_adjust_cfa_offset(-raw_closure_S_FS)\n+        ret\n@@ -587,1 +587,1 @@\n-\t\/\/ cfi_adjust_cfa_offset(raw_closure_S_FS)\n+        \/\/ cfi_adjust_cfa_offset(raw_closure_S_FS)\n@@ -589,1 +589,1 @@\n-\tadd \tesp, raw_closure_S_FS\n+        add     esp, raw_closure_S_FS\n@@ -591,2 +591,2 @@\n-\t\/\/ cfi_adjust_cfa_offset(-raw_closure_S_FS)\n-\tret\t4\n+        \/\/ cfi_adjust_cfa_offset(-raw_closure_S_FS)\n+        ret     4\n@@ -594,1 +594,1 @@\n-\t\/\/ cfi_adjust_cfa_offset(raw_closure_S_FS)\n+        \/\/ cfi_adjust_cfa_offset(raw_closure_S_FS)\n@@ -596,1 +596,1 @@\n-\tjmp\tL(e4)\n+        jmp     L(e4)\n@@ -598,2 +598,2 @@\n-\tmovzx\teax, al\n-\tjmp\tL(e4)\n+        movzx   eax, al\n+        jmp     L(e4)\n@@ -601,2 +601,2 @@\n-\tmovzx\teax, ax\n-\tjmp\tL(e4)\n+        movzx   eax, ax\n+        jmp     L(e4)\n@@ -604,1 +604,1 @@\n-\t\/* Fill out the table so that bad values are predictable.  *\/\n+        \/* Fill out the table so that bad values are predictable.  *\/\n@@ -606,1 +606,1 @@\n-\tint 3\n+        int 3\n@@ -608,1 +608,1 @@\n-\tint 3\n+        int 3\n@@ -611,1 +611,1 @@\n-\t\/\/ cfi_endproc\n+        \/\/ cfi_endproc\n@@ -614,1 +614,1 @@\n-#define raw_closure_T_FS\t(16+16+8)\n+#define raw_closure_T_FS        (16+16+8)\n@@ -620,4 +620,4 @@\n-\t\/\/ cfi_startproc\n-\t\/* Rearrange the stack such that %ecx is the first argument.\n-\t   This means moving the return address.  *\/\n-\tpop \tedx\n+        \/\/ cfi_startproc\n+        \/* Rearrange the stack such that %ecx is the first argument.\n+           This means moving the return address.  *\/\n+        pop     edx\n@@ -625,3 +625,3 @@\n-\t\/\/ cfi_def_cfa_offset(0)\n-\t\/\/ cfi_register(%eip, %edx)\n-\tpush\tecx\n+        \/\/ cfi_def_cfa_offset(0)\n+        \/\/ cfi_register(%eip, %edx)\n+        push    ecx\n@@ -629,2 +629,2 @@\n-\t\/\/ cfi_adjust_cfa_offset(4)\n-\tpush \tedx\n+        \/\/ cfi_adjust_cfa_offset(4)\n+        push    edx\n@@ -632,3 +632,3 @@\n-\t\/\/ cfi_adjust_cfa_offset(4)\n-\t\/\/ cfi_rel_offset(%eip, 0)\n-\tsub \tesp, raw_closure_T_FS\n+        \/\/ cfi_adjust_cfa_offset(4)\n+        \/\/ cfi_rel_offset(%eip, 0)\n+        sub     esp, raw_closure_T_FS\n@@ -636,2 +636,2 @@\n-\t\/\/ cfi_adjust_cfa_offset(raw_closure_T_FS)\n-\tmov \t[esp+raw_closure_T_FS-4], ebx\n+        \/\/ cfi_adjust_cfa_offset(raw_closure_T_FS)\n+        mov     [esp+raw_closure_T_FS-4], ebx\n@@ -639,14 +639,14 @@\n-\t\/\/ cfi_rel_offset(%ebx, raw_closure_T_FS-4)\n-\n-\tmov \tedx, [eax+FFI_TRAMPOLINE_SIZE+8]\t\/* load cl->user_data *\/\n-\tmov \t[esp+12], edx\n-\tlea \tedx, [esp+raw_closure_T_FS+4]\t\t\/* load raw_args *\/\n-\tmov \t[esp+8], edx\n-\tlea \tedx, [esp+16]\t\t\t\t\/* load &res *\/\n-\tmov \t[esp+4], edx\n-\tmov \tebx, [eax+FFI_TRAMPOLINE_SIZE]\t\t\/* load cl->cif *\/\n-\tmov \t[esp], ebx\n-\tcall\tDWORD PTR [eax+FFI_TRAMPOLINE_SIZE+4]\t\t\/* call cl->fun *\/\n-\n-\tmov \teax, [ebx+20]\t\t\t\t\/* load cif->flags *\/\n-\tand \teax, X86_RET_TYPE_MASK\n+        \/\/ cfi_rel_offset(%ebx, raw_closure_T_FS-4)\n+\n+        mov     edx, [eax+FFI_TRAMPOLINE_SIZE+8]        \/* load cl->user_data *\/\n+        mov     [esp+12], edx\n+        lea     edx, [esp+raw_closure_T_FS+4]           \/* load raw_args *\/\n+        mov     [esp+8], edx\n+        lea     edx, [esp+16]                           \/* load &res *\/\n+        mov     [esp+4], edx\n+        mov     ebx, [eax+FFI_TRAMPOLINE_SIZE]          \/* load cl->cif *\/\n+        mov     [esp], ebx\n+        call    DWORD PTR [eax+FFI_TRAMPOLINE_SIZE+4]           \/* call cl->fun *\/\n+\n+        mov     eax, [ebx+20]                           \/* load cif->flags *\/\n+        and     eax, X86_RET_TYPE_MASK\n@@ -654,1 +654,1 @@\n-\/\/ \tcall\t__x86.get_pc_thunk.bx\n+\/\/      call    __x86.get_pc_thunk.bx\n@@ -656,1 +656,1 @@\n-\/\/ \tleal\tL(load_table5)-L(pc5)(%ebx, %eax, 8), %ecx\n+\/\/      leal    L(load_table5)-L(pc5)(%ebx, %eax, 8), %ecx\n@@ -658,1 +658,1 @@\n-\tlea \tecx, [L(load_table5)+eax*8]\n+        lea     ecx, [L(load_table5)+eax*8]\n@@ -660,1 +660,1 @@\n-\tmov \tebx, [esp+raw_closure_T_FS-4]\n+        mov     ebx, [esp+raw_closure_T_FS-4]\n@@ -662,3 +662,3 @@\n-\t\/\/ cfi_restore(%ebx)\n-\tmov \teax, [esp+16]\t\t\t\t\/* Optimistic load *\/\n-\tjmp\t    DWORD PTR [ecx]\n+        \/\/ cfi_restore(%ebx)\n+        mov     eax, [esp+16]                           \/* Optimistic load *\/\n+        jmp         DWORD PTR [ecx]\n@@ -666,1 +666,1 @@\n-\tAlIGN 4\n+        AlIGN 4\n@@ -669,2 +669,2 @@\n-\tfld\tDWORD PTR [esp +16]\n-\tjmp\tL(e5)\n+        fld     DWORD PTR [esp +16]\n+        jmp     L(e5)\n@@ -672,2 +672,2 @@\n-\tfld\tQWORD PTR [esp +16]\n-\tjmp\tL(e5)\n+        fld     QWORD PTR [esp +16]\n+        jmp     L(e5)\n@@ -675,2 +675,2 @@\n-\tfld\tQWORD PTR [esp+16]\n-\tjmp\tL(e5)\n+        fld     QWORD PTR [esp+16]\n+        jmp     L(e5)\n@@ -678,2 +678,2 @@\n-\tmovsx\teax, al\n-\tjmp\tL(e5)\n+        movsx   eax, al\n+        jmp     L(e5)\n@@ -681,2 +681,2 @@\n-\tmovsx\teax, ax\n-\tjmp\tL(e5)\n+        movsx   eax, ax\n+        jmp     L(e5)\n@@ -684,2 +684,2 @@\n-\tmovzx\teax, al\n-\tjmp\tL(e5)\n+        movzx   eax, al\n+        jmp     L(e5)\n@@ -687,2 +687,2 @@\n-\tmovzx\teax, ax\n-\tjmp\tL(e5)\n+        movzx   eax, ax\n+        jmp     L(e5)\n@@ -690,2 +690,2 @@\n-\tmov \tedx, [esp+16+4]\n-\tjmp\tL(e5)\n+        mov     edx, [esp+16+4]\n+        jmp     L(e5)\n@@ -693,2 +693,2 @@\n-\tnop\n-\t\/* fallthru *\/\n+        nop\n+        \/* fallthru *\/\n@@ -697,1 +697,1 @@\n-\tadd \tesp, raw_closure_T_FS\n+        add     esp, raw_closure_T_FS\n@@ -699,3 +699,3 @@\n-\t\/\/ cfi_adjust_cfa_offset(-raw_closure_T_FS)\n-\t\/* Remove the extra %ecx argument we pushed.  *\/\n-\tret\t4\n+        \/\/ cfi_adjust_cfa_offset(-raw_closure_T_FS)\n+        \/* Remove the extra %ecx argument we pushed.  *\/\n+        ret     4\n@@ -703,1 +703,1 @@\n-\t\/\/ cfi_adjust_cfa_offset(raw_closure_T_FS)\n+        \/\/ cfi_adjust_cfa_offset(raw_closure_T_FS)\n@@ -705,1 +705,1 @@\n-\tadd \tesp, raw_closure_T_FS\n+        add     esp, raw_closure_T_FS\n@@ -707,2 +707,2 @@\n-\t\/\/ cfi_adjust_cfa_offset(-raw_closure_T_FS)\n-\tret\t8\n+        \/\/ cfi_adjust_cfa_offset(-raw_closure_T_FS)\n+        ret     8\n@@ -710,1 +710,1 @@\n-\t\/\/ cfi_adjust_cfa_offset(raw_closure_T_FS)\n+        \/\/ cfi_adjust_cfa_offset(raw_closure_T_FS)\n@@ -712,1 +712,1 @@\n-\tjmp\tL(e5)\n+        jmp     L(e5)\n@@ -714,2 +714,2 @@\n-\tmovzx\teax, al\n-\tjmp\tL(e5)\n+        movzx   eax, al\n+        jmp     L(e5)\n@@ -717,2 +717,2 @@\n-\tmovzx\teax, ax\n-\tjmp\tL(e5)\n+        movzx   eax, ax\n+        jmp     L(e5)\n@@ -720,1 +720,1 @@\n-\t\/* Fill out the table so that bad values are predictable.  *\/\n+        \/* Fill out the table so that bad values are predictable.  *\/\n@@ -722,1 +722,1 @@\n-\tint 3\n+        int 3\n@@ -724,1 +724,1 @@\n-\tint 3\n+        int 3\n@@ -727,1 +727,1 @@\n-\t\/\/ cfi_endproc\n+        \/\/ cfi_endproc\n@@ -733,3 +733,3 @@\n-# define COMDAT(X)\t\t\t\t\t\t\t\\\n-        .section __TEXT,__text,coalesced,pure_instructions;\t\t\\\n-        .weak_definition X;\t\t\t\t\t\t\\\n+# define COMDAT(X)                                                      \\\n+        .section __TEXT,__text,coalesced,pure_instructions;             \\\n+        .weak_definition X;                                             \\\n@@ -738,4 +738,4 @@\n-# define COMDAT(X)\t\t\t\t\t\t\t\\\n-\t.section .text.X,\"axG\",@progbits,X,comdat;\t\t\t\\\n-\tPUBLIC\tX;\t\t\t\t\t\t\t\\\n-\tFFI_HIDDEN(X)\n+# define COMDAT(X)                                                      \\\n+        .section .text.X,\"axG\",@progbits,X,comdat;                      \\\n+        PUBLIC  X;                                                      \\\n+        FFI_HIDDEN(X)\n@@ -747,1 +747,1 @@\n-\/\/ \tCOMDAT(C(__x86.get_pc_thunk.bx))\n+\/\/      COMDAT(C(__x86.get_pc_thunk.bx))\n@@ -749,2 +749,2 @@\n-\/\/ \tmovl\t(%esp), %ebx\n-\/\/ \tret\n+\/\/      movl    (%esp), %ebx\n+\/\/      ret\n@@ -753,1 +753,1 @@\n-\/\/ \tCOMDAT(C(__x86.get_pc_thunk.dx))\n+\/\/      COMDAT(C(__x86.get_pc_thunk.dx))\n@@ -755,2 +755,2 @@\n-\/\/ \tmovl\t(%esp), %edx\n-\/\/ \tret\n+\/\/      movl    (%esp), %edx\n+\/\/      ret\n@@ -776,1 +776,1 @@\n-# define PCREL(X)\tX - .\n+# define PCREL(X)       X - .\n@@ -778,1 +778,1 @@\n-# define PCREL(X)\tX@rel\n+# define PCREL(X)       X@rel\n@@ -782,1 +782,1 @@\n-#define ADV(N, P)\t.byte 2, L(N)-L(P)\n+#define ADV(N, P)       .byte 2, L(N)-L(P)\n@@ -784,1 +784,1 @@\n-\t.balign 4\n+        .balign 4\n@@ -786,2 +786,2 @@\n-\t.set\tL(set0),L(ECIE)-L(SCIE)\n-\t.long\tL(set0)\t\t\t\/* CIE Length *\/\n+        .set    L(set0),L(ECIE)-L(SCIE)\n+        .long   L(set0)                 \/* CIE Length *\/\n@@ -789,11 +789,11 @@\n-\t.long\t0\t\t\t\/* CIE Identifier Tag *\/\n-\t.byte\t1\t\t\t\/* CIE Version *\/\n-\t.ascii\t\"zR\\0\"\t\t\t\/* CIE Augmentation *\/\n-\t.byte\t1\t\t\t\/* CIE Code Alignment Factor *\/\n-\t.byte\t0x7c\t\t\t\/* CIE Data Alignment Factor *\/\n-\t.byte\t0x8\t\t\t\/* CIE RA Column *\/\n-\t.byte\t1\t\t\t\/* Augmentation size *\/\n-\t.byte\t0x1b\t\t\t\/* FDE Encoding (pcrel sdata4) *\/\n-\t.byte\t0xc, 4, 4\t\t\/* DW_CFA_def_cfa, %esp offset 4 *\/\n-\t.byte\t0x80+8, 1\t\t\/* DW_CFA_offset, %eip offset 1*-4 *\/\n-\t.balign 4\n+        .long   0                       \/* CIE Identifier Tag *\/\n+        .byte   1                       \/* CIE Version *\/\n+        .ascii  \"zR\\0\"                  \/* CIE Augmentation *\/\n+        .byte   1                       \/* CIE Code Alignment Factor *\/\n+        .byte   0x7c                    \/* CIE Data Alignment Factor *\/\n+        .byte   0x8                     \/* CIE RA Column *\/\n+        .byte   1                       \/* Augmentation size *\/\n+        .byte   0x1b                    \/* FDE Encoding (pcrel sdata4) *\/\n+        .byte   0xc, 4, 4               \/* DW_CFA_def_cfa, %esp offset 4 *\/\n+        .byte   0x80+8, 1               \/* DW_CFA_offset, %eip offset 1*-4 *\/\n+        .balign 4\n@@ -802,2 +802,2 @@\n-\t.set\tL(set1),L(EFDE1)-L(SFDE1)\n-\t.long\tL(set1)\t\t\t\/* FDE Length *\/\n+        .set    L(set1),L(EFDE1)-L(SFDE1)\n+        .long   L(set1)                 \/* FDE Length *\/\n@@ -805,17 +805,17 @@\n-\t.long\tL(SFDE1)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW0))\t\t\/* Initial location *\/\n-\t.long\tL(UW5)-L(UW0)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW1, UW0)\n-\t.byte\t0xc, 5, 8\t\t\/* DW_CFA_def_cfa, %ebp 8 *\/\n-\t.byte\t0x80+5, 2\t\t\/* DW_CFA_offset, %ebp 2*-4 *\/\n-\tADV(UW2, UW1)\n-\t.byte\t0x80+3, 0\t\t\/* DW_CFA_offset, %ebx 0*-4 *\/\n-\tADV(UW3, UW2)\n-\t.byte\t0xa\t\t\t\/* DW_CFA_remember_state *\/\n-\t.byte\t0xc, 4, 4\t\t\/* DW_CFA_def_cfa, %esp 4 *\/\n-\t.byte\t0xc0+3\t\t\t\/* DW_CFA_restore, %ebx *\/\n-\t.byte\t0xc0+5\t\t\t\/* DW_CFA_restore, %ebp *\/\n-\tADV(UW4, UW3)\n-\t.byte\t0xb\t\t\t\/* DW_CFA_restore_state *\/\n-\t.balign\t4\n+        .long   L(SFDE1)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW0))           \/* Initial location *\/\n+        .long   L(UW5)-L(UW0)           \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW1, UW0)\n+        .byte   0xc, 5, 8               \/* DW_CFA_def_cfa, %ebp 8 *\/\n+        .byte   0x80+5, 2               \/* DW_CFA_offset, %ebp 2*-4 *\/\n+        ADV(UW2, UW1)\n+        .byte   0x80+3, 0               \/* DW_CFA_offset, %ebx 0*-4 *\/\n+        ADV(UW3, UW2)\n+        .byte   0xa                     \/* DW_CFA_remember_state *\/\n+        .byte   0xc, 4, 4               \/* DW_CFA_def_cfa, %esp 4 *\/\n+        .byte   0xc0+3                  \/* DW_CFA_restore, %ebx *\/\n+        .byte   0xc0+5                  \/* DW_CFA_restore, %ebp *\/\n+        ADV(UW4, UW3)\n+        .byte   0xb                     \/* DW_CFA_restore_state *\/\n+        .balign 4\n@@ -824,2 +824,2 @@\n-\t.set\tL(set2),L(EFDE2)-L(SFDE2)\n-\t.long\tL(set2)\t\t\t\/* FDE Length *\/\n+        .set    L(set2),L(EFDE2)-L(SFDE2)\n+        .long   L(set2)                 \/* FDE Length *\/\n@@ -827,7 +827,7 @@\n-\t.long\tL(SFDE2)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW6))\t\t\/* Initial location *\/\n-\t.long\tL(UW8)-L(UW6)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW7, UW6)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .long   L(SFDE2)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW6))           \/* Initial location *\/\n+        .long   L(UW8)-L(UW6)           \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW7, UW6)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -836,2 +836,2 @@\n-\t.set\tL(set3),L(EFDE3)-L(SFDE3)\n-\t.long\tL(set3)\t\t\t\/* FDE Length *\/\n+        .set    L(set3),L(EFDE3)-L(SFDE3)\n+        .long   L(set3)                 \/* FDE Length *\/\n@@ -839,7 +839,7 @@\n-\t.long\tL(SFDE3)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW9))\t\t\/* Initial location *\/\n-\t.long\tL(UW11)-L(UW9)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW10, UW9)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .long   L(SFDE3)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW9))           \/* Initial location *\/\n+        .long   L(UW11)-L(UW9)          \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW10, UW9)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -848,2 +848,2 @@\n-\t.set\tL(set4),L(EFDE4)-L(SFDE4)\n-\t.long\tL(set4)\t\t\t\/* FDE Length *\/\n+        .set    L(set4),L(EFDE4)-L(SFDE4)\n+        .long   L(set4)                 \/* FDE Length *\/\n@@ -851,6 +851,6 @@\n-\t.long\tL(SFDE4)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW12))\t\t\/* Initial location *\/\n-\t.long\tL(UW20)-L(UW12)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW13, UW12)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n+        .long   L(SFDE4)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW12))          \/* Initial location *\/\n+        .long   L(UW20)-L(UW12)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW13, UW12)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n@@ -858,5 +858,5 @@\n-\tADV(UW14, UW13)\n-\t.byte\t0x80+3, (40-(closure_FS+4))\/-4  \/* DW_CFA_offset %ebx *\/\n-\tADV(UW15, UW14)\n-\t.byte\t0xc0+3\t\t\t\/* DW_CFA_restore %ebx *\/\n-\tADV(UW16, UW15)\n+        ADV(UW14, UW13)\n+        .byte   0x80+3, (40-(closure_FS+4))\/-4  \/* DW_CFA_offset %ebx *\/\n+        ADV(UW15, UW14)\n+        .byte   0xc0+3                  \/* DW_CFA_restore %ebx *\/\n+        ADV(UW16, UW15)\n@@ -864,1 +864,1 @@\n-\tADV(UW16, UW13)\n+        ADV(UW16, UW13)\n@@ -866,8 +866,8 @@\n-\t.byte\t0xe, 4\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW17, UW16)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW18, UW17)\n-\t.byte\t0xe, 4\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW19, UW18)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .byte   0xe, 4                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW17, UW16)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW18, UW17)\n+        .byte   0xe, 4                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW19, UW18)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -876,2 +876,2 @@\n-\t.set\tL(set5),L(EFDE5)-L(SFDE5)\n-\t.long\tL(set5)\t\t\t\/* FDE Length *\/\n+        .set    L(set5),L(EFDE5)-L(SFDE5)\n+        .long   L(set5)                 \/* FDE Length *\/\n@@ -879,7 +879,7 @@\n-\t.long\tL(SFDE5)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW21))\t\t\/* Initial location *\/\n-\t.long\tL(UW23)-L(UW21)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW22, UW21)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .long   L(SFDE5)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW21))          \/* Initial location *\/\n+        .long   L(UW23)-L(UW21)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW22, UW21)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -888,2 +888,2 @@\n-\t.set\tL(set6),L(EFDE6)-L(SFDE6)\n-\t.long\tL(set6)\t\t\t\/* FDE Length *\/\n+        .set    L(set6),L(EFDE6)-L(SFDE6)\n+        .long   L(set6)                 \/* FDE Length *\/\n@@ -891,9 +891,9 @@\n-\t.long\tL(SFDE6)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW24))\t\t\/* Initial location *\/\n-\t.long\tL(UW26)-L(UW24)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\t.byte\t0xe, 8\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\t.byte\t0x80+8, 2\t\t\/* DW_CFA_offset %eip, 2*-4 *\/\n-\tADV(UW25, UW24)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .long   L(SFDE6)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW24))          \/* Initial location *\/\n+        .long   L(UW26)-L(UW24)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        .byte   0xe, 8                  \/* DW_CFA_def_cfa_offset *\/\n+        .byte   0x80+8, 2               \/* DW_CFA_offset %eip, 2*-4 *\/\n+        ADV(UW25, UW24)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -902,2 +902,2 @@\n-\t.set\tL(set7),L(EFDE7)-L(SFDE7)\n-\t.long\tL(set7)\t\t\t\/* FDE Length *\/\n+        .set    L(set7),L(EFDE7)-L(SFDE7)\n+        .long   L(set7)                 \/* FDE Length *\/\n@@ -905,6 +905,6 @@\n-\t.long\tL(SFDE7)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW27))\t\t\/* Initial location *\/\n-\t.long\tL(UW31)-L(UW27)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW28, UW27)\n-\t.byte\t0xe, closure_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n+        .long   L(SFDE7)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW27))          \/* Initial location *\/\n+        .long   L(UW31)-L(UW27)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW28, UW27)\n+        .byte   0xe, closure_FS+4       \/* DW_CFA_def_cfa_offset *\/\n@@ -912,4 +912,4 @@\n-\tADV(UW29, UW28)\n-\t.byte\t0x80+3, (40-(closure_FS+4))\/-4  \/* DW_CFA_offset %ebx *\/\n-\tADV(UW30, UW29)\n-\t.byte\t0xc0+3\t\t\t\/* DW_CFA_restore %ebx *\/\n+        ADV(UW29, UW28)\n+        .byte   0x80+3, (40-(closure_FS+4))\/-4  \/* DW_CFA_offset %ebx *\/\n+        ADV(UW30, UW29)\n+        .byte   0xc0+3                  \/* DW_CFA_restore %ebx *\/\n@@ -917,1 +917,1 @@\n-\t.balign\t4\n+        .balign 4\n@@ -921,2 +921,2 @@\n-\t.set\tL(set8),L(EFDE8)-L(SFDE8)\n-\t.long\tL(set8)\t\t\t\/* FDE Length *\/\n+        .set    L(set8),L(EFDE8)-L(SFDE8)\n+        .long   L(set8)                 \/* FDE Length *\/\n@@ -924,19 +924,19 @@\n-\t.long\tL(SFDE8)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW32))\t\t\/* Initial location *\/\n-\t.long\tL(UW40)-L(UW32)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW33, UW32)\n-\t.byte\t0xe, raw_closure_S_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW34, UW33)\n-\t.byte\t0x80+3, 2\t\t\/* DW_CFA_offset %ebx 2*-4 *\/\n-\tADV(UW35, UW34)\n-\t.byte\t0xc0+3\t\t\t\/* DW_CFA_restore %ebx *\/\n-\tADV(UW36, UW35)\n-\t.byte\t0xe, 4\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW37, UW36)\n-\t.byte\t0xe, raw_closure_S_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW38, UW37)\n-\t.byte\t0xe, 4\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW39, UW38)\n-\t.byte\t0xe, raw_closure_S_FS+4\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .long   L(SFDE8)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW32))          \/* Initial location *\/\n+        .long   L(UW40)-L(UW32)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW33, UW32)\n+        .byte   0xe, raw_closure_S_FS+4 \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW34, UW33)\n+        .byte   0x80+3, 2               \/* DW_CFA_offset %ebx 2*-4 *\/\n+        ADV(UW35, UW34)\n+        .byte   0xc0+3                  \/* DW_CFA_restore %ebx *\/\n+        ADV(UW36, UW35)\n+        .byte   0xe, 4                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW37, UW36)\n+        .byte   0xe, raw_closure_S_FS+4 \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW38, UW37)\n+        .byte   0xe, 4                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW39, UW38)\n+        .byte   0xe, raw_closure_S_FS+4 \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -945,2 +945,2 @@\n-\t.set\tL(set9),L(EFDE9)-L(SFDE9)\n-\t.long\tL(set9)\t\t\t\/* FDE Length *\/\n+        .set    L(set9),L(EFDE9)-L(SFDE9)\n+        .long   L(set9)                 \/* FDE Length *\/\n@@ -948,27 +948,27 @@\n-\t.long\tL(SFDE9)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW41))\t\t\/* Initial location *\/\n-\t.long\tL(UW52)-L(UW41)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW42, UW41)\n-\t.byte\t0xe, 0\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\t.byte\t0x9, 8, 2\t\t\/* DW_CFA_register %eip, %edx *\/\n-\tADV(UW43, UW42)\n-\t.byte\t0xe, 4\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW44, UW43)\n-\t.byte\t0xe, 8\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\t.byte\t0x80+8, 2\t\t\/* DW_CFA_offset %eip 2*-4 *\/\n-\tADV(UW45, UW44)\n-\t.byte\t0xe, raw_closure_T_FS+8\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW46, UW45)\n-\t.byte\t0x80+3, 3\t\t\/* DW_CFA_offset %ebx 3*-4 *\/\n-\tADV(UW47, UW46)\n-\t.byte\t0xc0+3\t\t\t\/* DW_CFA_restore %ebx *\/\n-\tADV(UW48, UW47)\n-\t.byte\t0xe, 8\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW49, UW48)\n-\t.byte\t0xe, raw_closure_T_FS+8\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW50, UW49)\n-\t.byte\t0xe, 8\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\tADV(UW51, UW50)\n-\t.byte\t0xe, raw_closure_T_FS+8\t\/* DW_CFA_def_cfa_offset *\/\n-\t.balign\t4\n+        .long   L(SFDE9)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW41))          \/* Initial location *\/\n+        .long   L(UW52)-L(UW41)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW42, UW41)\n+        .byte   0xe, 0                  \/* DW_CFA_def_cfa_offset *\/\n+        .byte   0x9, 8, 2               \/* DW_CFA_register %eip, %edx *\/\n+        ADV(UW43, UW42)\n+        .byte   0xe, 4                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW44, UW43)\n+        .byte   0xe, 8                  \/* DW_CFA_def_cfa_offset *\/\n+        .byte   0x80+8, 2               \/* DW_CFA_offset %eip 2*-4 *\/\n+        ADV(UW45, UW44)\n+        .byte   0xe, raw_closure_T_FS+8 \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW46, UW45)\n+        .byte   0x80+3, 3               \/* DW_CFA_offset %ebx 3*-4 *\/\n+        ADV(UW47, UW46)\n+        .byte   0xc0+3                  \/* DW_CFA_restore %ebx *\/\n+        ADV(UW48, UW47)\n+        .byte   0xe, 8                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW49, UW48)\n+        .byte   0xe, raw_closure_T_FS+8 \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW50, UW49)\n+        .byte   0xe, 8                  \/* DW_CFA_def_cfa_offset *\/\n+        ADV(UW51, UW50)\n+        .byte   0xe, raw_closure_T_FS+8 \/* DW_CFA_def_cfa_offset *\/\n+        .balign 4\n@@ -979,5 +979,5 @@\n-\t.def\t @feat.00;\n-\t.scl\t3;\n-\t.type\t0;\n-\t.endef\n-\tPUBLIC\t@feat.00\n+        .def     @feat.00;\n+        .scl    3;\n+        .type   0;\n+        .endef\n+        PUBLIC  @feat.00\n@@ -991,1 +991,1 @@\n-\t.section\t.note.GNU-stack,\"\",@progbits\n+        .section        .note.GNU-stack,\"\",@progbits\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/x86\/sysv_intel.S","additions":565,"deletions":565,"binary":false,"changes":1130,"status":"modified"},{"patch":"@@ -3,2 +3,2 @@\n-\t    - Copyright (c) 2008  Red Hat, Inc\n-\t    - Copyright (c) 2002  Bo Thorsen <bo@suse.de>\n+            - Copyright (c) 2008  Red Hat, Inc\n+            - Copyright (c) 2002  Bo Thorsen <bo@suse.de>\n@@ -43,1 +43,1 @@\n-# define E(BASE, X)\t.balign 8\n+# define E(BASE, X)     .balign 8\n@@ -45,1 +45,5 @@\n-# define E(BASE, X)\t.balign 8; .org BASE + X * 8\n+# ifdef __CET__\n+#  define E(BASE, X)    .balign 8; .org BASE + X * 16\n+# else\n+#  define E(BASE, X)    .balign 8; .org BASE + X * 8\n+# endif\n@@ -49,1 +53,1 @@\n-\t            void *raddr, void (*fnaddr)(void));\n+                    void *raddr, void (*fnaddr)(void));\n@@ -55,3 +59,3 @@\n-\t.balign\t8\n-\t.globl\tC(ffi_call_unix64)\n-\tFFI_HIDDEN(C(ffi_call_unix64))\n+        .balign 8\n+        .globl  C(ffi_call_unix64)\n+        FFI_HIDDEN(C(ffi_call_unix64))\n@@ -61,15 +65,16 @@\n-\tmovq\t(%rsp), %r10\t\t\/* Load return address.  *\/\n-\tleaq\t(%rdi, %rsi), %rax\t\/* Find local stack base.  *\/\n-\tmovq\t%rdx, (%rax)\t\t\/* Save flags.  *\/\n-\tmovq\t%rcx, 8(%rax)\t\t\/* Save raddr.  *\/\n-\tmovq\t%rbp, 16(%rax)\t\t\/* Save old frame pointer.  *\/\n-\tmovq\t%r10, 24(%rax)\t\t\/* Relocate return address.  *\/\n-\tmovq\t%rax, %rbp\t\t\/* Finalize local stack frame.  *\/\n-\n-\t\/* New stack frame based off rbp.  This is a itty bit of unwind\n-\t   trickery in that the CFA *has* changed.  There is no easy way\n-\t   to describe it correctly on entry to the function.  Fortunately,\n-\t   it doesn't matter too much since at all points we can correctly\n-\t   unwind back to ffi_call.  Note that the location to which we\n-\t   moved the return address is (the new) CFA-8, so from the\n-\t   perspective of the unwind info, it hasn't moved.  *\/\n+        _CET_ENDBR\n+        movq    (%rsp), %r10            \/* Load return address.  *\/\n+        leaq    (%rdi, %rsi), %rax      \/* Find local stack base.  *\/\n+        movq    %rdx, (%rax)            \/* Save flags.  *\/\n+        movq    %rcx, 8(%rax)           \/* Save raddr.  *\/\n+        movq    %rbp, 16(%rax)          \/* Save old frame pointer.  *\/\n+        movq    %r10, 24(%rax)          \/* Relocate return address.  *\/\n+        movq    %rax, %rbp              \/* Finalize local stack frame.  *\/\n+\n+        \/* New stack frame based off rbp.  This is a itty bit of unwind\n+           trickery in that the CFA *has* changed.  There is no easy way\n+           to describe it correctly on entry to the function.  Fortunately,\n+           it doesn't matter too much since at all points we can correctly\n+           unwind back to ffi_call.  Note that the location to which we\n+           moved the return address is (the new) CFA-8, so from the\n+           perspective of the unwind info, it hasn't moved.  *\/\n@@ -77,17 +82,16 @@\n-\t\/* cfi_def_cfa(%rbp, 32) *\/\n-\t\/* cfi_rel_offset(%rbp, 16) *\/\n-\n-\tmovq\t%rdi, %r10\t\t\/* Save a copy of the register area. *\/\n-\tmovq\t%r8, %r11\t\t\/* Save a copy of the target fn.  *\/\n-\tmovl\t%r9d, %eax\t\t\/* Set number of SSE registers.  *\/\n-\n-\t\/* Load up all argument registers.  *\/\n-\tmovq\t(%r10), %rdi\n-\tmovq\t0x08(%r10), %rsi\n-\tmovq\t0x10(%r10), %rdx\n-\tmovq\t0x18(%r10), %rcx\n-\tmovq\t0x20(%r10), %r8\n-\tmovq\t0x28(%r10), %r9\n-\tmovl\t0xb0(%r10), %eax\n-\ttestl\t%eax, %eax\n-\tjnz\tL(load_sse)\n+        \/* cfi_def_cfa(%rbp, 32) *\/\n+        \/* cfi_rel_offset(%rbp, 16) *\/\n+\n+        movq    %rdi, %r10              \/* Save a copy of the register area. *\/\n+        movq    %r8, %r11               \/* Save a copy of the target fn.  *\/\n+\n+        \/* Load up all argument registers.  *\/\n+        movq    (%r10), %rdi\n+        movq    0x08(%r10), %rsi\n+        movq    0x10(%r10), %rdx\n+        movq    0x18(%r10), %rcx\n+        movq    0x20(%r10), %r8\n+        movq    0x28(%r10), %r9\n+        movl    0xb0(%r10), %eax        \/* Set number of SSE registers.  *\/\n+        testl   %eax, %eax\n+        jnz     L(load_sse)\n@@ -96,3 +100,3 @@\n-\t\/* Deallocate the reg arg area, except for r10, then load via pop.  *\/\n-\tleaq\t0xb8(%r10), %rsp\n-\tpopq\t%r10\n+        \/* Deallocate the reg arg area, except for r10, then load via pop.  *\/\n+        leaq    0xb8(%r10), %rsp\n+        popq    %r10\n@@ -100,2 +104,2 @@\n-\t\/* Call the user function.  *\/\n-\tcall\t*%r11\n+        \/* Call the user function.  *\/\n+        call    *%r11\n@@ -103,2 +107,2 @@\n-\t\/* Deallocate stack arg area; local stack frame in redzone.  *\/\n-\tleaq\t24(%rbp), %rsp\n+        \/* Deallocate stack arg area; local stack frame in redzone.  *\/\n+        leaq    24(%rbp), %rsp\n@@ -106,3 +110,3 @@\n-\tmovq\t0(%rbp), %rcx\t\t\/* Reload flags.  *\/\n-\tmovq\t8(%rbp), %rdi\t\t\/* Reload raddr.  *\/\n-\tmovq\t16(%rbp), %rbp\t\t\/* Reload old frame pointer.  *\/\n+        movq    0(%rbp), %rcx           \/* Reload flags.  *\/\n+        movq    8(%rbp), %rdi           \/* Reload raddr.  *\/\n+        movq    16(%rbp), %rbp          \/* Reload old frame pointer.  *\/\n@@ -110,16 +114,21 @@\n-\t\/* cfi_remember_state *\/\n-\t\/* cfi_def_cfa(%rsp, 8) *\/\n-\t\/* cfi_restore(%rbp) *\/\n-\n-\t\/* The first byte of the flags contains the FFI_TYPE.  *\/\n-\tcmpb\t$UNIX64_RET_LAST, %cl\n-\tmovzbl\t%cl, %r10d\n-\tleaq\tL(store_table)(%rip), %r11\n-\tja\tL(sa)\n-\tleaq\t(%r11, %r10, 8), %r10\n-\n-\t\/* Prep for the structure cases: scratch area in redzone.  *\/\n-\tleaq\t-20(%rsp), %rsi\n-\tjmp\t*%r10\n-\n-\t.balign\t8\n+        \/* cfi_remember_state *\/\n+        \/* cfi_def_cfa(%rsp, 8) *\/\n+        \/* cfi_restore(%rbp) *\/\n+\n+        \/* The first byte of the flags contains the FFI_TYPE.  *\/\n+        cmpb    $UNIX64_RET_LAST, %cl\n+        movzbl  %cl, %r10d\n+        leaq    L(store_table)(%rip), %r11\n+        ja      L(sa)\n+#ifdef __CET__\n+        \/* NB: Originally, each slot is 8 byte.  4 bytes of ENDBR64 +\n+           4 bytes NOP padding double slot size to 16 bytes.  *\/\n+        addl    %r10d, %r10d\n+#endif\n+        leaq    (%r11, %r10, 8), %r10\n+\n+        \/* Prep for the structure cases: scratch area in redzone.  *\/\n+        leaq    -20(%rsp), %rsi\n+        jmp     *%r10\n+\n+        .balign 8\n@@ -128,1 +137,2 @@\n-\tret\n+        _CET_ENDBR\n+        ret\n@@ -130,3 +140,4 @@\n-\tmovzbl\t%al, %eax\n-\tmovq\t%rax, (%rdi)\n-\tret\n+        _CET_ENDBR\n+        movzbl  %al, %eax\n+        movq    %rax, (%rdi)\n+        ret\n@@ -134,3 +145,4 @@\n-\tmovzwl\t%ax, %eax\n-\tmovq\t%rax, (%rdi)\n-\tret\n+        _CET_ENDBR\n+        movzwl  %ax, %eax\n+        movq    %rax, (%rdi)\n+        ret\n@@ -138,3 +150,4 @@\n-\tmovl\t%eax, %eax\n-\tmovq\t%rax, (%rdi)\n-\tret\n+        _CET_ENDBR\n+        movl    %eax, %eax\n+        movq    %rax, (%rdi)\n+        ret\n@@ -142,3 +155,4 @@\n-\tmovsbq\t%al, %rax\n-\tmovq\t%rax, (%rdi)\n-\tret\n+        _CET_ENDBR\n+        movsbq  %al, %rax\n+        movq    %rax, (%rdi)\n+        ret\n@@ -146,3 +160,4 @@\n-\tmovswq\t%ax, %rax\n-\tmovq\t%rax, (%rdi)\n-\tret\n+        _CET_ENDBR\n+        movswq  %ax, %rax\n+        movq    %rax, (%rdi)\n+        ret\n@@ -150,3 +165,4 @@\n-\tcltq\n-\tmovq\t%rax, (%rdi)\n-\tret\n+        _CET_ENDBR\n+        cltq\n+        movq    %rax, (%rdi)\n+        ret\n@@ -154,2 +170,3 @@\n-\tmovq\t%rax, (%rdi)\n-\tret\n+        _CET_ENDBR\n+        movq    %rax, (%rdi)\n+        ret\n@@ -157,2 +174,3 @@\n-\tmovd\t%xmm0, (%rdi)\n-\tret\n+        _CET_ENDBR\n+        movd    %xmm0, (%rdi)\n+        ret\n@@ -160,2 +178,3 @@\n-\tmovq\t%xmm0, (%rdi)\n-\tret\n+        _CET_ENDBR\n+        movq    %xmm0, (%rdi)\n+        ret\n@@ -163,2 +182,3 @@\n-\tfstpt\t(%rdi)\n-\tret\n+        _CET_ENDBR\n+        fstpt   (%rdi)\n+        ret\n@@ -166,3 +186,4 @@\n-\tfstpt\t(%rdi)\n-\tfstpt\t16(%rdi)\n-\tret\n+        _CET_ENDBR\n+        fstpt   (%rdi)\n+        fstpt   16(%rdi)\n+        ret\n@@ -170,2 +191,3 @@\n-\tmovq\t%rax, 8(%rsi)\n-\tjmp\tL(s3)\n+        _CET_ENDBR\n+        movq    %rax, 8(%rsi)\n+        jmp     L(s3)\n@@ -173,2 +195,3 @@\n-\tmovq\t%xmm0, 8(%rsi)\n-\tjmp\tL(s2)\n+        _CET_ENDBR\n+        movq    %xmm0, 8(%rsi)\n+        jmp     L(s2)\n@@ -176,2 +199,3 @@\n-\tmovq\t%xmm1, 8(%rsi)\n-\tjmp\tL(s3)\n+        _CET_ENDBR\n+        movq    %xmm1, 8(%rsi)\n+        jmp     L(s3)\n@@ -179,1 +203,2 @@\n-\tmovq\t%rdx, 8(%rsi)\n+        _CET_ENDBR\n+        movq    %rdx, 8(%rsi)\n@@ -181,5 +206,5 @@\n-\tmovq\t%rax, (%rsi)\n-\tshrl\t$UNIX64_SIZE_SHIFT, %ecx\n-\trep movsb\n-\tret\n-\t.balign 8\n+        movq    %rax, (%rsi)\n+        shrl    $UNIX64_SIZE_SHIFT, %ecx\n+        rep movsb\n+        ret\n+        .balign 8\n@@ -187,4 +212,4 @@\n-\tmovq\t%xmm0, (%rsi)\n-\tshrl\t$UNIX64_SIZE_SHIFT, %ecx\n-\trep movsb\n-\tret\n+        movq    %xmm0, (%rsi)\n+        shrl    $UNIX64_SIZE_SHIFT, %ecx\n+        rep movsb\n+        ret\n@@ -192,1 +217,1 @@\n-L(sa):\tcall\tPLT(C(abort))\n+L(sa):  call    PLT(C(abort))\n@@ -194,4 +219,4 @@\n-\t\/* Many times we can avoid loading any SSE registers at all.\n-\t   It's not worth an indirect jump to load the exact set of\n-\t   SSE registers needed; zero or all is a good compromise.  *\/\n-\t.balign 2\n+        \/* Many times we can avoid loading any SSE registers at all.\n+           It's not worth an indirect jump to load the exact set of\n+           SSE registers needed; zero or all is a good compromise.  *\/\n+        .balign 2\n@@ -199,1 +224,1 @@\n-\t\/* cfi_restore_state *\/\n+        \/* cfi_restore_state *\/\n@@ -201,9 +226,9 @@\n-\tmovdqa\t0x30(%r10), %xmm0\n-\tmovdqa\t0x40(%r10), %xmm1\n-\tmovdqa\t0x50(%r10), %xmm2\n-\tmovdqa\t0x60(%r10), %xmm3\n-\tmovdqa\t0x70(%r10), %xmm4\n-\tmovdqa\t0x80(%r10), %xmm5\n-\tmovdqa\t0x90(%r10), %xmm6\n-\tmovdqa\t0xa0(%r10), %xmm7\n-\tjmp\tL(ret_from_load_sse)\n+        movdqa  0x30(%r10), %xmm0\n+        movdqa  0x40(%r10), %xmm1\n+        movdqa  0x50(%r10), %xmm2\n+        movdqa  0x60(%r10), %xmm3\n+        movdqa  0x70(%r10), %xmm4\n+        movdqa  0x80(%r10), %xmm5\n+        movdqa  0x90(%r10), %xmm6\n+        movdqa  0xa0(%r10), %xmm7\n+        jmp     L(ret_from_load_sse)\n@@ -216,4 +241,4 @@\n-#define ffi_closure_OFS_G\t0\n-#define ffi_closure_OFS_V\t(6*8)\n-#define ffi_closure_OFS_RVALUE\t(ffi_closure_OFS_V + 8*16)\n-#define ffi_closure_FS\t\t(ffi_closure_OFS_RVALUE + 32 + 8)\n+#define ffi_closure_OFS_G       0\n+#define ffi_closure_OFS_V       (6*8)\n+#define ffi_closure_OFS_RVALUE  (ffi_closure_OFS_V + 8*16)\n+#define ffi_closure_FS          (ffi_closure_OFS_RVALUE + 32 + 8)\n@@ -222,1 +247,1 @@\n-#define ffi_closure_RED_RVALUE\t(ffi_closure_OFS_RVALUE - ffi_closure_FS)\n+#define ffi_closure_RED_RVALUE  (ffi_closure_OFS_RVALUE - ffi_closure_FS)\n@@ -224,3 +249,3 @@\n-\t.balign\t2\n-\t.globl\tC(ffi_closure_unix64_sse)\n-\tFFI_HIDDEN(C(ffi_closure_unix64_sse))\n+        .balign 2\n+        .globl  C(ffi_closure_unix64_sse)\n+        FFI_HIDDEN(C(ffi_closure_unix64_sse))\n@@ -230,1 +255,2 @@\n-\tsubq\t$ffi_closure_FS, %rsp\n+        _CET_ENDBR\n+        subq    $ffi_closure_FS, %rsp\n@@ -232,11 +258,11 @@\n-\t\/* cfi_adjust_cfa_offset(ffi_closure_FS) *\/\n-\n-\tmovdqa\t%xmm0, ffi_closure_OFS_V+0x00(%rsp)\n-\tmovdqa\t%xmm1, ffi_closure_OFS_V+0x10(%rsp)\n-\tmovdqa\t%xmm2, ffi_closure_OFS_V+0x20(%rsp)\n-\tmovdqa\t%xmm3, ffi_closure_OFS_V+0x30(%rsp)\n-\tmovdqa\t%xmm4, ffi_closure_OFS_V+0x40(%rsp)\n-\tmovdqa\t%xmm5, ffi_closure_OFS_V+0x50(%rsp)\n-\tmovdqa\t%xmm6, ffi_closure_OFS_V+0x60(%rsp)\n-\tmovdqa\t%xmm7, ffi_closure_OFS_V+0x70(%rsp)\n-\tjmp\tL(sse_entry1)\n+        \/* cfi_adjust_cfa_offset(ffi_closure_FS) *\/\n+\n+        movdqa  %xmm0, ffi_closure_OFS_V+0x00(%rsp)\n+        movdqa  %xmm1, ffi_closure_OFS_V+0x10(%rsp)\n+        movdqa  %xmm2, ffi_closure_OFS_V+0x20(%rsp)\n+        movdqa  %xmm3, ffi_closure_OFS_V+0x30(%rsp)\n+        movdqa  %xmm4, ffi_closure_OFS_V+0x40(%rsp)\n+        movdqa  %xmm5, ffi_closure_OFS_V+0x50(%rsp)\n+        movdqa  %xmm6, ffi_closure_OFS_V+0x60(%rsp)\n+        movdqa  %xmm7, ffi_closure_OFS_V+0x70(%rsp)\n+        jmp     L(sse_entry1)\n@@ -247,3 +273,3 @@\n-\t.balign\t2\n-\t.globl\tC(ffi_closure_unix64)\n-\tFFI_HIDDEN(C(ffi_closure_unix64))\n+        .balign 2\n+        .globl  C(ffi_closure_unix64)\n+        FFI_HIDDEN(C(ffi_closure_unix64))\n@@ -253,1 +279,2 @@\n-\tsubq\t$ffi_closure_FS, %rsp\n+        _CET_ENDBR\n+        subq    $ffi_closure_FS, %rsp\n@@ -255,1 +282,1 @@\n-\t\/* cfi_adjust_cfa_offset(ffi_closure_FS) *\/\n+        \/* cfi_adjust_cfa_offset(ffi_closure_FS) *\/\n@@ -257,6 +284,6 @@\n-\tmovq\t%rdi, ffi_closure_OFS_G+0x00(%rsp)\n-\tmovq    %rsi, ffi_closure_OFS_G+0x08(%rsp)\n-\tmovq    %rdx, ffi_closure_OFS_G+0x10(%rsp)\n-\tmovq    %rcx, ffi_closure_OFS_G+0x18(%rsp)\n-\tmovq    %r8,  ffi_closure_OFS_G+0x20(%rsp)\n-\tmovq    %r9,  ffi_closure_OFS_G+0x28(%rsp)\n+        movq    %rdi, ffi_closure_OFS_G+0x00(%rsp)\n+        movq    %rsi, ffi_closure_OFS_G+0x08(%rsp)\n+        movq    %rdx, ffi_closure_OFS_G+0x10(%rsp)\n+        movq    %rcx, ffi_closure_OFS_G+0x18(%rsp)\n+        movq    %r8,  ffi_closure_OFS_G+0x20(%rsp)\n+        movq    %r9,  ffi_closure_OFS_G+0x28(%rsp)\n@@ -265,3 +292,3 @@\n-\tmovl\tFFI_TRAMPOLINE_SIZE(%r10), %edi\t\t\/* Load cif *\/\n-\tmovl\tFFI_TRAMPOLINE_SIZE+4(%r10), %esi\t\/* Load fun *\/\n-\tmovl\tFFI_TRAMPOLINE_SIZE+8(%r10), %edx\t\/* Load user_data *\/\n+        movl    FFI_TRAMPOLINE_SIZE(%r10), %edi         \/* Load cif *\/\n+        movl    FFI_TRAMPOLINE_SIZE+4(%r10), %esi       \/* Load fun *\/\n+        movl    FFI_TRAMPOLINE_SIZE+8(%r10), %edx       \/* Load user_data *\/\n@@ -269,3 +296,3 @@\n-\tmovq\tFFI_TRAMPOLINE_SIZE(%r10), %rdi\t\t\/* Load cif *\/\n-\tmovq\tFFI_TRAMPOLINE_SIZE+8(%r10), %rsi\t\/* Load fun *\/\n-\tmovq\tFFI_TRAMPOLINE_SIZE+16(%r10), %rdx\t\/* Load user_data *\/\n+        movq    FFI_TRAMPOLINE_SIZE(%r10), %rdi         \/* Load cif *\/\n+        movq    FFI_TRAMPOLINE_SIZE+8(%r10), %rsi       \/* Load fun *\/\n+        movq    FFI_TRAMPOLINE_SIZE+16(%r10), %rdx      \/* Load user_data *\/\n@@ -274,4 +301,4 @@\n-\tleaq\tffi_closure_OFS_RVALUE(%rsp), %rcx\t\/* Load rvalue *\/\n-\tmovq\t%rsp, %r8\t\t\t\t\/* Load reg_args *\/\n-\tleaq\tffi_closure_FS+8(%rsp), %r9\t\t\/* Load argp *\/\n-\tcall\tPLT(C(ffi_closure_unix64_inner))\n+        leaq    ffi_closure_OFS_RVALUE(%rsp), %rcx      \/* Load rvalue *\/\n+        movq    %rsp, %r8                               \/* Load reg_args *\/\n+        leaq    ffi_closure_FS+8(%rsp), %r9             \/* Load argp *\/\n+        call    PLT(C(ffi_closure_unix64_inner))\n@@ -279,2 +306,2 @@\n-\t\/* Deallocate stack frame early; return value is now in redzone.  *\/\n-\taddq\t$ffi_closure_FS, %rsp\n+        \/* Deallocate stack frame early; return value is now in redzone.  *\/\n+        addq    $ffi_closure_FS, %rsp\n@@ -282,12 +309,17 @@\n-\t\/* cfi_adjust_cfa_offset(-ffi_closure_FS) *\/\n-\n-\t\/* The first byte of the return value contains the FFI_TYPE.  *\/\n-\tcmpb\t$UNIX64_RET_LAST, %al\n-\tmovzbl\t%al, %r10d\n-\tleaq\tL(load_table)(%rip), %r11\n-\tja\tL(la)\n-\tleaq\t(%r11, %r10, 8), %r10\n-\tleaq\tffi_closure_RED_RVALUE(%rsp), %rsi\n-\tjmp\t*%r10\n-\n-\t.balign\t8\n+        \/* cfi_adjust_cfa_offset(-ffi_closure_FS) *\/\n+\n+        \/* The first byte of the return value contains the FFI_TYPE.  *\/\n+        cmpb    $UNIX64_RET_LAST, %al\n+        movzbl  %al, %r10d\n+        leaq    L(load_table)(%rip), %r11\n+        ja      L(la)\n+#ifdef __CET__\n+        \/* NB: Originally, each slot is 8 byte.  4 bytes of ENDBR64 +\n+           4 bytes NOP padding double slot size to 16 bytes.  *\/\n+        addl    %r10d, %r10d\n+#endif\n+        leaq    (%r11, %r10, 8), %r10\n+        leaq    ffi_closure_RED_RVALUE(%rsp), %rsi\n+        jmp     *%r10\n+\n+        .balign 8\n@@ -296,1 +328,2 @@\n-\tret\n+        _CET_ENDBR\n+        ret\n@@ -298,2 +331,3 @@\n-\tmovzbl\t(%rsi), %eax\n-\tret\n+        _CET_ENDBR\n+        movzbl  (%rsi), %eax\n+        ret\n@@ -301,2 +335,3 @@\n-\tmovzwl\t(%rsi), %eax\n-\tret\n+        _CET_ENDBR\n+        movzwl  (%rsi), %eax\n+        ret\n@@ -304,2 +339,3 @@\n-\tmovl\t(%rsi), %eax\n-\tret\n+        _CET_ENDBR\n+        movl    (%rsi), %eax\n+        ret\n@@ -307,2 +343,3 @@\n-\tmovsbl\t(%rsi), %eax\n-\tret\n+        _CET_ENDBR\n+        movsbl  (%rsi), %eax\n+        ret\n@@ -310,2 +347,3 @@\n-\tmovswl\t(%rsi), %eax\n-\tret\n+        _CET_ENDBR\n+        movswl  (%rsi), %eax\n+        ret\n@@ -313,2 +351,3 @@\n-\tmovl\t(%rsi), %eax\n-\tret\n+        _CET_ENDBR\n+        movl    (%rsi), %eax\n+        ret\n@@ -316,2 +355,3 @@\n-\tmovq\t(%rsi), %rax\n-\tret\n+        _CET_ENDBR\n+        movq    (%rsi), %rax\n+        ret\n@@ -319,2 +359,3 @@\n-\tmovd\t(%rsi), %xmm0\n-\tret\n+        _CET_ENDBR\n+        movd    (%rsi), %xmm0\n+        ret\n@@ -322,2 +363,3 @@\n-\tmovq\t(%rsi), %xmm0\n-\tret\n+        _CET_ENDBR\n+        movq    (%rsi), %xmm0\n+        ret\n@@ -325,2 +367,3 @@\n-\tfldt\t(%rsi)\n-\tret\n+        _CET_ENDBR\n+        fldt    (%rsi)\n+        ret\n@@ -328,3 +371,4 @@\n-\tfldt\t16(%rsi)\n-\tfldt\t(%rsi)\n-\tret\n+        _CET_ENDBR\n+        fldt    16(%rsi)\n+        fldt    (%rsi)\n+        ret\n@@ -332,2 +376,3 @@\n-\tmovq\t8(%rsi), %rax\n-\tjmp\tL(l3)\n+        _CET_ENDBR\n+        movq    8(%rsi), %rax\n+        jmp     L(l3)\n@@ -335,2 +380,3 @@\n-\tmovq\t8(%rsi), %xmm0\n-\tjmp\tL(l2)\n+        _CET_ENDBR\n+        movq    8(%rsi), %xmm0\n+        jmp     L(l2)\n@@ -338,2 +384,3 @@\n-\tmovq\t8(%rsi), %xmm1\n-\tjmp\tL(l3)\n+        _CET_ENDBR\n+        movq    8(%rsi), %xmm1\n+        jmp     L(l3)\n@@ -341,1 +388,2 @@\n-\tmovq\t8(%rsi), %rdx\n+        _CET_ENDBR\n+        movq    8(%rsi), %rdx\n@@ -343,3 +391,3 @@\n-\tmovq\t(%rsi), %rax\n-\tret\n-\t.balign\t8\n+        movq    (%rsi), %rax\n+        ret\n+        .balign 8\n@@ -347,2 +395,2 @@\n-\tmovq\t(%rsi), %xmm0\n-\tret\n+        movq    (%rsi), %xmm0\n+        ret\n@@ -350,1 +398,1 @@\n-L(la):\tcall\tPLT(C(abort))\n+L(la):  call    PLT(C(abort))\n@@ -355,3 +403,3 @@\n-\t.balign\t2\n-\t.globl\tC(ffi_go_closure_unix64_sse)\n-\tFFI_HIDDEN(C(ffi_go_closure_unix64_sse))\n+        .balign 2\n+        .globl  C(ffi_go_closure_unix64_sse)\n+        FFI_HIDDEN(C(ffi_go_closure_unix64_sse))\n@@ -361,1 +409,2 @@\n-\tsubq\t$ffi_closure_FS, %rsp\n+        _CET_ENDBR\n+        subq    $ffi_closure_FS, %rsp\n@@ -363,11 +412,11 @@\n-\t\/* cfi_adjust_cfa_offset(ffi_closure_FS) *\/\n-\n-\tmovdqa\t%xmm0, ffi_closure_OFS_V+0x00(%rsp)\n-\tmovdqa\t%xmm1, ffi_closure_OFS_V+0x10(%rsp)\n-\tmovdqa\t%xmm2, ffi_closure_OFS_V+0x20(%rsp)\n-\tmovdqa\t%xmm3, ffi_closure_OFS_V+0x30(%rsp)\n-\tmovdqa\t%xmm4, ffi_closure_OFS_V+0x40(%rsp)\n-\tmovdqa\t%xmm5, ffi_closure_OFS_V+0x50(%rsp)\n-\tmovdqa\t%xmm6, ffi_closure_OFS_V+0x60(%rsp)\n-\tmovdqa\t%xmm7, ffi_closure_OFS_V+0x70(%rsp)\n-\tjmp\tL(sse_entry2)\n+        \/* cfi_adjust_cfa_offset(ffi_closure_FS) *\/\n+\n+        movdqa  %xmm0, ffi_closure_OFS_V+0x00(%rsp)\n+        movdqa  %xmm1, ffi_closure_OFS_V+0x10(%rsp)\n+        movdqa  %xmm2, ffi_closure_OFS_V+0x20(%rsp)\n+        movdqa  %xmm3, ffi_closure_OFS_V+0x30(%rsp)\n+        movdqa  %xmm4, ffi_closure_OFS_V+0x40(%rsp)\n+        movdqa  %xmm5, ffi_closure_OFS_V+0x50(%rsp)\n+        movdqa  %xmm6, ffi_closure_OFS_V+0x60(%rsp)\n+        movdqa  %xmm7, ffi_closure_OFS_V+0x70(%rsp)\n+        jmp     L(sse_entry2)\n@@ -378,3 +427,3 @@\n-\t.balign\t2\n-\t.globl\tC(ffi_go_closure_unix64)\n-\tFFI_HIDDEN(C(ffi_go_closure_unix64))\n+        .balign 2\n+        .globl  C(ffi_go_closure_unix64)\n+        FFI_HIDDEN(C(ffi_go_closure_unix64))\n@@ -384,1 +433,2 @@\n-\tsubq\t$ffi_closure_FS, %rsp\n+        _CET_ENDBR\n+        subq    $ffi_closure_FS, %rsp\n@@ -386,1 +436,1 @@\n-\t\/* cfi_adjust_cfa_offset(ffi_closure_FS) *\/\n+        \/* cfi_adjust_cfa_offset(ffi_closure_FS) *\/\n@@ -388,6 +438,6 @@\n-\tmovq\t%rdi, ffi_closure_OFS_G+0x00(%rsp)\n-\tmovq    %rsi, ffi_closure_OFS_G+0x08(%rsp)\n-\tmovq    %rdx, ffi_closure_OFS_G+0x10(%rsp)\n-\tmovq    %rcx, ffi_closure_OFS_G+0x18(%rsp)\n-\tmovq    %r8,  ffi_closure_OFS_G+0x20(%rsp)\n-\tmovq    %r9,  ffi_closure_OFS_G+0x28(%rsp)\n+        movq    %rdi, ffi_closure_OFS_G+0x00(%rsp)\n+        movq    %rsi, ffi_closure_OFS_G+0x08(%rsp)\n+        movq    %rdx, ffi_closure_OFS_G+0x10(%rsp)\n+        movq    %rcx, ffi_closure_OFS_G+0x18(%rsp)\n+        movq    %r8,  ffi_closure_OFS_G+0x20(%rsp)\n+        movq    %r9,  ffi_closure_OFS_G+0x28(%rsp)\n@@ -396,3 +446,3 @@\n-\tmovl\t4(%r10), %edi\t\t\/* Load cif *\/\n-\tmovl\t8(%r10), %esi\t\t\/* Load fun *\/\n-\tmovl\t%r10d, %edx\t\t\/* Load closure (user_data) *\/\n+        movl    4(%r10), %edi           \/* Load cif *\/\n+        movl    8(%r10), %esi           \/* Load fun *\/\n+        movl    %r10d, %edx             \/* Load closure (user_data) *\/\n@@ -400,3 +450,3 @@\n-\tmovq\t8(%r10), %rdi\t\t\/* Load cif *\/\n-\tmovq\t16(%r10), %rsi\t\t\/* Load fun *\/\n-\tmovq\t%r10, %rdx\t\t\/* Load closure (user_data) *\/\n+        movq    8(%r10), %rdi           \/* Load cif *\/\n+        movq    16(%r10), %rsi          \/* Load fun *\/\n+        movq    %r10, %rdx              \/* Load closure (user_data) *\/\n@@ -404,1 +454,1 @@\n-\tjmp\tL(do_closure)\n+        jmp     L(do_closure)\n@@ -409,0 +459,75 @@\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+        .balign 8\n+        .globl  C(ffi_closure_unix64_sse_alt)\n+        FFI_HIDDEN(C(ffi_closure_unix64_sse_alt))\n+\n+C(ffi_closure_unix64_sse_alt):\n+        \/* See the comments above trampoline_code_table. *\/\n+        _CET_ENDBR\n+        movq    8(%rsp), %r10                   \/* Load closure in r10 *\/\n+        addq    $16, %rsp                       \/* Restore the stack *\/\n+        jmp     C(ffi_closure_unix64_sse)\n+ENDF(C(ffi_closure_unix64_sse_alt))\n+\n+        .balign 8\n+        .globl  C(ffi_closure_unix64_alt)\n+        FFI_HIDDEN(C(ffi_closure_unix64_alt))\n+\n+C(ffi_closure_unix64_alt):\n+        \/* See the comments above trampoline_code_table. *\/\n+        _CET_ENDBR\n+        movq    8(%rsp), %r10                   \/* Load closure in r10 *\/\n+        addq    $16, %rsp                       \/* Restore the stack *\/\n+        jmp     C(ffi_closure_unix64)\n+        ENDF(C(ffi_closure_unix64_alt))\n+\n+\/*\n+ * Below is the definition of the trampoline code table. Each element in\n+ * the code table is a trampoline.\n+ *\n+ * Because we jump to the trampoline, we place a _CET_ENDBR at the\n+ * beginning of the trampoline to mark it as a valid branch target. This is\n+ * part of the the Intel CET (Control Flow Enforcement Technology).\n+ *\/\n+\/*\n+ * The trampoline uses register r10. It saves the original value of r10 on\n+ * the stack.\n+ *\n+ * The trampoline has two parameters - target code to jump to and data for\n+ * the target code. The trampoline extracts the parameters from its parameter\n+ * block (see tramp_table_map()). The trampoline saves the data address on\n+ * the stack. Finally, it jumps to the target code.\n+ *\n+ * The target code can choose to:\n+ *\n+ * - restore the value of r10\n+ * - load the data address in a register\n+ * - restore the stack pointer to what it was when the trampoline was invoked.\n+ *\/\n+#ifdef ENDBR_PRESENT\n+#define X86_DATA_OFFSET         4077\n+#define X86_CODE_OFFSET         4073\n+#else\n+#define X86_DATA_OFFSET         4081\n+#define X86_CODE_OFFSET         4077\n+#endif\n+\n+        .align  UNIX64_TRAMP_MAP_SIZE\n+        .globl  trampoline_code_table\n+        FFI_HIDDEN(C(trampoline_code_table))\n+\n+C(trampoline_code_table):\n+        .rept   UNIX64_TRAMP_MAP_SIZE \/ UNIX64_TRAMP_SIZE\n+        _CET_ENDBR\n+        subq    $16, %rsp                       \/* Make space on the stack *\/\n+        movq    %r10, (%rsp)                    \/* Save %r10 on stack *\/\n+        movq    X86_DATA_OFFSET(%rip), %r10     \/* Copy data into %r10 *\/\n+        movq    %r10, 8(%rsp)                   \/* Save data on stack *\/\n+        movq    X86_CODE_OFFSET(%rip), %r10     \/* Copy code into %r10 *\/\n+        jmp     *%r10                           \/* Jump to code *\/\n+        .align  8\n+        .endr\n+ENDF(C(trampoline_code_table))\n+        .align  UNIX64_TRAMP_MAP_SIZE\n+#endif \/* FFI_EXEC_STATIC_TRAMP *\/\n+\n@@ -421,1 +546,1 @@\n-# define PCREL(X)\tX - .\n+# define PCREL(X)       X - .\n@@ -423,1 +548,1 @@\n-# define PCREL(X)\tX@rel\n+# define PCREL(X)       X@rel\n@@ -427,1 +552,6 @@\n-#define ADV(N, P)\t.byte 2, L(N)-L(P)\n+#ifdef __CET__\n+\/* Use DW_CFA_advance_loc2 when IBT is enabled.  *\/\n+# define ADV(N, P)      .byte 3; .2byte L(N)-L(P)\n+#else\n+# define ADV(N, P)      .byte 2, L(N)-L(P)\n+#endif\n@@ -429,1 +559,1 @@\n-\t.balign 8\n+        .balign 8\n@@ -431,2 +561,2 @@\n-\t.set\tL(set0),L(ECIE)-L(SCIE)\n-\t.long\tL(set0)\t\t\t\/* CIE Length *\/\n+        .set    L(set0),L(ECIE)-L(SCIE)\n+        .long   L(set0)                 \/* CIE Length *\/\n@@ -434,11 +564,11 @@\n-\t.long\t0\t\t\t\/* CIE Identifier Tag *\/\n-\t.byte\t1\t\t\t\/* CIE Version *\/\n-\t.ascii\t\"zR\\0\"\t\t\t\/* CIE Augmentation *\/\n-\t.byte\t1\t\t\t\/* CIE Code Alignment Factor *\/\n-\t.byte\t0x78\t\t\t\/* CIE Data Alignment Factor *\/\n-\t.byte\t0x10\t\t\t\/* CIE RA Column *\/\n-\t.byte\t1\t\t\t\/* Augmentation size *\/\n-\t.byte\t0x1b\t\t\t\/* FDE Encoding (pcrel sdata4) *\/\n-\t.byte\t0xc, 7, 8\t\t\/* DW_CFA_def_cfa, %rsp offset 8 *\/\n-\t.byte\t0x80+16, 1\t\t\/* DW_CFA_offset, %rip offset 1*-8 *\/\n-\t.balign 8\n+        .long   0                       \/* CIE Identifier Tag *\/\n+        .byte   1                       \/* CIE Version *\/\n+        .ascii  \"zR\\0\"                  \/* CIE Augmentation *\/\n+        .byte   1                       \/* CIE Code Alignment Factor *\/\n+        .byte   0x78                    \/* CIE Data Alignment Factor *\/\n+        .byte   0x10                    \/* CIE RA Column *\/\n+        .byte   1                       \/* Augmentation size *\/\n+        .byte   0x1b                    \/* FDE Encoding (pcrel sdata4) *\/\n+        .byte   0xc, 7, 8               \/* DW_CFA_def_cfa, %rsp offset 8 *\/\n+        .byte   0x80+16, 1              \/* DW_CFA_offset, %rip offset 1*-8 *\/\n+        .balign 8\n@@ -447,2 +577,2 @@\n-\t.set\tL(set1),L(EFDE1)-L(SFDE1)\n-\t.long\tL(set1)\t\t\t\/* FDE Length *\/\n+        .set    L(set1),L(EFDE1)-L(SFDE1)\n+        .long   L(set1)                 \/* FDE Length *\/\n@@ -450,14 +580,14 @@\n-\t.long\tL(SFDE1)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW0))\t\t\/* Initial location *\/\n-\t.long\tL(UW4)-L(UW0)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW1, UW0)\n-\t.byte\t0xc, 6, 32\t\t\/* DW_CFA_def_cfa, %rbp 32 *\/\n-\t.byte\t0x80+6, 2\t\t\/* DW_CFA_offset, %rbp 2*-8 *\/\n-\tADV(UW2, UW1)\n-\t.byte\t0xa\t\t\t\/* DW_CFA_remember_state *\/\n-\t.byte\t0xc, 7, 8\t\t\/* DW_CFA_def_cfa, %rsp 8 *\/\n-\t.byte\t0xc0+6\t\t\t\/* DW_CFA_restore, %rbp *\/\n-\tADV(UW3, UW2)\n-\t.byte\t0xb\t\t\t\/* DW_CFA_restore_state *\/\n-\t.balign\t8\n+        .long   L(SFDE1)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW0))           \/* Initial location *\/\n+        .long   L(UW4)-L(UW0)           \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW1, UW0)\n+        .byte   0xc, 6, 32              \/* DW_CFA_def_cfa, %rbp 32 *\/\n+        .byte   0x80+6, 2               \/* DW_CFA_offset, %rbp 2*-8 *\/\n+        ADV(UW2, UW1)\n+        .byte   0xa                     \/* DW_CFA_remember_state *\/\n+        .byte   0xc, 7, 8               \/* DW_CFA_def_cfa, %rsp 8 *\/\n+        .byte   0xc0+6                  \/* DW_CFA_restore, %rbp *\/\n+        ADV(UW3, UW2)\n+        .byte   0xb                     \/* DW_CFA_restore_state *\/\n+        .balign 8\n@@ -466,2 +596,2 @@\n-\t.set\tL(set2),L(EFDE2)-L(SFDE2)\n-\t.long\tL(set2)\t\t\t\/* FDE Length *\/\n+        .set    L(set2),L(EFDE2)-L(SFDE2)\n+        .long   L(set2)                 \/* FDE Length *\/\n@@ -469,8 +599,8 @@\n-\t.long\tL(SFDE2)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW5))\t\t\/* Initial location *\/\n-\t.long\tL(UW7)-L(UW5)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW6, UW5)\n-\t.byte\t0xe\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\t.byte\tffi_closure_FS + 8, 1\t\/* uleb128, assuming 128 <= FS < 255 *\/\n-\t.balign\t8\n+        .long   L(SFDE2)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW5))           \/* Initial location *\/\n+        .long   L(UW7)-L(UW5)           \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW6, UW5)\n+        .byte   0xe                     \/* DW_CFA_def_cfa_offset *\/\n+        .byte   ffi_closure_FS + 8, 1   \/* uleb128, assuming 128 <= FS < 255 *\/\n+        .balign 8\n@@ -479,2 +609,2 @@\n-\t.set\tL(set3),L(EFDE3)-L(SFDE3)\n-\t.long\tL(set3)\t\t\t\/* FDE Length *\/\n+        .set    L(set3),L(EFDE3)-L(SFDE3)\n+        .long   L(set3)                 \/* FDE Length *\/\n@@ -482,9 +612,9 @@\n-\t.long\tL(SFDE3)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW8))\t\t\/* Initial location *\/\n-\t.long\tL(UW11)-L(UW8)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW9, UW8)\n-\t.byte\t0xe\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\t.byte\tffi_closure_FS + 8, 1\t\/* uleb128, assuming 128 <= FS < 255 *\/\n-\tADV(UW10, UW9)\n-\t.byte\t0xe, 8\t\t\t\/* DW_CFA_def_cfa_offset 8 *\/\n+        .long   L(SFDE3)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW8))           \/* Initial location *\/\n+        .long   L(UW11)-L(UW8)          \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW9, UW8)\n+        .byte   0xe                     \/* DW_CFA_def_cfa_offset *\/\n+        .byte   ffi_closure_FS + 8, 1   \/* uleb128, assuming 128 <= FS < 255 *\/\n+        ADV(UW10, UW9)\n+        .byte   0xe, 8                  \/* DW_CFA_def_cfa_offset 8 *\/\n@@ -493,2 +623,2 @@\n-\t.set\tL(set4),L(EFDE4)-L(SFDE4)\n-\t.long\tL(set4)\t\t\t\/* FDE Length *\/\n+        .set    L(set4),L(EFDE4)-L(SFDE4)\n+        .long   L(set4)                 \/* FDE Length *\/\n@@ -496,8 +626,8 @@\n-\t.long\tL(SFDE4)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW12))\t\t\/* Initial location *\/\n-\t.long\tL(UW14)-L(UW12)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW13, UW12)\n-\t.byte\t0xe\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\t.byte\tffi_closure_FS + 8, 1\t\/* uleb128, assuming 128 <= FS < 255 *\/\n-\t.balign\t8\n+        .long   L(SFDE4)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW12))          \/* Initial location *\/\n+        .long   L(UW14)-L(UW12)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW13, UW12)\n+        .byte   0xe                     \/* DW_CFA_def_cfa_offset *\/\n+        .byte   ffi_closure_FS + 8, 1   \/* uleb128, assuming 128 <= FS < 255 *\/\n+        .balign 8\n@@ -506,2 +636,2 @@\n-\t.set\tL(set5),L(EFDE5)-L(SFDE5)\n-\t.long\tL(set5)\t\t\t\/* FDE Length *\/\n+        .set    L(set5),L(EFDE5)-L(SFDE5)\n+        .long   L(set5)                 \/* FDE Length *\/\n@@ -509,8 +639,8 @@\n-\t.long\tL(SFDE5)-L(CIE)\t\t\/* FDE CIE offset *\/\n-\t.long\tPCREL(L(UW15))\t\t\/* Initial location *\/\n-\t.long\tL(UW17)-L(UW15)\t\t\/* Address range *\/\n-\t.byte\t0\t\t\t\/* Augmentation size *\/\n-\tADV(UW16, UW15)\n-\t.byte\t0xe\t\t\t\/* DW_CFA_def_cfa_offset *\/\n-\t.byte\tffi_closure_FS + 8, 1\t\/* uleb128, assuming 128 <= FS < 255 *\/\n-\t.balign\t8\n+        .long   L(SFDE5)-L(CIE)         \/* FDE CIE offset *\/\n+        .long   PCREL(L(UW15))          \/* Initial location *\/\n+        .long   L(UW17)-L(UW15)         \/* Address range *\/\n+        .byte   0                       \/* Augmentation size *\/\n+        ADV(UW16, UW15)\n+        .byte   0xe                     \/* DW_CFA_def_cfa_offset *\/\n+        .byte   ffi_closure_FS + 8, 1   \/* uleb128, assuming 128 <= FS < 255 *\/\n+        .balign 8\n@@ -519,42 +649,42 @@\n-\t.subsections_via_symbols\n-\t.section __LD,__compact_unwind,regular,debug\n-\n-\t\/* compact unwind for ffi_call_unix64 *\/\n-\t.quad    C(ffi_call_unix64)\n-\t.set     L1,L(UW4)-L(UW0)\n-\t.long    L1\n-\t.long    0x04000000 \/* use dwarf unwind info *\/\n-\t.quad    0\n-\t.quad    0\n-\n-\t\/* compact unwind for ffi_closure_unix64_sse *\/\n-\t.quad    C(ffi_closure_unix64_sse)\n-\t.set     L2,L(UW7)-L(UW5)\n-\t.long    L2\n-\t.long    0x04000000 \/* use dwarf unwind info *\/\n-\t.quad    0\n-\t.quad    0\n-\n-\t\/* compact unwind for ffi_closure_unix64 *\/\n-\t.quad    C(ffi_closure_unix64)\n-\t.set     L3,L(UW11)-L(UW8)\n-\t.long    L3\n-\t.long    0x04000000 \/* use dwarf unwind info *\/\n-\t.quad    0\n-\t.quad    0\n-\n-\t\/* compact unwind for ffi_go_closure_unix64_sse *\/\n-\t.quad    C(ffi_go_closure_unix64_sse)\n-\t.set     L4,L(UW14)-L(UW12)\n-\t.long    L4\n-\t.long    0x04000000 \/* use dwarf unwind info *\/\n-\t.quad    0\n-\t.quad    0\n-\n-\t\/* compact unwind for ffi_go_closure_unix64 *\/\n-\t.quad    C(ffi_go_closure_unix64)\n-\t.set     L5,L(UW17)-L(UW15)\n-\t.long    L5\n-\t.long    0x04000000 \/* use dwarf unwind info *\/\n-\t.quad    0\n-\t.quad    0\n+        .subsections_via_symbols\n+        .section __LD,__compact_unwind,regular,debug\n+\n+        \/* compact unwind for ffi_call_unix64 *\/\n+        .quad    C(ffi_call_unix64)\n+        .set     L1,L(UW4)-L(UW0)\n+        .long    L1\n+        .long    0x04000000 \/* use dwarf unwind info *\/\n+        .quad    0\n+        .quad    0\n+\n+        \/* compact unwind for ffi_closure_unix64_sse *\/\n+        .quad    C(ffi_closure_unix64_sse)\n+        .set     L2,L(UW7)-L(UW5)\n+        .long    L2\n+        .long    0x04000000 \/* use dwarf unwind info *\/\n+        .quad    0\n+        .quad    0\n+\n+        \/* compact unwind for ffi_closure_unix64 *\/\n+        .quad    C(ffi_closure_unix64)\n+        .set     L3,L(UW11)-L(UW8)\n+        .long    L3\n+        .long    0x04000000 \/* use dwarf unwind info *\/\n+        .quad    0\n+        .quad    0\n+\n+        \/* compact unwind for ffi_go_closure_unix64_sse *\/\n+        .quad    C(ffi_go_closure_unix64_sse)\n+        .set     L4,L(UW14)-L(UW12)\n+        .long    L4\n+        .long    0x04000000 \/* use dwarf unwind info *\/\n+        .quad    0\n+        .quad    0\n+\n+        \/* compact unwind for ffi_go_closure_unix64 *\/\n+        .quad    C(ffi_go_closure_unix64)\n+        .set     L5,L(UW17)-L(UW15)\n+        .long    L5\n+        .long    0x04000000 \/* use dwarf unwind info *\/\n+        .quad    0\n+        .quad    0\n@@ -565,1 +695,1 @@\n-\t.section\t.note.GNU-stack,\"\",@progbits\n+        .section        .note.GNU-stack,\"\",@progbits\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/x86\/unix64.S","additions":499,"deletions":369,"binary":false,"changes":868,"status":"modified"},{"patch":"@@ -14,4 +14,4 @@\n-#define arg0\t%rcx\n-#define arg1\t%rdx\n-#define arg2\t%r8\n-#define arg3\t%r9\n+#define arg0    %rcx\n+#define arg1    %rdx\n+#define arg2    %r8\n+#define arg3    %r9\n@@ -20,4 +20,4 @@\n-#define arg0\t%rdi\n-#define arg1\t%rsi\n-#define arg2\t%rdx\n-#define arg3\t%rcx\n+#define arg0    %rdi\n+#define arg1    %rsi\n+#define arg2    %rdx\n+#define arg3    %rcx\n@@ -31,1 +31,1 @@\n-# define E(BASE, X)\t.balign 8\n+# define E(BASE, X)     .balign 8\n@@ -33,1 +33,1 @@\n-# define E(BASE, X)\t.balign 8; .org BASE + X * 8\n+# define E(BASE, X)     .balign 8; .org BASE + (X) * 8\n@@ -36,1 +36,1 @@\n-\t.text\n+        .text\n@@ -44,3 +44,3 @@\n-\t.align\t8\n-\t.globl\tC(ffi_call_win64)\n-\tFFI_HIDDEN(C(ffi_call_win64))\n+        .align  8\n+        .globl  C(ffi_call_win64)\n+        FFI_HIDDEN(C(ffi_call_win64))\n@@ -48,1 +48,1 @@\n-\tSEH(.seh_proc ffi_call_win64)\n+        SEH(.seh_proc ffi_call_win64)\n@@ -50,34 +50,35 @@\n-\tcfi_startproc\n-\t\/* Set up the local stack frame and install it in rbp\/rsp.  *\/\n-\tmovq\t(%rsp), %rax\n-\tmovq\t%rbp, (arg1)\n-\tmovq\t%rax, 8(arg1)\n-\tmovq\targ1, %rbp\n-\tcfi_def_cfa(%rbp, 16)\n-\tcfi_rel_offset(%rbp, 0)\n-\tSEH(.seh_pushreg %rbp)\n-\tSEH(.seh_setframe %rbp, 0)\n-\tSEH(.seh_endprologue)\n-\tmovq\targ0, %rsp\n-\n-\tmovq\targ2, %r10\n-\n-\t\/* Load all slots into both general and xmm registers.  *\/\n-\tmovq\t(%rsp), %rcx\n-\tmovsd\t(%rsp), %xmm0\n-\tmovq\t8(%rsp), %rdx\n-\tmovsd\t8(%rsp), %xmm1\n-\tmovq\t16(%rsp), %r8\n-\tmovsd\t16(%rsp), %xmm2\n-\tmovq\t24(%rsp), %r9\n-\tmovsd\t24(%rsp), %xmm3\n-\n-\tcall\t*16(%rbp)\n-\n-\tmovl\t24(%rbp), %ecx\n-\tmovq\t32(%rbp), %r8\n-\tleaq\t0f(%rip), %r10\n-\tcmpl\t$FFI_TYPE_SMALL_STRUCT_4B, %ecx\n-\tleaq\t(%r10, %rcx, 8), %r10\n-\tja\t99f\n-\tjmp\t*%r10\n+        cfi_startproc\n+        _CET_ENDBR\n+        \/* Set up the local stack frame and install it in rbp\/rsp.  *\/\n+        movq    (%rsp), %rax\n+        movq    %rbp, (arg1)\n+        movq    %rax, 8(arg1)\n+        movq    arg1, %rbp\n+        cfi_def_cfa(%rbp, 16)\n+        cfi_rel_offset(%rbp, 0)\n+        SEH(.seh_pushreg %rbp)\n+        SEH(.seh_setframe %rbp, 0)\n+        SEH(.seh_endprologue)\n+        movq    arg0, %rsp\n+\n+        movq    arg2, %r10\n+\n+        \/* Load all slots into both general and xmm registers.  *\/\n+        movq    (%rsp), %rcx\n+        movsd   (%rsp), %xmm0\n+        movq    8(%rsp), %rdx\n+        movsd   8(%rsp), %xmm1\n+        movq    16(%rsp), %r8\n+        movsd   16(%rsp), %xmm2\n+        movq    24(%rsp), %r9\n+        movsd   24(%rsp), %xmm3\n+\n+        call    *16(%rbp)\n+\n+        movl    24(%rbp), %ecx\n+        movq    32(%rbp), %r8\n+        leaq    0f(%rip), %r10\n+        cmpl    $FFI_TYPE_SMALL_STRUCT_4B, %ecx\n+        leaq    (%r10, %rcx, 8), %r10\n+        ja      99f\n+        _CET_NOTRACK jmp *%r10\n@@ -88,6 +89,6 @@\n-\tleaveq\n-\tcfi_remember_state\n-\tcfi_def_cfa(%rsp, 8)\n-\tcfi_restore(%rbp)\n-\tret\n-\tcfi_restore_state\n+        leaveq\n+        cfi_remember_state\n+        cfi_def_cfa(%rsp, 8)\n+        cfi_restore(%rbp)\n+        ret\n+        cfi_restore_state\n@@ -96,1 +97,1 @@\n-\t.align\t8\n+        .align  8\n@@ -99,1 +100,1 @@\n-\tepilogue\n+        epilogue\n@@ -101,3 +102,3 @@\n-\tmovslq\t%eax, %rax\n-\tmovq\t%rax, (%r8)\n-\tepilogue\n+        movslq  %eax, %rax\n+        movq    %rax, (%r8)\n+        epilogue\n@@ -105,2 +106,2 @@\n-\tmovss\t%xmm0, (%r8)\n-\tepilogue\n+        movss   %xmm0, (%r8)\n+        epilogue\n@@ -108,4 +109,5 @@\n-\tmovsd\t%xmm0, (%r8)\n-\tepilogue\n-E(0b, FFI_TYPE_LONGDOUBLE)\n-\tcall\tPLT(C(abort))\n+        movsd   %xmm0, (%r8)\n+        epilogue\n+\/\/ FFI_TYPE_LONGDOUBLE may be FFI_TYPE_DOUBLE but we need a different value here.\n+E(0b, FFI_TYPE_DOUBLE + 1)\n+        call    PLT(C(abort))\n@@ -113,3 +115,3 @@\n-\tmovzbl\t%al, %eax\n-\tmovq\t%rax, (%r8)\n-\tepilogue\n+        movzbl  %al, %eax\n+        movq    %rax, (%r8)\n+        epilogue\n@@ -117,2 +119,2 @@\n-\tmovsbq\t%al, %rax\n-\tjmp\t98f\n+        movsbq  %al, %rax\n+        jmp     98f\n@@ -120,3 +122,3 @@\n-\tmovzwl\t%ax, %eax\n-\tmovq\t%rax, (%r8)\n-\tepilogue\n+        movzwl  %ax, %eax\n+        movq    %rax, (%r8)\n+        epilogue\n@@ -124,2 +126,2 @@\n-\tmovswq\t%ax, %rax\n-\tjmp\t98f\n+        movswq  %ax, %rax\n+        jmp     98f\n@@ -127,3 +129,3 @@\n-\tmovl\t%eax, %eax\n-\tmovq\t%rax, (%r8)\n-\tepilogue\n+        movl    %eax, %eax\n+        movq    %rax, (%r8)\n+        epilogue\n@@ -131,3 +133,3 @@\n-\tmovslq\t%eax, %rax\n-\tmovq\t%rax, (%r8)\n-\tepilogue\n+        movslq  %eax, %rax\n+        movq    %rax, (%r8)\n+        epilogue\n@@ -135,2 +137,2 @@\n-98:\tmovq\t%rax, (%r8)\n-\tepilogue\n+98:     movq    %rax, (%r8)\n+        epilogue\n@@ -138,2 +140,2 @@\n-\tmovq\t%rax, (%r8)\n-\tepilogue\n+        movq    %rax, (%r8)\n+        epilogue\n@@ -141,1 +143,1 @@\n-\tepilogue\n+        epilogue\n@@ -143,2 +145,2 @@\n-\tmovq\t%rax, (%r8)\n-\tepilogue\n+        movq    %rax, (%r8)\n+        epilogue\n@@ -146,1 +148,1 @@\n-\tcall\tPLT(C(abort))\n+        call    PLT(C(abort))\n@@ -148,2 +150,2 @@\n-\tmovb\t%al, (%r8)\n-\tepilogue\n+        movb    %al, (%r8)\n+        epilogue\n@@ -151,2 +153,2 @@\n-\tmovw\t%ax, (%r8)\n-\tepilogue\n+        movw    %ax, (%r8)\n+        epilogue\n@@ -154,2 +156,2 @@\n-\tmovl\t%eax, (%r8)\n-\tepilogue\n+        movl    %eax, (%r8)\n+        epilogue\n@@ -157,2 +159,2 @@\n-\t.align\t8\n-99:\tcall\tPLT(C(abort))\n+        .align  8\n+99:     call    PLT(C(abort))\n@@ -160,1 +162,1 @@\n-\tepilogue\n+        epilogue\n@@ -162,2 +164,2 @@\n-\tcfi_endproc\n-\tSEH(.seh_endproc)\n+        cfi_endproc\n+        SEH(.seh_endproc)\n@@ -168,3 +170,3 @@\n-#define ffi_clo_FS\t(32+8+16+32)\n-#define ffi_clo_OFF_R\t(32+8)\n-#define ffi_clo_OFF_X\t(32+8+16)\n+#define ffi_clo_FS      (32+8+16+32)\n+#define ffi_clo_OFF_R   (32+8)\n+#define ffi_clo_OFF_X   (32+8+16)\n@@ -172,3 +174,3 @@\n-\t.align\t8\n-\t.globl\tC(ffi_go_closure_win64)\n-\tFFI_HIDDEN(C(ffi_go_closure_win64))\n+        .align  8\n+        .globl  C(ffi_go_closure_win64)\n+        FFI_HIDDEN(C(ffi_go_closure_win64))\n@@ -176,1 +178,1 @@\n-\tSEH(.seh_proc ffi_go_closure_win64)\n+        SEH(.seh_proc ffi_go_closure_win64)\n@@ -178,19 +180,20 @@\n-\tcfi_startproc\n-\t\/* Save all integer arguments into the incoming reg stack space.  *\/\n-\tmovq\t%rcx, 8(%rsp)\n-\tmovq\t%rdx, 16(%rsp)\n-\tmovq\t%r8, 24(%rsp)\n-\tmovq\t%r9, 32(%rsp)\n-\n-\tmovq\t8(%r10), %rcx\t\t\t\/* load cif *\/\n-\tmovq\t16(%r10), %rdx\t\t\t\/* load fun *\/\n-\tmovq\t%r10, %r8\t\t\t\/* closure is user_data *\/\n-\tjmp\t0f\n-\tcfi_endproc\n-\tSEH(.seh_endproc)\n-\n-\t.align\t8\n-\t.globl\tC(ffi_closure_win64)\n-\tFFI_HIDDEN(C(ffi_closure_win64))\n-\n-\tSEH(.seh_proc ffi_closure_win64)\n+        cfi_startproc\n+        _CET_ENDBR\n+        \/* Save all integer arguments into the incoming reg stack space.  *\/\n+        movq    %rcx, 8(%rsp)\n+        movq    %rdx, 16(%rsp)\n+        movq    %r8, 24(%rsp)\n+        movq    %r9, 32(%rsp)\n+\n+        movq    8(%r10), %rcx                   \/* load cif *\/\n+        movq    16(%r10), %rdx                  \/* load fun *\/\n+        movq    %r10, %r8                       \/* closure is user_data *\/\n+        jmp     0f\n+        cfi_endproc\n+        SEH(.seh_endproc)\n+\n+        .align  8\n+        .globl  C(ffi_closure_win64)\n+        FFI_HIDDEN(C(ffi_closure_win64))\n+\n+        SEH(.seh_proc ffi_closure_win64)\n@@ -198,10 +201,11 @@\n-\tcfi_startproc\n-\t\/* Save all integer arguments into the incoming reg stack space.  *\/\n-\tmovq\t%rcx, 8(%rsp)\n-\tmovq\t%rdx, 16(%rsp)\n-\tmovq\t%r8, 24(%rsp)\n-\tmovq\t%r9, 32(%rsp)\n-\n-\tmovq\tFFI_TRAMPOLINE_SIZE(%r10), %rcx\t\t\/* load cif *\/\n-\tmovq\tFFI_TRAMPOLINE_SIZE+8(%r10), %rdx\t\/* load fun *\/\n-\tmovq\tFFI_TRAMPOLINE_SIZE+16(%r10), %r8\t\/* load user_data *\/\n+        cfi_startproc\n+        _CET_ENDBR\n+        \/* Save all integer arguments into the incoming reg stack space.  *\/\n+        movq    %rcx, 8(%rsp)\n+        movq    %rdx, 16(%rsp)\n+        movq    %r8, 24(%rsp)\n+        movq    %r9, 32(%rsp)\n+\n+        movq    FFI_TRAMPOLINE_SIZE(%r10), %rcx         \/* load cif *\/\n+        movq    FFI_TRAMPOLINE_SIZE+8(%r10), %rdx       \/* load fun *\/\n+        movq    FFI_TRAMPOLINE_SIZE+16(%r10), %r8       \/* load user_data *\/\n@@ -209,24 +213,38 @@\n-\tsubq\t$ffi_clo_FS, %rsp\n-\tcfi_adjust_cfa_offset(ffi_clo_FS)\n-\tSEH(.seh_stackalloc ffi_clo_FS)\n-\tSEH(.seh_endprologue)\n-\n-\t\/* Save all sse arguments into the stack frame.  *\/\n-\tmovsd\t%xmm0, ffi_clo_OFF_X(%rsp)\n-\tmovsd\t%xmm1, ffi_clo_OFF_X+8(%rsp)\n-\tmovsd\t%xmm2, ffi_clo_OFF_X+16(%rsp)\n-\tmovsd\t%xmm3, ffi_clo_OFF_X+24(%rsp)\n-\n-\tleaq\tffi_clo_OFF_R(%rsp), %r9\n-\tcall\tPLT(C(ffi_closure_win64_inner))\n-\n-\t\/* Load the result into both possible result registers.  *\/\n-\tmovq    ffi_clo_OFF_R(%rsp), %rax\n-\tmovsd   ffi_clo_OFF_R(%rsp), %xmm0\n-\n-\taddq\t$ffi_clo_FS, %rsp\n-\tcfi_adjust_cfa_offset(-ffi_clo_FS)\n-\tret\n-\n-\tcfi_endproc\n-\tSEH(.seh_endproc)\n+        subq    $ffi_clo_FS, %rsp\n+        cfi_adjust_cfa_offset(ffi_clo_FS)\n+        SEH(.seh_stackalloc ffi_clo_FS)\n+        SEH(.seh_endprologue)\n+\n+        \/* Save all sse arguments into the stack frame.  *\/\n+        movsd   %xmm0, ffi_clo_OFF_X(%rsp)\n+        movsd   %xmm1, ffi_clo_OFF_X+8(%rsp)\n+        movsd   %xmm2, ffi_clo_OFF_X+16(%rsp)\n+        movsd   %xmm3, ffi_clo_OFF_X+24(%rsp)\n+\n+        leaq    ffi_clo_OFF_R(%rsp), %r9\n+        call    PLT(C(ffi_closure_win64_inner))\n+\n+        \/* Load the result into both possible result registers.  *\/\n+        movq    ffi_clo_OFF_R(%rsp), %rax\n+        movsd   ffi_clo_OFF_R(%rsp), %xmm0\n+\n+        addq    $ffi_clo_FS, %rsp\n+        cfi_adjust_cfa_offset(-ffi_clo_FS)\n+        ret\n+\n+        cfi_endproc\n+        SEH(.seh_endproc)\n+\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+        .align  8\n+        .globl  C(ffi_closure_win64_alt)\n+        FFI_HIDDEN(C(ffi_closure_win64_alt))\n+\n+        SEH(.seh_proc ffi_closure_win64_alt)\n+C(ffi_closure_win64_alt):\n+        _CET_ENDBR\n+        movq    8(%rsp), %r10\n+        addq    $16, %rsp\n+        jmp     C(ffi_closure_win64)\n+        SEH(.seh_endproc)\n+#endif\n@@ -236,1 +254,1 @@\n-\t.section\t.note.GNU-stack,\"\",@progbits\n+        .section        .note.GNU-stack,\"\",@progbits\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/x86\/win64.S","additions":180,"deletions":162,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -13,4 +13,4 @@\n-#define arg0\trcx\n-#define arg1\trdx\n-#define arg2\tr8\n-#define arg3\tr9\n+#define arg0    rcx\n+#define arg1    rdx\n+#define arg2    r8\n+#define arg3    r9\n@@ -19,4 +19,4 @@\n-#define arg0\trdi\n-#define arg1\trsi\n-#define arg2\trdx\n-#define arg3\trcx\n+#define arg0    rdi\n+#define arg1    rsi\n+#define arg2    rdx\n+#define arg3    rcx\n@@ -30,1 +30,1 @@\n-# define E(BASE, X)\tALIGN 8\n+# define E(BASE, X)     ALIGN 8\n@@ -32,1 +32,1 @@\n-# define E(BASE, X)\tALIGN 8; ORG BASE + X * 8\n+# define E(BASE, X)     ALIGN 8; ORG BASE + (X) * 8\n@@ -35,3 +35,3 @@\n-\t.CODE\n-\textern PLT(C(abort)):near\n-\textern C(ffi_closure_win64_inner):near\n+        .CODE\n+        extern PLT(C(abort)):near\n+        extern C(ffi_closure_win64_inner):near\n@@ -45,2 +45,2 @@\n-\tALIGN\t8\n-\tPUBLIC\tC(ffi_call_win64)\n+        ALIGN   8\n+        PUBLIC  C(ffi_call_win64)\n@@ -48,1 +48,1 @@\n-\t; SEH(.safesh ffi_call_win64)\n+        ; SEH(.safesh ffi_call_win64)\n@@ -50,34 +50,34 @@\n-\tcfi_startproc\n-\t\/* Set up the local stack frame and install it in rbp\/rsp.  *\/\n-\tmov\tRAX, [RSP] ; \tmovq\t(%rsp), %rax\n-\tmov [arg1], RBP ; movq\t%rbp, (arg1)\n-\tmov [arg1 + 8], RAX;\tmovq\t%rax, 8(arg1)\n-\tmov\t RBP, arg1; movq\targ1, %rbp\n-\tcfi_def_cfa(rbp, 16)\n-\tcfi_rel_offset(rbp, 0)\n-\tSEH(.pushreg rbp)\n-\tSEH(.setframe rbp, 0)\n-\tSEH(.endprolog)\n-\tmov\tRSP, arg0 ;\tmovq\targ0, %rsp\n-\n-\tmov\tR10, arg2 ; movq\targ2, %r10\n-\n-\t\/* Load all slots into both general and xmm registers.  *\/\n-\tmov\tRCX, [RSP] ;\tmovq\t(%rsp), %rcx\n-\tmovsd XMM0, qword ptr [RSP] ; movsd\t(%rsp), %xmm0\n-\tmov\tRDX, [RSP + 8] ;movq\t8(%rsp), %rdx\n-\tmovsd XMM1, qword ptr [RSP + 8];\tmovsd\t8(%rsp), %xmm1\n-\tmov R8, [RSP + 16] ; movq\t16(%rsp), %r8\n-\tmovsd\tXMM2, qword ptr [RSP + 16] ; movsd\t16(%rsp), %xmm2\n-\tmov\tR9, [RSP + 24] ; movq\t24(%rsp), %r9\n-\tmovsd\tXMM3, qword ptr [RSP + 24] ;movsd\t24(%rsp), %xmm3\n-\n-\tCALL qword ptr [RBP + 16] ; call\t*16(%rbp)\n-\n-\tmov\t ECX, [RBP + 24] ; movl\t24(%rbp), %ecx\n-\tmov\tR8, [RBP + 32] ; movq\t32(%rbp), %r8\n-\tLEA\tR10, ffi_call_win64_tab ; leaq\t0f(%rip), %r10\n-\tCMP\tECX, FFI_TYPE_SMALL_STRUCT_4B ; cmpl\t$FFI_TYPE_SMALL_STRUCT_4B, %ecx\n-\tLEA\tR10, [R10 + RCX*8] ; leaq\t(%r10, %rcx, 8), %r10\n-\tJA\tL99 ; ja\t99f\n-\tJMP\tR10 ; jmp\t*%r10\n+        cfi_startproc\n+        \/* Set up the local stack frame and install it in rbp\/rsp.  *\/\n+        mov     RAX, [RSP] ;    movq    (%rsp), %rax\n+        mov [arg1], RBP ; movq  %rbp, (arg1)\n+        mov [arg1 + 8], RAX;    movq    %rax, 8(arg1)\n+        mov      RBP, arg1; movq        arg1, %rbp\n+        cfi_def_cfa(rbp, 16)\n+        cfi_rel_offset(rbp, 0)\n+        SEH(.pushreg rbp)\n+        SEH(.setframe rbp, 0)\n+        SEH(.endprolog)\n+        mov     RSP, arg0 ;     movq    arg0, %rsp\n+\n+        mov     R10, arg2 ; movq        arg2, %r10\n+\n+        \/* Load all slots into both general and xmm registers.  *\/\n+        mov     RCX, [RSP] ;    movq    (%rsp), %rcx\n+        movsd XMM0, qword ptr [RSP] ; movsd     (%rsp), %xmm0\n+        mov     RDX, [RSP + 8] ;movq    8(%rsp), %rdx\n+        movsd XMM1, qword ptr [RSP + 8];        movsd   8(%rsp), %xmm1\n+        mov R8, [RSP + 16] ; movq       16(%rsp), %r8\n+        movsd   XMM2, qword ptr [RSP + 16] ; movsd      16(%rsp), %xmm2\n+        mov     R9, [RSP + 24] ; movq   24(%rsp), %r9\n+        movsd   XMM3, qword ptr [RSP + 24] ;movsd       24(%rsp), %xmm3\n+\n+        CALL qword ptr [RBP + 16] ; call        *16(%rbp)\n+\n+        mov      ECX, [RBP + 24] ; movl 24(%rbp), %ecx\n+        mov     R8, [RBP + 32] ; movq   32(%rbp), %r8\n+        LEA     R10, ffi_call_win64_tab ; leaq  0f(%rip), %r10\n+        CMP     ECX, FFI_TYPE_SMALL_STRUCT_4B ; cmpl    $FFI_TYPE_SMALL_STRUCT_4B, %ecx\n+        LEA     R10, [R10 + RCX*8] ; leaq       (%r10, %rcx, 8), %r10\n+        JA      L99 ; ja        99f\n+        JMP     R10 ; jmp       *%r10\n@@ -88,6 +88,6 @@\n-\tLEAVE\n-\tcfi_remember_state\n-\tcfi_def_cfa(rsp, 8)\n-\tcfi_restore(rbp)\n-\tRET\n-\tcfi_restore_state\n+        LEAVE\n+        cfi_remember_state\n+        cfi_def_cfa(rsp, 8)\n+        cfi_restore(rbp)\n+        RET\n+        cfi_restore_state\n@@ -96,1 +96,1 @@\n-\tALIGN 8\n+        ALIGN 8\n@@ -99,1 +99,1 @@\n-\tepilogue\n+        epilogue\n@@ -101,3 +101,3 @@\n-\tmovsxd rax, eax ; movslq\t%eax, %rax\n-\tmov qword ptr [r8], rax; movq\t%rax, (%r8)\n-\tepilogue\n+        movsxd rax, eax ; movslq        %eax, %rax\n+        mov qword ptr [r8], rax; movq   %rax, (%r8)\n+        epilogue\n@@ -105,2 +105,2 @@\n-\tmovss dword ptr [r8], xmm0 ; movss\t%xmm0, (%r8)\n-\tepilogue\n+        movss dword ptr [r8], xmm0 ; movss      %xmm0, (%r8)\n+        epilogue\n@@ -108,4 +108,5 @@\n-\tmovsd qword ptr[r8], xmm0; movsd\t%xmm0, (%r8)\n-\tepilogue\n-E(0b, FFI_TYPE_LONGDOUBLE)\n-\tcall\tPLT(C(abort))\n+        movsd qword ptr[r8], xmm0; movsd        %xmm0, (%r8)\n+        epilogue\n+\/\/ FFI_TYPE_LONGDOUBLE may be FFI_TYPE_DOUBLE but we need a different value here.\n+E(0b, FFI_TYPE_DOUBLE + 1)\n+        call    PLT(C(abort))\n@@ -113,3 +114,3 @@\n-\tmovzx eax, al ;movzbl\t%al, %eax\n-\tmov qword ptr[r8], rax; movq\t%rax, (%r8)\n-\tepilogue\n+        movzx eax, al ;movzbl   %al, %eax\n+        mov qword ptr[r8], rax; movq    %rax, (%r8)\n+        epilogue\n@@ -117,2 +118,2 @@\n-\tmovsx rax, al ; movsbq\t%al, %rax\n-\tjmp\tL98\n+        movsx rax, al ; movsbq  %al, %rax\n+        jmp     L98\n@@ -120,3 +121,3 @@\n-\tmovzx eax, ax ; movzwl\t%ax, %eax\n-\tmov qword ptr[r8], rax; movq\t%rax, (%r8)\n-\tepilogue\n+        movzx eax, ax ; movzwl  %ax, %eax\n+        mov qword ptr[r8], rax; movq    %rax, (%r8)\n+        epilogue\n@@ -124,2 +125,2 @@\n-\tmovsx rax, ax; movswq\t%ax, %rax\n-\tjmp\tL98\n+        movsx rax, ax; movswq   %ax, %rax\n+        jmp     L98\n@@ -127,3 +128,3 @@\n-\tmov eax, eax; movl\t%eax, %eax\n-\tmov qword ptr[r8], rax ; movq\t%rax, (%r8)\n-\tepilogue\n+        mov eax, eax; movl      %eax, %eax\n+        mov qword ptr[r8], rax ; movq   %rax, (%r8)\n+        epilogue\n@@ -131,3 +132,3 @@\n-\tmovsxd rax, eax; movslq\t%eax, %rax\n-\tmov qword ptr [r8], rax; movq\t%rax, (%r8)\n-\tepilogue\n+        movsxd rax, eax; movslq %eax, %rax\n+        mov qword ptr [r8], rax; movq   %rax, (%r8)\n+        epilogue\n@@ -136,2 +137,2 @@\n-\tmov qword ptr [r8], rax ; movq\t%rax, (%r8)\n-\tepilogue\n+        mov qword ptr [r8], rax ; movq  %rax, (%r8)\n+        epilogue\n@@ -139,2 +140,2 @@\n-\tmov qword ptr [r8], rax;movq\t%rax, (%r8)\n-\tepilogue\n+        mov qword ptr [r8], rax;movq    %rax, (%r8)\n+        epilogue\n@@ -142,1 +143,1 @@\n-\tepilogue\n+        epilogue\n@@ -144,2 +145,2 @@\n-\tmov qword ptr [r8], rax ;movq\t%rax, (%r8)\n-\tepilogue\n+        mov qword ptr [r8], rax ;movq   %rax, (%r8)\n+        epilogue\n@@ -147,1 +148,1 @@\n-\tcall\tPLT(C(abort))\n+        call    PLT(C(abort))\n@@ -149,2 +150,2 @@\n-\tmov byte ptr [r8], al ; movb\t%al, (%r8)\n-\tepilogue\n+        mov byte ptr [r8], al ; movb    %al, (%r8)\n+        epilogue\n@@ -152,2 +153,2 @@\n-\tmov word ptr [r8], ax ; movw\t%ax, (%r8)\n-\tepilogue\n+        mov word ptr [r8], ax ; movw    %ax, (%r8)\n+        epilogue\n@@ -155,2 +156,2 @@\n-\tmov dword ptr [r8], eax ; movl\t%eax, (%r8)\n-\tepilogue\n+        mov dword ptr [r8], eax ; movl  %eax, (%r8)\n+        epilogue\n@@ -158,1 +159,1 @@\n-\talign\t8\n+        align   8\n@@ -160,1 +161,1 @@\n-\tcall\tPLT(C(abort))\n+        call    PLT(C(abort))\n@@ -162,1 +163,1 @@\n-\tepilogue\n+        epilogue\n@@ -164,2 +165,2 @@\n-\tcfi_endproc\n-\tC(ffi_call_win64) endp\n+        cfi_endproc\n+        C(ffi_call_win64) endp\n@@ -170,3 +171,3 @@\n-#define ffi_clo_FS\t(32+8+16+32)\n-#define ffi_clo_OFF_R\t(32+8)\n-#define ffi_clo_OFF_X\t(32+8+16)\n+#define ffi_clo_FS      (32+8+16+32)\n+#define ffi_clo_OFF_R   (32+8)\n+#define ffi_clo_OFF_X   (32+8+16)\n@@ -174,2 +175,2 @@\n-\talign\t8\n-\tPUBLIC\tC(ffi_go_closure_win64)\n+        align   8\n+        PUBLIC  C(ffi_go_closure_win64)\n@@ -178,15 +179,15 @@\n-\tcfi_startproc\n-\t\/* Save all integer arguments into the incoming reg stack space.  *\/\n-\tmov qword ptr [rsp + 8], rcx; movq\t%rcx, 8(%rsp)\n-\tmov qword ptr [rsp + 16], rdx; movq\t%rdx, 16(%rsp)\n-\tmov qword ptr [rsp + 24], r8; movq\t%r8, 24(%rsp)\n-\tmov qword ptr [rsp + 32], r9 ;movq\t%r9, 32(%rsp)\n-\n-\tmov rcx, qword ptr [r10 + 8]; movq\t8(%r10), %rcx\t\t\t\/* load cif *\/\n-\tmov rdx, qword ptr [r10 + 16];  movq\t16(%r10), %rdx\t\t\t\/* load fun *\/\n-\tmov r8, r10 ; movq\t%r10, %r8\t\t\t\/* closure is user_data *\/\n-\tjmp\tffi_closure_win64_2\n-\tcfi_endproc\n-\tC(ffi_go_closure_win64) endp\n-\n-\talign\t8\n+        cfi_startproc\n+        \/* Save all integer arguments into the incoming reg stack space.  *\/\n+        mov qword ptr [rsp + 8], rcx; movq      %rcx, 8(%rsp)\n+        mov qword ptr [rsp + 16], rdx; movq     %rdx, 16(%rsp)\n+        mov qword ptr [rsp + 24], r8; movq      %r8, 24(%rsp)\n+        mov qword ptr [rsp + 32], r9 ;movq      %r9, 32(%rsp)\n+\n+        mov rcx, qword ptr [r10 + 8]; movq      8(%r10), %rcx                   \/* load cif *\/\n+        mov rdx, qword ptr [r10 + 16];  movq    16(%r10), %rdx                  \/* load fun *\/\n+        mov r8, r10 ; movq      %r10, %r8                       \/* closure is user_data *\/\n+        jmp     ffi_closure_win64_2\n+        cfi_endproc\n+        C(ffi_go_closure_win64) endp\n+\n+        align   8\n@@ -196,10 +197,10 @@\n-\tcfi_startproc\n-\t\/* Save all integer arguments into the incoming reg stack space.  *\/\n-\tmov qword ptr [rsp + 8], rcx; movq\t%rcx, 8(%rsp)\n-\tmov qword ptr [rsp + 16], rdx;\tmovq\t%rdx, 16(%rsp)\n-\tmov qword ptr [rsp + 24], r8; \tmovq\t%r8, 24(%rsp)\n-\tmov qword ptr [rsp + 32], r9;\tmovq\t%r9, 32(%rsp)\n-\n-\tmov rcx, qword ptr [FFI_TRAMPOLINE_SIZE + r10]\t;movq\tFFI_TRAMPOLINE_SIZE(%r10), %rcx\t\t\/* load cif *\/\n-\tmov rdx, qword ptr [FFI_TRAMPOLINE_SIZE + 8 + r10] ;\tmovq\tFFI_TRAMPOLINE_SIZE+8(%r10), %rdx\t\/* load fun *\/\n-\tmov r8, qword ptr [FFI_TRAMPOLINE_SIZE+16+r10] ;movq\tFFI_TRAMPOLINE_SIZE+16(%r10), %r8\t\/* load user_data *\/\n+        cfi_startproc\n+        \/* Save all integer arguments into the incoming reg stack space.  *\/\n+        mov qword ptr [rsp + 8], rcx; movq      %rcx, 8(%rsp)\n+        mov qword ptr [rsp + 16], rdx;  movq    %rdx, 16(%rsp)\n+        mov qword ptr [rsp + 24], r8;   movq    %r8, 24(%rsp)\n+        mov qword ptr [rsp + 32], r9;   movq    %r9, 32(%rsp)\n+\n+        mov rcx, qword ptr [FFI_TRAMPOLINE_SIZE + r10]  ;movq   FFI_TRAMPOLINE_SIZE(%r10), %rcx         \/* load cif *\/\n+        mov rdx, qword ptr [FFI_TRAMPOLINE_SIZE + 8 + r10] ;    movq    FFI_TRAMPOLINE_SIZE+8(%r10), %rdx       \/* load fun *\/\n+        mov r8, qword ptr [FFI_TRAMPOLINE_SIZE+16+r10] ;movq    FFI_TRAMPOLINE_SIZE+16(%r10), %r8       \/* load user_data *\/\n@@ -207,4 +208,4 @@\n-\tsub rsp, ffi_clo_FS ;subq\t$ffi_clo_FS, %rsp\n-\tcfi_adjust_cfa_offset(ffi_clo_FS)\n-\tSEH(.allocstack ffi_clo_FS)\n-\tSEH(.endprolog)\n+        sub rsp, ffi_clo_FS ;subq       $ffi_clo_FS, %rsp\n+        cfi_adjust_cfa_offset(ffi_clo_FS)\n+        SEH(.allocstack ffi_clo_FS)\n+        SEH(.endprolog)\n@@ -212,5 +213,5 @@\n-\t\/* Save all sse arguments into the stack frame.  *\/\n-\tmovsd qword ptr [ffi_clo_OFF_X + rsp], xmm0\t; movsd\t%xmm0, ffi_clo_OFF_X(%rsp)\n-\tmovsd qword ptr [ffi_clo_OFF_X+8+rsp], xmm1 ; movsd\t%xmm1, ffi_clo_OFF_X+8(%rsp)\n-\tmovsd qword ptr [ffi_clo_OFF_X+16+rsp], xmm2 ; movsd %xmm2, ffi_clo_OFF_X+16(%rsp)\n-\tmovsd qword ptr [ffi_clo_OFF_X+24+rsp], xmm3 ; movsd %xmm3, ffi_clo_OFF_X+24(%rsp)\n+        \/* Save all sse arguments into the stack frame.  *\/\n+        movsd qword ptr [ffi_clo_OFF_X + rsp], xmm0     ; movsd %xmm0, ffi_clo_OFF_X(%rsp)\n+        movsd qword ptr [ffi_clo_OFF_X+8+rsp], xmm1 ; movsd     %xmm1, ffi_clo_OFF_X+8(%rsp)\n+        movsd qword ptr [ffi_clo_OFF_X+16+rsp], xmm2 ; movsd %xmm2, ffi_clo_OFF_X+16(%rsp)\n+        movsd qword ptr [ffi_clo_OFF_X+24+rsp], xmm3 ; movsd %xmm3, ffi_clo_OFF_X+24(%rsp)\n@@ -218,2 +219,2 @@\n-\tlea\tr9, [ffi_clo_OFF_R + rsp] ; leaq\tffi_clo_OFF_R(%rsp), %r9\n-\tcall C(ffi_closure_win64_inner)\n+        lea     r9, [ffi_clo_OFF_R + rsp] ; leaq        ffi_clo_OFF_R(%rsp), %r9\n+        call C(ffi_closure_win64_inner)\n@@ -221,1 +222,1 @@\n-\t\/* Load the result into both possible result registers.  *\/\n+        \/* Load the result into both possible result registers.  *\/\n@@ -223,2 +224,2 @@\n-\tmov rax, qword ptr [ffi_clo_OFF_R + rsp] ;movq    ffi_clo_OFF_R(%rsp), %rax\n-\tmovsd xmm0, qword ptr [rsp + ffi_clo_OFF_R] ;movsd   ffi_clo_OFF_R(%rsp), %xmm0\n+        mov rax, qword ptr [ffi_clo_OFF_R + rsp] ;movq    ffi_clo_OFF_R(%rsp), %rax\n+        movsd xmm0, qword ptr [rsp + ffi_clo_OFF_R] ;movsd   ffi_clo_OFF_R(%rsp), %xmm0\n@@ -226,3 +227,3 @@\n-\tadd rsp, ffi_clo_FS ;addq\t$ffi_clo_FS, %rsp\n-\tcfi_adjust_cfa_offset(-ffi_clo_FS)\n-\tret\n+        add rsp, ffi_clo_FS ;addq       $ffi_clo_FS, %rsp\n+        cfi_adjust_cfa_offset(-ffi_clo_FS)\n+        ret\n@@ -230,2 +231,2 @@\n-\tcfi_endproc\n-\tC(ffi_closure_win64) endp\n+        cfi_endproc\n+        C(ffi_closure_win64) endp\n@@ -234,1 +235,1 @@\n-\t.section\t.note.GNU-stack,\"\",@progbits\n+        .section        .note.GNU-stack,\"\",@progbits\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/libffi\/src\/x86\/win64_intel.S","additions":153,"deletions":152,"binary":false,"changes":305,"status":"modified"}]}