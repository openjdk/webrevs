{"files":[{"patch":"@@ -111,0 +111,4 @@\n+    \/*\n+     * Algorithm implemented based on the following specification:\n+     * https:\/\/www.w3.org\/TR\/css-easing-2\/#linear-easing-function-output\n+     *\/\n@@ -114,2 +118,0 @@\n-\n-        \/\/ Only a single control point: always return its output value.\n@@ -120,7 +122,1 @@\n-        \/\/ If t matches the x of one or more control points, return the y of the last such point.\n-        double lastMatchY = Double.NaN;\n-        for (int i = 0; i < n; ++i) {\n-            double x = controlPoints[2 * i];\n-            if (t < x) { \/\/ Xs are monotonically non-decreasing; no more matches possible\n-                break;\n-            }\n+        int pointAIndex = 0;\n@@ -128,55 +124,3 @@\n-            if (t == x) {\n-                lastMatchY = controlPoints[2 * i + 1];\n-            }\n-        }\n-\n-        if (!Double.isNaN(lastMatchY)) {\n-            return lastMatchY;\n-        }\n-\n-        double xFirst = controlPoints[0];\n-        double yFirst = controlPoints[1];\n-        double xLast  = controlPoints[2 * (n - 1)];\n-        double yLast  = controlPoints[2 * (n - 1) + 1];\n-        double ax, ay, bx, by;\n-\n-        \/\/ If t is smaller than any x, use the first segment.\n-        if (t < xFirst) {\n-            ax = xFirst;\n-            ay = yFirst;\n-            bx = controlPoints[2];\n-            by = controlPoints[3];\n-        }\n-        \/\/ If t is larger than any x, use the last segment.\n-        else if (t > xLast) {\n-            ax = controlPoints[2 * (n - 2)];\n-            ay = controlPoints[2 * (n - 2) + 1];\n-            bx = xLast;\n-            by = yLast;\n-        }\n-        \/\/ t is between first.x and last.x (and not equal to any x).\n-        else {\n-            int indexA = -1; \/\/ last point with x < t\n-            int indexB = -1; \/\/ first point with x > t\n-\n-            for (int i = 0; i < n; i++) {\n-                double x = controlPoints[2 * i];\n-                if (x < t) {\n-                    indexA = i;\n-                } else if (x > t) {\n-                    indexB = i;\n-                    break;\n-                }\n-            }\n-\n-            if (indexA < 0) {\n-                ax = xFirst;\n-                ay = yFirst;\n-            } else {\n-                ax = controlPoints[2 * indexA];\n-                ay = controlPoints[2 * indexA + 1];\n-            }\n-\n-            if (indexB < 0) {\n-                bx = xLast;\n-                by = yLast;\n+        for (int i = 0; i < n; ++i) {\n+            if (controlPoints[2 * i] <= t) {\n+                pointAIndex = i;\n@@ -184,2 +128,1 @@\n-                bx = controlPoints[2 * indexB];\n-                by = controlPoints[2 * indexB + 1];\n+                break;\n@@ -189,6 +132,2 @@\n-        double dx = bx - ax;\n-        double dy = by - ay;\n-\n-        \/\/ Degenerate vertical segment -> step\n-        if (dx == 0) {\n-            return ay;\n+        if (pointAIndex == n - 1) {\n+            --pointAIndex;\n@@ -197,4 +136,5 @@\n-        \/\/ Horizontal segment -> constant, avoids 0 * inf NaN\n-        if (dy == 0) {\n-            return ay;\n-        }\n+        int idx = pointAIndex * 2;\n+        double pointAInput = controlPoints[idx];\n+        double pointAOutput = controlPoints[idx + 1];\n+        double pointBInput = controlPoints[idx + 2];\n+        double pointBOutput = controlPoints[idx + 3];\n@@ -202,4 +142,2 @@\n-        \/\/ Linearly interpolate (or extrapolate) along the segment (ax, ay) -> (bx, by).\n-        double proportion = (t - ax) \/ dx;\n-        if (Double.isFinite(proportion)) {\n-            return ay + dy * proportion;\n+        if (pointAInput == pointBInput) {\n+            return pointBOutput;\n@@ -208,7 +146,6 @@\n-        \/\/ In case we overflow\/underflow to infinity, we return the signed infinity consistent with the line.\n-        double sign =\n-            Math.signum(dy)       \/\/ tells us whether we are extrapolating left or right of A\n-            * Math.signum(t - ax) \/\/ tells us the direction from A to B\n-            * Math.signum(dx);    \/\/ tells us whether the line goes up or down\n-\n-        return sign >= 0 ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n+        double progressFromPointA = t - pointAInput;\n+        double pointInputRange = pointBInput - pointAInput;\n+        double progressBetweenPoints = progressFromPointA \/ pointInputRange;\n+        double pointOutputRange = pointBOutput - pointAOutput;\n+        double outputFromLastPoint = progressBetweenPoints * pointOutputRange;\n+        return pointAOutput + outputFromLastPoint;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/scenario\/animation\/LinearInterpolator.java","additions":24,"deletions":87,"binary":false,"changes":111,"status":"modified"}]}