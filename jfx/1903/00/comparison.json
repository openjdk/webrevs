{"files":[{"patch":"@@ -1,1 +1,1 @@\n-3.45.3\n+3.50.4\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/VERSION.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-** version 3.49.1.  By combining all the individual C code files into this\n+** version 3.50.4.  By combining all the individual C code files into this\n@@ -21,1 +21,1 @@\n-** 873d4e274b4988d260ba8354a9718324a1c2 with changes in files:\n+** 4d8adfb30e03f9cf27f800a2c1ba3c48fb4c with changes in files:\n@@ -455,1 +455,1 @@\n-** <a href=\"http:\/\/www.fossil-scm.org\/\">Fossil configuration management\n+** <a href=\"http:\/\/fossil-scm.org\/\">Fossil configuration management\n@@ -468,3 +468,3 @@\n-#define SQLITE_VERSION        \"3.49.1\"\n-#define SQLITE_VERSION_NUMBER 3049001\n-#define SQLITE_SOURCE_ID      \"2025-02-18 13:38:58 873d4e274b4988d260ba8354a9718324a1c26187a4ab4c1cc0227c03d0f10e70\"\n+#define SQLITE_VERSION        \"3.50.4\"\n+#define SQLITE_VERSION_NUMBER 3050004\n+#define SQLITE_SOURCE_ID      \"2025-07-30 19:33:53 4d8adfb30e03f9cf27f800a2c1ba3c48fb4ca1b08b0f5ed59a4d5ecbf45e20a3\"\n@@ -1485,0 +1485,6 @@\n+** <li>[[SQLITE_FCNTL_BLOCK_ON_CONNECT]]\n+** The [SQLITE_FCNTL_BLOCK_ON_CONNECT] opcode is used to configure the\n+** VFS to block when taking a SHARED lock to connect to a wal mode database.\n+** This is used to implement the functionality associated with\n+** SQLITE_SETLK_BLOCK_ON_CONNECT.\n+**\n@@ -1581,0 +1587,1 @@\n+#define SQLITE_FCNTL_BLOCK_ON_CONNECT       44\n@@ -2311,1 +2318,1 @@\n-** the default size of lookaside memory on each [database connection].\n+** the default size of [lookaside memory] on each [database connection].\n@@ -2313,5 +2320,8 @@\n-** size of each lookaside buffer slot and the second is the number of\n-** slots allocated to each database connection.)^  ^(SQLITE_CONFIG_LOOKASIDE\n-** sets the <i>default<\/i> lookaside size. The [SQLITE_DBCONFIG_LOOKASIDE]\n-** option to [sqlite3_db_config()] can be used to change the lookaside\n-** configuration on individual connections.)^ <\/dd>\n+** size of each lookaside buffer slot (\"sz\") and the second is the number of\n+** slots allocated to each database connection (\"cnt\").)^\n+** ^(SQLITE_CONFIG_LOOKASIDE sets the <i>default<\/i> lookaside size.\n+** The [SQLITE_DBCONFIG_LOOKASIDE] option to [sqlite3_db_config()] can\n+** be used to change the lookaside configuration on individual connections.)^\n+** The [-DSQLITE_DEFAULT_LOOKASIDE] option can be used to change the\n+** default lookaside configuration at compile-time.\n+** <\/dd>\n@@ -2554,1 +2564,1 @@\n-** configuration of the lookaside memory allocator within a database\n+** configuration of the [lookaside memory allocator] within a database\n@@ -2561,1 +2571,2 @@\n-** ^The first argument (the third parameter to [sqlite3_db_config()] is a\n+** <ol>\n+** <li><p>The first argument (\"buf\") is a\n@@ -2563,9 +2574,18 @@\n-** ^The first argument after the SQLITE_DBCONFIG_LOOKASIDE verb\n-** may be NULL in which case SQLite will allocate the\n-** lookaside buffer itself using [sqlite3_malloc()]. ^The second argument is the\n-** size of each lookaside buffer slot.  ^The third argument is the number of\n-** slots.  The size of the buffer in the first argument must be greater than\n-** or equal to the product of the second and third arguments.  The buffer\n-** must be aligned to an 8-byte boundary.  ^If the second argument to\n-** SQLITE_DBCONFIG_LOOKASIDE is not a multiple of 8, it is internally\n-** rounded down to the next smaller multiple of 8.  ^(The lookaside memory\n+** The first argument may be NULL in which case SQLite will allocate the\n+** lookaside buffer itself using [sqlite3_malloc()].\n+** <li><P>The second argument (\"sz\") is the\n+** size of each lookaside buffer slot.  Lookaside is disabled if \"sz\"\n+** is less than 8.  The \"sz\" argument should be a multiple of 8 less than\n+** 65536.  If \"sz\" does not meet this constraint, it is reduced in size until\n+** it does.\n+** <li><p>The third argument (\"cnt\") is the number of slots. Lookaside is disabled\n+** if \"cnt\"is less than 1.  The \"cnt\" value will be reduced, if necessary, so\n+** that the product of \"sz\" and \"cnt\" does not exceed 2,147,418,112.  The \"cnt\"\n+** parameter is usually chosen so that the product of \"sz\" and \"cnt\" is less\n+** than 1,000,000.\n+** <\/ol>\n+** <p>If the \"buf\" argument is not NULL, then it must\n+** point to a memory buffer with a size that is greater than\n+** or equal to the product of \"sz\" and \"cnt\".\n+** The buffer must be aligned to an 8-byte boundary.\n+** The lookaside memory\n@@ -2574,2 +2594,1 @@\n-** when the \"current value\" returned by\n-** [sqlite3_db_status](D,[SQLITE_DBSTATUS_LOOKASIDE_USED],...) is zero.\n+** when the value returned by [SQLITE_DBSTATUS_LOOKASIDE_USED] is zero.\n@@ -2578,1 +2597,11 @@\n-** [SQLITE_BUSY].)^<\/dd>\n+** [SQLITE_BUSY].\n+** If the \"buf\" argument is NULL and an attempt\n+** to allocate memory based on \"sz\" and \"cnt\" fails, then\n+** lookaside is silently disabled.\n+** <p>\n+** The [SQLITE_CONFIG_LOOKASIDE] configuration option can be used to set the\n+** default lookaside configuration at initialization.  The\n+** [-DSQLITE_DEFAULT_LOOKASIDE] option can be used to set the default lookaside\n+** configuration at compile-time.  Typical values for lookaside are 1200 for\n+** \"sz\" and 40 to 100 for \"cnt\".\n+** <\/dd>\n@@ -3315,0 +3344,38 @@\n+\/*\n+** CAPI3REF: Set the Setlk Timeout\n+** METHOD: sqlite3\n+**\n+** This routine is only useful in SQLITE_ENABLE_SETLK_TIMEOUT builds. If\n+** the VFS supports blocking locks, it sets the timeout in ms used by\n+** eligible locks taken on wal mode databases by the specified database\n+** handle. In non-SQLITE_ENABLE_SETLK_TIMEOUT builds, or if the VFS does\n+** not support blocking locks, this function is a no-op.\n+**\n+** Passing 0 to this function disables blocking locks altogether. Passing\n+** -1 to this function requests that the VFS blocks for a long time -\n+** indefinitely if possible. The results of passing any other negative value\n+** are undefined.\n+**\n+** Internally, each SQLite database handle store two timeout values - the\n+** busy-timeout (used for rollback mode databases, or if the VFS does not\n+** support blocking locks) and the setlk-timeout (used for blocking locks\n+** on wal-mode databases). The sqlite3_busy_timeout() method sets both\n+** values, this function sets only the setlk-timeout value. Therefore,\n+** to configure separate busy-timeout and setlk-timeout values for a single\n+** database handle, call sqlite3_busy_timeout() followed by this function.\n+**\n+** Whenever the number of connections to a wal mode database falls from\n+** 1 to 0, the last connection takes an exclusive lock on the database,\n+** then checkpoints and deletes the wal file. While it is doing this, any\n+** new connection that tries to read from the database fails with an\n+** SQLITE_BUSY error. Or, if the SQLITE_SETLK_BLOCK_ON_CONNECT flag is\n+** passed to this API, the new connection blocks until the exclusive lock\n+** has been released.\n+*\/\n+SQLITE_API int sqlite3_setlk_timeout(sqlite3*, int ms, int flags);\n+\n+\/*\n+** CAPI3REF: Flags for sqlite3_setlk_timeout()\n+*\/\n+#define SQLITE_SETLK_BLOCK_ON_CONNECT 0x01\n+\n@@ -4334,1 +4401,1 @@\n-** with N URI parameters key\/values pairs in the array P.  The result from\n+** an array P of N URI Key\/Value pairs.  The result from\n@@ -5015,1 +5082,1 @@\n-** literals may be replaced by a [parameter] that matches one of following\n+** literals may be replaced by a [parameter] that matches one of the following\n@@ -5060,1 +5127,1 @@\n-** found in first character, which is removed, or in the absence of a BOM\n+** found in the first character, which is removed, or in the absence of a BOM\n@@ -5080,1 +5147,1 @@\n-** terminated.  If any NUL characters occurs at byte offsets less than\n+** terminated.  If any NUL characters occur at byte offsets less than\n@@ -5292,1 +5359,1 @@\n-** table column that is the origin of a particular result column in\n+** table column that is the origin of a particular result column in a\n@@ -5430,1 +5497,1 @@\n-** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1],\n+** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1]),\n@@ -5861,2 +5928,2 @@\n-** used inside of triggers, view, CHECK constraints, or other elements of\n-** the database schema.  This flags is especially recommended for SQL\n+** used inside of triggers, views, CHECK constraints, or other elements of\n+** the database schema.  This flag is especially recommended for SQL\n@@ -5893,1 +5960,1 @@\n-** sqlite3_create_window_function() is not NULL, then it is destructor for\n+** sqlite3_create_window_function() is not NULL, then it is the destructor for\n@@ -6293,1 +6360,1 @@\n-** object D and returns a pointer to that copy.  ^The [sqlite3_value] returned\n+** object V and returns a pointer to that copy.  ^The [sqlite3_value] returned\n@@ -6331,1 +6398,1 @@\n-** determined by the N parameter on first successful call.  Changing the\n+** determined by the N parameter on the first successful call.  Changing the\n@@ -6493,1 +6560,1 @@\n-** an attacker to invoke them.  Any agent that can invoke these interfaces\n+** attacker to invoke them.  Any agent that can invoke these interfaces\n@@ -6607,1 +6674,1 @@\n-** appear if the string where NUL terminated.  If any NUL characters occur\n+** appear if the string were NUL terminated.  If any NUL characters occur\n@@ -6665,1 +6732,1 @@\n-** If these routines are called from within the different thread\n+** If these routines are called from within a different thread\n@@ -7071,1 +7138,1 @@\n-** for the N-th database on database connection D, or a NULL pointer of N is\n+** for the N-th database on database connection D, or a NULL pointer if N is\n@@ -7166,1 +7233,1 @@\n-** will advanced to SQLITE_TXN_WRITE if any changes occur and there are\n+** will be advanced to SQLITE_TXN_WRITE if any changes occur and there are\n@@ -7175,1 +7242,1 @@\n-** to SQLITE_TXN_NONE at the next [ROLLBACK] or [COMMIT].<\/dd>\n+** SQLITE_TXN_NONE at the next [ROLLBACK] or [COMMIT].<\/dd>\n@@ -7326,0 +7393,2 @@\n+** ^The update hook is disabled by invoking sqlite3_update_hook()\n+** with a NULL pointer as the second parameter.\n@@ -7454,1 +7523,1 @@\n-** by all database connections within a single process.\n+** used by all database connections within a single process.\n@@ -7512,1 +7581,1 @@\n-** changes in future releases of SQLite.\n+** change in future releases of SQLite.\n@@ -7627,2 +7696,2 @@\n-** If that does not work, it constructs a name \"sqlite3_X_init\" where the\n-** X is consists of the lower-case equivalent of all ASCII alphabetic\n+** If that does not work, it constructs a name \"sqlite3_X_init\" where\n+** X consists of the lower-case equivalent of all ASCII alphabetic\n@@ -7699,1 +7768,1 @@\n-** entry point where as follows:\n+** entry point were as follows:\n@@ -7863,1 +7932,1 @@\n-** checked separately in byte code.  If the omit flag is change to true, then\n+** checked separately in byte code.  If the omit flag is changed to true, then\n@@ -7889,1 +7958,1 @@\n-** output to show the idxNum has hex instead of as decimal.  Another flag is\n+** output to show the idxNum as hex instead of as decimal.  Another flag is\n@@ -8030,1 +8099,1 @@\n-** when a new virtual table is be being created or reinitialized.\n+** when a new virtual table is being created or reinitialized.\n@@ -8195,1 +8264,1 @@\n-** on *ppBlob after this function it returns.\n+** on *ppBlob after this function returns.\n@@ -8315,1 +8384,1 @@\n-** incremental blob I\/O routines can only read or overwriting existing\n+** incremental blob I\/O routines can only read or overwrite existing\n@@ -8465,1 +8534,1 @@\n-** mutex.  The argument to sqlite3_mutex_alloc() must one of these\n+** mutex.  The argument to sqlite3_mutex_alloc() must be one of these\n@@ -8698,1 +8767,1 @@\n-** ^This interface returns a pointer the [sqlite3_mutex] object that\n+** ^This interface returns a pointer to the [sqlite3_mutex] object that\n@@ -8821,1 +8890,1 @@\n-** recognized by SQLite.  Applications can uses these routines to determine\n+** recognized by SQLite.  Applications can use these routines to determine\n@@ -8989,1 +9058,1 @@\n-** [sqlite3_str] object.  Applications must not used the pointer returned\n+** [sqlite3_str] object.  Applications must not use the pointer returned by\n@@ -9075,1 +9144,1 @@\n-** where too large (they were larger than the \"sz\" parameter to\n+** were too large (they were larger than the \"sz\" parameter to\n@@ -9159,1 +9228,1 @@\n-** the current value is always zero.)^\n+** the current value is always zero.<\/dd>)^\n@@ -9163,1 +9232,1 @@\n-** <dd>This parameter returns the number malloc attempts that might have\n+** <dd>This parameter returns the number of malloc attempts that might have\n@@ -9167,1 +9236,1 @@\n-** the current value is always zero.)^\n+** the current value is always zero.<\/dd>)^\n@@ -9171,1 +9240,1 @@\n-** <dd>This parameter returns the number malloc attempts that might have\n+** <dd>This parameter returns the number of malloc attempts that might have\n@@ -9175,1 +9244,1 @@\n-** the current value is always zero.)^\n+** the current value is always zero.<\/dd>)^\n@@ -9181,0 +9250,1 @@\n+** <\/dd>\n@@ -9189,1 +9259,1 @@\n-** value as DBSTATUS_CACHE_USED. Or, if one or more or the pager caches are\n+** value as DBSTATUS_CACHE_USED. Or, if one or more of the pager caches are\n@@ -9192,1 +9262,1 @@\n-** SQLITE_DBSTATUS_CACHE_USED_SHARED is always 0.\n+** SQLITE_DBSTATUS_CACHE_USED_SHARED is always 0.<\/dd>\n@@ -9202,0 +9272,1 @@\n+** <\/dd>\n@@ -9238,1 +9309,1 @@\n-** additional overhead. This parameter can be used help identify\n+** additional overhead. This parameter can be used to help identify\n@@ -9309,1 +9380,1 @@\n-** improvement performance through careful use of indices.<\/dd>\n+** improve performance through careful use of indices.<\/dd>\n@@ -9315,1 +9386,1 @@\n-** improvement performance by adding permanent indices that do not\n+** improve performance by adding permanent indices that do not\n@@ -9324,1 +9395,1 @@\n-** then the value returned by this statement status code is undefined.\n+** then the value returned by this statement status code is undefined.<\/dd>\n@@ -9329,1 +9400,1 @@\n-** [bound parameters] that might affect the query plan.\n+** [bound parameters] that might affect the query plan.<\/dd>\n@@ -9336,1 +9407,1 @@\n-** cycle.\n+** cycle.<\/dd>\n@@ -9346,1 +9417,1 @@\n-** had to be processed as normal.\n+** had to be processed as normal.<\/dd>\n@@ -9451,1 +9522,1 @@\n-** be allocated by the cache.  ^szPage will always a power of two.  ^The\n+** be allocated by the cache.  ^szPage will always be a power of two.  ^The\n@@ -9453,1 +9524,1 @@\n-** associated with each page cache entry.  ^The szExtra parameter will\n+** associated with each page cache entry.  ^The szExtra parameter will be\n@@ -9461,1 +9532,1 @@\n-** does not have to do anything special based with the value of bPurgeable;\n+** does not have to do anything special based upon the value of bPurgeable;\n@@ -9466,1 +9537,1 @@\n-** ^Hence, a cache created with bPurgeable false will\n+** ^Hence, a cache created with bPurgeable set to false will\n@@ -9471,1 +9542,1 @@\n-** suggested maximum cache-size (number of pages stored by) the cache\n+** suggested maximum cache-size (number of pages stored) for the cache\n@@ -9498,1 +9569,1 @@\n-** parameter to help it determined what action to take:\n+** parameter to help it determine what action to take:\n@@ -9503,1 +9574,1 @@\n-** <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.\n+** <tr><td> 1 <td> Allocate a new page if it is easy and convenient to do so.\n@@ -9520,1 +9591,1 @@\n-** zero, then the page may be discarded or retained at the discretion of\n+** zero, then the page may be discarded or retained at the discretion of the\n@@ -9538,1 +9609,1 @@\n-** of these pages are pinned, they are implicitly unpinned, meaning that\n+** of these pages are pinned, they become implicitly unpinned, meaning that\n@@ -9718,1 +9789,1 @@\n-** database is modified by the using the same database connection as is used\n+** database is modified by using the same database connection as is used\n@@ -9735,1 +9806,1 @@\n-** sqlite3_backup_step() errors occurred, regardless or whether or not\n+** sqlite3_backup_step() errors occurred, regardless of whether or not\n@@ -9837,1 +9908,1 @@\n-** when the blocking connections current transaction is concluded. ^The\n+** when the blocking connection's current transaction is concluded. ^The\n@@ -9857,1 +9928,1 @@\n-** unlock-notify callback is canceled. ^The blocked connections\n+** unlock-notify callback is canceled. ^The blocked connection's\n@@ -10255,1 +10326,1 @@\n-** specified as part of the users SQL statement, regardless of the actual\n+** specified as part of the user's SQL statement, regardless of the actual\n@@ -10289,1 +10360,1 @@\n-** the [xConnect] or [xCreate] methods of a [virtual table] implementation\n+** [xConnect] or [xCreate] methods of a [virtual table] implementation\n@@ -10457,1 +10528,1 @@\n-** values are same value for sorting purposes, two NULL values are considered\n+** values are the same value for sorting purposes, two NULL values are considered\n@@ -10467,1 +10538,1 @@\n-** the \"orderByConsumed\" flag is unset, the query planner will add extra\n+** \"orderByConsumed\" flag is unset, the query planner will add extra\n@@ -10564,1 +10635,1 @@\n-** processing use the [sqlite3_vtab_in()] interface in the\n+** processing using the [sqlite3_vtab_in()] interface in the\n@@ -10619,1 +10690,1 @@\n-** can return an result code other than SQLITE_OK or SQLITE_NOTFOUND if\n+** can return a result code other than SQLITE_OK or SQLITE_NOTFOUND if\n@@ -10647,2 +10718,2 @@\n-** inform a [virtual table] implementation what the [ON CONFLICT] mode\n-** is for the SQL statement being evaluated.\n+** inform a [virtual table] implementation of the [ON CONFLICT] mode\n+** for the SQL statement being evaluated.\n@@ -10688,1 +10759,1 @@\n-** iteration of the X-th loop.  If the query planner's estimates was accurate,\n+** iteration of the X-th loop.  If the query planner's estimate was accurate,\n@@ -10691,1 +10762,1 @@\n-** be the NLOOP value for the current loop.\n+** be the NLOOP value for the current loop.<\/dd>\n@@ -10696,1 +10767,1 @@\n-** used for the X-th loop.\n+** used for the X-th loop.<\/dd>\n@@ -10701,1 +10772,1 @@\n-** description for the X-th loop.\n+** description for the X-th loop.<\/dd>\n@@ -10707,1 +10778,1 @@\n-** column of an [EXPLAIN QUERY PLAN] query.\n+** column of an [EXPLAIN QUERY PLAN] query.<\/dd>\n@@ -10711,1 +10782,1 @@\n-** the id of the parent of the current query element, if applicable, or\n+** id of the parent of the current query element, if applicable, or\n@@ -10713,1 +10784,1 @@\n-** returned in the second column of an [EXPLAIN QUERY PLAN] query.\n+** returned in the second column of an [EXPLAIN QUERY PLAN] query.<\/dd>\n@@ -10720,1 +10791,1 @@\n-** set to -1.\n+** set to -1.<\/dd>\n@@ -10761,2 +10832,2 @@\n-** for. Query elements are numbered starting from zero. A value of -1 may be\n-** to query for statistics regarding the entire query. ^If idx is out of range\n+** for. Query elements are numbered starting from zero. A value of -1 may\n+** retrieve statistics for the entire query. ^If idx is out of range\n@@ -10805,1 +10876,1 @@\n-** [sqlite3_db_cacheflush(D)] interface invoked, any dirty\n+** [sqlite3_db_cacheflush(D)] interface is invoked, any dirty\n@@ -10919,2 +10990,2 @@\n-** the pre-update hook is invoked with SQLITE_DELETE. This is because the\n-** in this case the new values are not available. In this case, when a\n+** the pre-update hook is invoked with SQLITE_DELETE, because\n+** the new values are not yet available. In this case, when a\n@@ -11173,1 +11244,1 @@\n-** to disk if that database where backed up to disk.\n+** to disk if that database were backed up to disk.\n@@ -11182,1 +11253,1 @@\n-** is currently using for that database, or NULL if the no such contiguous\n+** is currently using for that database, or NULL if no such contiguous\n@@ -11253,1 +11324,1 @@\n-** It is not possible to deserialized into the TEMP database.  If the\n+** It is not possible to deserialize into the TEMP database.  If the\n@@ -11275,1 +11346,1 @@\n-  sqlite3_int64 szDb,     \/* Number bytes in the deserialization *\/\n+  sqlite3_int64 szDb,     \/* Number of bytes in the deserialization *\/\n@@ -11283,1 +11354,1 @@\n-** The following are allowed values for 6th argument (the F argument) to\n+** The following are allowed values for the 6th argument (the F argument) to\n@@ -11808,3 +11879,4 @@\n-** Or, if one field of a row is updated while a session is disabled, and\n-** another field of the same row is updated while the session is enabled, the\n-** resulting changeset will contain an UPDATE change that updates both fields.\n+** Or, if one field of a row is updated while a session is enabled, and\n+** then another field of the same row is updated while the session is disabled,\n+** the resulting changeset will contain an UPDATE change that updates both\n+** fields.\n@@ -11882,2 +11954,3 @@\n-** It an error if database zFrom does not exist or does not contain the\n-** required compatible table.\n+** Unless the call to this function is a no-op as described above, it is an\n+** error if database zFrom does not exist or does not contain the required\n+** compatible table.\n@@ -12018,1 +12091,1 @@\n-** <dt>SQLITE_CHANGESETAPPLY_INVERT <dd>\n+** <dt>SQLITE_CHANGESETSTART_INVERT <dd>\n@@ -12333,13 +12406,0 @@\n-\n-\/*\n-** CAPI3REF: Upgrade the Schema of a Changeset\/Patchset\n-*\/\n-SQLITE_API int sqlite3changeset_upgrade(\n-  sqlite3 *db,\n-  const char *zDb,\n-  int nIn, const void *pIn,       \/* Input changeset *\/\n-  int *pnOut, void **ppOut        \/* OUT: Inverse of input *\/\n-);\n-\n-\n-\n@@ -14093,1 +14153,1 @@\n-** The hard upper limit here is 32676.  Most database people will\n+** The hard upper limit here is 32767.  Most database people will\n@@ -14098,0 +14158,6 @@\n+**\n+** An index can only have SQLITE_MAX_COLUMN columns from the user\n+** point of view, but the underlying b-tree that implements the index\n+** might have up to twice as many columns in a WITHOUT ROWID table,\n+** since must also store the primary key at the end.  Hence the\n+** column count for Index is u16 instead of i16.\n@@ -14099,1 +14165,1 @@\n-#ifndef SQLITE_MAX_COLUMN\n+#if !defined(SQLITE_MAX_COLUMN)\n@@ -14101,0 +14167,2 @@\n+#elif SQLITE_MAX_COLUMN>32767\n+# error SQLITE_MAX_COLUMN may not exceed 32767\n@@ -14752,0 +14820,1 @@\n+  unsigned int h;              \/* hash for pKey *\/\n@@ -15112,1 +15181,11 @@\n-#define offsetof(STRUCTURE,FIELD) ((int)((char*)&((STRUCTURE*)0)->FIELD))\n+#define offsetof(STRUCTURE,FIELD) ((size_t)((char*)&((STRUCTURE*)0)->FIELD))\n+#endif\n+\n+\/*\n+** Work around C99 \"flex-array\" syntax for pre-C99 compilers, so as\n+** to avoid complaints from -fsanitize=strict-bounds.\n+*\/\n+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n+# define FLEXARRAY\n+#else\n+# define FLEXARRAY 1\n@@ -15190,0 +15269,5 @@\n+\/* A bitfield type for use inside of structures.  Always follow with :N where\n+** N is the number of bits.\n+*\/\n+typedef unsigned bft;  \/* Bit Field Type *\/\n+\n@@ -15358,0 +15442,8 @@\n+\/*\n+** Macro SMXV(n) return the maximum value that can be held in variable n,\n+** assuming n is a signed integer type.  UMXV(n) is similar for unsigned\n+** integer types.\n+*\/\n+#define SMXV(n) ((((i64)1)<<(sizeof(n)*8-1))-1)\n+#define UMXV(n) ((((i64)1)<<(sizeof(n)*8))-1)\n+\n@@ -17334,2 +17426,2 @@\n-\/* Use SQLITE_ENABLE_COMMENTS to enable generation of extra comments on\n-** each VDBE opcode.\n+\/* Use SQLITE_ENABLE_EXPLAIN_COMMENTS to enable generation of extra\n+** comments on each VDBE opcode.\n@@ -18058,0 +18150,4 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  int setlkTimeout;             \/* Blocking lock timeout, in msec. -1 -> inf. *\/\n+  int setlkFlags;               \/* Flags passed to setlk_timeout() *\/\n+#endif\n@@ -18612,0 +18708,1 @@\n+#define SQLITE_AFF_DEFER    0x58  \/* 'X'  - defer computation until later *\/\n@@ -18736,0 +18833,1 @@\n+  u8 aHx[16];          \/* Column aHt[K%sizeof(aHt)] might have hash K *\/\n@@ -18869,1 +18967,1 @@\n-  } aCol[1];            \/* One entry for each of nCol columns *\/\n+  } aCol[FLEXARRAY];      \/* One entry for each of nCol columns *\/\n@@ -18872,0 +18970,4 @@\n+\/* The size (in bytes) of an FKey object holding N columns.  The answer\n+** does NOT include space to hold the zTo name. *\/\n+#define SZ_FKEY(N)  (offsetof(FKey,aCol)+(N)*sizeof(struct sColMap))\n+\n@@ -18933,1 +19035,1 @@\n-  CollSeq *aColl[1];  \/* Collating sequence for each term of the key *\/\n+  CollSeq *aColl[FLEXARRAY]; \/* Collating sequence for each term of the key *\/\n@@ -18936,0 +19038,3 @@\n+\/* The size (in bytes) of a KeyInfo object with up to N fields *\/\n+#define SZ_KEYINFO(N)  (offsetof(KeyInfo,aColl) + (N)*sizeof(CollSeq*))\n+\n@@ -19055,1 +19160,1 @@\n-  u16 nColumn;             \/* Number of columns stored in the index *\/\n+  u16 nColumn;             \/* Nr columns in btree. Can be 2*Table.nCol *\/\n@@ -19064,1 +19169,0 @@\n-  unsigned bLowQual:1;     \/* sqlite_stat1 says this is a low-quality index *\/\n@@ -19154,1 +19258,1 @@\n-  u16 nSortingColumn;     \/* Number of columns in the sorting index *\/\n+  u32 nSortingColumn;     \/* Number of columns in the sorting index *\/\n@@ -19163,2 +19267,2 @@\n-    i16 iColumn;             \/* Column number within the source table *\/\n-    i16 iSorterColumn;       \/* Column number in the sorting index *\/\n+    int iColumn;             \/* Column number within the source table *\/\n+    int iSorterColumn;       \/* Column number in the sorting index *\/\n@@ -19339,0 +19443,1 @@\n+    int nReg;              \/* TK_NULLS: Number of registers to NULL out *\/\n@@ -19393,4 +19498,4 @@\n-#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)\n-#define ExprHasAllProperty(E,P)  (((E)->flags&(P))==(P))\n-#define ExprSetProperty(E,P)     (E)->flags|=(P)\n-#define ExprClearProperty(E,P)   (E)->flags&=~(P)\n+#define ExprHasProperty(E,P)     (((E)->flags&(u32)(P))!=0)\n+#define ExprHasAllProperty(E,P)  (((E)->flags&(u32)(P))==(u32)(P))\n+#define ExprSetProperty(E,P)     (E)->flags|=(u32)(P)\n+#define ExprClearProperty(E,P)   (E)->flags&=~(u32)(P)\n@@ -19508,1 +19613,1 @@\n-  } a[1];                  \/* One slot for each expression in the list *\/\n+  } a[FLEXARRAY];          \/* One slot for each expression in the list *\/\n@@ -19511,0 +19616,5 @@\n+\/* The size (in bytes) of an ExprList object that is big enough to hold\n+** as many as N expressions. *\/\n+#define SZ_EXPRLIST(N)  \\\n+             (offsetof(ExprList,a) + (N)*sizeof(struct ExprList_item))\n+\n@@ -19538,1 +19648,1 @@\n-  } a[1];\n+  } a[FLEXARRAY];\n@@ -19541,0 +19651,3 @@\n+\/* The size (in bytes) of an IdList object that can hold up to N IDs. *\/\n+#define SZ_IDLIST(N)  (offsetof(IdList,a)+(N)*sizeof(struct IdList_item))\n+\n@@ -19660,3 +19773,3 @@\n-  int nSrc;        \/* Number of tables or subqueries in the FROM clause *\/\n-  u32 nAlloc;      \/* Number of entries allocated in a[] below *\/\n-  SrcItem a[1];    \/* One entry for each identifier on the list *\/\n+  int nSrc;             \/* Number of tables or subqueries in the FROM clause *\/\n+  u32 nAlloc;           \/* Number of entries allocated in a[] below *\/\n+  SrcItem a[FLEXARRAY]; \/* One entry for each identifier on the list *\/\n@@ -19665,0 +19778,8 @@\n+\/* Size (in bytes) of a SrcList object that can hold as many as N\n+** SrcItem objects. *\/\n+#define SZ_SRCLIST(N) (offsetof(SrcList,a)+(N)*sizeof(SrcItem))\n+\n+\/* Size (in bytes( of a SrcList object that holds 1 SrcItem.  This is a\n+** special case of SZ_SRCITEM(1) that comes up often. *\/\n+#define SZ_SRCLIST_1  (offsetof(SrcList,a)+sizeof(SrcItem))\n+\n@@ -20133,2 +20254,1 @@\n-  u8 colNamesSet;      \/* TRUE after OP_ColumnName has been issued to pVdbe *\/\n-  u8 checkSchema;      \/* Causes schema cookie check after an error *\/\n+  LogEst nQueryLoop;   \/* Est number of iterations of a query (10*log2(N)) *\/\n@@ -20140,1 +20260,0 @@\n-  u8 okConstFactor;    \/* OK to factor out constants *\/\n@@ -20144,1 +20263,0 @@\n-  u8 bHasWith;         \/* True if statement contains WITH *\/\n@@ -20146,0 +20264,4 @@\n+  u8 eTriggerOp;       \/* TK_UPDATE, TK_INSERT or TK_DELETE *\/\n+  u8 bReturning;       \/* Coding a RETURNING trigger *\/\n+  u8 eOrconf;          \/* Default ON CONFLICT policy for trigger steps *\/\n+  u8 disableTriggers;  \/* True to disable triggers *\/\n@@ -20151,0 +20273,2 @@\n+  u8 isCreate;         \/* CREATE TABLE, INDEX, or VIEW (but not TRIGGER)\n+                       ** and ALTER TABLE ADD COLUMN. *\/\n@@ -20152,0 +20276,4 @@\n+  bft colNamesSet :1;   \/* TRUE after OP_ColumnName has been issued to pVdbe *\/\n+  bft bHasWith :1;      \/* True if statement contains WITH *\/\n+  bft okConstFactor :1; \/* OK to factor out constants *\/\n+  bft checkSchema :1;   \/* Causes schema cookie check after an error *\/\n@@ -20166,1 +20294,0 @@\n-  Token constraintName;\/* Name of the constraint currently being parsed *\/\n@@ -20169,3 +20296,1 @@\n-  int regRowid;        \/* Register holding rowid of CREATE TABLE entry *\/\n-  int regRoot;         \/* Register holding root page number for new objects *\/\n-  int nMaxArg;         \/* Max args passed to user function by sub-program *\/\n+  int nMaxArg;         \/* Max args to xUpdate and xFilter vtab methods *\/\n@@ -20185,11 +20310,0 @@\n-  union {\n-    int addrCrTab;         \/* Address of OP_CreateBtree on CREATE TABLE *\/\n-    Returning *pReturning; \/* The RETURNING clause *\/\n-  } u1;\n-  u32 oldmask;         \/* Mask of old.* columns referenced *\/\n-  u32 newmask;         \/* Mask of new.* columns referenced *\/\n-  LogEst nQueryLoop;   \/* Est number of iterations of a query (10*log2(N)) *\/\n-  u8 eTriggerOp;       \/* TK_UPDATE, TK_INSERT or TK_DELETE *\/\n-  u8 bReturning;       \/* Coding a RETURNING trigger *\/\n-  u8 eOrconf;          \/* Default ON CONFLICT policy for trigger steps *\/\n-  u8 disableTriggers;  \/* True to disable triggers *\/\n@@ -20207,0 +20321,13 @@\n+  u32 oldmask;            \/* Mask of old.* columns referenced *\/\n+  u32 newmask;            \/* Mask of new.* columns referenced *\/\n+  union {\n+    struct {  \/* These fields available when isCreate is true *\/\n+      int addrCrTab;        \/* Address of OP_CreateBtree on CREATE TABLE *\/\n+      int regRowid;         \/* Register holding rowid of CREATE TABLE entry *\/\n+      int regRoot;          \/* Register holding root page for new objects *\/\n+      Token constraintName; \/* Name of the constraint currently being parsed *\/\n+    } cr;\n+    struct {  \/* These fields available to all other statements *\/\n+      Returning *pReturning; \/* The RETURNING clause *\/\n+    } d;\n+  } u1;\n@@ -20722,1 +20849,1 @@\n-  Cte a[1];               \/* For each CTE in the WITH clause.... *\/\n+  Cte a[FLEXARRAY];       \/* For each CTE in the WITH clause.... *\/\n@@ -20725,0 +20852,4 @@\n+\/* The size (in bytes) of a With object that can hold as many\n+** as N different CTEs. *\/\n+#define SZ_WITH(N)  (offsetof(With,a) + (N)*sizeof(Cte))\n+\n@@ -20753,1 +20884,1 @@\n-  char zName[1];              \/* Name of this client data. MUST BE LAST *\/\n+  char zName[FLEXARRAY];      \/* Name of this client data. MUST BE LAST *\/\n@@ -20756,0 +20887,4 @@\n+\/* The size (in bytes) of a DbClientData object that can has a name\n+** that is N bytes long, including the zero-terminator. *\/\n+#define SZ_DBCLIENTDATA(N) (offsetof(DbClientData,zName)+(N))\n+\n@@ -21198,1 +21333,1 @@\n-SQLITE_PRIVATE i16 sqlite3TableColumnToIndex(Index*, i16);\n+SQLITE_PRIVATE int sqlite3TableColumnToIndex(Index*, int);\n@@ -21296,1 +21431,1 @@\n-SQLITE_PRIVATE Index *sqlite3AllocateIndexObject(sqlite3*,i16,int,char**);\n+SQLITE_PRIVATE Index *sqlite3AllocateIndexObject(sqlite3*,int,int,char**);\n@@ -21343,0 +21478,1 @@\n+SQLITE_PRIVATE void sqlite3ExprNullRegisterRange(Parse*, int, int);\n@@ -21432,1 +21568,2 @@\n-SQLITE_PRIVATE void sqlite3QuoteValue(StrAccum*,sqlite3_value*);\n+SQLITE_PRIVATE void sqlite3QuoteValue(StrAccum*,sqlite3_value*,int);\n+SQLITE_PRIVATE int sqlite3AppendOneUtf8Character(char*, u32);\n@@ -22297,0 +22434,3 @@\n+#ifdef SQLITE_BUG_COMPATIBLE_20250510\n+  \"BUG_COMPATIBLE_20250510\",\n+#endif\n@@ -22533,0 +22673,3 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  \"ENABLE_SETLK_TIMEOUT\",\n+#endif\n@@ -22587,0 +22730,3 @@\n+#ifdef SQLITE_EXTRA_INIT_MUTEXED\n+  \"EXTRA_INIT_MUTEXED=\" CTIMEOPT_VAL(SQLITE_EXTRA_INIT_MUTEXED),\n+#endif\n@@ -23571,4 +23717,3 @@\n-  \/* 2*nField extra array elements allocated for aType[], beyond the one\n-  ** static element declared in the structure.  nField total array slots for\n-  ** aType[] and nField+1 array slots for aOffset[] *\/\n-  u32 aType[1];           \/* Type values record decode.  MUST BE LAST *\/\n+  \/* Space is allocated for aType to hold at least 2*nField+1 entries:\n+  ** nField slots for aType[] and nField+1 array slots for aOffset[] *\/\n+  u32 aType[FLEXARRAY];    \/* Type values record decode.  MUST BE LAST *\/\n@@ -23577,0 +23722,8 @@\n+\/*\n+** The size (in bytes) of a VdbeCursor object that has an nField value of N\n+** or less.  The value of SZ_VDBECURSOR(n) is guaranteed to be a multiple\n+** of 8.\n+*\/\n+#define SZ_VDBECURSOR(N) \\\n+    (ROUND8(offsetof(VdbeCursor,aType)) + ((N)+1)*sizeof(u64))\n+\n@@ -23833,1 +23986,1 @@\n-  sqlite3_value *argv[1]; \/* Argument set *\/\n+  sqlite3_value *argv[FLEXARRAY]; \/* Argument set *\/\n@@ -23836,2 +23989,3 @@\n-\/* A bitfield type for use inside of structures.  Always follow with :N where\n-** N is the number of bits.\n+\/*\n+** The size (in bytes) of an sqlite3_context object that holds N\n+** argv[] arguments.\n@@ -23839,1 +23993,3 @@\n-typedef unsigned bft;  \/* Bit Field Type *\/\n+#define SZ_CONTEXT(N)  \\\n+   (offsetof(sqlite3_context,argv)+(N)*sizeof(sqlite3_value*))\n+\n@@ -23900,1 +24056,1 @@\n-  Mem **apArg;            \/* Arguments to currently executing user function *\/\n+  Mem **apArg;            \/* Arguments xUpdate and xFilter vtab methods *\/\n@@ -23920,0 +24076,1 @@\n+  int napArg;             \/* Size of the apArg[] array *\/\n@@ -23972,1 +24129,1 @@\n-  KeyInfo keyinfo;\n+  KeyInfo *pKeyinfo;              \/* Key information *\/\n@@ -23984,0 +24141,1 @@\n+  u8 keyinfoSpace[SZ_KEYINFO(0)]; \/* Space to hold pKeyinfo[0] content *\/\n@@ -24350,2 +24508,3 @@\n-  if( pHighwater ) *pHighwater = db->lookaside.nSlot - nInit;\n-  return db->lookaside.nSlot - (nInit+nFree);\n+  assert( db->lookaside.nSlot >= nInit+nFree );\n+  if( pHighwater ) *pHighwater = (int)(db->lookaside.nSlot - nInit);\n+  return (int)(db->lookaside.nSlot - (nInit+nFree));\n@@ -24404,1 +24563,1 @@\n-      *pHighwater = db->lookaside.anStat[op - SQLITE_DBSTATUS_LOOKASIDE_HIT];\n+      *pHighwater = (int)db->lookaside.anStat[op-SQLITE_DBSTATUS_LOOKASIDE_HIT];\n@@ -25916,1 +26075,1 @@\n-**   0=Sunday, 1=Monday, 2=Tues, ..., 6=Saturday\n+**   0=Sunday, 1=Monday, 2=Tuesday, ..., 6=Saturday\n@@ -30125,0 +30284,2 @@\n+# include <sys\/stat.h> \/* amalgamator: dontcache *\/\n+# include <unistd.h> \/* amalgamator: dontcache *\/\n@@ -31519,9 +31680,9 @@\n-#define etSQLESCAPE   9 \/* Strings with '\\'' doubled.  %q *\/\n-#define etSQLESCAPE2 10 \/* Strings with '\\'' doubled and enclosed in '',\n-                          NULL pointers replaced by SQL NULL.  %Q *\/\n-#define etTOKEN      11 \/* a pointer to a Token structure *\/\n-#define etSRCITEM    12 \/* a pointer to a SrcItem *\/\n-#define etPOINTER    13 \/* The %p conversion *\/\n-#define etSQLESCAPE3 14 \/* %w -> Strings with '\\\"' doubled *\/\n-#define etORDINAL    15 \/* %r -> 1st, 2nd, 3rd, 4th, etc.  English only *\/\n-#define etDECIMAL    16 \/* %d or %u, but not %x, %o *\/\n+#define etESCAPE_q    9  \/* Strings with '\\'' doubled.  %q *\/\n+#define etESCAPE_Q    10 \/* Strings with '\\'' doubled and enclosed in '',\n+                            NULL pointers replaced by SQL NULL.  %Q *\/\n+#define etTOKEN       11 \/* a pointer to a Token structure *\/\n+#define etSRCITEM     12 \/* a pointer to a SrcItem *\/\n+#define etPOINTER     13 \/* The %p conversion *\/\n+#define etESCAPE_w    14 \/* %w -> Strings with '\\\"' doubled *\/\n+#define etORDINAL     15 \/* %r -> 1st, 2nd, 3rd, 4th, etc.  English only *\/\n+#define etDECIMAL     16 \/* %d or %u, but not %x, %o *\/\n@@ -31529,1 +31690,1 @@\n-#define etINVALID    17 \/* Any unrecognized conversion type *\/\n+#define etINVALID     17 \/* Any unrecognized conversion type *\/\n@@ -31568,3 +31729,3 @@\n-  {  'q',  0, 4, etSQLESCAPE,  0,  0 },\n-  {  'Q',  0, 4, etSQLESCAPE2, 0,  0 },\n-  {  'w',  0, 4, etSQLESCAPE3, 0,  0 },\n+  {  'q',  0, 4, etESCAPE_q,   0,  0 },\n+  {  'Q',  0, 4, etESCAPE_Q,   0,  0 },\n+  {  'w',  0, 4, etESCAPE_w,   0,  0 },\n@@ -32167,19 +32328,1 @@\n-          if( ch<0x00080 ){\n-            buf[0] = ch & 0xff;\n-            length = 1;\n-          }else if( ch<0x00800 ){\n-            buf[0] = 0xc0 + (u8)((ch>>6)&0x1f);\n-            buf[1] = 0x80 + (u8)(ch & 0x3f);\n-            length = 2;\n-          }else if( ch<0x10000 ){\n-            buf[0] = 0xe0 + (u8)((ch>>12)&0x0f);\n-            buf[1] = 0x80 + (u8)((ch>>6) & 0x3f);\n-            buf[2] = 0x80 + (u8)(ch & 0x3f);\n-            length = 3;\n-          }else{\n-            buf[0] = 0xf0 + (u8)((ch>>18) & 0x07);\n-            buf[1] = 0x80 + (u8)((ch>>12) & 0x3f);\n-            buf[2] = 0x80 + (u8)((ch>>6) & 0x3f);\n-            buf[3] = 0x80 + (u8)(ch & 0x3f);\n-            length = 4;\n-          }\n+          length = sqlite3AppendOneUtf8Character(buf, ch);\n@@ -32265,3 +32408,3 @@\n-      case etSQLESCAPE:           \/* %q: Escape ' characters *\/\n-      case etSQLESCAPE2:          \/* %Q: Escape ' and enclose in '...' *\/\n-      case etSQLESCAPE3: {        \/* %w: Escape \" characters *\/\n+      case etESCAPE_q:          \/* %q: Escape ' characters *\/\n+      case etESCAPE_Q:          \/* %Q: Escape ' and enclose in '...' *\/\n+      case etESCAPE_w: {        \/* %w: Escape \" characters *\/\n@@ -32269,1 +32412,1 @@\n-        int needQuote, isnull;\n+        int needQuote = 0;\n@@ -32271,1 +32414,0 @@\n-        char q = ((xtype==etSQLESCAPE3)?'\"':'\\'');   \/* Quote character *\/\n@@ -32273,0 +32415,1 @@\n+        char q;\n@@ -32279,2 +32422,11 @@\n-        isnull = escarg==0;\n-        if( isnull ) escarg = (xtype==etSQLESCAPE2 ? \"NULL\" : \"(NULL)\");\n+        if( escarg==0 ){\n+          escarg = (xtype==etESCAPE_Q ? \"NULL\" : \"(NULL)\");\n+        }else if( xtype==etESCAPE_Q ){\n+          needQuote = 1;\n+        }\n+        if( xtype==etESCAPE_w ){\n+          q = '\"';\n+          flag_alternateform = 0;\n+        }else{\n+          q = '\\'';\n+        }\n@@ -32293,1 +32445,24 @@\n-        needQuote = !isnull && xtype==etSQLESCAPE2;\n+        if( flag_alternateform ){\n+          \/* For %#q, do unistr()-style backslash escapes for\n+          ** all control characters, and for backslash itself.\n+          ** For %#Q, do the same but only if there is at least\n+          ** one control character. *\/\n+          u32 nBack = 0;\n+          u32 nCtrl = 0;\n+          for(k=0; k<i; k++){\n+            if( escarg[k]=='\\\\' ){\n+              nBack++;\n+            }else if( ((u8*)escarg)[k]<=0x1f ){\n+              nCtrl++;\n+            }\n+          }\n+          if( nCtrl || xtype==etESCAPE_q ){\n+            n += nBack + 5*nCtrl;\n+            if( xtype==etESCAPE_Q ){\n+              n += 10;\n+              needQuote = 2;\n+            }\n+          }else{\n+            flag_alternateform = 0;\n+          }\n+        }\n@@ -32302,1 +32477,8 @@\n-        if( needQuote ) bufpt[j++] = q;\n+        if( needQuote ){\n+          if( needQuote==2 ){\n+            memcpy(&bufpt[j], \"unistr('\", 8);\n+            j += 8;\n+          }else{\n+            bufpt[j++] = '\\'';\n+          }\n+        }\n@@ -32304,3 +32486,25 @@\n-        for(i=0; i<k; i++){\n-          bufpt[j++] = ch = escarg[i];\n-          if( ch==q ) bufpt[j++] = ch;\n+        if( flag_alternateform ){\n+          for(i=0; i<k; i++){\n+            bufpt[j++] = ch = escarg[i];\n+            if( ch==q ){\n+              bufpt[j++] = ch;\n+            }else if( ch=='\\\\' ){\n+              bufpt[j++] = '\\\\';\n+            }else if( ((unsigned char)ch)<=0x1f ){\n+              bufpt[j-1] = '\\\\';\n+              bufpt[j++] = 'u';\n+              bufpt[j++] = '0';\n+              bufpt[j++] = '0';\n+              bufpt[j++] = ch>=0x10 ? '1' : '0';\n+              bufpt[j++] = \"0123456789abcdef\"[ch&0xf];\n+            }\n+          }\n+        }else{\n+          for(i=0; i<k; i++){\n+            bufpt[j++] = ch = escarg[i];\n+            if( ch==q ) bufpt[j++] = ch;\n+          }\n+        }\n+        if( needQuote ){\n+          bufpt[j++] = '\\'';\n+          if( needQuote==2 ) bufpt[j++] = ')';\n@@ -32308,1 +32512,0 @@\n-        if( needQuote ) bufpt[j++] = q;\n@@ -32551,1 +32754,1 @@\n-  zText = sqlite3DbMallocRaw(p->db, p->nChar+1 );\n+  zText = sqlite3DbMallocRaw(p->db, 1+(u64)p->nChar );\n@@ -32796,0 +32999,9 @@\n+\/* Maximum size of an sqlite3_log() message. *\/\n+#if defined(SQLITE_MAX_LOG_MESSAGE)\n+  \/* Leave the definition as supplied *\/\n+#elif SQLITE_PRINT_BUF_SIZE*10>10000\n+# define SQLITE_MAX_LOG_MESSAGE 10000\n+#else\n+# define SQLITE_MAX_LOG_MESSAGE (SQLITE_PRINT_BUF_SIZE*10)\n+#endif\n+\n@@ -32812,1 +33024,1 @@\n-  char zMsg[SQLITE_PRINT_BUF_SIZE*3];    \/* Complete log message *\/\n+  char zMsg[SQLITE_MAX_LOG_MESSAGE];     \/* Complete log message *\/\n@@ -34807,0 +35019,29 @@\n+\/*\n+** Write a single UTF8 character whose value is v into the\n+** buffer starting at zOut.  zOut must be sized to hold at\n+** least four bytes.  Return the number of bytes needed\n+** to encode the new character.\n+*\/\n+SQLITE_PRIVATE int sqlite3AppendOneUtf8Character(char *zOut, u32 v){\n+  if( v<0x00080 ){\n+    zOut[0] = (u8)(v & 0xff);\n+    return 1;\n+  }\n+  if( v<0x00800 ){\n+    zOut[0] = 0xc0 + (u8)((v>>6) & 0x1f);\n+    zOut[1] = 0x80 + (u8)(v & 0x3f);\n+    return 2;\n+  }\n+  if( v<0x10000 ){\n+    zOut[0] = 0xe0 + (u8)((v>>12) & 0x0f);\n+    zOut[1] = 0x80 + (u8)((v>>6) & 0x3f);\n+    zOut[2] = 0x80 + (u8)(v & 0x3f);\n+    return 3;\n+  }\n+  zOut[0] = 0xf0 + (u8)((v>>18) & 0x07);\n+  zOut[1] = 0x80 + (u8)((v>>12) & 0x3f);\n+  zOut[2] = 0x80 + (u8)((v>>6) & 0x3f);\n+  zOut[3] = 0x80 + (u8)(v & 0x3f);\n+  return 4;\n+}\n+\n@@ -35228,1 +35469,1 @@\n-  while( n<nChar && ALWAYS(z<=zEnd) ){\n+  while( n<nChar && z<=zEnd ){\n@@ -36403,1 +36644,5 @@\n-  while( ALWAYS(p->n>0) && p->z[p->n-1]=='0' ){ p->n--; }\n+  assert( p->n>0 );\n+  while( p->z[p->n-1]=='0' ){\n+    p->n--;\n+    assert( p->n>0 );\n+  }\n@@ -36908,1 +37153,1 @@\n-** Compute the absolute value of a 32-bit signed integer, of possible.  Or\n+** Compute the absolute value of a 32-bit signed integer, if possible.  Or\n@@ -37189,2 +37434,1 @@\n-  unsigned char c;\n-  while( (c = (unsigned char)*z++)!=0 ){     \/*OPTIMIZATION-IF-TRUE*\/\n+  while( z[0] ){     \/*OPTIMIZATION-IF-TRUE*\/\n@@ -37193,2 +37437,10 @@\n-    ** (2**32)*golden_ratio, where golden_ratio = (sqrt(5) - 1)\/2. *\/\n-    h += sqlite3UpperToLower[c];\n+    ** (2**32)*golden_ratio, where golden_ratio = (sqrt(5) - 1)\/2.\n+    **\n+    ** Only bits 0xdf for ASCII and bits 0xbf for EBCDIC each octet are\n+    ** hashed since the omitted bits determine the upper\/lower case difference.\n+    *\/\n+#ifdef SQLITE_EBCDIC\n+    h += 0xbf & (unsigned char)*(z++);\n+#else\n+    h += 0xdf & (unsigned char)*(z++);\n+#endif\n@@ -37267,1 +37519,0 @@\n-    unsigned int h = strHash(elem->pKey) % new_size;\n@@ -37269,1 +37520,1 @@\n-    insertElement(pH, &new_ht[h], elem);\n+    insertElement(pH, &new_ht[elem->h % new_size], elem);\n@@ -37287,1 +37538,1 @@\n-  static HashElem nullElement = { 0, 0, 0, 0 };\n+  static HashElem nullElement = { 0, 0, 0, 0, 0 };\n@@ -37289,0 +37540,1 @@\n+  h = strHash(pKey);\n@@ -37291,2 +37543,1 @@\n-    h = strHash(pKey) % pH->htsize;\n-    pEntry = &pH->ht[h];\n+    pEntry = &pH->ht[h % pH->htsize];\n@@ -37296,1 +37547,0 @@\n-    h = 0;\n@@ -37303,1 +37553,1 @@\n-    if( sqlite3StrICmp(elem->pKey,pKey)==0 ){\n+    if( h==elem->h && sqlite3StrICmp(elem->pKey,pKey)==0 ){\n@@ -37315,1 +37565,1 @@\n-static void removeElementGivenHash(\n+static void removeElement(\n@@ -37317,2 +37567,1 @@\n-  HashElem* elem,   \/* The element to be removed from the pH *\/\n-  unsigned int h    \/* Hash value for the element *\/\n+  HashElem *elem    \/* The element to be removed from the pH *\/\n@@ -37330,1 +37579,1 @@\n-    pEntry = &pH->ht[h];\n+    pEntry = &pH->ht[elem->h % pH->htsize];\n@@ -37381,1 +37630,1 @@\n-      removeElementGivenHash(pH,elem,h);\n+      removeElement(pH,elem);\n@@ -37392,0 +37641,1 @@\n+  new_elem->h = h;\n@@ -37394,5 +37644,2 @@\n-  if( pH->count>=10 && pH->count > 2*pH->htsize ){\n-    if( rehash(pH, pH->count*2) ){\n-      assert( pH->htsize>0 );\n-      h = strHash(pKey) % pH->htsize;\n-    }\n+  if( pH->count>=5 && pH->count > 2*pH->htsize ){\n+    rehash(pH, pH->count*3);\n@@ -37400,1 +37647,1 @@\n-  insertElement(pH, pH->ht ? &pH->ht[h] : 0, new_elem);\n+  insertElement(pH, pH->ht ? &pH->ht[new_elem->h % pH->htsize] : 0, new_elem);\n@@ -38883,0 +39130,1 @@\n+  int bBlockOnConnect;                \/* True to block for SHARED locks *\/\n@@ -40276,0 +40524,7 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    if( pFile->bBlockOnConnect && pLock->l_type==F_RDLCK\n+     && pLock->l_start==SHARED_FIRST && pLock->l_len==SHARED_SIZE\n+    ){\n+      rc = osFcntl(pFile->h, F_SETLKW, pLock);\n+    }else\n+#endif\n@@ -42637,0 +42892,1 @@\n+      int iNew = *(int*)pArg;\n@@ -42638,1 +42894,1 @@\n-      pFile->iBusyTimeout = *(int*)pArg;\n+      pFile->iBusyTimeout = iNew<0 ? 0x7FFFFFFF : (unsigned)iNew;\n@@ -42647,1 +42903,6 @@\n-#endif\n+    case SQLITE_FCNTL_BLOCK_ON_CONNECT: {\n+      int iNew = *(int*)pArg;\n+      pFile->bBlockOnConnect = iNew;\n+      return SQLITE_OK;\n+    }\n+#endif \/* SQLITE_ENABLE_SETLK_TIMEOUT *\/\n@@ -43620,3 +43881,4 @@\n-  **   1. Checkpointer lock (ofst==1).\n-  **   2. Write lock (ofst==0).\n-  **   3. Read locks (ofst>=3 && ofst<SQLITE_SHM_NLOCK).\n+  **   1. Recovery lock (ofst==2).\n+  **   2. Checkpointer lock (ofst==1).\n+  **   3. Write lock (ofst==0).\n+  **   4. Read locks (ofst>=3 && ofst<SQLITE_SHM_NLOCK).\n@@ -43627,2 +43889,0 @@\n-  **\n-  ** It is not permitted to block on the RECOVER lock.\n@@ -43630,1 +43890,1 @@\n-#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+#if defined(SQLITE_ENABLE_SETLK_TIMEOUT) && defined(SQLITE_DEBUG)\n@@ -43634,1 +43894,1 @@\n-          (ofst!=2)                                   \/* not RECOVER *\/\n+          (ofst!=2 || lockMask==0)\n@@ -45439,1 +45699,1 @@\n-  ** -DHAVE_NANOSLEEP=0 (perhaps in conjuction with -DHAVE_USLEEP if\n+  ** -DHAVE_NANOSLEEP=0 (perhaps in conjunction with -DHAVE_USLEEP if\n@@ -47160,0 +47420,4 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  DWORD iBusyTimeout;        \/* Wait this many millisec on locks *\/\n+  int bBlockOnConnect;\n+#endif\n@@ -47162,0 +47426,6 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+# define winFileBusyTimeout(pDbFd) pDbFd->iBusyTimeout\n+#else\n+# define winFileBusyTimeout(pDbFd) 0\n+#endif\n+\n@@ -47480,1 +47750,1 @@\n-#define osFileTimeToLocalFileTime ((BOOL(WINAPI*)(CONST FILETIME*, \\\n+#define osFileTimeToLocalFileTime ((BOOL(WINAPI*)(const FILETIME*, \\\n@@ -47489,1 +47759,1 @@\n-#define osFileTimeToSystemTime ((BOOL(WINAPI*)(CONST FILETIME*, \\\n+#define osFileTimeToSystemTime ((BOOL(WINAPI*)(const FILETIME*, \\\n@@ -47595,0 +47865,6 @@\n+\/*\n+** For GetLastError(), MSDN says:\n+**\n+** Minimum supported client: Windows XP [desktop apps | UWP apps]\n+** Minimum supported server: Windows Server 2003 [desktop apps | UWP apps]\n+*\/\n@@ -47763,1 +48039,1 @@\n-#ifndef osLockFile\n+#if !defined(osLockFile) && defined(SQLITE_WIN32_HAS_ANSI)\n@@ -47827,1 +48103,1 @@\n-#define osSystemTimeToFileTime ((BOOL(WINAPI*)(CONST SYSTEMTIME*, \\\n+#define osSystemTimeToFileTime ((BOOL(WINAPI*)(const SYSTEMTIME*, \\\n@@ -47836,1 +48112,1 @@\n-#ifndef osUnlockFile\n+#if !defined(osUnlockFile) && defined(SQLITE_WIN32_HAS_ANSI)\n@@ -47877,1 +48153,6 @@\n-#if !SQLITE_OS_WINRT\n+\/*\n+** For WaitForSingleObject(), MSDN says:\n+**\n+** Minimum supported client: Windows XP [desktop apps | UWP apps]\n+** Minimum supported server: Windows Server 2003 [desktop apps | UWP apps]\n+*\/\n@@ -47879,3 +48160,0 @@\n-#else\n-  { \"WaitForSingleObject\",     (SYSCALL)0,                       0 },\n-#endif\n@@ -48028,0 +48306,91 @@\n+\/*\n+** If SQLITE_ENABLE_SETLK_TIMEOUT is defined, we require CreateEvent()\n+** to implement blocking locks with timeouts. MSDN says:\n+**\n+** Minimum supported client: Windows XP [desktop apps | UWP apps]\n+** Minimum supported server: Windows Server 2003 [desktop apps | UWP apps]\n+*\/\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  { \"CreateEvent\",              (SYSCALL)CreateEvent,            0 },\n+#else\n+  { \"CreateEvent\",              (SYSCALL)0,                      0 },\n+#endif\n+\n+#define osCreateEvent ( \\\n+    (HANDLE(WINAPI*) (LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCSTR)) \\\n+    aSyscall[80].pCurrent \\\n+)\n+\n+\/*\n+** If SQLITE_ENABLE_SETLK_TIMEOUT is defined, we require CancelIo()\n+** for the case where a timeout expires and a lock request must be\n+** cancelled.\n+**\n+** Minimum supported client: Windows XP [desktop apps | UWP apps]\n+** Minimum supported server: Windows Server 2003 [desktop apps | UWP apps]\n+*\/\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  { \"CancelIo\",                 (SYSCALL)CancelIo,               0 },\n+#else\n+  { \"CancelIo\",                 (SYSCALL)0,                      0 },\n+#endif\n+\n+#define osCancelIo ((BOOL(WINAPI*)(HANDLE))aSyscall[81].pCurrent)\n+\n+#if defined(SQLITE_WIN32_HAS_WIDE) && defined(_WIN32)\n+  { \"GetModuleHandleW\",         (SYSCALL)GetModuleHandleW,       0 },\n+#else\n+  { \"GetModuleHandleW\",         (SYSCALL)0,                      0 },\n+#endif\n+\n+#define osGetModuleHandleW ((HMODULE(WINAPI*)(LPCWSTR))aSyscall[82].pCurrent)\n+\n+#ifndef _WIN32\n+  { \"getenv\",                   (SYSCALL)getenv,                 0 },\n+#else\n+  { \"getenv\",                   (SYSCALL)0,                      0 },\n+#endif\n+\n+#define osGetenv ((const char *(*)(const char *))aSyscall[83].pCurrent)\n+\n+#ifndef _WIN32\n+  { \"getcwd\",                   (SYSCALL)getcwd,                 0 },\n+#else\n+  { \"getcwd\",                   (SYSCALL)0,                      0 },\n+#endif\n+\n+#define osGetcwd ((char*(*)(char*,size_t))aSyscall[84].pCurrent)\n+\n+#ifndef _WIN32\n+  { \"readlink\",                 (SYSCALL)readlink,               0 },\n+#else\n+  { \"readlink\",                 (SYSCALL)0,                      0 },\n+#endif\n+\n+#define osReadlink ((ssize_t(*)(const char*,char*,size_t))aSyscall[85].pCurrent)\n+\n+#ifndef _WIN32\n+  { \"lstat\",                    (SYSCALL)lstat,                  0 },\n+#else\n+  { \"lstat\",                    (SYSCALL)0,                      0 },\n+#endif\n+\n+#define osLstat ((int(*)(const char*,struct stat*))aSyscall[86].pCurrent)\n+\n+#ifndef _WIN32\n+  { \"__errno\",                  (SYSCALL)__errno,                0 },\n+#else\n+  { \"__errno\",                  (SYSCALL)0,                      0 },\n+#endif\n+\n+#define osErrno (*((int*(*)(void))aSyscall[87].pCurrent)())\n+\n+#ifndef _WIN32\n+  { \"cygwin_conv_path\",         (SYSCALL)cygwin_conv_path,       0 },\n+#else\n+  { \"cygwin_conv_path\",         (SYSCALL)0,                      0 },\n+#endif\n+\n+#define osCygwin_conv_path ((size_t(*)(unsigned int, \\\n+    const void *, void *, size_t))aSyscall[88].pCurrent)\n+\n@@ -48201,0 +48570,1 @@\n+#ifdef _WIN32\n@@ -48243,0 +48613,1 @@\n+#endif \/* _WIN32 *\/\n@@ -48326,1 +48697,3 @@\n-  return osInterlockedCompareExchange(&sqlite3_os_type, 2, 2)==2;\n+  return osInterlockedCompareExchange(&sqlite3_os_type, 2, 2)==2\n+      || osInterlockedCompareExchange(&sqlite3_os_type, 0, 0)==0\n+  ;\n@@ -48541,0 +48914,1 @@\n+#ifdef _WIN32\n@@ -48566,0 +48940,1 @@\n+#endif \/* _WIN32 *\/\n@@ -48600,1 +48975,1 @@\n-  int nByte;\n+  int nWideChar;\n@@ -48604,3 +48979,3 @@\n-  nByte = osMultiByteToWideChar(codepage, 0, zText, -1, NULL,\n-                                0)*sizeof(WCHAR);\n-  if( nByte==0 ){\n+  nWideChar = osMultiByteToWideChar(codepage, 0, zText, -1, NULL,\n+                                0);\n+  if( nWideChar==0 ){\n@@ -48609,1 +48984,1 @@\n-  zMbcsText = sqlite3MallocZero( nByte*sizeof(WCHAR) );\n+  zMbcsText = sqlite3MallocZero( nWideChar*sizeof(WCHAR) );\n@@ -48613,3 +48988,3 @@\n-  nByte = osMultiByteToWideChar(codepage, 0, zText, -1, zMbcsText,\n-                                nByte);\n-  if( nByte==0 ){\n+  nWideChar = osMultiByteToWideChar(codepage, 0, zText, -1, zMbcsText,\n+                                nWideChar);\n+  if( nWideChar==0 ){\n@@ -48622,0 +48997,1 @@\n+#ifdef _WIN32\n@@ -48649,0 +49025,1 @@\n+#endif \/* _WIN32 *\/\n@@ -48668,0 +49045,1 @@\n+#ifdef _WIN32\n@@ -48717,0 +49095,1 @@\n+#endif \/* _WIN32 *\/\n@@ -48734,0 +49113,1 @@\n+#ifdef _WIN32\n@@ -48858,0 +49238,1 @@\n+#endif \/* _WIN32 *\/\n@@ -49406,0 +49787,1 @@\n+#ifdef SQLITE_WIN32_HAS_ANSI\n@@ -49409,0 +49791,1 @@\n+#endif\n@@ -49413,0 +49796,83 @@\n+\/*\n+** Lock a region of nByte bytes starting at offset offset of file hFile.\n+** Take an EXCLUSIVE lock if parameter bExclusive is true, or a SHARED lock\n+** otherwise. If nMs is greater than zero and the lock cannot be obtained\n+** immediately, block for that many ms before giving up.\n+**\n+** This function returns SQLITE_OK if the lock is obtained successfully. If\n+** some other process holds the lock, SQLITE_BUSY is returned if nMs==0, or\n+** SQLITE_BUSY_TIMEOUT otherwise. Or, if an error occurs, SQLITE_IOERR.\n+*\/\n+static int winHandleLockTimeout(\n+  HANDLE hFile,\n+  DWORD offset,\n+  DWORD nByte,\n+  int bExcl,\n+  DWORD nMs\n+){\n+  DWORD flags = LOCKFILE_FAIL_IMMEDIATELY | (bExcl?LOCKFILE_EXCLUSIVE_LOCK:0);\n+  int rc = SQLITE_OK;\n+  BOOL ret;\n+\n+  if( !osIsNT() ){\n+    ret = winLockFile(&hFile, flags, offset, 0, nByte, 0);\n+  }else{\n+    OVERLAPPED ovlp;\n+    memset(&ovlp, 0, sizeof(OVERLAPPED));\n+    ovlp.Offset = offset;\n+\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    if( nMs!=0 ){\n+      flags &= ~LOCKFILE_FAIL_IMMEDIATELY;\n+    }\n+    ovlp.hEvent = osCreateEvent(NULL, TRUE, FALSE, NULL);\n+    if( ovlp.hEvent==NULL ){\n+      return SQLITE_IOERR_LOCK;\n+    }\n+#endif\n+\n+    ret = osLockFileEx(hFile, flags, 0, nByte, 0, &ovlp);\n+\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    \/* If SQLITE_ENABLE_SETLK_TIMEOUT is defined, then the file-handle was\n+    ** opened with FILE_FLAG_OVERHEAD specified. In this case, the call to\n+    ** LockFileEx() may fail because the request is still pending. This can\n+    ** happen even if LOCKFILE_FAIL_IMMEDIATELY was specified.\n+    **\n+    ** If nMs is 0, then LOCKFILE_FAIL_IMMEDIATELY was set in the flags\n+    ** passed to LockFileEx(). In this case, if the operation is pending,\n+    ** block indefinitely until it is finished.\n+    **\n+    ** Otherwise, wait for up to nMs ms for the operation to finish. nMs\n+    ** may be set to INFINITE.\n+    *\/\n+    if( !ret && GetLastError()==ERROR_IO_PENDING ){\n+      DWORD nDelay = (nMs==0 ? INFINITE : nMs);\n+      DWORD res = osWaitForSingleObject(ovlp.hEvent, nDelay);\n+      if( res==WAIT_OBJECT_0 ){\n+        ret = TRUE;\n+      }else if( res==WAIT_TIMEOUT ){\n+#if SQLITE_ENABLE_SETLK_TIMEOUT==1\n+        rc = SQLITE_BUSY_TIMEOUT;\n+#else\n+        rc = SQLITE_BUSY;\n+#endif\n+      }else{\n+        \/* Some other error has occurred *\/\n+        rc = SQLITE_IOERR_LOCK;\n+      }\n+\n+      \/* If it is still pending, cancel the LockFileEx() call. *\/\n+      osCancelIo(hFile);\n+    }\n+\n+    osCloseHandle(ovlp.hEvent);\n+#endif\n+  }\n+\n+  if( rc==SQLITE_OK && !ret ){\n+    rc = SQLITE_BUSY;\n+  }\n+  return rc;\n+}\n+\n@@ -49437,0 +49903,1 @@\n+#ifdef SQLITE_WIN32_HAS_ANSI\n@@ -49440,0 +49907,1 @@\n+#endif\n@@ -49444,0 +49912,8 @@\n+\/*\n+** Remove an nByte lock starting at offset iOff from HANDLE h.\n+*\/\n+static int winHandleUnlock(HANDLE h, int iOff, int nByte){\n+  BOOL ret = winUnlockFile(&h, iOff, 0, nByte, 0);\n+  return (ret ? SQLITE_OK : SQLITE_IOERR_UNLOCK);\n+}\n+\n@@ -49457,3 +49933,4 @@\n-** Move the current position of the file handle passed as the first\n-** argument to offset iOffset within the file. If successful, return 0.\n-** Otherwise, set pFile->lastErrno and return non-zero.\n+** Seek the file handle h to offset nByte of the file.\n+**\n+** If successful, return SQLITE_OK. Or, if an error occurs, return an SQLite\n+** error code.\n@@ -49461,1 +49938,3 @@\n-static int winSeekFile(winFile *pFile, sqlite3_int64 iOffset){\n+static int winHandleSeek(HANDLE h, sqlite3_int64 iOffset){\n+  int rc = SQLITE_OK;             \/* Return value *\/\n+\n@@ -49466,3 +49945,0 @@\n-  DWORD lastErrno;                \/* Value returned by GetLastError() *\/\n-\n-  OSTRACE((\"SEEK file=%p, offset=%lld\\n\", pFile->h, iOffset));\n@@ -49473,0 +49949,2 @@\n+  dwRet = osSetFilePointer(h, lowerBits, &upperBits, FILE_BEGIN);\n+\n@@ -49478,11 +49956,6 @@\n-  ** GetLastError().\n-  *\/\n-  dwRet = osSetFilePointer(pFile->h, lowerBits, &upperBits, FILE_BEGIN);\n-\n-  if( (dwRet==INVALID_SET_FILE_POINTER\n-      && ((lastErrno = osGetLastError())!=NO_ERROR)) ){\n-    pFile->lastErrno = lastErrno;\n-    winLogError(SQLITE_IOERR_SEEK, pFile->lastErrno,\n-                \"winSeekFile\", pFile->zPath);\n-    OSTRACE((\"SEEK file=%p, rc=SQLITE_IOERR_SEEK\\n\", pFile->h));\n-    return 1;\n+  ** GetLastError().  *\/\n+  if( dwRet==INVALID_SET_FILE_POINTER ){\n+    DWORD lastErrno = osGetLastError();\n+    if( lastErrno!=NO_ERROR ){\n+      rc = SQLITE_IOERR_SEEK;\n+    }\n@@ -49490,3 +49963,0 @@\n-\n-  OSTRACE((\"SEEK file=%p, rc=SQLITE_OK\\n\", pFile->h));\n-  return 0;\n@@ -49494,4 +49964,1 @@\n-  \/*\n-  ** Same as above, except that this implementation works for WinRT.\n-  *\/\n-\n+  \/* This implementation works for WinRT. *\/\n@@ -49502,1 +49969,1 @@\n-  bRet = osSetFilePointerEx(pFile->h, x, 0, FILE_BEGIN);\n+  bRet = osSetFilePointerEx(h, x, 0, FILE_BEGIN);\n@@ -49505,5 +49972,1 @@\n-    pFile->lastErrno = osGetLastError();\n-    winLogError(SQLITE_IOERR_SEEK, pFile->lastErrno,\n-                \"winSeekFile\", pFile->zPath);\n-    OSTRACE((\"SEEK file=%p, rc=SQLITE_IOERR_SEEK\\n\", pFile->h));\n-    return 1;\n+    rc = SQLITE_IOERR_SEEK;\n@@ -49511,3 +49974,0 @@\n-\n-  OSTRACE((\"SEEK file=%p, rc=SQLITE_OK\\n\", pFile->h));\n-  return 0;\n@@ -49515,0 +49975,3 @@\n+\n+  OSTRACE((\"SEEK file=%p, offset=%lld rc=%s\\n\", h, iOffset, sqlite3ErrName(rc)));\n+  return rc;\n@@ -49517,0 +49980,17 @@\n+\/*\n+** Move the current position of the file handle passed as the first\n+** argument to offset iOffset within the file. If successful, return 0.\n+** Otherwise, set pFile->lastErrno and return non-zero.\n+*\/\n+static int winSeekFile(winFile *pFile, sqlite3_int64 iOffset){\n+  int rc;\n+\n+  rc = winHandleSeek(pFile->h, iOffset);\n+  if( rc!=SQLITE_OK ){\n+    pFile->lastErrno = osGetLastError();\n+    winLogError(rc, pFile->lastErrno, \"winSeekFile\", pFile->zPath);\n+  }\n+  return rc;\n+}\n+\n+\n@@ -49776,0 +50256,54 @@\n+\/*\n+** Truncate the file opened by handle h to nByte bytes in size.\n+*\/\n+static int winHandleTruncate(HANDLE h, sqlite3_int64 nByte){\n+  int rc = SQLITE_OK;             \/* Return code *\/\n+  rc = winHandleSeek(h, nByte);\n+  if( rc==SQLITE_OK ){\n+    if( 0==osSetEndOfFile(h) ){\n+      rc = SQLITE_IOERR_TRUNCATE;\n+    }\n+  }\n+  return rc;\n+}\n+\n+\/*\n+** Determine the size in bytes of the file opened by the handle passed as\n+** the first argument.\n+*\/\n+static int winHandleSize(HANDLE h, sqlite3_int64 *pnByte){\n+  int rc = SQLITE_OK;\n+\n+#if SQLITE_OS_WINRT\n+  FILE_STANDARD_INFO info;\n+  BOOL b;\n+  b = osGetFileInformationByHandleEx(h, FileStandardInfo, &info, sizeof(info));\n+  if( b ){\n+    *pnByte = info.EndOfFile.QuadPart;\n+  }else{\n+    rc = SQLITE_IOERR_FSTAT;\n+  }\n+#else\n+  DWORD upperBits = 0;\n+  DWORD lowerBits = 0;\n+\n+  assert( pnByte );\n+  lowerBits = osGetFileSize(h, &upperBits);\n+  *pnByte = (((sqlite3_int64)upperBits)<<32) + lowerBits;\n+  if( lowerBits==INVALID_FILE_SIZE && osGetLastError()!=NO_ERROR ){\n+    rc = SQLITE_IOERR_FSTAT;\n+  }\n+#endif\n+\n+  return rc;\n+}\n+\n+\/*\n+** Close the handle passed as the only argument.\n+*\/\n+static void winHandleClose(HANDLE h){\n+  if( h!=INVALID_HANDLE_VALUE ){\n+    osCloseHandle(h);\n+  }\n+}\n+\n@@ -50031,1 +50565,1 @@\n-static int winGetReadLock(winFile *pFile){\n+static int winGetReadLock(winFile *pFile, int bBlock){\n@@ -50033,0 +50567,1 @@\n+  DWORD mask = ~(bBlock ? LOCKFILE_FAIL_IMMEDIATELY : 0);\n@@ -50042,1 +50577,1 @@\n-    res = winLockFile(&pFile->h, SQLITE_LOCKFILEEX_FLAGS, SHARED_FIRST, 0,\n+    res = winLockFile(&pFile->h, SQLITE_LOCKFILEEX_FLAGS&mask, SHARED_FIRST, 0,\n@@ -50051,1 +50586,1 @@\n-    res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS,\n+    res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS&mask,\n@@ -50146,1 +50681,1 @@\n-  \/* Lock the PENDING_LOCK byte if we need to acquire a PENDING lock or\n+  \/* Lock the PENDING_LOCK byte if we need to acquire an EXCLUSIVE lock or\n@@ -50151,2 +50686,2 @@\n-  if( pFile->locktype==NO_LOCK\n-   || (locktype==EXCLUSIVE_LOCK && pFile->locktype<=RESERVED_LOCK)\n+  if( locktype==SHARED_LOCK\n+   || (locktype==EXCLUSIVE_LOCK && pFile->locktype==RESERVED_LOCK)\n@@ -50155,2 +50690,9 @@\n-    while( cnt-->0 && (res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS,\n-                                         PENDING_BYTE, 0, 1, 0))==0 ){\n+\n+    \/* Flags for the LockFileEx() call. This should be an exclusive lock if\n+    ** this call is to obtain EXCLUSIVE, or a shared lock if this call is to\n+    ** obtain SHARED.  *\/\n+    int flags = LOCKFILE_FAIL_IMMEDIATELY;\n+    if( locktype==EXCLUSIVE_LOCK ){\n+      flags |= LOCKFILE_EXCLUSIVE_LOCK;\n+    }\n+    while( cnt>0 ){\n@@ -50160,0 +50702,1 @@\n+      **\n@@ -50161,2 +50704,4 @@\n-      ** copy this retry logic.  It is a hack intended for Windows only.\n-      *\/\n+      ** copy this retry logic.  It is a hack intended for Windows only.  *\/\n+      res = winLockFile(&pFile->h, flags, PENDING_BYTE, 0, 1, 0);\n+      if( res ) break;\n+\n@@ -50165,1 +50710,3 @@\n-               pFile->h, cnt, res));\n+            pFile->h, cnt, res\n+      ));\n+\n@@ -50170,1 +50717,2 @@\n-                 pFile->h, cnt, sqlite3ErrName(rc)));\n+              pFile->h, cnt, sqlite3ErrName(rc)\n+        ));\n@@ -50173,1 +50721,3 @@\n-      if( cnt ) sqlite3_win32_sleep(1);\n+\n+      cnt--;\n+      if( cnt>0 ) sqlite3_win32_sleep(1);\n@@ -50176,3 +50726,0 @@\n-    if( !res ){\n-      lastErrno = osGetLastError();\n-    }\n@@ -50185,1 +50732,5 @@\n-    res = winGetReadLock(pFile);\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    res = winGetReadLock(pFile, pFile->bBlockOnConnect);\n+#else\n+    res = winGetReadLock(pFile, 0);\n+#endif\n@@ -50223,1 +50774,1 @@\n-      winGetReadLock(pFile);\n+      winGetReadLock(pFile, 0);\n@@ -50303,1 +50854,1 @@\n-    if( locktype==SHARED_LOCK && !winGetReadLock(pFile) ){\n+    if( locktype==SHARED_LOCK && !winGetReadLock(pFile, 0) ){\n@@ -50513,0 +51064,22 @@\n+\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    case SQLITE_FCNTL_LOCK_TIMEOUT: {\n+      int iOld = pFile->iBusyTimeout;\n+      int iNew = *(int*)pArg;\n+#if SQLITE_ENABLE_SETLK_TIMEOUT==1\n+      pFile->iBusyTimeout = (iNew < 0) ? INFINITE : (DWORD)iNew;\n+#elif SQLITE_ENABLE_SETLK_TIMEOUT==2\n+      pFile->iBusyTimeout = (DWORD)(!!iNew);\n+#else\n+# error \"SQLITE_ENABLE_SETLK_TIMEOUT must be set to 1 or 2\"\n+#endif\n+      *(int*)pArg = iOld;\n+      return SQLITE_OK;\n+    }\n+    case SQLITE_FCNTL_BLOCK_ON_CONNECT: {\n+      int iNew = *(int*)pArg;\n+      pFile->bBlockOnConnect = iNew;\n+      return SQLITE_OK;\n+    }\n+#endif \/* SQLITE_ENABLE_SETLK_TIMEOUT *\/\n+\n@@ -50593,1 +51166,0 @@\n-**      fid\n@@ -50600,0 +51172,5 @@\n+** File-handle hSharedShm is used to (a) take the DMS lock, (b) truncate\n+** the *-shm file if the DMS-locking protocol demands it, and (c) map\n+** regions of the *-shm file into memory using MapViewOfFile() or\n+** similar. Other locks are taken by individual clients using the\n+** winShm.hShm handles.\n@@ -50604,1 +51181,1 @@\n-  winFile hFile;             \/* File handle from winOpen *\/\n+  HANDLE hSharedShm;         \/* File handle open on zFilename *\/\n@@ -50606,0 +51183,2 @@\n+  int isUnlocked;            \/* DMS lock has not yet been obtained *\/\n+  int isReadonly;            \/* True if read-only *\/\n@@ -50608,2 +51187,0 @@\n-  u8 isReadonly;             \/* True if read-only *\/\n-  u8 isUnlocked;             \/* True if no DMS lock held *\/\n@@ -50618,1 +51195,0 @@\n-  winShm *pFirst;            \/* All winShm objects pointing to this *\/\n@@ -50634,10 +51210,2 @@\n-** open shared memory connection.\n-**\n-** The following fields are initialized when this object is created and\n-** are read-only thereafter:\n-**\n-**    winShm.pShmNode\n-**    winShm.id\n-**\n-** All other fields are read\/write.  The winShm.pShmNode->mutex must be held\n-** while accessing any read\/write fields.\n+** open shared memory connection. There is one such structure for each\n+** winFile open on a wal mode database.\n@@ -50647,2 +51215,0 @@\n-  winShm *pNext;             \/* Next winShm with the same winShmNode *\/\n-  u8 hasMutex;               \/* True if holding the winShmNode mutex *\/\n@@ -50651,0 +51217,2 @@\n+  HANDLE hShm;               \/* File-handle on *-shm file. For locking. *\/\n+  int bReadonly;             \/* True if hShm is opened read-only *\/\n@@ -50662,44 +51230,0 @@\n-\/*\n-** Apply advisory locks for all n bytes beginning at ofst.\n-*\/\n-#define WINSHM_UNLCK  1\n-#define WINSHM_RDLCK  2\n-#define WINSHM_WRLCK  3\n-static int winShmSystemLock(\n-  winShmNode *pFile,    \/* Apply locks to this open shared-memory segment *\/\n-  int lockType,         \/* WINSHM_UNLCK, WINSHM_RDLCK, or WINSHM_WRLCK *\/\n-  int ofst,             \/* Offset to first byte to be locked\/unlocked *\/\n-  int nByte             \/* Number of bytes to lock or unlock *\/\n-){\n-  int rc = 0;           \/* Result code form Lock\/UnlockFileEx() *\/\n-\n-  \/* Access to the winShmNode object is serialized by the caller *\/\n-  assert( pFile->nRef==0 || sqlite3_mutex_held(pFile->mutex) );\n-\n-  OSTRACE((\"SHM-LOCK file=%p, lock=%d, offset=%d, size=%d\\n\",\n-           pFile->hFile.h, lockType, ofst, nByte));\n-\n-  \/* Release\/Acquire the system-level lock *\/\n-  if( lockType==WINSHM_UNLCK ){\n-    rc = winUnlockFile(&pFile->hFile.h, ofst, 0, nByte, 0);\n-  }else{\n-    \/* Initialize the locking parameters *\/\n-    DWORD dwFlags = LOCKFILE_FAIL_IMMEDIATELY;\n-    if( lockType == WINSHM_WRLCK ) dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n-    rc = winLockFile(&pFile->hFile.h, dwFlags, ofst, 0, nByte, 0);\n-  }\n-\n-  if( rc!= 0 ){\n-    rc = SQLITE_OK;\n-  }else{\n-    pFile->lastErrno =  osGetLastError();\n-    rc = SQLITE_BUSY;\n-  }\n-\n-  OSTRACE((\"SHM-LOCK file=%p, func=%s, errno=%lu, rc=%s\\n\",\n-           pFile->hFile.h, (lockType == WINSHM_UNLCK) ? \"winUnlockFile\" :\n-           \"winLockFile\", pFile->lastErrno, sqlite3ErrName(rc)));\n-\n-  return rc;\n-}\n-\n@@ -50737,5 +51261,1 @@\n-      if( p->hFile.h!=NULL && p->hFile.h!=INVALID_HANDLE_VALUE ){\n-        SimulateIOErrorBenign(1);\n-        winClose((sqlite3_file *)&p->hFile);\n-        SimulateIOErrorBenign(0);\n-      }\n+      winHandleClose(p->hSharedShm);\n@@ -50759,7 +51279,3 @@\n-** The DMS lock has not yet been taken on shm file pShmNode. Attempt to\n-** take it now. Return SQLITE_OK if successful, or an SQLite error\n-** code otherwise.\n-**\n-** If the DMS cannot be locked because this is a readonly_shm=1\n-** connection and no other process already holds a lock, return\n-** SQLITE_READONLY_CANTINIT and set pShmNode->isUnlocked=1.\n+** The DMS lock has not yet been taken on the shm file associated with\n+** pShmNode. Take the lock. Truncate the *-shm file if required.\n+** Return SQLITE_OK if successful, or an SQLite error code otherwise.\n@@ -50767,2 +51283,3 @@\n-static int winLockSharedMemory(winShmNode *pShmNode){\n-  int rc = winShmSystemLock(pShmNode, WINSHM_WRLCK, WIN_SHM_DMS, 1);\n+static int winLockSharedMemory(winShmNode *pShmNode, DWORD nMs){\n+  HANDLE h = pShmNode->hSharedShm;\n+  int rc = SQLITE_OK;\n@@ -50770,0 +51287,2 @@\n+  assert( sqlite3_mutex_held(pShmNode->mutex) );\n+  rc = winHandleLockTimeout(h, WIN_SHM_DMS, 1, 1, 0);\n@@ -50771,0 +51290,3 @@\n+    \/* We have an EXCLUSIVE lock on the DMS byte. This means that this\n+    ** is the first process to open the file. Truncate it to zero bytes\n+    ** in this case.  *\/\n@@ -50772,7 +51294,3 @@\n-      pShmNode->isUnlocked = 1;\n-      winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);\n-      return SQLITE_READONLY_CANTINIT;\n-    }else if( winTruncate((sqlite3_file*)&pShmNode->hFile, 0) ){\n-      winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);\n-      return winLogError(SQLITE_IOERR_SHMOPEN, osGetLastError(),\n-                         \"winLockSharedMemory\", pShmNode->zFilename);\n+      rc = SQLITE_READONLY_CANTINIT;\n+    }else{\n+      rc = winHandleTruncate(h, 0);\n@@ -50780,0 +51298,5 @@\n+\n+    \/* Release the EXCLUSIVE lock acquired above. *\/\n+    winUnlockFile(&h, WIN_SHM_DMS, 0, 1, 0);\n+  }else if( (rc & 0xFF)==SQLITE_BUSY ){\n+    rc = SQLITE_OK;\n@@ -50783,1 +51306,5 @@\n-    winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);\n+    \/* Take a SHARED lock on the DMS byte. *\/\n+    rc = winHandleLockTimeout(h, WIN_SHM_DMS, 1, 0, nMs);\n+    if( rc==SQLITE_OK ){\n+      pShmNode->isUnlocked = 0;\n+    }\n@@ -50786,1 +51313,1 @@\n-  return winShmSystemLock(pShmNode, WINSHM_RDLCK, WIN_SHM_DMS, 1);\n+  return rc;\n@@ -50789,0 +51316,1 @@\n+\n@@ -50790,1 +51318,98 @@\n-** Open the shared-memory area associated with database file pDbFd.\n+** Convert a UTF-8 filename into whatever form the underlying\n+** operating system wants filenames in.  Space to hold the result\n+** is obtained from malloc and must be freed by the calling\n+** function\n+**\n+** On Cygwin, 3 possible input forms are accepted:\n+** - If the filename starts with \"<drive>:\/\" or \"<drive>:\\\",\n+**   it is converted to UTF-16 as-is.\n+** - If the filename contains '\/', it is assumed to be a\n+**   Cygwin absolute path, it is converted to a win32\n+**   absolute path in UTF-16.\n+** - Otherwise it must be a filename only, the win32 filename\n+**   is returned in UTF-16.\n+** Note: If the function cygwin_conv_path() fails, only\n+**   UTF-8 -> UTF-16 conversion will be done. This can only\n+**   happen when the file path >32k, in which case winUtf8ToUnicode()\n+**   will fail too.\n+*\/\n+static void *winConvertFromUtf8Filename(const char *zFilename){\n+  void *zConverted = 0;\n+  if( osIsNT() ){\n+#ifdef __CYGWIN__\n+    int nChar;\n+    LPWSTR zWideFilename;\n+\n+    if( osCygwin_conv_path && !(winIsDriveLetterAndColon(zFilename)\n+        && winIsDirSep(zFilename[2])) ){\n+      i64 nByte;\n+      int convertflag = CCP_POSIX_TO_WIN_W;\n+      if( !strchr(zFilename, '\/') ) convertflag |= CCP_RELATIVE;\n+      nByte = (i64)osCygwin_conv_path(convertflag,\n+          zFilename, 0, 0);\n+      if( nByte>0 ){\n+        zConverted = sqlite3MallocZero(12+(u64)nByte);\n+        if ( zConverted==0 ){\n+          return zConverted;\n+        }\n+        zWideFilename = zConverted;\n+        \/* Filenames should be prefixed, except when converted\n+         * full path already starts with \"\\\\?\\\". *\/\n+        if( osCygwin_conv_path(convertflag, zFilename,\n+                             zWideFilename+4, nByte)==0 ){\n+          if( (convertflag&CCP_RELATIVE) ){\n+            memmove(zWideFilename, zWideFilename+4, nByte);\n+          }else if( memcmp(zWideFilename+4, L\"\\\\\\\\\", 4) ){\n+            memcpy(zWideFilename, L\"\\\\\\\\?\\\\\", 8);\n+          }else if( zWideFilename[6]!='?' ){\n+            memmove(zWideFilename+6, zWideFilename+4, nByte);\n+            memcpy(zWideFilename, L\"\\\\\\\\?\\\\UNC\", 14);\n+          }else{\n+            memmove(zWideFilename, zWideFilename+4, nByte);\n+          }\n+          return zConverted;\n+        }\n+        sqlite3_free(zConverted);\n+      }\n+    }\n+    nChar = osMultiByteToWideChar(CP_UTF8, 0, zFilename, -1, NULL, 0);\n+    if( nChar==0 ){\n+      return 0;\n+    }\n+    zWideFilename = sqlite3MallocZero( nChar*sizeof(WCHAR)+12 );\n+    if( zWideFilename==0 ){\n+      return 0;\n+    }\n+    nChar = osMultiByteToWideChar(CP_UTF8, 0, zFilename, -1,\n+                                  zWideFilename, nChar);\n+    if( nChar==0 ){\n+      sqlite3_free(zWideFilename);\n+      zWideFilename = 0;\n+    }else if( nChar>MAX_PATH\n+        && winIsDriveLetterAndColon(zFilename)\n+        && winIsDirSep(zFilename[2]) ){\n+      memmove(zWideFilename+4, zWideFilename, nChar*sizeof(WCHAR));\n+      zWideFilename[2] = '\\\\';\n+      memcpy(zWideFilename, L\"\\\\\\\\?\\\\\", 8);\n+    }else if( nChar>MAX_PATH\n+        && winIsDirSep(zFilename[0]) && winIsDirSep(zFilename[1])\n+        && zFilename[2] != '?' ){\n+      memmove(zWideFilename+6, zWideFilename, nChar*sizeof(WCHAR));\n+      memcpy(zWideFilename, L\"\\\\\\\\?\\\\UNC\", 14);\n+    }\n+    zConverted = zWideFilename;\n+#else\n+    zConverted = winUtf8ToUnicode(zFilename);\n+#endif \/* __CYGWIN__ *\/\n+  }\n+#if defined(SQLITE_WIN32_HAS_ANSI) && defined(_WIN32)\n+  else{\n+    zConverted = winUtf8ToMbcs(zFilename, osAreFileApisANSI());\n+  }\n+#endif\n+  \/* caller will handle out of memory *\/\n+  return zConverted;\n+}\n+\n+\/*\n+** This function is used to open a handle on a *-shm file.\n@@ -50792,3 +51417,95 @@\n-** When opening a new shared-memory file, if no other instances of that\n-** file are currently open, in this process or in other processes, then\n-** the file must be truncated to zero length or have its header cleared.\n+** If SQLITE_ENABLE_SETLK_TIMEOUT is defined at build time, then the file\n+** is opened with FILE_FLAG_OVERLAPPED specified. If not, it is not.\n+*\/\n+static int winHandleOpen(\n+  const char *zUtf8,              \/* File to open *\/\n+  int *pbReadonly,                \/* IN\/OUT: True for readonly handle *\/\n+  HANDLE *ph                      \/* OUT: New HANDLE for file *\/\n+){\n+  int rc = SQLITE_OK;\n+  void *zConverted = 0;\n+  int bReadonly = *pbReadonly;\n+  HANDLE h = INVALID_HANDLE_VALUE;\n+\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  const DWORD flag_overlapped = FILE_FLAG_OVERLAPPED;\n+#else\n+  const DWORD flag_overlapped = 0;\n+#endif\n+\n+  \/* Convert the filename to the system encoding. *\/\n+  zConverted = winConvertFromUtf8Filename(zUtf8);\n+  if( zConverted==0 ){\n+    OSTRACE((\"OPEN name=%s, rc=SQLITE_IOERR_NOMEM\", zUtf8));\n+    rc = SQLITE_IOERR_NOMEM_BKPT;\n+    goto winopenfile_out;\n+  }\n+\n+  \/* Ensure the file we are trying to open is not actually a directory. *\/\n+  if( winIsDir(zConverted) ){\n+    OSTRACE((\"OPEN name=%s, rc=SQLITE_CANTOPEN_ISDIR\", zUtf8));\n+    rc = SQLITE_CANTOPEN_ISDIR;\n+    goto winopenfile_out;\n+  }\n+\n+  \/* TODO: platforms.\n+  ** TODO: retry-on-ioerr.\n+  *\/\n+  if( osIsNT() ){\n+#if SQLITE_OS_WINRT\n+    CREATEFILE2_EXTENDED_PARAMETERS extendedParameters;\n+    memset(&extendedParameters, 0, sizeof(extendedParameters));\n+    extendedParameters.dwSize = sizeof(extendedParameters);\n+    extendedParameters.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;\n+    extendedParameters.dwFileFlags = flag_overlapped;\n+    extendedParameters.dwSecurityQosFlags = SECURITY_ANONYMOUS;\n+    h = osCreateFile2((LPCWSTR)zConverted,\n+        (GENERIC_READ | (bReadonly ? 0 : GENERIC_WRITE)),\/* dwDesiredAccess *\/\n+        FILE_SHARE_READ | FILE_SHARE_WRITE,      \/* dwShareMode *\/\n+        OPEN_ALWAYS,                             \/* dwCreationDisposition *\/\n+        &extendedParameters\n+    );\n+#else\n+    h = osCreateFileW((LPCWSTR)zConverted,         \/* lpFileName *\/\n+        (GENERIC_READ | (bReadonly ? 0 : GENERIC_WRITE)),  \/* dwDesiredAccess *\/\n+        FILE_SHARE_READ | FILE_SHARE_WRITE,        \/* dwShareMode *\/\n+        NULL,                                      \/* lpSecurityAttributes *\/\n+        OPEN_ALWAYS,                               \/* dwCreationDisposition *\/\n+        FILE_ATTRIBUTE_NORMAL|flag_overlapped,\n+        NULL\n+    );\n+#endif\n+  }else{\n+    \/* Due to pre-processor directives earlier in this file,\n+    ** SQLITE_WIN32_HAS_ANSI is always defined if osIsNT() is false. *\/\n+#ifdef SQLITE_WIN32_HAS_ANSI\n+    h = osCreateFileA((LPCSTR)zConverted,\n+        (GENERIC_READ | (bReadonly ? 0 : GENERIC_WRITE)),  \/* dwDesiredAccess *\/\n+        FILE_SHARE_READ | FILE_SHARE_WRITE,        \/* dwShareMode *\/\n+        NULL,                                      \/* lpSecurityAttributes *\/\n+        OPEN_ALWAYS,                               \/* dwCreationDisposition *\/\n+        FILE_ATTRIBUTE_NORMAL|flag_overlapped,\n+        NULL\n+    );\n+#endif\n+  }\n+\n+  if( h==INVALID_HANDLE_VALUE ){\n+    if( bReadonly==0 ){\n+      bReadonly = 1;\n+      rc = winHandleOpen(zUtf8, &bReadonly, &h);\n+    }else{\n+      rc = SQLITE_CANTOPEN_BKPT;\n+    }\n+  }\n+\n+ winopenfile_out:\n+  sqlite3_free(zConverted);\n+  *pbReadonly = bReadonly;\n+  *ph = h;\n+  return rc;\n+}\n+\n+\n+\/*\n+** Open the shared-memory area associated with database file pDbFd.\n@@ -50806,2 +51523,1 @@\n-  ** allocate space for a new winShmNode and filename.\n-  *\/\n+  ** allocate space for a new winShmNode and filename.  *\/\n@@ -50811,1 +51527,1 @@\n-  pNew = sqlite3MallocZero( sizeof(*pShmNode) + nName + 17 );\n+  pNew = sqlite3MallocZero( sizeof(*pShmNode) + (i64)nName + 17 );\n@@ -50817,0 +51533,2 @@\n+  pNew->hSharedShm = INVALID_HANDLE_VALUE;\n+  pNew->isUnlocked = 1;\n@@ -50820,0 +51538,6 @@\n+  \/* Open a file-handle on the *-shm file for this connection. This file-handle\n+  ** is only used for locking. The mapping of the *-shm file is created using\n+  ** the shared file handle in winShmNode.hSharedShm.  *\/\n+  p->bReadonly = sqlite3_uri_boolean(pDbFd->zPath, \"readonly_shm\", 0);\n+  rc = winHandleOpen(pNew->zFilename, &p->bReadonly, &p->hShm);\n+\n@@ -50821,2 +51545,1 @@\n-  ** If no matching winShmNode currently exists, create a new one.\n-  *\/\n+  ** If no matching winShmNode currently exists, then create a new one.  *\/\n@@ -50826,2 +51549,1 @@\n-    ** use FILE_ID_BOTH_DIR_INFO Structure.\n-    *\/\n+    ** use FILE_ID_BOTH_DIR_INFO Structure.  *\/\n@@ -50830,6 +51552,1 @@\n-  if( pShmNode ){\n-    sqlite3_free(pNew);\n-  }else{\n-    int inFlags = SQLITE_OPEN_WAL;\n-    int outFlags = 0;\n-\n+  if( pShmNode==0 ){\n@@ -50837,4 +51554,0 @@\n-    pNew = 0;\n-    ((winFile*)(&pShmNode->hFile))->h = INVALID_HANDLE_VALUE;\n-    pShmNode->pNext = winShmNodeList;\n-    winShmNodeList = pShmNode;\n@@ -50842,0 +51555,1 @@\n+    \/* Allocate a mutex for this winShmNode object, if one is required. *\/\n@@ -50844,4 +51558,1 @@\n-      if( pShmNode->mutex==0 ){\n-        rc = SQLITE_IOERR_NOMEM_BKPT;\n-        goto shm_open_err;\n-      }\n+      if( pShmNode->mutex==0 ) rc = SQLITE_IOERR_NOMEM_BKPT;\n@@ -50850,12 +51561,6 @@\n-    if( 0==sqlite3_uri_boolean(pDbFd->zPath, \"readonly_shm\", 0) ){\n-      inFlags |= SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;\n-    }else{\n-      inFlags |= SQLITE_OPEN_READONLY;\n-    }\n-    rc = winOpen(pDbFd->pVfs, pShmNode->zFilename,\n-                 (sqlite3_file*)&pShmNode->hFile,\n-                 inFlags, &outFlags);\n-    if( rc!=SQLITE_OK ){\n-      rc = winLogError(rc, osGetLastError(), \"winOpenShm\",\n-                       pShmNode->zFilename);\n-      goto shm_open_err;\n+    \/* Open a file-handle to use for mappings, and for the DMS lock. *\/\n+    if( rc==SQLITE_OK ){\n+      HANDLE h = INVALID_HANDLE_VALUE;\n+      pShmNode->isReadonly = p->bReadonly;\n+      rc = winHandleOpen(pNew->zFilename, &pShmNode->isReadonly, &h);\n+      pShmNode->hSharedShm = h;\n@@ -50863,1 +51568,0 @@\n-    if( outFlags==SQLITE_OPEN_READONLY ) pShmNode->isReadonly = 1;\n@@ -50865,2 +51569,12 @@\n-    rc = winLockSharedMemory(pShmNode);\n-    if( rc!=SQLITE_OK && rc!=SQLITE_READONLY_CANTINIT ) goto shm_open_err;\n+    \/* If successful, link the new winShmNode into the global list. If an\n+    ** error occurred, free the object. *\/\n+    if( rc==SQLITE_OK ){\n+      pShmNode->pNext = winShmNodeList;\n+      winShmNodeList = pShmNode;\n+      pNew = 0;\n+    }else{\n+      sqlite3_mutex_free(pShmNode->mutex);\n+      if( pShmNode->hSharedShm!=INVALID_HANDLE_VALUE ){\n+        osCloseHandle(pShmNode->hSharedShm);\n+      }\n+    }\n@@ -50869,2 +51583,5 @@\n-  \/* Make the new connection a child of the winShmNode *\/\n-  p->pShmNode = pShmNode;\n+  \/* If no error has occurred, link the winShm object to the winShmNode and\n+  ** the winShm to pDbFd.  *\/\n+  if( rc==SQLITE_OK ){\n+    p->pShmNode = pShmNode;\n+    pShmNode->nRef++;\n@@ -50872,1 +51589,1 @@\n-  p->id = pShmNode->nextShmId++;\n+    p->id = pShmNode->nextShmId++;\n@@ -50874,16 +51591,5 @@\n-  pShmNode->nRef++;\n-  pDbFd->pShm = p;\n-  winShmLeaveMutex();\n-\n-  \/* The reference count on pShmNode has already been incremented under\n-  ** the cover of the winShmEnterMutex() mutex and the pointer from the\n-  ** new (struct winShm) object to the pShmNode has been set. All that is\n-  ** left to do is to link the new object into the linked list starting\n-  ** at pShmNode->pFirst. This must be done while holding the pShmNode->mutex\n-  ** mutex.\n-  *\/\n-  sqlite3_mutex_enter(pShmNode->mutex);\n-  p->pNext = pShmNode->pFirst;\n-  pShmNode->pFirst = p;\n-  sqlite3_mutex_leave(pShmNode->mutex);\n-  return rc;\n+    pDbFd->pShm = p;\n+  }else if( p ){\n+    winHandleClose(p->hShm);\n+    sqlite3_free(p);\n+  }\n@@ -50891,6 +51597,1 @@\n-  \/* Jump here on any error *\/\n-shm_open_err:\n-  winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);\n-  winShmPurge(pDbFd->pVfs, 0);      \/* This call frees pShmNode if required *\/\n-  sqlite3_free(p);\n-  sqlite3_free(pNew);\n+  assert( rc!=SQLITE_OK || pShmNode->isUnlocked==0 || pShmNode->nRegion==0 );\n@@ -50898,0 +51599,1 @@\n+  sqlite3_free(pNew);\n@@ -50912,1 +51614,0 @@\n-  winShm **pp;          \/* For looping over sibling connections *\/\n@@ -50917,7 +51618,3 @@\n-  pShmNode = p->pShmNode;\n-\n-  \/* Remove connection p from the set of connections associated\n-  ** with pShmNode *\/\n-  sqlite3_mutex_enter(pShmNode->mutex);\n-  for(pp=&pShmNode->pFirst; (*pp)!=p; pp = &(*pp)->pNext){}\n-  *pp = p->pNext;\n+  if( p->hShm!=INVALID_HANDLE_VALUE ){\n+    osCloseHandle(p->hShm);\n+  }\n@@ -50925,4 +51622,2 @@\n-  \/* Free the connection p *\/\n-  sqlite3_free(p);\n-  pDbFd->pShm = 0;\n-  sqlite3_mutex_leave(pShmNode->mutex);\n+  pShmNode = p->pShmNode;\n+  winShmEnterMutex();\n@@ -50931,2 +51626,1 @@\n-  ** shared-memory file, too *\/\n-  winShmEnterMutex();\n+  ** shared-memory file, too. *\/\n@@ -50940,0 +51634,3 @@\n+  \/* Free the connection p *\/\n+  sqlite3_free(p);\n+  pDbFd->pShm = 0;\n@@ -50954,1 +51651,0 @@\n-  winShm *pX;                           \/* For looping over all siblings *\/\n@@ -50957,1 +51653,1 @@\n-  u16 mask;                             \/* Mask of locks to take or release *\/\n+  u16 mask = (u16)((1U<<(ofst+n)) - (1U<<ofst)); \/* Mask of locks to [un]take *\/\n@@ -50971,12 +51667,23 @@\n-  mask = (u16)((1U<<(ofst+n)) - (1U<<ofst));\n-  assert( n>1 || mask==(1<<ofst) );\n-  sqlite3_mutex_enter(pShmNode->mutex);\n-  if( flags & SQLITE_SHM_UNLOCK ){\n-    u16 allMask = 0; \/* Mask of locks held by siblings *\/\n-\n-    \/* See if any siblings hold this same lock *\/\n-    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){\n-      if( pX==p ) continue;\n-      assert( (pX->exclMask & (p->exclMask|p->sharedMask))==0 );\n-      allMask |= pX->sharedMask;\n-    }\n+  \/* Check that, if this to be a blocking lock, no locks that occur later\n+  ** in the following list than the lock being obtained are already held:\n+  **\n+  **   1. Recovery lock (ofst==2).\n+  **   2. Checkpointer lock (ofst==1).\n+  **   3. Write lock (ofst==0).\n+  **   4. Read locks (ofst>=3 && ofst<SQLITE_SHM_NLOCK).\n+  **\n+  ** In other words, if this is a blocking lock, none of the locks that\n+  ** occur later in the above list than the lock being obtained may be\n+  ** held.\n+  *\/\n+#if defined(SQLITE_ENABLE_SETLK_TIMEOUT) && defined(SQLITE_DEBUG)\n+  {\n+    u16 lockMask = (p->exclMask|p->sharedMask);\n+    assert( (flags & SQLITE_SHM_UNLOCK) || pDbFd->iBusyTimeout==0 || (\n+          (ofst!=2 || lockMask==0)\n+       && (ofst!=1 || lockMask==0 || lockMask==2)\n+       && (ofst!=0 || lockMask<3)\n+       && (ofst<3  || lockMask<(1<<ofst))\n+    ));\n+  }\n+#endif\n@@ -50984,6 +51691,15 @@\n-    \/* Unlock the system-level locks *\/\n-    if( (mask & allMask)==0 ){\n-      rc = winShmSystemLock(pShmNode, WINSHM_UNLCK, ofst+WIN_SHM_BASE, n);\n-    }else{\n-      rc = SQLITE_OK;\n-    }\n+  \/* Check if there is any work to do. There are three cases:\n+  **\n+  **    a) An unlock operation where there are locks to unlock,\n+  **    b) An shared lock where the requested lock is not already held\n+  **    c) An exclusive lock where the requested lock is not already held\n+  **\n+  ** The SQLite core never requests an exclusive lock that it already holds.\n+  ** This is assert()ed immediately below.  *\/\n+  assert( flags!=(SQLITE_SHM_EXCLUSIVE|SQLITE_SHM_LOCK)\n+       || 0==(p->exclMask & mask)\n+  );\n+  if( ((flags & SQLITE_SHM_UNLOCK) && ((p->exclMask|p->sharedMask) & mask))\n+   || (flags==(SQLITE_SHM_SHARED|SQLITE_SHM_LOCK) && 0==(p->sharedMask & mask))\n+   || (flags==(SQLITE_SHM_EXCLUSIVE|SQLITE_SHM_LOCK))\n+  ){\n@@ -50991,7 +51707,2 @@\n-    \/* Undo the local locks *\/\n-    if( rc==SQLITE_OK ){\n-      p->exclMask &= ~mask;\n-      p->sharedMask &= ~mask;\n-    }\n-  }else if( flags & SQLITE_SHM_SHARED ){\n-    u16 allShared = 0;  \/* Union of locks held by connections other than \"p\" *\/\n+    if( flags & SQLITE_SHM_UNLOCK ){\n+      \/* Case (a) - unlock.  *\/\n@@ -50999,11 +51710,3 @@\n-    \/* Find out which shared locks are already held by sibling connections.\n-    ** If any sibling already holds an exclusive lock, go ahead and return\n-    ** SQLITE_BUSY.\n-    *\/\n-    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){\n-      if( (pX->exclMask & mask)!=0 ){\n-        rc = SQLITE_BUSY;\n-        break;\n-      }\n-      allShared |= pX->sharedMask;\n-    }\n+      assert( (p->exclMask & p->sharedMask)==0 );\n+      assert( !(flags & SQLITE_SHM_EXCLUSIVE) || (p->exclMask & mask)==mask );\n+      assert( !(flags & SQLITE_SHM_SHARED) || (p->sharedMask & mask)==mask );\n@@ -51011,8 +51714,1 @@\n-    \/* Get shared locks at the system level, if necessary *\/\n-    if( rc==SQLITE_OK ){\n-      if( (allShared & mask)==0 ){\n-        rc = winShmSystemLock(pShmNode, WINSHM_RDLCK, ofst+WIN_SHM_BASE, n);\n-      }else{\n-        rc = SQLITE_OK;\n-      }\n-    }\n+      rc = winHandleUnlock(p->hShm, ofst+WIN_SHM_BASE, n);\n@@ -51020,12 +51716,4 @@\n-    \/* Get the local shared locks *\/\n-    if( rc==SQLITE_OK ){\n-      p->sharedMask |= mask;\n-    }\n-  }else{\n-    \/* Make sure no sibling connections hold locks that will block this\n-    ** lock.  If any do, return SQLITE_BUSY right away.\n-    *\/\n-    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){\n-      if( (pX->exclMask & mask)!=0 || (pX->sharedMask & mask)!=0 ){\n-        rc = SQLITE_BUSY;\n-        break;\n+      \/* If successful, also clear the bits in sharedMask\/exclMask *\/\n+      if( rc==SQLITE_OK ){\n+        p->exclMask = (p->exclMask & ~mask);\n+        p->sharedMask = (p->sharedMask & ~mask);\n@@ -51033,7 +51721,4 @@\n-    }\n-\n-    \/* Get the exclusive locks at the system level.  Then if successful\n-    ** also mark the local connection as being locked.\n-    *\/\n-    if( rc==SQLITE_OK ){\n-      rc = winShmSystemLock(pShmNode, WINSHM_WRLCK, ofst+WIN_SHM_BASE, n);\n+    }else{\n+      int bExcl = ((flags & SQLITE_SHM_EXCLUSIVE) ? 1 : 0);\n+      DWORD nMs = winFileBusyTimeout(pDbFd);\n+      rc = winHandleLockTimeout(p->hShm, ofst+WIN_SHM_BASE, n, bExcl, nMs);\n@@ -51041,2 +51726,5 @@\n-        assert( (p->sharedMask & mask)==0 );\n-        p->exclMask |= mask;\n+        if( bExcl ){\n+          p->exclMask = (p->exclMask | mask);\n+        }else{\n+          p->sharedMask = (p->sharedMask | mask);\n+        }\n@@ -51046,4 +51734,8 @@\n-  sqlite3_mutex_leave(pShmNode->mutex);\n-  OSTRACE((\"SHM-LOCK pid=%lu, id=%d, sharedMask=%03x, exclMask=%03x, rc=%s\\n\",\n-           osGetCurrentProcessId(), p->id, p->sharedMask, p->exclMask,\n-           sqlite3ErrName(rc)));\n+\n+  OSTRACE((\n+      \"SHM-LOCK(%d,%d,%d) pid=%lu, id=%d, sharedMask=%03x, exclMask=%03x,\"\n+      \" rc=%s\\n\",\n+      ofst, n, flags,\n+      osGetCurrentProcessId(), p->id, p->sharedMask, p->exclMask,\n+      sqlite3ErrName(rc))\n+  );\n@@ -51111,1 +51803,3 @@\n-    rc = winLockSharedMemory(pShmNode);\n+    \/* Take the DMS lock. *\/\n+    assert( pShmNode->nRegion==0 );\n+    rc = winLockSharedMemory(pShmNode, winFileBusyTimeout(pDbFd));\n@@ -51113,1 +51807,0 @@\n-    pShmNode->isUnlocked = 0;\n@@ -51115,1 +51808,0 @@\n-  assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );\n@@ -51117,0 +51809,1 @@\n+  assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );\n@@ -51118,0 +51811,1 @@\n+    HANDLE hShared = pShmNode->hSharedShm;\n@@ -51128,1 +51822,1 @@\n-    rc = winFileSize((sqlite3_file *)&pShmNode->hFile, &sz);\n+    rc = winHandleSize(hShared, &sz);\n@@ -51130,2 +51824,1 @@\n-      rc = winLogError(SQLITE_IOERR_SHMSIZE, osGetLastError(),\n-                       \"winShmMap1\", pDbFd->zPath);\n+      rc = winLogError(rc, osGetLastError(), \"winShmMap1\", pDbFd->zPath);\n@@ -51140,2 +51833,1 @@\n-      ** the requested memory region.\n-      *\/\n+      ** the requested memory region.  *\/\n@@ -51143,1 +51835,1 @@\n-      rc = winTruncate((sqlite3_file *)&pShmNode->hFile, nByte);\n+      rc = winHandleTruncate(hShared, nByte);\n@@ -51145,2 +51837,1 @@\n-        rc = winLogError(SQLITE_IOERR_SHMSIZE, osGetLastError(),\n-                         \"winShmMap2\", pDbFd->zPath);\n+        rc = winLogError(rc, osGetLastError(), \"winShmMap2\", pDbFd->zPath);\n@@ -51152,1 +51843,1 @@\n-    apNew = (struct ShmRegion *)sqlite3_realloc64(\n+    apNew = (struct ShmRegion*)sqlite3_realloc64(\n@@ -51171,3 +51862,1 @@\n-      hMap = osCreateFileMappingFromApp(pShmNode->hFile.h,\n-          NULL, protect, nByte, NULL\n-      );\n+      hMap = osCreateFileMappingFromApp(hShared, NULL, protect, nByte, NULL);\n@@ -51175,3 +51864,1 @@\n-      hMap = osCreateFileMappingW(pShmNode->hFile.h,\n-          NULL, protect, 0, nByte, NULL\n-      );\n+      hMap = osCreateFileMappingW(hShared, NULL, protect, 0, nByte, NULL);\n@@ -51179,3 +51866,1 @@\n-      hMap = osCreateFileMappingA(pShmNode->hFile.h,\n-          NULL, protect, 0, nByte, NULL\n-      );\n+      hMap = osCreateFileMappingA(hShared, NULL, protect, 0, nByte, NULL);\n@@ -51183,0 +51868,1 @@\n+\n@@ -51225,1 +51911,3 @@\n-  if( pShmNode->isReadonly && rc==SQLITE_OK ) rc = SQLITE_READONLY;\n+  if( pShmNode->isReadonly && rc==SQLITE_OK ){\n+    rc = SQLITE_READONLY;\n+  }\n@@ -51545,41 +52233,0 @@\n-#if defined(__CYGWIN__)\n-\/*\n-** Convert a filename from whatever the underlying operating system\n-** supports for filenames into UTF-8.  Space to hold the result is\n-** obtained from malloc and must be freed by the calling function.\n-*\/\n-static char *winConvertToUtf8Filename(const void *zFilename){\n-  char *zConverted = 0;\n-  if( osIsNT() ){\n-    zConverted = winUnicodeToUtf8(zFilename);\n-  }\n-#ifdef SQLITE_WIN32_HAS_ANSI\n-  else{\n-    zConverted = winMbcsToUtf8(zFilename, osAreFileApisANSI());\n-  }\n-#endif\n-  \/* caller will handle out of memory *\/\n-  return zConverted;\n-}\n-#endif\n-\n-\/*\n-** Convert a UTF-8 filename into whatever form the underlying\n-** operating system wants filenames in.  Space to hold the result\n-** is obtained from malloc and must be freed by the calling\n-** function.\n-*\/\n-static void *winConvertFromUtf8Filename(const char *zFilename){\n-  void *zConverted = 0;\n-  if( osIsNT() ){\n-    zConverted = winUtf8ToUnicode(zFilename);\n-  }\n-#ifdef SQLITE_WIN32_HAS_ANSI\n-  else{\n-    zConverted = winUtf8ToMbcs(zFilename, osAreFileApisANSI());\n-  }\n-#endif\n-  \/* caller will handle out of memory *\/\n-  return zConverted;\n-}\n-\n@@ -51598,1 +52245,8 @@\n-        zBuf[nLen] = winGetDirSep();\n+        if( !osGetenv ){\n+          zBuf[nLen] = winGetDirSep();\n+        }else if( winIsDriveLetterAndColon(zBuf) && winIsDirSep(zBuf[2]) ){\n+          zBuf[nLen] = '\\\\';\n+          zBuf[2]='\\\\';\n+        }else{\n+          zBuf[nLen] = '\/';\n+        }\n@@ -51625,1 +52279,1 @@\n-  static char zChars[] =\n+  static const char zChars[] =\n@@ -51632,1 +52286,1 @@\n-  int nMax, nBuf, nDir, nLen;\n+  i64 nMax, nBuf, nDir, nLen;\n@@ -51644,1 +52298,2 @@\n-  nMax = pVfs->mxPathname; nBuf = nMax + 2;\n+  nMax = pVfs->mxPathname;\n+  nBuf = 2 + (i64)nMax;\n@@ -51675,1 +52330,1 @@\n-  else{\n+  else if( osGetenv!=NULL ){\n@@ -51691,5 +52346,5 @@\n-    if( !azDirs[0] ) azDirs[0] = getenv(\"SQLITE_TMPDIR\");\n-    if( !azDirs[1] ) azDirs[1] = getenv(\"TMPDIR\");\n-    if( !azDirs[2] ) azDirs[2] = getenv(\"TMP\");\n-    if( !azDirs[3] ) azDirs[3] = getenv(\"TEMP\");\n-    if( !azDirs[4] ) azDirs[4] = getenv(\"USERPROFILE\");\n+    if( !azDirs[0] ) azDirs[0] = osGetenv(\"SQLITE_TMPDIR\");\n+    if( !azDirs[1] ) azDirs[1] = osGetenv(\"TMPDIR\");\n+    if( !azDirs[2] ) azDirs[2] = osGetenv(\"TMP\");\n+    if( !azDirs[3] ) azDirs[3] = osGetenv(\"TEMP\");\n+    if( !azDirs[4] ) azDirs[4] = osGetenv(\"USERPROFILE\");\n@@ -51704,1 +52359,1 @@\n-      if( winIsDriveLetterAndColon(zDir) ){\n+      {\n@@ -51717,34 +52372,0 @@\n-      }else{\n-        zConverted = sqlite3MallocZero( nMax+1 );\n-        if( !zConverted ){\n-          sqlite3_free(zBuf);\n-          OSTRACE((\"TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\\n\"));\n-          return SQLITE_IOERR_NOMEM_BKPT;\n-        }\n-        if( cygwin_conv_path(\n-                osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A, zDir,\n-                zConverted, nMax+1)<0 ){\n-          sqlite3_free(zConverted);\n-          sqlite3_free(zBuf);\n-          OSTRACE((\"TEMP-FILENAME rc=SQLITE_IOERR_CONVPATH\\n\"));\n-          return winLogError(SQLITE_IOERR_CONVPATH, (DWORD)errno,\n-                             \"winGetTempname2\", zDir);\n-        }\n-        if( winIsDir(zConverted) ){\n-          \/* At this point, we know the candidate directory exists and should\n-          ** be used.  However, we may need to convert the string containing\n-          ** its name into UTF-8 (i.e. if it is UTF-16 right now).\n-          *\/\n-          char *zUtf8 = winConvertToUtf8Filename(zConverted);\n-          if( !zUtf8 ){\n-            sqlite3_free(zConverted);\n-            sqlite3_free(zBuf);\n-            OSTRACE((\"TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\\n\"));\n-            return SQLITE_IOERR_NOMEM_BKPT;\n-          }\n-          sqlite3_snprintf(nMax, zBuf, \"%s\", zUtf8);\n-          sqlite3_free(zUtf8);\n-          sqlite3_free(zConverted);\n-          break;\n-        }\n-        sqlite3_free(zConverted);\n@@ -51754,1 +52375,3 @@\n-#elif !SQLITE_OS_WINRT && !defined(__CYGWIN__)\n+#endif\n+\n+#if !SQLITE_OS_WINRT && defined(_WIN32)\n@@ -51878,1 +52501,1 @@\n-#if SQLITE_OS_WINCE==0\n+#if SQLITE_OS_WINCE==0 && defined(SQLITE_WIN32_HAS_ANSI)\n@@ -51894,0 +52517,6 @@\n+\/*\n+** The Windows version of xAccess() accepts an extra bit in the flags\n+** parameter that prevents an anti-virus retry loop.\n+*\/\n+#define NORETRY 0x4000\n+\n@@ -51918,0 +52547,1 @@\n+  int isRO = 0;              \/* file is known to be accessible readonly *\/\n@@ -52082,1 +52712,1 @@\n-        int rc2, isRO = 0;\n+        int rc2;\n@@ -52084,1 +52714,1 @@\n-        rc2 = winAccess(pVfs, zUtf8Name, SQLITE_ACCESS_READ, &isRO);\n+        rc2 = winAccess(pVfs, zUtf8Name, SQLITE_ACCESS_READ|NORETRY, &isRO);\n@@ -52099,1 +52729,1 @@\n-        int rc2, isRO = 0;\n+        int rc2;\n@@ -52101,1 +52731,1 @@\n-        rc2 = winAccess(pVfs, zUtf8Name, SQLITE_ACCESS_READ, &isRO);\n+        rc2 = winAccess(pVfs, zUtf8Name, SQLITE_ACCESS_READ|NORETRY, &isRO);\n@@ -52119,1 +52749,1 @@\n-        int rc2, isRO = 0;\n+        int rc2;\n@@ -52121,1 +52751,1 @@\n-        rc2 = winAccess(pVfs, zUtf8Name, SQLITE_ACCESS_READ, &isRO);\n+        rc2 = winAccess(pVfs, zUtf8Name, SQLITE_ACCESS_READ|NORETRY, &isRO);\n@@ -52136,1 +52766,1 @@\n-    if( isReadWrite && !isExclusive ){\n+    if( isReadWrite && isRO && !isExclusive ){\n@@ -52338,0 +52968,1 @@\n+  int noRetry = 0;           \/* Do not use winRetryIoerr() *\/\n@@ -52340,0 +52971,5 @@\n+  if( (flags & NORETRY)!=0 ){\n+    noRetry = 1;\n+    flags &= ~NORETRY;\n+  }\n+\n@@ -52362,1 +52998,4 @@\n-                             &sAttrData)) && winRetryIoerr(&cnt, &lastErrno) ){}\n+                             &sAttrData))\n+       && !noRetry\n+       && winRetryIoerr(&cnt, &lastErrno)\n+    ){ \/* Loop until true *\/}\n@@ -52430,0 +53069,1 @@\n+#ifdef _WIN32\n@@ -52466,0 +53106,64 @@\n+#endif \/* _WIN32 *\/\n+\n+#ifdef __CYGWIN__\n+\/*\n+** Simplify a filename into its canonical form\n+** by making the following changes:\n+**\n+**  * convert any '\/' to '\\' (win32) or reverse (Cygwin)\n+**  * removing any trailing and duplicate \/ (except for UNC paths)\n+**  * convert \/.\/ into just \/\n+**\n+** Changes are made in-place.  Return the new name length.\n+**\n+** The original filename is in z[0..]. If the path is shortened,\n+** no-longer used bytes will be written by '\\0'.\n+*\/\n+static void winSimplifyName(char *z){\n+  int i, j;\n+  for(i=j=0; z[i]; ++i){\n+    if( winIsDirSep(z[i]) ){\n+#if !defined(SQLITE_TEST)\n+      \/* Some test-cases assume that \".\/foo\" and \"foo\" are different *\/\n+      if( z[i+1]=='.' && winIsDirSep(z[i+2]) ){\n+        ++i;\n+        continue;\n+      }\n+#endif\n+      if( !z[i+1] || (winIsDirSep(z[i+1]) && (i!=0)) ){\n+        continue;\n+      }\n+      z[j++] = osGetenv?'\/':'\\\\';\n+    }else{\n+      z[j++] = z[i];\n+    }\n+  }\n+  while(j<i) z[j++] = '\\0';\n+}\n+\n+#define SQLITE_MAX_SYMLINKS 100\n+\n+static int mkFullPathname(\n+  const char *zPath,              \/* Input path *\/\n+  char *zOut,                     \/* Output buffer *\/\n+  int nOut                        \/* Allocated size of buffer zOut *\/\n+){\n+  int nPath = sqlite3Strlen30(zPath);\n+  int iOff = 0;\n+  if( zPath[0]!='\/' ){\n+    if( osGetcwd(zOut, nOut-2)==0 ){\n+      return winLogError(SQLITE_CANTOPEN_BKPT, (DWORD)osErrno, \"getcwd\", zPath);\n+    }\n+    iOff = sqlite3Strlen30(zOut);\n+    zOut[iOff++] = '\/';\n+  }\n+  if( (iOff+nPath+1)>nOut ){\n+    \/* SQLite assumes that xFullPathname() nul-terminates the output buffer\n+    ** even if it returns an error.  *\/\n+    zOut[iOff] = '\\0';\n+    return SQLITE_CANTOPEN_BKPT;\n+  }\n+  sqlite3_snprintf(nOut-iOff, &zOut[iOff], \"%s\", zPath);\n+  return SQLITE_OK;\n+}\n+#endif \/* __CYGWIN__ *\/\n@@ -52478,2 +53182,2 @@\n-#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(__CYGWIN__)\n-  DWORD nByte;\n+#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT\n+  int nByte;\n@@ -52492,1 +53196,0 @@\n-#if defined(__CYGWIN__)\n@@ -52494,50 +53197,70 @@\n-  UNUSED_PARAMETER(nFull);\n-  assert( nFull>=pVfs->mxPathname );\n-  if ( sqlite3_data_directory && !winIsVerbatimPathname(zRelative) ){\n-    \/*\n-    ** NOTE: We are dealing with a relative path name and the data\n-    **       directory has been set.  Therefore, use it as the basis\n-    **       for converting the relative path name to an absolute\n-    **       one by prepending the data directory and a slash.\n-    *\/\n-    char *zOut = sqlite3MallocZero( pVfs->mxPathname+1 );\n-    if( !zOut ){\n-      return SQLITE_IOERR_NOMEM_BKPT;\n-    }\n-    if( cygwin_conv_path(\n-            (osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A) |\n-            CCP_RELATIVE, zRelative, zOut, pVfs->mxPathname+1)<0 ){\n-      sqlite3_free(zOut);\n-      return winLogError(SQLITE_CANTOPEN_CONVPATH, (DWORD)errno,\n-                         \"winFullPathname1\", zRelative);\n-    }else{\n-      char *zUtf8 = winConvertToUtf8Filename(zOut);\n-      if( !zUtf8 ){\n-        sqlite3_free(zOut);\n-        return SQLITE_IOERR_NOMEM_BKPT;\n-      }\n-      sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, \"%s%c%s\",\n-                       sqlite3_data_directory, winGetDirSep(), zUtf8);\n-      sqlite3_free(zUtf8);\n-      sqlite3_free(zOut);\n-    }\n-  }else{\n-    char *zOut = sqlite3MallocZero( pVfs->mxPathname+1 );\n-    if( !zOut ){\n-      return SQLITE_IOERR_NOMEM_BKPT;\n-    }\n-    if( cygwin_conv_path(\n-            (osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A),\n-            zRelative, zOut, pVfs->mxPathname+1)<0 ){\n-      sqlite3_free(zOut);\n-      return winLogError(SQLITE_CANTOPEN_CONVPATH, (DWORD)errno,\n-                         \"winFullPathname2\", zRelative);\n-    }else{\n-      char *zUtf8 = winConvertToUtf8Filename(zOut);\n-      if( !zUtf8 ){\n-        sqlite3_free(zOut);\n-        return SQLITE_IOERR_NOMEM_BKPT;\n-      }\n-      sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, \"%s\", zUtf8);\n-      sqlite3_free(zUtf8);\n-      sqlite3_free(zOut);\n+\n+#ifdef __CYGWIN__\n+  if( osGetcwd ){\n+    zFull[nFull-1] = '\\0';\n+    if( !winIsDriveLetterAndColon(zRelative) || !winIsDirSep(zRelative[2]) ){\n+      int rc = SQLITE_OK;\n+      int nLink = 1;                \/* Number of symbolic links followed so far *\/\n+      const char *zIn = zRelative;      \/* Input path for each iteration of loop *\/\n+      char *zDel = 0;\n+      struct stat buf;\n+\n+      UNUSED_PARAMETER(pVfs);\n+\n+      do {\n+        \/* Call lstat() on path zIn. Set bLink to true if the path is a symbolic\n+        ** link, or false otherwise.  *\/\n+        int bLink = 0;\n+        if( osLstat && osReadlink ) {\n+          if( osLstat(zIn, &buf)!=0 ){\n+            int myErrno = osErrno;\n+            if( myErrno!=ENOENT ){\n+              rc = winLogError(SQLITE_CANTOPEN_BKPT, (DWORD)myErrno, \"lstat\", zIn);\n+            }\n+          }else{\n+            bLink = ((buf.st_mode & 0170000) == 0120000);\n+          }\n+\n+          if( bLink ){\n+            if( zDel==0 ){\n+              zDel = sqlite3MallocZero(nFull);\n+              if( zDel==0 ) rc = SQLITE_NOMEM;\n+            }else if( ++nLink>SQLITE_MAX_SYMLINKS ){\n+              rc = SQLITE_CANTOPEN_BKPT;\n+            }\n+\n+            if( rc==SQLITE_OK ){\n+              nByte = osReadlink(zIn, zDel, nFull-1);\n+              if( nByte ==(DWORD)-1 ){\n+                rc = winLogError(SQLITE_CANTOPEN_BKPT, (DWORD)osErrno, \"readlink\", zIn);\n+              }else{\n+                if( zDel[0]!='\/' ){\n+                  int n;\n+                  for(n = sqlite3Strlen30(zIn); n>0 && zIn[n-1]!='\/'; n--);\n+                  if( nByte+n+1>nFull ){\n+                    rc = SQLITE_CANTOPEN_BKPT;\n+                  }else{\n+                    memmove(&zDel[n], zDel, nByte+1);\n+                    memcpy(zDel, zIn, n);\n+                    nByte += n;\n+                  }\n+                }\n+                zDel[nByte] = '\\0';\n+              }\n+            }\n+\n+            zIn = zDel;\n+          }\n+        }\n+\n+        assert( rc!=SQLITE_OK || zIn!=zFull || zIn[0]=='\/' );\n+        if( rc==SQLITE_OK && zIn!=zFull ){\n+          rc = mkFullPathname(zIn, zFull, nFull);\n+        }\n+        if( bLink==0 ) break;\n+        zIn = zFull;\n+      }while( rc==SQLITE_OK );\n+\n+      sqlite3_free(zDel);\n+      winSimplifyName(zFull);\n+      return rc;\n@@ -52546,2 +53269,1 @@\n-  return SQLITE_OK;\n-#endif\n+#endif \/* __CYGWIN__ *\/\n@@ -52549,1 +53271,1 @@\n-#if (SQLITE_OS_WINCE || SQLITE_OS_WINRT) && !defined(__CYGWIN__)\n+#if (SQLITE_OS_WINCE || SQLITE_OS_WINRT) && defined(_WIN32)\n@@ -52568,1 +53290,2 @@\n-#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(__CYGWIN__)\n+#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT\n+#if defined(_WIN32)\n@@ -52586,0 +53309,1 @@\n+#endif\n@@ -52624,2 +53348,1 @@\n-    nByte += 3;\n-    zTemp = sqlite3MallocZero( nByte*sizeof(zTemp[0]) );\n+    zTemp = sqlite3MallocZero( nByte*sizeof(zTemp[0]) + 3*sizeof(zTemp[0]) );\n@@ -52630,1 +53353,1 @@\n-    nByte = osGetFullPathNameA((char*)zConverted, nByte, zTemp, 0);\n+    nByte = osGetFullPathNameA((char*)zConverted, nByte+3, zTemp, 0);\n@@ -52643,0 +53366,18 @@\n+#ifdef __CYGWIN__\n+    if( memcmp(zOut, \"\\\\\\\\?\\\\\", 4) ){\n+      sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, \"%s\", zOut);\n+    }else if( memcmp(zOut+4, \"UNC\\\\\", 4) ){\n+      sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, \"%s\", zOut+4);\n+    }else{\n+      char *p = zOut+6;\n+      *p = '\\\\';\n+      if( osGetcwd ){\n+        \/* On Cygwin, UNC paths use forward slashes *\/\n+        while( *p ){\n+          if( *p=='\\\\' ) *p = '\/';\n+          ++p;\n+        }\n+      }\n+      sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, \"%s\", zOut+6);\n+    }\n+#else\n@@ -52644,0 +53385,1 @@\n+#endif \/* __CYGWIN__ *\/\n@@ -52673,16 +53415,0 @@\n-#if defined(__CYGWIN__)\n-  int nFull = pVfs->mxPathname+1;\n-  char *zFull = sqlite3MallocZero( nFull );\n-  void *zConverted = 0;\n-  if( zFull==0 ){\n-    OSTRACE((\"DLOPEN name=%s, handle=%p\\n\", zFilename, (void*)0));\n-    return 0;\n-  }\n-  if( winFullPathname(pVfs, zFilename, nFull, zFull)!=SQLITE_OK ){\n-    sqlite3_free(zFull);\n-    OSTRACE((\"DLOPEN name=%s, handle=%p\\n\", zFilename, (void*)0));\n-    return 0;\n-  }\n-  zConverted = winConvertFromUtf8Filename(zFull);\n-  sqlite3_free(zFull);\n-#else\n@@ -52691,1 +53417,0 @@\n-#endif\n@@ -53040,1 +53765,1 @@\n-  assert( ArraySize(aSyscall)==80 );\n+  assert( ArraySize(aSyscall)==89 );\n@@ -53659,1 +54384,1 @@\n-      p = sqlite3Malloc( sizeof(*p) + szName + 3 );\n+      p = sqlite3Malloc( sizeof(*p) + (i64)szName + 3 );\n@@ -53665,1 +54390,1 @@\n-                             sizeof(apNew[0])*(memdb_g.nMemStore+1) );\n+                             sizeof(apNew[0])*(1+(i64)memdb_g.nMemStore) );\n@@ -54098,1 +54823,1 @@\n-#define BITVEC_NPTR      (BITVEC_USIZE\/sizeof(Bitvec *))\n+#define BITVEC_NPTR      ((u32)(BITVEC_USIZE\/sizeof(Bitvec *)))\n@@ -54247,1 +54972,3 @@\n-      p->iDivisor = (p->iSize + BITVEC_NPTR - 1)\/BITVEC_NPTR;\n+      p->iDivisor = p->iSize\/BITVEC_NPTR;\n+      if( (p->iSize%BITVEC_NPTR)!=0 ) p->iDivisor++;\n+      if( p->iDivisor<BITVEC_NBIT ) p->iDivisor = BITVEC_NBIT;\n@@ -54281,1 +55008,1 @@\n-    p->u.aBitmap[i\/BITVEC_SZELEM] &= ~(1 << (i&(BITVEC_SZELEM-1)));\n+    p->u.aBitmap[i\/BITVEC_SZELEM] &= ~(BITVEC_TELEM)(1<<(i&(BITVEC_SZELEM-1)));\n@@ -54332,1 +55059,1 @@\n-#define CLEARBIT(V,I)    V[I>>3] &= ~(1<<(I&7))\n+#define CLEARBIT(V,I)    V[I>>3] &= ~(BITVEC_TELEM)(1<<(I&7))\n@@ -54375,1 +55102,1 @@\n-  pV = sqlite3MallocZero( (sz+7)\/8 + 1 );\n+  pV = sqlite3MallocZero( (7+(i64)sz)\/8 + 1 );\n@@ -55616,4 +56343,0 @@\n-  \/* The following value requires a mutex to change.  We skip the mutex on\n-  ** reading because (1) most platforms read a 32-bit integer atomically and\n-  ** (2) even if an incorrect value is read, no great harm is done since this\n-  ** is really just an optimization. *\/\n@@ -55667,1 +56390,1 @@\n-    pcache1.bUnderPressure = 0;\n+    AtomicStore(&pcache1.bUnderPressure,0);\n@@ -55735,1 +56458,1 @@\n-      pcache1.bUnderPressure = pcache1.nFreeSlot<pcache1.nReserve;\n+      AtomicStore(&pcache1.bUnderPressure,pcache1.nFreeSlot<pcache1.nReserve);\n@@ -55774,1 +56497,1 @@\n-    pcache1.bUnderPressure = pcache1.nFreeSlot<pcache1.nReserve;\n+    AtomicStore(&pcache1.bUnderPressure,pcache1.nFreeSlot<pcache1.nReserve);\n@@ -55905,1 +56628,1 @@\n-    return pcache1.bUnderPressure;\n+    return AtomicLoad(&pcache1.bUnderPressure);\n@@ -55922,2 +56645,2 @@\n-  unsigned int nNew;\n-  unsigned int i;\n+  u64 nNew;\n+  u32 i;\n@@ -55927,1 +56650,1 @@\n-  nNew = p->nHash*2;\n+  nNew = 2*(u64)p->nHash;\n@@ -56150,1 +56873,1 @@\n-  int sz;               \/* Bytes of memory required to allocate the new cache *\/\n+  i64 sz;               \/* Bytes of memory required to allocate the new cache *\/\n@@ -58038,0 +58761,3 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  sqlite3 *dbWal;\n+#endif\n@@ -58629,1 +59355,1 @@\n-static int readSuperJournal(sqlite3_file *pJrnl, char *zSuper, u32 nSuper){\n+static int readSuperJournal(sqlite3_file *pJrnl, char *zSuper, u64 nSuper){\n@@ -59184,0 +59910,9 @@\n+    if( pPager->eState==PAGER_ERROR ){\n+      \/* If an IO error occurs in wal.c while attempting to wrap the wal file,\n+      ** then the Wal object may be holding a write-lock but no read-lock.\n+      ** This call ensures that the write-lock is dropped as well. We cannot\n+      ** have sqlite3WalEndReadTransaction() drop the write-lock, as it once\n+      ** did, because this would break \"BEGIN EXCLUSIVE\" handling for\n+      ** SQLITE_ENABLE_SETLK_TIMEOUT builds.  *\/\n+      sqlite3WalEndWriteTransaction(pPager->pWal);\n+    }\n@@ -59865,1 +60600,1 @@\n-  int nSuperPtr;            \/* Amount of space allocated to zSuperPtr[] *\/\n+  i64 nSuperPtr;            \/* Amount of space allocated to zSuperPtr[] *\/\n@@ -59870,1 +60605,1 @@\n-  pSuper = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);\n+  pSuper = (sqlite3_file *)sqlite3MallocZero(2 * (i64)pVfs->szOsFile);\n@@ -59888,1 +60623,2 @@\n-  nSuperPtr = pVfs->mxPathname+1;\n+  nSuperPtr = 1 + (i64)pVfs->mxPathname;\n+  assert( nSuperJournal>=0 && nSuperPtr>0 );\n@@ -59893,0 +60629,2 @@\n+  }else{\n+    assert( nSuperJournal<=0x7fffffff );\n@@ -60153,1 +60891,1 @@\n-  rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname+1);\n+  rc = readSuperJournal(pPager->jfd, zSuper, 1+(i64)pPager->pVfs->mxPathname);\n@@ -60292,1 +61030,1 @@\n-    rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname+1);\n+    rc = readSuperJournal(pPager->jfd, zSuper, 1+(i64)pPager->pVfs->mxPathname);\n@@ -62063,0 +62801,1 @@\n+\n@@ -62088,2 +62827,2 @@\n-    nPathname = pVfs->mxPathname+1;\n-    zPathname = sqlite3DbMallocRaw(0, nPathname*2);\n+    nPathname = pVfs->mxPathname + 1;\n+    zPathname = sqlite3DbMallocRaw(0, 2*(i64)nPathname);\n@@ -62176,1 +62915,1 @@\n-    journalFileSize * 2 +                \/* The two journal files *\/\n+    (u64)journalFileSize * 2 +           \/* The two journal files *\/\n@@ -62179,3 +62918,3 @@\n-    nPathname + 1 +                      \/* database filename *\/\n-    nUriByte +                           \/* query parameters *\/\n-    nPathname + 8 + 1 +                  \/* Journal filename *\/\n+    (u64)nPathname + 1 +                 \/* database filename *\/\n+    (u64)nUriByte +                      \/* query parameters *\/\n+    (u64)nPathname + 8 + 1 +             \/* Journal filename *\/\n@@ -62183,1 +62922,1 @@\n-    nPathname + 4 + 1 +                  \/* WAL filename *\/\n+    (u64)nPathname + 4 + 1 +             \/* WAL filename *\/\n@@ -64906,0 +65645,5 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    if( rc==SQLITE_OK ){\n+      sqlite3WalDb(pPager->pWal, pPager->dbWal);\n+    }\n+#endif\n@@ -65025,0 +65769,1 @@\n+  pPager->dbWal = db;\n@@ -65638,0 +66383,5 @@\n+**\n+** writeLock:\n+**   This is usually set to 1 whenever the WRITER lock is held. However,\n+**   if it is set to 2, then the WRITER lock is held but must be released\n+**   by walHandleException() if a SEH exception is thrown.\n@@ -65728,1 +66478,1 @@\n-  } aSegment[1];                  \/* One for every 32KB page in the wal-index *\/\n+  } aSegment[FLEXARRAY];          \/* One for every 32KB page in the wal-index *\/\n@@ -65731,0 +66481,4 @@\n+\/* Size (in bytes) of a WalIterator object suitable for N or fewer segments *\/\n+#define SZ_WALITERATOR(N)  \\\n+     (offsetof(WalIterator,aSegment)*(N)*sizeof(struct WalSegment))\n+\n@@ -65889,1 +66643,1 @@\n-    sqlite3_int64 nByte = sizeof(u32*)*(iPage+1);\n+    sqlite3_int64 nByte = sizeof(u32*)*(1+(i64)iPage);\n@@ -65998,4 +66752,2 @@\n-  assert( nByte>=8 );\n-  assert( (nByte&0x00000007)==0 );\n-  assert( nByte<=65536 );\n-  assert( nByte%4==0 );\n+  \/* nByte is a multiple of 8 between 8 and 65536 *\/\n+  assert( nByte>=8 && (nByte&7)==0 && nByte<=65536 );\n@@ -67091,2 +67843,1 @@\n-  nByte = sizeof(WalIterator)\n-        + (nSegment-1)*sizeof(struct WalSegment)\n+  nByte = SZ_WALITERATOR(nSegment)\n@@ -67163,1 +67914,1 @@\n-    int tmout = pWal->db->busyTimeout;\n+    int tmout = pWal->db->setlkTimeout;\n@@ -67549,1 +68300,3 @@\n-    u32 mUnlock = pWal->lockMask & ~(\n+    u32 mUnlock;\n+    if( pWal->writeLock==2 ) pWal->writeLock = 0;\n+    mUnlock = pWal->lockMask & ~(\n@@ -67821,1 +68574,6 @@\n-        pWal->writeLock = 1;\n+        \/* If the write-lock was just obtained, set writeLock to 2 instead of\n+        ** the usual 1. This causes walIndexPage() to behave as if the\n+        ** write-lock were held (so that it allocates new pages as required),\n+        ** and walHandleException() to unlock the write-lock if a SEH exception\n+        ** is thrown.  *\/\n+        if( !bWriteLock ) pWal->writeLock = 2;\n@@ -68185,1 +68943,0 @@\n-    walDisableBlocking(pWal);\n@@ -68200,0 +68957,1 @@\n+      (void)walEnableBlocking(pWal);\n@@ -68216,0 +68974,1 @@\n+    walDisableBlocking(pWal);\n@@ -68606,1 +69365,3 @@\n-  sqlite3WalEndWriteTransaction(pWal);\n+#ifndef SQLITE_ENABLE_SETLK_TIMEOUT\n+  assert( pWal->writeLock==0 || pWal->readLock<0 );\n+#endif\n@@ -68608,0 +69369,1 @@\n+    sqlite3WalEndWriteTransaction(pWal);\n@@ -68800,1 +69562,1 @@\n-    assert( !memcmp(&pWal->hdr,(void *)walIndexHdr(pWal),sizeof(WalIndexHdr)) );\n+    assert( !memcmp(&pWal->hdr,(void*)pWal->apWiData[0],sizeof(WalIndexHdr)) );\n@@ -68900,0 +69662,1 @@\n+    pWal->iReCksum = 0;\n@@ -68947,0 +69710,3 @@\n+    if( pWal->iReCksum>pWal->hdr.mxFrame ){\n+      pWal->iReCksum = 0;\n+    }\n@@ -70249,0 +71015,6 @@\n+\/*\n+** Maximum amount of storage local to a database page, regardless of\n+** page size.\n+*\/\n+#define BT_MAX_LOCAL  65501  \/* 65536 - 35 *\/\n+\n@@ -70657,1 +71429,1 @@\n-  int skipOk = 1;\n+  u8 skipOk = 1;\n@@ -71513,1 +72285,1 @@\n-    pKey = sqlite3Malloc( pCur->nKey + 9 + 8 );\n+    pKey = sqlite3Malloc( ((i64)pCur->nKey) + 9 + 8 );\n@@ -71803,1 +72575,1 @@\n-  pCur->hints = x;\n+  pCur->hints = (u8)x;\n@@ -71997,0 +72769,1 @@\n+  assert( nPayload>=0 );\n@@ -71998,1 +72771,1 @@\n-    return nPayload;\n+    return (int)nPayload;\n@@ -72003,2 +72776,2 @@\n-    surplus = minLocal + (nPayload - minLocal)%(pPage->pBt->usableSize-4);\n-    return ( surplus <= maxLocal ) ? surplus : minLocal;\n+    surplus = (int)(minLocal +(nPayload - minLocal)%(pPage->pBt->usableSize-4));\n+    return (surplus <= maxLocal) ? surplus : minLocal;\n@@ -72114,0 +72887,2 @@\n+  assert( nPayload>=0 );\n+  assert( pPage->maxLocal <= BT_MAX_LOCAL );\n@@ -72118,1 +72893,1 @@\n-    pInfo->nSize = nPayload + (u16)(pIter - pCell);\n+    pInfo->nSize = (u16)nPayload + (u16)(pIter - pCell);\n@@ -72151,0 +72926,2 @@\n+  assert( nPayload>=0 );\n+  assert( pPage->maxLocal <= BT_MAX_LOCAL );\n@@ -72155,1 +72932,1 @@\n-    pInfo->nSize = nPayload + (u16)(pIter - pCell);\n+    pInfo->nSize = (u16)nPayload + (u16)(pIter - pCell);\n@@ -72694,3 +73471,3 @@\n-static int freeSpace(MemPage *pPage, u16 iStart, u16 iSize){\n-  u16 iPtr;                             \/* Address of ptr to next freeblock *\/\n-  u16 iFreeBlk;                         \/* Address of the next freeblock *\/\n+static int freeSpace(MemPage *pPage, int iStart, int iSize){\n+  int iPtr;                             \/* Address of ptr to next freeblock *\/\n+  int iFreeBlk;                         \/* Address of the next freeblock *\/\n@@ -72698,4 +73475,4 @@\n-  u8 nFrag = 0;                         \/* Reduction in fragmentation *\/\n-  u16 iOrigSize = iSize;                \/* Original value of iSize *\/\n-  u16 x;                                \/* Offset to cell content area *\/\n-  u32 iEnd = iStart + iSize;            \/* First byte past the iStart buffer *\/\n+  int nFrag = 0;                        \/* Reduction in fragmentation *\/\n+  int iOrigSize = iSize;                \/* Original value of iSize *\/\n+  int x;                                \/* Offset to cell content area *\/\n+  int iEnd = iStart + iSize;            \/* First byte past the iStart buffer *\/\n@@ -72728,1 +73505,1 @@\n-    if( iFreeBlk>pPage->pBt->usableSize-4 ){ \/* TH3: corrupt081.100 *\/\n+    if( iFreeBlk>(int)pPage->pBt->usableSize-4 ){ \/* TH3: corrupt081.100 *\/\n@@ -72743,1 +73520,1 @@\n-      if( iEnd > pPage->pBt->usableSize ){\n+      if( iEnd > (int)pPage->pBt->usableSize ){\n@@ -72764,1 +73541,1 @@\n-    data[hdr+7] -= nFrag;\n+    data[hdr+7] -= (u8)nFrag;\n@@ -72785,1 +73562,2 @@\n-    put2byte(&data[iStart+2], iSize);\n+    assert( iSize>=0 && iSize<=0xffff );\n+    put2byte(&data[iStart+2], (u16)iSize);\n@@ -73011,1 +73789,1 @@\n-  pPage->cellOffset = pPage->hdrOffset + 8 + pPage->childPtrSize;\n+  pPage->cellOffset = (u16)(pPage->hdrOffset + 8 + pPage->childPtrSize);\n@@ -73045,2 +73823,2 @@\n-  u8 hdr = pPage->hdrOffset;\n-  u16 first;\n+  int hdr = pPage->hdrOffset;\n+  int first;\n@@ -73063,1 +73841,1 @@\n-  pPage->cellOffset = first;\n+  pPage->cellOffset = (u16)first;\n@@ -73849,1 +74627,1 @@\n-  pBt->nReserveWanted = nReserve;\n+  pBt->nReserveWanted = (u8)nReserve;\n@@ -73955,1 +74733,1 @@\n-    p->pBt->btsFlags |= BTS_SECURE_DELETE*newFlag;\n+    p->pBt->btsFlags |= (u16)(BTS_SECURE_DELETE*newFlag);\n@@ -74475,0 +75253,7 @@\n+#if defined(SQLITE_ENABLE_SETLK_TIMEOUT)\n+    if( rc==SQLITE_BUSY_TIMEOUT ){\n+      \/* If a blocking lock timed out, break out of the loop here so that\n+      ** the busy-handler is not invoked.  *\/\n+      break;\n+    }\n+#endif\n@@ -76884,1 +77669,1 @@\n-        pCellKey = sqlite3Malloc( nCell+nOverrun );\n+        pCellKey = sqlite3Malloc( (u64)nCell+(u64)nOverrun );\n@@ -78403,1 +79188,2 @@\n-  pPg->nCell = nCell;\n+  assert( nCell < 10922 );\n+  pPg->nCell = (u16)nCell;\n@@ -78650,1 +79436,4 @@\n-  ) ) goto editpage_fail;\n+      )\n+  ){\n+    goto editpage_fail;\n+  }\n@@ -78652,1 +79441,2 @@\n-  pPg->nCell = nNew;\n+  assert( nNew < 10922 );\n+  pPg->nCell = (u16)nNew;\n@@ -78961,1 +79751,1 @@\n-  int szScratch;               \/* Size of scratch memory requested *\/\n+  u64 szScratch;               \/* Size of scratch memory requested *\/\n@@ -80246,1 +81036,1 @@\n-        x2.nData = pX->nKey;\n+        x2.nData = (int)pX->nKey;  assert( pX->nKey<=0x7fffffff );\n@@ -80427,1 +81217,1 @@\n-    *(aOut++) = pSrc->info.nPayload;\n+    *(aOut++) = (u8)pSrc->info.nPayload;\n@@ -80440,1 +81230,1 @@\n-    pBt->nPreformatSize = nIn + (aOut - pBt->pTmpSpace);\n+    pBt->nPreformatSize = nIn + (int)(aOut - pBt->pTmpSpace);\n@@ -80452,1 +81242,1 @@\n-    pBt->nPreformatSize = nOut + (aOut - pBt->pTmpSpace);\n+    pBt->nPreformatSize = (int)nOut + (int)(aOut - pBt->pTmpSpace);\n@@ -82073,0 +82863,1 @@\n+  assert( nBytes==0 || nBytes==sizeof(Schema) );\n@@ -83189,1 +83980,1 @@\n-** https:\/\/www.sqlite.org\/src\/info\/343634942dd54ab (2018-01-31) for\n+** https:\/\/sqlite.org\/src\/info\/343634942dd54ab (2018-01-31) for\n@@ -83375,1 +84166,1 @@\n-  if( NEVER(pMem->z==0) ) return;\n+  assert( pMem->z!=0 );\n@@ -84488,1 +85279,1 @@\n-      int nByte;                  \/* Bytes of space to allocate *\/\n+      i64 nByte;                  \/* Bytes of space to allocate *\/\n@@ -84554,1 +85345,1 @@\n-  int nVal = 0;                   \/* Size of apVal[] array *\/\n+  int nVal = 0;                   \/* Number of function arguments *\/\n@@ -85552,1 +86343,0 @@\n-  int nByte;\n@@ -85556,2 +86346,1 @@\n-  nByte = sizeof(*pCtx) + (nArg-1)*sizeof(sqlite3_value*);\n-  pCtx = sqlite3DbMallocRawNN(pParse->db, nByte);\n+  pCtx = sqlite3DbMallocRawNN(pParse->db, SZ_CONTEXT(nArg));\n@@ -85833,1 +86622,1 @@\n-      int nByte = (p->nSub+1)*sizeof(SubProgram*);\n+      i64 nByte = (1+(u64)p->nSub)*sizeof(SubProgram*);\n@@ -85963,2 +86752,2 @@\n-** (2) Compute the maximum number of arguments used by any SQL function\n-**     and store that value in *pMaxFuncArgs.\n+** (2) Compute the maximum number of arguments used by the xUpdate\/xFilter\n+**     methods of any virtual table and store that value in *pMaxVtabArgs.\n@@ -85977,2 +86766,2 @@\n-static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){\n-  int nMaxArgs = *pMaxFuncArgs;\n+static void resolveP2Values(Vdbe *p, int *pMaxVtabArgs){\n+  int nMaxVtabArgs = *pMaxVtabArgs;\n@@ -86023,1 +86812,1 @@\n-          if( pOp->p2>nMaxArgs ) nMaxArgs = pOp->p2;\n+          if( pOp->p2>nMaxVtabArgs ) nMaxVtabArgs = pOp->p2;\n@@ -86028,0 +86817,3 @@\n+          \/* The instruction immediately prior to VFilter will be an\n+          ** OP_Integer that sets the \"argc\" value for the VFilter.  See\n+          ** the code where OP_VFilter is generated at tag-20250207a. *\/\n@@ -86030,0 +86822,1 @@\n+          assert( pOp[-1].p2==pOp->p3+1 );\n@@ -86031,1 +86824,1 @@\n-          if( n>nMaxArgs ) nMaxArgs = n;\n+          if( n>nMaxVtabArgs ) nMaxVtabArgs = n;\n@@ -86072,1 +86865,1 @@\n-  *pMaxFuncArgs = nMaxArgs;\n+  *pMaxVtabArgs = nMaxVtabArgs;\n@@ -86301,1 +87094,1 @@\n-    sqlite3_int64 nByte = (p->nScan+1) * sizeof(ScanStatus);\n+    i64 nByte = (1+(i64)p->nScan) * sizeof(ScanStatus);\n@@ -86411,0 +87204,3 @@\n+#ifdef SQLITE_DEBUG\n+  while( pOp->opcode==OP_ReleaseReg ) pOp--;\n+#endif\n@@ -87750,1 +88546,1 @@\n-  int nArg;                      \/* Number of arguments in subprograms *\/\n+  int nArg;                      \/* Max number args to xFilter or xUpdate *\/\n@@ -87822,0 +88618,3 @@\n+#ifdef SQLITE_DEBUG\n+  p->napArg = nArg;\n+#endif\n@@ -89319,0 +90118,1 @@\n+  assert( sizeof(UnpackedRecord) + sizeof(Mem)*65536 < 0x7fffffff );\n@@ -90625,4 +91425,5 @@\n-  preupdate.keyinfo.db = db;\n-  preupdate.keyinfo.enc = ENC(db);\n-  preupdate.keyinfo.nKeyField = pTab->nCol;\n-  preupdate.keyinfo.aSortFlags = (u8*)&fakeSortOrder;\n+  preupdate.pKeyinfo = (KeyInfo*)&preupdate.keyinfoSpace;\n+  preupdate.pKeyinfo->db = db;\n+  preupdate.pKeyinfo->enc = ENC(db);\n+  preupdate.pKeyinfo->nKeyField = pTab->nCol;\n+  preupdate.pKeyinfo->aSortFlags = (u8*)&fakeSortOrder;\n@@ -90638,2 +91439,2 @@\n-  vdbeFreeUnpacked(db, preupdate.keyinfo.nKeyField+1, preupdate.pUnpacked);\n-  vdbeFreeUnpacked(db, preupdate.keyinfo.nKeyField+1, preupdate.pNewUnpacked);\n+  vdbeFreeUnpacked(db, preupdate.pKeyinfo->nKeyField+1,preupdate.pUnpacked);\n+  vdbeFreeUnpacked(db, preupdate.pKeyinfo->nKeyField+1,preupdate.pNewUnpacked);\n@@ -92470,1 +93271,1 @@\n-    nData &= ~(u16)1;\n+    nData &= ~(u64)1;\n@@ -92878,1 +93679,1 @@\n-        p->pUnpacked = vdbeUnpackRecord(&p->keyinfo, nRec, aRec);\n+        p->pUnpacked = vdbeUnpackRecord(p->pKeyinfo, nRec, aRec);\n@@ -92895,1 +93696,3 @@\n-          int nByte = sizeof(sqlite3_value*)*p->pTab->nCol;\n+          int nByte;\n+          assert( sizeof(sqlite3_value*)*UMXV(p->pTab->nCol) < 0x7fffffff );\n+          nByte = sizeof(sqlite3_value*)*p->pTab->nCol;\n@@ -92941,1 +93744,1 @@\n-  return (p ? p->keyinfo.nKeyField : 0);\n+  return (p ? p->pKeyinfo->nKeyField : 0);\n@@ -93024,1 +93827,1 @@\n-      pUnpack = vdbeUnpackRecord(&p->keyinfo, pData->n, pData->z);\n+      pUnpack = vdbeUnpackRecord(p->pKeyinfo, pData->n, pData->z);\n@@ -93045,1 +93848,2 @@\n-      p->aNew = (Mem *)sqlite3DbMallocZero(db, sizeof(Mem) * p->pCsr->nField);\n+      assert( sizeof(Mem)*UMXV(p->pCsr->nField) < 0x7fffffff );\n+      p->aNew = (Mem *)sqlite3DbMallocZero(db, sizeof(Mem)*p->pCsr->nField);\n@@ -93815,1 +94619,1 @@\n-  int nByte;\n+  i64 nByte;\n@@ -93817,3 +94621,3 @@\n-  nByte =\n-      ROUND8P(sizeof(VdbeCursor)) + 2*sizeof(u32)*nField +\n-      (eCurType==CURTYPE_BTREE?sqlite3BtreeCursorSize():0);\n+  nByte = SZ_VDBECURSOR(nField);\n+  assert( ROUND8(nByte)==nByte );\n+  if( eCurType==CURTYPE_BTREE ) nByte += sqlite3BtreeCursorSize();\n@@ -93843,1 +94647,1 @@\n-    pMem->szMalloc = nByte;\n+    pMem->szMalloc = (int)nByte;\n@@ -93852,2 +94656,2 @@\n-    pCx->uc.pCursor = (BtCursor*)\n-        &pMem->z[ROUND8P(sizeof(VdbeCursor))+2*sizeof(u32)*nField];\n+    assert( ROUND8(SZ_VDBECURSOR(nField))==SZ_VDBECURSOR(nField) );\n+    pCx->uc.pCursor = (BtCursor*)&pMem->z[SZ_VDBECURSOR(nField)];\n@@ -94857,1 +95661,1 @@\n-    sqlite3_log(pOp->p1, \"abort at %d in [%s]: %s\", pcx, p->zSql, p->zErrMsg);\n+    sqlite3_log(pOp->p1, \"abort at %d: %s; [%s]\", pcx, p->zErrMsg, p->zSql);\n@@ -96183,1 +96987,1 @@\n-\/* Opcode: Once P1 P2 * * *\n+\/* Opcode: Once P1 P2 P3 * *\n@@ -96199,0 +97003,6 @@\n+**\n+** The P3 operand is not used directly by this opcode.  However P3 is\n+** used by the code generator as follows:  If this opcode is the start\n+** of a subroutine and that subroutine uses a Bloom filter, then P3 will\n+** be the register that holds that Bloom filter.  See tag-202407032019\n+** in the source code for implementation details.\n@@ -97244,0 +98054,1 @@\n+        assert( pRec->z!=(const char*)sqlite3CtypeMap );\n@@ -99595,1 +100406,1 @@\n-  ** If this where not the case, on of the following assert()s\n+  ** If this were not the case, one of the following assert()s\n@@ -100864,1 +101675,1 @@\n-  int nByte;              \/* Bytes of runtime space required for sub-program *\/\n+  i64 nByte;              \/* Bytes of runtime space required for sub-program *\/\n@@ -100915,1 +101726,1 @@\n-              + (pProgram->nOp + 7)\/8;\n+              + (7 + (i64)pProgram->nOp)\/8;\n@@ -100923,1 +101734,1 @@\n-    pRt->n = nByte;\n+    pRt->n = (int)nByte;\n@@ -101022,3 +101833,1 @@\n-  if( db->flags & SQLITE_DeferFKs ){\n-    db->nDeferredImmCons += pOp->p2;\n-  }else if( pOp->p1 ){\n+  if( pOp->p1 ){\n@@ -101027,1 +101836,5 @@\n-    p->nFkConstraint += pOp->p2;\n+    if( db->flags & SQLITE_DeferFKs ){\n+      db->nDeferredImmCons += pOp->p2;\n+    }else{\n+      p->nFkConstraint += pOp->p2;\n+    }\n@@ -101242,1 +102055,1 @@\n-  nAlloc = ROUND8P( sizeof(pCtx[0]) + (n-1)*sizeof(sqlite3_value*) );\n+  nAlloc = ROUND8P( SZ_CONTEXT(n) );\n@@ -101902,0 +102715,1 @@\n+  assert( nArg<=p->napArg );\n@@ -102112,0 +102926,1 @@\n+    assert( nArg<=p->napArg );\n@@ -102688,2 +103503,2 @@\n-  sqlite3_log(rc, \"statement aborts at %d: [%s] %s\",\n-                   (int)(pOp - aOp), p->zSql, p->zErrMsg);\n+  sqlite3_log(rc, \"statement aborts at %d: %s; [%s]\",\n+                   (int)(pOp - aOp), p->zErrMsg, p->zSql);\n@@ -102898,0 +103713,1 @@\n+  int iDb;\n@@ -102943,1 +103759,4 @@\n-    if( !pTab ){\n+    if( pTab==0\n+     || ((iDb = sqlite3SchemaToIndex(db, pTab->pSchema))==1 &&\n+         sqlite3OpenTempDatabase(&sParse))\n+    ){\n@@ -102954,1 +103773,1 @@\n-    pBlob->zDb = db->aDb[sqlite3SchemaToIndex(db, pTab->pSchema)].zDbSName;\n+    pBlob->zDb = db->aDb[iDb].zDbSName;\n@@ -102957,6 +103776,2 @@\n-    for(iCol=0; iCol<pTab->nCol; iCol++) {\n-      if( sqlite3StrICmp(pTab->aCol[iCol].zCnName, zColumn)==0 ){\n-        break;\n-      }\n-    }\n-    if( iCol==pTab->nCol ){\n+    iCol = sqlite3ColumnIndex(pTab, zColumn);\n+    if( iCol<0 ){\n@@ -103042,1 +103857,0 @@\n-      int iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n@@ -103620,1 +104434,1 @@\n-  SortSubtask aTask[1];           \/* One or more subtasks *\/\n+  SortSubtask aTask[FLEXARRAY];   \/* One or more subtasks *\/\n@@ -103623,0 +104437,3 @@\n+\/* Size (in bytes) of a VdbeSorter object that works with N or fewer subtasks *\/\n+#define SZ_VDBESORTER(N)  (offsetof(VdbeSorter,aTask)+(N)*sizeof(SortSubtask))\n+\n@@ -104224,1 +105041,1 @@\n-  int sz;                         \/* Size of pSorter in bytes *\/\n+  i64 sz;                         \/* Size of pSorter in bytes *\/\n@@ -104252,2 +105069,4 @@\n-  szKeyInfo = sizeof(KeyInfo) + (pCsr->pKeyInfo->nKeyField-1)*sizeof(CollSeq*);\n-  sz = sizeof(VdbeSorter) + nWorker * sizeof(SortSubtask);\n+  assert( sizeof(KeyInfo) + UMXV(pCsr->pKeyInfo->nKeyField)*sizeof(CollSeq*)\n+               < 0x7fffffff );\n+  szKeyInfo = SZ_KEYINFO(pCsr->pKeyInfo->nKeyField);\n+  sz = SZ_VDBESORTER(nWorker+1);\n@@ -104465,1 +105284,1 @@\n-  int nByte;                      \/* Total bytes of space to allocate *\/\n+  i64 nByte;                      \/* Total bytes of space to allocate *\/\n@@ -104717,0 +105536,4 @@\n+      \/* ,--Each aSlot[] holds twice as much as the previous. So we cannot use\n+      ** |  up all 64 aSlots[] with only a 64-bit address space.\n+      ** v                                                                *\/\n+      assert( i<ArraySize(aSlot) );\n@@ -107508,1 +108331,0 @@\n-  Column *pCol;                     \/* A column of pTab *\/\n@@ -107559,1 +108381,0 @@\n-        u8 hCol;\n@@ -107647,35 +108468,24 @@\n-        hCol = sqlite3StrIHash(zCol);\n-        for(j=0, pCol=pTab->aCol; j<pTab->nCol; j++, pCol++){\n-          if( pCol->hName==hCol\n-           && sqlite3StrICmp(pCol->zCnName, zCol)==0\n-          ){\n-            if( cnt>0 ){\n-              if( pItem->fg.isUsing==0\n-               || sqlite3IdListIndex(pItem->u3.pUsing, zCol)<0\n-              ){\n-                \/* Two or more tables have the same column name which is\n-                ** not joined by USING.  This is an error.  Signal as much\n-                ** by clearing pFJMatch and letting cnt go above 1. *\/\n-                sqlite3ExprListDelete(db, pFJMatch);\n-                pFJMatch = 0;\n-              }else\n-              if( (pItem->fg.jointype & JT_RIGHT)==0 ){\n-                \/* An INNER or LEFT JOIN.  Use the left-most table *\/\n-                continue;\n-              }else\n-              if( (pItem->fg.jointype & JT_LEFT)==0 ){\n-                \/* A RIGHT JOIN.  Use the right-most table *\/\n-                cnt = 0;\n-                sqlite3ExprListDelete(db, pFJMatch);\n-                pFJMatch = 0;\n-              }else{\n-                \/* For a FULL JOIN, we must construct a coalesce() func *\/\n-                extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n-              }\n-            }\n-            cnt++;\n-            pMatch = pItem;\n-            \/* Substitute the rowid (column -1) for the INTEGER PRIMARY KEY *\/\n-            pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;\n-            if( pItem->fg.isNestedFrom ){\n-              sqlite3SrcItemColumnUsed(pItem, j);\n+        j = sqlite3ColumnIndex(pTab, zCol);\n+        if( j>=0 ){\n+          if( cnt>0 ){\n+            if( pItem->fg.isUsing==0\n+             || sqlite3IdListIndex(pItem->u3.pUsing, zCol)<0\n+            ){\n+              \/* Two or more tables have the same column name which is\n+              ** not joined by USING.  This is an error.  Signal as much\n+              ** by clearing pFJMatch and letting cnt go above 1. *\/\n+              sqlite3ExprListDelete(db, pFJMatch);\n+              pFJMatch = 0;\n+            }else\n+            if( (pItem->fg.jointype & JT_RIGHT)==0 ){\n+              \/* An INNER or LEFT JOIN.  Use the left-most table *\/\n+              continue;\n+            }else\n+            if( (pItem->fg.jointype & JT_LEFT)==0 ){\n+              \/* A RIGHT JOIN.  Use the right-most table *\/\n+              cnt = 0;\n+              sqlite3ExprListDelete(db, pFJMatch);\n+              pFJMatch = 0;\n+            }else{\n+              \/* For a FULL JOIN, we must construct a coalesce() func *\/\n+              extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n@@ -107683,1 +108493,7 @@\n-            break;\n+          }\n+          cnt++;\n+          pMatch = pItem;\n+          \/* Substitute the rowid (column -1) for the INTEGER PRIMARY KEY *\/\n+          pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;\n+          if( pItem->fg.isNestedFrom ){\n+            sqlite3SrcItemColumnUsed(pItem, j);\n@@ -107773,1 +108589,0 @@\n-        u8 hCol = sqlite3StrIHash(zCol);\n@@ -107776,8 +108591,8 @@\n-        for(iCol=0, pCol=pTab->aCol; iCol<pTab->nCol; iCol++, pCol++){\n-          if( pCol->hName==hCol\n-           && sqlite3StrICmp(pCol->zCnName, zCol)==0\n-          ){\n-            if( iCol==pTab->iPKey ){\n-              iCol = -1;\n-            }\n-            break;\n+        iCol = sqlite3ColumnIndex(pTab, zCol);\n+        if( iCol>=0 ){\n+          if( pTab->iPKey==iCol ) iCol = -1;\n+        }else{\n+          if( sqlite3IsRowid(zCol) && VisibleRowid(pTab) ){\n+            iCol = -1;\n+          }else{\n+            iCol = pTab->nCol;\n@@ -107786,4 +108601,0 @@\n-        if( iCol>=pTab->nCol && sqlite3IsRowid(zCol) && VisibleRowid(pTab) ){\n-          \/* IMP: R-51414-32910 *\/\n-          iCol = -1;\n-        }\n@@ -108428,1 +109239,1 @@\n-          ** all this. *\/\n+          ** allow this. *\/\n@@ -108434,1 +109245,0 @@\n-          if( pNC->ncFlags & NC_FromDDL ) ExprSetProperty(pExpr, EP_FromDDL);\n@@ -108450,0 +109260,1 @@\n+          if( pNC->ncFlags & NC_FromDDL ) ExprSetProperty(pExpr, EP_FromDDL);\n@@ -109503,1 +110314,1 @@\n-  SrcList sSrc;                   \/* Fake SrcList for pParse->pNewTable *\/\n+  SrcList *pSrc;                  \/* Fake SrcList for pParse->pNewTable *\/\n@@ -109506,0 +110317,1 @@\n+  u8 srcSpace[SZ_SRCLIST_1];     \/* Memory space for the fake SrcList *\/\n@@ -109511,1 +110323,2 @@\n-  memset(&sSrc, 0, sizeof(sSrc));\n+  pSrc = (SrcList*)srcSpace;\n+  memset(pSrc, 0, SZ_SRCLIST_1);\n@@ -109513,4 +110326,4 @@\n-    sSrc.nSrc = 1;\n-    sSrc.a[0].zName = pTab->zName;\n-    sSrc.a[0].pSTab = pTab;\n-    sSrc.a[0].iCursor = -1;\n+    pSrc->nSrc = 1;\n+    pSrc->a[0].zName = pTab->zName;\n+    pSrc->a[0].pSTab = pTab;\n+    pSrc->a[0].iCursor = -1;\n@@ -109524,1 +110337,1 @@\n-  sNC.pSrcList = &sSrc;\n+  sNC.pSrcList = pSrc;\n@@ -109608,1 +110421,3 @@\n-    if( op==TK_VECTOR ){\n+    if( op==TK_VECTOR\n+     || (op==TK_FUNCTION && pExpr->affExpr==SQLITE_AFF_DEFER)\n+    ){\n@@ -109801,1 +110616,3 @@\n-    if( op==TK_VECTOR ){\n+    if( op==TK_VECTOR\n+     || (op==TK_FUNCTION && p->affExpr==SQLITE_AFF_DEFER)\n+    ){\n@@ -110675,1 +111492,1 @@\n-    if( (f&(EP_OuterON|EP_InnerON|EP_IsFalse))==EP_IsFalse\n+    if( (f&(EP_OuterON|EP_InnerON|EP_IsFalse|EP_HasFunc))==EP_IsFalse\n@@ -111273,1 +112090,1 @@\n-    sqlite3_int64 nByte = sizeof(*p) + sizeof(p->a[0]) * (p->nCte-1);\n+    sqlite3_int64 nByte = SZ_WITH(p->nCte);\n@@ -111384,1 +112201,0 @@\n-    pItem->fg.done = 0;\n@@ -111401,1 +112217,0 @@\n-  int nByte;\n@@ -111404,2 +112219,1 @@\n-  nByte = sizeof(*p) + (p->nSrc>0 ? sizeof(p->a[0]) * (p->nSrc-1) : 0);\n-  pNew = sqlite3DbMallocRawNN(db, nByte );\n+  pNew = sqlite3DbMallocRawNN(db, SZ_SRCLIST(p->nSrc) );\n@@ -111467,1 +112281,1 @@\n-  pNew = sqlite3DbMallocRawNN(db, sizeof(*pNew)+(p->nId-1)*sizeof(p->a[0]) );\n+  pNew = sqlite3DbMallocRawNN(db, SZ_IDLIST(p->nId));\n@@ -111499,1 +112313,1 @@\n-    pNew->selFlags = p->selFlags & ~SF_UsesEphemeral;\n+    pNew->selFlags = p->selFlags & ~(u32)SF_UsesEphemeral;\n@@ -111551,1 +112365,1 @@\n-  pList = sqlite3DbMallocRawNN(db, sizeof(ExprList)+sizeof(pList->a[0])*4 );\n+  pList = sqlite3DbMallocRawNN(db, SZ_EXPRLIST(4));\n@@ -111571,2 +112385,1 @@\n-  pNew = sqlite3DbRealloc(db, pList,\n-       sizeof(*pList)+(pList->nAlloc-1)*sizeof(pList->a[0]));\n+  pNew = sqlite3DbRealloc(db, pList, SZ_EXPRLIST(pList->nAlloc));\n@@ -112501,7 +113314,1 @@\n-    int iCol;\n-    for(iCol=0; iCol<pTab->nCol; iCol++){\n-      if( sqlite3_stricmp(azOpt[ii], pTab->aCol[iCol].zCnName)==0 ) break;\n-    }\n-    if( iCol==pTab->nCol ){\n-      return azOpt[ii];\n-    }\n+    if( sqlite3ColumnIndex(pTab, azOpt[ii])<0 ) return azOpt[ii];\n@@ -112911,1 +113718,1 @@\n-  zRet = sqlite3DbMallocRaw(pParse->db, nVal+1);\n+  zRet = sqlite3DbMallocRaw(pParse->db, 1+(i64)nVal);\n@@ -113171,0 +113978,2 @@\n+        \/* Remember that location of the Bloom filter in the P3 operand\n+        ** of the OP_Once that began this subroutine. tag-202407032019 *\/\n@@ -113173,3 +113982,2 @@\n-          sqlite3VdbeChangeToNoop(v, addrBloom);\n-        }else{\n-          sqlite3VdbeGetOp(v, addrOnce)->p3 = dest.iSDParm2;\n+          \/* If the Bloom filter won't actually be used, keep it small *\/\n+          sqlite3VdbeGetOp(v, addrBloom)->p1 = 10;\n@@ -113622,1 +114430,1 @@\n-        if( pOp->opcode==OP_Once && pOp->p3>0 ){\n+        if( pOp->opcode==OP_Once && pOp->p3>0 ){  \/* tag-202407032019 *\/\n@@ -114214,1 +115022,1 @@\n-** Expresion pExpr is guaranteed to be a TK_COLUMN or equivalent. This\n+** Expression pExpr is guaranteed to be a TK_COLUMN or equivalent. This\n@@ -114438,0 +115246,6 @@\n+    case TK_NULLS: {\n+      \/* Set a range of registers to NULL.  pExpr->y.nReg registers starting\n+      ** with target *\/\n+      sqlite3VdbeAddOp3(v, OP_Null, 0, target, target + pExpr->y.nReg - 1);\n+      return target;\n+    }\n@@ -115122,0 +115936,19 @@\n+\/*\n+** Make arrangements to invoke OP_Null on a range of registers\n+** during initialization.\n+*\/\n+SQLITE_PRIVATE SQLITE_NOINLINE void sqlite3ExprNullRegisterRange(\n+  Parse *pParse,   \/* Parsing context *\/\n+  int iReg,        \/* First register to set to NULL *\/\n+  int nReg         \/* Number of sequential registers to NULL out *\/\n+){\n+  u8 okConstFactor = pParse->okConstFactor;\n+  Expr t;\n+  memset(&t, 0, sizeof(t));\n+  t.op = TK_NULLS;\n+  t.y.nReg = nReg;\n+  pParse->okConstFactor = 1;\n+  sqlite3ExprCodeRunJustOnce(pParse, &t, iReg);\n+  pParse->okConstFactor = okConstFactor;\n+}\n+\n@@ -115471,1 +116304,2 @@\n-      sqlite3VdbeTypeofColumn(v, r1);\n+      assert( regFree1==0 || regFree1==r1 );\n+      if( regFree1 ) sqlite3VdbeTypeofColumn(v, r1);\n@@ -115475,1 +116309,0 @@\n-      testcase( regFree1==0 );\n@@ -115646,1 +116479,2 @@\n-      sqlite3VdbeTypeofColumn(v, r1);\n+      assert( regFree1==0 || regFree1==r1 );\n+      if( regFree1 ) sqlite3VdbeTypeofColumn(v, r1);\n@@ -115650,1 +116484,0 @@\n-      testcase( regFree1==0 );\n@@ -116550,0 +117383,1 @@\n+  int mxTerm = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];\n@@ -116551,0 +117385,1 @@\n+  assert( mxTerm <= SMXV(i16) );\n@@ -116568,0 +117403,4 @@\n+  if( k>mxTerm ){\n+    sqlite3ErrorMsg(pParse, \"more than %d aggregate terms\", mxTerm);\n+    k = mxTerm;\n+  }\n@@ -116601,0 +117440,1 @@\n+  assert( k <= SMXV(pExpr->iAgg) );\n@@ -116685,0 +117525,2 @@\n+        int mxTerm = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];\n+        assert( mxTerm <= SMXV(i16) );\n@@ -116691,1 +117533,5 @@\n-        if( i>=pAggInfo->nFunc ){\n+        if( i>mxTerm ){\n+          sqlite3ErrorMsg(pParse, \"more than %d aggregate terms\", mxTerm);\n+          i = mxTerm;\n+          assert( i<pAggInfo->nFunc );\n+        }else if( i>=pAggInfo->nFunc ){\n@@ -116745,0 +117591,1 @@\n+        assert( i <= SMXV(pExpr->iAgg) );\n@@ -117455,1 +118302,1 @@\n-  pNew->aCol = (Column*)sqlite3DbMallocZero(db, sizeof(Column)*nAlloc);\n+  pNew->aCol = (Column*)sqlite3DbMallocZero(db, sizeof(Column)*(u32)nAlloc);\n@@ -117461,1 +118308,1 @@\n-  memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*pNew->nCol);\n+  memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*(size_t)pNew->nCol);\n@@ -117556,4 +118403,2 @@\n-  for(iCol=0; iCol<pTab->nCol; iCol++){\n-    if( 0==sqlite3StrICmp(pTab->aCol[iCol].zCnName, zOld) ) break;\n-  }\n-  if( iCol==pTab->nCol ){\n+  iCol = sqlite3ColumnIndex(pTab, zOld);\n+  if( iCol<0 ){\n@@ -118062,0 +118907,1 @@\n+  u64 flags;\n@@ -118070,1 +118916,7 @@\n-  db->init.iDb = bTemp ? 1 : sqlite3FindDbName(db, zDb);\n+  if( bTemp ){\n+    db->init.iDb = 1;\n+  }else{\n+    int iDb = sqlite3FindDbName(db, zDb);\n+    assert( iDb>=0 && iDb<=0xff );\n+    db->init.iDb = (u8)iDb;\n+  }\n@@ -118074,0 +118926,3 @@\n+  flags = db->flags;\n+  testcase( (db->flags & SQLITE_Comments)==0 && strstr(zSql,\" \/* \")!=0 );\n+  db->flags |= SQLITE_Comments;\n@@ -118075,0 +118930,1 @@\n+  db->flags = flags;\n@@ -118137,2 +118993,2 @@\n-    assert( nQuot>=nNew );\n-    zOut = sqlite3DbMallocZero(db, nSql + pRename->nList*nQuot + 1);\n+    assert( nQuot>=nNew && nSql>=0 && nNew>=0 );\n+    zOut = sqlite3DbMallocZero(db, (u64)nSql + pRename->nList*(u64)nQuot + 1);\n@@ -118140,1 +118996,2 @@\n-    zOut = (char*)sqlite3DbMallocZero(db, (nSql*2+1) * 3);\n+    assert( nSql>0 );\n+    zOut = (char*)sqlite3DbMallocZero(db, (2*(u64)nSql + 1) * 3);\n@@ -118152,2 +119009,3 @@\n-    int nOut = nSql;\n-    memcpy(zOut, zSql, nSql);\n+    i64 nOut = nSql;\n+    assert( nSql>0 );\n+    memcpy(zOut, zSql, (size_t)nSql);\n@@ -118156,1 +119014,1 @@\n-      u32 nReplace;\n+      i64 nReplace;\n@@ -118161,1 +119019,1 @@\n-        if( bQuote==0 && sqlite3IsIdChar(*pBest->t.z) ){\n+        if( bQuote==0 && sqlite3IsIdChar(*(u8*)pBest->t.z) ){\n@@ -118179,1 +119037,2 @@\n-        sqlite3_snprintf(nSql*2, zBuf2, \"%Q%s\", zBuf1,\n+        assert( nSql < 0x15555554 \/* otherwise malloc would have failed *\/ );\n+        sqlite3_snprintf((int)(nSql*2), zBuf2, \"%Q%s\", zBuf1,\n@@ -118186,1 +119045,1 @@\n-      iOff = pBest->t.z - zSql;\n+      iOff = (int)(pBest->t.z - zSql);\n@@ -118212,0 +119071,1 @@\n+  assert( val==ENAME_NAME || val==ENAME_TAB || val==ENAME_SPAN );\n@@ -118216,1 +119076,1 @@\n-      pEList->a[i].fg.eEName = val;\n+      pEList->a[i].fg.eEName = val&0x3;\n@@ -118473,1 +119333,1 @@\n-      pSelect->selFlags &= ~SF_View;\n+      pSelect->selFlags &= ~(u32)SF_View;\n@@ -118691,1 +119551,1 @@\n-            pSelect->selFlags &= ~SF_View;\n+            pSelect->selFlags &= ~(u32)SF_View;\n@@ -118864,1 +119724,1 @@\n-          pSelect->selFlags &= ~SF_View;\n+          pSelect->selFlags &= ~(u32)SF_View;\n@@ -118963,1 +119823,1 @@\n-    int flags = db->flags;\n+    u64 flags = db->flags;\n@@ -118966,1 +119826,1 @@\n-    db->flags |= (flags & (SQLITE_DqsDML|SQLITE_DqsDDL));\n+    db->flags = flags;\n@@ -119458,1 +120318,2 @@\n-        aRoot[i] = (u32)pParse->regRoot;\n+        assert( pParse->isCreate || pParse->nErr );\n+        aRoot[i] = (u32)pParse->u1.cr.regRoot;\n@@ -119649,1 +120510,1 @@\n-  int n;                          \/* Bytes of space to allocate *\/\n+  i64 n;                          \/* Bytes of space to allocate *\/\n@@ -119685,1 +120546,1 @@\n-  p->nLimit = sqlite3_value_int64(argv[3]);\n+  p->nLimit = sqlite3_value_int(argv[3]);\n@@ -120818,10 +121679,0 @@\n-\n-    \/* Set the bLowQual flag if the peak number of rows obtained\n-    ** from a full equality match is so large that a full table scan\n-    ** seems likely to be faster than using the index.\n-    *\/\n-    if( aLog[0] > 66              \/* Index has more than 100 rows *\/\n-     && aLog[0] <= aLog[nOut-1]   \/* And only a single value seen *\/\n-    ){\n-      pIndex->bLowQual = 1;\n-    }\n@@ -121423,1 +122274,1 @@\n-      aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(db->nDb+1) );\n+      aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(1+(i64)db->nDb));\n@@ -121494,0 +122345,7 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    if( db->setlkFlags & SQLITE_SETLK_BLOCK_ON_CONNECT ){\n+      int val = 1;\n+      sqlite3_file *fd = sqlite3PagerFile(sqlite3BtreePager(pNew->pBt));\n+      sqlite3OsFileControlHint(fd, SQLITE_FCNTL_BLOCK_ON_CONNECT, &val);\n+    }\n+#endif\n@@ -122216,0 +123074,1 @@\n+  assert( pToplevel->nTableLock < 0x7fff0000 );\n@@ -122316,1 +123175,1 @@\n-      Returning *pReturning = pParse->u1.pReturning;\n+      Returning *pReturning;\n@@ -122320,0 +123179,2 @@\n+      assert( !pParse->isCreate );\n+      pReturning = pParse->u1.d.pReturning;\n@@ -122395,1 +123256,3 @@\n-      Returning *pRet = pParse->u1.pReturning;\n+      Returning *pRet;\n+      assert( !pParse->isCreate );\n+      pRet = pParse->u1.d.pReturning;\n@@ -123210,1 +124073,1 @@\n-SQLITE_PRIVATE i16 sqlite3TableColumnToIndex(Index *pIdx, i16 iCol){\n+SQLITE_PRIVATE int sqlite3TableColumnToIndex(Index *pIdx, int iCol){\n@@ -123212,0 +124075,4 @@\n+  i16 iCol16;\n+  assert( iCol>=(-1) && iCol<=SQLITE_MAX_COLUMN );\n+  assert( pIdx->nColumn<=SQLITE_MAX_COLUMN+1 );\n+  iCol16 = iCol;\n@@ -123213,1 +124080,3 @@\n-    if( iCol==pIdx->aiColumn[i] ) return i;\n+    if( iCol16==pIdx->aiColumn[i] ){\n+      return i;\n+    }\n@@ -123467,2 +124336,3 @@\n-    reg1 = pParse->regRowid = ++pParse->nMem;\n-    reg2 = pParse->regRoot = ++pParse->nMem;\n+    assert( pParse->isCreate );\n+    reg1 = pParse->u1.cr.regRowid = ++pParse->nMem;\n+    reg2 = pParse->u1.cr.regRoot = ++pParse->nMem;\n@@ -123483,2 +124353,2 @@\n-    ** The rowid for the new entry is left in register pParse->regRowid.\n-    ** The root page number of the new table is left in reg pParse->regRoot.\n+    ** The rowid for the new entry is left in register pParse->u1.cr.regRowid.\n+    ** The root page of the new table is left in reg pParse->u1.cr.regRoot.\n@@ -123495,1 +124365,1 @@\n-      pParse->u1.addrCrTab =\n+      pParse->u1.cr.addrCrTab =\n@@ -123573,1 +124443,2 @@\n-  pParse->u1.pReturning = pRet;\n+  assert( !pParse->isCreate );\n+  pParse->u1.d.pReturning = pRet;\n@@ -123615,1 +124486,0 @@\n-  u8 hName;\n@@ -123669,7 +124539,4 @@\n-  hName = sqlite3StrIHash(z);\n-  for(i=0; i<p->nCol; i++){\n-    if( p->aCol[i].hName==hName && sqlite3StrICmp(z, p->aCol[i].zCnName)==0 ){\n-      sqlite3ErrorMsg(pParse, \"duplicate column name: %s\", z);\n-      sqlite3DbFree(db, z);\n-      return;\n-    }\n+  if( p->nCol && sqlite3ColumnIndex(p, z)>=0 ){\n+    sqlite3ErrorMsg(pParse, \"duplicate column name: %s\", z);\n+    sqlite3DbFree(db, z);\n+    return;\n@@ -123686,1 +124553,1 @@\n-  pCol->hName = hName;\n+  pCol->hName = sqlite3StrIHash(z);\n@@ -123710,0 +124577,4 @@\n+  if( p->nCol<=0xff ){\n+    u8 h = pCol->hName % sizeof(p->aHx);\n+    p->aHx[h] = p->nCol;\n+  }\n@@ -123712,1 +124583,2 @@\n-  pParse->constraintName.n = 0;\n+  assert( pParse->isCreate );\n+  pParse->u1.cr.constraintName.n = 0;\n@@ -123976,1 +124848,0 @@\n-        const char *zCName;\n@@ -123978,7 +124849,4 @@\n-        zCName = pCExpr->u.zToken;\n-        for(iCol=0; iCol<pTab->nCol; iCol++){\n-          if( sqlite3StrICmp(zCName, pTab->aCol[iCol].zCnName)==0 ){\n-            pCol = &pTab->aCol[iCol];\n-            makeColumnPartOfPrimaryKey(pParse, pCol);\n-            break;\n-          }\n+        iCol = sqlite3ColumnIndex(pTab, pCExpr->u.zToken);\n+        if( iCol>=0 ){\n+          pCol = &pTab->aCol[iCol];\n+          makeColumnPartOfPrimaryKey(pParse, pCol);\n@@ -124036,2 +124904,4 @@\n-    if( pParse->constraintName.n ){\n-      sqlite3ExprListSetName(pParse, pTab->pCheck, &pParse->constraintName, 1);\n+    assert( pParse->isCreate );\n+    if( pParse->u1.cr.constraintName.n ){\n+      sqlite3ExprListSetName(pParse, pTab->pCheck,\n+                             &pParse->u1.cr.constraintName, 1);\n@@ -124232,1 +125102,2 @@\n-  int i, k, n;\n+  int i, k, len;\n+  i64 n;\n@@ -124256,2 +125127,3 @@\n-  sqlite3_snprintf(n, zStmt, \"CREATE TABLE \");\n-  k = sqlite3Strlen30(zStmt);\n+  assert( n>14 && n<=0x7fffffff );\n+  memcpy(zStmt, \"CREATE TABLE \", 13);\n+  k = 13;\n@@ -124269,1 +125141,0 @@\n-    int len;\n@@ -124272,2 +125143,4 @@\n-    sqlite3_snprintf(n-k, &zStmt[k], zSep);\n-    k += sqlite3Strlen30(&zStmt[k]);\n+    len = sqlite3Strlen30(zSep);\n+    assert( k+len<n );\n+    memcpy(&zStmt[k], zSep, len);\n+    k += len;\n@@ -124276,0 +125149,1 @@\n+    assert( k<n );\n@@ -124290,0 +125164,1 @@\n+    assert( k+len<n );\n@@ -124294,1 +125169,3 @@\n-  sqlite3_snprintf(n-k, &zStmt[k], \"%s\", zEnd);\n+  len = sqlite3Strlen30(zEnd);\n+  assert( k+len<n );\n+  memcpy(&zStmt[k], zEnd, len+1);\n@@ -124302,1 +125179,1 @@\n-static int resizeIndexObject(sqlite3 *db, Index *pIdx, int N){\n+static int resizeIndexObject(Parse *pParse, Index *pIdx, int N){\n@@ -124304,1 +125181,2 @@\n-  int nByte;\n+  u64 nByte;\n+  sqlite3 *db;\n@@ -124306,0 +125184,4 @@\n+  db = pParse->db;\n+  assert( N>0 );\n+  assert( N <= SQLITE_MAX_COLUMN*2 \/* tag-20250221-1 *\/ );\n+  testcase( N==2*pParse->db->aLimit[SQLITE_LIMIT_COLUMN] );\n@@ -124307,1 +125189,1 @@\n-  nByte = (sizeof(char*) + sizeof(LogEst) + sizeof(i16) + 1)*N;\n+  nByte = (sizeof(char*) + sizeof(LogEst) + sizeof(i16) + 1)*(u64)N;\n@@ -124321,1 +125203,1 @@\n-  pIdx->nColumn = N;\n+  pIdx->nColumn = (u16)N;  \/* See tag-20250221-1 above for proof of safety *\/\n@@ -124487,1 +125369,1 @@\n-  if( pParse->u1.addrCrTab ){\n+  if( pParse->u1.cr.addrCrTab ){\n@@ -124489,1 +125371,1 @@\n-    sqlite3VdbeChangeP3(v, pParse->u1.addrCrTab, BTREE_BLOBKEY);\n+    sqlite3VdbeChangeP3(v, pParse->u1.cr.addrCrTab, BTREE_BLOBKEY);\n@@ -124575,1 +125457,1 @@\n-    if( resizeIndexObject(db, pIdx, pIdx->nKeyCol+n) ) return;\n+    if( resizeIndexObject(pParse, pIdx, pIdx->nKeyCol+n) ) return;\n@@ -124582,1 +125464,1 @@\n-          \/* See ticket https:\/\/www.sqlite.org\/src\/info\/bba7b69f9849b5bf *\/\n+          \/* See ticket https:\/\/sqlite.org\/src\/info\/bba7b69f9849b5bf *\/\n@@ -124599,1 +125481,1 @@\n-  if( resizeIndexObject(db, pPk, nPk+nExtra) ) return;\n+  if( resizeIndexObject(pParse, pPk, nPk+nExtra) ) return;\n@@ -124929,1 +125811,1 @@\n-    ** new table is in register pParse->regRoot.\n+    ** new table is in register pParse->u1.cr.regRoot.\n@@ -124960,1 +125842,2 @@\n-      sqlite3VdbeAddOp3(v, OP_OpenWrite, iCsr, pParse->regRoot, iDb);\n+      assert( pParse->isCreate );\n+      sqlite3VdbeAddOp3(v, OP_OpenWrite, iCsr, pParse->u1.cr.regRoot, iDb);\n@@ -125005,0 +125888,1 @@\n+    assert( pParse->isCreate );\n@@ -125013,1 +125897,1 @@\n-      pParse->regRoot,\n+      pParse->u1.cr.regRoot,\n@@ -125015,1 +125899,1 @@\n-      pParse->regRowid\n+      pParse->u1.cr.regRowid\n@@ -125755,1 +126639,1 @@\n-  nByte = sizeof(*pFKey) + (nCol-1)*sizeof(pFKey->aCol[0]) + pTo->n + 1;\n+  nByte = SZ_FKEY(nCol) + pTo->n + 1;\n@@ -125957,1 +126841,1 @@\n-    ** See ticket: https:\/\/www.sqlite.org\/src\/info\/bba7b69f9849b5bf\n+    ** See ticket: https:\/\/sqlite.org\/src\/info\/bba7b69f9849b5bf\n@@ -125981,1 +126865,1 @@\n-  i16 nCol,            \/* Total number of columns in the index *\/\n+  int nCol,            \/* Total number of columns in the index *\/\n@@ -125986,1 +126870,1 @@\n-  int nByte;           \/* Bytes of space for Index object + arrays *\/\n+  i64 nByte;           \/* Bytes of space for Index object + arrays *\/\n@@ -125988,0 +126872,1 @@\n+  assert( nCol <= 2*db->aLimit[SQLITE_LIMIT_COLUMN] );\n@@ -126000,2 +126885,3 @@\n-    p->nColumn = nCol;\n-    p->nKeyCol = nCol - 1;\n+    assert( nCol>0 );\n+    p->nColumn = (u16)nCol;\n+    p->nKeyCol = (u16)(nCol - 1);\n@@ -126812,1 +127698,1 @@\n-    pList = sqlite3DbMallocZero(db, sizeof(IdList) );\n+    pList = sqlite3DbMallocZero(db, SZ_IDLIST(1));\n@@ -126816,2 +127702,1 @@\n-    pNew = sqlite3DbRealloc(db, pList,\n-                 sizeof(IdList) + pList->nId*sizeof(pList->a));\n+    pNew = sqlite3DbRealloc(db, pList, SZ_IDLIST(pList->nId+1));\n@@ -126916,2 +127801,1 @@\n-    pNew = sqlite3DbRealloc(db, pSrc,\n-               sizeof(*pSrc) + (nAlloc-1)*sizeof(pSrc->a[0]) );\n+    pNew = sqlite3DbRealloc(db, pSrc, SZ_SRCLIST(nAlloc));\n@@ -126992,1 +127876,1 @@\n-    pList = sqlite3DbMallocRawNN(pParse->db, sizeof(SrcList) );\n+    pList = sqlite3DbMallocRawNN(pParse->db, SZ_SRCLIST(1));\n@@ -127878,2 +128762,1 @@\n-    sqlite3_int64 nByte = sizeof(*pWith) + (sizeof(pWith->a[1]) * pWith->nCte);\n-    pNew = sqlite3DbRealloc(db, pWith, nByte);\n+    pNew = sqlite3DbRealloc(db, pWith, SZ_WITH(pWith->nCte+1));\n@@ -127881,1 +128764,1 @@\n-    pNew = sqlite3DbMallocZero(db, sizeof(*pWith));\n+    pNew = sqlite3DbMallocZero(db, SZ_WITH(1));\n@@ -129855,5 +130738,0 @@\n-  if( sqlite3_value_type(argv[1])==SQLITE_NULL\n-   || (argc==3 && sqlite3_value_type(argv[2])==SQLITE_NULL)\n-  ){\n-    return;\n-  }\n@@ -129877,8 +130755,0 @@\n-#ifdef SQLITE_SUBSTR_COMPATIBILITY\n-  \/* If SUBSTR_COMPATIBILITY is defined then substr(X,0,N) work the same as\n-  ** as substr(X,1,N) - it returns the first N characters of X.  This\n-  ** is essentially a back-out of the bug-fix in check-in [5fc125d362df4b8]\n-  ** from 2009-02-02 for compatibility of applications that exploited the\n-  ** old buggy behavior. *\/\n-  if( p1==0 ) p1 = 1; \/* <rdar:\/\/problem\/6778339> *\/\n-#endif\n@@ -129887,0 +130757,1 @@\n+    if( p2==0 && sqlite3_value_type(argv[2])==SQLITE_NULL ) return;\n@@ -129890,0 +130761,11 @@\n+  if( p1==0 ){\n+#ifdef SQLITE_SUBSTR_COMPATIBILITY\n+    \/* If SUBSTR_COMPATIBILITY is defined then substr(X,0,N) work the same as\n+    ** as substr(X,1,N) - it returns the first N characters of X.  This\n+    ** is essentially a back-out of the bug-fix in check-in [5fc125d362df4b8]\n+    ** from 2009-02-02 for compatibility of applications that exploited the\n+    ** old buggy behavior. *\/\n+    p1 = 1; \/* <rdar:\/\/problem\/6778339> *\/\n+#endif\n+    if( sqlite3_value_type(argv[1])==SQLITE_NULL ) return;\n+  }\n@@ -130590,1 +131472,1 @@\n-SQLITE_PRIVATE void sqlite3QuoteValue(StrAccum *pStr, sqlite3_value *pValue){\n+SQLITE_PRIVATE void sqlite3QuoteValue(StrAccum *pStr, sqlite3_value *pValue, int bEscape){\n@@ -130638,1 +131520,1 @@\n-      sqlite3_str_appendf(pStr, \"%Q\", zArg);\n+      sqlite3_str_appendf(pStr, bEscape ? \"%#Q\" : \"%Q\", zArg);\n@@ -130649,0 +131531,99 @@\n+\/*\n+** Return true if z[] begins with N hexadecimal digits, and write\n+** a decoding of those digits into *pVal.  Or return false if any\n+** one of the first N characters in z[] is not a hexadecimal digit.\n+*\/\n+static int isNHex(const char *z, int N, u32 *pVal){\n+  int i;\n+  int v = 0;\n+  for(i=0; i<N; i++){\n+    if( !sqlite3Isxdigit(z[i]) ) return 0;\n+    v = (v<<4) + sqlite3HexToInt(z[i]);\n+  }\n+  *pVal = v;\n+  return 1;\n+}\n+\n+\/*\n+** Implementation of the UNISTR() function.\n+**\n+** This is intended to be a work-alike of the UNISTR() function in\n+** PostgreSQL.  Quoting from the PG documentation (PostgreSQL 17 -\n+** scraped on 2025-02-22):\n+**\n+**    Evaluate escaped Unicode characters in the argument. Unicode\n+**    characters can be specified as \\XXXX (4 hexadecimal digits),\n+**    \\+XXXXXX (6 hexadecimal digits), \\uXXXX (4 hexadecimal digits),\n+**    or \\UXXXXXXXX (8 hexadecimal digits). To specify a backslash,\n+**    write two backslashes. All other characters are taken literally.\n+*\/\n+static void unistrFunc(\n+  sqlite3_context *context,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  char *zOut;\n+  const char *zIn;\n+  int nIn;\n+  int i, j, n;\n+  u32 v;\n+\n+  assert( argc==1 );\n+  UNUSED_PARAMETER( argc );\n+  zIn = (const char*)sqlite3_value_text(argv[0]);\n+  if( zIn==0 ) return;\n+  nIn = sqlite3_value_bytes(argv[0]);\n+  zOut = sqlite3_malloc64(nIn+1);\n+  if( zOut==0 ){\n+    sqlite3_result_error_nomem(context);\n+    return;\n+  }\n+  i = j = 0;\n+  while( i<nIn ){\n+    char *z = strchr(&zIn[i],'\\\\');\n+    if( z==0 ){\n+      n = nIn - i;\n+      memmove(&zOut[j], &zIn[i], n);\n+      j += n;\n+      break;\n+    }\n+    n = z - &zIn[i];\n+    if( n>0 ){\n+      memmove(&zOut[j], &zIn[i], n);\n+      j += n;\n+      i += n;\n+    }\n+    if( zIn[i+1]=='\\\\' ){\n+      i += 2;\n+      zOut[j++] = '\\\\';\n+    }else if( sqlite3Isxdigit(zIn[i+1]) ){\n+      if( !isNHex(&zIn[i+1], 4, &v) ) goto unistr_error;\n+      i += 5;\n+      j += sqlite3AppendOneUtf8Character(&zOut[j], v);\n+    }else if( zIn[i+1]=='+' ){\n+      if( !isNHex(&zIn[i+2], 6, &v) ) goto unistr_error;\n+      i += 8;\n+      j += sqlite3AppendOneUtf8Character(&zOut[j], v);\n+    }else if( zIn[i+1]=='u' ){\n+      if( !isNHex(&zIn[i+2], 4, &v) ) goto unistr_error;\n+      i += 6;\n+      j += sqlite3AppendOneUtf8Character(&zOut[j], v);\n+    }else if( zIn[i+1]=='U' ){\n+      if( !isNHex(&zIn[i+2], 8, &v) ) goto unistr_error;\n+      i += 10;\n+      j += sqlite3AppendOneUtf8Character(&zOut[j], v);\n+    }else{\n+      goto unistr_error;\n+    }\n+  }\n+  zOut[j] = 0;\n+  sqlite3_result_text64(context, zOut, j, sqlite3_free, SQLITE_UTF8);\n+  return;\n+\n+unistr_error:\n+  sqlite3_free(zOut);\n+  sqlite3_result_error(context, \"invalid Unicode escape\", -1);\n+  return;\n+}\n+\n+\n@@ -130658,0 +131639,4 @@\n+**\n+** If sqlite3_user_data() is non-zero, then the UNISTR_QUOTE() function is\n+** implemented instead.  The difference is that UNISTR_QUOTE() uses the\n+** UNISTR() function to escape control characters.\n@@ -130665,1 +131650,1 @@\n-  sqlite3QuoteValue(&str,argv[0]);\n+  sqlite3QuoteValue(&str,argv[0],SQLITE_PTR_TO_INT(sqlite3_user_data(context)));\n@@ -130920,1 +131905,1 @@\n-  zOut = contextMalloc(context, (i64)nOut);\n+  zOut = contextMalloc(context, nOut);\n@@ -131064,1 +132049,1 @@\n-  i64 j, k, n = 0;\n+  i64 j, n = 0;\n@@ -131078,2 +132063,2 @@\n-    k = sqlite3_value_bytes(argv[i]);\n-    if( k>0 ){\n+    if( sqlite3_value_type(argv[i])!=SQLITE_NULL ){\n+      int k = sqlite3_value_bytes(argv[i]);\n@@ -131316,1 +132301,1 @@\n-** value.  TOTAL never fails, but SUM might through an exception if\n+** value.  TOTAL never fails, but SUM might throw an exception if\n@@ -132236,0 +133221,1 @@\n+    FUNCTION(unistr,             1, 0, 0, unistrFunc       ),\n@@ -132237,0 +133223,1 @@\n+    FUNCTION(unistr_quote,       1, 1, 0, quoteFunc        ),\n@@ -134523,1 +135510,1 @@\n-    pLeft->selFlags &= ~SF_MultiValue;\n+    pLeft->selFlags &= ~(u32)SF_MultiValue;\n@@ -134905,10 +135892,7 @@\n-      const char *zCName = pColumn->a[i].zName;\n-      u8 hName = sqlite3StrIHash(zCName);\n-      for(j=0; j<pTab->nCol; j++){\n-        if( pTab->aCol[j].hName!=hName ) continue;\n-        if( sqlite3StrICmp(zCName, pTab->aCol[j].zCnName)==0 ){\n-          if( aTabColMap[j]==0 ) aTabColMap[j] = i+1;\n-          if( i!=j ) bIdListInOrder = 0;\n-          if( j==pTab->iPKey ){\n-            ipkColumn = i;  assert( !withoutRowid );\n-          }\n+      j = sqlite3ColumnIndex(pTab, pColumn->a[i].zName);\n+      if( j>=0 ){\n+        if( aTabColMap[j]==0 ) aTabColMap[j] = i+1;\n+        if( i!=j ) bIdListInOrder = 0;\n+        if( j==pTab->iPKey ){\n+          ipkColumn = i;  assert( !withoutRowid );\n+        }\n@@ -134916,8 +135900,5 @@\n-          if( pTab->aCol[j].colFlags & (COLFLAG_STORED|COLFLAG_VIRTUAL) ){\n-            sqlite3ErrorMsg(pParse,\n-               \"cannot INSERT into generated column \\\"%s\\\"\",\n-               pTab->aCol[j].zCnName);\n-            goto insert_cleanup;\n-          }\n-#endif\n-          break;\n+        if( pTab->aCol[j].colFlags & (COLFLAG_STORED|COLFLAG_VIRTUAL) ){\n+          sqlite3ErrorMsg(pParse,\n+             \"cannot INSERT into generated column \\\"%s\\\"\",\n+             pTab->aCol[j].zCnName);\n+          goto insert_cleanup;\n@@ -134925,2 +135906,2 @@\n-      }\n-      if( j>=pTab->nCol ){\n+#endif\n+      }else{\n@@ -135224,1 +136205,1 @@\n-        ** get there default value *\/\n+        ** get their default value *\/\n@@ -135949,1 +136930,1 @@\n-  ** 2018-08-14: Ticket https:\/\/www.sqlite.org\/src\/info\/908f001483982c43\n+  ** 2018-08-14: Ticket https:\/\/sqlite.org\/src\/info\/908f001483982c43\n@@ -137759,0 +138740,2 @@\n+  \/* Version 3.50.0 and later *\/\n+  int (*setlk_timeout)(sqlite3*,int,int);\n@@ -138092,0 +139075,2 @@\n+\/* Version 3.50.0 and later *\/\n+#define sqlite3_setlk_timeout          sqlite3_api->setlk_timeout\n@@ -138613,1 +139598,3 @@\n-  sqlite3_set_clientdata\n+  sqlite3_set_clientdata,\n+  \/* Version 3.50.0 and later *\/\n+  sqlite3_setlk_timeout\n@@ -139135,2 +140122,2 @@\n-  \/*  15 *\/ \"schema\",      \/* Used by: table_list *\/\n-  \/*  16 *\/ \"name\",\n+  \/*  15 *\/ \"name\",        \/* Used by: function_list *\/\n+  \/*  16 *\/ \"builtin\",\n@@ -139138,25 +140125,25 @@\n-  \/*  18 *\/ \"ncol\",\n-  \/*  19 *\/ \"wr\",\n-  \/*  20 *\/ \"strict\",\n-  \/*  21 *\/ \"seqno\",       \/* Used by: index_xinfo *\/\n-  \/*  22 *\/ \"cid\",\n-  \/*  23 *\/ \"name\",\n-  \/*  24 *\/ \"desc\",\n-  \/*  25 *\/ \"coll\",\n-  \/*  26 *\/ \"key\",\n-  \/*  27 *\/ \"name\",        \/* Used by: function_list *\/\n-  \/*  28 *\/ \"builtin\",\n-  \/*  29 *\/ \"type\",\n-  \/*  30 *\/ \"enc\",\n-  \/*  31 *\/ \"narg\",\n-  \/*  32 *\/ \"flags\",\n-  \/*  33 *\/ \"tbl\",         \/* Used by: stats *\/\n-  \/*  34 *\/ \"idx\",\n-  \/*  35 *\/ \"wdth\",\n-  \/*  36 *\/ \"hght\",\n-  \/*  37 *\/ \"flgs\",\n-  \/*  38 *\/ \"seq\",         \/* Used by: index_list *\/\n-  \/*  39 *\/ \"name\",\n-  \/*  40 *\/ \"unique\",\n-  \/*  41 *\/ \"origin\",\n-  \/*  42 *\/ \"partial\",\n+  \/*  18 *\/ \"enc\",\n+  \/*  19 *\/ \"narg\",\n+  \/*  20 *\/ \"flags\",\n+  \/*  21 *\/ \"schema\",      \/* Used by: table_list *\/\n+  \/*  22 *\/ \"name\",\n+  \/*  23 *\/ \"type\",\n+  \/*  24 *\/ \"ncol\",\n+  \/*  25 *\/ \"wr\",\n+  \/*  26 *\/ \"strict\",\n+  \/*  27 *\/ \"seqno\",       \/* Used by: index_xinfo *\/\n+  \/*  28 *\/ \"cid\",\n+  \/*  29 *\/ \"name\",\n+  \/*  30 *\/ \"desc\",\n+  \/*  31 *\/ \"coll\",\n+  \/*  32 *\/ \"key\",\n+  \/*  33 *\/ \"seq\",         \/* Used by: index_list *\/\n+  \/*  34 *\/ \"name\",\n+  \/*  35 *\/ \"unique\",\n+  \/*  36 *\/ \"origin\",\n+  \/*  37 *\/ \"partial\",\n+  \/*  38 *\/ \"tbl\",         \/* Used by: stats *\/\n+  \/*  39 *\/ \"idx\",\n+  \/*  40 *\/ \"wdth\",\n+  \/*  41 *\/ \"hght\",\n+  \/*  42 *\/ \"flgs\",\n@@ -139167,8 +140154,7 @@\n-                           \/* index_info reuses 21 *\/\n-  \/*  47 *\/ \"seq\",         \/* Used by: database_list *\/\n-  \/*  48 *\/ \"name\",\n-  \/*  49 *\/ \"file\",\n-  \/*  50 *\/ \"busy\",        \/* Used by: wal_checkpoint *\/\n-  \/*  51 *\/ \"log\",\n-  \/*  52 *\/ \"checkpointed\",\n-                           \/* collation_list reuses 38 *\/\n+  \/*  47 *\/ \"busy\",        \/* Used by: wal_checkpoint *\/\n+  \/*  48 *\/ \"log\",\n+  \/*  49 *\/ \"checkpointed\",\n+  \/*  50 *\/ \"seq\",         \/* Used by: database_list *\/\n+  \/*  51 *\/ \"name\",\n+  \/*  52 *\/ \"file\",\n+                           \/* index_info reuses 27 *\/\n@@ -139177,0 +140163,1 @@\n+                           \/* collation_list reuses 33 *\/\n@@ -139269,1 +140256,1 @@\n-  \/* ColNames:  *\/ 38, 2,\n+  \/* ColNames:  *\/ 33, 2,\n@@ -139304,1 +140291,1 @@\n-  \/* ColNames:  *\/ 47, 3,\n+  \/* ColNames:  *\/ 50, 3,\n@@ -139384,1 +140371,1 @@\n-  \/* ColNames:  *\/ 27, 6,\n+  \/* ColNames:  *\/ 15, 6,\n@@ -139413,1 +140400,1 @@\n-  \/* ColNames:  *\/ 21, 3,\n+  \/* ColNames:  *\/ 27, 3,\n@@ -139418,1 +140405,1 @@\n-  \/* ColNames:  *\/ 38, 5,\n+  \/* ColNames:  *\/ 33, 5,\n@@ -139423,1 +140410,1 @@\n-  \/* ColNames:  *\/ 21, 6,\n+  \/* ColNames:  *\/ 27, 6,\n@@ -139602,1 +140589,1 @@\n-  \/* ColNames:  *\/ 33, 5,\n+  \/* ColNames:  *\/ 38, 5,\n@@ -139621,1 +140608,1 @@\n-  \/* ColNames:  *\/ 15, 6,\n+  \/* ColNames:  *\/ 21, 6,\n@@ -139698,1 +140685,1 @@\n-  \/* ColNames:  *\/ 50, 3,\n+  \/* ColNames:  *\/ 47, 3,\n@@ -139720,1 +140707,1 @@\n-** The value of 2000 is chosen emperically so that the worst-case run-time\n+** The value of 2000 is chosen empirically so that the worst-case run-time\n@@ -140837,1 +141824,4 @@\n-        if( mask==SQLITE_DeferFKs ) db->nDeferredImmCons = 0;\n+        if( mask==SQLITE_DeferFKs ){\n+          db->nDeferredImmCons = 0;\n+          db->nDeferredCons = 0;\n+        }\n@@ -144006,1 +144996,1 @@\n-  if( pSrc==0 ) pSrc = sqlite3DbMallocZero(pParse->db, sizeof(*pSrc));\n+  if( pSrc==0 ) pSrc = sqlite3DbMallocZero(pParse->db, SZ_SRCLIST_1);\n@@ -144171,4 +145161,27 @@\n-  u8 h = sqlite3StrIHash(zCol);\n-  Column *pCol;\n-  for(pCol=pTab->aCol, i=0; i<pTab->nCol; pCol++, i++){\n-    if( pCol->hName==h && sqlite3StrICmp(pCol->zCnName, zCol)==0 ) return i;\n+  u8 h;\n+  const Column *aCol;\n+  int nCol;\n+\n+  h = sqlite3StrIHash(zCol);\n+  aCol = pTab->aCol;\n+  nCol = pTab->nCol;\n+\n+  \/* See if the aHx gives us a lucky match *\/\n+  i = pTab->aHx[h % sizeof(pTab->aHx)];\n+  assert( i<nCol );\n+  if( aCol[i].hName==h\n+   && sqlite3StrICmp(aCol[i].zCnName, zCol)==0\n+  ){\n+    return i;\n+  }\n+\n+  \/* No lucky match from the hash table.  Do a full search. *\/\n+  i = 0;\n+  while( 1 \/*exit-by-break*\/ ){\n+    if( aCol[i].hName==h\n+     && sqlite3StrICmp(aCol[i].zCnName, zCol)==0\n+    ){\n+      return i;\n+    }\n+    i++;\n+    if( i>=nCol ) break;\n@@ -144425,1 +145438,1 @@\n-        if( (pSrc->a[0].fg.jointype & JT_LTORJ)!=0 ){\n+        if( (pSrc->a[0].fg.jointype & JT_LTORJ)!=0 && pParse->nErr==0 ){\n@@ -144441,0 +145454,2 @@\n+          assert( pE1!=0 );\n+          ExprSetProperty(pE1, EP_CanBeNull);\n@@ -144457,0 +145472,3 @@\n+            if( pE1 ){\n+              pE1->affExpr = SQLITE_AFF_DEFER;\n+            }\n@@ -144458,0 +145476,3 @@\n+        }else if( (pSrc->a[i+1].fg.jointype & JT_LEFT)!=0 && pParse->nErr==0 ){\n+          assert( pE1!=0 );\n+          ExprSetProperty(pE1, EP_CanBeNull);\n@@ -145366,2 +146387,2 @@\n-  int nExtra = (N+X)*(sizeof(CollSeq*)+1) - sizeof(CollSeq*);\n-  KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);\n+  int nExtra = (N+X)*(sizeof(CollSeq*)+1);\n+  KeyInfo *p = sqlite3DbMallocRawNN(db, SZ_KEYINFO(0) + nExtra);\n@@ -145375,1 +146396,1 @@\n-    memset(&p[1], 0, nExtra);\n+    memset(p->aColl, 0, nExtra);\n@@ -147076,0 +148097,1 @@\n+  pDest->iSDParm2 = dest.iSDParm2;\n@@ -148064,3 +149086,3 @@\n-**        (3a) the subquery may not be a join and\n-**        (3b) the FROM clause of the subquery may not contain a virtual\n-**             table and\n+**        (3a) the subquery may not be a join\n+**        (**) Was (3b): \"the FROM clause of the subquery may not contain\n+**             a virtual table\"\n@@ -148282,1 +149304,1 @@\n-     || IsVirtual(pSubSrc->a[0].pSTab)         \/* (3b) *\/\n+     \/**** || IsVirtual(pSubSrc->a[0].pSTab)      (3b)-omitted *\/\n@@ -148686,1 +149708,2 @@\n-  if( sqlite3ExprAffinity(pColumn)==SQLITE_AFF_BLOB ){\n+  assert( SQLITE_AFF_NONE<SQLITE_AFF_BLOB );\n+  if( sqlite3ExprAffinity(pColumn)<=SQLITE_AFF_BLOB ){\n@@ -148761,1 +149784,2 @@\n-    if( bIgnoreAffBlob && sqlite3ExprAffinity(pColumn)==SQLITE_AFF_BLOB ){\n+    assert( SQLITE_AFF_NONE<SQLITE_AFF_BLOB );\n+    if( bIgnoreAffBlob && sqlite3ExprAffinity(pColumn)<=SQLITE_AFF_BLOB ){\n@@ -149414,1 +150438,1 @@\n-** http:\/\/www.sqlite.org\/src\/info\/6709574d2a\n+** http:\/\/sqlite.org\/src\/info\/6709574d2a\n@@ -149475,1 +150499,1 @@\n-  p->selFlags &= ~SF_Compound;\n+  p->selFlags &= ~(u32)SF_Compound;\n@@ -149891,1 +150915,1 @@\n-      p->pWith = (With*)sqlite3DbMallocZero(db, sizeof(With));\n+      p->pWith = (With*)sqlite3DbMallocZero(db, SZ_WITH(1) );\n@@ -151030,0 +152054,1 @@\n+**   *  None of the subqueries are DISTINCT (forumpost\/a860f5fb2e 2025-03-10)\n@@ -151062,1 +152087,5 @@\n-    if( pSub->selFlags & SF_Aggregate ) return 0;     \/* Not an aggregate *\/\n+    if( pSub->selFlags & (SF_Aggregate|SF_Distinct) ){\n+       testcase( pSub->selFlags & SF_Aggregate );\n+       testcase( pSub->selFlags & SF_Distinct );\n+       return 0;     \/* Not an aggregate nor DISTINCT *\/\n+    }\n@@ -151074,1 +152103,1 @@\n-  p->pSrc = sqlite3DbMallocZero(pParse->db, sizeof(*p->pSrc));\n+  p->pSrc = sqlite3DbMallocZero(pParse->db, SZ_SRCLIST_1);\n@@ -151081,1 +152110,1 @@\n-    pSub->selFlags &= ~SF_Compound;\n+    pSub->selFlags &= ~(u32)SF_Compound;\n@@ -151096,1 +152125,1 @@\n-  p->selFlags &= ~SF_Aggregate;\n+  p->selFlags &= ~(u32)SF_Aggregate;\n@@ -151303,1 +152332,1 @@\n-    p->selFlags &= ~SF_Distinct;\n+    p->selFlags &= ~(u32)SF_Distinct;\n@@ -151342,1 +152371,1 @@\n-    p->selFlags &= ~SF_UFSrcCheck;\n+    p->selFlags &= ~(u32)SF_UFSrcCheck;\n@@ -151831,1 +152860,1 @@\n-    p->selFlags &= ~SF_Distinct;\n+    p->selFlags &= ~(u32)SF_Distinct;\n@@ -151940,0 +152969,6 @@\n+      if( pDest->eDest<=SRT_DistQueue && pDest->eDest>=SRT_DistFifo ){\n+        \/* TUNING: For a UNION CTE, because UNION is implies DISTINCT,\n+        ** reduce the estimated output row count by 8 (LogEst 30).\n+        ** Search for tag-20250414a to see other cases *\/\n+        p->nSelectRow -= 30;\n+      }\n@@ -152170,0 +153205,1 @@\n+      sqlite3ExprNullRegisterRange(pParse, iAMem, pGroupBy->nExpr);\n@@ -152313,0 +153349,4 @@\n+          while( ALWAYS(pBase!=0) && pBase->op==TK_IF_NULL_ROW ){\n+            pX = pBase->pLeft;\n+            pBase = sqlite3ExprSkipCollateAndLikely(pX);\n+          }\n@@ -152896,1 +153936,2 @@\n-      assert( &(pParse->u1.pReturning->retTrig) == pTrig );\n+      assert( !pParse->isCreate );\n+      assert( &(pParse->u1.d.pReturning->retTrig) == pTrig );\n@@ -153864,1 +154905,2 @@\n-  SrcList sFrom;\n+  SrcList *pFrom;\n+  u8 fromSpace[SZ_SRCLIST_1];\n@@ -153873,1 +154915,2 @@\n-  pReturning = pParse->u1.pReturning;\n+  assert( !pParse->isCreate );\n+  pReturning = pParse->u1.d.pReturning;\n@@ -153879,1 +154922,2 @@\n-  memset(&sFrom, 0, sizeof(sFrom));\n+  pFrom = (SrcList*)fromSpace;\n+  memset(pFrom, 0, SZ_SRCLIST_1);\n@@ -153881,5 +154925,5 @@\n-  sSelect.pSrc = &sFrom;\n-  sFrom.nSrc = 1;\n-  sFrom.a[0].pSTab = pTab;\n-  sFrom.a[0].zName = pTab->zName; \/* tag-20240424-1 *\/\n-  sFrom.a[0].iCursor = -1;\n+  sSelect.pSrc = pFrom;\n+  pFrom->nSrc = 1;\n+  pFrom->a[0].pSTab = pTab;\n+  pFrom->a[0].zName = pTab->zName; \/* tag-20240424-1 *\/\n+  pFrom->a[0].iCursor = -1;\n@@ -154103,0 +155147,2 @@\n+  sSubParse.oldmask = 0;\n+  sSubParse.newmask = 0;\n@@ -154857,1 +155903,0 @@\n-    u8 hCol = sqlite3StrIHash(pChanges->a[i].zEName);\n@@ -154863,11 +155908,9 @@\n-    for(j=0; j<pTab->nCol; j++){\n-      if( pTab->aCol[j].hName==hCol\n-       && sqlite3StrICmp(pTab->aCol[j].zCnName, pChanges->a[i].zEName)==0\n-      ){\n-        if( j==pTab->iPKey ){\n-          chngRowid = 1;\n-          pRowidExpr = pChanges->a[i].pExpr;\n-          iRowidExpr = i;\n-        }else if( pPk && (pTab->aCol[j].colFlags & COLFLAG_PRIMKEY)!=0 ){\n-          chngPk = 1;\n-        }\n+    j = sqlite3ColumnIndex(pTab, pChanges->a[i].zEName);\n+    if( j>=0 ){\n+      if( j==pTab->iPKey ){\n+        chngRowid = 1;\n+        pRowidExpr = pChanges->a[i].pExpr;\n+        iRowidExpr = i;\n+      }else if( pPk && (pTab->aCol[j].colFlags & COLFLAG_PRIMKEY)!=0 ){\n+        chngPk = 1;\n+      }\n@@ -154875,11 +155918,7 @@\n-        else if( pTab->aCol[j].colFlags & COLFLAG_GENERATED ){\n-          testcase( pTab->aCol[j].colFlags & COLFLAG_VIRTUAL );\n-          testcase( pTab->aCol[j].colFlags & COLFLAG_STORED );\n-          sqlite3ErrorMsg(pParse,\n-             \"cannot UPDATE generated column \\\"%s\\\"\",\n-             pTab->aCol[j].zCnName);\n-          goto update_cleanup;\n-        }\n-#endif\n-        aXRef[j] = i;\n-        break;\n+      else if( pTab->aCol[j].colFlags & COLFLAG_GENERATED ){\n+        testcase( pTab->aCol[j].colFlags & COLFLAG_VIRTUAL );\n+        testcase( pTab->aCol[j].colFlags & COLFLAG_STORED );\n+        sqlite3ErrorMsg(pParse,\n+           \"cannot UPDATE generated column \\\"%s\\\"\",\n+           pTab->aCol[j].zCnName);\n+        goto update_cleanup;\n@@ -154887,2 +155926,3 @@\n-    }\n-    if( j>=pTab->nCol ){\n+#endif\n+      aXRef[j] = i;\n+    }else{\n@@ -156211,1 +157251,1 @@\n-    ** occurred on 2016-08-19 (https:\/\/www.sqlite.org\/src\/info\/083f9e6270).\n+    ** occurred on 2016-08-19 (https:\/\/sqlite.org\/src\/info\/083f9e6270).\n@@ -156290,1 +157330,1 @@\n-  db->flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks;\n+  db->flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks | SQLITE_Comments;\n@@ -156995,1 +158035,1 @@\n-    ** The VM register number pParse->regRowid holds the rowid of an\n+    ** The VM register number pParse->u1.cr.regRowid holds the rowid of an\n@@ -157000,0 +158040,1 @@\n+    assert( pParse->isCreate );\n@@ -157008,1 +158049,1 @@\n-      pParse->regRowid\n+      pParse->u1.cr.regRowid\n@@ -158418,1 +159459,1 @@\n-  WhereLevel a[1];          \/* Information about each nest loop in WHERE *\/\n+  WhereLevel a[FLEXARRAY];  \/* Information about each nest loop in WHERE *\/\n@@ -158421,0 +159462,5 @@\n+\/*\n+** The size (in bytes) of a WhereInfo object that holds N WhereLevels.\n+*\/\n+#define SZ_WHEREINFO(N) ROUND8(offsetof(WhereInfo,a)+(N)*sizeof(WhereLevel))\n+\n@@ -159100,1 +160146,1 @@\n-** LHS.  But not all terms in the vector are indexable and the terms might\n+** RHS.  But not all terms in the vector are indexable and the terms might\n@@ -159156,1 +160202,3 @@\n-          if( pOrigRhs->a[iField].pExpr==0 ) continue; \/* Duplicate PK column *\/\n+          if( NEVER(pOrigRhs->a[iField].pExpr==0) ){\n+            continue; \/* Duplicate PK column *\/\n+          }\n@@ -159253,1 +160301,1 @@\n-  for(i=iEq;i<pLoop->nLTerm; i++){\n+  for(i=iEq; i<pLoop->nLTerm; i++){\n@@ -159262,14 +160310,5 @@\n-    Expr *pExpr = pTerm->pExpr;\n-    if( pExpr->iTable==0 || !ExprHasProperty(pExpr, EP_Subrtn) ){\n-      sqlite3 *db = pParse->db;\n-      pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);\n-      if( !db->mallocFailed ){\n-        aiMap = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int)*nEq);\n-        eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, aiMap,&iTab);\n-        pExpr->iTable = iTab;\n-      }\n-      sqlite3ExprDelete(db, pX);\n-    }else{\n-      int n = sqlite3ExprVectorSize(pX->pLeft);\n-      aiMap = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int)*MAX(nEq,n));\n-      eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, aiMap, &iTab);\n+    sqlite3 *db = pParse->db;\n+    Expr *pXMod = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);\n+    if( !db->mallocFailed ){\n+      aiMap = (int*)sqlite3DbMallocZero(db, sizeof(int)*nEq);\n+      eType = sqlite3FindInIndex(pParse, pXMod, IN_INDEX_LOOP, 0, aiMap, &iTab);\n@@ -159277,1 +160316,1 @@\n-    pX = pExpr;\n+    sqlite3ExprDelete(db, pXMod);\n@@ -159307,1 +160346,1 @@\n-    for(i=iEq;i<pLoop->nLTerm; i++){\n+    for(i=iEq; i<pLoop->nLTerm; i++){\n@@ -160166,0 +161205,3 @@\n+    \/* The instruction immediately prior to OP_VFilter must be an OP_Integer\n+    ** that sets the \"argc\" value for xVFilter.  This is necessary for\n+    ** resolveP2() to work correctly.  See tag-20250207a. *\/\n@@ -160756,1 +161798,2 @@\n-      ** the partial index.\n+      ** the partial index.  This optimization does not work on an outer join,\n+      ** as shown by:\n@@ -160758,2 +161801,2 @@\n-      ** 2019-11-02 ticket 623eff57e76d45f6: This optimization does not work\n-      ** for a LEFT JOIN.\n+      ** 2019-11-02 ticket 623eff57e76d45f6      (LEFT JOIN)\n+      ** 2025-05-29 forum post 7dee41d32506c4ae  (RIGHT JOIN)\n@@ -160761,1 +161804,1 @@\n-      if( pIdx->pPartIdxWhere ){\n+      if( pIdx->pPartIdxWhere && pLevel->pRJ==0 ){\n@@ -160868,2 +161911,1 @@\n-      pOrTab = sqlite3DbMallocRawNN(db,\n-                            sizeof(*pOrTab)+ nNotReady*sizeof(pOrTab->a[0]));\n+      pOrTab = sqlite3DbMallocRawNN(db, SZ_SRCLIST(nNotReady+1));\n@@ -160920,1 +161962,1 @@\n-    ** See ticket http:\/\/www.sqlite.org\/src\/info\/f2369304e4\n+    ** See ticket http:\/\/sqlite.org\/src\/info\/f2369304e4\n@@ -161412,1 +162454,2 @@\n-  SrcList sFrom;\n+  SrcList *pFrom;\n+  u8 fromSpace[SZ_SRCLIST_1];\n@@ -161456,4 +162499,5 @@\n-  sFrom.nSrc = 1;\n-  sFrom.nAlloc = 1;\n-  memcpy(&sFrom.a[0], pTabItem, sizeof(SrcItem));\n-  sFrom.a[0].fg.jointype = 0;\n+  pFrom = (SrcList*)fromSpace;\n+  pFrom->nSrc = 1;\n+  pFrom->nAlloc = 1;\n+  memcpy(&pFrom->a[0], pTabItem, sizeof(SrcItem));\n+  pFrom->a[0].fg.jointype = 0;\n@@ -161462,1 +162506,1 @@\n-  pSubWInfo = sqlite3WhereBegin(pParse, &sFrom, pSubWhere, 0, 0, 0,\n+  pSubWInfo = sqlite3WhereBegin(pParse, pFrom, pSubWhere, 0, 0, 0,\n@@ -162433,3 +163477,4 @@\n-**   4.  The affinities of A and B must be compatible\n-**   5a. Both operands use the same collating sequence OR\n-**   5b. The overall collating sequence is BINARY\n+**   4.  The operator is not IS or else the query does not contain RIGHT JOIN\n+**   5.  The affinities of A and B must be compatible\n+**   6a. Both operands use the same collating sequence OR\n+**   6b. The overall collating sequence is BINARY\n@@ -162441,1 +163486,1 @@\n-static int termIsEquivalence(Parse *pParse, Expr *pExpr){\n+static int termIsEquivalence(Parse *pParse, Expr *pExpr, SrcList *pSrc){\n@@ -162444,3 +163489,10 @@\n-  if( !OptimizationEnabled(pParse->db, SQLITE_Transitive) ) return 0;\n-  if( pExpr->op!=TK_EQ && pExpr->op!=TK_IS ) return 0;\n-  if( ExprHasProperty(pExpr, EP_OuterON) ) return 0;\n+  if( !OptimizationEnabled(pParse->db, SQLITE_Transitive) ) return 0;  \/* (1) *\/\n+  if( pExpr->op!=TK_EQ && pExpr->op!=TK_IS ) return 0;                 \/* (2) *\/\n+  if( ExprHasProperty(pExpr, EP_OuterON) ) return 0;                   \/* (3) *\/\n+  assert( pSrc!=0 );\n+  if( pExpr->op==TK_IS\n+   && pSrc->nSrc\n+   && (pSrc->a[0].fg.jointype & JT_LTORJ)!=0\n+  ){\n+    return 0;                                                          \/* (4) *\/\n+  }\n@@ -162452,1 +163504,1 @@\n-    return 0;\n+    return 0;                                                          \/* (5) *\/\n@@ -162455,2 +163507,6 @@\n-  if( sqlite3IsBinary(pColl) ) return 1;\n-  return sqlite3ExprCollSeqMatch(pParse, pExpr->pLeft, pExpr->pRight);\n+  if( !sqlite3IsBinary(pColl)\n+   && !sqlite3ExprCollSeqMatch(pParse, pExpr->pLeft, pExpr->pRight)\n+  ){\n+    return 0;                                                          \/* (6) *\/\n+  }\n+  return 1;\n@@ -162721,2 +163777,2 @@\n-\n-        if( termIsEquivalence(pParse, pDup) ){\n+        assert( pWInfo->pTabList!=0 );\n+        if( termIsEquivalence(pParse, pDup, pWInfo->pTabList) ){\n@@ -163450,3 +164506,3 @@\n-  sqlite3_value *aRhs[1];  \/* RHS values for constraints. MUST BE LAST\n-                           ** because extra space is allocated to hold up\n-                           ** to nTerm such values *\/\n+  sqlite3_value *aRhs[FLEXARRAY];  \/* RHS values for constraints. MUST BE LAST\n+                                   ** Extra space is allocated to hold up\n+                                   ** to nTerm such values *\/\n@@ -163455,0 +164511,5 @@\n+\/* Size (in bytes) of a HiddenIndeInfo object sufficient to hold as\n+** many as N constraints *\/\n+#define SZ_HIDDENINDEXINFO(N) \\\n+                  (offsetof(HiddenIndexInfo,aRhs) + (N)*sizeof(sqlite3_value*))\n+\n@@ -164519,0 +165580,2 @@\n+  assert( nKeyCol <= pTable->nCol + MAX(0, pTable->nCol - BMS + 1) );\n+  \/* ^-- This guarantees that the number of index columns will fit in the u16 *\/\n@@ -164930,2 +165993,2 @@\n-                           + sizeof(*pIdxOrderBy)*nOrderBy + sizeof(*pHidden)\n-                           + sizeof(sqlite3_value*)*nTerm );\n+                           + sizeof(*pIdxOrderBy)*nOrderBy\n+                           + SZ_HIDDENINDEXINFO(nTerm) );\n@@ -166567,5 +167630,2 @@\n-  if( pProbe->bUnordered || pProbe->bLowQual ){\n-    if( pProbe->bUnordered ) opMask &= ~(WO_GT|WO_GE|WO_LT|WO_LE);\n-    if( pProbe->bLowQual && pSrc->fg.isIndexedBy==0 ){\n-      opMask &= ~(WO_EQ|WO_IN|WO_IS);\n-    }\n+  if( pProbe->bUnordered ){\n+    opMask &= ~(WO_GT|WO_GE|WO_LT|WO_LE);\n@@ -166644,0 +167704,1 @@\n+        int bRedundant = 0;\n@@ -166652,1 +167713,14 @@\n-          if( pNew->aLTerm[i] && pNew->aLTerm[i]->pExpr==pExpr ) nIn = 0;\n+          if( pNew->aLTerm[i] && pNew->aLTerm[i]->pExpr==pExpr ){\n+            nIn = 0;\n+            if( pNew->aLTerm[i]->u.x.iField == pTerm->u.x.iField ){\n+              \/* Detect when two or more columns of an index match the same\n+              ** column of a vector IN operater, and avoid adding the column\n+              ** to the WhereLoop more than once.  See tag-20250707-01\n+              ** in test\/rowvalue.test *\/\n+              bRedundant = 1;\n+            }\n+          }\n+        }\n+        if( bRedundant ){\n+          pNew->nLTerm--;\n+          continue;\n@@ -166884,1 +167958,1 @@\n-           pProbe->idxType!=SQLITE_IDXTYPE_PRIMARYKEY)\n+          pProbe->idxType!=SQLITE_IDXTYPE_PRIMARYKEY)\n@@ -167013,0 +168087,1 @@\n+     && !sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, -1)\n@@ -167426,0 +168501,1 @@\n+    pNew->u.btree.nDistinctCol = 0;\n@@ -167508,1 +168584,1 @@\n-             (\"-> %s a covering index according to bitmasks\\n\",\n+             (\"-> %s is a covering index according to bitmasks\\n\",\n@@ -168494,2 +169570,0 @@\n-    }else if( wctrlFlags & WHERE_DISTINCTBY ){\n-      pLoop->u.btree.nDistinctCol = 0;\n@@ -170125,4 +171199,1 @@\n-  nByteWInfo = ROUND8P(sizeof(WhereInfo));\n-  if( nTabList>1 ){\n-    nByteWInfo = ROUND8P(nByteWInfo + (nTabList-1)*sizeof(WhereLevel));\n-  }\n+  nByteWInfo = SZ_WHEREINFO(nTabList);\n@@ -170345,1 +171416,2 @@\n-    ** the output size by a factor of 8 (LogEst -30).\n+    ** the output size by a factor of 8 (LogEst -30).  Search for\n+    ** tag-20250414a to see other cases.\n@@ -172080,1 +173152,1 @@\n-    p->selFlags &= ~SF_Aggregate;\n+    p->selFlags &= ~(u32)SF_Aggregate;\n@@ -174220,0 +175292,5 @@\n+\/*\n+** Verify that the pParse->isCreate field is set\n+*\/\n+#define ASSERT_IS_CREATE   assert(pParse->isCreate)\n+\n@@ -174283,0 +175360,4 @@\n+#ifdef SQLITE_DEBUG\n+  pParse->isCreate = 1;\n+#endif\n+  memset(&pParse->u1.cr, 0, sizeof(pParse->u1.cr));\n@@ -177919,1 +179000,3 @@\n-{disableLookaside(pParse);}\n+{\n+  disableLookaside(pParse);\n+}\n@@ -178011,1 +179094,1 @@\n-{pParse->constraintName = yymsp[0].minor.yy0;}\n+{ASSERT_IS_CREATE; pParse->u1.cr.constraintName = yymsp[0].minor.yy0;}\n@@ -178121,1 +179204,1 @@\n-{pParse->constraintName.n = 0;}\n+{ASSERT_IS_CREATE; pParse->u1.cr.constraintName.n = 0;}\n@@ -178208,2 +179291,2 @@\n-    if( ALWAYS(pLhs) ) pLhs->selFlags &= ~SF_MultiValue;\n-    pRhs->selFlags &= ~SF_MultiValue;\n+    if( ALWAYS(pLhs) ) pLhs->selFlags &= ~(u32)SF_MultiValue;\n+    pRhs->selFlags &= ~(u32)SF_MultiValue;\n@@ -178849,2 +179932,6 @@\n-      ** simplify to constants 0 (false) and 1 (true), respectively,\n-      ** regardless of the value of expr1.\n+      ** simplify to constants 0 (false) and 1 (true), respectively.\n+      **\n+      ** Except, do not apply this optimization if expr1 contains a function\n+      ** because that function might be an aggregate (we don't know yet whether\n+      ** it is or not) and if it is an aggregate, that could change the meaning\n+      ** of the whole query.\n@@ -178852,3 +179939,8 @@\n-      sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy590);\n-      yymsp[-4].minor.yy590 = sqlite3Expr(pParse->db, TK_STRING, yymsp[-3].minor.yy502 ? \"true\" : \"false\");\n-      if( yymsp[-4].minor.yy590 ) sqlite3ExprIdToTrueFalse(yymsp[-4].minor.yy590);\n+      Expr *pB = sqlite3Expr(pParse->db, TK_STRING, yymsp[-3].minor.yy502 ? \"true\" : \"false\");\n+      if( pB ) sqlite3ExprIdToTrueFalse(pB);\n+      if( !ExprHasProperty(yymsp[-4].minor.yy590, EP_HasFunc) ){\n+        sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy590);\n+        yymsp[-4].minor.yy590 = pB;\n+      }else{\n+        yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, yymsp[-3].minor.yy502 ? TK_OR : TK_AND, pB, yymsp[-4].minor.yy590);\n+      }\n@@ -179014,0 +180106,4 @@\n+#ifdef SQLITE_DEBUG\n+  assert( pParse->isCreate ); \/* Set by createkw reduce action *\/\n+  pParse->isCreate = 0;       \/* But, should not be set for CREATE TRIGGER *\/\n+#endif\n@@ -180456,1 +181552,1 @@\n-  }while( t==TK_SPACE );\n+  }while( t==TK_SPACE || t==TK_COMMENT );\n@@ -180949,1 +182045,5 @@\n-      }else if( tokenType==TK_COMMENT && (db->flags & SQLITE_Comments)!=0 ){\n+      }else if( tokenType==TK_COMMENT\n+             && (db->init.busy || (db->flags & SQLITE_Comments)!=0)\n+      ){\n+        \/* Ignore SQL comments if either (1) we are reparsing the schema or\n+        ** (2) SQLITE_DBCONFIG_ENABLE_COMMENTS is turned on (the default). *\/\n@@ -181844,0 +182944,8 @@\n+#ifdef SQLITE_EXTRA_INIT_MUTEXED\n+      {\n+        int SQLITE_EXTRA_INIT_MUTEXED(const char*);\n+        rc = SQLITE_EXTRA_INIT_MUTEXED(0);\n+      }\n+#endif\n+    }\n+    if( rc==SQLITE_OK ){\n@@ -182300,4 +183408,4 @@\n-** The cnt parameter is the number of slots.  If pStart is NULL the\n-** space for the lookaside memory is obtained from sqlite3_malloc().\n-** If pStart is not NULL then it is sz*cnt bytes of memory to use for\n-** the lookaside memory.\n+** The cnt parameter is the number of slots.  If pBuf is NULL the\n+** space for the lookaside memory is obtained from sqlite3_malloc()\n+** or similar.  If pBuf is not NULL then it is sz*cnt bytes of memory\n+** to use for the lookaside memory.\n@@ -182305,1 +183413,6 @@\n-static int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt){\n+static int setupLookaside(\n+  sqlite3 *db,    \/* Database connection being configured *\/\n+  void *pBuf,     \/* Memory to use for lookaside.  May be NULL *\/\n+  int sz,         \/* Desired size of each lookaside memory slot *\/\n+  int cnt         \/* Number of slots to allocate *\/\n+){\n@@ -182307,4 +183420,4 @@\n-  void *pStart;\n-  sqlite3_int64 szAlloc;\n-  int nBig;   \/* Number of full-size slots *\/\n-  int nSm;    \/* Number smaller LOOKASIDE_SMALL-byte slots *\/\n+  void *pStart;          \/* Start of the lookaside buffer *\/\n+  sqlite3_int64 szAlloc; \/* Total space set aside for lookaside memory *\/\n+  int nBig;              \/* Number of full-size slots *\/\n+  int nSm;               \/* Number smaller LOOKASIDE_SMALL-byte slots *\/\n@@ -182323,1 +183436,1 @@\n-  ** than a pointer to be useful.\n+  ** than a pointer and small enough to fit in a u16.\n@@ -182325,1 +183438,1 @@\n-  sz = ROUNDDOWN8(sz);  \/* IMP: R-33038-09382 *\/\n+  sz = ROUNDDOWN8(sz);\n@@ -182328,1 +183441,4 @@\n-  if( cnt<0 ) cnt = 0;\n+  \/* Count must be at least 1 to be useful, but not so large as to use\n+  ** more than 0x7fff0000 total bytes for lookaside. *\/\n+  if( cnt<1 ) cnt = 0;\n+  if( sz>0 && cnt>(0x7fff0000\/sz) ) cnt = 0x7fff0000\/sz;\n@@ -182330,1 +183446,1 @@\n-  if( sz==0 || cnt==0 ){\n+  if( szAlloc==0 ){\n@@ -182335,1 +183451,1 @@\n-    pStart = sqlite3Malloc( szAlloc );  \/* IMP: R-61949-35727 *\/\n+    pStart = sqlite3Malloc( szAlloc );\n@@ -183312,0 +184428,3 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  db->setlkTimeout = 0;\n+#endif\n@@ -183361,0 +184480,3 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    db->setlkTimeout = ms;\n+#endif\n@@ -183367,0 +184489,34 @@\n+\/*\n+** Set the setlk timeout value.\n+*\/\n+SQLITE_API int sqlite3_setlk_timeout(sqlite3 *db, int ms, int flags){\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  int iDb;\n+  int bBOC = ((flags & SQLITE_SETLK_BLOCK_ON_CONNECT) ? 1 : 0);\n+#endif\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n+#endif\n+  if( ms<-1 ) return SQLITE_RANGE;\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  sqlite3_mutex_enter(db->mutex);\n+  db->setlkTimeout = ms;\n+  db->setlkFlags = flags;\n+  sqlite3BtreeEnterAll(db);\n+  for(iDb=0; iDb<db->nDb; iDb++){\n+    Btree *pBt = db->aDb[iDb].pBt;\n+    if( pBt ){\n+      sqlite3_file *fd = sqlite3PagerFile(sqlite3BtreePager(pBt));\n+      sqlite3OsFileControlHint(fd, SQLITE_FCNTL_BLOCK_ON_CONNECT, (void*)&bBOC);\n+    }\n+  }\n+  sqlite3BtreeLeaveAll(db);\n+  sqlite3_mutex_leave(db->mutex);\n+#endif\n+#if !defined(SQLITE_ENABLE_API_ARMOR) && !defined(SQLITE_ENABLE_SETLK_TIMEOUT)\n+  UNUSED_PARAMETER(db);\n+  UNUSED_PARAMETER(flags);\n+#endif\n+  return SQLITE_OK;\n+}\n+\n@@ -185332,1 +186488,1 @@\n-    p = sqlite3_malloc64( sizeof(DbClientData)+n+1 );\n+    p = sqlite3_malloc64( SZ_DBCLIENTDATA(n+1) );\n@@ -185486,1 +186642,2 @@\n-    for(iCol=0; iCol<pTab->nCol; iCol++){\n+    iCol = sqlite3ColumnIndex(pTab, zColumnName);\n+    if( iCol>=0 ){\n@@ -185488,5 +186645,1 @@\n-      if( 0==sqlite3StrICmp(pCol->zCnName, zColumnName) ){\n-        break;\n-      }\n-    }\n-    if( iCol==pTab->nCol ){\n+    }else{\n@@ -185701,2 +186854,2 @@\n-    ** false then clearn that setting.  If the SQLITE_FkNoAction setting is\n-    ** abled, all foreign key ON DELETE and ON UPDATE actions behave as if\n+    ** false then clear that setting.  If the SQLITE_FkNoAction setting is\n+    ** enabled, all foreign key ON DELETE and ON UPDATE actions behave as if\n@@ -187049,1 +188202,1 @@\n-** in the same logical place as the position element, and act as sentinals\n+** in the same logical place as the position element, and act as sentinels\n@@ -187268,0 +188421,7 @@\n+\/* #include <assert.h> *\/\n+\/* #include <stdlib.h> *\/\n+\/* #include <stddef.h> *\/\n+\/* #include <stdio.h> *\/\n+\/* #include <string.h> *\/\n+\/* #include <stdarg.h> *\/\n+\n@@ -187737,0 +188897,13 @@\n+\/*\n+** Macros needed to provide flexible arrays in a portable way\n+*\/\n+#ifndef offsetof\n+# define offsetof(STRUCTURE,FIELD) ((size_t)((char*)&((STRUCTURE*)0)->FIELD))\n+#endif\n+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n+# define FLEXARRAY\n+#else\n+# define FLEXARRAY 1\n+#endif\n+\n+\n@@ -187841,1 +189014,1 @@\n-  \/* True to disable the incremental doclist optimization. This is controled\n+  \/* True to disable the incremental doclist optimization. This is controlled\n@@ -187893,1 +189066,1 @@\n-** Actualy, Fts3Cursor.eSearch can be greater than or equal to\n+** Actually, Fts3Cursor.eSearch can be greater than or equal to\n@@ -187966,1 +189139,1 @@\n-  Fts3PhraseToken aToken[1]; \/* One entry for each token in the phrase *\/\n+  Fts3PhraseToken aToken[FLEXARRAY]; \/* One for each token in the phrase *\/\n@@ -187969,0 +189142,4 @@\n+\/* Size (in bytes) of an Fts3Phrase object large enough to hold N tokens *\/\n+#define SZ_FTS3PHRASE(N) \\\n+  (offsetof(Fts3Phrase,aToken)+(N)*sizeof(Fts3PhraseToken))\n+\n@@ -188202,6 +189379,0 @@\n-\/* #include <assert.h> *\/\n-\/* #include <stdlib.h> *\/\n-\/* #include <stddef.h> *\/\n-\/* #include <stdio.h> *\/\n-\/* #include <string.h> *\/\n-\/* #include <stdarg.h> *\/\n@@ -190546,1 +191717,1 @@\n-  ** A symetric argument may be made if the doclists are in descending\n+  ** A symmetric argument may be made if the doclists are in descending\n@@ -192345,1 +193516,1 @@\n-      aOut = (char *)sqlite3Fts3MallocZero(nPoslist+FTS3_BUFFER_PADDING);\n+      aOut = (char *)sqlite3Fts3MallocZero(((i64)nPoslist)+FTS3_BUFFER_PADDING);\n@@ -192644,1 +193815,1 @@\n-** Advance it to the next matching documnent in the database and populate\n+** Advance it to the next matching document in the database and populate\n@@ -193651,1 +194822,1 @@\n-** Restart interation for expression pExpr so that the next call to\n+** Restart iteration for expression pExpr so that the next call to\n@@ -194843,0 +196014,17 @@\n+\/*\n+** Search buffer z[], size n, for a '\"' character. Or, if enable_parenthesis\n+** is defined, search for '(' and ')' as well. Return the index of the first\n+** such character in the buffer. If there is no such character, return -1.\n+*\/\n+static int findBarredChar(const char *z, int n){\n+  int ii;\n+  for(ii=0; ii<n; ii++){\n+    if( (z[ii]=='\"')\n+     || (sqlite3_fts3_enable_parentheses && (z[ii]=='(' || z[ii]==')'))\n+    ){\n+      return ii;\n+    }\n+  }\n+  return -1;\n+}\n+\n@@ -194867,7 +196055,0 @@\n-  int i = 0;\n-\n-  \/* Set variable i to the maximum number of bytes of input to tokenize. *\/\n-  for(i=0; i<n; i++){\n-    if( sqlite3_fts3_enable_parentheses && (z[i]=='(' || z[i]==')') ) break;\n-    if( z[i]=='\"' ) break;\n-  }\n@@ -194875,2 +196056,2 @@\n-  *pnConsumed = i;\n-  rc = sqlite3Fts3OpenTokenizer(pTokenizer, pParse->iLangid, z, i, &pCursor);\n+  *pnConsumed = n;\n+  rc = sqlite3Fts3OpenTokenizer(pTokenizer, pParse->iLangid, z, n, &pCursor);\n@@ -194884,1 +196065,12 @@\n-      nByte = sizeof(Fts3Expr) + sizeof(Fts3Phrase) + nToken;\n+      \/* Check that this tokenization did not gobble up any \" characters. Or,\n+      ** if enable_parenthesis is true, that it did not gobble up any\n+      ** open or close parenthesis characters either. If it did, call\n+      ** getNextToken() again, but pass only that part of the input buffer\n+      ** up to the first such character.  *\/\n+      int iBarred = findBarredChar(z, iEnd);\n+      if( iBarred>=0 ){\n+        pModule->xClose(pCursor);\n+        return getNextToken(pParse, iCol, z, iBarred, ppExpr, pnConsumed);\n+      }\n+\n+      nByte = sizeof(Fts3Expr) + SZ_FTS3PHRASE(1) + nToken;\n@@ -194894,1 +196086,1 @@\n-        pRet->pPhrase->aToken[0].z = (char *)&pRet->pPhrase[1];\n+        pRet->pPhrase->aToken[0].z = (char*)&pRet->pPhrase->aToken[1];\n@@ -194918,1 +196110,5 @@\n-    }else if( i && rc==SQLITE_DONE ){\n+    }else if( n && rc==SQLITE_DONE ){\n+      int iBarred = findBarredChar(z, n);\n+      if( iBarred>=0 ){\n+        *pnConsumed = iBarred;\n+      }\n@@ -194965,1 +196161,1 @@\n-  int nTemp = 0;\n+  i64 nTemp = 0;\n@@ -194967,1 +196163,1 @@\n-  const int nSpace = sizeof(Fts3Expr) + sizeof(Fts3Phrase);\n+  const int nSpace = sizeof(Fts3Expr) + SZ_FTS3PHRASE(1);\n@@ -195339,1 +196535,1 @@\n-          ** binary operator (AND, OR, NOT or NEAR) is encounted when\n+          ** binary operator (AND, OR, NOT or NEAR) is encountered when\n@@ -195921,1 +197117,0 @@\n-    sqlite3Fts3ExprFree(pExpr);\n@@ -196164,1 +197359,1 @@\n-\/* Resize the hash table so that it cantains \"new_size\" buckets.\n+\/* Resize the hash table so that it contains \"new_size\" buckets.\n@@ -196619,1 +197814,1 @@\n-** of the word that preceeds the zFrom ending, then change the\n+** of the word that precedes the zFrom ending, then change the\n@@ -198130,1 +199325,1 @@\n-    int nByte = sqlite3_value_bytes(apVal[0]);\n+    sqlite3_int64 nByte = sqlite3_value_bytes(apVal[0]);\n@@ -202202,1 +203397,1 @@\n-** is extended by this function if requrired.\n+** is extended by this function if required.\n@@ -203865,1 +205060,1 @@\n-** of subsiduary data structures accordingly.\n+** of subsidiary data structures accordingly.\n@@ -204191,1 +205386,1 @@\n-  u32 aMatchinfo[1];\n+  u32 aMI[FLEXARRAY];\n@@ -204194,0 +205389,4 @@\n+\/* Size (in bytes) of a MatchinfoBuffer sufficient for N elements *\/\n+#define SZ_MATCHINFOBUFFER(N) \\\n+            (offsetof(MatchinfoBuffer,aMI)+(((N)+1)\/2)*sizeof(u64))\n+\n@@ -204218,1 +205417,1 @@\n-                           + sizeof(MatchinfoBuffer);\n+                           + SZ_MATCHINFOBUFFER(1);\n@@ -204223,2 +205422,2 @@\n-    pRet->aMatchinfo[0] = (u8*)(&pRet->aMatchinfo[1]) - (u8*)pRet;\n-    pRet->aMatchinfo[1+nElem] = pRet->aMatchinfo[0]\n+    pRet->aMI[0] = (u8*)(&pRet->aMI[1]) - (u8*)pRet;\n+    pRet->aMI[1+nElem] = pRet->aMI[0]\n@@ -204238,2 +205437,2 @@\n-  assert( (u32*)p==&pBuf->aMatchinfo[1]\n-       || (u32*)p==&pBuf->aMatchinfo[pBuf->nElem+2]\n+  assert( (u32*)p==&pBuf->aMI[1]\n+       || (u32*)p==&pBuf->aMI[pBuf->nElem+2]\n@@ -204241,1 +205440,1 @@\n-  if( (u32*)p==&pBuf->aMatchinfo[1] ){\n+  if( (u32*)p==&pBuf->aMI[1] ){\n@@ -204258,1 +205457,1 @@\n-    aOut = &p->aMatchinfo[1];\n+    aOut = &p->aMI[1];\n@@ -204263,1 +205462,1 @@\n-    aOut = &p->aMatchinfo[p->nElem+2];\n+    aOut = &p->aMI[p->nElem+2];\n@@ -204269,1 +205468,1 @@\n-      if( p->bGlobal ) memcpy(aOut, &p->aMatchinfo[1], p->nElem*sizeof(u32));\n+      if( p->bGlobal ) memcpy(aOut, &p->aMI[1], p->nElem*sizeof(u32));\n@@ -204279,1 +205478,1 @@\n-  memcpy(&p->aMatchinfo[2+p->nElem], &p->aMatchinfo[1], p->nElem*sizeof(u32));\n+  memcpy(&p->aMI[2+p->nElem], &p->aMI[1], p->nElem*sizeof(u32));\n@@ -204694,1 +205893,1 @@\n-  ** to grow the buffer until so that it is big enough to accomadate the\n+  ** to grow the buffer until so that it is big enough to accommodate the\n@@ -205106,1 +206305,1 @@\n-      nVal = pInfo->nCol * pInfo->nPhrase;\n+      nVal = (size_t)pInfo->nCol * pInfo->nPhrase;\n@@ -205110,1 +206309,1 @@\n-      nVal = pInfo->nPhrase * ((pInfo->nCol + 31) \/ 32);\n+      nVal = (size_t)pInfo->nPhrase * ((pInfo->nCol + 31) \/ 32);\n@@ -205115,1 +206314,1 @@\n-      nVal = pInfo->nCol * pInfo->nPhrase * 3;\n+      nVal = (size_t)pInfo->nCol * pInfo->nPhrase * 3;\n@@ -206673,2 +207872,2 @@\n-** format SQLite JSONB is completely different and incompatible with\n-** PostgreSQL JSONB.\n+** format for SQLite-JSONB is completely different and incompatible with\n+** PostgreSQL-JSONB.\n@@ -206731,1 +207930,1 @@\n-** ways: (1) (X>>4)==10, (2) (X>>4)==12 following by on 0x0a byte,\n+** ways: (1) (X>>4)==10, (2) (X>>4)==12 following by one 0x0a byte,\n@@ -206741,1 +207940,1 @@\n-** (as SQLite is currently unable handle BLOBs larger than about 2GB)\n+** (as SQLite is currently unable to handle BLOBs larger than about 2GB)\n@@ -206801,17 +208000,41 @@\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 1, 1, 0, 0, 1, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  1, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+#ifdef SQLITE_ASCII\n+\/*0  1  2  3  4  5  6  7   8  9  a  b  c  d  e  f  *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 1, 1, 0, 0, 1, 0, 0,  \/* 0 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 1 *\/\n+  1, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 2 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 3 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 4 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 5 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 6 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 7 *\/\n+\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 8 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 9 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* a *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* b *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* c *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* d *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* e *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* f *\/\n+#endif\n+#ifdef SQLITE_EBCDIC\n+\/*0  1  2  3  4  5  6  7   8  9  a  b  c  d  e  f  *\/\n+  0, 0, 0, 0, 0, 1, 0, 0,  0, 0, 0, 0, 0, 1, 0, 0,  \/* 0 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 1 *\/\n+  0, 0, 0, 0, 0, 1, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 2 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 3 *\/\n+  1, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 4 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 5 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 6 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 7 *\/\n+\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 8 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 9 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* a *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* b *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* c *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* d *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* e *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* f *\/\n+#endif\n+\n@@ -206825,0 +208048,1 @@\n+#ifdef SQLITE_ASCII\n@@ -206826,0 +208050,5 @@\n+#endif\n+#ifdef SQLITE_EBCDIC\n+static const char jsonSpaces[] = \"\\005\\045\\015\\100\";\n+#endif\n+\n@@ -206834,17 +208063,40 @@\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n-  1, 1, 0, 1, 1, 1, 1, 0,  1, 1, 1, 1, 1, 1, 1, 1,\n-  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n-  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n-  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 1, 1, 1,\n-  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n-  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n-\n-  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n-  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n-  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n-  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n-  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n-  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n-  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n-  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1\n+#ifdef SQLITE_ASCII\n+\/*0  1  2  3  4  5  6  7   8  9  a  b  c  d  e  f  *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 0 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 1 *\/\n+  1, 1, 0, 1, 1, 1, 1, 0,  1, 1, 1, 1, 1, 1, 1, 1,  \/* 2 *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* 3 *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* 4 *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 1, 1, 1,  \/* 5 *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* 6 *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* 7 *\/\n+\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* 8 *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* 9 *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* a *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* b *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* c *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* d *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* e *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1   \/* f *\/\n+#endif\n+#ifdef SQLITE_EBCDIC\n+\/*0  1  2  3  4  5  6  7   8  9  a  b  c  d  e  f  *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 0 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 1 *\/\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,  \/* 2 *\/\n+  1, 1, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 1, 0,  \/* 3 *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* 4 *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* 5 *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* 6 *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 0, 1, 0,  \/* 7 *\/\n+\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* 8 *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* 9 *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* a *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* b *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* c *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* d *\/\n+  0, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,  \/* e *\/\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1   \/* f *\/\n+#endif\n@@ -206995,1 +208247,1 @@\n-static int jsonFuncArgMightBeBinary(sqlite3_value *pJson);\n+static int jsonArgIsJsonb(sqlite3_value *pJson, JsonParse *p);\n@@ -207069,1 +208321,1 @@\n-** be deleted at any moment.  If the caller whants the JsonParse to\n+** be deleted at any moment.  If the caller wants the JsonParse to\n@@ -207413,5 +208665,3 @@\n-      if( jsonFuncArgMightBeBinary(pValue) ){\n-        JsonParse px;\n-        memset(&px, 0, sizeof(px));\n-        px.aBlob = (u8*)sqlite3_value_blob(pValue);\n-        px.nBlob = sqlite3_value_bytes(pValue);\n+      JsonParse px;\n+      memset(&px, 0, sizeof(px));\n+      if( jsonArgIsJsonb(pValue, &px) ){\n@@ -207736,1 +208986,1 @@\n-  u32 t;\n+  u64 t;\n@@ -207746,0 +208996,1 @@\n+  assert( t<0x7fffffff );\n@@ -207747,1 +208998,1 @@\n-  pParse->nBlobAlloc = t;\n+  pParse->nBlobAlloc = (u32)t;\n@@ -207814,1 +209065,1 @@\n-\/* Append an node type byte together with the payload size and\n+\/* Append a node type byte together with the payload size and\n@@ -207883,1 +209134,1 @@\n-  }else{\n+  }else if( szType==14 ){\n@@ -207885,0 +209136,2 @@\n+  }else{\n+    nExtra = 8;\n@@ -208354,1 +209607,6 @@\n-        }else if( c=='\\'' || c=='0' || c=='v' || c=='\\n'\n+        }else if( c=='\\'' ||  c=='v' || c=='\\n'\n+#ifdef SQLITE_BUG_COMPATIBLE_20250510\n+           || (c=='0')                            \/* Legacy bug compatible *\/\n+#else\n+           || (c=='0' && !sqlite3Isdigit(z[j+1])) \/* Correct implementation *\/\n+#endif\n@@ -208704,4 +209962,1 @@\n-  if( NEVER(i>pParse->nBlob) ){\n-    *pSz = 0;\n-    return 0;\n-  }\n+  assert( i<=pParse->nBlob );\n@@ -208744,1 +209999,1 @@\n-    sz = (pParse->aBlob[i+5]<<24) + (pParse->aBlob[i+6]<<16) +\n+    sz = ((u32)pParse->aBlob[i+5]<<24) + (pParse->aBlob[i+6]<<16) +\n@@ -208751,2 +210006,2 @@\n-    sz = 0;\n-    n = 0;\n+    *pSz = 0;\n+    return 0;\n@@ -208849,3 +210104,6 @@\n-      jsonAppendChar(pOut, '\"');\n-      jsonAppendRaw(pOut, (const char*)&pParse->aBlob[i+n], sz);\n-      jsonAppendChar(pOut, '\"');\n+      if( pOut->nUsed+sz+2<=pOut->nAlloc || jsonStringGrow(pOut, sz+2)==0 ){\n+        pOut->zBuf[pOut->nUsed] = '\"';\n+        memcpy(pOut->zBuf+pOut->nUsed+1,(const char*)&pParse->aBlob[i+n],sz);\n+        pOut->zBuf[pOut->nUsed+sz+1] = '\"';\n+        pOut->nUsed += sz+2;\n+      }\n@@ -209090,27 +210348,0 @@\n-\n-\/* Return true if the input pJson\n-**\n-** For performance reasons, this routine does not do a detailed check of the\n-** input BLOB to ensure that it is well-formed.  Hence, false positives are\n-** possible.  False negatives should never occur, however.\n-*\/\n-static int jsonFuncArgMightBeBinary(sqlite3_value *pJson){\n-  u32 sz, n;\n-  const u8 *aBlob;\n-  int nBlob;\n-  JsonParse s;\n-  if( sqlite3_value_type(pJson)!=SQLITE_BLOB ) return 0;\n-  aBlob = sqlite3_value_blob(pJson);\n-  nBlob = sqlite3_value_bytes(pJson);\n-  if( nBlob<1 ) return 0;\n-  if( NEVER(aBlob==0) || (aBlob[0] & 0x0f)>JSONB_OBJECT ) return 0;\n-  memset(&s, 0, sizeof(s));\n-  s.aBlob = (u8*)aBlob;\n-  s.nBlob = nBlob;\n-  n = jsonbPayloadSize(&s, 0, &sz);\n-  if( n==0 ) return 0;\n-  if( sz+n!=(u32)nBlob ) return 0;\n-  if( (aBlob[0] & 0x0f)<=JSONB_FALSE && sz>0 ) return 0;\n-  return sz+n==(u32)nBlob;\n-}\n-\n@@ -209149,0 +210380,76 @@\n+\/*\n+** If the JSONB at aIns[0..nIns-1] can be expanded (by denormalizing the\n+** size field) by d bytes, then write the expansion into aOut[] and\n+** return true.  In this way, an overwrite happens without changing the\n+** size of the JSONB, which reduces memcpy() operations and also make it\n+** faster and easier to update the B-Tree entry that contains the JSONB\n+** in the database.\n+**\n+** If the expansion of aIns[] by d bytes cannot be (easily) accomplished\n+** then return false.\n+**\n+** The d parameter is guaranteed to be between 1 and 8.\n+**\n+** This routine is an optimization.  A correct answer is obtained if it\n+** always leaves the output unchanged and returns false.\n+*\/\n+static int jsonBlobOverwrite(\n+  u8 *aOut,                 \/* Overwrite here *\/\n+  const u8 *aIns,           \/* New content *\/\n+  u32 nIns,                 \/* Bytes of new content *\/\n+  u32 d                     \/* Need to expand new content by this much *\/\n+){\n+  u32 szPayload;       \/* Bytes of payload *\/\n+  u32 i;               \/* New header size, after expansion & a loop counter *\/\n+  u8 szHdr;            \/* Size of header before expansion *\/\n+\n+  \/* Lookup table for finding the upper 4 bits of the first byte of the\n+  ** expanded aIns[], based on the size of the expanded aIns[] header:\n+  **\n+  **                             2     3  4     5  6  7  8     9 *\/\n+  static const u8 aType[] = { 0xc0, 0xd0, 0, 0xe0, 0, 0, 0, 0xf0 };\n+\n+  if( (aIns[0]&0x0f)<=2 ) return 0;    \/* Cannot enlarge NULL, true, false *\/\n+  switch( aIns[0]>>4 ){\n+    default: {                         \/* aIns[] header size 1 *\/\n+      if( ((1<<d)&0x116)==0 ) return 0;  \/* d must be 1, 2, 4, or 8 *\/\n+      i = d + 1;                         \/* New hdr sz: 2, 3, 5, or 9 *\/\n+      szHdr = 1;\n+      break;\n+    }\n+    case 12: {                         \/* aIns[] header size is 2 *\/\n+      if( ((1<<d)&0x8a)==0) return 0;    \/* d must be 1, 3, or 7 *\/\n+      i = d + 2;                         \/* New hdr sz: 2, 5, or 9 *\/\n+      szHdr = 2;\n+      break;\n+    }\n+    case 13: {                         \/* aIns[] header size is 3 *\/\n+      if( d!=2 && d!=6 ) return 0;       \/* d must be 2 or 6 *\/\n+      i = d + 3;                         \/* New hdr sz: 5 or 9 *\/\n+      szHdr = 3;\n+      break;\n+    }\n+    case 14: {                         \/* aIns[] header size is 5 *\/\n+      if( d!=4 ) return 0;               \/* d must be 4 *\/\n+      i = 9;                             \/* New hdr sz: 9 *\/\n+      szHdr = 5;\n+      break;\n+    }\n+    case 15: {                         \/* aIns[] header size is 9 *\/\n+      return 0;                          \/* No solution *\/\n+    }\n+  }\n+  assert( i>=2 && i<=9 && aType[i-2]!=0 );\n+  aOut[0] = (aIns[0] & 0x0f) | aType[i-2];\n+  memcpy(&aOut[i], &aIns[szHdr], nIns-szHdr);\n+  szPayload = nIns - szHdr;\n+  while( 1\/*edit-by-break*\/ ){\n+    i--;\n+    aOut[i] = szPayload & 0xff;\n+    if( i==1 ) break;\n+    szPayload >>= 8;\n+  }\n+  assert( (szPayload>>8)==0 );\n+  return 1;\n+}\n+\n@@ -209170,0 +210477,5 @@\n+  if( d<0 && d>=(-8) && aIns!=0\n+   && jsonBlobOverwrite(&pParse->aBlob[iDel], aIns, nIns, (int)-d)\n+  ){\n+    return;\n+  }\n@@ -209181,1 +210493,3 @@\n-  if( nIns && aIns ) memcpy(&pParse->aBlob[iDel], aIns, nIns);\n+  if( nIns && aIns ){\n+    memcpy(&pParse->aBlob[iDel], aIns, nIns);\n+  }\n@@ -209266,1 +210580,15 @@\n-    case '0': {   *piOut = 0;     return 2; }\n+    case '0': {\n+      \/* JSON5 requires that the \\0 escape not be followed by a digit.\n+      ** But SQLite did not enforce this restriction in versions 3.42.0\n+      ** through 3.49.2.  That was a bug.  But some applications might have\n+      ** come to depend on that bug.  Use the SQLITE_BUG_COMPATIBLE_20250510\n+      ** option to restore the old buggy behavior. *\/\n+#ifdef SQLITE_BUG_COMPATIBLE_20250510\n+      \/* Legacy bug-compatible behavior *\/\n+      *piOut = 0;\n+#else\n+      \/* Correct behavior *\/\n+      *piOut = (n>2 && sqlite3Isdigit(z[2])) ? JSON_INVALID_CHAR : 0;\n+#endif\n+      return 2;\n+    }\n@@ -209766,1 +211094,1 @@\n-      zOut = sqlite3DbMallocRaw(db, nOut+1);\n+      zOut = sqlite3DbMallocRaw(db, ((u64)nOut)+1);\n@@ -209861,4 +211189,1 @@\n-      if( jsonFuncArgMightBeBinary(pArg) ){\n-        pParse->aBlob = (u8*)sqlite3_value_blob(pArg);\n-        pParse->nBlob = sqlite3_value_bytes(pArg);\n-      }else{\n+      if( !jsonArgIsJsonb(pArg, pParse) ){\n@@ -209944,1 +211269,1 @@\n-** arguments come in parse where each pair contains a JSON path and\n+** arguments come in pairs where each pair contains a JSON path and\n@@ -210015,5 +211340,24 @@\n-** a JSONB blob, then return FALSE;\n-**\n-** This routine is only called if it is already known that pArg is a\n-** blob.  The only open question is whether or not the blob appears\n-** to be a JSONB blob.\n+** a JSONB blob, then return FALSE.\n+**\n+** For small BLOBs (having no more than 7 bytes of payload) a full\n+** validity check is done.  So for small BLOBs this routine only returns\n+** true if the value is guaranteed to be a valid JSONB.  For larger BLOBs\n+** (8 byte or more of payload) only the size of the outermost element is\n+** checked to verify that the BLOB is superficially valid JSONB.\n+**\n+** A full JSONB validation is done on smaller BLOBs because those BLOBs might\n+** also be text JSON that has been incorrectly cast into a BLOB.\n+** (See tag-20240123-a and https:\/\/sqlite.org\/forum\/forumpost\/012136abd5)\n+** If the BLOB is 9 bytes are larger, then it is not possible for the\n+** superficial size check done here to pass if the input is really text\n+** JSON so we do not need to look deeper in that case.\n+**\n+** Why we only need to do full JSONB validation for smaller BLOBs:\n+**\n+** The first byte of valid JSON text must be one of: '{', '[', '\"', ' ', '\\n',\n+** '\\r', '\\t', '-', or a digit '0' through '9'.  Of these, only a subset\n+** can also be the first byte of JSONB:  '{', '[', and digits '3'\n+** through '9'.  In every one of those cases, the payload size is 7 bytes\n+** or less.  So if we do full JSONB validation for every BLOB where the\n+** payload is less than 7 bytes, we will never get a false positive for\n+** JSONB on an input that is really text JSON.\n@@ -210023,0 +211367,2 @@\n+  u8 c;\n+  if( sqlite3_value_type(pArg)!=SQLITE_BLOB ) return 0;\n@@ -210025,8 +211371,3 @@\n-  if( p->nBlob==0 ){\n-    p->aBlob = 0;\n-    return 0;\n-  }\n-  if( NEVER(p->aBlob==0) ){\n-    return 0;\n-  }\n-  if( (p->aBlob[0] & 0x0f)<=JSONB_OBJECT\n+  if( p->nBlob>0\n+   && ALWAYS(p->aBlob!=0)\n+   && ((c = p->aBlob[0]) & 0x0f)<=JSONB_OBJECT\n@@ -210035,1 +211376,4 @@\n-   && ((p->aBlob[0] & 0x0f)>JSONB_FALSE || sz==0)\n+   && ((c & 0x0f)>JSONB_FALSE || sz==0)\n+   && (sz>7\n+      || (c!=0x7b && c!=0x5b && !sqlite3Isdigit(c))\n+      || jsonbValidityCheck(p, 0, p->nBlob, 1)==0)\n@@ -210113,1 +211457,1 @@\n-    ** upon this buggy behavior, espeically when using the CLI and reading\n+    ** upon this buggy behavior, especially when using the CLI and reading\n@@ -211128,1 +212472,3 @@\n-      if( jsonFuncArgMightBeBinary(argv[0]) ){\n+      JsonParse py;\n+      memset(&py, 0, sizeof(py));\n+      if( jsonArgIsJsonb(argv[0], &py) ){\n@@ -211131,1 +212477,1 @@\n-          ** jsonFuncArgMightBeBinary() call above. *\/\n+          ** jsonArgIsJsonb() call above. *\/\n@@ -211136,7 +212482,1 @@\n-          JsonParse px;\n-          u32 iErr;\n-          memset(&px, 0, sizeof(px));\n-          px.aBlob = (u8*)sqlite3_value_blob(argv[0]);\n-          px.nBlob = sqlite3_value_bytes(argv[0]);\n-          iErr = jsonbValidityCheck(&px, 0, px.nBlob, 1);\n-          res = iErr==0;\n+          res = 0==jsonbValidityCheck(&py, 0, py.nBlob, 1);\n@@ -211200,3 +212540,1 @@\n-  if( jsonFuncArgMightBeBinary(argv[0]) ){\n-    s.aBlob = (u8*)sqlite3_value_blob(argv[0]);\n-    s.nBlob = sqlite3_value_bytes(argv[0]);\n+  if( jsonArgIsJsonb(argv[0], &s) ){\n@@ -211363,0 +212701,2 @@\n+    z = (const char*)sqlite3_value_text(argv[0]);\n+    n = sqlite3Strlen30(z);\n@@ -211366,1 +212706,1 @@\n-    }else if( pStr->nUsed>1 ){\n+    }else if( pStr->nUsed>1 && z!=0 ){\n@@ -211370,5 +212710,5 @@\n-    z = (const char*)sqlite3_value_text(argv[0]);\n-    n = sqlite3Strlen30(z);\n-    jsonAppendString(pStr, z, n);\n-    jsonAppendChar(pStr, ':');\n-    jsonAppendSqlValue(pStr, argv[1]);\n+    if( z!=0 ){\n+      jsonAppendString(pStr, z, n);\n+      jsonAppendChar(pStr, ':');\n+      jsonAppendSqlValue(pStr, argv[1]);\n+    }\n@@ -211887,3 +213227,2 @@\n-  if( jsonFuncArgMightBeBinary(argv[0]) ){\n-    p->sParse.nBlob = sqlite3_value_bytes(argv[0]);\n-    p->sParse.aBlob = (u8*)sqlite3_value_blob(argv[0]);\n+  if( jsonArgIsJsonb(argv[0], &p->sParse) ){\n+    \/* We have JSONB *\/\n@@ -212183,0 +213522,2 @@\n+\/* #include <stddef.h> *\/\n+\n@@ -212213,0 +213554,8 @@\n+#ifndef offsetof\n+#define offsetof(STRUCTURE,FIELD) ((size_t)((char*)&((STRUCTURE*)0)->FIELD))\n+#endif\n+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n+# define FLEXARRAY\n+#else\n+# define FLEXARRAY 1\n+#endif\n@@ -212533,1 +213882,1 @@\n-  RtreeDValue aParam[1];      \/* Values for parameters to the SQL function *\/\n+  RtreeDValue aParam[FLEXARRAY]; \/* Values for parameters to the SQL function *\/\n@@ -212536,0 +213885,4 @@\n+\/* Size of an RtreeMatchArg object with N parameters *\/\n+#define SZ_RTREEMATCHARG(N)  \\\n+        (offsetof(RtreeMatchArg,aParam)+(N)*sizeof(RtreeDValue))\n+\n@@ -214224,1 +215577,1 @@\n-** Return the N-dimensional volumn of the cell stored in *p.\n+** Return the N-dimensional volume of the cell stored in *p.\n@@ -215990,1 +217343,1 @@\n-** appends it to the report being accumuated in pCheck.\n+** appends it to the report being accumulated in pCheck.\n@@ -217178,1 +218531,1 @@\n-**    +2  x0,y0 is on the line segement\n+**    +2  x0,y0 is on the line segment\n@@ -217284,1 +218637,1 @@\n-\/* Objects used by the overlap algorihm. *\/\n+\/* Objects used by the overlap algorithm. *\/\n@@ -218331,2 +219684,1 @@\n-  nBlob = sizeof(RtreeMatchArg) + (nArg-1)*sizeof(RtreeDValue)\n-           + nArg*sizeof(sqlite3_value*);\n+  nBlob = SZ_RTREEMATCHARG(nArg) + nArg*sizeof(sqlite3_value*);\n@@ -219427,1 +220779,1 @@\n-** applied using this extension is hence refered to as an \"RBU update\".\n+** applied using this extension is hence referred to as an \"RBU update\".\n@@ -219724,1 +221076,1 @@\n-** As with sqlite3rbu_open(), Zipvfs users should rever to the comment\n+** As with sqlite3rbu_open(), Zipvfs users should refer to the comment\n@@ -219820,1 +221172,1 @@\n-** current state of the RBU update appliation to the RBU database.\n+** current state of the RBU update application to the RBU database.\n@@ -224746,1 +226098,1 @@\n-  ** check for the existance of a *-wal file. rbuVfsRead() contains\n+  ** check for the existence of a *-wal file. rbuVfsRead() contains\n@@ -226678,2 +228030,2 @@\n-      pgno--;\n-      pTab->pgnoTrunc = pgno;\n+      pTab->pgnoTrunc = pgno-1;\n+      pgno = 1;\n@@ -227976,1 +229328,1 @@\n-** fields are already initilialized, this function is a no-op.\n+** fields are already initialized, this function is a no-op.\n@@ -227995,0 +229347,2 @@\n+    sqlite3_free(pTab->azCol);\n+    pTab->abPK = 0;\n@@ -229002,0 +230356,1 @@\n+    pSession->bAutoAttach++;\n@@ -229003,0 +230358,1 @@\n+    pSession->bAutoAttach--;\n@@ -229013,1 +230369,1 @@\n-      int nCol;                   \/* Columns in zFrom.zTbl *\/\n+      int nCol = 0;               \/* Columns in zFrom.zTbl *\/\n@@ -229015,1 +230371,1 @@\n-      u8 *abPK;\n+      u8 *abPK = 0;\n@@ -229017,4 +230373,23 @@\n-      rc = sessionTableInfo(0, db, zFrom, zTbl,\n-          &nCol, 0, 0, &azCol, 0, 0, &abPK,\n-          pSession->bImplicitPK ? &bRowid : 0\n-      );\n+      char *zDbExists = 0;\n+\n+      \/* Check that database zFrom is attached.  *\/\n+      zDbExists = sqlite3_mprintf(\"SELECT * FROM %Q.sqlite_schema\", zFrom);\n+      if( zDbExists==0 ){\n+        rc = SQLITE_NOMEM;\n+      }else{\n+        sqlite3_stmt *pDbExists = 0;\n+        rc = sqlite3_prepare_v2(db, zDbExists, -1, &pDbExists, 0);\n+        if( rc==SQLITE_ERROR ){\n+          rc = SQLITE_OK;\n+          nCol = -1;\n+        }\n+        sqlite3_finalize(pDbExists);\n+        sqlite3_free(zDbExists);\n+      }\n+\n+      if( rc==SQLITE_OK && nCol==0 ){\n+        rc = sessionTableInfo(0, db, zFrom, zTbl,\n+            &nCol, 0, 0, &azCol, 0, 0, &abPK,\n+            pSession->bImplicitPK ? &bRowid : 0\n+        );\n+      }\n@@ -229023,1 +230398,8 @@\n-          bMismatch = 1;\n+          if( nCol<=0 ){\n+            rc = SQLITE_SCHEMA;\n+            if( pzErrMsg ){\n+              *pzErrMsg = sqlite3_mprintf(\"no such table: %s.%s\", zFrom, zTbl);\n+            }\n+          }else{\n+            bMismatch = 1;\n+          }\n@@ -229799,1 +231181,1 @@\n-  SessionBuffer buf = {0,0,0};    \/* Buffer in which to accumlate changeset *\/\n+  SessionBuffer buf = {0,0,0};    \/* Buffer in which to accumulate changeset *\/\n@@ -230152,2 +231534,2 @@\n-  if( pIn->xInput && pIn->iNext>=sessions_strm_chunk_size ){\n-    int nMove = pIn->buf.nBuf - pIn->iNext;\n+  if( pIn->xInput && pIn->iCurrent>=sessions_strm_chunk_size ){\n+    int nMove = pIn->buf.nBuf - pIn->iCurrent;\n@@ -230156,1 +231538,1 @@\n-      memmove(pIn->buf.aBuf, &pIn->buf.aBuf[pIn->iNext], nMove);\n+      memmove(pIn->buf.aBuf, &pIn->buf.aBuf[pIn->iCurrent], nMove);\n@@ -230158,2 +231540,3 @@\n-    pIn->buf.nBuf -= pIn->iNext;\n-    pIn->iNext = 0;\n+    pIn->buf.nBuf -= pIn->iCurrent;\n+    pIn->iNext -= pIn->iCurrent;\n+    pIn->iCurrent = 0;\n@@ -230513,1 +231896,0 @@\n-  sessionDiscardData(&p->in);\n@@ -230515,0 +231897,1 @@\n+  sessionDiscardData(&p->in);\n@@ -232873,0 +234256,2 @@\n+  int rc = SQLITE_OK;\n+\n@@ -232878,1 +234263,4 @@\n-    return SQLITE_ERROR;\n+    rc = SQLITE_ERROR;\n+  }else{\n+    pIter->in.bNoDiscard = 1;\n+    rc = sessionOneChangeToHash(pGrp, pIter, 0);\n@@ -232880,1 +234268,1 @@\n-  return sessionOneChangeToHash(pGrp, pIter, 0);\n+  return rc;\n@@ -234178,0 +235566,1 @@\n+\/* #include <stddef.h> *\/\n@@ -234233,0 +235622,12 @@\n+\/*\n+** Macros needed to provide flexible arrays in a portable way\n+*\/\n+#ifndef offsetof\n+# define offsetof(STRUCTURE,FIELD) ((size_t)((char*)&((STRUCTURE*)0)->FIELD))\n+#endif\n+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n+# define FLEXARRAY\n+#else\n+# define FLEXARRAY 1\n+#endif\n+\n@@ -234305,1 +235706,1 @@\n-  int aiCol[1];\n+  int aiCol[FLEXARRAY];\n@@ -234308,1 +235709,2 @@\n-\n+\/* Size (int bytes) of a complete Fts5Colset object with N columns. *\/\n+#define SZ_FTS5COLSET(N) (sizeof(i64)*((N+2)\/2))\n@@ -235137,1 +236539,1 @@\n-** at each \"%%\" line.  Also, any \"P-a-r-s-e\" identifer prefix (without the\n+** at each \"%%\" line.  Also, any \"P-a-r-s-e\" identifier prefix (without the\n@@ -237291,1 +238693,1 @@\n-        ** negative. Which is undesirable. So the mimimum allowable IDF is\n+        ** negative. Which is undesirable. So the minimum allowable IDF is\n@@ -237754,1 +239156,1 @@\n-**   * The unicode \"subsitute\" character (0x1A).\n+**   * The unicode \"substitute\" character (0x1A).\n@@ -239072,1 +240474,1 @@\n-  Fts5ExprNode *apChild[1];       \/* Array of child nodes *\/\n+  Fts5ExprNode *apChild[FLEXARRAY]; \/* Array of child nodes *\/\n@@ -239075,0 +240477,4 @@\n+\/* Size (in bytes) of an Fts5ExprNode object that holds up to N children *\/\n+#define SZ_FTS5EXPRNODE(N) \\\n+  (offsetof(Fts5ExprNode,apChild) + (N)*sizeof(Fts5ExprNode*))\n+\n@@ -239105,1 +240511,1 @@\n-  Fts5ExprTerm aTerm[1];          \/* Terms that make up this phrase *\/\n+  Fts5ExprTerm aTerm[FLEXARRAY];  \/* Terms that make up this phrase *\/\n@@ -239108,0 +240514,4 @@\n+\/* Size (in bytes) of an Fts5ExprPhrase object that holds up to N terms *\/\n+#define SZ_FTS5EXPRPHRASE(N) \\\n+    (offsetof(Fts5ExprPhrase,aTerm) + (N)*sizeof(Fts5ExprTerm))\n+\n@@ -239116,1 +240526,1 @@\n-  Fts5ExprPhrase *apPhrase[1];    \/* Array of phrase pointers *\/\n+  Fts5ExprPhrase *apPhrase[FLEXARRAY]; \/* Array of phrase pointers *\/\n@@ -239119,0 +240529,3 @@\n+\/* Size (in bytes) of an Fts5ExprNearset object covering up to N phrases *\/\n+#define SZ_FTS5EXPRNEARSET(N) \\\n+  (offsetof(Fts5ExprNearset,apPhrase)+(N)*sizeof(Fts5ExprPhrase*))\n@@ -239278,1 +240691,1 @@\n-    int n = sizeof(Fts5Colset);\n+    int n = SZ_FTS5COLSET(1);\n@@ -240636,1 +242049,1 @@\n-      nByte = sizeof(Fts5ExprNearset) + SZALLOC * sizeof(Fts5ExprPhrase*);\n+      nByte = SZ_FTS5EXPRNEARSET(SZALLOC+1);\n@@ -240647,1 +242060,1 @@\n-      nByte = sizeof(Fts5ExprNearset) + nNew * sizeof(Fts5ExprPhrase*);\n+      nByte = SZ_FTS5EXPRNEARSET(nNew+1);\n@@ -240738,1 +242151,1 @@\n-          sizeof(Fts5ExprPhrase) + sizeof(Fts5ExprTerm) * nNew\n+          SZ_FTS5EXPRPHRASE(nNew+1)\n@@ -240743,1 +242156,1 @@\n-        if( pPhrase==0 ) memset(pNew, 0, sizeof(Fts5ExprPhrase));\n+        if( pPhrase==0 ) memset(pNew, 0, SZ_FTS5EXPRPHRASE(1));\n@@ -240851,1 +242264,1 @@\n-      sCtx.pPhrase = sqlite3Fts5MallocZero(&pParse->rc, sizeof(Fts5ExprPhrase));\n+      sCtx.pPhrase = sqlite3Fts5MallocZero(&pParse->rc, SZ_FTS5EXPRPHRASE(1));\n@@ -240886,2 +242299,1 @@\n-    pNew->pRoot = (Fts5ExprNode*)sqlite3Fts5MallocZero(&rc,\n-        sizeof(Fts5ExprNode));\n+    pNew->pRoot = (Fts5ExprNode*)sqlite3Fts5MallocZero(&rc, SZ_FTS5EXPRNODE(1));\n@@ -240891,1 +242303,1 @@\n-        sizeof(Fts5ExprNearset) + sizeof(Fts5ExprPhrase*));\n+                                                    SZ_FTS5EXPRNEARSET(2));\n@@ -240898,1 +242310,1 @@\n-      nByte = sizeof(Fts5Colset) + (pColsetOrig->nCol-1) * sizeof(int);\n+      nByte = SZ_FTS5COLSET(pColsetOrig->nCol);\n@@ -240926,1 +242338,1 @@\n-      sCtx.pPhrase = sqlite3Fts5MallocZero(&rc, sizeof(Fts5ExprPhrase));\n+      sCtx.pPhrase = sqlite3Fts5MallocZero(&rc, SZ_FTS5EXPRPHRASE(1));\n@@ -240991,1 +242403,2 @@\n-        nNear = nNear * 10 + (p->p[i] - '0');\n+        if( nNear<214748363 ) nNear = nNear * 10 + (p->p[i] - '0');\n+        \/*  ^^^^^^^^^^^^^^^---  Prevent integer overflow *\/\n@@ -241020,1 +242433,1 @@\n-  pNew = sqlite3_realloc64(p, sizeof(Fts5Colset) + sizeof(int)*nCol);\n+  pNew = sqlite3_realloc64(p, SZ_FTS5COLSET(nCol+1));\n@@ -241055,1 +242468,1 @@\n-      sizeof(Fts5Colset) + sizeof(int)*nCol\n+      SZ_FTS5COLSET(nCol+1)\n@@ -241116,1 +242529,1 @@\n-    sqlite3_int64 nByte = sizeof(Fts5Colset) + (pOrig->nCol-1) * sizeof(int);\n+    sqlite3_int64 nByte = SZ_FTS5COLSET(pOrig->nCol);\n@@ -241284,1 +242697,1 @@\n-  nByte = sizeof(Fts5ExprNode) + nTerm*sizeof(Fts5ExprNode*);\n+  nByte = SZ_FTS5EXPRNODE(nTerm+1);\n@@ -241294,1 +242707,1 @@\n-          &pParse->rc, sizeof(Fts5ExprPhrase)\n+          &pParse->rc, SZ_FTS5EXPRPHRASE(1)\n@@ -241363,1 +242776,1 @@\n-      nByte = sizeof(Fts5ExprNode) + sizeof(Fts5ExprNode*)*(nChild-1);\n+      nByte = SZ_FTS5EXPRNODE(nChild);\n@@ -242238,1 +243651,1 @@\n-** Clear the token mappings for all Fts5IndexIter objects mannaged by\n+** Clear the token mappings for all Fts5IndexIter objects managed by\n@@ -242273,1 +243686,1 @@\n-** to accumuluate \"term -> doclist\" content before it is flused to a level-0\n+** to accumulate \"term -> doclist\" content before it is flushed to a level-0\n@@ -242330,1 +243743,1 @@\n-** Eqivalent to:\n+** Equivalent to:\n@@ -243266,1 +244679,1 @@\n-  Fts5StructureLevel aLevel[1];   \/* Array of nLevel level objects *\/\n+  Fts5StructureLevel aLevel[FLEXARRAY]; \/* Array of nLevel level objects *\/\n@@ -243269,0 +244682,4 @@\n+\/* Size (in bytes) of an Fts5Structure object holding up to N levels *\/\n+#define SZ_FTS5STRUCTURE(N) \\\n+         (offsetof(Fts5Structure,aLevel) + (N)*sizeof(Fts5StructureLevel))\n+\n@@ -243398,1 +244815,1 @@\n-  int nRef;                       \/* Number of pointers to this object *\/\n+  int nRef;                         \/* Number of pointers to this object *\/\n@@ -243400,1 +244817,1 @@\n-  Fts5Data *apTombstone[1];       \/* Array of tombstone pages *\/\n+  Fts5Data *apTombstone[FLEXARRAY]; \/* Array of tombstone pages *\/\n@@ -243403,0 +244820,4 @@\n+\/* Size (in bytes) of an Fts5TombstoneArray holding up to N tombstones *\/\n+#define SZ_FTS5TOMBSTONEARRAY(N) \\\n+  (offsetof(Fts5TombstoneArray,apTombstone)+(N)*sizeof(Fts5Data*))\n+\n@@ -243471,1 +244892,1 @@\n-  Fts5SegIter aSeg[1];            \/* Array of segment iterators *\/\n+  Fts5SegIter aSeg[FLEXARRAY];    \/* Array of segment iterators *\/\n@@ -243474,0 +244895,3 @@\n+\/* Size (in bytes) of an Fts5Iter object holding up to N segment iterators *\/\n+#define SZ_FTS5ITER(N)  (offsetof(Fts5Iter,aSeg)+(N)*sizeof(Fts5SegIter))\n+\n@@ -243500,1 +244924,1 @@\n-  Fts5DlidxLvl aLvl[1];\n+  Fts5DlidxLvl aLvl[FLEXARRAY];\n@@ -243503,0 +244927,4 @@\n+\/* Size (in bytes) of an Fts5DlidxIter object with up to N levels *\/\n+#define SZ_FTS5DLIDXITER(N) \\\n+          (offsetof(Fts5DlidxIter,aLvl)+(N)*sizeof(Fts5DlidxLvl))\n+\n@@ -243870,1 +245298,1 @@\n-    i64 nByte = sizeof(Fts5Structure)+(p->nLevel-1)*sizeof(Fts5StructureLevel);\n+    i64 nByte = SZ_FTS5STRUCTURE(p->nLevel);\n@@ -243944,4 +245372,1 @@\n-  nByte = (\n-      sizeof(Fts5Structure) +                    \/* Main structure *\/\n-      sizeof(Fts5StructureLevel) * (nLevel-1)    \/* aLevel[] array *\/\n-  );\n+  nByte = SZ_FTS5STRUCTURE(nLevel);\n@@ -244027,4 +245452,1 @@\n-    sqlite3_int64 nByte = (\n-        sizeof(Fts5Structure) +                  \/* Main structure *\/\n-        sizeof(Fts5StructureLevel) * (nLevel+1)  \/* aLevel[] array *\/\n-    );\n+    sqlite3_int64 nByte = SZ_FTS5STRUCTURE(nLevel+2);\n@@ -244569,1 +245991,1 @@\n-    sqlite3_int64 nByte = sizeof(Fts5DlidxIter) + i * sizeof(Fts5DlidxLvl);\n+    sqlite3_int64 nByte = SZ_FTS5DLIDXITER(i+1);\n@@ -244785,1 +246207,1 @@\n-  const int nTomb = pIter->pSeg->nPgTombstone;\n+  const i64 nTomb = (i64)pIter->pSeg->nPgTombstone;\n@@ -244787,1 +246209,1 @@\n-    int nByte = nTomb * sizeof(Fts5Data*) + sizeof(Fts5TombstoneArray);\n+    i64 nByte = SZ_FTS5TOMBSTONEARRAY(nTomb+1);\n@@ -246248,2 +247670,1 @@\n-      sizeof(Fts5Iter) +                  \/* pNew *\/\n-      sizeof(Fts5SegIter) * (nSlot-1) +   \/* pNew->aSeg[] *\/\n+      SZ_FTS5ITER(nSlot) +                \/* pNew + pNew->aSeg[] *\/\n@@ -248050,1 +249471,1 @@\n-  aIdx = sqlite3Fts5MallocZero(&p->rc, nIdx+16);\n+  aIdx = sqlite3Fts5MallocZero(&p->rc, ((i64)nIdx)+16);\n@@ -248615,1 +250036,1 @@\n-  sqlite3_int64 nByte = sizeof(Fts5Structure);\n+  sqlite3_int64 nByte = SZ_FTS5STRUCTURE(1);\n@@ -248644,1 +250065,2 @@\n-  nByte += (pStruct->nLevel+1) * sizeof(Fts5StructureLevel);\n+  nByte += (((i64)pStruct->nLevel)+1) * sizeof(Fts5StructureLevel);\n+  assert( nByte==SZ_FTS5STRUCTURE(pStruct->nLevel+2) );\n@@ -249221,1 +250643,1 @@\n-  Fts5Iter *apIter[1];\n+  Fts5Iter *apIter[FLEXARRAY];\n@@ -249224,0 +250646,4 @@\n+\/* Size in bytes of an Fts5TokenDataIter object holding up to N iterators *\/\n+#define SZ_FTS5TOKENDATAITER(N) \\\n+    (offsetof(Fts5TokenDataIter,apIter) + (N)*sizeof(Fts5Iter))\n+\n@@ -249295,1 +250721,1 @@\n-** The sorting algorithm requries a malloc(). If this fails, an error code\n+** The sorting algorithm requires a malloc(). If this fails, an error code\n@@ -249486,1 +250912,1 @@\n-    s2.pT = (Fts5TokenDataIter*)fts5IdxMalloc(p, sizeof(*s2.pT));\n+    s2.pT = (Fts5TokenDataIter*)fts5IdxMalloc(p, SZ_FTS5TOKENDATAITER(1));\n@@ -249532,1 +250958,2 @@\n-    pData = fts5IdxMalloc(p, sizeof(*pData)+s.doclist.n+FTS5_DATA_ZERO_PADDING);\n+    pData = fts5IdxMalloc(p, sizeof(*pData)\n+                             + ((i64)s.doclist.n)+FTS5_DATA_ZERO_PADDING);\n@@ -249613,1 +251040,2 @@\n-  Fts5Structure s;\n+  Fts5Structure *pTmp;\n+  u8 tmpSpace[SZ_FTS5STRUCTURE(1)];\n@@ -249616,1 +251044,2 @@\n-  memset(&s, 0, sizeof(Fts5Structure));\n+  pTmp = (Fts5Structure*)tmpSpace;\n+  memset(pTmp, 0, SZ_FTS5STRUCTURE(1));\n@@ -249618,1 +251047,1 @@\n-    s.nOriginCntr = 1;\n+    pTmp->nOriginCntr = 1;\n@@ -249621,1 +251050,1 @@\n-  fts5StructureWrite(p, &s);\n+  fts5StructureWrite(p, pTmp);\n@@ -249829,1 +251258,1 @@\n-      int nByte = nAlloc * sizeof(Fts5Iter*) + sizeof(Fts5TokenDataIter);\n+      int nByte = SZ_FTS5TOKENDATAITER(nAlloc+1);\n@@ -250345,1 +251774,2 @@\n-  ctx.pT = (Fts5TokenDataIter*)sqlite3Fts5MallocZero(&p->rc, sizeof(*ctx.pT));\n+  ctx.pT = (Fts5TokenDataIter*)sqlite3Fts5MallocZero(&p->rc,\n+                                                   SZ_FTS5TOKENDATAITER(1));\n@@ -250476,1 +251906,2 @@\n-      pT = (Fts5TokenDataIter*)sqlite3Fts5MallocZero(&p->rc, sizeof(*pT));\n+      pT = (Fts5TokenDataIter*)sqlite3Fts5MallocZero(&p->rc,\n+                                           SZ_FTS5TOKENDATAITER(1));\n@@ -251510,1 +252941,1 @@\n-  int iSegid, iHeight, iPgno, bDlidx, bTomb;     \/* Rowid compenents *\/\n+  int iSegid, iHeight, iPgno, bDlidx, bTomb;     \/* Rowid components *\/\n@@ -251756,1 +253187,1 @@\n-  nSpace = n + FTS5_DATA_ZERO_PADDING;\n+  nSpace = ((i64)n) + FTS5_DATA_ZERO_PADDING;\n@@ -252471,1 +253902,1 @@\n-  int aIdx[1];                    \/* Offsets into aPoslist for current row *\/\n+  int aIdx[FLEXARRAY];            \/* Offsets into aPoslist for current row *\/\n@@ -252474,0 +253905,2 @@\n+\/* Size (int bytes) of an Fts5Sorter object with N indexes *\/\n+#define SZ_FTS5SORTER(N) (offsetof(Fts5Sorter,nIdx)+((N+2)\/2)*sizeof(i64))\n@@ -253351,1 +254784,1 @@\n-  nByte = sizeof(Fts5Sorter) + sizeof(int) * (nPhrase-1);\n+  nByte = SZ_FTS5SORTER(nPhrase);\n@@ -255877,1 +257310,1 @@\n-  sqlite3_result_text(pCtx, \"fts5: 2025-02-18 13:38:58 873d4e274b4988d260ba8354a9718324a1c26187a4ab4c1cc0227c03d0f10e70\", -1, SQLITE_TRANSIENT);\n+  sqlite3_result_text(pCtx, \"fts5: 2025-07-30 19:33:53 4d8adfb30e03f9cf27f800a2c1ba3c48fb4ca1b08b0f5ed59a4d5ecbf45e20a3\", -1, SQLITE_TRANSIENT);\n@@ -256102,2 +257535,2 @@\n-    extern int sqlite3Fts5TestRegisterMatchinfo(sqlite3*);\n-    rc = sqlite3Fts5TestRegisterMatchinfo(db);\n+    extern int sqlite3Fts5TestRegisterMatchinfoAPI(fts5_api*);\n+    rc = sqlite3Fts5TestRegisterMatchinfoAPI(&pGlobal->api);\n@@ -256692,0 +258125,1 @@\n+      sqlite3_value *pFree = 0;\n@@ -256708,5 +258142,16 @@\n-        pText = (const char*)sqlite3_value_text(pVal);\n-        nText = sqlite3_value_bytes(pVal);\n-        if( pConfig->bLocale && pSeek ){\n-          pLoc = (const char*)sqlite3_column_text(pSeek, iCol + pConfig->nCol);\n-          nLoc = sqlite3_column_bytes(pSeek, iCol + pConfig->nCol);\n+        if( sqlite3_value_type(pVal)!=SQLITE_TEXT ){\n+          \/* Make a copy of the value to work with. This is because the call\n+          ** to sqlite3_value_text() below forces the type of the value to\n+          ** SQLITE_TEXT, and we may need to use it again later. *\/\n+          pFree = pVal = sqlite3_value_dup(pVal);\n+          if( pVal==0 ){\n+            rc = SQLITE_NOMEM;\n+          }\n+        }\n+        if( rc==SQLITE_OK ){\n+          pText = (const char*)sqlite3_value_text(pVal);\n+          nText = sqlite3_value_bytes(pVal);\n+          if( pConfig->bLocale && pSeek ){\n+            pLoc = (const char*)sqlite3_column_text(pSeek, iCol+pConfig->nCol);\n+            nLoc = sqlite3_column_bytes(pSeek, iCol + pConfig->nCol);\n+          }\n@@ -256728,0 +258173,1 @@\n+      sqlite3_value_free(pFree);\n@@ -259941,1 +261387,0 @@\n-\n@@ -260482,1 +261927,1 @@\n-    int nByte;                      \/* Bytes of space to allocate *\/\n+    i64 nByte;                      \/* Bytes of space to allocate *\/\n@@ -260486,2 +261931,2 @@\n-    int nDb = (int)strlen(zDb)+1;\n-    int nTab = (int)strlen(zTab)+1;\n+    i64 nDb = strlen(zDb)+1;\n+    i64 nTab = strlen(zTab)+1;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/sqlite3.c","additions":3096,"deletions":1651,"binary":false,"changes":4747,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-** <a href=\"http:\/\/www.fossil-scm.org\/\">Fossil configuration management\n+** <a href=\"http:\/\/fossil-scm.org\/\">Fossil configuration management\n@@ -149,3 +149,3 @@\n-#define SQLITE_VERSION        \"3.49.1\"\n-#define SQLITE_VERSION_NUMBER 3049001\n-#define SQLITE_SOURCE_ID      \"2025-02-18 13:38:58 873d4e274b4988d260ba8354a9718324a1c26187a4ab4c1cc0227c03d0f10e70\"\n+#define SQLITE_VERSION        \"3.50.4\"\n+#define SQLITE_VERSION_NUMBER 3050004\n+#define SQLITE_SOURCE_ID      \"2025-07-30 19:33:53 4d8adfb30e03f9cf27f800a2c1ba3c48fb4ca1b08b0f5ed59a4d5ecbf45e20a3\"\n@@ -1166,0 +1166,6 @@\n+** <li>[[SQLITE_FCNTL_BLOCK_ON_CONNECT]]\n+** The [SQLITE_FCNTL_BLOCK_ON_CONNECT] opcode is used to configure the\n+** VFS to block when taking a SHARED lock to connect to a wal mode database.\n+** This is used to implement the functionality associated with\n+** SQLITE_SETLK_BLOCK_ON_CONNECT.\n+**\n@@ -1262,0 +1268,1 @@\n+#define SQLITE_FCNTL_BLOCK_ON_CONNECT       44\n@@ -1992,1 +1999,1 @@\n-** the default size of lookaside memory on each [database connection].\n+** the default size of [lookaside memory] on each [database connection].\n@@ -1994,5 +2001,8 @@\n-** size of each lookaside buffer slot and the second is the number of\n-** slots allocated to each database connection.)^  ^(SQLITE_CONFIG_LOOKASIDE\n-** sets the <i>default<\/i> lookaside size. The [SQLITE_DBCONFIG_LOOKASIDE]\n-** option to [sqlite3_db_config()] can be used to change the lookaside\n-** configuration on individual connections.)^ <\/dd>\n+** size of each lookaside buffer slot (\"sz\") and the second is the number of\n+** slots allocated to each database connection (\"cnt\").)^\n+** ^(SQLITE_CONFIG_LOOKASIDE sets the <i>default<\/i> lookaside size.\n+** The [SQLITE_DBCONFIG_LOOKASIDE] option to [sqlite3_db_config()] can\n+** be used to change the lookaside configuration on individual connections.)^\n+** The [-DSQLITE_DEFAULT_LOOKASIDE] option can be used to change the\n+** default lookaside configuration at compile-time.\n+** <\/dd>\n@@ -2235,1 +2245,1 @@\n-** configuration of the lookaside memory allocator within a database\n+** configuration of the [lookaside memory allocator] within a database\n@@ -2242,1 +2252,2 @@\n-** ^The first argument (the third parameter to [sqlite3_db_config()] is a\n+** <ol>\n+** <li><p>The first argument (\"buf\") is a\n@@ -2244,9 +2255,18 @@\n-** ^The first argument after the SQLITE_DBCONFIG_LOOKASIDE verb\n-** may be NULL in which case SQLite will allocate the\n-** lookaside buffer itself using [sqlite3_malloc()]. ^The second argument is the\n-** size of each lookaside buffer slot.  ^The third argument is the number of\n-** slots.  The size of the buffer in the first argument must be greater than\n-** or equal to the product of the second and third arguments.  The buffer\n-** must be aligned to an 8-byte boundary.  ^If the second argument to\n-** SQLITE_DBCONFIG_LOOKASIDE is not a multiple of 8, it is internally\n-** rounded down to the next smaller multiple of 8.  ^(The lookaside memory\n+** The first argument may be NULL in which case SQLite will allocate the\n+** lookaside buffer itself using [sqlite3_malloc()].\n+** <li><P>The second argument (\"sz\") is the\n+** size of each lookaside buffer slot.  Lookaside is disabled if \"sz\"\n+** is less than 8.  The \"sz\" argument should be a multiple of 8 less than\n+** 65536.  If \"sz\" does not meet this constraint, it is reduced in size until\n+** it does.\n+** <li><p>The third argument (\"cnt\") is the number of slots. Lookaside is disabled\n+** if \"cnt\"is less than 1.  The \"cnt\" value will be reduced, if necessary, so\n+** that the product of \"sz\" and \"cnt\" does not exceed 2,147,418,112.  The \"cnt\"\n+** parameter is usually chosen so that the product of \"sz\" and \"cnt\" is less\n+** than 1,000,000.\n+** <\/ol>\n+** <p>If the \"buf\" argument is not NULL, then it must\n+** point to a memory buffer with a size that is greater than\n+** or equal to the product of \"sz\" and \"cnt\".\n+** The buffer must be aligned to an 8-byte boundary.\n+** The lookaside memory\n@@ -2255,2 +2275,1 @@\n-** when the \"current value\" returned by\n-** [sqlite3_db_status](D,[SQLITE_DBSTATUS_LOOKASIDE_USED],...) is zero.\n+** when the value returned by [SQLITE_DBSTATUS_LOOKASIDE_USED] is zero.\n@@ -2259,1 +2278,11 @@\n-** [SQLITE_BUSY].)^<\/dd>\n+** [SQLITE_BUSY].\n+** If the \"buf\" argument is NULL and an attempt\n+** to allocate memory based on \"sz\" and \"cnt\" fails, then\n+** lookaside is silently disabled.\n+** <p>\n+** The [SQLITE_CONFIG_LOOKASIDE] configuration option can be used to set the\n+** default lookaside configuration at initialization.  The\n+** [-DSQLITE_DEFAULT_LOOKASIDE] option can be used to set the default lookaside\n+** configuration at compile-time.  Typical values for lookaside are 1200 for\n+** \"sz\" and 40 to 100 for \"cnt\".\n+** <\/dd>\n@@ -2996,0 +3025,38 @@\n+\/*\n+** CAPI3REF: Set the Setlk Timeout\n+** METHOD: sqlite3\n+**\n+** This routine is only useful in SQLITE_ENABLE_SETLK_TIMEOUT builds. If\n+** the VFS supports blocking locks, it sets the timeout in ms used by\n+** eligible locks taken on wal mode databases by the specified database\n+** handle. In non-SQLITE_ENABLE_SETLK_TIMEOUT builds, or if the VFS does\n+** not support blocking locks, this function is a no-op.\n+**\n+** Passing 0 to this function disables blocking locks altogether. Passing\n+** -1 to this function requests that the VFS blocks for a long time -\n+** indefinitely if possible. The results of passing any other negative value\n+** are undefined.\n+**\n+** Internally, each SQLite database handle store two timeout values - the\n+** busy-timeout (used for rollback mode databases, or if the VFS does not\n+** support blocking locks) and the setlk-timeout (used for blocking locks\n+** on wal-mode databases). The sqlite3_busy_timeout() method sets both\n+** values, this function sets only the setlk-timeout value. Therefore,\n+** to configure separate busy-timeout and setlk-timeout values for a single\n+** database handle, call sqlite3_busy_timeout() followed by this function.\n+**\n+** Whenever the number of connections to a wal mode database falls from\n+** 1 to 0, the last connection takes an exclusive lock on the database,\n+** then checkpoints and deletes the wal file. While it is doing this, any\n+** new connection that tries to read from the database fails with an\n+** SQLITE_BUSY error. Or, if the SQLITE_SETLK_BLOCK_ON_CONNECT flag is\n+** passed to this API, the new connection blocks until the exclusive lock\n+** has been released.\n+*\/\n+SQLITE_API int sqlite3_setlk_timeout(sqlite3*, int ms, int flags);\n+\n+\/*\n+** CAPI3REF: Flags for sqlite3_setlk_timeout()\n+*\/\n+#define SQLITE_SETLK_BLOCK_ON_CONNECT 0x01\n+\n@@ -4015,1 +4082,1 @@\n-** with N URI parameters key\/values pairs in the array P.  The result from\n+** an array P of N URI Key\/Value pairs.  The result from\n@@ -4696,1 +4763,1 @@\n-** literals may be replaced by a [parameter] that matches one of following\n+** literals may be replaced by a [parameter] that matches one of the following\n@@ -4741,1 +4808,1 @@\n-** found in first character, which is removed, or in the absence of a BOM\n+** found in the first character, which is removed, or in the absence of a BOM\n@@ -4761,1 +4828,1 @@\n-** terminated.  If any NUL characters occurs at byte offsets less than\n+** terminated.  If any NUL characters occur at byte offsets less than\n@@ -4973,1 +5040,1 @@\n-** table column that is the origin of a particular result column in\n+** table column that is the origin of a particular result column in a\n@@ -5111,1 +5178,1 @@\n-** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1],\n+** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1]),\n@@ -5542,2 +5609,2 @@\n-** used inside of triggers, view, CHECK constraints, or other elements of\n-** the database schema.  This flags is especially recommended for SQL\n+** used inside of triggers, views, CHECK constraints, or other elements of\n+** the database schema.  This flag is especially recommended for SQL\n@@ -5574,1 +5641,1 @@\n-** sqlite3_create_window_function() is not NULL, then it is destructor for\n+** sqlite3_create_window_function() is not NULL, then it is the destructor for\n@@ -5974,1 +6041,1 @@\n-** object D and returns a pointer to that copy.  ^The [sqlite3_value] returned\n+** object V and returns a pointer to that copy.  ^The [sqlite3_value] returned\n@@ -6012,1 +6079,1 @@\n-** determined by the N parameter on first successful call.  Changing the\n+** determined by the N parameter on the first successful call.  Changing the\n@@ -6174,1 +6241,1 @@\n-** an attacker to invoke them.  Any agent that can invoke these interfaces\n+** attacker to invoke them.  Any agent that can invoke these interfaces\n@@ -6288,1 +6355,1 @@\n-** appear if the string where NUL terminated.  If any NUL characters occur\n+** appear if the string were NUL terminated.  If any NUL characters occur\n@@ -6346,1 +6413,1 @@\n-** If these routines are called from within the different thread\n+** If these routines are called from within a different thread\n@@ -6752,1 +6819,1 @@\n-** for the N-th database on database connection D, or a NULL pointer of N is\n+** for the N-th database on database connection D, or a NULL pointer if N is\n@@ -6847,1 +6914,1 @@\n-** will advanced to SQLITE_TXN_WRITE if any changes occur and there are\n+** will be advanced to SQLITE_TXN_WRITE if any changes occur and there are\n@@ -6856,1 +6923,1 @@\n-** to SQLITE_TXN_NONE at the next [ROLLBACK] or [COMMIT].<\/dd>\n+** SQLITE_TXN_NONE at the next [ROLLBACK] or [COMMIT].<\/dd>\n@@ -7007,0 +7074,2 @@\n+** ^The update hook is disabled by invoking sqlite3_update_hook()\n+** with a NULL pointer as the second parameter.\n@@ -7135,1 +7204,1 @@\n-** by all database connections within a single process.\n+** used by all database connections within a single process.\n@@ -7193,1 +7262,1 @@\n-** changes in future releases of SQLite.\n+** change in future releases of SQLite.\n@@ -7308,2 +7377,2 @@\n-** If that does not work, it constructs a name \"sqlite3_X_init\" where the\n-** X is consists of the lower-case equivalent of all ASCII alphabetic\n+** If that does not work, it constructs a name \"sqlite3_X_init\" where\n+** X consists of the lower-case equivalent of all ASCII alphabetic\n@@ -7380,1 +7449,1 @@\n-** entry point where as follows:\n+** entry point were as follows:\n@@ -7544,1 +7613,1 @@\n-** checked separately in byte code.  If the omit flag is change to true, then\n+** checked separately in byte code.  If the omit flag is changed to true, then\n@@ -7570,1 +7639,1 @@\n-** output to show the idxNum has hex instead of as decimal.  Another flag is\n+** output to show the idxNum as hex instead of as decimal.  Another flag is\n@@ -7711,1 +7780,1 @@\n-** when a new virtual table is be being created or reinitialized.\n+** when a new virtual table is being created or reinitialized.\n@@ -7876,1 +7945,1 @@\n-** on *ppBlob after this function it returns.\n+** on *ppBlob after this function returns.\n@@ -7996,1 +8065,1 @@\n-** incremental blob I\/O routines can only read or overwriting existing\n+** incremental blob I\/O routines can only read or overwrite existing\n@@ -8146,1 +8215,1 @@\n-** mutex.  The argument to sqlite3_mutex_alloc() must one of these\n+** mutex.  The argument to sqlite3_mutex_alloc() must be one of these\n@@ -8379,1 +8448,1 @@\n-** ^This interface returns a pointer the [sqlite3_mutex] object that\n+** ^This interface returns a pointer to the [sqlite3_mutex] object that\n@@ -8502,1 +8571,1 @@\n-** recognized by SQLite.  Applications can uses these routines to determine\n+** recognized by SQLite.  Applications can use these routines to determine\n@@ -8670,1 +8739,1 @@\n-** [sqlite3_str] object.  Applications must not used the pointer returned\n+** [sqlite3_str] object.  Applications must not use the pointer returned by\n@@ -8756,1 +8825,1 @@\n-** where too large (they were larger than the \"sz\" parameter to\n+** were too large (they were larger than the \"sz\" parameter to\n@@ -8840,1 +8909,1 @@\n-** the current value is always zero.)^\n+** the current value is always zero.<\/dd>)^\n@@ -8844,1 +8913,1 @@\n-** <dd>This parameter returns the number malloc attempts that might have\n+** <dd>This parameter returns the number of malloc attempts that might have\n@@ -8848,1 +8917,1 @@\n-** the current value is always zero.)^\n+** the current value is always zero.<\/dd>)^\n@@ -8852,1 +8921,1 @@\n-** <dd>This parameter returns the number malloc attempts that might have\n+** <dd>This parameter returns the number of malloc attempts that might have\n@@ -8856,1 +8925,1 @@\n-** the current value is always zero.)^\n+** the current value is always zero.<\/dd>)^\n@@ -8862,0 +8931,1 @@\n+** <\/dd>\n@@ -8870,1 +8940,1 @@\n-** value as DBSTATUS_CACHE_USED. Or, if one or more or the pager caches are\n+** value as DBSTATUS_CACHE_USED. Or, if one or more of the pager caches are\n@@ -8873,1 +8943,1 @@\n-** SQLITE_DBSTATUS_CACHE_USED_SHARED is always 0.\n+** SQLITE_DBSTATUS_CACHE_USED_SHARED is always 0.<\/dd>\n@@ -8883,0 +8953,1 @@\n+** <\/dd>\n@@ -8919,1 +8990,1 @@\n-** additional overhead. This parameter can be used help identify\n+** additional overhead. This parameter can be used to help identify\n@@ -8990,1 +9061,1 @@\n-** improvement performance through careful use of indices.<\/dd>\n+** improve performance through careful use of indices.<\/dd>\n@@ -8996,1 +9067,1 @@\n-** improvement performance by adding permanent indices that do not\n+** improve performance by adding permanent indices that do not\n@@ -9005,1 +9076,1 @@\n-** then the value returned by this statement status code is undefined.\n+** then the value returned by this statement status code is undefined.<\/dd>\n@@ -9010,1 +9081,1 @@\n-** [bound parameters] that might affect the query plan.\n+** [bound parameters] that might affect the query plan.<\/dd>\n@@ -9017,1 +9088,1 @@\n-** cycle.\n+** cycle.<\/dd>\n@@ -9027,1 +9098,1 @@\n-** had to be processed as normal.\n+** had to be processed as normal.<\/dd>\n@@ -9132,1 +9203,1 @@\n-** be allocated by the cache.  ^szPage will always a power of two.  ^The\n+** be allocated by the cache.  ^szPage will always be a power of two.  ^The\n@@ -9134,1 +9205,1 @@\n-** associated with each page cache entry.  ^The szExtra parameter will\n+** associated with each page cache entry.  ^The szExtra parameter will be\n@@ -9142,1 +9213,1 @@\n-** does not have to do anything special based with the value of bPurgeable;\n+** does not have to do anything special based upon the value of bPurgeable;\n@@ -9147,1 +9218,1 @@\n-** ^Hence, a cache created with bPurgeable false will\n+** ^Hence, a cache created with bPurgeable set to false will\n@@ -9152,1 +9223,1 @@\n-** suggested maximum cache-size (number of pages stored by) the cache\n+** suggested maximum cache-size (number of pages stored) for the cache\n@@ -9179,1 +9250,1 @@\n-** parameter to help it determined what action to take:\n+** parameter to help it determine what action to take:\n@@ -9184,1 +9255,1 @@\n-** <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.\n+** <tr><td> 1 <td> Allocate a new page if it is easy and convenient to do so.\n@@ -9201,1 +9272,1 @@\n-** zero, then the page may be discarded or retained at the discretion of\n+** zero, then the page may be discarded or retained at the discretion of the\n@@ -9219,1 +9290,1 @@\n-** of these pages are pinned, they are implicitly unpinned, meaning that\n+** of these pages are pinned, they become implicitly unpinned, meaning that\n@@ -9399,1 +9470,1 @@\n-** database is modified by the using the same database connection as is used\n+** database is modified by using the same database connection as is used\n@@ -9416,1 +9487,1 @@\n-** sqlite3_backup_step() errors occurred, regardless or whether or not\n+** sqlite3_backup_step() errors occurred, regardless of whether or not\n@@ -9518,1 +9589,1 @@\n-** when the blocking connections current transaction is concluded. ^The\n+** when the blocking connection's current transaction is concluded. ^The\n@@ -9538,1 +9609,1 @@\n-** unlock-notify callback is canceled. ^The blocked connections\n+** unlock-notify callback is canceled. ^The blocked connection's\n@@ -9936,1 +10007,1 @@\n-** specified as part of the users SQL statement, regardless of the actual\n+** specified as part of the user's SQL statement, regardless of the actual\n@@ -9970,1 +10041,1 @@\n-** the [xConnect] or [xCreate] methods of a [virtual table] implementation\n+** [xConnect] or [xCreate] methods of a [virtual table] implementation\n@@ -10138,1 +10209,1 @@\n-** values are same value for sorting purposes, two NULL values are considered\n+** values are the same value for sorting purposes, two NULL values are considered\n@@ -10148,1 +10219,1 @@\n-** the \"orderByConsumed\" flag is unset, the query planner will add extra\n+** \"orderByConsumed\" flag is unset, the query planner will add extra\n@@ -10245,1 +10316,1 @@\n-** processing use the [sqlite3_vtab_in()] interface in the\n+** processing using the [sqlite3_vtab_in()] interface in the\n@@ -10300,1 +10371,1 @@\n-** can return an result code other than SQLITE_OK or SQLITE_NOTFOUND if\n+** can return a result code other than SQLITE_OK or SQLITE_NOTFOUND if\n@@ -10328,2 +10399,2 @@\n-** inform a [virtual table] implementation what the [ON CONFLICT] mode\n-** is for the SQL statement being evaluated.\n+** inform a [virtual table] implementation of the [ON CONFLICT] mode\n+** for the SQL statement being evaluated.\n@@ -10369,1 +10440,1 @@\n-** iteration of the X-th loop.  If the query planner's estimates was accurate,\n+** iteration of the X-th loop.  If the query planner's estimate was accurate,\n@@ -10372,1 +10443,1 @@\n-** be the NLOOP value for the current loop.\n+** be the NLOOP value for the current loop.<\/dd>\n@@ -10377,1 +10448,1 @@\n-** used for the X-th loop.\n+** used for the X-th loop.<\/dd>\n@@ -10382,1 +10453,1 @@\n-** description for the X-th loop.\n+** description for the X-th loop.<\/dd>\n@@ -10388,1 +10459,1 @@\n-** column of an [EXPLAIN QUERY PLAN] query.\n+** column of an [EXPLAIN QUERY PLAN] query.<\/dd>\n@@ -10392,1 +10463,1 @@\n-** the id of the parent of the current query element, if applicable, or\n+** id of the parent of the current query element, if applicable, or\n@@ -10394,1 +10465,1 @@\n-** returned in the second column of an [EXPLAIN QUERY PLAN] query.\n+** returned in the second column of an [EXPLAIN QUERY PLAN] query.<\/dd>\n@@ -10401,1 +10472,1 @@\n-** set to -1.\n+** set to -1.<\/dd>\n@@ -10442,2 +10513,2 @@\n-** for. Query elements are numbered starting from zero. A value of -1 may be\n-** to query for statistics regarding the entire query. ^If idx is out of range\n+** for. Query elements are numbered starting from zero. A value of -1 may\n+** retrieve statistics for the entire query. ^If idx is out of range\n@@ -10486,1 +10557,1 @@\n-** [sqlite3_db_cacheflush(D)] interface invoked, any dirty\n+** [sqlite3_db_cacheflush(D)] interface is invoked, any dirty\n@@ -10600,2 +10671,2 @@\n-** the pre-update hook is invoked with SQLITE_DELETE. This is because the\n-** in this case the new values are not available. In this case, when a\n+** the pre-update hook is invoked with SQLITE_DELETE, because\n+** the new values are not yet available. In this case, when a\n@@ -10854,1 +10925,1 @@\n-** to disk if that database where backed up to disk.\n+** to disk if that database were backed up to disk.\n@@ -10863,1 +10934,1 @@\n-** is currently using for that database, or NULL if the no such contiguous\n+** is currently using for that database, or NULL if no such contiguous\n@@ -10934,1 +11005,1 @@\n-** It is not possible to deserialized into the TEMP database.  If the\n+** It is not possible to deserialize into the TEMP database.  If the\n@@ -10956,1 +11027,1 @@\n-  sqlite3_int64 szDb,     \/* Number bytes in the deserialization *\/\n+  sqlite3_int64 szDb,     \/* Number of bytes in the deserialization *\/\n@@ -10964,1 +11035,1 @@\n-** The following are allowed values for 6th argument (the F argument) to\n+** The following are allowed values for the 6th argument (the F argument) to\n@@ -11489,3 +11560,4 @@\n-** Or, if one field of a row is updated while a session is disabled, and\n-** another field of the same row is updated while the session is enabled, the\n-** resulting changeset will contain an UPDATE change that updates both fields.\n+** Or, if one field of a row is updated while a session is enabled, and\n+** then another field of the same row is updated while the session is disabled,\n+** the resulting changeset will contain an UPDATE change that updates both\n+** fields.\n@@ -11563,2 +11635,3 @@\n-** It an error if database zFrom does not exist or does not contain the\n-** required compatible table.\n+** Unless the call to this function is a no-op as described above, it is an\n+** error if database zFrom does not exist or does not contain the required\n+** compatible table.\n@@ -11699,1 +11772,1 @@\n-** <dt>SQLITE_CHANGESETAPPLY_INVERT <dd>\n+** <dt>SQLITE_CHANGESETSTART_INVERT <dd>\n@@ -12014,13 +12087,0 @@\n-\n-\/*\n-** CAPI3REF: Upgrade the Schema of a Changeset\/Patchset\n-*\/\n-SQLITE_API int sqlite3changeset_upgrade(\n-  sqlite3 *db,\n-  const char *zDb,\n-  int nIn, const void *pIn,       \/* Input changeset *\/\n-  int *pnOut, void **ppOut        \/* OUT: Inverse of input *\/\n-);\n-\n-\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/sqlite3.h","additions":188,"deletions":128,"binary":false,"changes":316,"status":"modified"},{"patch":"@@ -369,0 +369,2 @@\n+  \/* Version 3.50.0 and later *\/\n+  int (*setlk_timeout)(sqlite3*,int,int);\n@@ -702,0 +704,2 @@\n+\/* Version 3.50.0 and later *\/\n+#define sqlite3_setlk_timeout          sqlite3_api->setlk_timeout\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/sqlite3ext.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}