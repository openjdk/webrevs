{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -959,5 +959,0 @@\n-        \/\/ Some implementations (like GTK) can fire synthesized events when they receive a mouse button\n-        \/\/ event on the resize border. These events, even though happening on non-client regions, must\n-        \/\/ not be processed by the non-client event handler. For example, if a mouse click happens on\n-        \/\/ the resize border that straddles the window close button, we don't want the close button to\n-        \/\/ act on this click, because we just started a resize-drag operation.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/View.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1468,6 +1468,3 @@\n-            \/\/ Send a synthetic PRESS + RELEASE to FX. This allows FX to do things that need to be done\n-            \/\/ prior to resizing the window, like closing a popup menu. We do this because we won't be\n-            \/\/ sending events to FX once the resize operation has started.\n-            WindowContextBase::process_mouse_button(event, true);\n-            event->type = GDK_BUTTON_RELEASE;\n-            WindowContextBase::process_mouse_button(event, true);\n+            \/\/ We send FocusUngrabEvent to FX before we start the resize-drag operation. This allows FX\n+            \/\/ to do things that need to be done prior to resizing the window, like closing a popup menu.\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusUngrab);\n@@ -1483,4 +1480,1 @@\n-            \/\/ Send a synthetic PRESS + RELEASE to FX.\n-            WindowContextBase::process_mouse_button(event, true);\n-            event->type = GDK_BUTTON_RELEASE;\n-            WindowContextBase::process_mouse_button(event, true);\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusUngrab);\n@@ -1499,0 +1493,24 @@\n+void WindowContextTop::process_mouse_cross(GdkEventCrossing* event) {\n+    \/\/ Delegate to the base implementation for non-EXTENDED windows.\n+    if (frame_type != EXTENDED) {\n+        WindowContextBase::process_mouse_cross(event);\n+        return;\n+    }\n+\n+    \/\/ We only send MouseEvent.EXIT if we didn't already send it when the cursor was moved\n+    \/\/ from the client area to the resize border. This is indicated by is_mouse_entered\n+    \/\/ being false at this point.\n+    if (is_mouse_entered && event->type != GDK_ENTER_NOTIFY) {\n+        is_mouse_entered = false;\n+        mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+            com_sun_glass_events_MouseEvent_EXIT,\n+            com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+            (jint) event->x, (jint) event->y,\n+            (jint) event->x_root, (jint) event->y_root,\n+            gdk_modifier_mask_to_glass(event->state),\n+            JNI_FALSE,\n+            JNI_FALSE);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n+\n@@ -1513,0 +1531,16 @@\n+        \/\/ If is_mouse_entered is false at this point, the cursor was on the resize border just a moment\n+        \/\/ ago (which doesn't count as a client area, even though it is on the window). Since the cursor\n+        \/\/ has now entered the client area, we need to send MouseEvent.ENTER to FX.\n+        if (!is_mouse_entered) {\n+            is_mouse_entered = true;\n+            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+                com_sun_glass_events_MouseEvent_ENTER,\n+                com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+                (jint) event->x, (jint) event->y,\n+                (jint) event->x_root, (jint) event->y_root,\n+                gdk_modifier_mask_to_glass(event->state),\n+                JNI_FALSE,\n+                JNI_FALSE);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+\n@@ -1556,0 +1590,16 @@\n+        return;\n+    }\n+\n+    \/\/ If the cursor has moved to a resize border, we need to send MouseEvent.EXIT to FX,\n+    \/\/ since from the perspective of FX, resize borders are not a part of client area.\n+    if (is_mouse_entered && jview) {\n+        is_mouse_entered = false;\n+        mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+            com_sun_glass_events_MouseEvent_EXIT,\n+            com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+            (jint) event->x, (jint) event->y,\n+            (jint) event->x_root, (jint) event->y_root,\n+            gdk_modifier_mask_to_glass(event->state),\n+            JNI_FALSE,\n+            JNI_FALSE);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":60,"deletions":10,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -309,0 +309,1 @@\n+    void process_mouse_cross(GdkEventCrossing*);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}