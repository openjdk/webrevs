{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,14 @@\n+    \/**\n+     * Resets this {@code PickResultChooser} instance so that it can be reused.\n+     *\/\n+    public void reset() {\n+        distance = Double.POSITIVE_INFINITY;\n+        node = null;\n+        face = -1;\n+        point = null;\n+        normal = null;\n+        texCoord = null;\n+        empty = true;\n+        closed = false;\n+    }\n+\n@@ -178,3 +192,2 @@\n-    private boolean processOffer(Node node, Node depthTestNode, double distance,\n-            Point3D point, int face, Point3D normal, Point2D texCoord) {\n-\n+    protected boolean processOffer(Node node, Node depthTestNode, double distance,\n+                                   Point3D point, int face, Point3D normal, Point2D texCoord) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/input\/PickResultChooser.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3062,0 +3062,44 @@\n+        private final PickRay headerAreaPickRay = new PickRay();\n+\n+        \/**\n+         * A pick result chooser for header area hit testing that ignores nodes that\n+         * are effectively {@link HeaderDragType#TRANSPARENT}.\n+         *\/\n+        private final PickResultChooser headerAreaPickResultChooser = new PickResultChooser() {\n+\n+            @Override\n+            protected boolean processOffer(Node node, Node depthTestNode, double distance, Point3D point, int face,\n+                                           Point3D normal, Point2D texCoord) {\n+                \/\/ If the offered node is draggable, don't decline.\n+                HeaderDragType dragType = HeaderBar.getDragType(node);\n+                if (node instanceof HeaderBar\n+                        || dragType == HeaderDragType.DRAGGABLE\n+                        || dragType == HeaderDragType.DRAGGABLE_SUBTREE) {\n+                    return super.processOffer(node, depthTestNode, distance, point, face, normal, texCoord);\n+                }\n+\n+                \/\/ If the offered node is transparent, always decline.\n+                if (dragType == HeaderDragType.TRANSPARENT || dragType == HeaderDragType.TRANSPARENT_SUBTREE) {\n+                    return false;\n+                }\n+\n+                \/\/ Walk up the scene graph and only decline if we're in a transparent subtree.\n+                for (Node parent = node.getParent(); parent != null; parent = parent.getParent()) {\n+                    if (parent instanceof HeaderBar) {\n+                        break;\n+                    }\n+\n+                    HeaderDragType parentDragType = HeaderBar.getDragType(parent);\n+                    if (parentDragType == HeaderDragType.NONE || parentDragType == HeaderDragType.DRAGGABLE_SUBTREE) {\n+                        break;\n+                    }\n+\n+                    if (parentDragType == HeaderDragType.TRANSPARENT_SUBTREE) {\n+                        return false;\n+                    }\n+                }\n+\n+                return super.processOffer(node, depthTestNode, distance, point, face, normal, texCoord);\n+            }\n+        };\n+\n@@ -3064,1 +3108,5 @@\n-            PickResult result = pick(x, y);\n+            getEffectiveCamera().computePickRay(x, y, headerAreaPickRay);\n+            headerAreaPickRay.getDirectionNoClone().normalize();\n+            getRoot().pickNode(headerAreaPickRay, headerAreaPickResultChooser);\n+            PickResult result = headerAreaPickResultChooser.toPickResult();\n+            headerAreaPickResultChooser.reset();\n@@ -3087,1 +3135,2 @@\n-                        && type != HeaderDragType.DRAGGABLE) {\n+                        && type != HeaderDragType.DRAGGABLE\n+                        && type != HeaderDragType.TRANSPARENT) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -196,1 +196,3 @@\n-        dragTypeProperty(child).set(value);\n+        if (getDragType(child) != value) {\n+            dragTypeProperty(child).set(value);\n+        }\n@@ -205,0 +207,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -206,1 +209,7 @@\n-        return dragTypeProperty(child).get();\n+        if (!child.hasProperties()) {\n+            return null;\n+        }\n+\n+        return child.getProperties().get(HeaderDragType.class) instanceof ObjectProperty<?> property\n+            ? ((ObjectProperty<HeaderDragType>)property).get()\n+            : null;\n@@ -236,1 +245,3 @@\n-        buttonTypeProperty(child).set(value);\n+        if (getButtonType(child) != value) {\n+            buttonTypeProperty(child).set(value);\n+        }\n@@ -245,0 +256,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -246,1 +258,7 @@\n-        return buttonTypeProperty(child).get();\n+        if (!child.hasProperties()) {\n+            return null;\n+        }\n+\n+        return child.getProperties().get(HeaderButtonType.class) instanceof ObjectProperty<?> property\n+            ? ((ObjectProperty<HeaderButtonType>)property).get()\n+            : null;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HeaderBar.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-     * The node is not a draggable part of the {@code HeaderBar}.\n+     * The node is not a draggable part of the {@code HeaderBar}, and not transparent in regard to\n+     * draggable-area hit testing.\n@@ -43,2 +44,2 @@\n-     * If the node inherits {@link #DRAGGABLE_SUBTREE} from its parent, the inheritance stops and\n-     * descendants of the node will not inherit {@code DRAGGABLE_SUBTREE}.\n+     * If the node inherits {@link #DRAGGABLE_SUBTREE} or {@link #TRANSPARENT_SUBTREE} from its parent,\n+     * the inheritance stops and descendants of the node will not inherit either drag type.\n@@ -51,2 +52,6 @@\n-     * This drag type does not apply to descendants of the node. However, it does not stop an inherited\n-     * {@link #DRAGGABLE_SUBTREE} drag type from being inherited by descendants of the node.\n+     * This drag type is only relevant for nodes that are descendants of the header bar. When set on a node,\n+     * the node participates in draggable-area hit testing. If the node extends beyond the header bar, the\n+     * effective draggable area is extended accordingly.\n+     * <p>\n+     * This drag type does not apply to descendants of the node on which it is set. However, it does not stop\n+     * an inherited {@link #DRAGGABLE_SUBTREE} drag type from being inherited by descendants of the node.\n@@ -59,0 +64,41 @@\n+     * This drag type is only relevant for nodes that are descendants of the header bar. When set on a node,\n+     * the node and its descendants participate in draggable-area hit testing. If the node or its descendants\n+     * extend beyond the header bar, the effective draggable area is extended accordingly.\n+     * <p>\n+     * This drag type is inherited by descendants of the node until a descendant specifies {@link #NONE}.\n+     *\/\n+    DRAGGABLE_SUBTREE,\n+\n+    \/**\n+     * The node is transparent in regard to draggable-area hit testing.\n+     * <p>\n+     * In contrast to {@link #DRAGGABLE}, which positively identifies a node as a draggable part of the\n+     * {@code HeaderBar}, this option excludes a node from draggable-area hit testing: the header bar\n+     * behaves as if the node was not present and continues hit testing unimpeded.\n+     * <p>\n+     * This drag type can be used not only on descendants of the header bar, but also on other nodes that\n+     * may overlap it (for example, a sibling shown on top of the header bar). In that case, the overlapping\n+     * node behaves as if it were draggable, but only where it overlaps a draggable area of the header bar;\n+     * it does not create any additional draggable area.\n+     * <p>\n+     * This drag type does not apply to descendants of the node on which it is set. However, it does\n+     * not stop an inherited {@link #TRANSPARENT_SUBTREE} drag type from being inherited by descendants\n+     * of the node.\n+     *\n+     * @since 26\n+     *\/\n+    TRANSPARENT,\n+\n+    \/**\n+     * The node and its descendants are transparent in regard to draggable-area hit testing.\n+     * <p>\n+     * In contrast to {@link #DRAGGABLE_SUBTREE}, which positively identifies a node and its descendants\n+     * as a draggable part of the {@code HeaderBar}, this option excludes a node and its descendants from\n+     * draggable-area hit testing: the header bar behaves as if the node and its descendants were not\n+     * present and continues hit testing unimpeded.\n+     * <p>\n+     * This drag type can be used not only on descendants of the header bar, but also on other nodes that\n+     * may overlap it (for example, a sibling shown on top of the header bar). In that case, the overlapping\n+     * node and its descendants behave as if they were draggable, but only where they overlap a draggable\n+     * area of the header bar; they do not create any additional draggable area.\n+     * <p>\n@@ -60,0 +106,2 @@\n+     *\n+     * @since 26\n@@ -61,1 +109,1 @@\n-    DRAGGABLE_SUBTREE\n+    TRANSPARENT_SUBTREE\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HeaderDragType.java","additions":54,"deletions":6,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -524,1 +524,0 @@\n-                resize(250, 100);\n@@ -540,4 +539,3 @@\n-        @Test\n-         void pickDraggableNode() {\n-            var headerBar = new TestHeaderBar();\n-            HeaderBar.setDragType(headerBar.box1, HeaderDragType.DRAGGABLE);\n+        Stage stage;\n+        Scene scene;\n+        TestHeaderBar headerBar;\n@@ -545,2 +543,6 @@\n-            var scene = new Scene(headerBar, 250, 200);\n-            var stage = new Stage();\n+        @BeforeEach\n+        void setup() {\n+            headerBar = new TestHeaderBar();\n+            headerBar.setManaged(false);\n+            scene = new Scene(headerBar, 250, 200);\n+            stage = new Stage();\n@@ -549,0 +551,11 @@\n+            headerBar.resize(250, 100);\n+        }\n+\n+        @AfterEach\n+        void teardown() {\n+            stage.close();\n+        }\n+\n+        @Test\n+        void pickDraggableNode() {\n+            HeaderBar.setDragType(headerBar.box1, HeaderDragType.DRAGGABLE);\n@@ -551,1 +564,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 10, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 10, 10);\n@@ -554,1 +567,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 60, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 60, 10);\n@@ -557,3 +570,3 @@\n-            assertNull(pickHeaderArea(scene, 110, 10));\n-            assertNull(pickHeaderArea(scene, 160, 10));\n-            assertNull(pickHeaderArea(scene, 210, 10));\n+            assertHeaderArea(null, 110, 10);\n+            assertHeaderArea(null, 160, 10);\n+            assertHeaderArea(null, 210, 10);\n@@ -564,1 +577,0 @@\n-            var headerBar = new TestHeaderBar();\n@@ -567,5 +579,0 @@\n-            var scene = new Scene(headerBar, 250, 200);\n-            var stage = new Stage();\n-            stage.setScene(scene);\n-            stage.show();\n-\n@@ -573,1 +580,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 10, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 10, 10);\n@@ -576,1 +583,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 60, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 60, 10);\n@@ -579,3 +586,3 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 110, 10));\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 160, 10));\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 210, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 110, 10);\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 160, 10);\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 210, 10);\n@@ -586,1 +593,0 @@\n-            var headerBar = new TestHeaderBar();\n@@ -590,5 +596,0 @@\n-            var scene = new Scene(headerBar, 250, 200);\n-            var stage = new Stage();\n-            stage.setScene(scene);\n-            stage.show();\n-\n@@ -596,1 +597,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 10, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 10, 10);\n@@ -599,1 +600,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 60, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 60, 10);\n@@ -602,1 +603,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 110, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 110, 10);\n@@ -605,2 +606,2 @@\n-            assertNull(pickHeaderArea(scene, 160, 10));\n-            assertNull(pickHeaderArea(scene, 210, 10));\n+            assertHeaderArea(null, 160, 10);\n+            assertHeaderArea(null, 210, 10);\n@@ -611,1 +612,0 @@\n-            var headerBar = new TestHeaderBar();\n@@ -615,5 +615,0 @@\n-            var scene = new Scene(headerBar, 250, 200);\n-            var stage = new Stage();\n-            stage.setScene(scene);\n-            stage.show();\n-\n@@ -621,1 +616,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 10, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 10, 10);\n@@ -624,1 +619,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 60, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 60, 10);\n@@ -627,1 +622,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 110, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 110, 10);\n@@ -630,2 +625,95 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 160, 10));\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 210, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 160, 10);\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 210, 10);\n+        }\n+\n+        @Test\n+        void transparentSiblingIsOnlyDraggableOnExistingDraggableArea() {\n+            var sibling = new Rectangle(100, 150);\n+            sibling.setManaged(false);\n+            HeaderBar.setDragType(sibling, HeaderDragType.TRANSPARENT);\n+\n+            var root = new StackPane(headerBar, sibling);\n+            root.setManaged(false);\n+            scene.setRoot(root);\n+\n+            \/\/ 1. Overlapping transparent sibling is draggable where it overlaps the HeaderBar\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 25, 90);\n+\n+            \/\/ 2. It is not draggable where it overlaps a non-draggable box on the HeaderBar\n+            assertHeaderArea(null, 75, 90);\n+\n+            \/\/ 3. It is also not draggable outside the bounds of the HeaderBar\n+            assertHeaderArea(null, 25, 110);\n+        }\n+\n+        @Test\n+        void childOfSiblingInheritsTransparentDragType() {\n+            var sibling = new StackPane(new Rectangle(100, 150));\n+            sibling.setManaged(false);\n+            sibling.resize(100, 150);\n+\n+            scene.setRoot(new StackPane(headerBar, sibling));\n+\n+            \/\/ 1. Even though the sibling is TRANSPARENT, its child is not.\n+            HeaderBar.setDragType(sibling, HeaderDragType.TRANSPARENT);\n+            assertHeaderArea(null, 25, 90);\n+\n+            \/\/ 2. With TRANSPARENT_SUBTREE, the child inherits the transparent flag.\n+            HeaderBar.setDragType(sibling, HeaderDragType.TRANSPARENT_SUBTREE);\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 25, 90);\n+\n+            \/\/ 3. Sibling is not draggable where it overlaps a non-draggable box on the HeaderBar\n+            assertHeaderArea(null, 75, 90);\n+\n+            \/\/ 4. It is also not draggable outside the bounds of the HeaderBar\n+            assertHeaderArea(null, 25, 110);\n+        }\n+\n+        @Test\n+        void draggableNodeInTransparentSubtree() {\n+            var rect = new Rectangle(50, 50);\n+            var area = new StackPane(rect);\n+            area.setManaged(false);\n+            area.resizeRelocate(50, 0, 50, 100);\n+\n+            headerBar.setLeft(area);\n+            HeaderBar.setDragType(area, HeaderDragType.TRANSPARENT_SUBTREE);\n+            HeaderBar.setDragType(rect, HeaderDragType.DRAGGABLE);\n+\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 75, 25);\n+        }\n+\n+        @Test\n+        void draggableSubtreeInTransparentSubtree() {\n+            var rect = new Rectangle(50, 50);\n+            var area2 = new StackPane(rect);\n+            area2.setManaged(false);\n+            area2.resizeRelocate(50, 0, 50, 100);\n+\n+            var area1 = new StackPane(area2);\n+            area1.setManaged(false);\n+            area2.resizeRelocate(50, 0, 50, 100);\n+\n+            headerBar.setLeft(area1);\n+            HeaderBar.setDragType(area1, HeaderDragType.TRANSPARENT_SUBTREE);\n+            HeaderBar.setDragType(area2, HeaderDragType.DRAGGABLE_SUBTREE);\n+\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 75, 25);\n+        }\n+\n+        @Test\n+        void transparentSubtreeInDraggableSubtree() {\n+            var rect = new Rectangle(50, 50);\n+            var area2 = new StackPane(rect);\n+            area2.setManaged(false);\n+            area2.resizeRelocate(50, 0, 50, 100);\n+\n+            var area1 = new StackPane(area2);\n+            area1.setManaged(false);\n+            area2.resizeRelocate(50, 0, 50, 100);\n+\n+            headerBar.setLeft(area1);\n+            HeaderBar.setDragType(area1, HeaderDragType.DRAGGABLE_SUBTREE);\n+            HeaderBar.setDragType(area2, HeaderDragType.TRANSPARENT_SUBTREE);\n+\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 75, 25);\n@@ -634,1 +722,1 @@\n-        private static HeaderAreaType pickHeaderArea(Scene scene, double x, double y) {\n+        private void assertHeaderArea(HeaderAreaType expected, double x, double y) {\n@@ -637,1 +725,1 @@\n-            return listener.pickHeaderArea(x, y);\n+            assertEquals(expected, listener.pickHeaderArea(x, y));\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/HeaderBarTest.java","additions":135,"deletions":47,"binary":false,"changes":182,"status":"modified"}]}