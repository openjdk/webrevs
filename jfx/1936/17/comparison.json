{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -959,5 +959,0 @@\n-        \/\/ Some implementations (like GTK) can fire synthesized events when they receive a mouse button\n-        \/\/ event on the resize border. These events, even though happening on non-client regions, must\n-        \/\/ not be processed by the non-client event handler. For example, if a mouse click happens on\n-        \/\/ the resize border that straddles the window close button, we don't want the close button to\n-        \/\/ act on this click, because we just started a resize-drag operation.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/View.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-import com.sun.javafx.tk.HeaderAreaType;\n+import java.lang.annotation.Native;\n@@ -264,0 +264,4 @@\n+    @Native private static final int HT_UNSPECIFIED = 0;\n+    @Native private static final int HT_CAPTION = 1;\n+    @Native private static final int HT_CLIENT = 2;\n+\n@@ -265,1 +269,1 @@\n-     * Returns whether the window is draggable at the specified coordinate.\n+     * Classifies the window region at the specified physical coordinate.\n@@ -273,1 +277,1 @@\n-    private boolean dragAreaHitTest(int x, int y) {\n+    private int nonClientHitTest(int x, int y) {\n@@ -276,1 +280,1 @@\n-            return false;\n+            return HT_CLIENT;\n@@ -283,1 +287,1 @@\n-            return false;\n+            return HT_CLIENT;\n@@ -288,1 +292,1 @@\n-            return false;\n+            return HT_CLIENT;\n@@ -291,1 +295,5 @@\n-        return eventHandler.pickHeaderArea(wx, wy) == HeaderAreaType.DRAGBAR;\n+        return switch (eventHandler.pickHeaderArea(wx, wy)) {\n+            case UNSPECIFIED -> HT_UNSPECIFIED;\n+            case DRAGBAR -> HT_CAPTION;\n+            case null, default -> HT_CLIENT;\n+        };\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkWindow.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.glass.events.MouseEvent;\n@@ -131,2 +132,1 @@\n-        if (getWindow() instanceof WinWindow window &&\n-                window.headerButtonOverlayProperty().get() instanceof HeaderButtonOverlay overlay) {\n+        if (getWindow() instanceof WinWindow window) {\n@@ -137,1 +137,2 @@\n-            if (overlay.handleMouseEvent(type, button, wx, wy)) {\n+            if (window.headerButtonOverlayProperty().get() instanceof HeaderButtonOverlay overlay\n+                    && overlay.handleMouseEvent(type, button, wx, wy)) {\n@@ -140,0 +141,8 @@\n+\n+            if (window.isResizable()\n+                    && clickCount == 2\n+                    && type == MouseEvent.DOWN\n+                    && getEventHandler() instanceof View.EventHandler eventHandler\n+                    && eventHandler.pickHeaderArea(wx, wy) == HeaderAreaType.DRAGBAR) {\n+                window.maximize(!window.isMaximized());\n+            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinView.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -422,1 +422,2 @@\n-            CLIENT(1), CAPTION(2), MINBUTTON(8), MAXBUTTON(9), CLOSE(20);\n+            CLIENT(1), CAPTION(2), MINBUTTON(8), MAXBUTTON(9), CLOSE(20),\n+            UNSPECIFIED('H' << 24 | 'T' << 16 | 'U' << 8 | 'N'); \/\/ see GlassWindow.cpp:HandleNCHitTestEvent\n@@ -444,1 +445,1 @@\n-        \/\/ Otherwise, test if the cursor is over a draggable area and return HTCAPTION.\n+        \/\/ Otherwise, pick the header area under the cursor and return the appropriate hit-testing constant.\n@@ -447,0 +448,1 @@\n+            case UNSPECIFIED -> HT.UNSPECIFIED.value;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinWindow.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,14 @@\n+    \/**\n+     * Resets this {@code PickResultChooser} instance so that it can be reused.\n+     *\/\n+    public void reset() {\n+        distance = Double.POSITIVE_INFINITY;\n+        node = null;\n+        face = -1;\n+        point = null;\n+        normal = null;\n+        texCoord = null;\n+        empty = true;\n+        closed = false;\n+    }\n+\n@@ -178,3 +192,2 @@\n-    private boolean processOffer(Node node, Node depthTestNode, double distance,\n-            Point3D point, int face, Point3D normal, Point2D texCoord) {\n-\n+    protected boolean processOffer(Node node, Node depthTestNode, double distance,\n+                                   Point3D point, int face, Point3D normal, Point2D texCoord) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/input\/PickResultChooser.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+    UNSPECIFIED,\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/HeaderAreaType.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import com.sun.javafx.css.media.MediaQueryContext;\n@@ -3062,0 +3061,44 @@\n+        private final PickRay headerAreaPickRay = new PickRay();\n+\n+        \/**\n+         * A pick result chooser for header area hit testing that ignores nodes that\n+         * are effectively {@link HeaderDragType#TRANSPARENT}.\n+         *\/\n+        private final PickResultChooser headerAreaPickResultChooser = new PickResultChooser() {\n+\n+            @Override\n+            protected boolean processOffer(Node node, Node depthTestNode, double distance, Point3D point, int face,\n+                                           Point3D normal, Point2D texCoord) {\n+                \/\/ If the offered node is draggable, don't decline.\n+                HeaderDragType dragType = HeaderBar.getDragType(node);\n+                if (node instanceof HeaderBar\n+                        || dragType == HeaderDragType.DRAGGABLE\n+                        || dragType == HeaderDragType.DRAGGABLE_SUBTREE) {\n+                    return super.processOffer(node, depthTestNode, distance, point, face, normal, texCoord);\n+                }\n+\n+                \/\/ If the offered node is transparent, always decline.\n+                if (dragType == HeaderDragType.TRANSPARENT || dragType == HeaderDragType.TRANSPARENT_SUBTREE) {\n+                    return false;\n+                }\n+\n+                \/\/ Walk up the scene graph and only decline if we're in a transparent subtree.\n+                for (Node parent = node.getParent(); parent != null; parent = parent.getParent()) {\n+                    if (parent instanceof HeaderBar) {\n+                        break;\n+                    }\n+\n+                    HeaderDragType parentDragType = HeaderBar.getDragType(parent);\n+                    if (parentDragType == HeaderDragType.NONE || parentDragType == HeaderDragType.DRAGGABLE_SUBTREE) {\n+                        break;\n+                    }\n+\n+                    if (parentDragType == HeaderDragType.TRANSPARENT_SUBTREE) {\n+                        return false;\n+                    }\n+                }\n+\n+                return super.processOffer(node, depthTestNode, distance, point, face, normal, texCoord);\n+            }\n+        };\n+\n@@ -3064,1 +3107,9 @@\n-            PickResult result = pick(x, y);\n+            getEffectiveCamera().computePickRay(x, y, headerAreaPickRay);\n+            headerAreaPickRay.getDirectionNoClone().normalize();\n+            getRoot().pickNode(headerAreaPickRay, headerAreaPickResultChooser);\n+            PickResult result = headerAreaPickResultChooser.toPickResult();\n+            headerAreaPickResultChooser.reset();\n+            if (result == null) {\n+                return null;\n+            }\n+\n@@ -3074,1 +3125,3 @@\n-                            : null;\n+                            : dragType != HeaderDragType.NONE\n+                                ? HeaderAreaType.UNSPECIFIED\n+                                : null;\n@@ -3087,1 +3140,2 @@\n-                        && type != HeaderDragType.DRAGGABLE) {\n+                        && type != HeaderDragType.DRAGGABLE\n+                        && type != HeaderDragType.TRANSPARENT) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":59,"deletions":5,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n@@ -35,0 +38,1 @@\n+import javafx.beans.property.DoubleProperty;\n@@ -41,1 +45,2 @@\n-import javafx.beans.value.ObservableValue;\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n@@ -64,2 +69,2 @@\n- * can specify draggable content nodes of the {@code HeaderBar} with the {@link #setDragType(Node, HeaderDragType)}\n- * method.\n+ * can specify draggable content nodes of the {@code HeaderBar} with the {@link #dragTypeProperty(Node) dragType}\n+ * property.\n@@ -68,1 +73,1 @@\n- * {@link #leadingProperty() leading}, {@link #centerProperty() center}, and {@link #trailingProperty() trailing}.\n+ * {@link #leftProperty() left}, {@link #centerProperty() center}, and {@link #rightProperty() right}.\n@@ -75,1 +80,1 @@\n- * {@link #leftSystemInsetProperty() leftSystemInset} and {@link #rightSystemInsetProperty() rightSystemInset},\n+ * {@link #leftSystemInsetProperty(Stage) leftSystemInset} and {@link #rightSystemInsetProperty(Stage) rightSystemInset},\n@@ -83,2 +88,2 @@\n- * two header bars. In this case, the {@link #leadingSystemPaddingProperty() leadingSystemPadding} and\n- * {@link #trailingSystemPaddingProperty() trailingSystemPadding} properties can be used to remove the padding\n+ * two header bars. In this case, the {@link #leftSystemPaddingProperty() leftSystemPadding} and\n+ * {@link #rightSystemPaddingProperty() rightSystemPadding} properties can be used to remove the padding\n@@ -88,4 +93,10 @@\n- * Applications can specify the preferred height for system-provided header buttons by setting the static\n- * {@link #setPrefButtonHeight(Stage, double)} property on the {@code Stage} associated with the header bar.\n- * This can be used to achieve a more cohesive visual appearance by having the system-provided header buttons\n- * match the height of the client-area header bar.\n+ * Applications can specify the preferred height for system-provided header buttons by setting the\n+ * {@link #prefButtonHeightProperty(Stage) prefButtonHeight} property on the {@code Stage} associated with\n+ * the header bar. This can be used to achieve a more cohesive visual appearance by having the system-provided\n+ * header buttons match the height of the client-area header bar.\n+ *\n+ * <h2>Color scheme<\/h2>\n+ * The color scheme of the default header buttons is automatically adjusted to remain easily recognizable\n+ * by inspecting the {@link Scene#fillProperty() Scene.fill} property to gauge the brightness of the user\n+ * interface. Applications should set the scene fill to a color that matches the user interface of the header\n+ * bar area, even if the scene fill is not visible because it is obscured by other controls.\n@@ -95,3 +106,4 @@\n- * buttons by setting {@link #setPrefButtonHeight(Stage, double)} to zero and place custom header buttons in\n- * the JavaFX scene graph instead. Any JavaFX control can be used as a custom header button by setting its\n- * semantic type with the {@link #setButtonType(Node, HeaderButtonType)} method.\n+ * buttons by setting the {@link #prefButtonHeightProperty(Stage) prefButtonHeight} property on the {@code Stage}\n+ * associated with the header bar to zero and place custom header buttons in the JavaFX scene graph instead.\n+ * Any JavaFX control can be used as a custom header button by specifying its semantic type with the\n+ * {@link #buttonTypeProperty(Node) buttonType} property.\n@@ -109,1 +121,1 @@\n- * The {@code leading} and {@code trailing} children will be resized to their preferred widths and extend the\n+ * The {@code left} and {@code right} children will be resized to their preferred widths and extend the\n@@ -174,2 +186,0 @@\n-    private static final String DRAG_TYPE = \"headerbar-drag-type\";\n-    private static final String BUTTON_TYPE = \"headerbar-button-type\";\n@@ -180,4 +190,1 @@\n-     * Specifies the {@code HeaderDragType} of the child, indicating whether it is a draggable\n-     * part of the {@code HeaderBar}.\n-     * <p>\n-     * Setting the value to {@code null} will remove the flag.\n+     * Sets the value of the {@link #dragTypeProperty(Node) dragType} property for the specified child.\n@@ -189,1 +196,3 @@\n-        Pane.setConstraint(child, DRAG_TYPE, value);\n+        if (getDragType(child) != value) {\n+            dragTypeProperty(child).set(value);\n+        }\n@@ -193,1 +202,1 @@\n-     * Returns the {@code HeaderDragType} of the specified child.\n+     * Gets the value of the {@link #dragTypeProperty(Node) dragType} property of the specified child.\n@@ -198,0 +207,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -199,1 +209,7 @@\n-        return (HeaderDragType)Pane.getConstraint(child, DRAG_TYPE);\n+        if (!child.hasProperties()) {\n+            return null;\n+        }\n+\n+        return child.getProperties().get(HeaderDragType.class) instanceof ObjectProperty<?> property\n+            ? ((ObjectProperty<HeaderDragType>)property).get()\n+            : null;\n@@ -203,5 +219,2 @@\n-     * Specifies the {@code HeaderButtonType} of the child, indicating its semantic use in the header bar.\n-     * <p>\n-     * This property can be set on any {@link Node}. Specifying a header button type also provides the behavior\n-     * associated with the button type. If the default behavior is not desired, applications can register an\n-     * event filter on the child node that consumes the {@link MouseEvent#MOUSE_RELEASED} event.\n+     * Specifies the {@code HeaderDragType} of the child, indicating whether it is a draggable part\n+     * of the {@code HeaderBar}. A value of {@code null} indicates that the drag type is not set.\n@@ -210,1 +223,3 @@\n-     * @param value the {@code HeaderButtonType}, or {@code null}\n+     * @return the {@code dragType} property\n+     * @defaultValue {@code null}\n+     * @since 26\n@@ -212,5 +227,4 @@\n-    public static void setButtonType(Node child, HeaderButtonType value) {\n-        Pane.setConstraint(child, BUTTON_TYPE, value);\n-\n-        if (child.getProperties().get(HeaderButtonBehavior.class) instanceof HeaderButtonBehavior behavior) {\n-            behavior.dispose();\n+    @SuppressWarnings(\"unchecked\")\n+    public static ObjectProperty<HeaderDragType> dragTypeProperty(Node child) {\n+        if (child.getProperties().get(HeaderDragType.class) instanceof ObjectProperty<?> property) {\n+            return (ObjectProperty<HeaderDragType>)property;\n@@ -219,4 +233,14 @@\n-        if (value != null) {\n-            child.getProperties().put(HeaderButtonBehavior.class, new HeaderButtonBehavior(child, value));\n-        } else {\n-            child.getProperties().remove(HeaderButtonBehavior.class);\n+        var property = new SimpleObjectProperty<HeaderDragType>(child, \"dragType\");\n+        child.getProperties().put(HeaderDragType.class, property);\n+        return property;\n+    }\n+\n+    \/**\n+     * Sets the value of the {@link #buttonTypeProperty(Node) buttonType} property for the specified child.\n+     *\n+     * @param child the child node\n+     * @param value the {@code HeaderButtonType}, or {@code null}\n+     *\/\n+    public static void setButtonType(Node child, HeaderButtonType value) {\n+        if (getButtonType(child) != value) {\n+            buttonTypeProperty(child).set(value);\n@@ -227,1 +251,1 @@\n-     * Returns the {@code HeaderButtonType} of the specified child.\n+     * Gets the value of the {@link #buttonTypeProperty(Node) buttonType} property of the specified child.\n@@ -232,0 +256,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -233,1 +258,7 @@\n-        return (HeaderButtonType)Pane.getConstraint(child, BUTTON_TYPE);\n+        if (!child.hasProperties()) {\n+            return null;\n+        }\n+\n+        return child.getProperties().get(HeaderButtonType.class) instanceof ObjectProperty<?> property\n+            ? ((ObjectProperty<HeaderButtonType>)property).get()\n+            : null;\n@@ -237,2 +268,41 @@\n-     * Sentinel value that can be used for {@link #setPrefButtonHeight(Stage, double)} to indicate that\n-     * the platform should choose the platform-specific default button height.\n+     * Specifies the {@code HeaderButtonType} of the child, indicating its semantic use in the header bar.\n+     * <p>\n+     * This property can be set on any {@link Node}. Specifying a header button type also provides the behavior\n+     * associated with the button type. If the default behavior is not desired, applications can register an\n+     * event filter on the child node that consumes the {@link MouseEvent#MOUSE_RELEASED} event.\n+     *\n+     * @param child the child node\n+     * @return the {@code buttonType} property\n+     * @defaultValue {@code null}\n+     * @since 26\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public static ObjectProperty<HeaderButtonType> buttonTypeProperty(Node child) {\n+        if (child.getProperties().get(HeaderButtonType.class) instanceof ObjectProperty<?> property) {\n+            return (ObjectProperty<HeaderButtonType>)property;\n+        }\n+\n+        var property = new SimpleObjectProperty<HeaderButtonType>(child, \"buttonType\") {\n+            HeaderButtonBehavior behavior;\n+\n+            @Override\n+            protected void invalidated() {\n+                HeaderButtonType type = get();\n+\n+                if (behavior != null) {\n+                    behavior.dispose();\n+                }\n+\n+                if (type != null) {\n+                    behavior = new HeaderButtonBehavior((Node)getBean(), type);\n+                }\n+            }\n+        };\n+\n+        child.getProperties().put(HeaderButtonType.class, property);\n+        return property;\n+    }\n+\n+    \/**\n+     * Sentinel value that can be used for the {@link #prefButtonHeightProperty(Stage) prefButtonHeight}\n+     * property to indicate that the platform should choose the platform-specific default button height.\n@@ -243,1 +313,23 @@\n-     * Specifies the preferred height of the system-provided header buttons of the specified stage.\n+     * Sets the value of the {@link #prefButtonHeightProperty(Stage) prefButtonHeight} property\n+     * for the specified {@code Stage}.\n+     *\n+     * @param stage the {@code Stage}\n+     * @param height the preferred height, or 0 to hide the system-provided header buttons\n+     *\/\n+    public static void setPrefButtonHeight(Stage stage, double height) {\n+        AttachedProperties.of(stage).prefButtonHeight.set(height);\n+    }\n+\n+    \/**\n+     * Gets the value of the {@link #prefButtonHeightProperty(Stage) prefButtonHeight} property\n+     * of the specified {@code Stage}.\n+     *\n+     * @param stage the {@code Stage}\n+     * @return the preferred height of the system-provided header buttons\n+     *\/\n+    public static double getPrefButtonHeight(Stage stage) {\n+        return AttachedProperties.of(stage).prefButtonHeight.get();\n+    }\n+\n+    \/**\n+     * Specifies the preferred height of the system-provided header buttons of the specified {@code Stage}.\n@@ -257,1 +349,3 @@\n-     * @param height the preferred height, or 0 to hide the system-provided header buttons\n+     * @return the {@code prefButtonHeight} property\n+     * @defaultValue {@code USE_DEFAULT_SIZE}\n+     * @since 26\n@@ -259,2 +353,2 @@\n-    public static void setPrefButtonHeight(Stage stage, double height) {\n-        StageHelper.setPrefHeaderButtonHeight(stage, height);\n+    public static DoubleProperty prefButtonHeightProperty(Stage stage) {\n+        return AttachedProperties.of(stage).prefButtonHeight;\n@@ -264,1 +358,3 @@\n-     * Returns the preferred height of the system-provided header buttons of the specified stage.\n+     * Describes the size of the left system-reserved inset of the specified {@code Stage}, which is an area\n+     * reserved for the iconify, maximize, and close window buttons. If there are no window buttons on the left\n+     * side of the window, the returned area is an empty {@code Dimension2D}.\n@@ -267,1 +363,2 @@\n-     * @return the preferred height of the system-provided header buttons\n+     * @return the {@code leftSystemInset} property\n+     * @since 26\n@@ -269,2 +366,67 @@\n-    public static double getPrefButtonHeight(Stage stage) {\n-        return StageHelper.getPrefHeaderButtonHeight(stage);\n+    public static ReadOnlyObjectProperty<Dimension2D> leftSystemInsetProperty(Stage stage) {\n+        return AttachedProperties.of(stage).leftSystemInset.getReadOnlyProperty();\n+    }\n+\n+    \/**\n+     * Gets the value of the {@link #leftSystemInsetProperty(Stage) leftSystemInset} property\n+     * of the specified {@code Stage}.\n+     *\n+     * @param stage the {@code Stage}\n+     * @return the size of the left system-reserved inset\n+     * @since 26\n+     *\/\n+    public static Dimension2D getLeftSystemInset(Stage stage) {\n+        return AttachedProperties.of(stage).leftSystemInset.get();\n+    }\n+\n+    \/**\n+     * Describes the size of the right system-reserved inset of the specified {@code Stage}, which is an area\n+     * reserved for the iconify, maximize, and close window buttons. If there are no window buttons on the right\n+     * side of the window, the returned area is an empty {@code Dimension2D}.\n+     *\n+     * @param stage the {@code Stage}\n+     * @return the {@code rightSystemInset} property\n+     * @since 26\n+     *\/\n+    public static ReadOnlyObjectProperty<Dimension2D> rightSystemInsetProperty(Stage stage) {\n+        return AttachedProperties.of(stage).rightSystemInset.getReadOnlyProperty();\n+    }\n+\n+    \/**\n+     * Gets the value of the {@link #rightSystemInsetProperty(Stage) rightSystemInset} property\n+     * of the specified {@code Stage}.\n+     *\n+     * @param stage the {@code Stage}\n+     * @return the size of the right system-reserved inset\n+     * @since 26\n+     *\/\n+    public static Dimension2D getRightSystemInset(Stage stage) {\n+        return AttachedProperties.of(stage).rightSystemInset.get();\n+    }\n+\n+    \/**\n+     * The system-provided minimum recommended height for the {@code HeaderBar} of the specified {@code Stage},\n+     * which usually corresponds to the height of the default header buttons. Applications can use this value\n+     * as a sensible lower limit for the height of the {@code HeaderBar}.\n+     * <p>\n+     * By default, {@code HeaderBar}.{@link #minHeightProperty() minHeight} is set to the value of\n+     * {@code minSystemHeight}, unless {@code minHeight} is explicitly set by a stylesheet or application code.\n+     *\n+     * @param stage the {@code Stage}\n+     * @return the {@code minSystemHeight} property\n+     * @since 26\n+     *\/\n+    public static ReadOnlyDoubleProperty minSystemHeightProperty(Stage stage) {\n+        return AttachedProperties.of(stage).minSystemHeight.getReadOnlyProperty();\n+    }\n+\n+    \/**\n+     * Gets the value of the {@link #minSystemHeightProperty(Stage) minSystemHeight} property\n+     * of the specified {@code Stage}.\n+     *\n+     * @param stage the {@code Stage}\n+     * @return the system-provided minimum recommended height for the {@code HeaderBar}\n+     * @since 26\n+     *\/\n+    public static double getMinSystemHeight(Stage stage) {\n+        return AttachedProperties.of(stage).minSystemHeight.get();\n@@ -317,3 +479,1 @@\n-    private Subscription subscription = Subscription.EMPTY;\n-    private HeaderButtonMetrics currentMetrics;\n-    private boolean currentFullScreen;\n+    private Subscription subscriptions = Subscription.EMPTY;\n@@ -331,1 +491,1 @@\n-        ObservableValue<Stage> stage = sceneProperty()\n+        sceneProperty()\n@@ -333,7 +493,2 @@\n-            .map(w -> w instanceof Stage s ? s : null);\n-\n-        stage.flatMap(Stage::fullScreenProperty)\n-            .orElse(false)\n-            .subscribe(this::onFullScreenChanged);\n-\n-        stage.subscribe(this::onStageChanged);\n+            .map(w -> w instanceof Stage stage ? stage : null)\n+            .subscribe(this::onStageChanged);\n@@ -345,1 +500,1 @@\n-     * @param leading the leading node, or {@code null}\n+     * @param left the left node, or {@code null}\n@@ -347,1 +502,1 @@\n-     * @param trailing the trailing node, or {@code null}\n+     * @param right the right node, or {@code null}\n@@ -349,1 +504,1 @@\n-    public HeaderBar(Node leading, Node center, Node trailing) {\n+    public HeaderBar(Node left, Node center, Node right) {\n@@ -351,1 +506,1 @@\n-        setLeading(leading);\n+        setLeft(left);\n@@ -353,77 +508,1 @@\n-        setTrailing(trailing);\n-    }\n-\n-    private void onStageChanged(Stage stage) {\n-        subscription.unsubscribe();\n-\n-        if (stage != null) {\n-            subscription = StageHelper.getHeaderButtonMetrics(stage).subscribe(this::onMetricsChanged);\n-        }\n-    }\n-\n-    private void onMetricsChanged(HeaderButtonMetrics metrics) {\n-        currentMetrics = metrics;\n-        updateInsets();\n-    }\n-\n-    private void onFullScreenChanged(boolean fullScreen) {\n-        currentFullScreen = fullScreen;\n-        updateInsets();\n-    }\n-\n-    private void updateInsets() {\n-        if (currentFullScreen || currentMetrics == null) {\n-            leftSystemInset.set(EMPTY);\n-            rightSystemInset.set(EMPTY);\n-            minSystemHeight.set(0);\n-        } else {\n-            leftSystemInset.set(currentMetrics.leftInset());\n-            rightSystemInset.set(currentMetrics.rightInset());\n-            minSystemHeight.set(currentMetrics.minHeight());\n-        }\n-    }\n-\n-    \/**\n-     * Describes the size of the left system-reserved inset, which is an area reserved for the iconify, maximize,\n-     * and close window buttons. If there are no window buttons on the left side of the window, the returned area\n-     * is an empty {@code Dimension2D}.\n-     * <p>\n-     * Note that the left system inset refers to the left side of the window, independent of layout orientation.\n-     *\/\n-    private final ReadOnlyObjectWrapper<Dimension2D> leftSystemInset =\n-        new ReadOnlyObjectWrapper<>(this, \"leftSystemInset\", EMPTY) {\n-            @Override\n-            protected void invalidated() {\n-                requestLayout();\n-            }\n-        };\n-\n-    public final ReadOnlyObjectProperty<Dimension2D> leftSystemInsetProperty() {\n-        return leftSystemInset.getReadOnlyProperty();\n-    }\n-\n-    public final Dimension2D getLeftSystemInset() {\n-        return leftSystemInset.get();\n-    }\n-\n-    \/**\n-     * Describes the size of the right system-reserved inset, which is an area reserved for the iconify, maximize,\n-     * and close window buttons. If there are no window buttons on the right side of the window, the returned area\n-     * is an empty {@code Dimension2D}.\n-     * <p>\n-     * Note that the right system inset refers to the right side of the window, independent of layout orientation.\n-     *\/\n-    private final ReadOnlyObjectWrapper<Dimension2D> rightSystemInset =\n-        new ReadOnlyObjectWrapper<>(this, \"rightSystemInset\", EMPTY) {\n-            @Override\n-            protected void invalidated() {\n-                requestLayout();\n-            }\n-        };\n-\n-    public final ReadOnlyObjectProperty<Dimension2D> rightSystemInsetProperty() {\n-        return rightSystemInset.getReadOnlyProperty();\n-    }\n-\n-    public final Dimension2D getRightSystemInset() {\n-        return rightSystemInset.get();\n+        setRight(right);\n@@ -433,34 +512,1 @@\n-     * The system-provided minimum recommended height for the {@code HeaderBar}, which usually corresponds\n-     * to the height of the default header buttons. Applications can use this value as a sensible lower limit\n-     * for the height of the {@code HeaderBar}.\n-     * <p>\n-     * By default, {@link #minHeightProperty() minHeight} is set to the value of {@code minSystemHeight},\n-     * unless {@code minHeight} is explicitly set by a stylesheet or application code.\n-     *\/\n-    private final ReadOnlyDoubleWrapper minSystemHeight =\n-        new ReadOnlyDoubleWrapper(this, \"minSystemHeight\") {\n-            @Override\n-            protected void invalidated() {\n-                double height = get();\n-                var minHeight = (StyleableDoubleProperty)minHeightProperty();\n-\n-                \/\/ Only change minHeight if it was not set by a stylesheet or application code.\n-                if (minHeight.getStyleOrigin() == null) {\n-                    minHeight.applyStyle(null, height);\n-                }\n-            }\n-        };\n-\n-    public final ReadOnlyDoubleProperty minSystemHeightProperty() {\n-        return minSystemHeight.getReadOnlyProperty();\n-    }\n-\n-    public final double getMinSystemHeight() {\n-        return minSystemHeight.get();\n-    }\n-\n-    \/**\n-     * The leading area of the {@code HeaderBar}.\n-     * <p>\n-     * The leading area corresponds to the left area in a left-to-right layout, and to the right area\n-     * in a right-to-left layout.\n+     * The left area of the {@code HeaderBar}.\n@@ -469,0 +515,1 @@\n+     * @since 26\n@@ -470,1 +517,1 @@\n-    private final ObjectProperty<Node> leading = new NodeProperty(\"leading\");\n+    private final ObjectProperty<Node> left = new NodeProperty(\"left\");\n@@ -472,2 +519,2 @@\n-    public final ObjectProperty<Node> leadingProperty() {\n-        return leading;\n+    public final ObjectProperty<Node> leftProperty() {\n+        return left;\n@@ -476,2 +523,2 @@\n-    public final Node getLeading() {\n-        return leading.get();\n+    public final Node getLeft() {\n+        return left.get();\n@@ -480,2 +527,2 @@\n-    public final void setLeading(Node value) {\n-        leading.set(value);\n+    public final void setLeft(Node value) {\n+        left.set(value);\n@@ -504,4 +551,1 @@\n-     * The trailing area of the {@code HeaderBar}.\n-     * <p>\n-     * The trailing area corresponds to the right area in a left-to-right layout, and to the left area\n-     * in a right-to-left layout.\n+     * The right area of the {@code HeaderBar}.\n@@ -510,0 +554,1 @@\n+     * @since 26\n@@ -511,1 +556,1 @@\n-    private final ObjectProperty<Node> trailing = new NodeProperty(\"trailing\");\n+    private final ObjectProperty<Node> right = new NodeProperty(\"right\");\n@@ -513,2 +558,2 @@\n-    public final ObjectProperty<Node> trailingProperty() {\n-        return trailing;\n+    public final ObjectProperty<Node> rightProperty() {\n+        return right;\n@@ -517,2 +562,2 @@\n-    public final Node getTrailing() {\n-        return trailing.get();\n+    public final Node getRight() {\n+        return right.get();\n@@ -521,2 +566,2 @@\n-    public final void setTrailing(Node value) {\n-        trailing.set(value);\n+    public final void setRight(Node value) {\n+        right.set(value);\n@@ -526,1 +571,1 @@\n-     * Specifies whether additional padding should be added to the leading side of the {@code HeaderBar}.\n+     * Specifies whether additional padding should be added to the left side of the {@code HeaderBar}.\n@@ -529,1 +574,1 @@\n-     * header buttons, no additional padding is added to the leading side of the {@code HeaderBar}.\n+     * header buttons, no additional padding is added to the left side of the {@code HeaderBar}.\n@@ -536,1 +581,2 @@\n-     * @see #trailingSystemPaddingProperty() trailingSystemPadding\n+     * @see #rightSystemPaddingProperty() rightSystemPadding\n+     * @since 26\n@@ -538,1 +584,1 @@\n-    private final BooleanProperty leadingSystemPadding = new BooleanPropertyBase(true) {\n+    private final BooleanProperty leftSystemPadding = new BooleanPropertyBase(true) {\n@@ -546,1 +592,1 @@\n-            return \"leadingSystemPadding\";\n+            return \"leftSystemPadding\";\n@@ -555,2 +601,2 @@\n-    public final BooleanProperty leadingSystemPaddingProperty() {\n-        return leadingSystemPadding;\n+    public final BooleanProperty leftSystemPaddingProperty() {\n+        return leftSystemPadding;\n@@ -559,2 +605,2 @@\n-    public final boolean isLeadingSystemPadding() {\n-        return leadingSystemPadding.get();\n+    public final boolean isLeftSystemPadding() {\n+        return leftSystemPadding.get();\n@@ -563,2 +609,2 @@\n-    public final void setLeadingSystemPadding(boolean value) {\n-        leadingSystemPadding.set(value);\n+    public final void setLeftSystemPadding(boolean value) {\n+        leftSystemPadding.set(value);\n@@ -568,1 +614,1 @@\n-     * Specifies whether additional padding should be added to the trailing side of the {@code HeaderBar}.\n+     * Specifies whether additional padding should be added to the right side of the {@code HeaderBar}.\n@@ -571,1 +617,1 @@\n-     * header buttons, no additional padding is added to the trailing side of the {@code HeaderBar}.\n+     * header buttons, no additional padding is added to the right side of the {@code HeaderBar}.\n@@ -578,1 +624,2 @@\n-     * @see #leadingSystemPaddingProperty() leadingSystemPadding\n+     * @see #leftSystemPaddingProperty() leftSystemPadding\n+     * @since 26\n@@ -580,1 +627,1 @@\n-    private final BooleanProperty trailingSystemPadding = new BooleanPropertyBase(true) {\n+    private final BooleanProperty rightSystemPadding = new BooleanPropertyBase(true) {\n@@ -588,1 +635,1 @@\n-            return \"trailingSystemPadding\";\n+            return \"rightSystemPadding\";\n@@ -597,2 +644,2 @@\n-    public final BooleanProperty trailingSystemPaddingProperty() {\n-        return trailingSystemPadding;\n+    public final BooleanProperty rightSystemPaddingProperty() {\n+        return rightSystemPadding;\n@@ -601,2 +648,2 @@\n-    public final boolean isTrailingSystemPadding() {\n-        return trailingSystemPadding.get();\n+    public final boolean isRightSystemPadding() {\n+        return rightSystemPadding.get();\n@@ -605,12 +652,2 @@\n-    public final void setTrailingSystemPadding(boolean value) {\n-        trailingSystemPadding.set(value);\n-    }\n-\n-    private boolean isLeftSystemPadding(NodeOrientation nodeOrientation) {\n-        return nodeOrientation == NodeOrientation.LEFT_TO_RIGHT && isLeadingSystemPadding()\n-            || nodeOrientation == NodeOrientation.RIGHT_TO_LEFT && isTrailingSystemPadding();\n-    }\n-\n-    private boolean isRightSystemPadding(NodeOrientation nodeOrientation) {\n-        return nodeOrientation == NodeOrientation.LEFT_TO_RIGHT && isTrailingSystemPadding()\n-            || nodeOrientation == NodeOrientation.RIGHT_TO_LEFT && isLeadingSystemPadding();\n+    public final void setRightSystemPadding(boolean value) {\n+        rightSystemPadding.set(value);\n@@ -621,1 +658,1 @@\n-        Node leading = getLeading();\n+        Node left = getLeft();\n@@ -623,1 +660,1 @@\n-        Node trailing = getTrailing();\n+        Node right = getRight();\n@@ -628,1 +665,2 @@\n-        double systemPaddingWidth = 0;\n+        double leftSystemPaddingWidth = 0;\n+        double rightSystemPaddingWidth = 0;\n@@ -631,2 +669,2 @@\n-                && (childHasContentBias(leading, Orientation.VERTICAL) ||\n-                    childHasContentBias(trailing, Orientation.VERTICAL) ||\n+                && (childHasContentBias(left, Orientation.VERTICAL) ||\n+                    childHasContentBias(right, Orientation.VERTICAL) ||\n@@ -635,2 +673,2 @@\n-            leftPrefWidth = getAreaWidth(leading, areaHeight, false);\n-            rightPrefWidth = getAreaWidth(trailing, areaHeight, false);\n+            leftPrefWidth = getAreaWidth(left, areaHeight, false);\n+            rightPrefWidth = getAreaWidth(right, areaHeight, false);\n@@ -639,2 +677,2 @@\n-            leftPrefWidth = getAreaWidth(leading, -1, false);\n-            rightPrefWidth = getAreaWidth(trailing, -1, false);\n+            leftPrefWidth = getAreaWidth(left, -1, false);\n+            rightPrefWidth = getAreaWidth(right, -1, false);\n@@ -644,1 +682,4 @@\n-        NodeOrientation nodeOrientation = getEffectiveNodeOrientation();\n+        Scene scene = getScene();\n+        Stage stage = scene != null\n+            ? scene.getWindow() instanceof Stage s ? s : null\n+            : null;\n@@ -646,3 +687,2 @@\n-        if (isLeftSystemPadding(nodeOrientation)) {\n-            systemPaddingWidth += getLeftSystemInset().getWidth();\n-        }\n+        if (stage != null) {\n+            var attachedProperties = AttachedProperties.of(stage);\n@@ -650,2 +690,7 @@\n-        if (isRightSystemPadding(nodeOrientation)) {\n-            systemPaddingWidth += getRightSystemInset().getWidth();\n+            if (scene.getEffectiveNodeOrientation() != getEffectiveNodeOrientation()) {\n+                leftSystemPaddingWidth = isLeftSystemPadding() ? attachedProperties.rightSystemInset.get().getWidth() : 0;\n+                rightSystemPaddingWidth = isRightSystemPadding() ? attachedProperties.leftSystemInset.get().getWidth() : 0;\n+            } else {\n+                leftSystemPaddingWidth = isLeftSystemPadding() ? attachedProperties.leftSystemInset.get().getWidth() : 0;\n+                rightSystemPaddingWidth = isRightSystemPadding() ? attachedProperties.rightSystemInset.get().getWidth() : 0;\n+            }\n@@ -659,1 +704,2 @@\n-             + systemPaddingWidth;\n+             + leftSystemPaddingWidth\n+             + rightSystemPaddingWidth;\n@@ -664,1 +710,1 @@\n-        Node leading = getLeading();\n+        Node left = getLeft();\n@@ -666,1 +712,1 @@\n-        Node trailing = getTrailing();\n+        Node right = getRight();\n@@ -668,2 +714,2 @@\n-        double leadingMinHeight = getAreaHeight(leading, -1, true);\n-        double trailingMinHeight = getAreaHeight(trailing, -1, true);\n+        double leftMinHeight = getAreaHeight(left, -1, true);\n+        double rightMinHeight = getAreaHeight(right, -1, true);\n@@ -673,3 +719,3 @@\n-            double leadingPrefWidth = getAreaWidth(leading, -1, false);\n-            double trailingPrefWidth = getAreaWidth(trailing, -1, false);\n-            centerMinHeight = getAreaHeight(center, Math.max(0, width - leadingPrefWidth - trailingPrefWidth), true);\n+            double leftPrefWidth = getAreaWidth(left, -1, false);\n+            double rightPrefWidth = getAreaWidth(right, -1, false);\n+            centerMinHeight = getAreaHeight(center, Math.max(0, width - leftPrefWidth - rightPrefWidth), true);\n@@ -682,1 +728,1 @@\n-             + Math.max(centerMinHeight, Math.max(trailingMinHeight, leadingMinHeight));\n+             + Math.max(centerMinHeight, Math.max(rightMinHeight, leftMinHeight));\n@@ -687,1 +733,1 @@\n-        Node leading = getLeading();\n+        Node left = getLeft();\n@@ -689,1 +735,1 @@\n-        Node trailing = getTrailing();\n+        Node right = getRight();\n@@ -691,2 +737,2 @@\n-        double leadingPrefHeight = getAreaHeight(leading, -1, false);\n-        double trailingPrefHeight = getAreaHeight(trailing, -1, false);\n+        double leftPrefHeight = getAreaHeight(left, -1, false);\n+        double rightPrefHeight = getAreaHeight(right, -1, false);\n@@ -696,3 +742,3 @@\n-            double leadingPrefWidth = getAreaWidth(leading, -1, false);\n-            double trailingPrefWidth = getAreaWidth(trailing, -1, false);\n-            centerPrefHeight = getAreaHeight(center, Math.max(0, width - leadingPrefWidth - trailingPrefWidth), false);\n+            double leftPrefWidth = getAreaWidth(left, -1, false);\n+            double rightPrefWidth = getAreaWidth(right, -1, false);\n+            centerPrefHeight = getAreaHeight(center, Math.max(0, width - leftPrefWidth - rightPrefWidth), false);\n@@ -705,6 +751,1 @@\n-             + Math.max(centerPrefHeight, Math.max(trailingPrefHeight, leadingPrefHeight));\n-    }\n-\n-    @Override\n-    public boolean usesMirroring() {\n-        return false;\n+             + Math.max(centerPrefHeight, Math.max(rightPrefHeight, leftPrefHeight));\n@@ -715,0 +756,1 @@\n+        Node left = getLeft();\n@@ -716,1 +758,1 @@\n-        Node left, right;\n+        Node right = getRight();\n@@ -718,2 +760,0 @@\n-        NodeOrientation nodeOrientation = getEffectiveNodeOrientation();\n-        boolean rtl = nodeOrientation == NodeOrientation.RIGHT_TO_LEFT;\n@@ -726,14 +766,18 @@\n-        double insideX, insideWidth;\n-        double leftSystemPaddingWidth = isLeftSystemPadding(nodeOrientation) ? getLeftSystemInset().getWidth() : 0;\n-        double rightSystemPaddingWidth = isRightSystemPadding(nodeOrientation) ? getRightSystemInset().getWidth() : 0;\n-\n-        if (rtl) {\n-            left = getTrailing();\n-            right = getLeading();\n-            insideX = insets.getRight() + leftSystemPaddingWidth;\n-            insideWidth = width - insideX - insets.getLeft() - rightSystemPaddingWidth;\n-        } else {\n-            left = getLeading();\n-            right = getTrailing();\n-            insideX = insets.getLeft() + leftSystemPaddingWidth;\n-            insideWidth = width - insideX - insets.getRight() - rightSystemPaddingWidth;\n+        double rightSystemPaddingWidth = 0;\n+        double leftSystemPaddingWidth = 0;\n+\n+        Scene scene = getScene();\n+        Stage stage = scene != null\n+            ? scene.getWindow() instanceof Stage s ? s : null\n+            : null;\n+\n+        if (stage != null) {\n+            AttachedProperties attachedProperties = AttachedProperties.of(stage);\n+\n+            if (scene.getEffectiveNodeOrientation() != getEffectiveNodeOrientation()) {\n+                leftSystemPaddingWidth = isLeftSystemPadding() ? attachedProperties.rightSystemInset.get().getWidth() : 0;\n+                rightSystemPaddingWidth = isRightSystemPadding() ? attachedProperties.leftSystemInset.get().getWidth() : 0;\n+            } else {\n+                leftSystemPaddingWidth = isLeftSystemPadding() ? attachedProperties.leftSystemInset.get().getWidth() : 0;\n+                rightSystemPaddingWidth = isRightSystemPadding() ? attachedProperties.rightSystemInset.get().getWidth() : 0;\n+            }\n@@ -742,0 +786,3 @@\n+        double insideX = insets.getLeft() + leftSystemPaddingWidth;\n+        double insideWidth = width - insideX - insets.getRight() - rightSystemPaddingWidth;\n+\n@@ -743,1 +790,1 @@\n-            Insets leftMargin = adjustMarginForRTL(getNodeMargin(left), rtl);\n+            Insets leftMargin = getNodeMargin(left);\n@@ -759,1 +806,1 @@\n-            Insets rightMargin = adjustMarginForRTL(getNodeMargin(right), rtl);\n+            Insets rightMargin = getNodeMargin(right);\n@@ -775,1 +822,1 @@\n-            Insets centerMargin = adjustMarginForRTL(getNodeMargin(center), rtl);\n+            Insets centerMargin = getNodeMargin(center);\n@@ -812,10 +859,0 @@\n-    private Insets adjustMarginForRTL(Insets margin, boolean rtl) {\n-        if (margin == null) {\n-            return null;\n-        }\n-\n-        return rtl\n-            ? new Insets(margin.getTop(), margin.getLeft(), margin.getBottom(), margin.getRight())\n-            : margin;\n-    }\n-\n@@ -867,0 +904,20 @@\n+    private void onStageChanged(Stage stage) {\n+        subscriptions.unsubscribe();\n+\n+        if (stage != null) {\n+            var attachedProperties = AttachedProperties.of(stage);\n+\n+            subscriptions = Subscription.combine(\n+                attachedProperties.minSystemHeight.subscribe(height -> {\n+                    var minHeight = (StyleableDoubleProperty)minHeightProperty();\n+\n+                    \/\/ Only change minHeight if it was not set by a stylesheet or application code.\n+                    if (minHeight.getStyleOrigin() == null) {\n+                        minHeight.applyStyle(null, height);\n+                    }\n+                }),\n+                attachedProperties.subscribeLayoutInvalidated(this::requestLayout)\n+            );\n+        }\n+    }\n+\n@@ -898,0 +955,89 @@\n+\n+    \/**\n+     * This class holds attached properties that are defined on {@code HeaderBar}, but associated\n+     * with and stored per {@code Stage}. {@code HeaderBar} uses these properties for layout purposes,\n+     * and also subscribes to invalidation notifications that cause {@code HeaderBar} to request a\n+     * new layout pass.\n+     *\/\n+    private static final class AttachedProperties {\n+\n+        private final Stage stage;\n+        private final ReadOnlyObjectWrapper<Dimension2D> leftSystemInset;\n+        private final ReadOnlyObjectWrapper<Dimension2D> rightSystemInset;\n+        private final ReadOnlyDoubleWrapper minSystemHeight;\n+        private final DoubleProperty prefButtonHeight;\n+        private final List<Runnable> layoutInvalidatedListeners = new ArrayList<>();\n+\n+        private boolean currentFullScreen;\n+        private HeaderButtonMetrics currentMetrics;\n+\n+        AttachedProperties(Stage stage) {\n+            this.stage = stage;\n+            this.leftSystemInset = new ReadOnlyObjectWrapper<>(stage, \"leftSystemInset\", EMPTY);\n+            this.rightSystemInset = new ReadOnlyObjectWrapper<>(stage, \"rightSystemInset\", EMPTY);\n+            this.minSystemHeight = new ReadOnlyDoubleWrapper(stage, \"minSystemHeight\");\n+            this.prefButtonHeight = new SimpleDoubleProperty(\n+                    stage, \"prefButtonHeight\", StageHelper.getPrefHeaderButtonHeight(stage)) {\n+                @Override\n+                protected void invalidated() {\n+                    StageHelper.setPrefHeaderButtonHeight(stage, get());\n+                }\n+            };\n+\n+            StageHelper.getHeaderButtonMetrics(stage).subscribe(this::onMetricsChanged);\n+            stage.fullScreenProperty().subscribe(this::onFullScreenChanged);\n+            stage.sceneProperty().flatMap(Scene::effectiveNodeOrientationProperty).subscribe(this::updateInsets);\n+        }\n+\n+        public static AttachedProperties of(Stage stage) {\n+            var instance = (AttachedProperties)Objects.requireNonNull(stage, \"Stage cannot be null\")\n+                .getProperties()\n+                .get(AttachedProperties.class);\n+\n+            if (instance == null) {\n+                instance = new AttachedProperties(stage);\n+                stage.getProperties().put(AttachedProperties.class, instance);\n+            }\n+\n+            return instance;\n+        }\n+\n+        public Subscription subscribeLayoutInvalidated(Runnable listener) {\n+            layoutInvalidatedListeners.add(listener);\n+            return () -> layoutInvalidatedListeners.remove(listener);\n+        }\n+\n+        private void onMetricsChanged(HeaderButtonMetrics metrics) {\n+            currentMetrics = metrics;\n+\n+            updateInsets(stage.getScene() instanceof Scene scene\n+                ? scene.getEffectiveNodeOrientation()\n+                : NodeOrientation.LEFT_TO_RIGHT);\n+        }\n+\n+        private void onFullScreenChanged(boolean fullScreen) {\n+            currentFullScreen = fullScreen;\n+\n+            updateInsets(stage.getScene() instanceof Scene scene\n+                ? scene.getEffectiveNodeOrientation()\n+                : NodeOrientation.LEFT_TO_RIGHT);\n+        }\n+\n+        private void updateInsets(NodeOrientation orientation) {\n+            if (currentFullScreen || currentMetrics == null) {\n+                leftSystemInset.set(EMPTY);\n+                rightSystemInset.set(EMPTY);\n+                minSystemHeight.set(0);\n+            } else if (orientation == NodeOrientation.LEFT_TO_RIGHT) {\n+                leftSystemInset.set(currentMetrics.leftInset());\n+                rightSystemInset.set(currentMetrics.rightInset());\n+                minSystemHeight.set(currentMetrics.minHeight());\n+            } else {\n+                leftSystemInset.set(currentMetrics.rightInset());\n+                rightSystemInset.set(currentMetrics.leftInset());\n+                minSystemHeight.set(currentMetrics.minHeight());\n+            }\n+\n+            layoutInvalidatedListeners.forEach(Runnable::run);\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HeaderBar.java","additions":441,"deletions":295,"binary":false,"changes":736,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javafx.stage.StageStyle;\n@@ -31,1 +32,16 @@\n- * Specifies whether a node is a draggable part of a {@link HeaderBar}.\n+ * Specifies how a {@link Node} participates in {@link HeaderBar} draggable-area hit testing.\n+ * <p>\n+ * In stages with the {@link StageStyle#EXTENDED} style, the window can be moved (and on some platforms,\n+ * resized near the top edge) by interacting with a draggable area. {@code HeaderBar} provides such an\n+ * area in the scene graph, and uses {@code HeaderDragType} flags on nodes to decide which parts of the\n+ * scene graph count as draggable, block an underlying draggable area, or are ignored during draggable\n+ * area hit testing.\n+ *\n+ * <h2>Recommended usage<\/h2>\n+ * <ul>\n+ *   <li>Mark non-interactive \"blank\" areas as {@link #DRAGGABLE} \/ {@link #DRAGGABLE_SUBTREE}.\n+ *   <li>Do <em>not<\/em> mark interactive controls (buttons, menu bars, text inputs) as draggable; use\n+ *       {@link #NONE} on controls if you need them to explicitly opt out or stop inheritance.\n+ *   <li>Mark overlays that may cover the header area as {@link #TRANSPARENT} \/ {@link #TRANSPARENT_SUBTREE}\n+ *       so they do not obstruct existing draggable areas.\n+ * <\/ul>\n@@ -41,1 +57,4 @@\n-     * The node is not a draggable part of the {@code HeaderBar}.\n+     * The node and its descendants are not a draggable part of the {@code HeaderBar}, and not transparent\n+     * in regard to draggable-area hit testing. Explicitly opting out of draggability can be useful for\n+     * controls that are flush with the top edge (for example a {@code MenuBar}), where some platforms\n+     * may otherwise prioritize a window resize border over control interaction.\n@@ -43,2 +62,2 @@\n-     * If the node inherits {@link #DRAGGABLE_SUBTREE} from its parent, the inheritance stops and\n-     * descendants of the node will not inherit {@code DRAGGABLE_SUBTREE}.\n+     * If the node inherits {@link #DRAGGABLE_SUBTREE} or {@link #TRANSPARENT_SUBTREE} from its parent,\n+     * the inheritance stops and descendants of the node will not inherit either drag type.\n@@ -51,2 +70,9 @@\n-     * This drag type does not apply to descendants of the node. However, it does not stop an inherited\n-     * {@link #DRAGGABLE_SUBTREE} drag type from being inherited by descendants of the node.\n+     * This drag type is only relevant for nodes that are descendants of the header bar. When set on a node,\n+     * the node participates in draggable-area hit testing. If the node extends beyond the header bar, the\n+     * effective draggable area is extended accordingly.\n+     * <p>\n+     * An interactive node (for example, a {@code Control}) should not be draggable. This can cause problems\n+     * as both the header bar and the interactive node may react to mouse events in incompatible ways.\n+     * <p>\n+     * This drag type does not apply to descendants of the node on which it is set. However, it does not stop\n+     * an inherited {@link #DRAGGABLE_SUBTREE} drag type from being inherited by descendants of the node.\n@@ -59,0 +85,52 @@\n+     * This drag type is only relevant for nodes that are descendants of the header bar. When set on a node,\n+     * the node and its descendants participate in draggable-area hit testing. If the node or its descendants\n+     * extend beyond the header bar, the effective draggable area is extended accordingly.\n+     * <p>\n+     * An interactive node (for example, a {@code Control}) should not be draggable. This can cause problems\n+     * as both the header bar and the interactive node may react to mouse events in incompatible ways.\n+     * <p>\n+     * This drag type is inherited by descendants of the node until a descendant specifies {@link #NONE}.\n+     *\/\n+    DRAGGABLE_SUBTREE,\n+\n+    \/**\n+     * The node is transparent in regard to draggable-area hit testing.\n+     * <p>\n+     * In contrast to {@link #DRAGGABLE}, which positively identifies a node as a draggable part of the\n+     * {@code HeaderBar}, this option excludes a node from draggable-area hit testing: the header bar\n+     * behaves as if the node was not present and continues hit testing unimpeded.\n+     * <p>\n+     * This drag type can be used not only on descendants of the header bar, but also on other nodes that\n+     * may overlap it (for example, a sibling shown on top of the header bar). In that case, the overlapping\n+     * node behaves as if it were draggable, but only where it overlaps a draggable area of the header bar;\n+     * it does not create any additional draggable area.\n+     * <p>\n+     * An interactive node (for example, a {@code Control}) should not be transparent in regard to draggable\n+     * area hit testing. This can cause problems as both the header bar and the interactive node may react to\n+     * mouse events in incompatible ways.\n+     * <p>\n+     * This drag type does not apply to descendants of the node on which it is set. However, it does\n+     * not stop an inherited {@link #TRANSPARENT_SUBTREE} drag type from being inherited by descendants\n+     * of the node.\n+     *\n+     * @since 26\n+     *\/\n+    TRANSPARENT,\n+\n+    \/**\n+     * The node and its descendants are transparent in regard to draggable-area hit testing.\n+     * <p>\n+     * In contrast to {@link #DRAGGABLE_SUBTREE}, which positively identifies a node and its descendants\n+     * as a draggable part of the {@code HeaderBar}, this option excludes a node and its descendants from\n+     * draggable-area hit testing: the header bar behaves as if the node and its descendants were not\n+     * present and continues hit testing unimpeded.\n+     * <p>\n+     * This drag type can be used not only on descendants of the header bar, but also on other nodes that\n+     * may overlap it (for example, a sibling shown on top of the header bar). In that case, the overlapping\n+     * node and its descendants behave as if they were draggable, but only where they overlap a draggable\n+     * area of the header bar; they do not create any additional draggable area.\n+     * <p>\n+     * An interactive node (for example, a {@code Control}) should not be transparent in regard to draggable\n+     * area hit testing. This can cause problems as both the header bar and the interactive node may react to\n+     * mouse events in incompatible ways.\n+     * <p>\n@@ -60,0 +138,2 @@\n+     *\n+     * @since 26\n@@ -61,1 +141,1 @@\n-    DRAGGABLE_SUBTREE\n+    TRANSPARENT_SUBTREE\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HeaderDragType.java","additions":88,"deletions":8,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,0 +100,1 @@\n+ * <li>{@link StageStyle#EXTENDED} - a decorated stage with a custom {@link HeaderBar} (Preview Feature).<\/li>\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/Stage.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-jmethodID jGtkWindowDragAreaHitTest;\n+jmethodID jGtkWindowNonClientHitTest;\n@@ -275,1 +275,1 @@\n-    jGtkWindowDragAreaHitTest = env->GetMethodID(clazz, \"dragAreaHitTest\", \"(II)Z\");\n+    jGtkWindowNonClientHitTest = env->GetMethodID(clazz, \"nonClientHitTest\", \"(II)I\");\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,1 +190,1 @@\n-    extern jmethodID jGtkWindowDragAreaHitTest; \/\/com.sun.glass.ui.gtk.GtkWindow#dragAreaHitTest (II)Z\n+    extern jmethodID jGtkWindowNonClientHitTest; \/\/com.sun.glass.ui.gtk.GtkWindow#nonClientHitTest (II)I\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include <com_sun_glass_ui_gtk_GtkWindow.h>\n@@ -1436,2 +1437,2 @@\n-        jboolean dragArea = mainEnv->CallBooleanMethod(\n-            jwindow, jGtkWindowDragAreaHitTest, (jint)event->x, (jint)event->y);\n+        jint hitTestResult = mainEnv->CallBooleanMethod(\n+            jwindow, jGtkWindowNonClientHitTest, (jint)event->x, (jint)event->y);\n@@ -1440,1 +1441,1 @@\n-        if (dragArea) {\n+        if (hitTestResult == com_sun_glass_ui_gtk_GtkWindow_HT_CAPTION) {\n@@ -1449,0 +1450,3 @@\n+        jint hitTestResult = mainEnv->CallBooleanMethod(\n+            jwindow, jGtkWindowNonClientHitTest, (jint)event->x, (jint)event->y);\n+\n@@ -1450,1 +1454,5 @@\n-        bool shouldStartResizeDrag = is_resizable() && !is_maximized && get_window_edge(event->x, event->y, &edge);\n+        bool shouldStartResizeDrag =\n+            is_resizable() &&\n+            !is_maximized &&\n+            get_window_edge(event->x, event->y, &edge) &&\n+            (edge != GDK_WINDOW_EDGE_NORTH || hitTestResult != com_sun_glass_ui_gtk_GtkWindow_HT_CLIENT);\n@@ -1454,6 +1462,3 @@\n-            \/\/ Send a synthetic PRESS + RELEASE to FX. This allows FX to do things that need to be done\n-            \/\/ prior to resizing the window, like closing a popup menu. We do this because we won't be\n-            \/\/ sending events to FX once the resize operation has started.\n-            WindowContextBase::process_mouse_button(event, true);\n-            event->type = GDK_BUTTON_RELEASE;\n-            WindowContextBase::process_mouse_button(event, true);\n+            \/\/ We send FocusUngrabEvent to FX before we start the resize-drag operation. This allows FX\n+            \/\/ to do things that need to be done prior to resizing the window, like closing a popup menu.\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusUngrab);\n@@ -1467,4 +1472,0 @@\n-        bool shouldStartMoveDrag = mainEnv->CallBooleanMethod(\n-            jwindow, jGtkWindowDragAreaHitTest, (jint)event->x, (jint)event->y);\n-        CHECK_JNI_EXCEPTION(mainEnv);\n-\n@@ -1472,5 +1473,2 @@\n-        if (shouldStartMoveDrag) {\n-            \/\/ Send a synthetic PRESS + RELEASE to FX.\n-            WindowContextBase::process_mouse_button(event, true);\n-            event->type = GDK_BUTTON_RELEASE;\n-            WindowContextBase::process_mouse_button(event, true);\n+        if (hitTestResult == com_sun_glass_ui_gtk_GtkWindow_HT_CAPTION) {\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusUngrab);\n@@ -1489,0 +1487,24 @@\n+void WindowContextTop::process_mouse_cross(GdkEventCrossing* event) {\n+    \/\/ Delegate to the base implementation for non-EXTENDED windows.\n+    if (frame_type != EXTENDED) {\n+        WindowContextBase::process_mouse_cross(event);\n+        return;\n+    }\n+\n+    \/\/ We only send MouseEvent.EXIT if we didn't already send it when the cursor was moved\n+    \/\/ from the client area to the resize border. This is indicated by is_mouse_entered\n+    \/\/ being false at this point.\n+    if (is_mouse_entered && event->type != GDK_ENTER_NOTIFY) {\n+        is_mouse_entered = false;\n+        mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+            com_sun_glass_events_MouseEvent_EXIT,\n+            com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+            (jint) event->x, (jint) event->y,\n+            (jint) event->x_root, (jint) event->y_root,\n+            gdk_modifier_mask_to_glass(event->state),\n+            JNI_FALSE,\n+            JNI_FALSE);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n+\n@@ -1503,0 +1525,25 @@\n+        \/\/ If is_mouse_entered is false at this point, the cursor was on the resize border just a moment\n+        \/\/ ago (which doesn't count as a client area, even though it is on the window). Since the cursor\n+        \/\/ has now entered the client area, we need to send MouseEvent.ENTER to FX.\n+        if (!is_mouse_entered) {\n+            is_mouse_entered = true;\n+            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+                com_sun_glass_events_MouseEvent_ENTER,\n+                com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+                (jint) event->x, (jint) event->y,\n+                (jint) event->x_root, (jint) event->y_root,\n+                gdk_modifier_mask_to_glass(event->state),\n+                JNI_FALSE,\n+                JNI_FALSE);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+\n+        set_cursor_override(NULL);\n+        WindowContextBase::process_mouse_motion(event);\n+        return;\n+    }\n+\n+    jint hitTestResult = mainEnv->CallBooleanMethod(\n+        jwindow, jGtkWindowNonClientHitTest, (jint)event->x, (jint)event->y);\n+\n+    if (edge == GDK_WINDOW_EDGE_NORTH && hitTestResult == com_sun_glass_ui_gtk_GtkWindow_HT_CLIENT) {\n@@ -1537,0 +1584,16 @@\n+        return;\n+    }\n+\n+    \/\/ If the cursor has moved to a resize border, we need to send MouseEvent.EXIT to FX,\n+    \/\/ since from the perspective of FX, resize borders are not a part of client area.\n+    if (is_mouse_entered && jview) {\n+        is_mouse_entered = false;\n+        mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+            com_sun_glass_events_MouseEvent_EXIT,\n+            com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+            (jint) event->x, (jint) event->y,\n+            (jint) event->x_root, (jint) event->y_root,\n+            gdk_modifier_mask_to_glass(event->state),\n+            JNI_FALSE,\n+            JNI_FALSE);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":83,"deletions":20,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -309,0 +309,1 @@\n+    void process_mouse_cross(GdkEventCrossing*);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,2 @@\n+#define HTUNSPECIFIED ('H' << 24 | 'T' << 16 | 'U' << 8 | 'N') \/\/ see WinWindow.java:nonClientHitTest\n+\n@@ -629,0 +631,4 @@\n+    if (m_isExtended && HandleCaptionMouseEvents(msg, wParam, lParam)) {\n+        return true;\n+    }\n+\n@@ -645,0 +651,90 @@\n+\/*\n+ * This method is only called for windows with the EXTENDED style to handle a press-drag-release interaction\n+ * on the title bar, which will move the window. Ordinarily, this wouldn't be required at all, since correctly\n+ * responding to the WM_NCHITTEST message tells Windows which part of our window it should treat as the title\n+ * bar area; this automatically enables the press-drag-release interaction.\n+ *\n+ * However, there's a small problem with serious consequences: Windows will send us a WM_NCLBUTTONDOWN message\n+ * when the mouse button is pressed on the title bar, but it will NOT send us a WM_NCLBUTTONUP message when the\n+ * button is released again. Pressing the mouse button on the title bar area starts a move-modal message loop,\n+ * and the corresponding WM_LBUTTONUP (NB: not WM_NCLBUTTONUP) event is handled inside of this modal loop;\n+ * it doesn't arrive at the message loop in this class where we could react to it. This is a problem because\n+ * JavaFX has its own press-drag-release detection in the Scene class, and this missing release event messes\n+ * up its state.\n+ *\n+ * So, how can we still get a notification when the mouse button was released on the title bar? For future\n+ * reference, here are potential solutions that don't work well for various reasons:\n+ *\n+ * 1. Listen to WM_ENTERSIZEMOVE\/WM_EXITSIZEMOVE, which are posted at the beginning and the end of a PDR\n+ *    interaction. Unfortunately, a single short click on the title bar doesn't count as a PDR interaction,\n+ *    and none of the messages are posted. Interestingly, a single click with about a one-second delay between\n+ *    press and release does count as a PDR interaction.\n+ *\n+ * 2. Install a WH_MOUSE hook to intercept mouse messages before they are posted to the move-modal message loop,\n+ *    and use it to discover the \"missing\" WM_LBUTTONUP message. While this works, some anti-virus tools might\n+ *    dislike us using the SetWindowsHookEx API.\n+ *\n+ * What seems to work best is to not rely on Windows to start the move-modal message loop for us, but to start\n+ * it ourselves. When it returns, we know that the mouse button was released. The prerequisite for this solution\n+ * is that we never tell Windows that the cursor is on the title bar area, as Windows would then invariably start\n+ * the move-modal message loop. So every time we determine in HandleNCHitTestEvent() that the cursor is on the\n+ * title bar, we tell Windows that it's HTCLIENT instead.\n+ *\/\n+bool GlassWindow::HandleCaptionMouseEvents(UINT msg, WPARAM wParam, LPARAM lParam)\n+{\n+    switch (msg) {\n+        \/\/ Pressing the left mouse button on the title bar area initializes PDR tracking.\n+        \/\/ We don't consume this message, so it will be handled as usual in HandleViewMouseEvent()\n+        \/\/ to generate a normal JavaFX event. Note that HandleViewMouseEvent() calls SetCapture().\n+        case WM_LBUTTONDOWN:\n+            if (m_caption.entered) {\n+                m_caption.tracking = true;\n+                m_caption.dragStart = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };\n+            }\n+            break;\n+\n+        \/\/ Releasing the left mouse button without moving the cursor cancels PDR tracking.\n+        \/\/ We don't consume this message, so it will be handled as usual in HandleViewMouseEvent()\n+        \/\/ to generate a normal JavaFX event.\n+        case WM_LBUTTONUP:\n+            if (m_caption.tracking && GetCapture() == GetHWND()) {\n+                m_caption.tracking = false;\n+            }\n+            break;\n+\n+        \/\/ Moving the cursor starts up a modal message loop that handles the window movement.\n+        \/\/ Note that we only start the window drag operation when the cursor movement exceeds the\n+        \/\/ minimum distance for a PDR interaction.\n+        case WM_MOUSEMOVE:\n+            if (m_caption.tracking && GetCapture() == GetHWND()) {\n+                POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };\n+                const int dx = abs(pt.x - m_caption.dragStart.x);\n+                const int dy = abs(pt.y - m_caption.dragStart.y);\n+                const int cx = GetSystemMetrics(SM_CXDRAG);\n+                const int cy = GetSystemMetrics(SM_CYDRAG);\n+\n+                if (dx >= cx || dy >= cy) {\n+                    \/\/ Start the move-modal message loop, and return when the drag operation has finished.\n+                    ReleaseCapture();\n+                    SendMessage(GetHWND(), WM_SYSCOMMAND, SC_MOVE | HTCAPTION, 0);\n+\n+                    \/\/ Cancel tracking and synthesize a WM_LBUTTONUP event.\n+                    m_caption.tracking = false;\n+                    HandleViewMouseEvent(GetHWND(), WM_LBUTTONUP, wParam, lParam, true);\n+                }\n+\n+                \/\/ Always consume WM_MOUSEMOVE when we're in a PDR interaction.\n+                return true;\n+            }\n+            break;\n+\n+        \/\/ Cancel tracking when an in-progress PDR interaction is canceled.\n+        case WM_CANCELMODE:\n+        case WM_CAPTURECHANGED:\n+            m_caption.tracking = false;\n+            break;\n+    }\n+\n+    return false;\n+}\n+\n@@ -942,6 +1038,9 @@\n-    \/\/ In contrast, the top resize border is not outside, but inside the client area and below user controls.\n-    \/\/ For example, if a control extends to the top of the client area, it covers the resize border at that\n-    \/\/ location. We know that the cursor is on top of the caption area (and not on top of a control) when\n-    \/\/ the nonClientHitTest() function returns HTCAPTION (instead of HTCLIENT). In this case, we apply the\n-    \/\/ default resize border.\n-    if (res == HTCAPTION) {\n+    \/\/ In contrast, the top resize border is not outside, but inside the client area and may be below user\n+    \/\/ controls. For example, if a control with HeaderDragType.NONE extends to the top of the client area,\n+    \/\/ it covers the resize border at that location. We know that the cursor is on top of the caption area\n+    \/\/ (and not on top of a control) when the nonClientHitTest() function returns HTCAPTION instead of\n+    \/\/ HTCLIENT. In this case, we apply the default resize border.\n+    \/\/ Note that HTUNSPECIFIED is a custom JavaFX classification that means the cursor is on the HeaderBar,\n+    \/\/ but no user-specified HeaderDragType is known. In this case, we treat the current cursor position as\n+    \/\/ HTTOP if the cursor is on the top resize border, and as HTCLIENT otherwise.\n+    if (res == HTCAPTION || res == HTUNSPECIFIED) {\n@@ -953,2 +1052,3 @@\n-            result = LRESULT(HTTOP);\n-            return TRUE;\n+            res = HTTOP;\n+        } else if (res == HTUNSPECIFIED) {\n+            res = HTCLIENT;\n@@ -958,0 +1058,7 @@\n+    \/\/ If the cursor is on the title bar, lie to Windows and say it's on the client area instead.\n+    \/\/ See GlassWindow::HandleCaptionMouseEvents() for more information.\n+    m_caption.entered = res == HTCAPTION;\n+    if (res == HTCAPTION) {\n+        res = HTCLIENT;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.cpp","additions":116,"deletions":9,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,0 +164,6 @@\n+    struct {\n+        bool entered = false;\n+        bool tracking = false;\n+        POINT dragStart = {};\n+    } m_caption;\n+\n@@ -192,0 +198,1 @@\n+    bool HandleCaptionMouseEvents(UINT msg, WPARAM wParam, LPARAM lParam);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.h","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1040,0 +1040,10 @@\n+    } else if (msg == WM_NCMOUSEMOVE && wParam == HTTOP && m_bTrackingMouse) {\n+        \/\/ We are here because the mouse cursor moved from the client area to the HTTOP non-client area.\n+        \/\/ We emit an EXIT event to signal to JavaFX that the mouse cursor is no longer within the client area.\n+        pt.x = GET_X_LPARAM(lParam);\n+        pt.y = GET_Y_LPARAM(lParam);\n+        ::MapWindowPoints(NULL, hwnd, &pt, 1);\n+\n+        type = com_sun_glass_events_MouseEvent_EXIT;\n+        m_bTrackingMouse = FALSE;\n+        m_lastMouseMovePosition = -1;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/ViewContainer.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.lang.reflect.Method;\n@@ -39,0 +40,1 @@\n+import javafx.scene.layout.HeaderButtonType;\n@@ -43,0 +45,1 @@\n+import org.junit.jupiter.api.AfterEach;\n@@ -55,0 +58,2 @@\n+    Stage stage;\n+    Scene scene;\n@@ -60,0 +65,20 @@\n+        scene = new Scene(headerBar);\n+        stage = new Stage();\n+        stage.setScene(scene);\n+        stage.show();\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        stage.close();\n+    }\n+\n+    <T> T getAttachedProperty(String name) {\n+        try {\n+            Class<?> propertiesClass = Class.forName(HeaderBar.class.getName() + \"$AttachedProperties\");\n+            Method method = propertiesClass.getMethod(\"of\", Stage.class);\n+            method.setAccessible(true);\n+            return ReflectionUtils.getFieldValue(method.invoke(null, stage), name);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n@@ -64,1 +89,1 @@\n-        assertNull(headerBar.getLeading());\n+        assertNull(headerBar.getLeft());\n@@ -66,1 +91,1 @@\n-        assertNull(headerBar.getTrailing());\n+        assertNull(headerBar.getRight());\n@@ -71,1 +96,1 @@\n-        DoubleProperty minSystemHeight = ReflectionUtils.getFieldValue(headerBar, \"minSystemHeight\");\n+        DoubleProperty minSystemHeight = getAttachedProperty(\"minSystemHeight\");\n@@ -80,0 +105,32 @@\n+    @Test\n+    void dragType_attachedProperty() {\n+        var child = new Rectangle();\n+        var type = new HeaderDragType[1];\n+        assertNull(HeaderBar.getDragType(child));\n+        HeaderBar.dragTypeProperty(child).subscribe(v -> type[0] = v);\n+        HeaderBar.setDragType(child, HeaderDragType.DRAGGABLE);\n+        assertEquals(HeaderDragType.DRAGGABLE, type[0]);\n+        assertEquals(HeaderDragType.DRAGGABLE, HeaderBar.getDragType(child));\n+    }\n+\n+    @Test\n+    void buttonType_attachedProperty() {\n+        var child = new Rectangle();\n+        var type = new HeaderButtonType[1];\n+        assertNull(HeaderBar.getButtonType(child));\n+        HeaderBar.buttonTypeProperty(child).subscribe(v -> type[0] = v);\n+        HeaderBar.setButtonType(child, HeaderButtonType.MAXIMIZE);\n+        assertEquals(HeaderButtonType.MAXIMIZE, type[0]);\n+        assertEquals(HeaderButtonType.MAXIMIZE, HeaderBar.getButtonType(child));\n+    }\n+\n+    @Test\n+    void prefButtonHeight_attachedProperty() {\n+        var minHeight = new double[1];\n+        assertEquals(HeaderBar.USE_DEFAULT_SIZE, HeaderBar.getPrefButtonHeight(stage));\n+        HeaderBar.prefButtonHeightProperty(stage).subscribe(v -> minHeight[0] = v.doubleValue());\n+        HeaderBar.prefButtonHeightProperty(stage).set(123);\n+        assertEquals(123, minHeight[0]);\n+        assertEquals(123, HeaderBar.getPrefButtonHeight(stage));\n+    }\n+\n@@ -94,1 +151,1 @@\n-        void alignmentOfLeadingChildOnly_resizable(Pos pos, double x, double y, double width, double height) {\n+        void alignmentOfLeftChildOnly_resizable(Pos pos, double x, double y, double width, double height) {\n@@ -98,1 +155,1 @@\n-            headerBar.setLeading(content);\n+            headerBar.setLeft(content);\n@@ -117,1 +174,1 @@\n-        void alignmentOfLeadingChildOnly_notResizable(Pos pos, double x, double y, double width, double height) {\n+        void alignmentOfLeftChildOnly_notResizable(Pos pos, double x, double y, double width, double height) {\n@@ -121,1 +178,1 @@\n-            headerBar.setLeading(content);\n+            headerBar.setLeft(content);\n@@ -140,1 +197,1 @@\n-        void alignmentOfTrailingChildOnly_resizable(Pos pos, double x, double y, double width, double height) {\n+        void alignmentOfRightChildOnly_resizable(Pos pos, double x, double y, double width, double height) {\n@@ -144,1 +201,1 @@\n-            headerBar.setTrailing(content);\n+            headerBar.setRight(content);\n@@ -163,1 +220,1 @@\n-        void alignmentOfTrailingChildOnly_notResizable(Pos pos, double x, double y, double width, double height) {\n+        void alignmentOfRightChildOnly_notResizable(Pos pos, double x, double y, double width, double height) {\n@@ -167,1 +224,1 @@\n-            headerBar.setTrailing(content);\n+            headerBar.setRight(content);\n@@ -233,1 +290,1 @@\n-        void alignmentOfCenterChild_resizable_withNonEmptyLeadingAndTrailingChild(\n+        void alignmentOfCenterChild_resizable_withNonEmptyLeftAndRightChild(\n@@ -235,1 +292,1 @@\n-            var leading = new MockResizable(50, 50);\n+            var left = new MockResizable(50, 50);\n@@ -237,1 +294,1 @@\n-            var trailing = new MockResizable(150, 50);\n+            var right = new MockResizable(150, 50);\n@@ -240,1 +297,1 @@\n-            headerBar.setLeading(leading);\n+            headerBar.setLeft(left);\n@@ -242,1 +299,1 @@\n-            headerBar.setTrailing(trailing);\n+            headerBar.setRight(right);\n@@ -261,1 +318,1 @@\n-        void alignmentOfCenterChild_notResizable_withNonEmptyLeadingAndTrailingChild(\n+        void alignmentOfCenterChild_notResizable_withNonEmptyLeftAndRightChild(\n@@ -263,1 +320,1 @@\n-            var leading = new Rectangle(50, 50);\n+            var left = new Rectangle(50, 50);\n@@ -265,1 +322,1 @@\n-            var trailing = new Rectangle(150, 50);\n+            var right = new Rectangle(150, 50);\n@@ -268,1 +325,1 @@\n-            headerBar.setLeading(leading);\n+            headerBar.setLeft(left);\n@@ -270,1 +327,1 @@\n-            headerBar.setTrailing(trailing);\n+            headerBar.setRight(right);\n@@ -290,1 +347,1 @@\n-            ObjectProperty<Dimension2D> leftSystemInset = ReflectionUtils.getFieldValue(headerBar, \"leftSystemInset\");\n+            ObjectProperty<Dimension2D> leftSystemInset = getAttachedProperty(\"leftSystemInset\");\n@@ -309,1 +366,1 @@\n-            ObjectProperty<Dimension2D> leftSystemInset = ReflectionUtils.getFieldValue(headerBar, \"leftSystemInset\");\n+            ObjectProperty<Dimension2D> leftSystemInset = getAttachedProperty(\"leftSystemInset\");\n@@ -327,1 +384,1 @@\n-            ObjectProperty<Dimension2D> rightSystemInset = ReflectionUtils.getFieldValue(headerBar, \"rightSystemInset\");\n+            ObjectProperty<Dimension2D> rightSystemInset = getAttachedProperty(\"rightSystemInset\");\n@@ -346,1 +403,1 @@\n-            ObjectProperty<Dimension2D> rightSystemInset = ReflectionUtils.getFieldValue(headerBar, \"rightSystemInset\");\n+            ObjectProperty<Dimension2D> rightSystemInset = getAttachedProperty(\"rightSystemInset\");\n@@ -359,1 +416,1 @@\n-            ObjectProperty<Dimension2D> leftSystemInset = ReflectionUtils.getFieldValue(headerBar, \"leftSystemInset\");\n+            ObjectProperty<Dimension2D> leftSystemInset = getAttachedProperty(\"leftSystemInset\");\n@@ -372,1 +429,1 @@\n-            ObjectProperty<Dimension2D> rightSystemInset = ReflectionUtils.getFieldValue(headerBar, \"rightSystemInset\");\n+            ObjectProperty<Dimension2D> rightSystemInset = getAttachedProperty(\"rightSystemInset\");\n@@ -379,1 +436,1 @@\n-            var leading = new MockResizable(50, 50);\n+            var left = new MockResizable(50, 50);\n@@ -381,1 +438,1 @@\n-            var trailing = new MockResizable(150, 50);\n+            var right = new MockResizable(150, 50);\n@@ -384,1 +441,1 @@\n-            headerBar.setLeading(leading);\n+            headerBar.setLeft(left);\n@@ -386,1 +443,1 @@\n-            headerBar.setTrailing(trailing);\n+            headerBar.setRight(right);\n@@ -399,1 +456,1 @@\n-        void alignmentOfLeadingChild_notResizable_withoutReservedArea(\n+        void alignmentOfLeftChild_notResizable_withoutReservedArea(\n@@ -401,1 +458,1 @@\n-            ObjectProperty<Dimension2D> leftSystemInset = ReflectionUtils.getFieldValue(headerBar, \"leftSystemInset\");\n+            ObjectProperty<Dimension2D> leftSystemInset = getAttachedProperty(\"leftSystemInset\");\n@@ -403,5 +460,5 @@\n-            var leading = new Rectangle(50, 50);\n-            HeaderBar.setAlignment(leading, pos);\n-            HeaderBar.setMargin(leading, new Insets(10));\n-            headerBar.setLeadingSystemPadding(false);\n-            headerBar.setLeading(leading);\n+            var left = new Rectangle(50, 50);\n+            HeaderBar.setAlignment(left, pos);\n+            HeaderBar.setMargin(left, new Insets(10));\n+            headerBar.setLeftSystemPadding(false);\n+            headerBar.setLeft(left);\n@@ -411,1 +468,1 @@\n-            assertBounds(x, y, width, height, leading);\n+            assertBounds(x, y, width, height, left);\n@@ -420,1 +477,1 @@\n-        void alignmentOfTrailingChild_notResizable_withoutReservedArea(\n+        void alignmentOfRightChild_notResizable_withoutReservedArea(\n@@ -422,1 +479,1 @@\n-            ObjectProperty<Dimension2D> rightSystemInset = ReflectionUtils.getFieldValue(headerBar, \"rightSystemInset\");\n+            ObjectProperty<Dimension2D> rightSystemInset = getAttachedProperty(\"rightSystemInset\");\n@@ -424,5 +481,5 @@\n-            var trailing = new Rectangle(50, 50);\n-            HeaderBar.setAlignment(trailing, pos);\n-            HeaderBar.setMargin(trailing, new Insets(10));\n-            headerBar.setTrailingSystemPadding(false);\n-            headerBar.setTrailing(trailing);\n+            var right = new Rectangle(50, 50);\n+            HeaderBar.setAlignment(right, pos);\n+            HeaderBar.setMargin(right, new Insets(10));\n+            headerBar.setRightSystemPadding(false);\n+            headerBar.setRight(right);\n@@ -432,1 +489,1 @@\n-            assertBounds(x, y, width, height, trailing);\n+            assertBounds(x, y, width, height, right);\n@@ -461,4 +518,4 @@\n-            final Box box4 = new Box(null, 50, 0, 50, 100);\n-            final Box box3 = new Box(box4, 50, 0, 100, 100);\n-            final Box box2 = new Box(box3, 50, 0, 150, 100);\n-            final Box box1 = new Box(box2, 50, 0, 200, 100);\n+            final Box box4 = new Box(\"box4\", null, 50, 0, 50, 100);\n+            final Box box3 = new Box(\"box3\", box4, 50, 0, 100, 100);\n+            final Box box2 = new Box(\"box2\", box3, 50, 0, 150, 100);\n+            final Box box1 = new Box(\"box1\", box2, 50, 0, 200, 100);\n@@ -467,1 +524,0 @@\n-                resize(250, 100);\n@@ -473,1 +529,4 @@\n-            Box(Node child, double x, double y, double width, double height) {\n+            final String name;\n+\n+            Box(String name, Node child, double x, double y, double width, double height) {\n+                this.name = name;\n@@ -481,0 +540,5 @@\n+\n+            @Override\n+            public String toString() {\n+                return name;\n+            }\n@@ -483,4 +547,3 @@\n-        @Test\n-         void pickDraggableNode() {\n-            var headerBar = new TestHeaderBar();\n-            HeaderBar.setDragType(headerBar.box1, HeaderDragType.DRAGGABLE);\n+        Stage stage;\n+        Scene scene;\n+        TestHeaderBar headerBar;\n@@ -488,2 +551,6 @@\n-            var scene = new Scene(headerBar, 250, 200);\n-            var stage = new Stage();\n+        @BeforeEach\n+        void setup() {\n+            headerBar = new TestHeaderBar();\n+            headerBar.setManaged(false);\n+            scene = new Scene(headerBar, 250, 200);\n+            stage = new Stage();\n@@ -492,0 +559,11 @@\n+            headerBar.resize(250, 100);\n+        }\n+\n+        @AfterEach\n+        void teardown() {\n+            stage.close();\n+        }\n+\n+        @Test\n+        void pickDraggableNode() {\n+            HeaderBar.setDragType(headerBar.box1, HeaderDragType.DRAGGABLE);\n@@ -494,1 +572,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 10, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 10, 10);\n@@ -497,1 +575,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 60, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 60, 10);\n@@ -500,3 +578,3 @@\n-            assertNull(pickHeaderArea(scene, 110, 10));\n-            assertNull(pickHeaderArea(scene, 160, 10));\n-            assertNull(pickHeaderArea(scene, 210, 10));\n+            assertHeaderArea(HeaderAreaType.UNSPECIFIED, 110, 10);\n+            assertHeaderArea(HeaderAreaType.UNSPECIFIED, 160, 10);\n+            assertHeaderArea(HeaderAreaType.UNSPECIFIED, 210, 10);\n@@ -507,1 +585,0 @@\n-            var headerBar = new TestHeaderBar();\n@@ -510,5 +587,0 @@\n-            var scene = new Scene(headerBar, 250, 200);\n-            var stage = new Stage();\n-            stage.setScene(scene);\n-            stage.show();\n-\n@@ -516,1 +588,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 10, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 10, 10);\n@@ -519,1 +591,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 60, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 60, 10);\n@@ -522,3 +594,3 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 110, 10));\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 160, 10));\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 210, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 110, 10);\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 160, 10);\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 210, 10);\n@@ -529,1 +601,0 @@\n-            var headerBar = new TestHeaderBar();\n@@ -533,5 +604,0 @@\n-            var scene = new Scene(headerBar, 250, 200);\n-            var stage = new Stage();\n-            stage.setScene(scene);\n-            stage.show();\n-\n@@ -539,1 +605,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 10, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 10, 10);\n@@ -542,1 +608,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 60, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 60, 10);\n@@ -545,1 +611,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 110, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 110, 10);\n@@ -548,2 +614,2 @@\n-            assertNull(pickHeaderArea(scene, 160, 10));\n-            assertNull(pickHeaderArea(scene, 210, 10));\n+            assertHeaderArea(null, 160, 10);\n+            assertHeaderArea(null, 210, 10);\n@@ -554,1 +620,0 @@\n-            var headerBar = new TestHeaderBar();\n@@ -558,5 +623,0 @@\n-            var scene = new Scene(headerBar, 250, 200);\n-            var stage = new Stage();\n-            stage.setScene(scene);\n-            stage.show();\n-\n@@ -564,1 +624,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 10, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 10, 10);\n@@ -567,1 +627,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 60, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 60, 10);\n@@ -570,1 +630,1 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 110, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 110, 10);\n@@ -573,2 +633,95 @@\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 160, 10));\n-            assertEquals(HeaderAreaType.DRAGBAR, pickHeaderArea(scene, 210, 10));\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 160, 10);\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 210, 10);\n+        }\n+\n+        @Test\n+        void transparentSiblingIsOnlyDraggableOnExistingDraggableArea() {\n+            var sibling = new Rectangle(100, 150);\n+            sibling.setManaged(false);\n+            HeaderBar.setDragType(sibling, HeaderDragType.TRANSPARENT);\n+\n+            var root = new StackPane(headerBar, sibling);\n+            root.setManaged(false);\n+            scene.setRoot(root);\n+\n+            \/\/ 1. Overlapping transparent sibling is draggable where it overlaps the HeaderBar\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 25, 90);\n+\n+            \/\/ 2. It is not draggable where it overlaps a non-draggable box on the HeaderBar\n+            assertHeaderArea(HeaderAreaType.UNSPECIFIED, 75, 90);\n+\n+            \/\/ 3. It is also not draggable outside the bounds of the HeaderBar\n+            assertHeaderArea(null, 25, 110);\n+        }\n+\n+        @Test\n+        void childOfSiblingInheritsTransparentDragType() {\n+            var sibling = new StackPane(new Rectangle(100, 150));\n+            sibling.setManaged(false);\n+            sibling.resize(100, 150);\n+\n+            scene.setRoot(new StackPane(headerBar, sibling));\n+\n+            \/\/ 1. Even though the sibling is TRANSPARENT, its child is not.\n+            HeaderBar.setDragType(sibling, HeaderDragType.TRANSPARENT);\n+            assertHeaderArea(null, 25, 90);\n+\n+            \/\/ 2. With TRANSPARENT_SUBTREE, the child inherits the transparent flag.\n+            HeaderBar.setDragType(sibling, HeaderDragType.TRANSPARENT_SUBTREE);\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 25, 90);\n+\n+            \/\/ 3. Sibling is not draggable where it overlaps a non-draggable box on the HeaderBar\n+            assertHeaderArea(HeaderAreaType.UNSPECIFIED, 75, 90);\n+\n+            \/\/ 4. It is also not draggable outside the bounds of the HeaderBar\n+            assertHeaderArea(null, 25, 110);\n+        }\n+\n+        @Test\n+        void draggableNodeInTransparentSubtree() {\n+            var rect = new Rectangle(50, 50);\n+            var area = new StackPane(rect);\n+            area.setManaged(false);\n+            area.resizeRelocate(50, 0, 50, 100);\n+\n+            headerBar.setLeft(area);\n+            HeaderBar.setDragType(area, HeaderDragType.TRANSPARENT_SUBTREE);\n+            HeaderBar.setDragType(rect, HeaderDragType.DRAGGABLE);\n+\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 75, 25);\n+        }\n+\n+        @Test\n+        void draggableSubtreeInTransparentSubtree() {\n+            var rect = new Rectangle(50, 50);\n+            var area2 = new StackPane(rect);\n+            area2.setManaged(false);\n+            area2.resizeRelocate(50, 0, 50, 100);\n+\n+            var area1 = new StackPane(area2);\n+            area1.setManaged(false);\n+            area2.resizeRelocate(50, 0, 50, 100);\n+\n+            headerBar.setLeft(area1);\n+            HeaderBar.setDragType(area1, HeaderDragType.TRANSPARENT_SUBTREE);\n+            HeaderBar.setDragType(area2, HeaderDragType.DRAGGABLE_SUBTREE);\n+\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 75, 25);\n+        }\n+\n+        @Test\n+        void transparentSubtreeInDraggableSubtree() {\n+            var rect = new Rectangle(50, 50);\n+            var area2 = new StackPane(rect);\n+            area2.setManaged(false);\n+            area2.resizeRelocate(50, 0, 50, 100);\n+\n+            var area1 = new StackPane(area2);\n+            area1.setManaged(false);\n+            area2.resizeRelocate(50, 0, 50, 100);\n+\n+            headerBar.setLeft(area1);\n+            HeaderBar.setDragType(area1, HeaderDragType.DRAGGABLE_SUBTREE);\n+            HeaderBar.setDragType(area2, HeaderDragType.TRANSPARENT_SUBTREE);\n+\n+            assertHeaderArea(HeaderAreaType.DRAGBAR, 75, 25);\n@@ -577,1 +730,1 @@\n-        private static HeaderAreaType pickHeaderArea(Scene scene, double x, double y) {\n+        private void assertHeaderArea(HeaderAreaType expected, double x, double y) {\n@@ -580,1 +733,1 @@\n-            return listener.pickHeaderArea(x, y);\n+            assertEquals(expected, listener.pickHeaderArea(x, y));\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/HeaderBarTest.java","additions":253,"deletions":100,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,1 +183,1 @@\n-                default -> headerBar.getMinSystemHeight();\n+                default -> HeaderBar.getMinSystemHeight(stage);\n@@ -187,1 +187,1 @@\n-        headerBar.minSystemHeightProperty().subscribe(event -> updateMinHeight.run());\n+        HeaderBar.minSystemHeightProperty(stage).subscribe(event -> updateMinHeight.run());\n@@ -201,3 +201,3 @@\n-        var leadingContent = new HBox(menuBar);\n-        HeaderBar.setDragType(leadingContent, HeaderDragType.DRAGGABLE);\n-        headerBar.setLeading(leadingContent);\n+        var leftContent = new HBox(menuBar);\n+        HeaderBar.setDragType(leftContent, HeaderDragType.DRAGGABLE);\n+        headerBar.setLeft(leftContent);\n@@ -225,1 +225,1 @@\n-            leadingContent.getChildren().add(adaptiveButtonHeight);\n+            leftContent.getChildren().add(adaptiveButtonHeight);\n@@ -228,4 +228,4 @@\n-        var trailingNodes = new HBox(sizeComboBox);\n-        trailingNodes.setAlignment(Pos.CENTER);\n-        trailingNodes.setSpacing(5);\n-        headerBar.setTrailing(trailingNodes);\n+        var rightNodes = new HBox(sizeComboBox);\n+        rightNodes.setAlignment(Pos.CENTER);\n+        rightNodes.setSpacing(5);\n+        headerBar.setRight(rightNodes);\n@@ -234,1 +234,1 @@\n-            trailingNodes.getChildren().addAll(createCustomWindowButtons());\n+            rightNodes.getChildren().addAll(createCustomWindowButtons());\n@@ -247,1 +247,1 @@\n-        leftHeaderBar.setLeading(new Button(\"\\u2728\"));\n+        leftHeaderBar.setLeft(new Button(\"\\u2728\"));\n@@ -249,1 +249,1 @@\n-        leftHeaderBar.setTrailingSystemPadding(false);\n+        leftHeaderBar.setRightSystemPadding(false);\n@@ -253,1 +253,1 @@\n-        rightHeaderBar.setLeadingSystemPadding(false);\n+        rightHeaderBar.setLeftSystemPadding(false);\n@@ -262,1 +262,1 @@\n-                default -> rightHeaderBar.getMinSystemHeight();\n+                default -> HeaderBar.getMinSystemHeight(stage);\n@@ -266,1 +266,1 @@\n-        rightHeaderBar.minSystemHeightProperty().subscribe(event -> updateMinHeight.run());\n+        HeaderBar.minSystemHeightProperty(stage).subscribe(event -> updateMinHeight.run());\n@@ -268,4 +268,4 @@\n-        var trailingNodes = new HBox(sizeComboBox);\n-        trailingNodes.setAlignment(Pos.CENTER);\n-        trailingNodes.setSpacing(5);\n-        rightHeaderBar.setTrailing(trailingNodes);\n+        var rightNodes = new HBox(sizeComboBox);\n+        rightNodes.setAlignment(Pos.CENTER);\n+        rightNodes.setSpacing(5);\n+        rightHeaderBar.setRight(rightNodes);\n@@ -274,1 +274,1 @@\n-            trailingNodes.getChildren().addAll(createCustomWindowButtons());\n+            rightNodes.getChildren().addAll(createCustomWindowButtons());\n@@ -278,1 +278,1 @@\n-        rightHeaderBar.setTrailing(trailingNodes);\n+        rightHeaderBar.setRight(rightNodes);\n","filename":"tests\/manual\/monkey\/src\/com\/oracle\/tools\/fx\/monkey\/tools\/StageTesterWindow.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"}]}