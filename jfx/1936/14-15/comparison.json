{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.glass.events.MouseEvent;\n@@ -131,2 +132,1 @@\n-        if (getWindow() instanceof WinWindow window &&\n-                window.headerButtonOverlayProperty().get() instanceof HeaderButtonOverlay overlay) {\n+        if (getWindow() instanceof WinWindow window) {\n@@ -137,1 +137,2 @@\n-            if (overlay.handleMouseEvent(type, button, wx, wy)) {\n+            if (window.headerButtonOverlayProperty().get() instanceof HeaderButtonOverlay overlay\n+                    && overlay.handleMouseEvent(type, button, wx, wy)) {\n@@ -140,0 +141,8 @@\n+\n+            if (window.isResizable()\n+                    && clickCount == 2\n+                    && type == MouseEvent.DOWN\n+                    && getEventHandler() instanceof View.EventHandler eventHandler\n+                    && eventHandler.pickHeaderArea(wx, wy) == HeaderAreaType.DRAGBAR) {\n+                window.maximize(!window.isMaximized());\n+            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinView.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -631,0 +631,4 @@\n+    if (m_isExtended && HandleCaptionMouseEvents(msg, wParam, lParam)) {\n+        return true;\n+    }\n+\n@@ -647,0 +651,88 @@\n+\/*\n+ * This method is only called for windows with the EXTENDED style to handle a press-drag-release interaction\n+ * on the title bar, which will move the window. Ordinarily, this wouldn't be required at all, since correctly\n+ * responding to the WM_NCHITTEST message tells Windows which part of our window it should treat as the title\n+ * bar area; this automatically enables the press-drag-release interaction.\n+ *\n+ * However, there's a small problem with serious consequences: Windows will send us a WM_NCLBUTTONDOWN message\n+ * when the mouse button is pressed on the title bar, but it will NOT send us a WM_NCLBUTTONUP message when the\n+ * button is released again. Pressing the mouse button on the title bar area starts a move-modal message loop,\n+ * and the corresponding WM_LBUTTONUP (NB: not WM_NCLBUTTONUP) event is handled inside of this modal loop;\n+ * it doesn't arrive at the message loop in this class where we could react to it. This is a problem because\n+ * JavaFX has its own press-drag-release detection in the Scene class, and this missing release event messes\n+ * up its state.\n+ *\n+ * So, how can we still get a notification when the mouse button was released on the title bar? For future\n+ * reference, here are potential solutions that don't work well for various reasons:\n+ *\n+ * 1. Listen to WM_ENTERSIZEMOVE\/WM_EXITSIZEMOVE, which are posted at the beginning and the end of a PDR\n+ *    interaction. Unfortunately, a single short click on the title bar doesn't count as a PDR interaction,\n+ *    and none of the messages are posted. Interestingly, a single click with about a one-second delay between\n+ *    press and release does count as a PDR interaction.\n+ *\n+ * 2. Install a WH_MOUSE hook to intercept mouse messages before they are posted to the move-modal message loop,\n+ *    and use it to discover the \"missing\" WM_LBUTTONUP message. While this works, some anti-virus tools might\n+ *    dislike us using the SetWindowsHookEx API.\n+ *\n+ * What seems to work best is to not rely on Windows to start the move-modal message loop for us, but to start\n+ * it ourselves. When it returns, we know that the mouse button was released. The prerequisite for this solution\n+ * is that we never tell Windows that the cursor is on the title bar area, as Windows would then invariably start\n+ * the move-modal message loop. So every time we determine in HandleNCHitTestEvent() that the cursor is on the\n+ * title bar, we tell Windows that it's HTCLIENT instead.\n+ *\/\n+bool GlassWindow::HandleCaptionMouseEvents(UINT msg, WPARAM wParam, LPARAM lParam)\n+{\n+    switch (msg) {\n+        \/\/ Pressing the left mouse button on the title bar area initializes PDR tracking.\n+        \/\/ We don't consume this message, so it will be handled as usual in HandleViewMouseEvent()\n+        \/\/ to generate a normal JavaFX event. Note that HandleViewMouseEvent() calls SetCapture().\n+        case WM_LBUTTONDOWN:\n+            if (m_caption.entered) {\n+                m_caption.tracking = true;\n+                m_caption.dragStart = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };\n+            }\n+            break;\n+\n+        \/\/ Releasing the left mouse button without moving the cursor cancels PDR tracking.\n+        \/\/ We don't consume this message, so it will be handled as usual in HandleViewMouseEvent()\n+        \/\/ to generate a normal JavaFX event.\n+        case WM_LBUTTONUP:\n+            if (m_caption.tracking && GetCapture() == GetHWND()) {\n+                m_caption.tracking = false;\n+            }\n+            break;\n+\n+        \/\/ Moving the cursor starts up a modal message loop that handles the window movement.\n+        \/\/ Note that we only start the window drag operation when the cursor movement exceeds the\n+        \/\/ minimum distance for a PDR interaction.\n+        case WM_MOUSEMOVE:\n+            if (m_caption.tracking && GetCapture() == GetHWND()) {\n+                POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };\n+                const int dx = abs(pt.x - m_caption.dragStart.x);\n+                const int dy = abs(pt.y - m_caption.dragStart.y);\n+                const int cx = GetSystemMetrics(SM_CXDRAG);\n+                const int cy = GetSystemMetrics(SM_CYDRAG);\n+\n+                if (dx >= cx || dy >= cy) {\n+                    \/\/ Start the move-modal message loop, and return when the drag operation has finished.\n+                    ReleaseCapture();\n+                    SendMessage(GetHWND(), WM_SYSCOMMAND, SC_MOVE | HTCAPTION, 0);\n+\n+                    \/\/ Cancel tracking and synthesize a WM_LBUTTONUP event.\n+                    m_caption.tracking = false;\n+                    HandleViewMouseEvent(GetHWND(), WM_LBUTTONUP, wParam, lParam, true);\n+                    return true;\n+                }\n+            }\n+            break;\n+\n+        \/\/ Cancel tracking when an in-progress PDR interaction is canceled.\n+        case WM_CANCELMODE:\n+        case WM_CAPTURECHANGED:\n+            m_caption.tracking = false;\n+            break;\n+    }\n+\n+    return false;\n+}\n+\n@@ -964,0 +1056,7 @@\n+    \/\/ If the cursor is on the title bar, lie to Windows and say it's on the client area instead.\n+    \/\/ See GlassWindow::HandleCaptionMouseEvents() for more information.\n+    m_caption.entered = res == HTCAPTION;\n+    if (res == HTCAPTION) {\n+        res = HTCLIENT;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.cpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,0 +164,6 @@\n+    struct {\n+        bool entered = false;\n+        bool tracking = false;\n+        POINT dragStart = {};\n+    } m_caption;\n+\n@@ -192,0 +198,1 @@\n+    bool HandleCaptionMouseEvents(UINT msg, WPARAM wParam, LPARAM lParam);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassWindow.h","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}