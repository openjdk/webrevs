{"files":[{"patch":"@@ -1,1776 +0,0 @@\n-\/*\n- * legacy.c: set of deprecated routines, not to be used anymore but\n- *           kept purely for ABI compatibility\n- *\n- * See Copyright for the status of this software.\n- *\n- * daniel@veillard.com\n- *\/\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-\n-#ifdef LIBXML_LEGACY_ENABLED\n-#include <stdio.h>\n-#include <string.h>\n-\n-#include <libxml\/tree.h>\n-#include <libxml\/entities.h>\n-#include <libxml\/SAX.h>\n-#include <libxml\/parserInternals.h>\n-#include <libxml\/HTMLparser.h>\n-\n-void xmlUpgradeOldNs(xmlDocPtr doc);\n-\n-\/************************************************************************\n- *\t\t\t\t\t\t\t\t\t*\n- *\t\tDeprecated functions kept for compatibility\t\t*\n- *\t\t\t\t\t\t\t\t\t*\n- ************************************************************************\/\n-\n-#ifdef LIBXML_HTML_ENABLED\n-xmlChar *htmlDecodeEntities(htmlParserCtxtPtr ctxt, int len, xmlChar end,\n-                            xmlChar end2, xmlChar end3);\n-\n-\/**\n- * htmlDecodeEntities:\n- * @ctxt:  the parser context\n- * @len:  the len to decode (in bytes !), -1 for no size limit\n- * @end:  an end marker xmlChar, 0 if none\n- * @end2:  an end marker xmlChar, 0 if none\n- * @end3:  an end marker xmlChar, 0 if none\n- *\n- * Substitute the HTML entities by their value\n- *\n- * DEPRECATED !!!!\n- *\n- * Returns A newly allocated string with the substitution done. The caller\n- *      must deallocate it !\n- *\/\n-xmlChar *\n-htmlDecodeEntities(htmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-                   int len ATTRIBUTE_UNUSED, xmlChar end ATTRIBUTE_UNUSED,\n-                   xmlChar end2 ATTRIBUTE_UNUSED,\n-                   xmlChar end3 ATTRIBUTE_UNUSED)\n-{\n-    static int deprecated = 0;\n-\n-    if (!deprecated) {\n-        fprintf(stderr,\n-                        \"htmlDecodeEntities() deprecated function reached\\n\");\n-        deprecated = 1;\n-    }\n-    return (NULL);\n-}\n-#endif\n-\n-\/**\n- * xmlInitializePredefinedEntities:\n- *\n- * Set up the predefined entities.\n- * Deprecated call\n- *\/\n-void\n-xmlInitializePredefinedEntities(void)\n-{\n-}\n-\n-\/**\n- * xmlCleanupPredefinedEntities:\n- *\n- * Cleanup up the predefined entities table.\n- * Deprecated call\n- *\/\n-void\n-xmlCleanupPredefinedEntities(void)\n-{\n-}\n-\n-static const char* const xmlFeaturesList[] = {\n-    \"validate\",\n-    \"load subset\",\n-    \"keep blanks\",\n-    \"disable SAX\",\n-    \"fetch external entities\",\n-    \"substitute entities\",\n-    \"gather line info\",\n-    \"user data\",\n-    \"is html\",\n-    \"is standalone\",\n-    \"stop parser\",\n-    \"document\",\n-    \"is well formed\",\n-    \"is valid\",\n-    \"SAX block\",\n-    \"SAX function internalSubset\",\n-    \"SAX function isStandalone\",\n-    \"SAX function hasInternalSubset\",\n-    \"SAX function hasExternalSubset\",\n-    \"SAX function resolveEntity\",\n-    \"SAX function getEntity\",\n-    \"SAX function entityDecl\",\n-    \"SAX function notationDecl\",\n-    \"SAX function attributeDecl\",\n-    \"SAX function elementDecl\",\n-    \"SAX function unparsedEntityDecl\",\n-    \"SAX function setDocumentLocator\",\n-    \"SAX function startDocument\",\n-    \"SAX function endDocument\",\n-    \"SAX function startElement\",\n-    \"SAX function endElement\",\n-    \"SAX function reference\",\n-    \"SAX function characters\",\n-    \"SAX function ignorableWhitespace\",\n-    \"SAX function processingInstruction\",\n-    \"SAX function comment\",\n-    \"SAX function warning\",\n-    \"SAX function error\",\n-    \"SAX function fatalError\",\n-    \"SAX function getParameterEntity\",\n-    \"SAX function cdataBlock\",\n-    \"SAX function externalSubset\",\n-};\n-\n-\/**\n- * xmlGetFeaturesList:\n- * @len:  the length of the features name array (input\/output)\n- * @result:  an array of string to be filled with the features name.\n- *\n- * Copy at most *@len feature names into the @result array\n- *\n- * Returns -1 in case or error, or the total number of features,\n- *            len is updated with the number of strings copied,\n- *            strings must not be deallocated\n- *\/\n-int\n-xmlGetFeaturesList(int *len, const char **result)\n-{\n-    int ret, i;\n-\n-    ret = sizeof(xmlFeaturesList) \/ sizeof(xmlFeaturesList[0]);\n-    if ((len == NULL) || (result == NULL))\n-        return (ret);\n-    if ((*len < 0) || (*len >= 1000))\n-        return (-1);\n-    if (*len > ret)\n-        *len = ret;\n-    for (i = 0; i < *len; i++)\n-        result[i] = xmlFeaturesList[i];\n-    return (ret);\n-}\n-\n-\/**\n- * xmlGetFeature:\n- * @ctxt:  an XML\/HTML parser context\n- * @name:  the feature name\n- * @result:  location to store the result\n- *\n- * Read the current value of one feature of this parser instance\n- *\n- * Returns -1 in case or error, 0 otherwise\n- *\/\n-int\n-xmlGetFeature(xmlParserCtxtPtr ctxt, const char *name, void *result)\n-{\n-    if ((ctxt == NULL) || (name == NULL) || (result == NULL))\n-        return (-1);\n-\n-    if (!strcmp(name, \"validate\")) {\n-        *((int *) result) = ctxt->validate;\n-    } else if (!strcmp(name, \"keep blanks\")) {\n-        *((int *) result) = ctxt->keepBlanks;\n-    } else if (!strcmp(name, \"disable SAX\")) {\n-        *((int *) result) = ctxt->disableSAX;\n-    } else if (!strcmp(name, \"fetch external entities\")) {\n-        *((int *) result) = ctxt->loadsubset;\n-    } else if (!strcmp(name, \"substitute entities\")) {\n-        *((int *) result) = ctxt->replaceEntities;\n-    } else if (!strcmp(name, \"gather line info\")) {\n-        *((int *) result) = ctxt->record_info;\n-    } else if (!strcmp(name, \"user data\")) {\n-        *((void **) result) = ctxt->userData;\n-    } else if (!strcmp(name, \"is html\")) {\n-        *((int *) result) = ctxt->html;\n-    } else if (!strcmp(name, \"is standalone\")) {\n-        *((int *) result) = ctxt->standalone;\n-    } else if (!strcmp(name, \"document\")) {\n-        *((xmlDocPtr *) result) = ctxt->myDoc;\n-    } else if (!strcmp(name, \"is well formed\")) {\n-        *((int *) result) = ctxt->wellFormed;\n-    } else if (!strcmp(name, \"is valid\")) {\n-        *((int *) result) = ctxt->valid;\n-    } else if (!strcmp(name, \"SAX block\")) {\n-        *((xmlSAXHandlerPtr *) result) = ctxt->sax;\n-    } else if (!strcmp(name, \"SAX function internalSubset\")) {\n-        *((internalSubsetSAXFunc *) result) = ctxt->sax->internalSubset;\n-    } else if (!strcmp(name, \"SAX function isStandalone\")) {\n-        *((isStandaloneSAXFunc *) result) = ctxt->sax->isStandalone;\n-    } else if (!strcmp(name, \"SAX function hasInternalSubset\")) {\n-        *((hasInternalSubsetSAXFunc *) result) =\n-            ctxt->sax->hasInternalSubset;\n-    } else if (!strcmp(name, \"SAX function hasExternalSubset\")) {\n-        *((hasExternalSubsetSAXFunc *) result) =\n-            ctxt->sax->hasExternalSubset;\n-    } else if (!strcmp(name, \"SAX function resolveEntity\")) {\n-        *((resolveEntitySAXFunc *) result) = ctxt->sax->resolveEntity;\n-    } else if (!strcmp(name, \"SAX function getEntity\")) {\n-        *((getEntitySAXFunc *) result) = ctxt->sax->getEntity;\n-    } else if (!strcmp(name, \"SAX function entityDecl\")) {\n-        *((entityDeclSAXFunc *) result) = ctxt->sax->entityDecl;\n-    } else if (!strcmp(name, \"SAX function notationDecl\")) {\n-        *((notationDeclSAXFunc *) result) = ctxt->sax->notationDecl;\n-    } else if (!strcmp(name, \"SAX function attributeDecl\")) {\n-        *((attributeDeclSAXFunc *) result) = ctxt->sax->attributeDecl;\n-    } else if (!strcmp(name, \"SAX function elementDecl\")) {\n-        *((elementDeclSAXFunc *) result) = ctxt->sax->elementDecl;\n-    } else if (!strcmp(name, \"SAX function unparsedEntityDecl\")) {\n-        *((unparsedEntityDeclSAXFunc *) result) =\n-            ctxt->sax->unparsedEntityDecl;\n-    } else if (!strcmp(name, \"SAX function setDocumentLocator\")) {\n-        *((setDocumentLocatorSAXFunc *) result) =\n-            ctxt->sax->setDocumentLocator;\n-    } else if (!strcmp(name, \"SAX function startDocument\")) {\n-        *((startDocumentSAXFunc *) result) = ctxt->sax->startDocument;\n-    } else if (!strcmp(name, \"SAX function endDocument\")) {\n-        *((endDocumentSAXFunc *) result) = ctxt->sax->endDocument;\n-    } else if (!strcmp(name, \"SAX function startElement\")) {\n-        *((startElementSAXFunc *) result) = ctxt->sax->startElement;\n-    } else if (!strcmp(name, \"SAX function endElement\")) {\n-        *((endElementSAXFunc *) result) = ctxt->sax->endElement;\n-    } else if (!strcmp(name, \"SAX function reference\")) {\n-        *((referenceSAXFunc *) result) = ctxt->sax->reference;\n-    } else if (!strcmp(name, \"SAX function characters\")) {\n-        *((charactersSAXFunc *) result) = ctxt->sax->characters;\n-    } else if (!strcmp(name, \"SAX function ignorableWhitespace\")) {\n-        *((ignorableWhitespaceSAXFunc *) result) =\n-            ctxt->sax->ignorableWhitespace;\n-    } else if (!strcmp(name, \"SAX function processingInstruction\")) {\n-        *((processingInstructionSAXFunc *) result) =\n-            ctxt->sax->processingInstruction;\n-    } else if (!strcmp(name, \"SAX function comment\")) {\n-        *((commentSAXFunc *) result) = ctxt->sax->comment;\n-    } else if (!strcmp(name, \"SAX function warning\")) {\n-        *((warningSAXFunc *) result) = ctxt->sax->warning;\n-    } else if (!strcmp(name, \"SAX function error\")) {\n-        *((errorSAXFunc *) result) = ctxt->sax->error;\n-    } else if (!strcmp(name, \"SAX function fatalError\")) {\n-        *((fatalErrorSAXFunc *) result) = ctxt->sax->fatalError;\n-    } else if (!strcmp(name, \"SAX function getParameterEntity\")) {\n-        *((getParameterEntitySAXFunc *) result) =\n-            ctxt->sax->getParameterEntity;\n-    } else if (!strcmp(name, \"SAX function cdataBlock\")) {\n-        *((cdataBlockSAXFunc *) result) = ctxt->sax->cdataBlock;\n-    } else if (!strcmp(name, \"SAX function externalSubset\")) {\n-        *((externalSubsetSAXFunc *) result) = ctxt->sax->externalSubset;\n-    } else {\n-        return (-1);\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlSetFeature:\n- * @ctxt:  an XML\/HTML parser context\n- * @name:  the feature name\n- * @value:  pointer to the location of the new value\n- *\n- * Change the current value of one feature of this parser instance\n- *\n- * Returns -1 in case or error, 0 otherwise\n- *\/\n-int\n-xmlSetFeature(xmlParserCtxtPtr ctxt, const char *name, void *value)\n-{\n-    if ((ctxt == NULL) || (name == NULL) || (value == NULL))\n-        return (-1);\n-\n-    if (!strcmp(name, \"validate\")) {\n-        int newvalidate = *((int *) value);\n-\n-        if ((!ctxt->validate) && (newvalidate != 0)) {\n-            if (ctxt->vctxt.warning == NULL)\n-                ctxt->vctxt.warning = xmlParserValidityWarning;\n-            if (ctxt->vctxt.error == NULL)\n-                ctxt->vctxt.error = xmlParserValidityError;\n-            ctxt->vctxt.nodeMax = 0;\n-        }\n-        ctxt->validate = newvalidate;\n-    } else if (!strcmp(name, \"keep blanks\")) {\n-        ctxt->keepBlanks = *((int *) value);\n-    } else if (!strcmp(name, \"disable SAX\")) {\n-        ctxt->disableSAX = *((int *) value);\n-    } else if (!strcmp(name, \"fetch external entities\")) {\n-        ctxt->loadsubset = *((int *) value);\n-    } else if (!strcmp(name, \"substitute entities\")) {\n-        ctxt->replaceEntities = *((int *) value);\n-    } else if (!strcmp(name, \"gather line info\")) {\n-        ctxt->record_info = *((int *) value);\n-    } else if (!strcmp(name, \"user data\")) {\n-        ctxt->userData = *((void **) value);\n-    } else if (!strcmp(name, \"is html\")) {\n-        ctxt->html = *((int *) value);\n-    } else if (!strcmp(name, \"is standalone\")) {\n-        ctxt->standalone = *((int *) value);\n-    } else if (!strcmp(name, \"document\")) {\n-        ctxt->myDoc = *((xmlDocPtr *) value);\n-    } else if (!strcmp(name, \"is well formed\")) {\n-        ctxt->wellFormed = *((int *) value);\n-    } else if (!strcmp(name, \"is valid\")) {\n-        ctxt->valid = *((int *) value);\n-    } else if (!strcmp(name, \"SAX block\")) {\n-        ctxt->sax = *((xmlSAXHandlerPtr *) value);\n-    } else if (!strcmp(name, \"SAX function internalSubset\")) {\n-        ctxt->sax->internalSubset = *((internalSubsetSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function isStandalone\")) {\n-        ctxt->sax->isStandalone = *((isStandaloneSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function hasInternalSubset\")) {\n-        ctxt->sax->hasInternalSubset =\n-            *((hasInternalSubsetSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function hasExternalSubset\")) {\n-        ctxt->sax->hasExternalSubset =\n-            *((hasExternalSubsetSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function resolveEntity\")) {\n-        ctxt->sax->resolveEntity = *((resolveEntitySAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function getEntity\")) {\n-        ctxt->sax->getEntity = *((getEntitySAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function entityDecl\")) {\n-        ctxt->sax->entityDecl = *((entityDeclSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function notationDecl\")) {\n-        ctxt->sax->notationDecl = *((notationDeclSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function attributeDecl\")) {\n-        ctxt->sax->attributeDecl = *((attributeDeclSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function elementDecl\")) {\n-        ctxt->sax->elementDecl = *((elementDeclSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function unparsedEntityDecl\")) {\n-        ctxt->sax->unparsedEntityDecl =\n-            *((unparsedEntityDeclSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function setDocumentLocator\")) {\n-        ctxt->sax->setDocumentLocator =\n-            *((setDocumentLocatorSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function startDocument\")) {\n-        ctxt->sax->startDocument = *((startDocumentSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function endDocument\")) {\n-        ctxt->sax->endDocument = *((endDocumentSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function startElement\")) {\n-        ctxt->sax->startElement = *((startElementSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function endElement\")) {\n-        ctxt->sax->endElement = *((endElementSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function reference\")) {\n-        ctxt->sax->reference = *((referenceSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function characters\")) {\n-        ctxt->sax->characters = *((charactersSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function ignorableWhitespace\")) {\n-        ctxt->sax->ignorableWhitespace =\n-            *((ignorableWhitespaceSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function processingInstruction\")) {\n-        ctxt->sax->processingInstruction =\n-            *((processingInstructionSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function comment\")) {\n-        ctxt->sax->comment = *((commentSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function warning\")) {\n-        ctxt->sax->warning = *((warningSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function error\")) {\n-        ctxt->sax->error = *((errorSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function fatalError\")) {\n-        ctxt->sax->fatalError = *((fatalErrorSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function getParameterEntity\")) {\n-        ctxt->sax->getParameterEntity =\n-            *((getParameterEntitySAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function cdataBlock\")) {\n-        ctxt->sax->cdataBlock = *((cdataBlockSAXFunc *) value);\n-    } else if (!strcmp(name, \"SAX function externalSubset\")) {\n-        ctxt->sax->externalSubset = *((externalSubsetSAXFunc *) value);\n-    } else {\n-        return (-1);\n-    }\n-    return (0);\n-}\n-\n-\/**\n- * xmlDecodeEntities:\n- * @ctxt:  the parser context\n- * @len:  the len to decode (in bytes !), -1 for no size limit\n- * @what:  combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF\n- * @end:  an end marker xmlChar, 0 if none\n- * @end2:  an end marker xmlChar, 0 if none\n- * @end3:  an end marker xmlChar, 0 if none\n- *\n- * This function is deprecated, we now always process entities content\n- * through xmlStringDecodeEntities\n- *\n- * TODO: remove it in next major release.\n- *\n- * [67] Reference ::= EntityRef | CharRef\n- *\n- * [69] PEReference ::= '%' Name ';'\n- *\n- * Returns A newly allocated string with the substitution done. The caller\n- *      must deallocate it !\n- *\/\n-xmlChar *\n-xmlDecodeEntities(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-                  int len ATTRIBUTE_UNUSED, int what ATTRIBUTE_UNUSED,\n-                  xmlChar end ATTRIBUTE_UNUSED,\n-                  xmlChar end2 ATTRIBUTE_UNUSED,\n-                  xmlChar end3 ATTRIBUTE_UNUSED)\n-{\n-    static int deprecated = 0;\n-\n-    if (!deprecated) {\n-        fprintf(stderr,\n-                        \"xmlDecodeEntities() deprecated function reached\\n\");\n-        deprecated = 1;\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlNamespaceParseNCName:\n- * @ctxt:  an XML parser context\n- *\n- * parse an XML namespace name.\n- *\n- * TODO: this seems not in use anymore, the namespace handling is done on\n- *       top of the SAX interfaces, i.e. not on raw input.\n- *\n- * [NS 3] NCName ::= (Letter | '_') (NCNameChar)*\n- *\n- * [NS 4] NCNameChar ::= Letter | Digit | '.' | '-' | '_' |\n- *                       CombiningChar | Extender\n- *\n- * Returns the namespace name or NULL\n- *\/\n-\n-xmlChar *\n-xmlNamespaceParseNCName(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED)\n-{\n-    static int deprecated = 0;\n-\n-    if (!deprecated) {\n-        fprintf(stderr,\n-                        \"xmlNamespaceParseNCName() deprecated function reached\\n\");\n-        deprecated = 1;\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlNamespaceParseQName:\n- * @ctxt:  an XML parser context\n- * @prefix:  a xmlChar **\n- *\n- * TODO: this seems not in use anymore, the namespace handling is done on\n- *       top of the SAX interfaces, i.e. not on raw input.\n- *\n- * parse an XML qualified name\n- *\n- * [NS 5] QName ::= (Prefix ':')? LocalPart\n- *\n- * [NS 6] Prefix ::= NCName\n- *\n- * [NS 7] LocalPart ::= NCName\n- *\n- * Returns the local part, and prefix is updated\n- *   to get the Prefix if any.\n- *\/\n-\n-xmlChar *\n-xmlNamespaceParseQName(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-                       xmlChar ** prefix ATTRIBUTE_UNUSED)\n-{\n-\n-    static int deprecated = 0;\n-\n-    if (!deprecated) {\n-        fprintf(stderr,\n-                        \"xmlNamespaceParseQName() deprecated function reached\\n\");\n-        deprecated = 1;\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlNamespaceParseNSDef:\n- * @ctxt:  an XML parser context\n- *\n- * parse a namespace prefix declaration\n- *\n- * TODO: this seems not in use anymore, the namespace handling is done on\n- *       top of the SAX interfaces, i.e. not on raw input.\n- *\n- * [NS 1] NSDef ::= PrefixDef Eq SystemLiteral\n- *\n- * [NS 2] PrefixDef ::= 'xmlns' (':' NCName)?\n- *\n- * Returns the namespace name\n- *\/\n-\n-xmlChar *\n-xmlNamespaceParseNSDef(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED)\n-{\n-    static int deprecated = 0;\n-\n-    if (!deprecated) {\n-        fprintf(stderr,\n-                        \"xmlNamespaceParseNSDef() deprecated function reached\\n\");\n-        deprecated = 1;\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlParseQuotedString:\n- * @ctxt:  an XML parser context\n- *\n- * Parse and return a string between quotes or doublequotes\n- *\n- * TODO: Deprecated, to  be removed at next drop of binary compatibility\n- *\n- * Returns the string parser or NULL.\n- *\/\n-xmlChar *\n-xmlParseQuotedString(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED)\n-{\n-    static int deprecated = 0;\n-\n-    if (!deprecated) {\n-        fprintf(stderr,\n-                        \"xmlParseQuotedString() deprecated function reached\\n\");\n-        deprecated = 1;\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlParseNamespace:\n- * @ctxt:  an XML parser context\n- *\n- * xmlParseNamespace: parse specific PI '<?namespace ...' constructs.\n- *\n- * This is what the older xml-name Working Draft specified, a bunch of\n- * other stuff may still rely on it, so support is still here as\n- * if it was declared on the root of the Tree:-(\n- *\n- * TODO: remove from library\n- *\n- * To be removed at next drop of binary compatibility\n- *\/\n-\n-void\n-xmlParseNamespace(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED)\n-{\n-    static int deprecated = 0;\n-\n-    if (!deprecated) {\n-        fprintf(stderr,\n-                        \"xmlParseNamespace() deprecated function reached\\n\");\n-        deprecated = 1;\n-    }\n-}\n-\n-\/**\n- * xmlScanName:\n- * @ctxt:  an XML parser context\n- *\n- * Trickery: parse an XML name but without consuming the input flow\n- * Needed for rollback cases. Used only when parsing entities references.\n- *\n- * TODO: seems deprecated now, only used in the default part of\n- *       xmlParserHandleReference\n- *\n- * [4] NameChar ::= Letter | Digit | '.' | '-' | '_' | ':' |\n- *                  CombiningChar | Extender\n- *\n- * [5] Name ::= (Letter | '_' | ':') (NameChar)*\n- *\n- * [6] Names ::= Name (S Name)*\n- *\n- * Returns the Name parsed or NULL\n- *\/\n-\n-xmlChar *\n-xmlScanName(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED)\n-{\n-    static int deprecated = 0;\n-\n-    if (!deprecated) {\n-        fprintf(stderr,\n-                        \"xmlScanName() deprecated function reached\\n\");\n-        deprecated = 1;\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlParserHandleReference:\n- * @ctxt:  the parser context\n- *\n- * TODO: Remove, now deprecated ... the test is done directly in the\n- *       content parsing\n- * routines.\n- *\n- * [67] Reference ::= EntityRef | CharRef\n- *\n- * [68] EntityRef ::= '&' Name ';'\n- *\n- * [ WFC: Entity Declared ]\n- * the Name given in the entity reference must match that in an entity\n- * declaration, except that well-formed documents need not declare any\n- * of the following entities: amp, lt, gt, apos, quot.\n- *\n- * [ WFC: Parsed Entity ]\n- * An entity reference must not contain the name of an unparsed entity\n- *\n- * [66] CharRef ::= '&#' [0-9]+ ';' |\n- *                  '&#x' [0-9a-fA-F]+ ';'\n- *\n- * A PEReference may have been detected in the current input stream\n- * the handling is done accordingly to\n- *      http:\/\/www.w3.org\/TR\/REC-xml#entproc\n- *\/\n-void\n-xmlParserHandleReference(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED)\n-{\n-    static int deprecated = 0;\n-\n-    if (!deprecated) {\n-        fprintf(stderr,\n-                        \"xmlParserHandleReference() deprecated function reached\\n\");\n-        deprecated = 1;\n-    }\n-\n-    return;\n-}\n-\n-\/**\n- * xmlHandleEntity:\n- * @ctxt:  an XML parser context\n- * @entity:  an XML entity pointer.\n- *\n- * Default handling of defined entities, when should we define a new input\n- * stream ? When do we just handle that as a set of chars ?\n- *\n- * OBSOLETE: to be removed at some point.\n- *\/\n-\n-void\n-xmlHandleEntity(xmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-                xmlEntityPtr entity ATTRIBUTE_UNUSED)\n-{\n-    static int deprecated = 0;\n-\n-    if (!deprecated) {\n-        fprintf(stderr,\n-                        \"xmlHandleEntity() deprecated function reached\\n\");\n-        deprecated = 1;\n-    }\n-}\n-\n-\/**\n- * xmlNewGlobalNs:\n- * @doc:  the document carrying the namespace\n- * @href:  the URI associated\n- * @prefix:  the prefix for the namespace\n- *\n- * Creation of a Namespace, the old way using PI and without scoping\n- *   DEPRECATED !!!\n- * Returns NULL this functionality had been removed\n- *\/\n-xmlNsPtr\n-xmlNewGlobalNs(xmlDocPtr doc ATTRIBUTE_UNUSED,\n-               const xmlChar * href ATTRIBUTE_UNUSED,\n-               const xmlChar * prefix ATTRIBUTE_UNUSED)\n-{\n-    static int deprecated = 0;\n-\n-    if (!deprecated) {\n-        fprintf(stderr,\n-                        \"xmlNewGlobalNs() deprecated function reached\\n\");\n-        deprecated = 1;\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlUpgradeOldNs:\n- * @doc:  a document pointer\n- *\n- * Upgrade old style Namespaces (PI) and move them to the root of the document.\n- * DEPRECATED\n- *\/\n-void\n-xmlUpgradeOldNs(xmlDocPtr doc ATTRIBUTE_UNUSED)\n-{\n-    static int deprecated = 0;\n-\n-    if (!deprecated) {\n-        fprintf(stderr,\n-                        \"xmlUpgradeOldNs() deprecated function reached\\n\");\n-        deprecated = 1;\n-    }\n-}\n-\n-\/**\n- * xmlEncodeEntities:\n- * @doc:  the document containing the string\n- * @input:  A string to convert to XML.\n- *\n- * TODO: remove xmlEncodeEntities, once we are not afraid of breaking binary\n- *       compatibility\n- *\n- * People must migrate their code to xmlEncodeEntitiesReentrant !\n- * This routine will issue a warning when encountered.\n- *\n- * Returns NULL\n- *\/\n-const xmlChar *\n-xmlEncodeEntities(xmlDocPtr doc ATTRIBUTE_UNUSED,\n-                  const xmlChar * input ATTRIBUTE_UNUSED)\n-{\n-    static int warning = 1;\n-\n-    if (warning) {\n-        fprintf(stderr,\n-                        \"Deprecated API xmlEncodeEntities() used\\n\");\n-        fprintf(stderr,\n-                        \"   change code to use xmlEncodeEntitiesReentrant()\\n\");\n-        warning = 0;\n-    }\n-    return (NULL);\n-}\n-\n-\/**\n- * xmlSetEntityReferenceFunc:\n- * @func: A valid function\n- *\n- * Set the function to call call back when a xml reference has been made\n- *\/\n-void\n-xmlSetEntityReferenceFunc(xmlEntityReferenceFunc func ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-\/************************************************************************\n- *\t\t\t\t\t\t\t\t\t*\n- *\t\tOld set of SAXv1 functions\t\t\t\t*\n- *\t\t\t\t\t\t\t\t\t*\n- ************************************************************************\/\n-static int deprecated_v1_msg = 0;\n-\n-#define DEPRECATED(n)\t\t\t\t\t\t\\\n-    if (deprecated_v1_msg == 0)\t\t\t\t\t\\\n-\tfprintf(stderr,\t\t\t\\\n-\t  \"Use of deprecated SAXv1 function %s\\n\", n);\t\t\\\n-    deprecated_v1_msg++;\n-\n-\/**\n- * getPublicId:\n- * @ctx: the user data (XML parser context)\n- *\n- * Provides the public ID e.g. \"-\/\/SGMLSOURCE\/\/DTD DEMO\/\/EN\"\n- * DEPRECATED: use xmlSAX2GetPublicId()\n- *\n- * Returns a xmlChar *\n- *\/\n-const xmlChar *\n-getPublicId(void *ctx)\n-{\n-    DEPRECATED(\"getPublicId\")\n-        return (xmlSAX2GetPublicId(ctx));\n-}\n-\n-\/**\n- * getSystemId:\n- * @ctx: the user data (XML parser context)\n- *\n- * Provides the system ID, basically URL or filename e.g.\n- * http:\/\/www.sgmlsource.com\/dtds\/memo.dtd\n- * DEPRECATED: use xmlSAX2GetSystemId()\n- *\n- * Returns a xmlChar *\n- *\/\n-const xmlChar *\n-getSystemId(void *ctx)\n-{\n-    DEPRECATED(\"getSystemId\")\n-        return (xmlSAX2GetSystemId(ctx));\n-}\n-\n-\/**\n- * getLineNumber:\n- * @ctx: the user data (XML parser context)\n- *\n- * Provide the line number of the current parsing point.\n- * DEPRECATED: use xmlSAX2GetLineNumber()\n- *\n- * Returns an int\n- *\/\n-int\n-getLineNumber(void *ctx)\n-{\n-    DEPRECATED(\"getLineNumber\")\n-        return (xmlSAX2GetLineNumber(ctx));\n-}\n-\n-\/**\n- * getColumnNumber:\n- * @ctx: the user data (XML parser context)\n- *\n- * Provide the column number of the current parsing point.\n- * DEPRECATED: use xmlSAX2GetColumnNumber()\n- *\n- * Returns an int\n- *\/\n-int\n-getColumnNumber(void *ctx)\n-{\n-    DEPRECATED(\"getColumnNumber\")\n-        return (xmlSAX2GetColumnNumber(ctx));\n-}\n-\n-\/**\n- * isStandalone:\n- * @ctx: the user data (XML parser context)\n- *\n- * Is this document tagged standalone ?\n- * DEPRECATED: use xmlSAX2IsStandalone()\n- *\n- * Returns 1 if true\n- *\/\n-int\n-isStandalone(void *ctx)\n-{\n-    DEPRECATED(\"isStandalone\")\n-        return (xmlSAX2IsStandalone(ctx));\n-}\n-\n-\/**\n- * hasInternalSubset:\n- * @ctx: the user data (XML parser context)\n- *\n- * Does this document has an internal subset\n- * DEPRECATED: use xmlSAX2HasInternalSubset()\n- *\n- * Returns 1 if true\n- *\/\n-int\n-hasInternalSubset(void *ctx)\n-{\n-    DEPRECATED(\"hasInternalSubset\")\n-        return (xmlSAX2HasInternalSubset(ctx));\n-}\n-\n-\/**\n- * hasExternalSubset:\n- * @ctx: the user data (XML parser context)\n- *\n- * Does this document has an external subset\n- * DEPRECATED: use xmlSAX2HasExternalSubset()\n- *\n- * Returns 1 if true\n- *\/\n-int\n-hasExternalSubset(void *ctx)\n-{\n-    DEPRECATED(\"hasExternalSubset\")\n-        return (xmlSAX2HasExternalSubset(ctx));\n-}\n-\n-\/**\n- * internalSubset:\n- * @ctx:  the user data (XML parser context)\n- * @name:  the root element name\n- * @ExternalID:  the external ID\n- * @SystemID:  the SYSTEM ID (e.g. filename or URL)\n- *\n- * Callback on internal subset declaration.\n- * DEPRECATED: use xmlSAX2InternalSubset()\n- *\/\n-void\n-internalSubset(void *ctx, const xmlChar * name,\n-               const xmlChar * ExternalID, const xmlChar * SystemID)\n-{\n-    DEPRECATED(\"internalSubset\")\n-        xmlSAX2InternalSubset(ctx, name, ExternalID, SystemID);\n-}\n-\n-\/**\n- * externalSubset:\n- * @ctx: the user data (XML parser context)\n- * @name:  the root element name\n- * @ExternalID:  the external ID\n- * @SystemID:  the SYSTEM ID (e.g. filename or URL)\n- *\n- * Callback on external subset declaration.\n- * DEPRECATED: use xmlSAX2ExternalSubset()\n- *\/\n-void\n-externalSubset(void *ctx, const xmlChar * name,\n-               const xmlChar * ExternalID, const xmlChar * SystemID)\n-{\n-    DEPRECATED(\"externalSubset\")\n-        xmlSAX2ExternalSubset(ctx, name, ExternalID, SystemID);\n-}\n-\n-\/**\n- * resolveEntity:\n- * @ctx: the user data (XML parser context)\n- * @publicId: The public ID of the entity\n- * @systemId: The system ID of the entity\n- *\n- * The entity loader, to control the loading of external entities,\n- * the application can either:\n- *    - override this resolveEntity() callback in the SAX block\n- *    - or better use the xmlSetExternalEntityLoader() function to\n- *      set up it's own entity resolution routine\n- * DEPRECATED: use xmlSAX2ResolveEntity()\n- *\n- * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.\n- *\/\n-xmlParserInputPtr\n-resolveEntity(void *ctx, const xmlChar * publicId,\n-              const xmlChar * systemId)\n-{\n-    DEPRECATED(\"resolveEntity\")\n-        return (xmlSAX2ResolveEntity(ctx, publicId, systemId));\n-}\n-\n-\/**\n- * getEntity:\n- * @ctx: the user data (XML parser context)\n- * @name: The entity name\n- *\n- * Get an entity by name\n- * DEPRECATED: use xmlSAX2GetEntity()\n- *\n- * Returns the xmlEntityPtr if found.\n- *\/\n-xmlEntityPtr\n-getEntity(void *ctx, const xmlChar * name)\n-{\n-    DEPRECATED(\"getEntity\")\n-        return (xmlSAX2GetEntity(ctx, name));\n-}\n-\n-\/**\n- * getParameterEntity:\n- * @ctx: the user data (XML parser context)\n- * @name: The entity name\n- *\n- * Get a parameter entity by name\n- * DEPRECATED: use xmlSAX2GetParameterEntity()\n- *\n- * Returns the xmlEntityPtr if found.\n- *\/\n-xmlEntityPtr\n-getParameterEntity(void *ctx, const xmlChar * name)\n-{\n-    DEPRECATED(\"getParameterEntity\")\n-        return (xmlSAX2GetParameterEntity(ctx, name));\n-}\n-\n-\n-\/**\n- * entityDecl:\n- * @ctx: the user data (XML parser context)\n- * @name:  the entity name\n- * @type:  the entity type\n- * @publicId: The public ID of the entity\n- * @systemId: The system ID of the entity\n- * @content: the entity value (without processing).\n- *\n- * An entity definition has been parsed\n- * DEPRECATED: use xmlSAX2EntityDecl()\n- *\/\n-void\n-entityDecl(void *ctx, const xmlChar * name, int type,\n-           const xmlChar * publicId, const xmlChar * systemId,\n-           xmlChar * content)\n-{\n-    DEPRECATED(\"entityDecl\")\n-        xmlSAX2EntityDecl(ctx, name, type, publicId, systemId, content);\n-}\n-\n-\/**\n- * attributeDecl:\n- * @ctx: the user data (XML parser context)\n- * @elem:  the name of the element\n- * @fullname:  the attribute name\n- * @type:  the attribute type\n- * @def:  the type of default value\n- * @defaultValue: the attribute default value\n- * @tree:  the tree of enumerated value set\n- *\n- * An attribute definition has been parsed\n- * DEPRECATED: use xmlSAX2AttributeDecl()\n- *\/\n-void\n-attributeDecl(void *ctx, const xmlChar * elem, const xmlChar * fullname,\n-              int type, int def, const xmlChar * defaultValue,\n-              xmlEnumerationPtr tree)\n-{\n-    DEPRECATED(\"attributeDecl\")\n-        xmlSAX2AttributeDecl(ctx, elem, fullname, type, def, defaultValue,\n-                             tree);\n-}\n-\n-\/**\n- * elementDecl:\n- * @ctx: the user data (XML parser context)\n- * @name:  the element name\n- * @type:  the element type\n- * @content: the element value tree\n- *\n- * An element definition has been parsed\n- * DEPRECATED: use xmlSAX2ElementDecl()\n- *\/\n-void\n-elementDecl(void *ctx, const xmlChar * name, int type,\n-            xmlElementContentPtr content)\n-{\n-    DEPRECATED(\"elementDecl\")\n-        xmlSAX2ElementDecl(ctx, name, type, content);\n-}\n-\n-\/**\n- * notationDecl:\n- * @ctx: the user data (XML parser context)\n- * @name: The name of the notation\n- * @publicId: The public ID of the entity\n- * @systemId: The system ID of the entity\n- *\n- * What to do when a notation declaration has been parsed.\n- * DEPRECATED: use xmlSAX2NotationDecl()\n- *\/\n-void\n-notationDecl(void *ctx, const xmlChar * name,\n-             const xmlChar * publicId, const xmlChar * systemId)\n-{\n-    DEPRECATED(\"notationDecl\")\n-        xmlSAX2NotationDecl(ctx, name, publicId, systemId);\n-}\n-\n-\/**\n- * unparsedEntityDecl:\n- * @ctx: the user data (XML parser context)\n- * @name: The name of the entity\n- * @publicId: The public ID of the entity\n- * @systemId: The system ID of the entity\n- * @notationName: the name of the notation\n- *\n- * What to do when an unparsed entity declaration is parsed\n- * DEPRECATED: use xmlSAX2UnparsedEntityDecl()\n- *\/\n-void\n-unparsedEntityDecl(void *ctx, const xmlChar * name,\n-                   const xmlChar * publicId, const xmlChar * systemId,\n-                   const xmlChar * notationName)\n-{\n-    DEPRECATED(\"unparsedEntityDecl\")\n-        xmlSAX2UnparsedEntityDecl(ctx, name, publicId, systemId,\n-                                  notationName);\n-}\n-\n-\/**\n- * setDocumentLocator:\n- * @ctx: the user data (XML parser context)\n- * @loc: A SAX Locator\n- *\n- * Receive the document locator at startup, actually xmlDefaultSAXLocator\n- * Everything is available on the context, so this is useless in our case.\n- * DEPRECATED\n- *\/\n-void\n-setDocumentLocator(void *ctx ATTRIBUTE_UNUSED,\n-                   xmlSAXLocatorPtr loc ATTRIBUTE_UNUSED)\n-{\n-    DEPRECATED(\"setDocumentLocator\")\n-}\n-\n-\/**\n- * startDocument:\n- * @ctx: the user data (XML parser context)\n- *\n- * called when the document start being processed.\n- * DEPRECATED: use xmlSAX2StartDocument()\n- *\/\n-void\n-startDocument(void *ctx)\n-{\n-   \/* don't be too painful for glade users *\/\n-   \/*  DEPRECATED(\"startDocument\") *\/\n-        xmlSAX2StartDocument(ctx);\n-}\n-\n-\/**\n- * endDocument:\n- * @ctx: the user data (XML parser context)\n- *\n- * called when the document end has been detected.\n- * DEPRECATED: use xmlSAX2EndDocument()\n- *\/\n-void\n-endDocument(void *ctx)\n-{\n-    DEPRECATED(\"endDocument\")\n-        xmlSAX2EndDocument(ctx);\n-}\n-\n-\/**\n- * attribute:\n- * @ctx: the user data (XML parser context)\n- * @fullname:  The attribute name, including namespace prefix\n- * @value:  The attribute value\n- *\n- * Handle an attribute that has been read by the parser.\n- * The default handling is to convert the attribute into an\n- * DOM subtree and past it in a new xmlAttr element added to\n- * the element.\n- * DEPRECATED: use xmlSAX2Attribute()\n- *\/\n-void\n-attribute(void *ctx ATTRIBUTE_UNUSED,\n-          const xmlChar * fullname ATTRIBUTE_UNUSED,\n-          const xmlChar * value ATTRIBUTE_UNUSED)\n-{\n-    DEPRECATED(\"attribute\")\n-}\n-\n-\/**\n- * startElement:\n- * @ctx: the user data (XML parser context)\n- * @fullname:  The element name, including namespace prefix\n- * @atts:  An array of name\/value attributes pairs, NULL terminated\n- *\n- * called when an opening tag has been processed.\n- * DEPRECATED: use xmlSAX2StartElement()\n- *\/\n-void\n-startElement(void *ctx, const xmlChar * fullname, const xmlChar ** atts)\n-{\n-    xmlSAX2StartElement(ctx, fullname, atts);\n-}\n-\n-\/**\n- * endElement:\n- * @ctx: the user data (XML parser context)\n- * @name:  The element name\n- *\n- * called when the end of an element has been detected.\n- * DEPRECATED: use xmlSAX2EndElement()\n- *\/\n-void\n-endElement(void *ctx, const xmlChar * name ATTRIBUTE_UNUSED)\n-{\n-    DEPRECATED(\"endElement\")\n-    xmlSAX2EndElement(ctx, name);\n-}\n-\n-\/**\n- * reference:\n- * @ctx: the user data (XML parser context)\n- * @name:  The entity name\n- *\n- * called when an entity reference is detected.\n- * DEPRECATED: use xmlSAX2Reference()\n- *\/\n-void\n-reference(void *ctx, const xmlChar * name)\n-{\n-    DEPRECATED(\"reference\")\n-        xmlSAX2Reference(ctx, name);\n-}\n-\n-\/**\n- * characters:\n- * @ctx: the user data (XML parser context)\n- * @ch:  a xmlChar string\n- * @len: the number of xmlChar\n- *\n- * receiving some chars from the parser.\n- * DEPRECATED: use xmlSAX2Characters()\n- *\/\n-void\n-characters(void *ctx, const xmlChar * ch, int len)\n-{\n-    DEPRECATED(\"characters\")\n-        xmlSAX2Characters(ctx, ch, len);\n-}\n-\n-\/**\n- * ignorableWhitespace:\n- * @ctx: the user data (XML parser context)\n- * @ch:  a xmlChar string\n- * @len: the number of xmlChar\n- *\n- * receiving some ignorable whitespaces from the parser.\n- * UNUSED: by default the DOM building will use characters\n- * DEPRECATED: use xmlSAX2IgnorableWhitespace()\n- *\/\n-void\n-ignorableWhitespace(void *ctx ATTRIBUTE_UNUSED,\n-                    const xmlChar * ch ATTRIBUTE_UNUSED,\n-                    int len ATTRIBUTE_UNUSED)\n-{\n-    DEPRECATED(\"ignorableWhitespace\")\n-}\n-\n-\/**\n- * processingInstruction:\n- * @ctx: the user data (XML parser context)\n- * @target:  the target name\n- * @data: the PI data's\n- *\n- * A processing instruction has been parsed.\n- * DEPRECATED: use xmlSAX2ProcessingInstruction()\n- *\/\n-void\n-processingInstruction(void *ctx, const xmlChar * target,\n-                      const xmlChar * data)\n-{\n-    DEPRECATED(\"processingInstruction\")\n-        xmlSAX2ProcessingInstruction(ctx, target, data);\n-}\n-\n-\/**\n- * globalNamespace:\n- * @ctx: the user data (XML parser context)\n- * @href:  the namespace associated URN\n- * @prefix: the namespace prefix\n- *\n- * An old global namespace has been parsed.\n- * DEPRECATED\n- *\/\n-void\n-globalNamespace(void *ctx ATTRIBUTE_UNUSED,\n-                const xmlChar * href ATTRIBUTE_UNUSED,\n-                const xmlChar * prefix ATTRIBUTE_UNUSED)\n-{\n-    DEPRECATED(\"globalNamespace\")\n-}\n-\n-\/**\n- * setNamespace:\n- * @ctx: the user data (XML parser context)\n- * @name:  the namespace prefix\n- *\n- * Set the current element namespace.\n- * DEPRECATED\n- *\/\n-\n-void\n-setNamespace(void *ctx ATTRIBUTE_UNUSED,\n-             const xmlChar * name ATTRIBUTE_UNUSED)\n-{\n-    DEPRECATED(\"setNamespace\")\n-}\n-\n-\/**\n- * getNamespace:\n- * @ctx: the user data (XML parser context)\n- *\n- * Get the current element namespace.\n- * DEPRECATED\n- *\n- * Returns the xmlNsPtr or NULL if none\n- *\/\n-\n-xmlNsPtr\n-getNamespace(void *ctx ATTRIBUTE_UNUSED)\n-{\n-    DEPRECATED(\"getNamespace\")\n-        return (NULL);\n-}\n-\n-\/**\n- * checkNamespace:\n- * @ctx: the user data (XML parser context)\n- * @namespace: the namespace to check against\n- *\n- * Check that the current element namespace is the same as the\n- * one read upon parsing.\n- * DEPRECATED\n- *\n- * Returns 1 if true 0 otherwise\n- *\/\n-\n-int\n-checkNamespace(void *ctx ATTRIBUTE_UNUSED,\n-               xmlChar * namespace ATTRIBUTE_UNUSED)\n-{\n-    DEPRECATED(\"checkNamespace\")\n-        return (0);\n-}\n-\n-\/**\n- * namespaceDecl:\n- * @ctx: the user data (XML parser context)\n- * @href:  the namespace associated URN\n- * @prefix: the namespace prefix\n- *\n- * A namespace has been parsed.\n- * DEPRECATED\n- *\/\n-void\n-namespaceDecl(void *ctx ATTRIBUTE_UNUSED,\n-              const xmlChar * href ATTRIBUTE_UNUSED,\n-              const xmlChar * prefix ATTRIBUTE_UNUSED)\n-{\n-    DEPRECATED(\"namespaceDecl\")\n-}\n-\n-\/**\n- * comment:\n- * @ctx: the user data (XML parser context)\n- * @value:  the comment content\n- *\n- * A comment has been parsed.\n- * DEPRECATED: use xmlSAX2Comment()\n- *\/\n-void\n-comment(void *ctx, const xmlChar * value)\n-{\n-    DEPRECATED(\"comment\")\n-        xmlSAX2Comment(ctx, value);\n-}\n-\n-\/**\n- * cdataBlock:\n- * @ctx: the user data (XML parser context)\n- * @value:  The pcdata content\n- * @len:  the block length\n- *\n- * called when a pcdata block has been parsed\n- * DEPRECATED: use xmlSAX2CDataBlock()\n- *\/\n-void\n-cdataBlock(void *ctx, const xmlChar * value, int len)\n-{\n-    DEPRECATED(\"cdataBlock\")\n-        xmlSAX2CDataBlock(ctx, value, len);\n-}\n-\n-\/*\n- * nanoftp.h\n- *\/\n-\n-#ifndef LIBXML_FTP_ENABLED\n-\n-#include <libxml\/nanoftp.h>\n-\n-\/** DOC_DISABLE *\/\n-\n-#ifdef _WIN32\n-  #include <winsock2.h>\n-#else\n-  #define SOCKET int\n-#endif\n-\n-typedef void\n-(*ftpListCallback)(void *userData, const char *filename, const char *attrib,\n-                   const char *owner, const char *group, unsigned long size,\n-                   int links, int year, const char *month, int day, int hour,\n-                   int minute);\n-\n-typedef void\n-(*ftpDataCallback) (void *userData, const char *data, int len);\n-\n-XMLPUBFUN void\n-xmlNanoFTPInit(void);\n-\n-void\n-xmlNanoFTPInit(void) {\n-}\n-\n-XMLPUBFUN void\n-xmlNanoFTPCleanup(void);\n-\n-void\n-xmlNanoFTPCleanup(void) {\n-}\n-\n-XMLPUBFUN void\n-xmlNanoFTPProxy(const char *host, int port, const char *user,\n-                const char *passwd, int type);\n-\n-void\n-xmlNanoFTPProxy(const char *host ATTRIBUTE_UNUSED, int port ATTRIBUTE_UNUSED,\n-                const char *user ATTRIBUTE_UNUSED,\n-\t        const char *passwd ATTRIBUTE_UNUSED, int type ATTRIBUTE_UNUSED) {\n-}\n-\n-XMLPUBFUN int\n-xmlNanoFTPUpdateURL(void *ctx, const char *URL);\n-\n-int\n-xmlNanoFTPUpdateURL(void *ctx ATTRIBUTE_UNUSED,\n-                    const char *URL ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN void\n-xmlNanoFTPScanProxy(const char *URL);\n-\n-void\n-xmlNanoFTPScanProxy(const char *URL ATTRIBUTE_UNUSED) {\n-}\n-\n-XMLPUBFUN void *\n-xmlNanoFTPNewCtxt(const char *URL);\n-\n-void*\n-xmlNanoFTPNewCtxt(const char *URL ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN void\n-xmlNanoFTPFreeCtxt(void *ctx);\n-\n-void\n-xmlNanoFTPFreeCtxt(void * ctx ATTRIBUTE_UNUSED) {\n-}\n-\n-XMLPUBFUN int\n-xmlNanoFTPGetResponse(void *ctx);\n-\n-int\n-xmlNanoFTPGetResponse(void *ctx ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN int\n-xmlNanoFTPCheckResponse(void *ctx);\n-\n-int\n-xmlNanoFTPCheckResponse(void *ctx ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN int\n-xmlNanoFTPQuit(void *ctx);\n-\n-int\n-xmlNanoFTPQuit(void *ctx ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN int\n-xmlNanoFTPConnect(void *ctx);\n-\n-int\n-xmlNanoFTPConnect(void *ctx ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN void *\n-xmlNanoFTPConnectTo(const char *server, int port);\n-\n-void*\n-xmlNanoFTPConnectTo(const char *server ATTRIBUTE_UNUSED,\n-                    int port ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN int\n-xmlNanoFTPCwd(void *ctx, const char *directory);\n-\n-int\n-xmlNanoFTPCwd(void *ctx ATTRIBUTE_UNUSED,\n-              const char *directory ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN int\n-xmlNanoFTPDele(void *ctx, const char *file);\n-\n-int\n-xmlNanoFTPDele(void *ctx ATTRIBUTE_UNUSED, const char *file ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN SOCKET\n-xmlNanoFTPGetConnection(void *ctx);\n-\n-SOCKET\n-xmlNanoFTPGetConnection(void *ctx ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN int\n-xmlNanoFTPCloseConnection(void *ctx);\n-\n-int\n-xmlNanoFTPCloseConnection(void *ctx ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN int\n-xmlNanoFTPList(void *ctx, ftpListCallback callback, void *userData,\n-\t       const char *filename);\n-\n-int\n-xmlNanoFTPList(void *ctx ATTRIBUTE_UNUSED,\n-               ftpListCallback callback ATTRIBUTE_UNUSED,\n-               void *userData ATTRIBUTE_UNUSED,\n-\t       const char *filename ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN SOCKET\n-xmlNanoFTPGetSocket(void *ctx, const char *filename);\n-\n-SOCKET\n-xmlNanoFTPGetSocket(void *ctx ATTRIBUTE_UNUSED,\n-                    const char *filename ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN int\n-xmlNanoFTPGet(void *ctx, ftpDataCallback callback, void *userData,\n-\t      const char *filename);\n-\n-int\n-xmlNanoFTPGet(void *ctx ATTRIBUTE_UNUSED,\n-              ftpDataCallback callback ATTRIBUTE_UNUSED,\n-              void *userData ATTRIBUTE_UNUSED,\n-\t      const char *filename ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN int\n-xmlNanoFTPRead(void *ctx, void *dest, int len);\n-\n-int\n-xmlNanoFTPRead(void *ctx ATTRIBUTE_UNUSED, void *dest ATTRIBUTE_UNUSED,\n-               int len ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN void *\n-xmlNanoFTPOpen(const char *URL);\n-\n-void*\n-xmlNanoFTPOpen(const char *URL ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN int\n-xmlNanoFTPClose(void *ctx);\n-\n-int\n-xmlNanoFTPClose(void *ctx ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN int\n-xmlIOFTPMatch(const char *filename);\n-\n-int\n-xmlIOFTPMatch(const char *filename ATTRIBUTE_UNUSED) {\n-    return(0);\n-}\n-\n-XMLPUBFUN void *\n-xmlIOFTPOpen(const char *filename);\n-\n-void *\n-xmlIOFTPOpen(const char *filename ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN int\n-xmlIOFTPRead(void *context, char *buffer, int len);\n-\n-int\n-xmlIOFTPRead(void *context ATTRIBUTE_UNUSED, char *buffer ATTRIBUTE_UNUSED,\n-             int len ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-XMLPUBFUN int\n-xmlIOFTPClose(void *context);\n-\n-int\n-xmlIOFTPClose(void *context ATTRIBUTE_UNUSED) {\n-    return(-1);\n-}\n-\n-\/** DOC_ENABLE *\/\n-\n-#endif \/* #ifndef LIBXML_FTP_ENABLED *\/\n-\n-\/*\n- * xpointer.h\n- *\/\n-\n-#ifndef LIBXML_XPTR_LOCS_ENABLED\n-\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-#include <libxml\/xpointer.h>\n-\n-\/** DOC_DISABLE *\/\n-\n-typedef struct _xmlLocationSet *xmlLocationSetPtr;\n-\n-XMLPUBFUN xmlXPathObjectPtr\n-xmlXPtrNewRange(xmlNodePtr start, int startindex,\n-                xmlNodePtr end, int endindex);\n-\n-xmlXPathObjectPtr\n-xmlXPtrNewRange(xmlNodePtr start ATTRIBUTE_UNUSED,\n-                int startindex ATTRIBUTE_UNUSED,\n-                xmlNodePtr end ATTRIBUTE_UNUSED,\n-                int endindex ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN xmlXPathObjectPtr\n-xmlXPtrNewRangePoints(xmlXPathObjectPtr start, xmlXPathObjectPtr end);\n-\n-xmlXPathObjectPtr\n-xmlXPtrNewRangePoints(xmlXPathObjectPtr start ATTRIBUTE_UNUSED,\n-                      xmlXPathObjectPtr end ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN xmlXPathObjectPtr\n-xmlXPtrNewRangePointNode(xmlXPathObjectPtr start, xmlNodePtr end);\n-\n-xmlXPathObjectPtr\n-xmlXPtrNewRangePointNode(xmlXPathObjectPtr start ATTRIBUTE_UNUSED,\n-                         xmlNodePtr end ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN xmlXPathObjectPtr\n-xmlXPtrNewRangeNodePoint(xmlNodePtr start, xmlXPathObjectPtr end);\n-\n-xmlXPathObjectPtr\n-xmlXPtrNewRangeNodePoint(xmlNodePtr start ATTRIBUTE_UNUSED,\n-                         xmlXPathObjectPtr end ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN xmlXPathObjectPtr\n-xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end);\n-\n-xmlXPathObjectPtr\n-xmlXPtrNewRangeNodes(xmlNodePtr start ATTRIBUTE_UNUSED,\n-                     xmlNodePtr end ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN xmlXPathObjectPtr\n-xmlXPtrNewCollapsedRange(xmlNodePtr start);\n-\n-xmlXPathObjectPtr\n-xmlXPtrNewCollapsedRange(xmlNodePtr start ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN xmlXPathObjectPtr\n-xmlXPtrNewRangeNodeObject(xmlNodePtr start, xmlXPathObjectPtr end);\n-\n-xmlXPathObjectPtr\n-xmlXPtrNewRangeNodeObject(xmlNodePtr start ATTRIBUTE_UNUSED,\n-                          xmlXPathObjectPtr end ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN xmlLocationSetPtr\n-xmlXPtrLocationSetCreate(xmlXPathObjectPtr val);\n-\n-xmlLocationSetPtr\n-xmlXPtrLocationSetCreate(xmlXPathObjectPtr val ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN void\n-xmlXPtrLocationSetAdd(xmlLocationSetPtr cur, xmlXPathObjectPtr val);\n-\n-void\n-xmlXPtrLocationSetAdd(xmlLocationSetPtr cur ATTRIBUTE_UNUSED,\n-                      xmlXPathObjectPtr val ATTRIBUTE_UNUSED) {\n-}\n-\n-XMLPUBFUN xmlLocationSetPtr\n-xmlXPtrLocationSetMerge(xmlLocationSetPtr val1, xmlLocationSetPtr val2);\n-\n-xmlLocationSetPtr\n-xmlXPtrLocationSetMerge(xmlLocationSetPtr val1 ATTRIBUTE_UNUSED,\n-                        xmlLocationSetPtr val2 ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN void\n-xmlXPtrLocationSetDel(xmlLocationSetPtr cur, xmlXPathObjectPtr val);\n-\n-void\n-xmlXPtrLocationSetDel(xmlLocationSetPtr cur ATTRIBUTE_UNUSED,\n-                      xmlXPathObjectPtr val ATTRIBUTE_UNUSED) {\n-}\n-\n-XMLPUBFUN void\n-xmlXPtrLocationSetRemove(xmlLocationSetPtr cur, int val);\n-\n-void\n-xmlXPtrLocationSetRemove(xmlLocationSetPtr cur ATTRIBUTE_UNUSED,\n-                         int val ATTRIBUTE_UNUSED) {\n-}\n-\n-XMLPUBFUN void\n-xmlXPtrFreeLocationSet(xmlLocationSetPtr obj);\n-\n-void\n-xmlXPtrFreeLocationSet(xmlLocationSetPtr obj ATTRIBUTE_UNUSED) {\n-}\n-\n-XMLPUBFUN xmlXPathObjectPtr\n-xmlXPtrNewLocationSetNodes(xmlNodePtr start, xmlNodePtr end);\n-\n-xmlXPathObjectPtr\n-xmlXPtrNewLocationSetNodes(xmlNodePtr start ATTRIBUTE_UNUSED,\n-                           xmlNodePtr end ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN xmlXPathObjectPtr\n-xmlXPtrNewLocationSetNodeSet(xmlNodeSetPtr set);\n-\n-xmlXPathObjectPtr\n-xmlXPtrNewLocationSetNodeSet(xmlNodeSetPtr set ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN xmlXPathObjectPtr\n-xmlXPtrWrapLocationSet(xmlLocationSetPtr val);\n-\n-xmlXPathObjectPtr\n-xmlXPtrWrapLocationSet(xmlLocationSetPtr val ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN xmlNodePtr\n-xmlXPtrBuildNodeList(xmlXPathObjectPtr obj);\n-\n-xmlNodePtr\n-xmlXPtrBuildNodeList(xmlXPathObjectPtr obj ATTRIBUTE_UNUSED) {\n-    return(NULL);\n-}\n-\n-XMLPUBFUN void\n-xmlXPtrRangeToFunction(xmlXPathParserContextPtr ctxt, int nargs);\n-\n-void\n-xmlXPtrRangeToFunction(xmlXPathParserContextPtr ctxt,\n-                       int nargs ATTRIBUTE_UNUSED) {\n-    XP_ERROR(XPATH_EXPR_ERROR);\n-}\n-\n-\/** DOC_ENABLE *\/\n-\n-#endif \/* #ifndef LIBXML_XPTR_LOCS_ENABLED *\/\n-\n-#endif \/* LIBXML_LEGACY_ENABLED *\/\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/legacy.c","additions":0,"deletions":1776,"binary":false,"changes":1776,"status":"deleted"},{"patch":"@@ -1,2098 +0,0 @@\n-\/*\n- * schematron.c : implementation of the Schematron schema validity checking\n- *\n- * See Copyright for the status of this software.\n- *\n- * Daniel Veillard <daniel@veillard.com>\n- *\/\n-\n-\/*\n- * TODO:\n- * + double check the semantic, especially\n- *        - multiple rules applying in a single pattern\/node\n- *        - the semantic of libxml2 patterns vs. XSLT production referenced\n- *          by the spec.\n- * + export of results in SVRL\n- * + full parsing and coverage of the spec, conformance of the input to the\n- *   spec\n- * + divergences between the draft and the ISO proposed standard :-(\n- * + hook and test include\n- * + try and compare with the XSLT version\n- *\/\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-\n-#ifdef LIBXML_SCHEMATRON_ENABLED\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/tree.h>\n-#include <libxml\/uri.h>\n-#include <libxml\/xpath.h>\n-#include <libxml\/xpathInternals.h>\n-#include <libxml\/pattern.h>\n-#include <libxml\/schematron.h>\n-\n-#include \"private\/error.h\"\n-\n-#define SCHEMATRON_PARSE_OPTIONS XML_PARSE_NOENT\n-\n-#define SCT_OLD_NS BAD_CAST \"http:\/\/www.ascc.net\/xml\/schematron\"\n-\n-#define XML_SCHEMATRON_NS BAD_CAST \"http:\/\/purl.oclc.org\/dsdl\/schematron\"\n-\n-\n-static const xmlChar *xmlSchematronNs = XML_SCHEMATRON_NS;\n-static const xmlChar *xmlOldSchematronNs = SCT_OLD_NS;\n-\n-#define IS_SCHEMATRON(node, elem)                                       \\\n-   ((node != NULL) && (node->type == XML_ELEMENT_NODE ) &&              \\\n-    (node->ns != NULL) &&                                               \\\n-    (xmlStrEqual(node->name, (const xmlChar *) elem)) &&                \\\n-    ((xmlStrEqual(node->ns->href, xmlSchematronNs)) ||                  \\\n-     (xmlStrEqual(node->ns->href, xmlOldSchematronNs))))\n-\n-#define NEXT_SCHEMATRON(node)                                           \\\n-   while (node != NULL) {                                               \\\n-       if ((node->type == XML_ELEMENT_NODE ) && (node->ns != NULL) &&   \\\n-           ((xmlStrEqual(node->ns->href, xmlSchematronNs)) ||           \\\n-            (xmlStrEqual(node->ns->href, xmlOldSchematronNs))))         \\\n-           break;                                                       \\\n-       node = node->next;                                               \\\n-   }\n-\n-typedef enum {\n-    XML_SCHEMATRON_ASSERT=1,\n-    XML_SCHEMATRON_REPORT=2\n-} xmlSchematronTestType;\n-\n-\/**\n- * _xmlSchematronLet:\n- *\n- * A Schematron let variable\n- *\/\n-typedef struct _xmlSchematronLet xmlSchematronLet;\n-typedef xmlSchematronLet *xmlSchematronLetPtr;\n-struct _xmlSchematronLet {\n-    xmlSchematronLetPtr next; \/* the next let variable in the list *\/\n-    xmlChar *name;            \/* the name of the variable *\/\n-    xmlXPathCompExprPtr comp; \/* the compiled expression *\/\n-};\n-\n-\/**\n- * _xmlSchematronTest:\n- *\n- * A Schematrons test, either an assert or a report\n- *\/\n-typedef struct _xmlSchematronTest xmlSchematronTest;\n-typedef xmlSchematronTest *xmlSchematronTestPtr;\n-struct _xmlSchematronTest {\n-    xmlSchematronTestPtr next;  \/* the next test in the list *\/\n-    xmlSchematronTestType type; \/* the test type *\/\n-    xmlNodePtr node;            \/* the node in the tree *\/\n-    xmlChar *test;              \/* the expression to test *\/\n-    xmlXPathCompExprPtr comp;   \/* the compiled expression *\/\n-    xmlChar *report;            \/* the message to report *\/\n-};\n-\n-\/**\n- * _xmlSchematronRule:\n- *\n- * A Schematrons rule\n- *\/\n-typedef struct _xmlSchematronRule xmlSchematronRule;\n-typedef xmlSchematronRule *xmlSchematronRulePtr;\n-struct _xmlSchematronRule {\n-    xmlSchematronRulePtr next;  \/* the next rule in the list *\/\n-    xmlSchematronRulePtr patnext;\/* the next rule in the pattern list *\/\n-    xmlNodePtr node;            \/* the node in the tree *\/\n-    xmlChar *context;           \/* the context evaluation rule *\/\n-    xmlSchematronTestPtr tests; \/* the list of tests *\/\n-    xmlPatternPtr pattern;      \/* the compiled pattern associated *\/\n-    xmlChar *report;            \/* the message to report *\/\n-    xmlSchematronLetPtr lets;   \/* the list of let variables *\/\n-};\n-\n-\/**\n- * _xmlSchematronPattern:\n- *\n- * A Schematrons pattern\n- *\/\n-typedef struct _xmlSchematronPattern xmlSchematronPattern;\n-typedef xmlSchematronPattern *xmlSchematronPatternPtr;\n-struct _xmlSchematronPattern {\n-    xmlSchematronPatternPtr next;\/* the next pattern in the list *\/\n-    xmlSchematronRulePtr rules; \/* the list of rules *\/\n-    xmlChar *name;              \/* the name of the pattern *\/\n-};\n-\n-\/**\n- * _xmlSchematron:\n- *\n- * A Schematrons definition\n- *\/\n-struct _xmlSchematron {\n-    const xmlChar *name;        \/* schema name *\/\n-    int preserve;               \/* was the document passed by the user *\/\n-    xmlDocPtr doc;              \/* pointer to the parsed document *\/\n-    int flags;                  \/* specific to this schematron *\/\n-\n-    void *_private;             \/* unused by the library *\/\n-    xmlDictPtr dict;            \/* the dictionary used internally *\/\n-\n-    const xmlChar *title;       \/* the title if any *\/\n-\n-    int nbNs;                   \/* the number of namespaces *\/\n-\n-    int nbPattern;              \/* the number of patterns *\/\n-    xmlSchematronPatternPtr patterns;\/* the patterns found *\/\n-    xmlSchematronRulePtr rules; \/* the rules gathered *\/\n-    int nbNamespaces;           \/* number of namespaces in the array *\/\n-    int maxNamespaces;          \/* size of the array *\/\n-    const xmlChar **namespaces; \/* the array of namespaces *\/\n-};\n-\n-\/**\n- * xmlSchematronValidCtxt:\n- *\n- * A Schematrons validation context\n- *\/\n-struct _xmlSchematronValidCtxt {\n-    int type;\n-    int flags;                  \/* an or of xmlSchematronValidOptions *\/\n-\n-    xmlDictPtr dict;\n-    int nberrors;\n-    int err;\n-\n-    xmlSchematronPtr schema;\n-    xmlXPathContextPtr xctxt;\n-\n-    FILE *outputFile;           \/* if using XML_SCHEMATRON_OUT_FILE *\/\n-    xmlBufferPtr outputBuffer;  \/* if using XML_SCHEMATRON_OUT_BUFFER *\/\n-#ifdef LIBXML_OUTPUT_ENABLED\n-    xmlOutputWriteCallback iowrite; \/* if using XML_SCHEMATRON_OUT_IO *\/\n-    xmlOutputCloseCallback  ioclose;\n-#endif\n-    void *ioctx;\n-\n-    \/* error reporting data *\/\n-    void *userData;                      \/* user specific data block *\/\n-    xmlSchematronValidityErrorFunc error;\/* the callback in case of errors *\/\n-    xmlSchematronValidityWarningFunc warning;\/* callback in case of warning *\/\n-    xmlStructuredErrorFunc serror;       \/* the structured function *\/\n-};\n-\n-struct _xmlSchematronParserCtxt {\n-    int type;\n-    const xmlChar *URL;\n-    xmlDocPtr doc;\n-    int preserve;               \/* Whether the doc should be freed  *\/\n-    const char *buffer;\n-    int size;\n-\n-    xmlDictPtr dict;            \/* dictionary for interned string names *\/\n-\n-    int nberrors;\n-    int err;\n-    xmlXPathContextPtr xctxt;   \/* the XPath context used for compilation *\/\n-    xmlSchematronPtr schema;\n-\n-    int nbNamespaces;           \/* number of namespaces in the array *\/\n-    int maxNamespaces;          \/* size of the array *\/\n-    const xmlChar **namespaces; \/* the array of namespaces *\/\n-\n-    int nbIncludes;             \/* number of includes in the array *\/\n-    int maxIncludes;            \/* size of the array *\/\n-    xmlNodePtr *includes;       \/* the array of includes *\/\n-\n-    \/* error reporting data *\/\n-    void *userData;                      \/* user specific data block *\/\n-    xmlSchematronValidityErrorFunc error;\/* the callback in case of errors *\/\n-    xmlSchematronValidityWarningFunc warning;\/* callback in case of warning *\/\n-    xmlStructuredErrorFunc serror;       \/* the structured function *\/\n-};\n-\n-#define XML_STRON_CTXT_PARSER 1\n-#define XML_STRON_CTXT_VALIDATOR 2\n-\n-\/************************************************************************\n- *                                                                      *\n- *                      Error reporting                                 *\n- *                                                                      *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchematronPErrMemory:\n- * @node: a context node\n- * @extra:  extra information\n- *\n- * Handle an out of memory condition\n- *\/\n-static void\n-xmlSchematronPErrMemory(xmlSchematronParserCtxtPtr ctxt)\n-{\n-    if (ctxt != NULL)\n-        ctxt->nberrors++;\n-    xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_SCHEMASP, NULL);\n-}\n-\n-\/**\n- * xmlSchematronPErr:\n- * @ctxt: the parsing context\n- * @node: the context node\n- * @error: the error code\n- * @msg: the error message\n- * @str1: extra data\n- * @str2: extra data\n- *\n- * Handle a parser error\n- *\/\n-static void LIBXML_ATTR_FORMAT(4,0)\n-xmlSchematronPErr(xmlSchematronParserCtxtPtr ctxt, xmlNodePtr node, int error,\n-              const char *msg, const xmlChar * str1, const xmlChar * str2)\n-{\n-    xmlGenericErrorFunc channel = NULL;\n-    xmlStructuredErrorFunc schannel = NULL;\n-    void *data = NULL;\n-    int res;\n-\n-    if (ctxt != NULL) {\n-        ctxt->nberrors++;\n-        channel = ctxt->error;\n-        data = ctxt->userData;\n-        schannel = ctxt->serror;\n-    }\n-\n-    if ((channel == NULL) && (schannel == NULL)) {\n-        channel = xmlGenericError;\n-        data = xmlGenericErrorContext;\n-    }\n-\n-    res = __xmlRaiseError(schannel, channel, data, ctxt, node,\n-                          XML_FROM_SCHEMASP, error, XML_ERR_ERROR, NULL, 0,\n-                          (const char *) str1, (const char *) str2, NULL, 0, 0,\n-                          msg, str1, str2);\n-    if (res < 0)\n-        xmlSchematronPErrMemory(ctxt);\n-}\n-\n-\/**\n- * xmlSchematronVTypeErrMemory:\n- * @node: a context node\n- * @extra:  extra information\n- *\n- * Handle an out of memory condition\n- *\/\n-static void\n-xmlSchematronVErrMemory(xmlSchematronValidCtxtPtr ctxt)\n-{\n-    if (ctxt != NULL) {\n-        ctxt->nberrors++;\n-        ctxt->err = XML_SCHEMAV_INTERNAL;\n-    }\n-    xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_SCHEMASV, NULL);\n-}\n-\n-\/**\n- * xmlSchematronVErr:\n- * @ctxt: the parsing context\n- * @node: the context node\n- * @error: the error code\n- * @msg: the error message\n- * @str1: extra data\n- * @str2: extra data\n- *\n- * Handle a validation error\n- *\/\n-static void LIBXML_ATTR_FORMAT(3,0)\n-xmlSchematronVErr(xmlSchematronValidCtxtPtr ctxt, int error,\n-                  const char *msg, const xmlChar * str1)\n-{\n-    xmlGenericErrorFunc channel = NULL;\n-    xmlStructuredErrorFunc schannel = NULL;\n-    void *data = NULL;\n-    int res;\n-\n-    if (ctxt != NULL) {\n-        ctxt->nberrors++;\n-        channel = ctxt->error;\n-        data = ctxt->userData;\n-        schannel = ctxt->serror;\n-    }\n-\n-    if ((channel == NULL) && (schannel == NULL)) {\n-        channel = xmlGenericError;\n-        data = xmlGenericErrorContext;\n-    }\n-\n-    res = __xmlRaiseError(schannel, channel, data, ctxt, NULL,\n-                          XML_FROM_SCHEMASV, error, XML_ERR_ERROR, NULL, 0,\n-                          (const char *) str1, NULL, NULL, 0, 0,\n-                          msg, str1);\n-    if (res < 0)\n-        xmlSchematronVErrMemory(ctxt);\n-}\n-\n-\/************************************************************************\n- *                                                                      *\n- *              Parsing and compilation of the Schematrontrons          *\n- *                                                                      *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchematronAddTest:\n- * @ctxt: the schema parsing context\n- * @type:  the type of test\n- * @rule:  the parent rule\n- * @node:  the node hosting the test\n- * @test: the associated test\n- * @report: the associated report string\n- *\n- * Add a test to a schematron\n- *\n- * Returns the new pointer or NULL in case of error\n- *\/\n-static xmlSchematronTestPtr\n-xmlSchematronAddTest(xmlSchematronParserCtxtPtr ctxt,\n-                     xmlSchematronTestType type,\n-                     xmlSchematronRulePtr rule,\n-                     xmlNodePtr node, xmlChar *test, xmlChar *report)\n-{\n-    xmlSchematronTestPtr ret;\n-    xmlXPathCompExprPtr comp;\n-\n-    if ((ctxt == NULL) || (rule == NULL) || (node == NULL) ||\n-        (test == NULL))\n-        return(NULL);\n-\n-    \/*\n-     * try first to compile the test expression\n-     *\/\n-    comp = xmlXPathCtxtCompile(ctxt->xctxt, test);\n-    if (comp == NULL) {\n-        xmlSchematronPErr(ctxt, node,\n-            XML_SCHEMAP_NOROOT,\n-            \"Failed to compile test expression %s\",\n-            test, NULL);\n-        return(NULL);\n-    }\n-\n-    ret = (xmlSchematronTestPtr) xmlMalloc(sizeof(xmlSchematronTest));\n-    if (ret == NULL) {\n-        xmlSchematronPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchematronTest));\n-    ret->type = type;\n-    ret->node = node;\n-    ret->test = test;\n-    ret->comp = comp;\n-    ret->report = report;\n-    ret->next = NULL;\n-    if (rule->tests == NULL) {\n-        rule->tests = ret;\n-    } else {\n-        xmlSchematronTestPtr prev = rule->tests;\n-\n-        while (prev->next != NULL)\n-             prev = prev->next;\n-        prev->next = ret;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchematronFreeTests:\n- * @tests:  a list of tests\n- *\n- * Free a list of tests.\n- *\/\n-static void\n-xmlSchematronFreeTests(xmlSchematronTestPtr tests) {\n-    xmlSchematronTestPtr next;\n-\n-    while (tests != NULL) {\n-        next = tests->next;\n-        if (tests->test != NULL)\n-            xmlFree(tests->test);\n-        if (tests->comp != NULL)\n-            xmlXPathFreeCompExpr(tests->comp);\n-        if (tests->report != NULL)\n-            xmlFree(tests->report);\n-        xmlFree(tests);\n-        tests = next;\n-    }\n-}\n-\n-\/**\n- * xmlSchematronFreeLets:\n- * @lets:  a list of let variables\n- *\n- * Free a list of let variables.\n- *\/\n-static void\n-xmlSchematronFreeLets(xmlSchematronLetPtr lets) {\n-    xmlSchematronLetPtr next;\n-\n-    while (lets != NULL) {\n-        next = lets->next;\n-        if (lets->name != NULL)\n-            xmlFree(lets->name);\n-        if (lets->comp != NULL)\n-            xmlXPathFreeCompExpr(lets->comp);\n-        xmlFree(lets);\n-        lets = next;\n-    }\n-}\n-\n-\/**\n- * xmlSchematronAddRule:\n- * @ctxt: the schema parsing context\n- * @schema:  a schema structure\n- * @node:  the node hosting the rule\n- * @context: the associated context string\n- * @report: the associated report string\n- *\n- * Add a rule to a schematron\n- *\n- * Returns the new pointer or NULL in case of error\n- *\/\n-static xmlSchematronRulePtr\n-xmlSchematronAddRule(xmlSchematronParserCtxtPtr ctxt, xmlSchematronPtr schema,\n-                     xmlSchematronPatternPtr pat, xmlNodePtr node,\n-                     xmlChar *context, xmlChar *report)\n-{\n-    xmlSchematronRulePtr ret;\n-    xmlPatternPtr pattern;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL) ||\n-        (context == NULL))\n-        return(NULL);\n-\n-    \/*\n-     * Try first to compile the pattern\n-     *\/\n-    pattern = xmlPatterncompile(context, ctxt->dict, XML_PATTERN_XPATH,\n-                                ctxt->namespaces);\n-    if (pattern == NULL) {\n-        xmlSchematronPErr(ctxt, node,\n-            XML_SCHEMAP_NOROOT,\n-            \"Failed to compile context expression %s\",\n-            context, NULL);\n-    }\n-\n-    ret = (xmlSchematronRulePtr) xmlMalloc(sizeof(xmlSchematronRule));\n-    if (ret == NULL) {\n-        xmlSchematronPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchematronRule));\n-    ret->node = node;\n-    ret->context = context;\n-    ret->pattern = pattern;\n-    ret->report = report;\n-    ret->next = NULL;\n-    ret->lets = NULL;\n-    if (schema->rules == NULL) {\n-        schema->rules = ret;\n-    } else {\n-        xmlSchematronRulePtr prev = schema->rules;\n-\n-        while (prev->next != NULL)\n-             prev = prev->next;\n-        prev->next = ret;\n-    }\n-    ret->patnext = NULL;\n-    if (pat->rules == NULL) {\n-        pat->rules = ret;\n-    } else {\n-        xmlSchematronRulePtr prev = pat->rules;\n-\n-        while (prev->patnext != NULL)\n-             prev = prev->patnext;\n-        prev->patnext = ret;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchematronFreeRules:\n- * @rules:  a list of rules\n- *\n- * Free a list of rules.\n- *\/\n-static void\n-xmlSchematronFreeRules(xmlSchematronRulePtr rules) {\n-    xmlSchematronRulePtr next;\n-\n-    while (rules != NULL) {\n-        next = rules->next;\n-        if (rules->tests)\n-            xmlSchematronFreeTests(rules->tests);\n-        if (rules->context != NULL)\n-            xmlFree(rules->context);\n-        if (rules->pattern)\n-            xmlFreePattern(rules->pattern);\n-        if (rules->report != NULL)\n-            xmlFree(rules->report);\n-        if (rules->lets != NULL)\n-            xmlSchematronFreeLets(rules->lets);\n-        xmlFree(rules);\n-        rules = next;\n-    }\n-}\n-\n-\/**\n- * xmlSchematronAddPattern:\n- * @ctxt: the schema parsing context\n- * @schema:  a schema structure\n- * @node:  the node hosting the pattern\n- * @id: the id or name of the pattern\n- *\n- * Add a pattern to a schematron\n- *\n- * Returns the new pointer or NULL in case of error\n- *\/\n-static xmlSchematronPatternPtr\n-xmlSchematronAddPattern(xmlSchematronParserCtxtPtr ctxt,\n-                     xmlSchematronPtr schema, xmlNodePtr node, xmlChar *name)\n-{\n-    xmlSchematronPatternPtr ret;\n-\n-    if ((ctxt == NULL) || (schema == NULL) || (node == NULL) || (name == NULL))\n-        return(NULL);\n-\n-    ret = (xmlSchematronPatternPtr) xmlMalloc(sizeof(xmlSchematronPattern));\n-    if (ret == NULL) {\n-        xmlSchematronPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchematronPattern));\n-    ret->name = name;\n-    ret->next = NULL;\n-    if (schema->patterns == NULL) {\n-        schema->patterns = ret;\n-    } else {\n-        xmlSchematronPatternPtr prev = schema->patterns;\n-\n-        while (prev->next != NULL)\n-             prev = prev->next;\n-        prev->next = ret;\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchematronFreePatterns:\n- * @patterns:  a list of patterns\n- *\n- * Free a list of patterns.\n- *\/\n-static void\n-xmlSchematronFreePatterns(xmlSchematronPatternPtr patterns) {\n-    xmlSchematronPatternPtr next;\n-\n-    while (patterns != NULL) {\n-        next = patterns->next;\n-        if (patterns->name != NULL)\n-            xmlFree(patterns->name);\n-        xmlFree(patterns);\n-        patterns = next;\n-    }\n-}\n-\n-\/**\n- * xmlSchematronNewSchematron:\n- * @ctxt:  a schema validation context\n- *\n- * Allocate a new Schematron structure.\n- *\n- * Returns the newly allocated structure or NULL in case or error\n- *\/\n-static xmlSchematronPtr\n-xmlSchematronNewSchematron(xmlSchematronParserCtxtPtr ctxt)\n-{\n-    xmlSchematronPtr ret;\n-\n-    ret = (xmlSchematronPtr) xmlMalloc(sizeof(xmlSchematron));\n-    if (ret == NULL) {\n-        xmlSchematronPErrMemory(ctxt);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchematron));\n-    ret->dict = ctxt->dict;\n-    xmlDictReference(ret->dict);\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchematronFree:\n- * @schema:  a schema structure\n- *\n- * Deallocate a Schematron structure.\n- *\/\n-void\n-xmlSchematronFree(xmlSchematronPtr schema)\n-{\n-    if (schema == NULL)\n-        return;\n-\n-    if ((schema->doc != NULL) && (!(schema->preserve)))\n-        xmlFreeDoc(schema->doc);\n-\n-    if (schema->namespaces != NULL)\n-        xmlFree((char **) schema->namespaces);\n-\n-    xmlSchematronFreeRules(schema->rules);\n-    xmlSchematronFreePatterns(schema->patterns);\n-    xmlDictFree(schema->dict);\n-    xmlFree(schema);\n-}\n-\n-\/**\n- * xmlSchematronNewParserCtxt:\n- * @URL:  the location of the schema\n- *\n- * Create an XML Schematrons parse context for that file\/resource expected\n- * to contain an XML Schematrons file.\n- *\n- * Returns the parser context or NULL in case of error\n- *\/\n-xmlSchematronParserCtxtPtr\n-xmlSchematronNewParserCtxt(const char *URL)\n-{\n-    xmlSchematronParserCtxtPtr ret;\n-\n-    if (URL == NULL)\n-        return (NULL);\n-\n-    ret =\n-        (xmlSchematronParserCtxtPtr)\n-        xmlMalloc(sizeof(xmlSchematronParserCtxt));\n-    if (ret == NULL) {\n-        xmlSchematronPErrMemory(NULL);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchematronParserCtxt));\n-    ret->type = XML_STRON_CTXT_PARSER;\n-    ret->dict = xmlDictCreate();\n-    ret->URL = xmlDictLookup(ret->dict, (const xmlChar *) URL, -1);\n-    ret->includes = NULL;\n-    ret->xctxt = xmlXPathNewContext(NULL);\n-    if (ret->xctxt == NULL) {\n-        xmlSchematronPErrMemory(NULL);\n-        xmlSchematronFreeParserCtxt(ret);\n-        return (NULL);\n-    }\n-    ret->xctxt->flags = XML_XPATH_CHECKNS;\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchematronNewMemParserCtxt:\n- * @buffer:  a pointer to a char array containing the schemas\n- * @size:  the size of the array\n- *\n- * Create an XML Schematrons parse context for that memory buffer expected\n- * to contain an XML Schematrons file.\n- *\n- * Returns the parser context or NULL in case of error\n- *\/\n-xmlSchematronParserCtxtPtr\n-xmlSchematronNewMemParserCtxt(const char *buffer, int size)\n-{\n-    xmlSchematronParserCtxtPtr ret;\n-\n-    if ((buffer == NULL) || (size <= 0))\n-        return (NULL);\n-\n-    ret =\n-        (xmlSchematronParserCtxtPtr)\n-        xmlMalloc(sizeof(xmlSchematronParserCtxt));\n-    if (ret == NULL) {\n-        xmlSchematronPErrMemory(NULL);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchematronParserCtxt));\n-    ret->buffer = buffer;\n-    ret->size = size;\n-    ret->dict = xmlDictCreate();\n-    ret->xctxt = xmlXPathNewContext(NULL);\n-    if (ret->xctxt == NULL) {\n-        xmlSchematronPErrMemory(NULL);\n-        xmlSchematronFreeParserCtxt(ret);\n-        return (NULL);\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchematronNewDocParserCtxt:\n- * @doc:  a preparsed document tree\n- *\n- * Create an XML Schematrons parse context for that document.\n- * NB. The document may be modified during the parsing process.\n- *\n- * Returns the parser context or NULL in case of error\n- *\/\n-xmlSchematronParserCtxtPtr\n-xmlSchematronNewDocParserCtxt(xmlDocPtr doc)\n-{\n-    xmlSchematronParserCtxtPtr ret;\n-\n-    if (doc == NULL)\n-        return (NULL);\n-\n-    ret =\n-        (xmlSchematronParserCtxtPtr)\n-        xmlMalloc(sizeof(xmlSchematronParserCtxt));\n-    if (ret == NULL) {\n-        xmlSchematronPErrMemory(NULL);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchematronParserCtxt));\n-    ret->doc = doc;\n-    ret->dict = xmlDictCreate();\n-    \/* The application has responsibility for the document *\/\n-    ret->preserve = 1;\n-    ret->xctxt = xmlXPathNewContext(doc);\n-    if (ret->xctxt == NULL) {\n-        xmlSchematronPErrMemory(NULL);\n-        xmlSchematronFreeParserCtxt(ret);\n-        return (NULL);\n-    }\n-\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchematronFreeParserCtxt:\n- * @ctxt:  the schema parser context\n- *\n- * Free the resources associated to the schema parser context\n- *\/\n-void\n-xmlSchematronFreeParserCtxt(xmlSchematronParserCtxtPtr ctxt)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    if (ctxt->doc != NULL && !ctxt->preserve)\n-        xmlFreeDoc(ctxt->doc);\n-    if (ctxt->xctxt != NULL) {\n-        xmlXPathFreeContext(ctxt->xctxt);\n-    }\n-    if (ctxt->namespaces != NULL)\n-        xmlFree((char **) ctxt->namespaces);\n-    xmlDictFree(ctxt->dict);\n-    xmlFree(ctxt);\n-}\n-\n-#if 0\n-\/**\n- * xmlSchematronPushInclude:\n- * @ctxt:  the schema parser context\n- * @doc:  the included document\n- * @cur:  the current include node\n- *\n- * Add an included document\n- *\/\n-static void\n-xmlSchematronPushInclude(xmlSchematronParserCtxtPtr ctxt,\n-                        xmlDocPtr doc, xmlNodePtr cur)\n-{\n-    if (ctxt->includes == NULL) {\n-        ctxt->maxIncludes = 10;\n-        ctxt->includes = (xmlNodePtr *)\n-            xmlMalloc(ctxt->maxIncludes * 2 * sizeof(xmlNodePtr));\n-        if (ctxt->includes == NULL) {\n-            xmlSchematronPErrMemory(NULL);\n-            return;\n-        }\n-        ctxt->nbIncludes = 0;\n-    } else if (ctxt->nbIncludes + 2 >= ctxt->maxIncludes) {\n-        xmlNodePtr *tmp;\n-\n-        tmp = (xmlNodePtr *)\n-            xmlRealloc(ctxt->includes, ctxt->maxIncludes * 4 *\n-                       sizeof(xmlNodePtr));\n-        if (tmp == NULL) {\n-            xmlSchematronPErrMemory(NULL);\n-            return;\n-        }\n-        ctxt->includes = tmp;\n-        ctxt->maxIncludes *= 2;\n-    }\n-    ctxt->includes[2 * ctxt->nbIncludes] = cur;\n-    ctxt->includes[2 * ctxt->nbIncludes + 1] = (xmlNodePtr) doc;\n-    ctxt->nbIncludes++;\n-}\n-\n-\/**\n- * xmlSchematronPopInclude:\n- * @ctxt:  the schema parser context\n- *\n- * Pop an include level. The included document is being freed\n- *\n- * Returns the node immediately following the include or NULL if the\n- *         include list was empty.\n- *\/\n-static xmlNodePtr\n-xmlSchematronPopInclude(xmlSchematronParserCtxtPtr ctxt)\n-{\n-    xmlDocPtr doc;\n-    xmlNodePtr ret;\n-\n-    if (ctxt->nbIncludes <= 0)\n-        return(NULL);\n-    ctxt->nbIncludes--;\n-    doc = (xmlDocPtr) ctxt->includes[2 * ctxt->nbIncludes + 1];\n-    ret = ctxt->includes[2 * ctxt->nbIncludes];\n-    xmlFreeDoc(doc);\n-    if (ret != NULL)\n-        ret = ret->next;\n-    if (ret == NULL)\n-        return(xmlSchematronPopInclude(ctxt));\n-    return(ret);\n-}\n-#endif\n-\n-\/**\n- * xmlSchematronAddNamespace:\n- * @ctxt:  the schema parser context\n- * @prefix:  the namespace prefix\n- * @ns:  the namespace name\n- *\n- * Add a namespace definition in the context\n- *\/\n-static void\n-xmlSchematronAddNamespace(xmlSchematronParserCtxtPtr ctxt,\n-                          const xmlChar *prefix, const xmlChar *ns)\n-{\n-    if (ctxt->namespaces == NULL) {\n-        ctxt->maxNamespaces = 10;\n-        ctxt->namespaces = (const xmlChar **)\n-            xmlMalloc(ctxt->maxNamespaces * 2 * sizeof(const xmlChar *));\n-        if (ctxt->namespaces == NULL) {\n-            xmlSchematronPErrMemory(NULL);\n-            return;\n-        }\n-        ctxt->nbNamespaces = 0;\n-    } else if (ctxt->nbNamespaces + 2 >= ctxt->maxNamespaces) {\n-        const xmlChar **tmp;\n-\n-        tmp = (const xmlChar **)\n-            xmlRealloc((xmlChar **) ctxt->namespaces, ctxt->maxNamespaces * 4 *\n-                       sizeof(const xmlChar *));\n-        if (tmp == NULL) {\n-            xmlSchematronPErrMemory(NULL);\n-            return;\n-        }\n-        ctxt->namespaces = tmp;\n-        ctxt->maxNamespaces *= 2;\n-    }\n-    ctxt->namespaces[2 * ctxt->nbNamespaces] =\n-        xmlDictLookup(ctxt->dict, ns, -1);\n-    ctxt->namespaces[2 * ctxt->nbNamespaces + 1] =\n-        xmlDictLookup(ctxt->dict, prefix, -1);\n-    ctxt->nbNamespaces++;\n-    ctxt->namespaces[2 * ctxt->nbNamespaces] = NULL;\n-    ctxt->namespaces[2 * ctxt->nbNamespaces + 1] = NULL;\n-\n-}\n-\n-\/**\n- * xmlSchematronParseTestReportMsg:\n- * @ctxt:  the schema parser context\n- * @con:  the assert or report node\n- *\n- * Format the message content of the assert or report test\n- *\/\n-static void\n-xmlSchematronParseTestReportMsg(xmlSchematronParserCtxtPtr ctxt, xmlNodePtr con)\n-{\n-    xmlNodePtr child;\n-    xmlXPathCompExprPtr comp;\n-\n-    child = con->children;\n-    while (child != NULL) {\n-        if ((child->type == XML_TEXT_NODE) ||\n-            (child->type == XML_CDATA_SECTION_NODE))\n-            \/* Do Nothing *\/\n-            {}\n-        else if (IS_SCHEMATRON(child, \"name\")) {\n-            \/* Do Nothing *\/\n-        } else if (IS_SCHEMATRON(child, \"value-of\")) {\n-            xmlChar *select;\n-\n-            select = xmlGetNoNsProp(child, BAD_CAST \"select\");\n-\n-            if (select == NULL) {\n-                xmlSchematronPErr(ctxt, child,\n-                                  XML_SCHEMAV_ATTRINVALID,\n-                                  \"value-of has no select attribute\",\n-                                  NULL, NULL);\n-            } else {\n-                \/*\n-                 * try first to compile the test expression\n-                 *\/\n-                comp = xmlXPathCtxtCompile(ctxt->xctxt, select);\n-                if (comp == NULL) {\n-                    xmlSchematronPErr(ctxt, child,\n-                                      XML_SCHEMAV_ATTRINVALID,\n-                                      \"Failed to compile select expression %s\",\n-                                      select, NULL);\n-                }\n-                xmlXPathFreeCompExpr(comp);\n-            }\n-            xmlFree(select);\n-        }\n-        child = child->next;\n-        continue;\n-    }\n-}\n-\n-\/**\n- * xmlSchematronParseRule:\n- * @ctxt:  a schema validation context\n- * @rule:  the rule node\n- *\n- * parse a rule element\n- *\/\n-static void\n-xmlSchematronParseRule(xmlSchematronParserCtxtPtr ctxt,\n-                       xmlSchematronPatternPtr pattern,\n-                       xmlNodePtr rule)\n-{\n-    xmlNodePtr cur;\n-    int nbChecks = 0;\n-    xmlChar *test;\n-    xmlChar *context;\n-    xmlChar *report;\n-    xmlChar *name;\n-    xmlChar *value;\n-    xmlSchematronRulePtr ruleptr;\n-    xmlSchematronTestPtr testptr;\n-\n-    if ((ctxt == NULL) || (rule == NULL)) return;\n-\n-    context = xmlGetNoNsProp(rule, BAD_CAST \"context\");\n-    if (context == NULL) {\n-        xmlSchematronPErr(ctxt, rule,\n-            XML_SCHEMAP_NOROOT,\n-            \"rule has no context attribute\",\n-            NULL, NULL);\n-        return;\n-    } else if (context[0] == 0) {\n-        xmlSchematronPErr(ctxt, rule,\n-            XML_SCHEMAP_NOROOT,\n-            \"rule has an empty context attribute\",\n-            NULL, NULL);\n-        xmlFree(context);\n-        return;\n-    } else {\n-        ruleptr = xmlSchematronAddRule(ctxt, ctxt->schema, pattern,\n-                                       rule, context, NULL);\n-        if (ruleptr == NULL) {\n-            xmlFree(context);\n-            return;\n-        }\n-    }\n-\n-    cur = rule->children;\n-    NEXT_SCHEMATRON(cur);\n-    while (cur != NULL) {\n-        if (IS_SCHEMATRON(cur, \"let\")) {\n-            xmlXPathCompExprPtr var_comp;\n-            xmlSchematronLetPtr let;\n-\n-            name = xmlGetNoNsProp(cur, BAD_CAST \"name\");\n-            if (name == NULL) {\n-                xmlSchematronPErr(ctxt, cur,\n-                                  XML_SCHEMAP_NOROOT,\n-                                  \"let has no name attribute\",\n-                                  NULL, NULL);\n-                return;\n-            } else if (name[0] == 0) {\n-                xmlSchematronPErr(ctxt, cur,\n-                                  XML_SCHEMAP_NOROOT,\n-                                  \"let has an empty name attribute\",\n-                                  NULL, NULL);\n-                xmlFree(name);\n-                return;\n-            }\n-            value = xmlGetNoNsProp(cur, BAD_CAST \"value\");\n-            if (value == NULL) {\n-                xmlSchematronPErr(ctxt, cur,\n-                                  XML_SCHEMAP_NOROOT,\n-                                  \"let has no value attribute\",\n-                                  NULL, NULL);\n-                return;\n-            } else if (value[0] == 0) {\n-                xmlSchematronPErr(ctxt, cur,\n-                                  XML_SCHEMAP_NOROOT,\n-                                  \"let has an empty value attribute\",\n-                                  NULL, NULL);\n-                xmlFree(value);\n-                return;\n-            }\n-\n-            var_comp = xmlXPathCtxtCompile(ctxt->xctxt, value);\n-            if (var_comp == NULL) {\n-                xmlSchematronPErr(ctxt, cur,\n-                                  XML_SCHEMAP_NOROOT,\n-                                  \"Failed to compile let expression %s\",\n-                                  value, NULL);\n-                return;\n-            }\n-\n-            let = (xmlSchematronLetPtr) malloc(sizeof(xmlSchematronLet));\n-            let->name = name;\n-            let->comp = var_comp;\n-            let->next = NULL;\n-\n-            \/* add new let variable to the beginning of the list *\/\n-            if (ruleptr->lets != NULL) {\n-                let->next = ruleptr->lets;\n-            }\n-            ruleptr->lets = let;\n-\n-            xmlFree(value);\n-        } else if (IS_SCHEMATRON(cur, \"assert\")) {\n-            nbChecks++;\n-            test = xmlGetNoNsProp(cur, BAD_CAST \"test\");\n-            if (test == NULL) {\n-                xmlSchematronPErr(ctxt, cur,\n-                    XML_SCHEMAP_NOROOT,\n-                    \"assert has no test attribute\",\n-                    NULL, NULL);\n-            } else if (test[0] == 0) {\n-                xmlSchematronPErr(ctxt, cur,\n-                    XML_SCHEMAP_NOROOT,\n-                    \"assert has an empty test attribute\",\n-                    NULL, NULL);\n-                xmlFree(test);\n-            } else {\n-                xmlSchematronParseTestReportMsg(ctxt, cur);\n-                report = xmlNodeGetContent(cur);\n-\n-                testptr = xmlSchematronAddTest(ctxt, XML_SCHEMATRON_ASSERT,\n-                                               ruleptr, cur, test, report);\n-                if (testptr == NULL)\n-                    xmlFree(test);\n-            }\n-        } else if (IS_SCHEMATRON(cur, \"report\")) {\n-            nbChecks++;\n-            test = xmlGetNoNsProp(cur, BAD_CAST \"test\");\n-            if (test == NULL) {\n-                xmlSchematronPErr(ctxt, cur,\n-                    XML_SCHEMAP_NOROOT,\n-                    \"assert has no test attribute\",\n-                    NULL, NULL);\n-            } else if (test[0] == 0) {\n-                xmlSchematronPErr(ctxt, cur,\n-                    XML_SCHEMAP_NOROOT,\n-                    \"assert has an empty test attribute\",\n-                    NULL, NULL);\n-                xmlFree(test);\n-            } else {\n-                xmlSchematronParseTestReportMsg(ctxt, cur);\n-                report = xmlNodeGetContent(cur);\n-\n-                testptr = xmlSchematronAddTest(ctxt, XML_SCHEMATRON_REPORT,\n-                                               ruleptr, cur, test, report);\n-                if (testptr == NULL)\n-                    xmlFree(test);\n-            }\n-        } else {\n-            xmlSchematronPErr(ctxt, cur,\n-                XML_SCHEMAP_NOROOT,\n-                \"Expecting an assert or a report element instead of %s\",\n-                cur->name, NULL);\n-        }\n-        cur = cur->next;\n-        NEXT_SCHEMATRON(cur);\n-    }\n-    if (nbChecks == 0) {\n-        xmlSchematronPErr(ctxt, rule,\n-            XML_SCHEMAP_NOROOT,\n-            \"rule has no assert nor report element\", NULL, NULL);\n-    }\n-}\n-\n-\/**\n- * xmlSchematronParsePattern:\n- * @ctxt:  a schema validation context\n- * @pat:  the pattern node\n- *\n- * parse a pattern element\n- *\/\n-static void\n-xmlSchematronParsePattern(xmlSchematronParserCtxtPtr ctxt, xmlNodePtr pat)\n-{\n-    xmlNodePtr cur;\n-    xmlSchematronPatternPtr pattern;\n-    int nbRules = 0;\n-    xmlChar *id;\n-\n-    if ((ctxt == NULL) || (pat == NULL)) return;\n-\n-    id = xmlGetNoNsProp(pat, BAD_CAST \"id\");\n-    if (id == NULL) {\n-        id = xmlGetNoNsProp(pat, BAD_CAST \"name\");\n-    }\n-    pattern = xmlSchematronAddPattern(ctxt, ctxt->schema, pat, id);\n-    if (pattern == NULL) {\n-        if (id != NULL)\n-            xmlFree(id);\n-        return;\n-    }\n-    cur = pat->children;\n-    NEXT_SCHEMATRON(cur);\n-    while (cur != NULL) {\n-        if (IS_SCHEMATRON(cur, \"rule\")) {\n-            xmlSchematronParseRule(ctxt, pattern, cur);\n-            nbRules++;\n-        } else {\n-            xmlSchematronPErr(ctxt, cur,\n-                XML_SCHEMAP_NOROOT,\n-                \"Expecting a rule element instead of %s\", cur->name, NULL);\n-        }\n-        cur = cur->next;\n-        NEXT_SCHEMATRON(cur);\n-    }\n-    if (nbRules == 0) {\n-        xmlSchematronPErr(ctxt, pat,\n-            XML_SCHEMAP_NOROOT,\n-            \"Pattern has no rule element\", NULL, NULL);\n-    }\n-}\n-\n-#if 0\n-\/**\n- * xmlSchematronLoadInclude:\n- * @ctxt:  a schema validation context\n- * @cur:  the include element\n- *\n- * Load the include document, Push the current pointer\n- *\n- * Returns the updated node pointer\n- *\/\n-static xmlNodePtr\n-xmlSchematronLoadInclude(xmlSchematronParserCtxtPtr ctxt, xmlNodePtr cur)\n-{\n-    xmlNodePtr ret = NULL;\n-    xmlDocPtr doc = NULL;\n-    xmlChar *href = NULL;\n-    xmlChar *base = NULL;\n-    xmlChar *URI = NULL;\n-\n-    if ((ctxt == NULL) || (cur == NULL))\n-        return(NULL);\n-\n-    href = xmlGetNoNsProp(cur, BAD_CAST \"href\");\n-    if (href == NULL) {\n-        xmlSchematronPErr(ctxt, cur,\n-            XML_SCHEMAP_NOROOT,\n-            \"Include has no href attribute\", NULL, NULL);\n-        return(cur->next);\n-    }\n-\n-    \/* do the URI base composition, load and find the root *\/\n-    base = xmlNodeGetBase(cur->doc, cur);\n-    URI = xmlBuildURI(href, base);\n-    doc = xmlReadFile((const char *) URI, NULL, SCHEMATRON_PARSE_OPTIONS);\n-    if (doc == NULL) {\n-        xmlSchematronPErr(ctxt, cur,\n-                      XML_SCHEMAP_FAILED_LOAD,\n-                      \"could not load include '%s'.\\n\",\n-                      URI, NULL);\n-        goto done;\n-    }\n-    ret = xmlDocGetRootElement(doc);\n-    if (ret == NULL) {\n-        xmlSchematronPErr(ctxt, cur,\n-                      XML_SCHEMAP_FAILED_LOAD,\n-                      \"could not find root from include '%s'.\\n\",\n-                      URI, NULL);\n-        goto done;\n-    }\n-\n-    \/* Success, push the include for rollback on exit *\/\n-    xmlSchematronPushInclude(ctxt, doc, cur);\n-\n-done:\n-    if (ret == NULL) {\n-        if (doc != NULL)\n-            xmlFreeDoc(doc);\n-    }\n-    xmlFree(href);\n-    if (base != NULL)\n-        xmlFree(base);\n-    if (URI != NULL)\n-        xmlFree(URI);\n-    return(ret);\n-}\n-#endif\n-\n-\/**\n- * xmlSchematronParse:\n- * @ctxt:  a schema validation context\n- *\n- * parse a schema definition resource and build an internal\n- * XML Schema structure which can be used to validate instances.\n- *\n- * Returns the internal XML Schematron structure built from the resource or\n- *         NULL in case of error\n- *\/\n-xmlSchematronPtr\n-xmlSchematronParse(xmlSchematronParserCtxtPtr ctxt)\n-{\n-    xmlSchematronPtr ret = NULL;\n-    xmlDocPtr doc;\n-    xmlNodePtr root, cur;\n-    int preserve = 0;\n-\n-    if (ctxt == NULL)\n-        return (NULL);\n-\n-    ctxt->nberrors = 0;\n-\n-    \/*\n-     * First step is to parse the input document into an DOM\/Infoset\n-     *\/\n-    if (ctxt->URL != NULL) {\n-        doc = xmlReadFile((const char *) ctxt->URL, NULL,\n-                          SCHEMATRON_PARSE_OPTIONS);\n-        if (doc == NULL) {\n-            xmlSchematronPErr(ctxt, NULL,\n-                          XML_SCHEMAP_FAILED_LOAD,\n-                          \"xmlSchematronParse: could not load '%s'.\\n\",\n-                          ctxt->URL, NULL);\n-            return (NULL);\n-        }\n-        ctxt->preserve = 0;\n-    } else if (ctxt->buffer != NULL) {\n-        doc = xmlReadMemory(ctxt->buffer, ctxt->size, NULL, NULL,\n-                            SCHEMATRON_PARSE_OPTIONS);\n-        if (doc == NULL) {\n-            xmlSchematronPErr(ctxt, NULL,\n-                          XML_SCHEMAP_FAILED_PARSE,\n-                          \"xmlSchematronParse: could not parse.\\n\",\n-                          NULL, NULL);\n-            return (NULL);\n-        }\n-        doc->URL = xmlStrdup(BAD_CAST \"in_memory_buffer\");\n-        ctxt->URL = xmlDictLookup(ctxt->dict, BAD_CAST \"in_memory_buffer\", -1);\n-        ctxt->preserve = 0;\n-    } else if (ctxt->doc != NULL) {\n-        doc = ctxt->doc;\n-        preserve = 1;\n-        ctxt->preserve = 1;\n-    } else {\n-        xmlSchematronPErr(ctxt, NULL,\n-                      XML_SCHEMAP_NOTHING_TO_PARSE,\n-                      \"xmlSchematronParse: could not parse.\\n\",\n-                      NULL, NULL);\n-        return (NULL);\n-    }\n-\n-    \/*\n-     * Then extract the root and Schematron parse it\n-     *\/\n-    root = xmlDocGetRootElement(doc);\n-    if (root == NULL) {\n-        xmlSchematronPErr(ctxt, (xmlNodePtr) doc,\n-                      XML_SCHEMAP_NOROOT,\n-                      \"The schema has no document element.\\n\", NULL, NULL);\n-        if (!preserve) {\n-            xmlFreeDoc(doc);\n-        }\n-        return (NULL);\n-    }\n-\n-    if (!IS_SCHEMATRON(root, \"schema\")) {\n-        xmlSchematronPErr(ctxt, root,\n-            XML_SCHEMAP_NOROOT,\n-            \"The XML document '%s' is not a XML schematron document\",\n-            ctxt->URL, NULL);\n-        goto exit;\n-    }\n-    ret = xmlSchematronNewSchematron(ctxt);\n-    if (ret == NULL)\n-        goto exit;\n-    ctxt->schema = ret;\n-\n-    \/*\n-     * scan the schema elements\n-     *\/\n-    cur = root->children;\n-    NEXT_SCHEMATRON(cur);\n-    if (IS_SCHEMATRON(cur, \"title\")) {\n-        xmlChar *title = xmlNodeGetContent(cur);\n-        if (title != NULL) {\n-            ret->title = xmlDictLookup(ret->dict, title, -1);\n-            xmlFree(title);\n-        }\n-        cur = cur->next;\n-        NEXT_SCHEMATRON(cur);\n-    }\n-    while (IS_SCHEMATRON(cur, \"ns\")) {\n-        xmlChar *prefix = xmlGetNoNsProp(cur, BAD_CAST \"prefix\");\n-        xmlChar *uri = xmlGetNoNsProp(cur, BAD_CAST \"uri\");\n-        if ((uri == NULL) || (uri[0] == 0)) {\n-            xmlSchematronPErr(ctxt, cur,\n-                XML_SCHEMAP_NOROOT,\n-                \"ns element has no uri\", NULL, NULL);\n-        }\n-        if ((prefix == NULL) || (prefix[0] == 0)) {\n-            xmlSchematronPErr(ctxt, cur,\n-                XML_SCHEMAP_NOROOT,\n-                \"ns element has no prefix\", NULL, NULL);\n-        }\n-        if ((prefix) && (uri)) {\n-            xmlXPathRegisterNs(ctxt->xctxt, prefix, uri);\n-            xmlSchematronAddNamespace(ctxt, prefix, uri);\n-            ret->nbNs++;\n-        }\n-        if (uri)\n-            xmlFree(uri);\n-        if (prefix)\n-            xmlFree(prefix);\n-        cur = cur->next;\n-        NEXT_SCHEMATRON(cur);\n-    }\n-    while (cur != NULL) {\n-        if (IS_SCHEMATRON(cur, \"pattern\")) {\n-            xmlSchematronParsePattern(ctxt, cur);\n-            ret->nbPattern++;\n-        } else {\n-            xmlSchematronPErr(ctxt, cur,\n-                XML_SCHEMAP_NOROOT,\n-                \"Expecting a pattern element instead of %s\", cur->name, NULL);\n-        }\n-        cur = cur->next;\n-        NEXT_SCHEMATRON(cur);\n-    }\n-    if (ret->nbPattern == 0) {\n-        xmlSchematronPErr(ctxt, root,\n-            XML_SCHEMAP_NOROOT,\n-            \"The schematron document '%s' has no pattern\",\n-            ctxt->URL, NULL);\n-        goto exit;\n-    }\n-    \/* the original document must be kept for reporting *\/\n-    ret->doc = doc;\n-    if (preserve) {\n-            ret->preserve = 1;\n-    }\n-    preserve = 1;\n-\n-exit:\n-    if (!preserve) {\n-        xmlFreeDoc(doc);\n-    }\n-    if (ret != NULL) {\n-        if (ctxt->nberrors != 0) {\n-            xmlSchematronFree(ret);\n-            ret = NULL;\n-        } else {\n-            ret->namespaces = ctxt->namespaces;\n-            ret->nbNamespaces = ctxt->nbNamespaces;\n-            ctxt->namespaces = NULL;\n-        }\n-    }\n-    return (ret);\n-}\n-\n-\/************************************************************************\n- *                                                                      *\n- *              Schematrontron Reports handler                          *\n- *                                                                      *\n- ************************************************************************\/\n-\n-static xmlNodePtr\n-xmlSchematronGetNode(xmlSchematronValidCtxtPtr ctxt,\n-                     xmlNodePtr cur, const xmlChar *xpath) {\n-    xmlNodePtr node = NULL;\n-    xmlXPathObjectPtr ret;\n-\n-    if ((ctxt == NULL) || (cur == NULL) || (xpath == NULL))\n-        return(NULL);\n-\n-    ctxt->xctxt->doc = cur->doc;\n-    ctxt->xctxt->node = cur;\n-    ret = xmlXPathEval(xpath, ctxt->xctxt);\n-    if (ret == NULL)\n-        return(NULL);\n-\n-    if ((ret->type == XPATH_NODESET) &&\n-        (ret->nodesetval != NULL) && (ret->nodesetval->nodeNr > 0))\n-        node = ret->nodesetval->nodeTab[0];\n-\n-    xmlXPathFreeObject(ret);\n-    return(node);\n-}\n-\n-\/**\n- * xmlSchematronReportOutput:\n- * @ctxt: the validation context\n- * @cur: the current node tested\n- * @msg: the message output\n- *\n- * Output part of the report to whatever channel the user selected\n- *\/\n-static void\n-xmlSchematronReportOutput(xmlSchematronValidCtxtPtr ctxt ATTRIBUTE_UNUSED,\n-                          xmlNodePtr cur ATTRIBUTE_UNUSED,\n-                          const char *msg) {\n-    \/* TODO *\/\n-    fprintf(stderr, \"%s\", msg);\n-}\n-\n-\/**\n- * xmlSchematronFormatReport:\n- * @ctxt:  the validation context\n- * @test: the test node\n- * @cur: the current node tested\n- *\n- * Build the string being reported to the user.\n- *\n- * Returns a report string or NULL in case of error. The string needs\n- *         to be deallocated by the caller\n- *\/\n-static xmlChar *\n-xmlSchematronFormatReport(xmlSchematronValidCtxtPtr ctxt,\n-                          xmlNodePtr test, xmlNodePtr cur) {\n-    xmlChar *ret = NULL;\n-    xmlNodePtr child, node;\n-    xmlXPathCompExprPtr comp;\n-\n-    if ((test == NULL) || (cur == NULL))\n-        return(ret);\n-\n-    child = test->children;\n-    while (child != NULL) {\n-        if ((child->type == XML_TEXT_NODE) ||\n-            (child->type == XML_CDATA_SECTION_NODE))\n-            ret = xmlStrcat(ret, child->content);\n-        else if (IS_SCHEMATRON(child, \"name\")) {\n-            xmlChar *path;\n-\n-            path = xmlGetNoNsProp(child, BAD_CAST \"path\");\n-\n-            node = cur;\n-            if (path != NULL) {\n-                node = xmlSchematronGetNode(ctxt, cur, path);\n-                if (node == NULL)\n-                    node = cur;\n-                xmlFree(path);\n-            }\n-\n-            if ((node->ns == NULL) || (node->ns->prefix == NULL))\n-                ret = xmlStrcat(ret, node->name);\n-            else {\n-                ret = xmlStrcat(ret, node->ns->prefix);\n-                ret = xmlStrcat(ret, BAD_CAST \":\");\n-                ret = xmlStrcat(ret, node->name);\n-            }\n-        } else if (IS_SCHEMATRON(child, \"value-of\")) {\n-            xmlChar *select;\n-            xmlXPathObjectPtr eval;\n-\n-            select = xmlGetNoNsProp(child, BAD_CAST \"select\");\n-            comp = xmlXPathCtxtCompile(ctxt->xctxt, select);\n-            eval = xmlXPathCompiledEval(comp, ctxt->xctxt);\n-\n-            switch (eval->type) {\n-            case XPATH_NODESET: {\n-                int indx;\n-                xmlChar *spacer = BAD_CAST \" \";\n-\n-                if (eval->nodesetval) {\n-                    for (indx = 0; indx < eval->nodesetval->nodeNr; indx++) {\n-                        if (indx > 0)\n-                            ret = xmlStrcat(ret, spacer);\n-                        ret = xmlStrcat(ret, eval->nodesetval->nodeTab[indx]->name);\n-                    }\n-                }\n-                break;\n-            }\n-            case XPATH_BOOLEAN: {\n-                const char *str = eval->boolval ? \"True\" : \"False\";\n-                ret = xmlStrcat(ret, BAD_CAST str);\n-                break;\n-            }\n-            case XPATH_NUMBER: {\n-                xmlChar *buf;\n-                int size;\n-\n-                size = snprintf(NULL, 0, \"%0g\", eval->floatval);\n-                buf = (xmlChar *) xmlMalloc(size + 1);\n-                if (buf != NULL) {\n-                    snprintf((char *) buf, size + 1, \"%0g\", eval->floatval);\n-                    ret = xmlStrcat(ret, buf);\n-                    xmlFree(buf);\n-                }\n-                break;\n-            }\n-            case XPATH_STRING:\n-                ret = xmlStrcat(ret, eval->stringval);\n-                break;\n-            default:\n-                xmlSchematronVErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                                  \"Unsupported XPATH Type\\n\", NULL);\n-            }\n-            xmlXPathFreeObject(eval);\n-            xmlXPathFreeCompExpr(comp);\n-            xmlFree(select);\n-        } else {\n-            child = child->next;\n-            continue;\n-        }\n-\n-        \/*\n-         * remove superfluous \\n\n-         *\/\n-        if (ret != NULL) {\n-            int len = xmlStrlen(ret);\n-            xmlChar c;\n-\n-            if (len > 0) {\n-                c = ret[len - 1];\n-                if ((c == ' ') || (c == '\\n') || (c == '\\r') || (c == '\\t')) {\n-                    while ((c == ' ') || (c == '\\n') ||\n-                           (c == '\\r') || (c == '\\t')) {\n-                        len--;\n-                        if (len == 0)\n-                            break;\n-                        c = ret[len - 1];\n-                    }\n-                    ret[len] = ' ';\n-                    ret[len + 1] = 0;\n-                }\n-            }\n-        }\n-\n-        child = child->next;\n-    }\n-    return(ret);\n-}\n-\n-\/**\n- * xmlSchematronReportSuccess:\n- * @ctxt:  the validation context\n- * @test: the compiled test\n- * @cur: the current node tested\n- * @success: boolean value for the result\n- *\n- * called from the validation engine when an assert or report test have\n- * been done.\n- *\/\n-static void\n-xmlSchematronReportSuccess(xmlSchematronValidCtxtPtr ctxt,\n-                   xmlSchematronTestPtr test, xmlNodePtr cur, xmlSchematronPatternPtr pattern, int success) {\n-    if ((ctxt == NULL) || (cur == NULL) || (test == NULL))\n-        return;\n-    \/* if quiet and not SVRL report only failures *\/\n-    if ((ctxt->flags & XML_SCHEMATRON_OUT_QUIET) &&\n-        ((ctxt->flags & XML_SCHEMATRON_OUT_XML) == 0) &&\n-        (test->type == XML_SCHEMATRON_REPORT))\n-        return;\n-    if (ctxt->flags & XML_SCHEMATRON_OUT_XML) {\n-        \/* TODO *\/\n-    } else {\n-        xmlChar *path;\n-        char msg[1000];\n-        long line;\n-        const xmlChar *report = NULL;\n-\n-        if (((test->type == XML_SCHEMATRON_REPORT) && (!success)) ||\n-            ((test->type == XML_SCHEMATRON_ASSERT) && (success)))\n-            return;\n-        line = xmlGetLineNo(cur);\n-        path = xmlGetNodePath(cur);\n-        if (path == NULL)\n-            path = (xmlChar *) cur->name;\n-#if 0\n-        if ((test->report != NULL) && (test->report[0] != 0))\n-            report = test->report;\n-#endif\n-        if (test->node != NULL)\n-            report = xmlSchematronFormatReport(ctxt, test->node, cur);\n-        if (report == NULL) {\n-            if (test->type == XML_SCHEMATRON_ASSERT) {\n-            report = xmlStrdup((const xmlChar *) \"node failed assert\");\n-            } else {\n-            report = xmlStrdup((const xmlChar *) \"node failed report\");\n-            }\n-            }\n-            snprintf(msg, 999, \"%s line %ld: %s\\n\", (const char *) path,\n-                     line, (const char *) report);\n-\n-    if (ctxt->flags & XML_SCHEMATRON_OUT_ERROR) {\n-        xmlStructuredErrorFunc schannel;\n-        xmlGenericErrorFunc channel;\n-        void *data;\n-        int res;\n-\n-        schannel = ctxt->serror;\n-        channel = ctxt->error;\n-        data = ctxt->userData;\n-\n-        if ((channel == NULL) && (schannel == NULL)) {\n-            channel = xmlGenericError;\n-            data = xmlGenericErrorContext;\n-        }\n-\n-        res = __xmlRaiseError(schannel, channel, data, NULL, cur,\n-                              XML_FROM_SCHEMATRONV,\n-                              (test->type == XML_SCHEMATRON_ASSERT) ?\n-                                  XML_SCHEMATRONV_ASSERT :\n-                                  XML_SCHEMATRONV_REPORT,\n-                              XML_ERR_ERROR, NULL, line,\n-                              (pattern == NULL) ?\n-                                  NULL :\n-                                  (const char *) pattern->name,\n-                              (const char *) path, (const char *) report, 0, 0,\n-                              \"%s\", msg);\n-        if (res < 0)\n-            xmlSchematronVErrMemory(ctxt);\n-    } else {\n-        xmlSchematronReportOutput(ctxt, cur, &msg[0]);\n-    }\n-\n-    xmlFree((char *) report);\n-\n-        if ((path != NULL) && (path != (xmlChar *) cur->name))\n-            xmlFree(path);\n-    }\n-}\n-\n-\/**\n- * xmlSchematronReportPattern:\n- * @ctxt:  the validation context\n- * @pattern: the current pattern\n- *\n- * called from the validation engine when starting to check a pattern\n- *\/\n-static void\n-xmlSchematronReportPattern(xmlSchematronValidCtxtPtr ctxt,\n-                           xmlSchematronPatternPtr pattern) {\n-    if ((ctxt == NULL) || (pattern == NULL))\n-        return;\n-    if ((ctxt->flags & XML_SCHEMATRON_OUT_QUIET) || (ctxt->flags & XML_SCHEMATRON_OUT_ERROR)) \/* Error gives pattern name as part of error *\/\n-        return;\n-    if (ctxt->flags & XML_SCHEMATRON_OUT_XML) {\n-        \/* TODO *\/\n-    } else {\n-        char msg[1000];\n-\n-        if (pattern->name == NULL)\n-            return;\n-        snprintf(msg, 999, \"Pattern: %s\\n\", (const char *) pattern->name);\n-        xmlSchematronReportOutput(ctxt, NULL, &msg[0]);\n-    }\n-}\n-\n-\n-\/************************************************************************\n- *                                                                      *\n- *              Validation against a Schematrontron                             *\n- *                                                                      *\n- ************************************************************************\/\n-\n-\/**\n- * xmlSchematronSetValidStructuredErrors:\n- * @ctxt:  a Schematron validation context\n- * @serror:  the structured error function\n- * @ctx: the functions context\n- *\n- * Set the structured error callback\n- *\/\n-void\n-xmlSchematronSetValidStructuredErrors(xmlSchematronValidCtxtPtr ctxt,\n-                                      xmlStructuredErrorFunc serror, void *ctx)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    ctxt->serror = serror;\n-    ctxt->error = NULL;\n-    ctxt->warning = NULL;\n-    ctxt->userData = ctx;\n-}\n-\n-\/**\n- * xmlSchematronNewValidCtxt:\n- * @schema:  a precompiled XML Schematrons\n- * @options: a set of xmlSchematronValidOptions\n- *\n- * Create an XML Schematrons validation context based on the given schema.\n- *\n- * Returns the validation context or NULL in case of error\n- *\/\n-xmlSchematronValidCtxtPtr\n-xmlSchematronNewValidCtxt(xmlSchematronPtr schema, int options)\n-{\n-    int i;\n-    xmlSchematronValidCtxtPtr ret;\n-\n-    ret = (xmlSchematronValidCtxtPtr) xmlMalloc(sizeof(xmlSchematronValidCtxt));\n-    if (ret == NULL) {\n-        xmlSchematronVErrMemory(NULL);\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlSchematronValidCtxt));\n-    ret->type = XML_STRON_CTXT_VALIDATOR;\n-    ret->schema = schema;\n-    ret->xctxt = xmlXPathNewContext(NULL);\n-    ret->flags = options;\n-    if (ret->xctxt == NULL) {\n-        xmlSchematronPErrMemory(NULL);\n-        xmlSchematronFreeValidCtxt(ret);\n-        return (NULL);\n-    }\n-    for (i = 0;i < schema->nbNamespaces;i++) {\n-        if ((schema->namespaces[2 * i] == NULL) ||\n-            (schema->namespaces[2 * i + 1] == NULL))\n-            break;\n-        xmlXPathRegisterNs(ret->xctxt, schema->namespaces[2 * i + 1],\n-                           schema->namespaces[2 * i]);\n-    }\n-    return (ret);\n-}\n-\n-\/**\n- * xmlSchematronFreeValidCtxt:\n- * @ctxt:  the schema validation context\n- *\n- * Free the resources associated to the schema validation context\n- *\/\n-void\n-xmlSchematronFreeValidCtxt(xmlSchematronValidCtxtPtr ctxt)\n-{\n-    if (ctxt == NULL)\n-        return;\n-    if (ctxt->xctxt != NULL)\n-        xmlXPathFreeContext(ctxt->xctxt);\n-    if (ctxt->dict != NULL)\n-        xmlDictFree(ctxt->dict);\n-    xmlFree(ctxt);\n-}\n-\n-static xmlNodePtr\n-xmlSchematronNextNode(xmlNodePtr cur) {\n-    if (cur->children != NULL) {\n-        \/*\n-         * Do not descend on entities declarations\n-         *\/\n-        if (cur->children->type != XML_ENTITY_DECL) {\n-            cur = cur->children;\n-            \/*\n-             * Skip DTDs\n-             *\/\n-            if (cur->type != XML_DTD_NODE)\n-                return(cur);\n-        }\n-    }\n-\n-    while (cur->next != NULL) {\n-        cur = cur->next;\n-        if ((cur->type != XML_ENTITY_DECL) &&\n-            (cur->type != XML_DTD_NODE))\n-            return(cur);\n-    }\n-\n-    do {\n-        cur = cur->parent;\n-        if (cur == NULL) break;\n-        if (cur->type == XML_DOCUMENT_NODE) return(NULL);\n-        if (cur->next != NULL) {\n-            cur = cur->next;\n-            return(cur);\n-        }\n-    } while (cur != NULL);\n-    return(cur);\n-}\n-\n-\/**\n- * xmlSchematronRunTest:\n- * @ctxt:  the schema validation context\n- * @test:  the current test\n- * @instance:  the document instance tree\n- * @cur:  the current node in the instance\n- *\n- * Validate a rule against a tree instance at a given position\n- *\n- * Returns 1 in case of success, 0 if error and -1 in case of internal error\n- *\/\n-static int\n-xmlSchematronRunTest(xmlSchematronValidCtxtPtr ctxt,\n-     xmlSchematronTestPtr test, xmlDocPtr instance, xmlNodePtr cur, xmlSchematronPatternPtr pattern)\n-{\n-    xmlXPathObjectPtr ret;\n-    int failed;\n-\n-    failed = 0;\n-    ctxt->xctxt->doc = instance;\n-    ctxt->xctxt->node = cur;\n-    ret = xmlXPathCompiledEval(test->comp, ctxt->xctxt);\n-    if (ret == NULL) {\n-        failed = 1;\n-    } else {\n-        switch (ret->type) {\n-            case XPATH_XSLT_TREE:\n-            case XPATH_NODESET:\n-                if ((ret->nodesetval == NULL) ||\n-                    (ret->nodesetval->nodeNr == 0))\n-                    failed = 1;\n-                break;\n-            case XPATH_BOOLEAN:\n-                failed = !ret->boolval;\n-                break;\n-            case XPATH_NUMBER:\n-                if ((xmlXPathIsNaN(ret->floatval)) ||\n-                    (ret->floatval == 0.0))\n-                    failed = 1;\n-                break;\n-            case XPATH_STRING:\n-                if ((ret->stringval == NULL) ||\n-                    (ret->stringval[0] == 0))\n-                    failed = 1;\n-                break;\n-            case XPATH_UNDEFINED:\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-            case XPATH_POINT:\n-            case XPATH_RANGE:\n-            case XPATH_LOCATIONSET:\n-#endif\n-            case XPATH_USERS:\n-                failed = 1;\n-                break;\n-        }\n-        xmlXPathFreeObject(ret);\n-    }\n-    if ((failed) && (test->type == XML_SCHEMATRON_ASSERT))\n-        ctxt->nberrors++;\n-    else if ((!failed) && (test->type == XML_SCHEMATRON_REPORT))\n-        ctxt->nberrors++;\n-\n-    xmlSchematronReportSuccess(ctxt, test, cur, pattern, !failed);\n-\n-    return(!failed);\n-}\n-\n-\/**\n- * xmlSchematronRegisterVariables:\n- * @ctxt:  the schema validation context\n- * @let:  the list of let variables\n- * @instance:  the document instance tree\n- * @cur:  the current node\n- *\n- * Registers a list of let variables to the current context of @cur\n- *\n- * Returns -1 in case of errors, otherwise 0\n- *\/\n-static int\n-xmlSchematronRegisterVariables(xmlSchematronValidCtxtPtr vctxt,\n-                               xmlXPathContextPtr ctxt,\n-                               xmlSchematronLetPtr let,\n-                               xmlDocPtr instance, xmlNodePtr cur)\n-{\n-    xmlXPathObjectPtr let_eval;\n-\n-    ctxt->doc = instance;\n-    ctxt->node = cur;\n-    while (let != NULL) {\n-        let_eval = xmlXPathCompiledEval(let->comp, ctxt);\n-        if (let_eval == NULL) {\n-            xmlSchematronVErr(vctxt, XML_ERR_INTERNAL_ERROR,\n-                              \"Evaluation of compiled expression failed\\n\",\n-                              NULL);\n-            return -1;\n-        }\n-        if(xmlXPathRegisterVariableNS(ctxt, let->name, NULL, let_eval)) {\n-            xmlSchematronVErr(vctxt, XML_ERR_INTERNAL_ERROR,\n-                              \"Registering a let variable failed\\n\", NULL);\n-            return -1;\n-        }\n-        let = let->next;\n-    }\n-    return 0;\n-}\n-\n-\/**\n- * xmlSchematronUnregisterVariables:\n- * @ctxt:  the schema validation context\n- * @let:  the list of let variables\n- *\n- * Unregisters a list of let variables from the context\n- *\n- * Returns -1 in case of errors, otherwise 0\n- *\/\n-static int\n-xmlSchematronUnregisterVariables(xmlSchematronValidCtxtPtr vctxt,\n-                                 xmlXPathContextPtr ctxt,\n-                                 xmlSchematronLetPtr let)\n-{\n-    while (let != NULL) {\n-        if (xmlXPathRegisterVariableNS(ctxt, let->name, NULL, NULL)) {\n-            xmlSchematronVErr(vctxt, XML_ERR_INTERNAL_ERROR,\n-                              \"Unregistering a let variable failed\\n\", NULL);\n-            return -1;\n-        }\n-        let = let->next;\n-    }\n-    return 0;\n-}\n-\n-\/**\n- * xmlSchematronValidateDoc:\n- * @ctxt:  the schema validation context\n- * @instance:  the document instance tree\n- *\n- * Validate a tree instance against the schematron\n- *\n- * Returns 0 in case of success, -1 in case of internal error\n- *         and an error count otherwise.\n- *\/\n-int\n-xmlSchematronValidateDoc(xmlSchematronValidCtxtPtr ctxt, xmlDocPtr instance)\n-{\n-    xmlNodePtr cur, root;\n-    xmlSchematronPatternPtr pattern;\n-    xmlSchematronRulePtr rule;\n-    xmlSchematronTestPtr test;\n-\n-    if ((ctxt == NULL) || (ctxt->schema == NULL) ||\n-        (ctxt->schema->rules == NULL) || (instance == NULL))\n-        return(-1);\n-    ctxt->nberrors = 0;\n-    root = xmlDocGetRootElement(instance);\n-    if (root == NULL) {\n-        \/* TODO *\/\n-        ctxt->nberrors++;\n-        return(1);\n-    }\n-    if ((ctxt->flags & XML_SCHEMATRON_OUT_QUIET) ||\n-        (ctxt->flags == 0)) {\n-        \/*\n-         * we are just trying to assert the validity of the document,\n-         * speed primes over the output, run in a single pass\n-         *\/\n-        cur = root;\n-        while (cur != NULL) {\n-            rule = ctxt->schema->rules;\n-            while (rule != NULL) {\n-                if (xmlPatternMatch(rule->pattern, cur) == 1) {\n-                    test = rule->tests;\n-\n-                    if (xmlSchematronRegisterVariables(ctxt, ctxt->xctxt,\n-                                rule->lets, instance, cur))\n-                        return -1;\n-\n-                    while (test != NULL) {\n-                        xmlSchematronRunTest(ctxt, test, instance, cur, (xmlSchematronPatternPtr)rule->pattern);\n-                        test = test->next;\n-                    }\n-\n-                    if (xmlSchematronUnregisterVariables(ctxt, ctxt->xctxt,\n-                                rule->lets))\n-                        return -1;\n-\n-                }\n-                rule = rule->next;\n-            }\n-\n-            cur = xmlSchematronNextNode(cur);\n-        }\n-    } else {\n-        \/*\n-         * Process all contexts one at a time\n-         *\/\n-        pattern = ctxt->schema->patterns;\n-\n-        while (pattern != NULL) {\n-            xmlSchematronReportPattern(ctxt, pattern);\n-\n-            \/*\n-             * TODO convert the pattern rule to a direct XPath and\n-             * compute directly instead of using the pattern matching\n-             * over the full document...\n-             * Check the exact semantic\n-             *\/\n-            cur = root;\n-            while (cur != NULL) {\n-                rule = pattern->rules;\n-                while (rule != NULL) {\n-                    if (xmlPatternMatch(rule->pattern, cur) == 1) {\n-                        test = rule->tests;\n-                        xmlSchematronRegisterVariables(ctxt, ctxt->xctxt,\n-                                rule->lets, instance, cur);\n-\n-                        while (test != NULL) {\n-                            xmlSchematronRunTest(ctxt, test, instance, cur, pattern);\n-                            test = test->next;\n-                        }\n-\n-                        xmlSchematronUnregisterVariables(ctxt, ctxt->xctxt,\n-                                rule->lets);\n-                    }\n-                    rule = rule->patnext;\n-                }\n-\n-                cur = xmlSchematronNextNode(cur);\n-            }\n-            pattern = pattern->next;\n-        }\n-    }\n-    return(ctxt->nberrors);\n-}\n-\n-#ifdef STANDALONE\n-int\n-main(void)\n-{\n-    int ret;\n-    xmlDocPtr instance;\n-    xmlSchematronParserCtxtPtr pctxt;\n-    xmlSchematronValidCtxtPtr vctxt;\n-    xmlSchematronPtr schema = NULL;\n-\n-    pctxt = xmlSchematronNewParserCtxt(\"tst.sct\");\n-    if (pctxt == NULL) {\n-        fprintf(stderr, \"failed to build schematron parser\\n\");\n-    } else {\n-        schema = xmlSchematronParse(pctxt);\n-        if (schema == NULL) {\n-            fprintf(stderr, \"failed to compile schematron\\n\");\n-        }\n-        xmlSchematronFreeParserCtxt(pctxt);\n-    }\n-    instance = xmlReadFile(\"tst.sct\", NULL,\n-                           XML_PARSE_NOENT | XML_PARSE_NOCDATA);\n-    if (instance == NULL) {\n-        fprintf(stderr, \"failed to parse instance\\n\");\n-    }\n-    if ((schema != NULL) && (instance != NULL)) {\n-        vctxt = xmlSchematronNewValidCtxt(schema);\n-        if (vctxt == NULL) {\n-            fprintf(stderr, \"failed to build schematron validator\\n\");\n-        } else {\n-            ret = xmlSchematronValidateDoc(vctxt, instance);\n-            xmlSchematronFreeValidCtxt(vctxt);\n-        }\n-    }\n-    xmlSchematronFree(schema);\n-    xmlFreeDoc(instance);\n-\n-    xmlCleanupParser();\n-\n-    return (0);\n-}\n-#endif\n-\n-#endif \/* LIBXML_SCHEMATRON_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/schematron.c","additions":0,"deletions":2098,"binary":false,"changes":2098,"status":"deleted"},{"patch":"@@ -23327,1 +23327,1 @@\n-\t\tif (bind->nbNodes) {\n+        if (bind->nbNodes) {\n@@ -23378,1 +23378,1 @@\n-\t\t    } while (j < bind->nbNodes);\n+            } while (j < bind->nbNodes);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlschemas.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}